/*
 * $Id: 6c20869e5bc41dc3893f0ae600f5b1c21e3e4764 $
 * 
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_L3_H__
#define __BCM_L3_H__

#if defined(INCLUDE_L3)

#include <bcm/types.h>
#include <bcm/stat.h>

/* L3 module flags. */
#define BCM_L3_L2ONLY               (1 << 0)   /* L2 switch only on interface. */
#define BCM_L3_UNTAG                (1 << 1)   /* Packet goes out untagged. */
#define BCM_L3_S_HIT                (1 << 2)   /* Source IP address match. */
#define BCM_L3_D_HIT                (1 << 3)   /* Destination IP address match. */
#define BCM_L3_HIT                  (BCM_L3_S_HIT | BCM_L3_D_HIT) 
#define BCM_L3_HIT_CLEAR            (1 << 4)   /* Clear HIT bit. */
#define BCM_L3_ADD_TO_ARL           (1 << 5)   /* Add interface address MAC to
                                                  ARL. */
#define BCM_L3_WITH_ID              (1 << 6)   /* ID is provided. */
#define BCM_L3_NEGATE               (1 << 7)   /* Negate a set. */
#define BCM_L3_INGRESS_ONLY         BCM_L3_NEGATE /* configure ingress objects
                                                  only. */
#define BCM_L3_REPLACE              (1 << 8)   /* Replace existing entry. */
#define BCM_L3_TGID                 (1 << 9)   /* Port belongs to trunk. */
#define BCM_L3_OVERLAY_ENCAP        BCM_L3_TGID /* LL encapsulation, used for
                                                  overlay LL for intra DC routed
                                                  packets */
#define BCM_L3_RPE                  (1 << 10)  /* Pick up new priority (COS). */
#define BCM_L3_IPMC                 (1 << 11)  /* Set IPMC for real IPMC entry. */
#define BCM_L3_L2TOCPU              (1 << 12)  /* Packet to CPU unrouted, XGS12:
                                                  Set IPMC for UC address. */
#define BCM_L3_NATIVE_ENCAP         BCM_L3_L2TOCPU /* Eth encapsulation, used for
                                                  nativ Ethernet for intra DC
                                                  routed packets */
#define BCM_L3_DEFIP_CPU            (1 << 13)  /* Strata: DEFIP CPU bit set. */
#define BCM_L3_DEFIP_LOCAL          BCM_L3_DEFIP_CPU /* XGS: Local DEFIP route. */
#define BCM_L3_VIRTUAL_OBJECT       (1 << 13)  /* FEC/egress-encap (virtual
                                                  FEC). */
#define BCM_L3_EGRESS_ONLY          BCM_L3_VIRTUAL_OBJECT /*  Configure Egress objects
                                                  only. */
#define BCM_L3_MULTIPATH            (1 << 14)  /* Specify ECMP treatment. */
#define BCM_L3_HOST_LOCAL           (1 << 15)  /* Packet to local IP stack. */
#define BCM_L3_HOST_AS_ROUTE        (1 << 16)  /* Use LPM if host table full. */
#define BCM_L3_IP6                  (1 << 17)  /* IPv6. */
#define BCM_L3_RPF                  (1 << 18)  /* RPF check. */
#define BCM_L3_SRC_DISCARD          (1 << 19)  /* Source Match Discard. */
#define BCM_L3_DST_DISCARD          (1 << 20)  /* Destination match discard. */
#define BCM_L3_SECONDARY            (1 << 21)  /* Secondary L3 interface. */
#define BCM_L3_ROUTE_LABEL          (1 << 22)  /* Indicates that MPLS label in
                                                  route entry is valid. */
#define BCM_L3_COPY_TO_CPU          (1 << 23)  /* Send a copy to CPU. */
#define BCM_L3_KEEP_SRCMAC          (1 << 24)  /* Disable SA replacement for
                                                  L3UC packets. */
#define BCM_L3_KEEP_DSTMAC          (1 << 25)  /* Disable DA replacement for
                                                  L3UC packets. */
#define BCM_L3_KEEP_VLAN            (1 << 26)  /* Disable VLAN replacement for
                                                  L3UC packets. */
#define BCM_L3_KEEP_TTL             (1 << 27)  /* Disable TTL replacement for
                                                  L3UC packets. */
#define BCM_L3_TRILL_ONLY           (1 << 28)  /* Specific for TRILL Nexthop */
#define BCM_L3_L2GRE_ONLY           (1 << 29)  /* Specific for L2GRE Nexthop */
#define BCM_L3_QUEUE_MAP            (1 << 30)  /* Use queue map to derive queue
                                                  number */
#define BCM_L3_DEREFERENCED_NEXTHOP (1 << 30)  /* Indicates this is a wider L3
                                                  entry. */
#define BCM_L3_ECMP_RH_REPLACE      BCM_L3_DEREFERENCED_NEXTHOP /* Replace ECMP member without RH
                                                  flowset table shuffle. */
#define BCM_L3_VXLAN_ONLY           (1 << 31)  /* Specific for VXLAN Nexthop */

/* L3 module Multicast flags. */
#define BCM_L3_MULTICAST_L2_DEST_PRESERVE   (1 << 0)   /* L2 multicast dest
                                                          address replacement
                                                          disable */
#define BCM_L3_MULTICAST_L2_SRC_PRESERVE    (1 << 1)   /* L2 multicast source
                                                          address replacement
                                                          disable */
#define BCM_L3_MULTICAST_L2_VLAN_PRESERVE   (1 << 2)   /* L2 multicast outer
                                                          vlan replacement
                                                          disable */
#define BCM_L3_MULTICAST_TTL_PRESERVE       (1 << 3)   /* L3 multicast TTL
                                                          decrement disable */
#define BCM_L3_MULTICAST_DEST_PRESERVE      (1 << 4)   /* L3 multicast dest
                                                          address replacement
                                                          disable */
#define BCM_L3_MULTICAST_SRC_PRESERVE       (1 << 5)   /* L3 multicast source
                                                          address replacement
                                                          disable */
#define BCM_L3_MULTICAST_VLAN_PRESERVE      (1 << 6)   /* L3 multicast outer
                                                          vlan replacement
                                                          disable */
#define BCM_L3_MULTICAST_L3_DROP            (1 << 7)   /* L3 multicast L3 drop */
#define BCM_L3_MULTICAST_L2_DROP            (1 << 8)   /* L3 multicast L2 drop */

/* L3 Ingress Interface flags. */
#define BCM_L3_INGRESS_WITH_ID              (1 << 0)   /* L3 Ingress ID is
                                                          provided. */
#define BCM_L3_INGRESS_REPLACE              (1 << 1)   /* Replace existing L3
                                                          Ingress entry. */
#define BCM_L3_INGRESS_GLOBAL_ROUTE         (1 << 2)   /* Allow Global Route on
                                                          L3 Ingress Interface. */
#define BCM_L3_INGRESS_DSCP_TRUST           (1 << 3)   /* Trust incoming DSCP on
                                                          L3 Ingress */
#define BCM_L3_INGRESS_URPF_DEFAULT_ROUTE_CHECK (1 << 4)   /* Allow URPF Check on
                                                          Default Routes. */
#define BCM_L3_INGRESS_ROUTE_DISABLE_IP4_UCAST (1 << 5)   /* Disable L3 routing on
                                                          IPv4 UC packets */
#define BCM_L3_INGRESS_ROUTE_DISABLE_IP4_MCAST (1 << 6)   /* Disable L3 routing on
                                                          IPv4 MC packets */
#define BCM_L3_INGRESS_ROUTE_DISABLE_IP6_UCAST (1 << 7)   /* Disable L3 routing on
                                                          IPv6 UC packets */
#define BCM_L3_INGRESS_ROUTE_DISABLE_IP6_MCAST (1 << 8)   /* Disable L3 routing on
                                                          IPv6 MC packets */
#define BCM_L3_INGRESS_ROUTE_DISABLE_MPLS   (1 << 9)   /* Disable L3 routing on
                                                          MPLS packets */
#define BCM_L3_INGRESS_IPMC_DO_VLAN_DISABLE (1 << 10)  /* Disable using L3
                                                          interface as part of
                                                          IPMC forwarding lookup
                                                          key */
#define BCM_L3_INGRESS_IPV6_ROUTING_HEADER_TYPE_0_DROP (1 << 11)  /* Drop Ipv6 Header Type
                                                          0 packets */
#define BCM_L3_INGRESS_UNKNOWN_SRC_TOCPU    (1 << 12)  /* Unresolved source for
                                                          L3 send to CPU */
#define BCM_L3_INGRESS_UNKNOWN_IP4_MCAST_TOCPU (1 << 13)  /* Unknown IPMC (IPMC
                                                          miss) for IPv4 packets
                                                          sent to CPU */
#define BCM_L3_INGRESS_UNKNOWN_IP6_MCAST_TOCPU (1 << 14)  /* Unknown IPMC (IPMC
                                                          miss) for IPv6 packets
                                                          sent to CPU */
#define BCM_L3_INGRESS_ICMP_REDIRECT_TOCPU  (1 << 15)  /* Enables copy to cpu
                                                          when ICMP redirect
                                                          packet is needed */

/* L3 Interface QOS flags. */
#define BCM_L3_INTF_QOS_OUTER_VLAN_PRI_COPY (1 << 0)   /* Copy Outer Vlan .1p
                                                          from incoming packet
                                                          .1p. */
#define BCM_L3_INTF_QOS_OUTER_VLAN_PRI_SET  (1 << 1)   /* Set Outer Vlan .1p
                                                          from table entry. */
#define BCM_L3_INTF_QOS_OUTER_VLAN_PRI_REMARK (1 << 2)   /* Remark Outer Vlan .1p
                                                          from PHB. */
#define BCM_L3_INTF_QOS_INNER_VLAN_PRI_COPY (1 << 3)   /* Copy Inner Vlan .1p
                                                          from incoming packet
                                                          .1p. */
#define BCM_L3_INTF_QOS_INNER_VLAN_PRI_SET  (1 << 4)   /* Set Inner Vlan .1p
                                                          from table entry. */
#define BCM_L3_INTF_QOS_INNER_VLAN_PRI_REMARK (1 << 5)   /* Remark Outer Vlan .1p
                                                          from PHB. */
#define BCM_L3_INTF_QOS_DSCP_COPY           (1 << 6)   /* Use existing DSCP */
#define BCM_L3_INTF_QOS_DSCP_SET            (1 << 7)   /* Set DSCP from table
                                                          entry. */
#define BCM_L3_INTF_QOS_DSCP_REMARK         (1 << 8)   /* Remark DSCP from PHB. */
#define BCM_L3_INTF_OVERLAY_ENCAP           (1 << 9)   /*  L3 interface used for
                                                          overlay routing.
                                                          Relevant for intra DC
                                                          routed packets */
#define BCM_L3_INTF_NATIVE_ENCAP            (1 << 10)  /* L3 interface used for
                                                          native outing.
                                                          Relevant for intra DC
                                                          routed packets */

/* L3 Egress Interface flags. */
#define BCM_L3_INTF_INNER_VLAN_DO_NOT_MODIFY (1 << 0)   /* Do not modify inner
                                                          VLAN Tag */
#define BCM_L3_INTF_INNER_VLAN_ADD          (1 << 1)   /* Add Inner VLAN Tag */
#define BCM_L3_INTF_INNER_VLAN_REPLACE      (1 << 2)   /* Replace Inner VLAN Tag */
#define BCM_L3_INTF_INNER_VLAN_DELETE       (1 << 3)   /* Delete Inner VLAN Tag */

/* Reserved VRF values . */
#define BCM_L3_VRF_OVERRIDE     _SHR_L3_VRF_OVERRIDE /* Matches before VRF specific
                                              entries. */
#define BCM_L3_VRF_GLOBAL       _SHR_L3_VRF_GLOBAL /* Matches after VRF specific
                                              entries. */
#define BCM_L3_VRF_DEFAULT      _SHR_L3_VRF_DEFAULT /* Default VRF ID. */

/* Backward compatibility. */
#define BCM_L3_TUNNEL_TYPE_IP6_IP4  BCM_L3_TUNNEL_TYPE_6TO4 

/* Invalid L3 Ingress Interface */
#define BCM_L3_INGRESS_INTERFACE_INVALID    4095       /* Invalid L3 Ingress
                                                          Interface */

#define BCM_IP6_BYTE(a, n)      (((uint8 *) (a))[n]) 

#define BCM_IP6_HALF(a, n)      (((uint16 *) (a))[n]) 

#define BCM_IP6_WORD(a, n)      (((uint8 *) (a))[n]) 

#define BCM_IP4_MULTICAST(a)    \
    (((a) & 0xf0000000) == 0xe0000000) 

#define BCM_IP6_MULTICAST(a)    \
    ((BCM_IP6_BYTE(a, 0)) == 0xff) 

#define BCM_IP6_ADDR_EQ(a1, a2)  \
    (sal_memcmp((a1), (a2), BCM_IP6_ADDRLEN) == 0) 

#define BCM_IP6_LOOPBACK(a)     \
    ((BCM_IP6_WORD((a), 0) | BCM_IP6_WORD((a), 1) | \
      BCM_IP6_WORD((a), 2) | BCM_IP6_HALF((a), 6) | \
      BCM_IP6_BYTE((a), 14)) == 0 && BCM_IP6_BYTE((a), 15) == 1) 

#define BCM_IP6_V4_MAPPED(a)    \
    ((BCM_IP6_WORD((a), 0) | BCM_IP6_WORD((a), 1) | \
      BCM_IP6_HALF((a), 4)) == 0 && BCM_IP6_HALF((a), 5) == 0xffff) 

#define BCM_IP6_V4_COMPATIBLE(a)  \
    (BCM_IP6_WORD((a), 0) | BCM_IP6_WORD((a), 1) | BCM_IP6_WORD((a), 2) == 0) 

/* L3 Egress Interface flags. */
#define BCM_L3_ECMP_RESILIENT_MATCH_HASH_KEY (1 << 0)   /* Match on the hash key
                                                          value */
#define BCM_L3_ECMP_RESILIENT_MATCH_INTF    (1 << 1)   /* Match on the interface
                                                          value */
#define BCM_L3_ECMP_RESILIENT_MATCH_ECMP    (1 << 2)   /* Match on the ECMP-Id
                                                          value */
#define BCM_L3_ECMP_RESILIENT_DELETE        (1 << 3)   /* Delete matched entries */
#define BCM_L3_ECMP_RESILIENT_REPLACE       (1 << 4)   /* Replace matched
                                                          entries with
                                                          replace_entry */
#define BCM_L3_ECMP_RESILIENT_COUNT         (1 << 5)   /* Count matched entries
                                                          in num_entries */

/* L3 Interface QOS setting. */
typedef struct bcm_l3_intf_qos_s {
    uint32 flags;   /* See BCM_L3_INTF_QOS_XXX flag definitions. */
    int qos_map_id; /* QOS Map ID. */
    uint8 pri;      /* Packet .1p. */
    uint8 cfi;      /* Packet CFI. */
    int dscp;       /* Packet DSCP. */
} bcm_l3_intf_qos_t;

/* 
 * L3 Interface Structure.
 * 
 * Contains information required for manipulating L3 interfaces.
 */
typedef struct bcm_l3_intf_s {
    uint32 l3a_flags;                   /* See BCM_L3_XXX flag definitions. */
    bcm_vrf_t l3a_vrf;                  /* Virtual router instance. */
    bcm_if_t l3a_intf_id;               /* Interface ID. */
    bcm_mac_t l3a_mac_addr;             /* MAC address. */
    bcm_vlan_t l3a_vid;                 /* VLAN ID. */
    bcm_vlan_t l3a_inner_vlan;          /* Inner vlan for double tagged packets. */
    int l3a_tunnel_idx;                 /* Tunnel (initiator) index. */
    int l3a_ttl;                        /* TTL threshold. */
    int l3a_mtu;                        /* MTU. */
    bcm_if_group_t l3a_group;           /* Interface group number. */
    bcm_l3_intf_qos_t vlan_qos;         /* Outer-Vlan QoS Setting. */
    bcm_l3_intf_qos_t inner_vlan_qos;   /* Inner-Vlan QoS Setting. */
    bcm_l3_intf_qos_t dscp_qos;         /* DSCP QoS Setting. */
    int l3a_intf_class;                 /* L3 interface class ID */
    int l3a_ip4_options_profile_id;     /* IP4 Options handling Profile ID */
    int l3a_nat_realm_id;               /* Realm id of the interface for NAT */
    uint16 outer_tpid;                  /* TPID value */
    uint32 l3a_intf_flags;              /* See BCM_L3_INTF_XXX flag definitions. */
    uint8 native_routing_vlan_tags;     /* Set number of VLAN tags expected when
                                           interface is used for native routing */
} bcm_l3_intf_t;

/* 
 * L3 Egress Structure.
 * 
 * Description of an L3 forwarding destination.
 */
typedef struct bcm_l3_egress_s {
    uint32 flags;                       /* Interface flags (BCM_L3_TGID,
                                           BCM_L3_L2TOCPU). */
    bcm_if_t intf;                      /* L3 interface (source MAC, tunnel). */
    bcm_mac_t mac_addr;                 /* Next hop forwarding destination mac. */
    bcm_vlan_t vlan;                    /* Next hop vlan id. */
    bcm_module_t module; 
    bcm_port_t port;                    /* Port packet switched to (if
                                           !BCM_L3_TGID). */
    bcm_trunk_t trunk;                  /* Trunk packet switched to (if
                                           BCM_L3_TGID). */
    uint32 mpls_flags;                  /* BCM_MPLS flag definitions. */
    bcm_mpls_label_t mpls_label;        /* MPLS label. */
    int mpls_qos_map_id;                /* MPLS EXP map ID. */
    int mpls_ttl;                       /* MPLS TTL threshold. */
    uint8 mpls_pkt_pri;                 /* MPLS Packet Priority Value. */
    uint8 mpls_pkt_cfi;                 /* MPLS Packet CFI Value. */
    uint8 mpls_exp;                     /* MPLS Exp. */
    int qos_map_id;                     /* General QOS map id */
    bcm_if_t encap_id;                  /* Encapsulation index. */
    bcm_failover_t failover_id;         /* Failover Object Index. */
    bcm_if_t failover_if_id;            /* Failover Egress Object index. */
    bcm_multicast_t failover_mc_group;  /* Failover Multicast Group. */
    int dynamic_scaling_factor;         /* Scaling factor for dynamic load
                                           balancing thresholds. */
    int dynamic_load_weight;            /* Weight of traffic load in determining
                                           a dynamic load balancing member's
                                           quality. */
    int intf_class;                     /* L3 interface class ID */
    uint32 multicast_flags;             /* BCM_L3_MULTICAST flag definitions. */
} bcm_l3_egress_t;

/* Invalid values for L3 ECMP dynamic load balancing parameters. */
#define BCM_L3_ECMP_DYNAMIC_SCALING_FACTOR_INVALID -1         /* Invalid value for
                                                          dynamic_scaling_factor. */
#define BCM_L3_ECMP_DYNAMIC_LOAD_WEIGHT_INVALID -1         /* Invalid value for
                                                          dynamic_load_weight. */

/* L3 Ingress Interface URPF Mode setting. */
typedef enum bcm_l3_ingress_urpf_mode_e {
    bcmL3IngressUrpfDisable = 0,    /* Disable unicast RPF. */
    bcmL3IngressUrpfLoose = 1,      /* Loose mode Unicast RPF. */
    bcmL3IngressUrpfStrict = 2      /* Strict mode Unicast RPF. */
} bcm_l3_ingress_urpf_mode_t;

/* 
 * L3 Ingress Structure.
 * 
 * Description of an L3 Ingress interface.
 */
typedef struct bcm_l3_ingress_s {
    uint32 flags;                       /* Interface flags. */
    bcm_vrf_t vrf;                      /* Virtual router id. */
    bcm_l3_ingress_urpf_mode_t urpf_mode; /* URPF mode setting for L3 Ingress
                                           Interface. */
    int intf_class;                     /* Classification class ID. */
    bcm_vlan_t ipmc_intf_id;            /* IPMC L2 distribution Vlan. */
    int qos_map_id;                     /* QoS DSCP priority map. */
    int ip4_options_profile_id;         /* IP4 Options handling Profile ID */
    int nat_realm_id;                   /* Realm id of the interface for NAT */
} bcm_l3_ingress_t;

/* 
 * L3 Host Structure.
 * 
 * Contains information required for manipulating L3 host table entries.
 * 
 * The BCM_L3_IP6 flag in l3a_flags must be set to specify whether the
 * IPv4 or IPv6 addresses are valid.
 */
typedef struct bcm_l3_host_s {
    uint32 l3a_flags;           /* See BCM_L3_xxx flag definitions. */
    bcm_vrf_t l3a_vrf;          /* Virtual router instance. */
    bcm_ip_t l3a_ip_addr;       /* Destination host IP address (IPv4). */
    bcm_ip6_t l3a_ip6_addr;     /* Destination host IP address (IPv6). */
    bcm_cos_t l3a_pri;          /* New priority in packet. */
    bcm_if_t l3a_intf;          /* L3 intf associated with this address. */
    bcm_mac_t l3a_nexthop_mac;  /* Next hop MAC addr. */
    bcm_module_t l3a_modid;     /* Module ID packet is switched to. */
    bcm_port_t l3a_port_tgid;   /* Port/TGID packet is switched to. */
    bcm_port_t l3a_stack_port;  /* Used if modid not local (Strata Only). */
    int l3a_ipmc_ptr;           /* Pointer to IPMC table. */
    int l3a_lookup_class;       /* Classification lookup class ID. */
    bcm_if_t encap_id;          /* Encapsulation index. */
    bcm_if_t native_intf;       /*  L3 native interface (source MAC). */
} bcm_l3_host_t;

/* Backward compatibility. */
typedef bcm_l3_host_t bcm_l3_ip_t;

/* 
 * L3 Key Structure.
 * 
 * Defines L3 table hash key structure.
 * 
 *   - For unicast addresses, key is DIP address or SIP to update HIT bit
 *   - For multicast addresses, the key is either IPMC group address
 *     (IPMC group address + src IP address), or
 *     (IPMC group address + src IP address + VID)
 *     depending on the chip being used and the (G, S, V) mode enable.
 * 
 * The BCM_L3_IP6 flag in l3k_flags is set to specify whether the IPv4 or
 * IPv6 addresses are valid.
 */
typedef struct bcm_l3_key_s {
    uint32 l3k_flags;           /* Set BCM_L3_IP6 for IPv6, default is IPv4, no
                                   other flags are relevant. */
    bcm_ip_t l3k_ip_addr;       /* Destination IP address (IPv4). */
    bcm_ip6_t l3k_ip6_addr;     /* Destination IP address (IPv6). */
    bcm_ip_t l3k_sip_addr;      /* Source IP address (IPv4). */
    bcm_ip6_t l3k_sip6_addr;    /* Source IP address (IPv6). */
    bcm_vlan_t l3k_vid;         /* VLAN ID. */
    bcm_vrf_t l3k_vrf;          /* BCM5660x: Virtual router instance. */
} bcm_l3_key_t;

/* 
 * L3 Route Structure
 * 
 * Contains information required for manipulating L3 route table entries.
 * 
 * The BCM_L3_IP6 flag in l3a_flags must be set to specify whether the
 * IPv4 or IPv6 addresses are valid.
 */
typedef struct bcm_l3_route_s {
    uint32 l3a_flags;                   /* See BCM_L3_xxx flag definitions. */
    bcm_vrf_t l3a_vrf;                  /* Virtual router instance. */
    bcm_ip_t l3a_subnet;                /* IP subnet address (IPv4). */
    bcm_ip6_t l3a_ip6_net;              /* IP subnet address (IPv6). */
    bcm_ip_t l3a_ip_mask;               /* IP subnet mask (IPv4). */
    bcm_ip6_t l3a_ip6_mask;             /* IP subnet mask (IPv6). */
    bcm_if_t l3a_intf;                  /* L3 interface associated with route. */
    bcm_ip_t l3a_nexthop_ip;            /* Next hop IP address (XGS1/2, IPv4). */
    bcm_mac_t l3a_nexthop_mac;          /* Next hop MAC address. */
    bcm_module_t l3a_modid;             /* Module ID. */
    bcm_port_t l3a_port_tgid;           /* Port or trunk group ID. */
    bcm_port_t l3a_stack_port;          /* Used if modid is not local (Strata
                                           Only). */
    bcm_vlan_t l3a_vid;                 /* BCM5695 only - for per-VLAN def
                                           route. */
    bcm_cos_t l3a_pri;                  /* Priority (COS). */
    uint32 l3a_tunnel_option;           /* Tunnel option value. */
    bcm_mpls_label_t l3a_mpls_label;    /* MPLS label. */
    int l3a_lookup_class;               /* Classification class ID. */
} bcm_l3_route_t;

/* 
 * L3 Information Structure.
 * 
 * Contains information about L3 hardware capacity and utilization.
 * 
 * Note that in chips that implement the longest prefix match route table
 * as a trie, one IP route may consume up to 128 table entries in the
 * worst case.
 */
typedef struct bcm_l3_info_s {
    int l3info_max_vrf;             /* Maximum number of virtual routers
                                       allowed. */
    int l3info_used_vrf;            /* Number of virtual routers created so far. */
    int l3info_max_intf;            /* Maximum L3 interfaces the chip supports. */
    int l3info_max_intf_group;      /* Maximum L3 interface groups the chip
                                       supports. */
    int l3info_max_host;            /* L3 host table size(unit is IPv4 unicast). */
    int l3info_max_route;           /* L3 route table size (unit is IPv4 route). */
    int l3info_max_ecmp;            /* Maximum ECMP paths allowed. */
    int l3info_used_intf;           /* L3 interfaces used. */
    int l3info_used_host;           /* L3 host entries used. */
    int l3info_used_route;          /* L3 route entries used. */
    int l3info_max_lpm_block;       /* Maximum LPM blocks. */
    int l3info_used_lpm_block;      /* LPM blocks used. */
    int l3info_max_l3;              /* Superseded by l3info_max_host. */
    int l3info_max_defip;           /* Superseded by l3info_max_route. */
    int l3info_used_l3;             /* Superseded by l3info_occupied_host. */
    int l3info_used_defip;          /* Superseded by l3info_occupied_route. */
    int l3info_max_nexthop;         /* Maximum NextHops. */
    int l3info_used_nexthop;        /* NextHops used. */
    int l3info_max_tunnel_init;     /* Maximum IPV4 tunnels that can be
                                       initiated. */
    int l3info_used_tunnel_init;    /* Number of active IPV4 tunnels initiated. */
    int l3info_max_tunnel_term;     /* Maximum IPV4 tunnels that can be
                                       terminated. */
    int l3info_used_tunnel_term;    /* Number of active IPV4 tunnels terminated. */
} bcm_l3_info_t;

/* Renamed bcm_l3_info_t fields. */
#define l3info_occupied_intf    l3info_used_intf 
#define l3info_occupied_host    l3info_used_host 
#define l3info_occupied_route   l3info_used_route 
#define l3info_occupied_l3      l3info_used_l3 
#define l3info_occupied_defip   l3info_used_defip 
#define bcm_l3_detach           bcm_l3_cleanup 

/* L3 ECMP structure */
typedef struct bcm_l3_egress_ecmp_s {
    uint32 flags;                       /* See BCM_L3_xxx flag definitions. */
    bcm_if_t ecmp_intf;                 /* L3 interface ID pointing to egress
                                           ecmp object. */
    int max_paths;                      /* Max number of paths in ECMP group. If
                                           max_paths <= 0, the default max path
                                           which can be set by the API
                                           bcm_l3_route_max_ecmp_set will be
                                           picked. */
    uint32 ecmp_group_flags;            /* BCM_L3_ECMP_xxx flags. */
    uint32 dynamic_mode;                /* Dynamic load balancing mode. See
                                           BCM_L3_ECMP_DYNAMIC_MODE_xxx
                                           definitions. */
    uint32 dynamic_size;                /* Number of flows for dynamic load
                                           balancing. Valid values are 512, 1k,
                                           doubling up to 32k */
    uint32 dynamic_age;                 /* Inactivity duration, in microseconds. */
    uint32 dynamic_load_exponent;       /* The exponent used in the
                                           exponentially weighted moving average
                                           calculation of historical member
                                           load. */
    uint32 dynamic_expected_load_exponent; /* The exponent used in the
                                           exponentially weighted moving average
                                           calculation of historical expected
                                           member load. */
} bcm_l3_egress_ecmp_t;

/* Resilient ecmp entry */
typedef struct bcm_l3_egress_ecmp_resilient_entry_s {
    uint64 hash_key;            /* Hash key. */
    bcm_l3_egress_ecmp_t ecmp;  /* ECMP. */
    bcm_if_t intf;              /* L3 interface. */
} bcm_l3_egress_ecmp_resilient_entry_t;

/* L3 ECMP flags. */
#define BCM_L3_ECMP_DYNAMIC_LOAD_DECREASE_RESET 0x01       /* If set, historical
                                                          member load is reset
                                                          to the instantaneous
                                                          member load if the
                                                          latter is smaller. */
#define BCM_L3_ECMP_DYNAMIC_EXPECTED_LOAD_DECREASE_RESET 0x02       /* If set, historical
                                                          expected member load
                                                          is reset to the
                                                          instantaneous expected
                                                          member load if the
                                                          latter is smaller. */
#define BCM_L3_ECMP_PATH_NO_SORTING         0x04       /* If set, the members of
                                                          the ECMP group won't
                                                          be resorted. */

/* L3 ECMP dynamic load balancing modes. */
#define BCM_L3_ECMP_DYNAMIC_MODE_DISABLED   0          /* ECMP dynamic load
                                                          balancing disabled. */
#define BCM_L3_ECMP_DYNAMIC_MODE_NORMAL     1          /* ECMP dynamic load
                                                          balancing normal mode:
                                                          if inactivity duration
                                                          lapsed, use optimal
                                                          member, else use
                                                          assigned member. */
#define BCM_L3_ECMP_DYNAMIC_MODE_ASSIGNED   2          /* ECMP dynamic load
                                                          balancing assigned
                                                          mode: always use
                                                          assigned member. */
#define BCM_L3_ECMP_DYNAMIC_MODE_OPTIMAL    3          /* ECMP dynamic load
                                                          balancing optimal
                                                          mode: always use
                                                          optimal member */
#define BCM_L3_ECMP_DYNAMIC_MODE_RESILIENT  4          /* ECMP resilient load
                                                          balancing mode:
                                                          minimize reassignment
                                                          of flows to members */

/* L3 ECMP dynamic load balancing Ethertype eligibility flags. */
#define BCM_L3_ECMP_DYNAMIC_ETHERTYPE_ELIGIBLE 0x01       /* If set, the specified
                                                          Ethertypes are
                                                          eligible, else
                                                          ineligible. */
#define BCM_L3_ECMP_DYNAMIC_ETHERTYPE_INNER 0x02       /* Use packet's inner
                                                          Ethertype. */
#define BCM_L3_ECMP_DYNAMIC_ETHERTYPE_RESILIENT 0x04       /* If set, configure
                                                          Ethertype eligibility
                                                          for resilient load
                                                          balancing, else for
                                                          dynamic load
                                                          balancing. */

/* L3 ECMP dynamic load balancing link status. */
#define BCM_L3_ECMP_DYNAMIC_MEMBER_FORCE_DOWN 0          /* Force down the link
                                                          status of an ECMP
                                                          dynamic load balancing
                                                          member. */
#define BCM_L3_ECMP_DYNAMIC_MEMBER_FORCE_UP 1          /* Force up the link
                                                          status of an ECMP
                                                          dynamic load balancing
                                                          member. */
#define BCM_L3_ECMP_DYNAMIC_MEMBER_HW       2          /* Let hardware determine
                                                          the link status of an
                                                          ECMP dynamic load
                                                          balancing member. */
#define BCM_L3_ECMP_DYNAMIC_MEMBER_HW_DOWN  3          /* Hardware indicates
                                                          down link status of an
                                                          ECMP dynamic load
                                                          balancing member. */
#define BCM_L3_ECMP_DYNAMIC_MEMBER_HW_UP    4          /* Hardware indicates up
                                                          link status of an ECMP
                                                          dynamic load balancing
                                                          member. */

/* bcm_l3_host_traverse_cb */
typedef int (*bcm_l3_host_traverse_cb)(
    int unit, 
    int index, 
    bcm_l3_host_t *info, 
    void *user_data);

/* bcm_l3_route_traverse_cb */
typedef int (*bcm_l3_route_traverse_cb)(
    int unit, 
    int index, 
    bcm_l3_route_t *info, 
    void *user_data);

/* bcm_l3_egress_traverse_cb */
typedef int (*bcm_l3_egress_traverse_cb)(
    int unit, 
    bcm_if_t intf, 
    bcm_l3_egress_t *info, 
    void *user_data);

/* bcm_l3_ingress_traverse_cb */
typedef int (*bcm_l3_ingress_traverse_cb)(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_ingress_t *ing_intf, 
    void *user_data);

/* bcm_l3_egress_multipath_traverse_cb */
typedef int (*bcm_l3_egress_multipath_traverse_cb)(
    int unit, 
    bcm_if_t mpintf, 
    int intf_count, 
    bcm_if_t *intf_array, 
    void *user_data);

/* bcm_l3_egress_ecmp_traverse_cb */
typedef int (*bcm_l3_egress_ecmp_traverse_cb)(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp, 
    int intf_count, 
    bcm_if_t *intf_array, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* Initialize the BCM L3 subsystem. */
extern int bcm_l3_init(
    int unit);

/* De-initialize the BCM L3 subsystem. */
extern int bcm_l3_cleanup(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

#define bcm_l3_detach           bcm_l3_cleanup 

#ifndef BCM_HIDE_DISPATCHABLE

/* Enable/disable L3 function without clearing any L3 tables. */
extern int bcm_l3_enable_set(
    int unit, 
    int enable);

/* Get the status of hardware tables. */
extern int bcm_l3_info(
    int unit, 
    bcm_l3_info_t *l3info);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize a bcm_l3_intf_t/bcmx_l3_intf_t structure. */
extern void bcm_l3_intf_t_init(
    bcm_l3_intf_t *intf);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create a new L3 interface. */
extern int bcm_l3_intf_create(
    int unit, 
    bcm_l3_intf_t *intf);

/* Delete an L3 interface. */
extern int bcm_l3_intf_delete(
    int unit, 
    bcm_l3_intf_t *intf);

/* Delete all L3 interfaces. */
extern int bcm_l3_intf_delete_all(
    int unit);

/* Search for L3 interface by MAC address and VLAN. */
extern int bcm_l3_intf_find(
    int unit, 
    bcm_l3_intf_t *intf);

/* Search for L3 interface by VLAN only. */
extern int bcm_l3_intf_find_vlan(
    int unit, 
    bcm_l3_intf_t *intf);

/* Given the L3 interface number, return the interface information. */
extern int bcm_l3_intf_get(
    int unit, 
    bcm_l3_intf_t *intf);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize a bcm_l3_egress_t/bcmx_l3_egress_t structure. */
extern void bcm_l3_egress_t_init(
    bcm_l3_egress_t *egr);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create an Egress forwarding object. */
extern int bcm_l3_egress_create(
    int unit, 
    uint32 flags, 
    bcm_l3_egress_t *egr, 
    bcm_if_t *if_id);

/* Destroy an Egress forwarding object. */
extern int bcm_l3_egress_destroy(
    int unit, 
    bcm_if_t intf);

/* Get an Egress forwarding object. */
extern int bcm_l3_egress_get(
    int unit, 
    bcm_if_t intf, 
    bcm_l3_egress_t *egr);

/* Find an interface pinting to an Egress forwarding object. */
extern int bcm_l3_egress_find(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_if_t *intf);

/* 
 * Traverse through the egress object table and run callback at each
 * valid entry.
 */
extern int bcm_l3_egress_traverse(
    int unit, 
    bcm_l3_egress_traverse_cb trav_fn, 
    void *user_data);

/* Create a Multipath Egress forwarding object. */
extern int bcm_l3_egress_multipath_create(
    int unit, 
    uint32 flags, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_if_t *mpintf);

/* Create a Multipath Egress forwarding object with specified path-width. */
extern int bcm_l3_egress_multipath_max_create(
    int unit, 
    uint32 flags, 
    int max_paths, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_if_t *mpintf);

/* Destroy an Egress Multipath forwarding object. */
extern int bcm_l3_egress_multipath_destroy(
    int unit, 
    bcm_if_t mpintf);

/* Get an Egress Multipath forwarding object. */
extern int bcm_l3_egress_multipath_get(
    int unit, 
    bcm_if_t mpintf, 
    int intf_size, 
    bcm_if_t *intf_array, 
    int *intf_count);

/* 
 * Add an Egress forwarding object to an Egress Multipath forwarding
 * object.
 */
extern int bcm_l3_egress_multipath_add(
    int unit, 
    bcm_if_t mpintf, 
    bcm_if_t intf);

/* 
 * Delete an Egress forwarding object from an Egress Multipath forwarding
 * object.
 */
extern int bcm_l3_egress_multipath_delete(
    int unit, 
    bcm_if_t mpintf, 
    bcm_if_t intf);

/* Find an interface pinting to an Egress Multipath forwarding object. */
extern int bcm_l3_egress_multipath_find(
    int unit, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_if_t *mpintf);

/* 
 * Traverse through the multipath egress object table and run callback at
 * each valid entry.
 */
extern int bcm_l3_egress_multipath_traverse(
    int unit, 
    bcm_l3_egress_multipath_traverse_cb trav_fn, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize a bcm_l3_egress_ecmp_t structure. */
extern void bcm_l3_egress_ecmp_t_init(
    bcm_l3_egress_ecmp_t *ecmp);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create an Egress ECMP forwarding object. */
extern int bcm_l3_egress_ecmp_create(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp, 
    int intf_count, 
    bcm_if_t *intf_array);

/* Destroy an Egress ECMP forwarding object. */
extern int bcm_l3_egress_ecmp_destroy(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp);

/* Get an Egress ECMP forwarding object. */
extern int bcm_l3_egress_ecmp_get(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp, 
    int intf_size, 
    bcm_if_t *intf_array, 
    int *intf_count);

/* Add an Egress forwarding object to an Egress ECMP forwarding object. */
extern int bcm_l3_egress_ecmp_add(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp, 
    bcm_if_t intf);

/* 
 * Delete an Egress forwarding object from an Egress ECMP forwarding
 * object.
 */
extern int bcm_l3_egress_ecmp_delete(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp, 
    bcm_if_t intf);

/* Find an interface pinting to an Egress ECMP forwarding object. */
extern int bcm_l3_egress_ecmp_find(
    int unit, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_l3_egress_ecmp_t *ecmp);

/* 
 * Traverse through the ecmp egress object table and run callback at each
 * valid entry.
 */
extern int bcm_l3_egress_ecmp_traverse(
    int unit, 
    bcm_l3_egress_ecmp_traverse_cb trav_fn, 
    void *user_data);

/* Set Ethertype eligibility for ECMP dynamic load balancing */
extern int bcm_l3_egress_ecmp_ethertype_set(
    int unit, 
    uint32 flags, 
    int ethertype_count, 
    int *ethertype_array);

/* Get Ethertype eligibility for ECMP dynamic load balancing */
extern int bcm_l3_egress_ecmp_ethertype_get(
    int unit, 
    uint32 *flags, 
    int ethertype_max, 
    int *ethertype_array, 
    int *ethertype_count);

/* Set ECMP member status */
extern int bcm_l3_egress_ecmp_member_status_set(
    int unit, 
    bcm_if_t intf, 
    int status);

/* Get ECMP member status */
extern int bcm_l3_egress_ecmp_member_status_get(
    int unit, 
    bcm_if_t intf, 
    int *status);

#endif /* BCM_HIDE_DISPATCHABLE */

/* bcm_l3_egress_ecmp_resilient_traverse_cb */
typedef int (*bcm_l3_egress_ecmp_resilient_traverse_cb)(
    int unit, 
    bcm_l3_egress_ecmp_resilient_entry_t *entry, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Traverse through the resilient ecmp table and run callback at each
 * valid entry. Possible replacement of the matched entries
 */
extern int bcm_l3_egress_ecmp_resilient_traverse(
    int unit, 
    uint32 flags, 
    bcm_l3_egress_ecmp_resilient_entry_t *match_entry, 
    bcm_l3_egress_ecmp_resilient_traverse_cb trav_fn, 
    void *user_data);

/* Replace ECMP resilient entries matching given criteria */
extern int bcm_l3_egress_ecmp_resilient_replace(
    int unit, 
    uint32 flags, 
    bcm_l3_egress_ecmp_resilient_entry_t *match_entry, 
    int *num_entries, 
    bcm_l3_egress_ecmp_resilient_entry_t *replace_entry);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize a bcm_l3_ingress_t/bcmx_l3_ingress_t structure. */
extern void bcm_l3_ingress_t_init(
    bcm_l3_ingress_t *ing_intf);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create an L3 Ingress Interface. */
extern int bcm_l3_ingress_create(
    int unit, 
    bcm_l3_ingress_t *ing_intf, 
    bcm_if_t *intf_id);

/* Destroy an L3 Ingress Interface. */
extern int bcm_l3_ingress_destroy(
    int unit, 
    bcm_if_t intf_id);

/* Get L3 Ingress Interface configuration. */
extern int bcm_l3_ingress_get(
    int unit, 
    bcm_if_t intf, 
    bcm_l3_ingress_t *ing_intf);

/* Find an identical ingress L3 interface. */
extern int bcm_l3_ingress_find(
    int unit, 
    bcm_l3_ingress_t *ing_intf, 
    bcm_if_t *intf_id);

/* 
 * Traverse through the L3 ingress interfaces and invoke a user provide
 * callback for each valid entry.
 */
extern int bcm_l3_ingress_traverse(
    int unit, 
    bcm_l3_ingress_traverse_cb trav_fn, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize a bcm_l3_host_t/bcmx_l3_host_t structure. */
extern void bcm_l3_host_t_init(
    bcm_l3_host_t *ip);

#ifndef BCM_HIDE_DISPATCHABLE

/* Look up an L3 host table entry based on IP address. */
extern int bcm_l3_host_find(
    int unit, 
    bcm_l3_host_t *info);

/* Add an entry into the L3 switching table. */
extern int bcm_l3_host_add(
    int unit, 
    bcm_l3_host_t *info);

/* Delete an entry from the L3 host table. */
extern int bcm_l3_host_delete(
    int unit, 
    bcm_l3_host_t *ip_addr);

/* Delete L3 entries based on IP prefix (network). */
extern int bcm_l3_host_delete_by_network(
    int unit, 
    bcm_l3_route_t *ip_addr);

/* 
 * Deletes L3 entries that match or do not match a specified L3 interface
 * number.
 */
extern int bcm_l3_host_delete_by_interface(
    int unit, 
    bcm_l3_host_t *info);

/* Deletes all L3 host table entries. */
extern int bcm_l3_host_delete_all(
    int unit, 
    bcm_l3_host_t *info);

/* Return list of conflicts in the L3 table. */
extern int bcm_l3_host_conflict_get(
    int unit, 
    bcm_l3_key_t *ipkey, 
    bcm_l3_key_t *cf_array, 
    int cf_max, 
    int *cf_count);

/* Run L3 table aging. */
extern int bcm_l3_host_age(
    int unit, 
    uint32 flags, 
    bcm_l3_host_traverse_cb age_cb, 
    void *user_data);

/* Traverse through the L3 table and run callback at each valid L3 entry. */
extern int bcm_l3_host_traverse(
    int unit, 
    uint32 flags, 
    uint32 start, 
    uint32 end, 
    bcm_l3_host_traverse_cb cb, 
    void *user_data);

/* bcm_l3_host_invalidate_entry */
extern int bcm_l3_host_invalidate_entry(
    int unit, 
    bcm_ip_t info);

/* bcm_l3_host_validate_entry */
extern int bcm_l3_host_validate_entry(
    int unit, 
    bcm_ip_t info);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize a bcm_l3_route_t/bcmx_l3_route_t_init structure. */
extern void bcm_l3_route_t_init(
    bcm_l3_route_t *route);

#ifndef BCM_HIDE_DISPATCHABLE

/* Add an IP route to the L3 route table. */
extern int bcm_l3_route_add(
    int unit, 
    bcm_l3_route_t *info);

/* Delete an IP route from the DEFIP table. */
extern int bcm_l3_route_delete(
    int unit, 
    bcm_l3_route_t *info);

/* Delete routes based on matching or non-matching L3 interface number. */
extern int bcm_l3_route_delete_by_interface(
    int unit, 
    bcm_l3_route_t *info);

/* Delete all routes. */
extern int bcm_l3_route_delete_all(
    int unit, 
    bcm_l3_route_t *info);

/* Look up a route given the network and netmask. */
extern int bcm_l3_route_get(
    int unit, 
    bcm_l3_route_t *info);

/* Given a network, return all the paths for this route. */
extern int bcm_l3_route_multipath_get(
    int unit, 
    bcm_l3_route_t *the_route, 
    bcm_l3_route_t *path_array, 
    int max_path, 
    int *path_count);

/* Age the route table. */
extern int bcm_l3_route_age(
    int unit, 
    uint32 flags, 
    bcm_l3_route_traverse_cb age_out, 
    void *user_data);

/* Traverse through the routing table and run callback at each route. */
extern int bcm_l3_route_traverse(
    int unit, 
    uint32 flags, 
    uint32 start, 
    uint32 end, 
    bcm_l3_route_traverse_cb trav_fn, 
    void *user_data);

/* Set the maximum ECMP paths allowed for a route (XGS only). */
extern int bcm_l3_route_max_ecmp_set(
    int unit, 
    int max);

/* Get the maximum ECMP paths allowed for a route (XGS only). */
extern int bcm_l3_route_max_ecmp_get(
    int unit, 
    int *max);

/* 
 * Extract list of IPv6 prefixes which are forwarded based on lower 32
 * bit of IPv6 address, treated as IPv4 address.
 */
extern int bcm_l3_ip6_prefix_map_get(
    int unit, 
    int map_size, 
    bcm_ip6_t *ip6_array, 
    int *ip6_count);

/* 
 * Add IPv6 prefix to the list of prefixes which are forwarded based on
 * lower 32 bit of IPv6 address, treated as IPv4 address.
 */
extern int bcm_l3_ip6_prefix_map_add(
    int unit, 
    bcm_ip6_t ip6_addr);

/* 
 * Remove IPv6 prefix from the list of prefixes which are forwarded based
 * on lower 32 bit of IPv6 address, treated as IPv4 address.
 */
extern int bcm_l3_ip6_prefix_map_delete(
    int unit, 
    bcm_ip6_t ip6_addr);

/* 
 * Remove all the IPv6 prefixes from the list of prefixes which are
 * forwarded based on lower 32 bit of IPv6 address, treated as IPv4
 * address.
 */
extern int bcm_l3_ip6_prefix_map_delete_all(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

/* bcm_l3_age_cb */
typedef void (*bcm_l3_age_cb)(
    int unit, 
    bcm_ip_t ip);

/* Initialize a bcm_l3_key_t_init structure. */
extern void bcm_l3_key_t_init(
    bcm_l3_key_t *key);

/* Initialize a bcm_l3_info_t_init structure. */
extern void bcm_l3_info_t_init(
    bcm_l3_info_t *info);

/* Types of counters per L3 object. */
typedef enum bcm_l3_stat_e {
    bcmL3StatOutPackets = 0, 
    bcmL3StatOutBytes = 1, 
    bcmL3StatDropPackets = 2, 
    bcmL3StatDropBytes = 3, 
    bcmL3StatInPackets = 4, 
    bcmL3StatInBytes = 5 
} bcm_l3_stat_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Extract L3 egress statistics from the chip. */
extern int bcm_l3_egress_stat_get(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint64 *val);

/* Extract L3 egress statistics from the chip. */
extern int bcm_l3_egress_stat_get32(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint32 *val);

/* 
 * Set the specified L3 statistic to the indicated value for the
 * specified L3 egress.
 */
extern int bcm_l3_egress_stat_set(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint64 val);

/* 
 * Set the specified L3 statistic to the indicated value for the
 * specified L3 egress.
 */
extern int bcm_l3_egress_stat_set32(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint32 val);

/* Enable/disable collection of statistics on the indicated L3 egress. */
extern int bcm_l3_egress_stat_enable_set(
    int unit, 
    bcm_l3_egress_t *egr, 
    int enable);

/* Extract L3 host statistics from the chip. */
extern int bcm_l3_host_stat_get(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint64 *val);

/* Extract L3 host statistics from the chip. */
extern int bcm_l3_host_stat_get32(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint32 *val);

/* 
 * Set the specified L3 statistic to the indicated value for the
 * specified L3 host.
 */
extern int bcm_l3_host_stat_set(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint64 val);

/* 
 * Set the specified L3 statistic to the indicated value for the
 * specified L3 host.
 */
extern int bcm_l3_host_stat_set32(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint32 val);

/* Enable/disable collection of statistics for the indicated L3 host. */
extern int bcm_l3_host_stat_enable_set(
    int unit, 
    bcm_l3_host_t *host, 
    int enable);

extern int bcm_l3_route_stat_get(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint64 *val);

extern int bcm_l3_route_stat_get32(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint32 *val);

extern int bcm_l3_route_stat_set(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint64 val);

extern int bcm_l3_route_stat_set32(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint32 val);

/* Enable/disable collection of statistics for the indicated L3 route. */
extern int bcm_l3_route_stat_enable_set(
    int unit, 
    bcm_l3_route_t *route, 
    int enable);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Types of statistics that are maintained per L3 VRF. */
typedef enum bcm_l3_vrf_stat_e {
    bcmL3VrfStatIngressPackets = 0, /* Packets that ingress on the L3 VRF */
    bcmL3VrfStatIngressBytes = 1    /* Bytes that ingress on the L3 VRF */
} bcm_l3_vrf_stat_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Enable/disable packet and byte counters for the selected VRF. */
extern int bcm_l3_vrf_stat_enable_set(
    int unit, 
    bcm_vrf_t vrf, 
    int enable);

/* Get 64-bit counter value for specified VRF statistic type. */
extern int bcm_l3_vrf_stat_get(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint64 *val);

/* Get 64-bit counter value for specified VRF statistic type. */
extern int bcm_l3_vrf_stat_sync_get(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint64 *val);

/* Get lower 32-bit counter value for specified VRF statistic type. */
extern int bcm_l3_vrf_stat_get32(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 *val);

/* Get lower 32-bit counter value for specified VRF statistic type. */
extern int bcm_l3_vrf_stat_sync_get32(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 *val);

/* Provide stat counter ids associated with given vrf */
extern int bcm_l3_vrf_stat_id_get(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 *stat_counter_id);

/* Set 64-bit counter value for specified VRF statistic type. */
extern int bcm_l3_vrf_stat_set(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint64 val);

/* Set lower 32-bit counter value for specified VRF statistic type. */
extern int bcm_l3_vrf_stat_set32(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 val);

/* Get 64-bit counter value for multiple VRF statistic types. */
extern int bcm_l3_vrf_stat_multi_get(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint64 *value_arr);

/* Get lower 32-bit counter value for multiple VRF statistic types. */
extern int bcm_l3_vrf_stat_multi_get32(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint32 *value_arr);

/* Set 64-bit counter value for multiple VRF statistic types. */
extern int bcm_l3_vrf_stat_multi_set(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint64 *value_arr);

/* Set lower 32-bit counter value for multiple VRF statistic types. */
extern int bcm_l3_vrf_stat_multi_set32(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint32 *value_arr);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_L3_SOURCE_BIND_IP6      0x00000001 
#define BCM_L3_SOURCE_BIND_REPLACE  0x00000002 
#define BCM_L3_SOURCE_BIND_USE_MASK 0x00000004 

/* L3 source binding information structure. */
typedef struct bcm_l3_source_bind_s {
    uint32 flags;                   /* BCM_L3_SOURCE_BIND_xxx flags. */
    bcm_gport_t port;               /* Source module and port, BCM_GPORT_INVALID
                                       to wildcard. */
    bcm_ip_t ip;                    /* Source IPv4 address. */
    bcm_ip6_t ip6;                  /* Source IPv6 address. */
    bcm_mac_t mac;                  /* Source MAC address. */
    bcm_ipfix_rate_id_t rate_id;    /* IPFIX rate ID */
    bcm_ip_t ip_mask;               /* IP subnet mask (IPv4). */
    bcm_ip6_t ip6_mask;             /* IP subnet mask (IPv6). */
} bcm_l3_source_bind_t;

/* Initialize a bcm_l3_source_bind_t structure. */
extern void bcm_l3_source_bind_t_init(
    bcm_l3_source_bind_t *info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Enable or disable l3 source binding checks on an ingress port. */
extern int bcm_l3_source_bind_enable_set(
    int unit, 
    bcm_port_t port, 
    int enable);

/* 
 * Retrieve whether l3 source binding checks are performed on an ingress
 * port.
 */
extern int bcm_l3_source_bind_enable_get(
    int unit, 
    bcm_port_t port, 
    int *enable);

/* Add or replace an L3 source binding. */
extern int bcm_l3_source_bind_add(
    int unit, 
    bcm_l3_source_bind_t *info);

/* Remove an existing L3 source binding. */
extern int bcm_l3_source_bind_delete(
    int unit, 
    bcm_l3_source_bind_t *info);

/* Remove all existing L3 source bindings. */
extern int bcm_l3_source_bind_delete_all(
    int unit);

/* Retrieve the details of an existing L3 source binding. */
extern int bcm_l3_source_bind_get(
    int unit, 
    bcm_l3_source_bind_t *info);

#endif /* BCM_HIDE_DISPATCHABLE */

typedef int (*bcm_l3_source_bind_traverse_cb)(
    int unit, 
    bcm_l3_source_bind_t *info, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Traverse through the L3 source bindings and run callback at each
 * defined binding.
 */
extern int bcm_l3_source_bind_traverse(
    int unit, 
    bcm_l3_source_bind_traverse_cb cb, 
    void *user_data);

/* 
 * Add VRID for the given VSI. Adding a VRID using this API means the
 * physical node has become the master for the virtual router
 */
extern int bcm_l3_vrrp_add(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 vrid);

/* Delete VRID for a particulat VLAN/VSI */
extern int bcm_l3_vrrp_delete(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 vrid);

/* Delete all the VRIDs for a particular VLAN/VSI */
extern int bcm_l3_vrrp_delete_all(
    int unit, 
    bcm_vlan_t vlan);

/* 
 * Get all the VRIDs for which the physical node is master for the
 * virtual routers on the given VLAN/VSI
 */
extern int bcm_l3_vrrp_get(
    int unit, 
    bcm_vlan_t vlan, 
    int alloc_size, 
    int *vrid_array, 
    int *count);

/* Attach   counters entries to the given VRF. */
extern int bcm_l3_vrf_stat_attach(
    int unit, 
    bcm_vrf_t vrf, 
    uint32 stat_counter_id);

/* Detach   counters entries to the given VRF. */
extern int bcm_l3_vrf_stat_detach(
    int unit, 
    bcm_vrf_t vrf);

/* Get L3 VRF counter value for specified VRF statistic type */
extern int bcm_l3_vrf_stat_counter_get(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Get L3 VRF counter value for specified VRF statistic type */
extern int bcm_l3_vrf_stat_counter_sync_get(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Set L3 VRF counter value for specified VRF statistic type */
extern int bcm_l3_vrf_stat_counter_set(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Attach counters entries to the given L3 Egress interface */
extern int bcm_l3_egress_stat_attach(
    int unit, 
    bcm_if_t intf_id, 
    uint32 stat_counter_id);

/* Detach  counters entries to the given L3 Egress interface. */
extern int bcm_l3_egress_stat_detach(
    int unit, 
    bcm_if_t intf_id);

/* Get the specified counter statistic for a L3 egress interface */
extern int bcm_l3_egress_stat_counter_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Get the specified counter statistic for a L3 egress interface */
extern int bcm_l3_egress_stat_counter_sync_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Provide stat counter ids associated with given L3 egress interface */
extern int bcm_l3_egress_stat_id_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 *stat_counter_id);

/* Set the specified counter statistic for a L3 egress interface */
extern int bcm_l3_egress_stat_counter_set(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Attach counters entries to the given L3 Ingress interface */
extern int bcm_l3_ingress_stat_attach(
    int unit, 
    bcm_if_t intf_id, 
    uint32 stat_counter_id);

/* Detach  counters entries to the given L3 Ingress interface. */
extern int bcm_l3_ingress_stat_detach(
    int unit, 
    bcm_if_t intf_id);

/* Get the specified counter statistic for a L3 ingress interface */
extern int bcm_l3_ingress_stat_counter_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Get the specified counter statistic for a L3 ingress interface */
extern int bcm_l3_ingress_stat_counter_sync_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Provide stat counter ids associated with given L3 ingress interface */
extern int bcm_l3_ingress_stat_id_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 *stat_counter_id);

/* Set the specified counter statistic for a L3 ingress interface */
extern int bcm_l3_ingress_stat_counter_set(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Attach counters entries to the given L3 host entry */
extern int bcm_l3_host_stat_attach(
    int unit, 
    bcm_l3_host_t *info, 
    uint32 stat_counter_id);

/* Detach  counters entries to the given L3 host entry */
extern int bcm_l3_host_stat_detach(
    int unit, 
    bcm_l3_host_t *info);

/* Get the specified counter statistic for a L3 host entry */
extern int bcm_l3_host_stat_counter_get(
    int unit, 
    bcm_l3_host_t *info, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Get the specified counter statistic for a L3 host entry */
extern int bcm_l3_host_stat_counter_sync_get(
    int unit, 
    bcm_l3_host_t *info, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Set the specified counter statistic for a L3 host entry */
extern int bcm_l3_host_stat_counter_set(
    int unit, 
    bcm_l3_host_t *info, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Provide stat counter ids associated with given L3 host entry */
extern int bcm_l3_host_stat_id_get(
    int unit, 
    bcm_l3_host_t *info, 
    bcm_l3_stat_t stat, 
    uint32 *stat_counter_id);

#endif /* BCM_HIDE_DISPATCHABLE */

/* L3 VRRP Flags. */
#define BCM_L3_VRRP_IPV4        0x00000001 /* VRID for IPV4 */
#define BCM_L3_VRRP_IPV6        0x00000002 /* VRID for IPV6 */

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Add VRID for the given VSI, for IPV4 or IPV6. Adding a VRID using this
 * API means the physical node has become the master for the virtual
 * router
 */
extern int bcm_l3_vrrp_config_add(
    int unit, 
    uint32 flags, 
    bcm_vlan_t vlan, 
    uint32 vrid);

/* Delete VRID for a particulat VLAN/VSI, for IPV4 or IPV6 */
extern int bcm_l3_vrrp_config_delete(
    int unit, 
    uint32 flags, 
    bcm_vlan_t vlan, 
    uint32 vrid);

/* Delete all the VRIDs for a particular VLAN/VSI, for IPV4 or IPV6 */
extern int bcm_l3_vrrp_config_delete_all(
    int unit, 
    uint32 flags, 
    bcm_vlan_t vlan);

/* 
 * Get all the VRIDs for which the physical node is master for the
 * virtual routers on the given VLAN/VSI. VRIDs can be for IPV4 or IPV6
 */
extern int bcm_l3_vrrp_config_get(
    int unit, 
    uint32 flags, 
    bcm_vlan_t vlan, 
    uint32 alloc_size, 
    uint32 *vrid_array, 
    uint32 *count);

#endif /* BCM_HIDE_DISPATCHABLE */

/* L3 Route statistics maintained per route. */
typedef enum bcm_l3_route_stat_e {
    bcmL3RouteInPackets = 0,    /* Packets that ingress on the l3 route */
    bcmL3RouteInBytes = 1       /* Bytes that ingress on the l3 route */
} bcm_l3_route_stat_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Attach counter entries to the given l3 route. */
extern int bcm_l3_route_stat_attach(
    int unit, 
    bcm_l3_route_t *info, 
    uint32 stat_counter_id);

/* Detach counter entries to the given l3 route. */
extern int bcm_l3_route_stat_detach(
    int unit, 
    bcm_l3_route_t *info);

/* Get L3 Route counter value for specified l3 route */
extern int bcm_l3_route_stat_counter_get(
    int unit, 
    bcm_l3_route_t *info, 
    bcm_l3_route_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Get L3 Route counter value for specified l3 route */
extern int bcm_l3_route_stat_counter_sync_get(
    int unit, 
    bcm_l3_route_t *info, 
    bcm_l3_route_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Set l3 route counter value for specified l3 route */
extern int bcm_l3_route_stat_counter_set(
    int unit, 
    bcm_l3_route_t *info, 
    bcm_l3_route_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Get 64-bit counter value for multiple route statistic types. */
extern int bcm_l3_route_stat_multi_get(
    int unit, 
    bcm_l3_route_t *info, 
    int nstat, 
    bcm_l3_route_stat_t *stat_arr, 
    uint64 *value_arr);

/* Get lower 32-bit counter value for multiple route statistic types. */
extern int bcm_l3_route_stat_multi_get32(
    int unit, 
    bcm_l3_route_t *info, 
    int nstat, 
    bcm_l3_route_stat_t *stat_arr, 
    uint32 *value_arr);

/* Set 64-bit counter value for multiple route statistic types. */
extern int bcm_l3_route_stat_multi_set(
    int unit, 
    bcm_l3_route_t *info, 
    int nstat, 
    bcm_l3_route_stat_t *stat_arr, 
    uint64 *value_arr);

/* Set lower 32-bit counter value for multiple route statistic types. */
extern int bcm_l3_route_stat_multi_set32(
    int unit, 
    bcm_l3_route_t *info, 
    int nstat, 
    bcm_l3_route_stat_t *stat_arr, 
    uint32 *value_arr);

/* Provide stat counter ids associated with given l3 route */
extern int bcm_l3_route_stat_id_get(
    int unit, 
    bcm_l3_route_t *info, 
    bcm_l3_route_stat_t stat, 
    uint32 *stat_counter_id);

#endif /* BCM_HIDE_DISPATCHABLE */

/* L3 IP options Flags. */
#define BCM_L3_IP4_OPTIONS_WITH_ID  0x00000001 /* With ID option creation */
#define BCM_L3_IP4_OPTIONS_REPLACE  0x00000002 /* Replace existing entry */

/* L3 IP options handing actions. */
typedef enum bcm_l3_ip4_options_action_e {
    bcmIntfIPOptionActionNone = 0,      /* No action. */
    bcmIntfIPOptionActionCopyToCPU = 1, /* Copy to CPU action. */
    bcmIntfIPOptionActionDrop = 2,      /* Drop action. */
    bcmIntfIPOptionActionCopyCPUAndDrop = 3 /* Copy to CPU and Drop action. */
} bcm_l3_ip4_options_action_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Create an IP Option handing Profile with a specified default action */
extern int bcm_l3_ip4_options_profile_create(
    int unit, 
    uint32 flags, 
    bcm_l3_ip4_options_action_t default_action, 
    int *ip4_options_profile_id);

/* Destroy an IP Option handing Profile */
extern int bcm_l3_ip4_options_profile_destroy(
    int unit, 
    int ip4_options_profile_id);

/* Set action to an IP option for a given IP Option Profile */
extern int bcm_l3_ip4_options_action_set(
    int unit, 
    int ip4_options_profile_id, 
    int ip4_option, 
    bcm_l3_ip4_options_action_t action);

/* Retrieve action of an IP option for a given IP Option Profile */
extern int bcm_l3_ip4_options_action_get(
    int unit, 
    int ip4_options_profile_id, 
    int ip4_option, 
    bcm_l3_ip4_options_action_t *action);

/* Find a longest prefix matched route given an IP address. */
extern int bcm_l3_route_find(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_route_t *route);

/* Find a longest prefix matched route given the ip and netmask. */
extern int bcm_l3_subnet_route_find(
    int unit, 
    bcm_l3_route_t *input, 
    bcm_l3_route_t *route);

#endif /* defined(INCLUDE_L3) */

#endif /* BCM_HIDE_DISPATCHABLE */

#endif /* __BCM_L3_H__ */
