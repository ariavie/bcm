/*
 * $Id: 387cbe8a1874c3d6ac0e5399df3b697d8f584f41 $
 * 
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_RX_H__
#define __BCM_RX_H__

#include <bcm/types.h>
#include <bcm/pkt.h>
#include <bcm/tx.h>

#define BCM_RX_COS              64         /* Number of COS supported. */
#define BCM_RX_COS_ALL          -1         /* Affect all COS. */
#define BCM_RX_CHANNELS         4          /* Max. number of RX channels. */

/* 
 * This is the default time between minimum token refreshes. It is also
 * the maximum time between RX thread wake-ups.
 */
#define BCM_RX_TOKEN_CHECK_US_DEFAULT   100000     /* 10 times/sec. */

/* bcm_rx_token_check_us */
extern int bcm_rx_token_check_us;

/* 
 * RX Callback Flags
 * 
 * The lower eight bits of the flag value are used to indicate which
 * COS(es) a callback should look at.
 * 
 *   BCM_RX_F_INTERRUPT_SET(flags) Add the interrupt flags
 *   BCM_RX_F_COS_ADD(flags, cos)  Add COS to flags
 * 
 *   BCM_RCO_F_COS_ACCEPT_MASK             Bits used for COS
 *   BCM_RCO_F_COS_ACCEPT(cos)             Generate bit for given COS
 *   BCM_RCO_F_INTR                        Interrupt level callback
 */
#define BCM_RCO_F_COS_ACCEPT_MASK   0xc0ff     
#define BCM_RCO_F_COS_ACCEPT(cos)   (1 << (cos)) 
#define BCM_RCO_F_ALL_COS           0x40000000 
#define BCM_RCO_F_INTR              0x80000000 

#define BCM_RX_F_INTERRUPT_SET(flags)  ((flags) |= BCM_RCO_F_INTR) 
#define BCM_RX_F_COS_ADD(flags, cos)  ((flags) |= BCM_RCO_F_COS_ACCEPT(cos)) 

#define BCM_RX_RATE_NOLIMIT         0          
#define BCM_RX_SCHED_ALL_PACKETS    -1         

/* Return values from PKT RX callout routines. */
typedef enum bcm_rx_e {
    BCM_RX_INVALID = 0,         /* Invalid return value. */
    BCM_RX_NOT_HANDLED = 1,     /* Packet not processed. */
    BCM_RX_HANDLED = 2,         /* Packet handled, not owned. */
    BCM_RX_HANDLED_OWNED = 3    /* Packet handled and owned. */
} bcm_rx_t;

/* Max. allowed packets per chain. */
#define BCM_RX_PPC_MAX                     

/* Callback function type for applications using bcm RX facility. */
typedef bcm_rx_t (*bcm_rx_cb_f)(
    int unit, 
    bcm_pkt_t *pkt, 
    void *cookie);

/* Callback function type for applications implementing RX scheduling. */
typedef int (*bcm_rx_sched_cb)(
    int unit, 
    int *sched_unit, 
    bcm_cos_queue_t *sched_cosq, 
    int *sched_count);

/* RX packet buffer allocation function. */
typedef int (*bcm_rx_alloc_f)(
    int unit, 
    int size, 
    uint32 flags, 
    void **pkt_buf);

/* RX packet buffer free function. */
typedef int (*bcm_rx_free_f)(
    int unit, 
    void *pkt_buf);

#define bcm_data_alloc_f        bcm_rx_alloc_f 
#define bcm_data_free_f         bcm_rx_free_f 

/* RX registration function. */
typedef int (*bcm_rx_reg_f)(
    int unit, 
    const char *name, 
    bcm_rx_cb_f callback, 
    uint8 priority, 
    void *cookie, 
    uint32 flags);

/* RX unregistration function. */
typedef int (*bcm_rx_unreg_f)(
    int unit, 
    bcm_rx_cb_f callback, 
    uint8 priority);

/* 
 * Channel-specific RX data.
 * 
 * The number of chains allowed for the channel controls the burst size
 * that the channel accepts.
 * 
 * The 'rate_pps' field is DEPRECATED. The rate may be set on a per-COS
 * basis using bcm_rx_rate_set/get.
 * 
 * IMPORTANT: If BCM_RX_F_MULTI_DCB is NOT used (single DCB per packet)
 * then the rx_free routine must be given the allocation pointer
 * (pkt->alloc_ptr) rather than the packet data pointer
 * (pkt->_pkt_data.data or pkt->pkt_data[0].data).
 */
typedef struct bcm_rx_chan_cfg_s {
    int chains;     /* Number of chains (DVs) set up. 0 means channel not used. */
    int rate_pps;   /* Deprecated: Use bcm_rx_cos_rate_set/get. */
    int flags;      /* See BCM_RX_F_* definitions. */
    uint32 cos_bmp; /* COS bitmap, if supported. */
} bcm_rx_chan_cfg_t;

/* Flags for bcm_rx_chan_cfg_t. */
#define BCM_RX_F_CRC_STRIP      0x1        /* Strip CRC from packets. */
#define BCM_RX_F_VTAG_STRIP     0x2        /* Strip VLAN tag from packets. */
#define BCM_RX_F_RATE_STALL     0x4        /* Use stall instead of discard. */
#define BCM_RX_F_MULTI_DCB      0x8        /* Scatter data with multiple DCBs. */
#define BCM_RX_F_OVERSIZED_OK   0x10       /* Accept packets larger than
                                              bufsize. */
#define BCM_RX_F_PKT_UNPARSED   0x20       /* Do not parse received packets. */

/* User-configurable, per-unit RX configuration. */
typedef struct bcm_rx_cfg_s {
    int pkt_size;                       /* Default packet size. */
    int pkts_per_chain;                 /* Packets per DMA chain. */
    int global_pps;                     /* Global rate limiting as packets per
                                           second. */
    int max_burst;                      /* Max. packets to be received in a
                                           single burst. */
    bcm_rx_chan_cfg_t chan_cfg[BCM_RX_CHANNELS]; /* RX channel configuration. */
    bcm_rx_alloc_f rx_alloc;            /* RX packet allocation function. */
    bcm_rx_free_f rx_free;              /* RX packet free function. */
    int32 flags;                        /* See BCM_RX_F_* definitions. */
} bcm_rx_cfg_t;

/* Flags for bcm_rx_cfg_t. */
#define BCM_RX_F_IGNORE_HGHDR   0x1        /* Force HiGig Header into packet for
                                              fabric device. */
#define BCM_RX_F_IGNORE_SLTAG   0x2        /* Force SL tag into packet on SL
                                              stacking. */

/* Structure of transport related function pointers. */
typedef struct bcm_trans_ptr_s {
    bcm_rx_alloc_f tp_data_alloc;   /* Packet data allocation function. */
    bcm_rx_free_f tp_data_free;     /* Packet data free function. */
    bcm_pkt_alloc_f tp_pkt_alloc;   /* Packet structure (bcm_pkt_t) allocation
                                       function. */
    bcm_pkt_free_f tp_pkt_free;     /* Packet structure (bcm_pkt_t) free
                                       function. */
    bcm_rx_reg_f tp_rx_reg;         /* RX registration function. */
    bcm_rx_unreg_f tp_rx_unreg;     /* RX unregistration function. */
    bcm_tx_pkt_setup_f tp_setup_tx; /* TX packet setup function. */
    bcm_tx_f tp_tx;                 /* TX single packet transmit function. */
    bcm_tx_list_f tp_tx_list;       /* TX function for sending a list of
                                       packets. */
    bcm_tx_array_f tp_tx_array;     /* TX function for sending an array of
                                       packets. */
    bcm_pkt_l2_map_f tp_l2_map;     /* Map a packet's L2 information into a port
                                       bitmap. */
    int tp_unit;                    /* Default unit to use for allocation/free
                                       functions. */
} bcm_trans_ptr_t;

/* bcm_rx_chan_t */
typedef int bcm_rx_chan_t;

/* Standard BCM transport pointer structure. */
extern bcm_trans_ptr_t bcm_trans_ptr;

#define BCM_RX_REASON_NAMES_INITIALIZER _SHR_RX_REASON_NAMES_INITIALIZER 

/* 
 * PKT RX Packet Reasons; reason CPU received the packet.
 * 
 * It is possible no reasons are set (directed to CPU from ARL for
 * example), or multiple reasons may be set.
 */
typedef enum bcm_rx_reason_e {
    bcmRxReasonInvalid = _SHR_RX_INVALID, 
    bcmRxReasonArp = _SHR_RX_ARP, 
    bcmRxReasonBpdu = _SHR_RX_BPDU, 
    bcmRxReasonBroadcast = _SHR_RX_BROADCAST, 
    bcmRxReasonClassBasedMove = _SHR_RX_CLASS_BASED_MOVE, 
    bcmRxReasonClassTagPackets = _SHR_RX_CLASS_TAG_PACKETS, 
    bcmRxReasonControl = _SHR_RX_CONTROL, 
    bcmRxReasonCpuLearn = _SHR_RX_CPU_LEARN, 
    bcmRxReasonDestLookupFail = _SHR_RX_DEST_LOOKUP_FAIL, 
    bcmRxReasonDhcp = _SHR_RX_DHCP, 
    bcmRxReasonDosAttack = _SHR_RX_DOS_ATTACK, 
    bcmRxReasonE2eHolIbp = _SHR_RX_E2E_HOL_IBP, 
    bcmRxReasonEncapHigigError = _SHR_RX_ENCAP_HIGIG_ERROR, 
    bcmRxReasonFilterMatch = _SHR_RX_FILTER_MATCH, 
    bcmRxReasonGreChecksum = _SHR_RX_GRE_CHECKSUM, 
    bcmRxReasonGreSourceRoute = _SHR_RX_GRE_SOURCE_ROUTE, 
    bcmRxReasonHigigControl = _SHR_RX_HIGIG_CONTROL, 
    bcmRxReasonHigigHdrError = _SHR_RX_HIGIG_HDR_ERROR, 
    bcmRxReasonIcmpRedirect = _SHR_RX_ICMP_REDIRECT, 
    bcmRxReasonIgmp = _SHR_RX_IGMP, 
    bcmRxReasonIngressFilter = _SHR_RX_INGRESS_FILTER, 
    bcmRxReasonIp = _SHR_RX_IP, 
    bcmRxReasonIpfixRateViolation = _SHR_RX_IPFIX_RATE_VIOLATION, 
    bcmRxReasonIpMcastMiss = _SHR_RX_IP_MCAST_MISS, 
    bcmRxReasonIpmcReserved = _SHR_RX_IPMC_RSVD, 
    bcmRxReasonIpOptionVersion = _SHR_RX_IP_OPTION_VERSION, 
    bcmRxReasonIpmc = _SHR_RX_IPMC, 
    bcmRxReasonL2Cpu = _SHR_RX_L2_CPU, 
    bcmRxReasonL2DestMiss = _SHR_RX_L2_DEST_MISS, 
    bcmRxReasonL2LearnLimit = _SHR_RX_L2_LEARN_LIMIT, 
    bcmRxReasonL2Move = _SHR_RX_L2_MOVE, 
    bcmRxReasonL2MtuFail = _SHR_RX_L2_MTU_FAIL, 
    bcmRxReasonL2NonUnicastMiss = _SHR_RX_L2_NON_UNICAST_MISS, 
    bcmRxReasonL2SourceMiss = _SHR_RX_L2_SOURCE_MISS, 
    bcmRxReasonL3AddrBindFail = _SHR_RX_L3_ADDR_BIND_FAIL, 
    bcmRxReasonL3DestMiss = _SHR_RX_L3_DEST_MISS, 
    bcmRxReasonL3HeaderError = _SHR_RX_L3_HEADER_ERROR, 
    bcmRxReasonL3MtuFail = _SHR_RX_L3_MTU_FAIL, 
    bcmRxReasonL3Slowpath = _SHR_RX_L3_SLOW_PATH, 
    bcmRxReasonL3SourceMiss = _SHR_RX_L3_SOURCE_MISS, 
    bcmRxReasonL3SourceMove = _SHR_RX_L3_SOUCE_MOVE, 
    bcmRxReasonMartianAddr = _SHR_RX_MARTIAN_ADDR, 
    bcmRxReasonMcastIdxError = _SHR_RX_MCAST_IDX_ERROR, 
    bcmRxReasonMcastMiss = _SHR_RX_MCAST_MISS, 
    bcmRxReasonMimServiceError = _SHR_RX_MIM_SERVICE_ERROR, 
    bcmRxReasonMplsCtrlWordError = _SHR_RX_MPLS_CTRL_WORD_ERROR, 
    bcmRxReasonMplsError = _SHR_RX_MPLS_ERROR, 
    bcmRxReasonMplsInvalidAction = _SHR_RX_MPLS_INVALID_ACTION, 
    bcmRxReasonMplsInvalidPayload = _SHR_RX_MPLS_INVALID_PAYLOAD, 
    bcmRxReasonMplsLabelMiss = _SHR_RX_MPLS_LABEL_MISS, 
    bcmRxReasonMplsSequenceNumber = _SHR_RX_MPLS_SEQUENCE_NUMBER, 
    bcmRxReasonMplsTtl = _SHR_RX_MPLS_TTL, 
    bcmRxReasonMulticast = _SHR_RX_MULTICAST, 
    bcmRxReasonNhop = _SHR_RX_NHOP, 
    bcmRxReasonOAMError = _SHR_RX_OAM_ERROR, 
    bcmRxReasonOAMSlowpath = _SHR_RX_OAM_SLOW_PATH, 
    bcmRxReasonOAMLMDM = _SHR_RX_OAM_LMDM, 
    bcmRxReasonParityError = _SHR_RX_PARITY_ERROR, 
    bcmRxReasonProtocol = _SHR_RX_PROTOCOL, 
    bcmRxReasonSampleDest = _SHR_RX_SAMPLE_DEST, 
    bcmRxReasonSampleSource = _SHR_RX_SAMPLE_SOURCE, 
    bcmRxReasonSharedVlanMismatch = _SHR_RX_SHARED_VLAN_MISMATCH, 
    bcmRxReasonSourceRoute = _SHR_RX_SOURCE_ROUTE, 
    bcmRxReasonTimeStamp = _SHR_RX_TIME_STAMP, 
    bcmRxReasonTtl = _SHR_RX_TTL, 
    bcmRxReasonTtl1 = _SHR_RX_TTL1, 
    bcmRxReasonTunnelError = _SHR_RX_TUNNEL_ERROR, 
    bcmRxReasonUdpChecksum = _SHR_RX_UDP_CHECKSUM, 
    bcmRxReasonUnknownVlan = _SHR_RX_UNKNOWN_VLAN, 
    bcmRxReasonUrpfFail = _SHR_RX_URPF_FAIL, 
    bcmRxReasonVcLabelMiss = _SHR_RX_VC_LABEL_MISS, 
    bcmRxReasonVlanFilterMatch = _SHR_RX_VLAN_FILTER_MATCH, 
    bcmRxReasonWlanClientError = _SHR_RX_WLAN_CLIENT_ERROR, 
    bcmRxReasonWlanSlowpath = _SHR_RX_WLAN_SLOW_PATH, 
    bcmRxReasonWlanDot1xDrop = _SHR_RX_WLAN_DOT1X_DROP, 
    bcmRxReasonExceptionFlood = _SHR_RX_EXCEPTION_FLOOD, 
    bcmRxReasonTimeSync = _SHR_RX_TIMESYNC, 
    bcmRxReasonEAVData = _SHR_RX_EAV_DATA, 
    bcmRxReasonSamePortBridge = _SHR_RX_SAME_PORT_BRIDGE, 
    bcmRxReasonSplitHorizon = _SHR_RX_SPLIT_HORIZON, 
    bcmRxReasonL4Error = _SHR_RX_L4_ERROR, 
    bcmRxReasonStp = _SHR_RX_STP, 
    bcmRxReasonEgressFilterRedirect = _SHR_RX_EGRESS_FILTER_REDIRECT, 
    bcmRxReasonFilterRedirect = _SHR_RX_FILTER_REDIRECT, 
    bcmRxReasonLoopback = _SHR_RX_LOOPBACK, 
    bcmRxReasonVlanTranslate = _SHR_RX_VLAN_TRANSLATE, 
    bcmRxReasonMmrp = _SHR_RX_MMRP, 
    bcmRxReasonSrp = _SHR_RX_SRP, 
    bcmRxReasonTunnelControl = _SHR_RX_TUNNEL_CONTROL, 
    bcmRxReasonL2Marked = _SHR_RX_L2_MARKED, 
    bcmRxReasonWlanSlowpathKeepalive = _SHR_RX_WLAN_SLOWPATH_KEEPALIVE, 
    bcmRxReasonStation = _SHR_RX_STATION, 
    bcmRxReasonNiv = _SHR_RX_NIV, 
    bcmRxReasonNivPrioDrop = _SHR_RX_NIV_PRIO_DROP, 
    bcmRxReasonNivInterfaceMiss = _SHR_RX_NIV_INTERFACE_MISS, 
    bcmRxReasonNivRpfFail = _SHR_RX_NIV_RPF_FAIL, 
    bcmRxReasonNivTagInvalid = _SHR_RX_NIV_TAG_INVALID, 
    bcmRxReasonNivTagDrop = _SHR_RX_NIV_TAG_DROP, 
    bcmRxReasonNivUntagDrop = _SHR_RX_NIV_UNTAG_DROP, 
    bcmRxReasonTrill = _SHR_RX_TRILL, 
    bcmRxReasonTrillInvalid = _SHR_RX_TRILL_INVALID, 
    bcmRxReasonTrillMiss = _SHR_RX_TRILL_MISS, 
    bcmRxReasonTrillRpfFail = _SHR_RX_TRILL_RPF_FAIL, 
    bcmRxReasonTrillSlowpath = _SHR_RX_TRILL_SLOWPATH, 
    bcmRxReasonTrillCoreIsIs = _SHR_RX_TRILL_CORE_IS_IS, 
    bcmRxReasonTrillTtl = _SHR_RX_TRILL_TTL, 
    bcmRxReasonTrillName = _SHR_RX_TRILL_NAME, 
    bcmRxReasonBfdSlowpath = _SHR_RX_BFD_SLOWPATH, 
    bcmRxReasonBfd = _SHR_RX_BFD_ERROR, 
    bcmRxReasonMirror = _SHR_RX_MIRROR, 
    bcmRxReasonRegexAction = _SHR_RX_REGEX_ACTION, 
    bcmRxReasonRegexMatch = _SHR_RX_REGEX_MATCH, 
    bcmRxReasonFailoverDrop = _SHR_RX_FAILOVER_DROP, 
    bcmRxReasonWlanTunnelError = _SHR_RX_WLAN_TUNNEL_ERROR, 
    bcmRxReasonCongestionCnmProxy = _SHR_RX_CONGESTION_CNM_PROXY, 
    bcmRxReasonCongestionCnmProxyError = _SHR_RX_CONGESTION_CNM_PROXY_ERROR, 
    bcmRxReasonCongestionCnm = _SHR_RX_CONGESTION_CNM, 
    bcmRxReasonMplsUnknownAch = _SHR_RX_MPLS_UNKNOWN_ACH, 
    bcmRxReasonMplsLookupsExceeded = _SHR_RX_MPLS_LOOKUPS_EXCEEDED, 
    bcmRxReasonMplsReservedEntropyLabel = _SHR_RX_MPLS_RESERVED_ENTROPY_LABEL, 
    bcmRxReasonMplsIllegalReservedLabel = _SHR_RX_MPLS_ILLEGAL_RESERVED_LABEL, 
    bcmRxReasonMplsRouterAlertLabel = _SHR_RX_MPLS_ROUTER_ALERT_LABEL, 
    bcmRxReasonNivPrune = _SHR_RX_NIV_PRUNE, 
    bcmRxReasonVirtualPortPrune = _SHR_RX_VIRTUAL_PORT_PRUNE, 
    bcmRxReasonNonUnicastDrop = _SHR_RX_NON_UNICAST_DROP, 
    bcmRxReasonTrillPacketPortMismatch = _SHR_RX_TRILL_PACKET_PORT_MISMATCH, 
    bcmRxReasonWlanClientMove = _SHR_RX_WLAN_CLIENT_MOVE, 
    bcmRxReasonWlanSourcePortMiss = _SHR_RX_WLAN_SOURCE_PORT_MISS, 
    bcmRxReasonWlanClientSourceMiss = _SHR_RX_WLAN_CLIENT_SOURCE_MISS, 
    bcmRxReasonWlanClientDestMiss = _SHR_RX_WLAN_CLIENT_DEST_MISS, 
    bcmRxReasonWlanMtu = _SHR_RX_WLAN_MTU, 
    bcmRxReasonL2GreSipMiss = _SHR_RX_L2GRE_SIP_MISS, 
    bcmRxReasonL2GreVpnIdMiss = _SHR_RX_L2GRE_VPN_ID_MISS, 
    bcmRxReasonTimesyncUnknownVersion = _SHR_RX_TIMESYNC_UNKNOWN_VERSION, 
    bcmRxReasonBfdUnknownVersion = _SHR_RX_BFD_UNKNOWN_VERSION, 
    bcmRxReasonBfdInvalidVersion = _SHR_RX_BFD_INVALID_VERSION, 
    bcmRxReasonBfdLookupFailure = _SHR_RX_BFD_LOOKUP_FAILURE, 
    bcmRxReasonBfdInvalidPacket = _SHR_RX_BFD_INVALID_PACKET, 
    bcmRxReasonVxlanSipMiss = _SHR_RX_VXLAN_SIP_MISS, 
    bcmRxReasonVxlanVpnIdMiss = _SHR_RX_VXLAN_VPN_ID_MISS, 
    bcmRxReasonFcoeZoneCheckFail = _SHR_RX_FCOE_ZONE_CHECK_FAIL, 
    bcmRxReasonIpmcInterfaceMismatch = _SHR_RX_IPMC_INTERFACE_MISMATCH, 
    bcmRxReasonNat = _SHR_RX_NAT, 
    bcmRxReasonTcpUdpNatMiss = _SHR_RX_TCP_UDP_NAT_MISS, 
    bcmRxReasonIcmpNatMiss = _SHR_RX_ICMP_NAT_MISS, 
    bcmRxReasonNatFragment = _SHR_RX_NAT_FRAGMENT, 
    bcmRxReasonNatMiss = _SHR_RX_NAT_MISS, 
    bcmRxReasonOAMCCMSlowpath = _SHR_RX_OAM_CCM_SLOWPATH, 
    bcmRxReasonBHHOAM = _SHR_RX_BHH_OAM_PACKET, 
    bcmRxReasonCount = _SHR_RX_REASON_COUNT 
} bcm_rx_reason_t;

/* 
 * Macro to check if a reason (bcmRxReason*) is included in a set of
 * reasons (bcm_rx_reasons_t).
 * 
 * Returns:
 *   zero     => reason is not included in the set
 *   non-zero => reason is included in the set
 */
#define BCM_RX_REASON_GET(_reasons, _reason)  \
   _SHR_RX_REASON_GET(_reasons, _reason) 

/* 
 * Macro to add a reason (bcmRxReason*) to a set of reasons
 * (bcm_rx_reasons_t).
 */
#define BCM_RX_REASON_SET(_reasons, _reason)  \
   _SHR_RX_REASON_SET(_reasons, _reason) 

/* 
 * Macro to add all reasons (bcmRxReason*) to a set of reasons
 * (bcm_rx_reasons_t).
 */
#define BCM_RX_REASON_SET_ALL(_reasons)  \
   _SHR_RX_REASON_SET_ALL(_reasons) 

/* 
 * Macro to clear a reason (bcmRxReason*) from a set of reasons
 * (bcm_rx_reasons_t).
 */
#define BCM_RX_REASON_CLEAR(_reasons, _reason)  \
   _SHR_RX_REASON_CLEAR(_reasons, _reason) 

/* Macro to clear a set of reasons (bcm_rx_reasons_t). */
#define BCM_RX_REASON_CLEAR_ALL(_reasons)  \
   _SHR_RX_REASON_CLEAR_ALL(_reasons) 

/* Macro to check if a set of reasons (bcm_rx_reasons_t) is empty. */
#define BCM_RX_REASON_IS_NULL(_reasons)  \
   _SHR_RX_REASON_IS_NULL(_reasons) 

/* Macro to itterate over a set of reasons (bcm_rx_reasons_t). */
#define BCM_RX_REASON_ITER(_reasons, _reason)  \
   _SHR_RX_REASON_ITER(_reasons, _reason) 

/* 
 * Macro to count number of active reasons in a set of reasons
 * (bcm_rx_reasons_t).
 */
#define BCM_RX_REASON_COUNT(_reasons, count)  \
   _SHR_RX_REASON_COUNT(_reasons, count) 

/* Macro to compare two sets of reasons (bcm_rx_reasons_t). */
#define BCM_RX_REASON_EQ(_reasons1, _reasons2)  \
   _SHR_RX_REASON_EQ(_reasons1, _reasons2) 

/* Macro to negative compare two sets of reasons (bcm_rx_reasons_t). */
#define BCM_RX_REASON_NEQ(_reasons1, _reasons2)  \
   _SHR_RX_REASON_NEQ(_reasons1, _reasons2) 

/* 
 * Macro to perform logical AND operation on two sets of reasons
 * (bcm_rx_reasons_t).
 */
#define BCM_RX_REASON_AND(_reasons1, _reasons2)  \
   _SHR_RX_REASON_AND(_reasons1, _reasons2) 

/* 
 * Macro to perform logical OR operation on two sets of reasons
 * (bcm_rx_reasons_t).
 */
#define BCM_RX_REASON_OR(_reasons1, _reasons2)  \
   _SHR_RX_REASON_OR(_reasons1, _reasons2) 

/* 
 * Macro to perform logical XOR operation on two sets of reasons
 * (bcm_rx_reasons_t).
 */
#define BCM_RX_REASON_XOR(_reasons1, _reasons2)  \
   _SHR_RX_REASON_XOR(_reasons1, _reasons2) 

/* 
 * Macro to remove set of reasons2 (bcm_rx_reasons_t) from set of
 * reasons1 (bcm_rx_reasons_t).
 */
#define BCM_RX_REASON_REMOVE(_reasons1, _reasons2)  \
   _SHR_RX_REASON_REMOVE(_reasons1, _reasons2) 

/* Macro to negate two sets of reasons (bcm_rx_reasons_t). */
#define BCM_RX_REASON_NEGATE(_reasons1, _reasons2)  \
   _SHR_RX_REASON_NEGATE(_reasons1, _reasons2) 

#ifndef BCM_HIDE_DISPATCHABLE

/* Associate a policer to the specified set of reason codes. */
extern int bcm_rx_reasons_policer_set(
    int unit, 
    bcm_rx_reasons_t rx_reasons, 
    bcm_policer_t polid);

#endif /* BCM_HIDE_DISPATCHABLE */

/* 
 * Defines for priorities of registered PKT RX handlers. PKT RX handlers
 * are always called from highest priority to lowest priority until one
 * of the handlers returns rx_handled or rx_handled_owned.
 * 
 * When started, a default PKT RX handler is installed at PKT_RX_PRIO_MIN
 * that discards the packets.
 */
#define BCM_RX_PRIO_MIN         ((uint8)0) 
#define BCM_RX_PRIO_MAX         ((uint8)255) 

#define BCM_RX_INIT_DONE(unit)  (bcm_rx_cfg_get(unit, NULL) == 0) 

#ifndef BCM_HIDE_DISPATCHABLE

/* Initialize the RX software module for the given device. */
extern int bcm_rx_init(
    int unit);

/* Re-initialize the user level configuration for the RX module. */
extern int bcm_rx_cfg_init(
    int unit);

/* Start packet reception for the given device. */
extern int bcm_rx_start(
    int unit, 
    bcm_rx_cfg_t *cfg);

/* Stop the RX software module. */
extern int bcm_rx_stop(
    int unit, 
    bcm_rx_cfg_t *cfg);

/* Get the current configuration for the given device. */
extern int bcm_rx_cfg_get(
    int unit, 
    bcm_rx_cfg_t *cfg);

/* Boolean indication of whether RX is running on this device. */
extern int bcm_rx_active(
    int unit);

/* Register CPU bound packets scheduler. */
extern int bcm_rx_sched_register(
    int unit, 
    bcm_rx_sched_cb sched_cb);

/* Unregister CPU bound packets scheduler. */
extern int bcm_rx_sched_unregister(
    int unit);

/* Get next unit with cpu rx enabled. */
extern int bcm_rx_unit_next_get(
    int unit, 
    int *next_unit);

/* Get maximum cos queue number for the device. */
extern int bcm_rx_queue_max_get(
    int unit, 
    bcm_cos_queue_t *cosq);

/* 
 * Get number of packet takens available for the specific device/queue
 *                 BCM_RX_SCHED_ALL_PACKETS - queue doesn't limit number
 * of packets.
 */
extern int bcm_rx_queue_rate_limit_status_get(
    int unit, 
    bcm_cos_queue_t cosq, 
    int *packet_tokens);

/* 
 * Get number of packets awaiting processing in the specific device,
 * queue.
 */
extern int bcm_rx_queue_packet_count_get(
    int unit, 
    bcm_cos_queue_t cosq, 
    int *packet_count);

/* Register or unregister to receive callbacks for received packets. */
extern int bcm_rx_register(
    int unit, 
    const char *name, 
    bcm_rx_cb_f callback, 
    uint8 priority, 
    void *cookie, 
    uint32 flags);

/* Register or unregister to receive callbacks for received packets. */
extern int bcm_rx_unregister(
    int unit, 
    bcm_rx_cb_f callback, 
    uint8 priority);

/* 
 * Register a callback function to be called when a packet is received on
 * the specified CPU COS queue.
 */
extern int bcm_rx_queue_register(
    int unit, 
    const char *name, 
    bcm_cos_queue_t cosq, 
    bcm_rx_cb_f callback, 
    uint8 priority, 
    void *cookie, 
    uint32 flags);

/* Unregister CPU COS callback function. */
extern int bcm_rx_queue_unregister(
    int unit, 
    bcm_cos_queue_t cosq, 
    bcm_rx_cb_f callback, 
    uint8 priority);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_RX_COSQ_PACKET_TYPE_SWITCHED    0x1        
#define BCM_RX_COSQ_PACKET_TYPE_NON_UNICAST 0x2        
#define BCM_RX_COSQ_PACKET_TYPE_MIRROR      0x4        

#ifndef BCM_HIDE_DISPATCHABLE

/* Get number of packet to CPU COS queue mappings. */
extern int bcm_rx_cosq_mapping_size_get(
    int unit, 
    int *size);

/* Map packets to a CPU COS queue. */
extern int bcm_rx_cosq_mapping_set(
    int unit, 
    int index, 
    bcm_rx_reasons_t reasons, 
    bcm_rx_reasons_t reasons_mask, 
    uint8 int_prio, 
    uint8 int_prio_mask, 
    uint32 packet_type, 
    uint32 packet_type_mask, 
    bcm_cos_queue_t cosq);

/* Get packets to CPU COS queue mappings. */
extern int bcm_rx_cosq_mapping_get(
    int unit, 
    int index, 
    bcm_rx_reasons_t *reasons, 
    bcm_rx_reasons_t *reasons_mask, 
    uint8 *int_prio, 
    uint8 *int_prio_mask, 
    uint32 *packet_type, 
    uint32 *packet_type_mask, 
    bcm_cos_queue_t *cosq);

/* Unmap packets to a CPU COS queue. */
extern int bcm_rx_cosq_mapping_delete(
    int unit, 
    int index);

/* Get all supported reasons for CPU COS queue mapping. */
extern int bcm_rx_cosq_mapping_reasons_get(
    int unit, 
    bcm_rx_reasons_t *reasons);

/* Get all supported reasons for rx packets. */
extern int bcm_rx_reasons_get(
    int unit, 
    bcm_rx_reasons_t *reasons);

/* Assign a RX channel to a cosq. */
extern int bcm_rx_queue_channel_set(
    int unit, 
    bcm_cos_queue_t queue_id, 
    bcm_rx_chan_t chan_id);

/* Get the RX channel assigned to the given cosq. */
extern int bcm_rx_queue_channel_get(
    int unit, 
    bcm_cos_queue_t queue_id, 
    bcm_rx_chan_t *chan_id);

/* bcm_rx_channels_running */
extern int bcm_rx_channels_running(
    int unit, 
    uint32 *channels);

/* Allocate or deallocate a packet buffer as configured. */
extern int bcm_rx_alloc(
    int unit, 
    int pkt_size, 
    uint32 flags, 
    void **buf);

/* Allocate or deallocate a packet buffer as configured. */
extern int bcm_rx_free(
    int unit, 
    void *pkt_data);

/* Enqueue a data buffer to be freed later. */
extern int bcm_rx_free_enqueue(
    int unit, 
    void *pkt_data);

/* Set/get the overall packet rate for the given device. */
extern int bcm_rx_rate_set(
    int unit, 
    int pps);

/* Set/get the overall packet rate for the given device. */
extern int bcm_rx_rate_get(
    int unit, 
    int *pps);

/* 
 * Set/get the overall packet rate for the CPU that given device is
 * attached to.
 */
extern int bcm_rx_cpu_rate_set(
    int unit, 
    int pps);

/* 
 * Set/get the overall packet rate for the CPU that given device is
 * attached to.
 */
extern int bcm_rx_cpu_rate_get(
    int unit, 
    int *pps);

/* Set/get the burst size for the given device. */
extern int bcm_rx_burst_set(
    int unit, 
    int burst);

/* Set/get the burst size for the given device. */
extern int bcm_rx_burst_get(
    int unit, 
    int *burst);

/* Set/get the RX per-COS rate limiting value. */
extern int bcm_rx_cos_rate_set(
    int unit, 
    int cos, 
    int pps);

/* Set/get the RX per-COS rate limiting value. */
extern int bcm_rx_cos_rate_get(
    int unit, 
    int cos, 
    int *pps);

/* Set/get the per-COS burst setting. */
extern int bcm_rx_cos_burst_set(
    int unit, 
    int cos, 
    int burst);

/* Set/get the per-COS burst setting. */
extern int bcm_rx_cos_burst_get(
    int unit, 
    int cos, 
    int *burst);

/* Set/get the per-COS max queue length. */
extern int bcm_rx_cos_max_len_set(
    int unit, 
    int cos, 
    int max_q_len);

/* Set/get the per-COS max queue length. */
extern int bcm_rx_cos_max_len_get(
    int unit, 
    int cos, 
    int *max_q_len);

/* Clear all the RX configuration. */
extern int bcm_rx_clear(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize a BCM RX configuration structure. */
extern void bcm_rx_cfg_t_init(
    bcm_rx_cfg_t *rx_cfg);

#if defined(BCM_RPC_SUPPORT) || defined(BCM_RCPU_SUPPORT)
#define BCM_RX_PKTLIST_COUNT_DEFAULT    64         
#endif

#if defined(BCM_RPC_SUPPORT) || defined(BCM_RCPU_SUPPORT)
/* bcm_rx_pktlist_count */
extern int bcm_rx_pktlist_count;
#endif

#if defined(BCM_RPC_SUPPORT) || defined(BCM_RCPU_SUPPORT)
/* bcm_rx_remote_pkt_alloc */
extern int bcm_rx_remote_pkt_alloc(
    int len, 
    bcm_pkt_t **pkt);
#endif

#if defined(BCM_RPC_SUPPORT) || defined(BCM_RCPU_SUPPORT)
/* bcm_rx_remote_pkt_free */
extern int bcm_rx_remote_pkt_free(
    bcm_pkt_t *pkt);
#endif

#ifndef BCM_HIDE_DISPATCHABLE

/* bcm_rx_remote_pkt_enqueue */
extern int bcm_rx_remote_pkt_enqueue(
    int unit, 
    bcm_pkt_t *pkt);

#if defined(BROADCOM_DEBUG)
/* bcm_rx_show */
extern int bcm_rx_show(
    int unit);
#endif

#endif /* BCM_HIDE_DISPATCHABLE */

/* 
 * RX Pool
 * 
 * RX Pool is not really a true API, but an implementation of an
 * efficient buffer management scheme. RX uses the RX Pool allocation and
 * free routines as the default, and the application is free to change
 * them.
 */

/* Set up the RX pool software module. */
extern int bcm_rx_pool_setup(
    int pkt_count, 
    int bytes_per_pkt);

/* Boolean indication of whether the RX pool module is currently set up. */
extern int bcm_rx_pool_setup_done(
    void );

/* Deallocate RX pool structures. */
extern int bcm_rx_pool_cleanup(
    void );

/* Allocate a buffer from RX pool. */
extern int bcm_rx_pool_alloc(
    int unit, 
    int size, 
    uint32 flags, 
    void **pool);

/* Deallocate a buffer allocated with =bcm_rx_pool_alloc. */
extern int bcm_rx_pool_free(
    int unit, 
    void *buf);

#if defined(BCM_RXP_DEBUG)
/* Display information on RX pool buffer status. */
extern void bcm_rx_pool_dump(
    int min, 
    int max);
#endif

#if defined(BCM_RXP_DEBUG)
/* Verify the RX pool free buffer list. */
extern void bcm_rx_pool_free_verify(void);
#endif

#if defined(BCM_RXP_DEBUG)
/* Indicate ownership of an RX pool buffer. */
extern void bcm_rx_pool_own(
    void *buf, 
    void *owner);
#endif

#if defined(BCM_RXP_DEBUG)
/* Send RX pool debugging information to an output stream. */
extern void bcm_rx_pool_report(
    int min, 
    int max);
#endif

typedef enum bcm_rx_control_e {
    bcmRxControlCRCStrip = 0,       /* Strip CRC from packets. */
    bcmRxControlVTagStrip = 1,      /* Strip VLAN tag from packets. */
    bcmRxControlRateStall = 2,      /* Use stall instead of discard. */
    bcmRxControlMultiDCB = 3,       /* Scatter data with multiple DCBs. */
    bcmRxControlOversizedOK = 4,    /* Accept packets larger than bufsize. */
    bcmRxControlIgnoreHGHeader = 5, /* Force HiGig Header into packet for fabric
                                       device. */
    bcmRxControlIgnoreSLHeader = 6, /* Force SL tag into packet on SL stacking. */
    bcmRxControlTmSnoopCount = 7    /* Indicate the number of snoop commands
                                       used for Traffic Management (TM)
                                       processing. */
} bcm_rx_control_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Get RX operating modes. */
extern int bcm_rx_control_get(
    int unit, 
    bcm_rx_control_t type, 
    int *arg);

/* Configure RX operating modes. */
extern int bcm_rx_control_set(
    int unit, 
    bcm_rx_control_t type, 
    int arg);

#endif /* BCM_HIDE_DISPATCHABLE */

typedef enum bcm_rx_redirect_e {
    bcmRxRedirectNormal = _SHR_RX_REDIRECT_NORMAL, /* Rx redirect reasons for normal
                                           packets. */
    bcmRxRedirectHigig = _SHR_RX_REDIRECT_HIGIG, /* Rx redirect reasons for higig
                                           packets. */
    bcmRxRedirectTruncated = _SHR_RX_REDIRECT_TRUNCATED /* Rx redirect reasons for truncated
                                           packets. */
} bcm_rx_redirect_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Get mode specific configured redirection reasons for rx packets. */
extern int bcm_rx_redirect_reasons_get(
    int unit, 
    bcm_rx_redirect_t mode, 
    bcm_rx_reasons_t *reasons);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Return values from PKT RX callout routines. */
typedef enum bcm_rx_trap_e {
    bcmRxTrapMimDiscardMacsaFwd = 0,    /* Triggered by port control
                                           bcmPortControlDiscardMacsaAction with
                                           BCM_PORT_CONTROL_DISCARD_MACSA_FWD. */
    bcmRxTrapMimDiscardMacsaDrop = 1,   /* Triggered by port control
                                           bcmPortControlDiscardMacsaAction with
                                           BCM_PORT_CONTROL_DISCARD_MACSA_DROP. */
    bcmRxTrapMimDiscardMacsaTrap = 2,   /*  Triggered by port control
                                           bcmPortControlDiscardMacsaAction with
                                           BCM_PORT_CONTROL_DISCARD_MACSA_TRAP. */
    bcmRxTrapMimDiscardMacsaSnoop = 3,  /* Triggered by port control
                                           bcmPortControlDiscardMacsaAction with
                                           BCM_PORT_CONTROL_DISCARD_MACSA_SNOOP. */
    bcmRxTrapMimTeSaMove = 4,           /*  Packet's BVID is in TE-BVID range,
                                           SA lookup succeeds, butSystem Port ID
                                           of SA lookup is different from source
                                           system Port ID. */
    bcmRxTrapMimTeSaUnknown = 5,        /*  Packet's BVID is in TE-BVID range,
                                           SA lookup fails. */
    bcmRxTrapMimSaMove = 6,             /* Packet's BVID is not in TE-BVID
                                           range, SA lookup succeeds. */
    bcmRxTrapMimSaUnknown = 7,          /* Packet's BVID is not in TE-BVID
                                           range, SA lookup fails. */
    bcmRxTrapAuthSaLookupFail = 8,      /* SA authentication fails: SA lookup
                                           fails. */
    bcmRxTrapAuthSaPortFail = 9,        /* SA authentication fails: SA lookup
                                           succeeds in an unpermitted port. */
    bcmRxTrapAuthSaVlanFail = 10,       /* SA authentication fails: SA lookup
                                           succeeds in an unpermitted VLAN. */
    bcmRxTrapSaMulticast = 11,          /* SA is multicast. */
    bcmRxTrapSaEqualsDa = 12,           /* SA equals DA. */
    bcmRxTrap8021xFail = 13,            /* 8021x authentication fails. */
    bcmRxTrapArpMyIp = 14,              /* If InPort is enabled for ARP trapping
                                           AND ARP request TPA is equal to My-IP
                                           (two configurable IP addresses). */
    bcmRxTrapArp = 15,                  /* ARP Request incoming on InPort which
                                           is enabled for ARP trapping. If DA is
                                           set to be ignored for ARP replies,
                                           ARP replies are also trapped with
                                           this trap code. */
    bcmRxTrapIgmpMembershipQuery = 16,  /* Packet is IGMP and first octet in the
                                           IGMP payload is 0x11. */
    bcmRxTrapIgmpReportLeaveMsg = 17,   /* Packet is IGMP and first octet in the
                                           IGMP payload is 0x12, 0x16, 0x17, or
                                           0x22. */
    bcmRxTrapIgmpUndefined = 18,        /* Packet is IGMP and first octet in the
                                           IGMP payload is not 0x11, 0x12, 0x16,
                                           0x17, or 0x22. */
    bcmRxTrapIcmpv6MldMcListenerQuery = 19, /* . */
    bcmRxTrapL2Cache = 20,              /* Triggered by  bcm_l2_cache_set 
                                           entry. */
    bcmRxTrapDhcpv6Server = 21,         /* DHCP packet sent to server over
                                           IPv6oE. */
    bcmRxTrapDhcpv6Client = 22,         /* DHCP packet sent to client over
                                           IPv6oE. */
    bcmRxTrapPortNotVlanMember = 23,    /*  Initial VID membership error. */
    bcmRxTrapHeaderSizeErr = 24,        /* Parser indicates header size error. */
    bcmRxTrapMyBmacUknownTunnel = 25,   /* BSA lookup fail and (BDA = My-BDA). */
    bcmRxTrapMyBmacUnknownISid = 26,    /*   Unknown I-SID. */
    bcmRxTrapStpStateBlock = 27,        /* Packet ingresses on a blocked port.
                                           Note - BPDU will be forwarded with
                                           strength 6. */
    bcmRxTrapStpStateLearn = 28,        /* Packet ingresses a port in a LEARN
                                           state. */
    bcmRxTrapIpCompMcInvalidIp = 29,    /*   L2 compatible MC, but IP does not
                                           match. */
    bcmRxTrapMyMacAndIpDisabled = 30,   /*   Terminated My-MAC over IP, but
                                           routing is disabled for InRIF. */
    bcmRxTrapTrillVersion = 31,         /* Invalid TRILL version. */
    bcmRxTrapTrillTtl0 = 32,            /* Invalid TRILL TTL. */
    bcmRxTrapTrillChbh = 33,            /* Unsupported TRILL option flags. */
    bcmRxTrapTrillUnknonwnIngressNickname = 34, /* Unknown ingress nickname. */
    bcmRxTrapTrillCite = 35,            /* Unsupported TRILL options flags. */
    bcmRxTrapTrillIllegalInnerMc = 36,  /*  Invalid packet format. */
    bcmRxTrapMyMacAndMplsDisable = 37,  /* Terminated My-MAC over MPLS, but MPLS
                                           is disabled for InRIF. */
    bcmRxTrapArpReply = 38,             /* ARP reply to My-MAC. */
    bcmRxTrapMyMacAndUnknownL3 = 39,    /* Terminated My-MAC but L3 protocol is
                                           unknown. */
    bcmRxTrapMplsLabel0150 = 40,        /* Triggerd by MPLS labels 0-15
                                           forwarding Trap Code. */
    bcmRxTrapMplsLabel0151 = 41,        /* Triggerd by MPLS labels 0-15
                                           forwarding Trap Code. */
    bcmRxTrapMplsLabel0152 = 42,        /* Triggerd by MPLS labels 0-15
                                           forwarding Trap Code. */
    bcmRxTrapMplsLabel0153 = 43,        /* Triggerd by MPLS labels 0-15
                                           forwarding Trap Code. */
    bcmRxTrapMplsTerminationFail = 44,  /* MPLS already terminated twice by
                                           label range match. Additional labels
                                           may not be terminated by Label range
                                           match. */
    bcmRxTrapMplsUnexpectedBos = 45,    /* Terminated MPLS label indicates that
                                           another MPLS shim is to follow,
                                           however the terminated label is BOS. */
    bcmRxTrapMplsUnexpectedNoBos = 46,  /* Reserved MPLS label (0.15) is mapped
                                           to this action by
                                           ppd_mpls_term_reserved_label_info_set(). */
    bcmRxTrapCfmAcceleratedIngress = 47, /* ITU Y.1731 packet observed (CFM). */
    bcmRxTrapIllegelPacketFormat = 48,  /* Parser failure. */
    bcmRxTrapL2DiscardMacsaFwd = 49,    /* Triggered by contorl
                                           bcmPortControlDiscardMacsaAction with
                                            BCM_PORT_CONTROL_DISCARD_MACSA_FWD. */
    bcmRxTrapL2DiscardMacsaDrop = 50,   /* Triggered by contorl
                                           bcmPortControlDiscardMacsaAction with
                                            BCM_PORT_CONTROL_DISCARD_MACSA_FWD . */
    bcmRxTrapL2DiscardMacsaTrap = 51,   /* Triggered by contorl
                                           bcmPortControlDiscardMacsaAction with
                                            BCM_PORT_CONTROL_DISCARD_MACSA_DROP. */
    bcmRxTrapL2DiscardMacsaSnoop = 52,  /* Triggered by contorl
                                           bcmPortControlDiscardMacsaAction with
                                            BCM_PORT_CONTROL_DISCARD_MACSA_TRAP. */
    bcmRxTrapL2Learn0 = 53,             /* Triggeerd by bcm_port_learn_set with
                                           flag =
                                           BCM_PORT_LEARN_ARL|BCM_PORT_LEARN_FWD. */
    bcmRxTrapL2Learn1 = 54,             /* Triggeerd by bcm_port_learn_set with
                                           flag =
                                           BCM_PORT_LEARN_CPU|BCM_PORT_LEARN_FWD. */
    bcmRxTrapL2Learn2 = 55,             /* Triggeerd by bcm_port_learn_set with
                                           flag = BCM_PORT_LEARN_ARL. */
    bcmRxTrapL2Learn3 = 56,             /* Triggeerd by bcm_port_learn_set with
                                           flag = BCM_PORT_LEARN_FWD |
                                           BCM_PORT_LEARN_CPU. */
    bcmRxTrapVlanUnknownDa = 57,        /* Per VLAN/VSI 8 flooding profiled can
                                           be set for unknown packets. These
                                           Trap code define the flloding
                                           profile. The flooding multicast group
                                           is teh VLAN/VSI base flooding group +
                                           the flooding offset. */
    bcmRxTrapExternalLookupError = 58,  /* ELK is accessed and returns an error. */
    bcmRxTrapL2DlfFwd = 59,             /* per port trap when DA is not found,
                                           see bcmPortControlUnknownMacDaAction
                                           BCM_PORT_CONTROL_UNKNOWN_MACDA_FWD. */
    bcmRxTrapL2DlfDrop = 60,            /* BCM_PORT_CONTROL_UNKNOWN_MACDA_DROP. */
    bcmRxTrapL2DlfTrap = 61,            /* BCM_PORT_CONTROL_UNKNOWN_MACDA_TRAP. */
    bcmRxTrapL2DlfSnoop = 62,           /* BCM_PORT_CONTROL_UNKNOWN_MACDA_SNOOP. */
    bcmRxTrapExtendedP2pLookupFail = 63, /* Transparent P2P Lookup key is not
                                           found in the ELK/LEM. */
    bcmRxTrapSameInterface = 64,        /* Source interface is equal to
                                           destination interface (hair-pin). */
    bcmRxTrapTrillUnknownUc = 65,       /* Forwarding Code is TRILL, lookup key
                                           is not found in ELK/LEM. */
    bcmRxTrapTrillUnknownMc = 66,       /* Forwarding Code is TRILL, lookup key
                                           is not found in ELK/LEM. */
    bcmRxTrapUcLooseRpfFail = 67,       /* Forwarding Code is IPv4 UC and RPF
                                           FEC Pointer Valid is not set. */
    bcmRxTrapDefaultUcv6 = 68,          /* IPv6 UC default forwarding. */
    bcmRxTrapDefaultMcv6 = 69,          /* IPv6 MC default forwarding. */
    bcmRxTrapMplsP2pNoBos = 70,         /* Lookup key is found in ELK/LEM,
                                           P2P-Service If lookup result is set,
                                           and header is not BOS.. */
    bcmRxTrapMplsControlWordTrap = 71,  /* Lookup key is found in ELK/LEM,
                                           P2P-Service If lookup result is set,
                                           lookup result determines that there's
                                           a control word, nibble after MPLS
                                           stack equal '1'. */
    bcmRxTrapMplsControlWordDrop = 72,  /* Lookup key is found in ELK/LEM,
                                           P2P-Service If lookup result is set,
                                           lookup result determines that there's
                                           a control word, nibble after MPLS
                                           stack does not equal '1' or '0'. */
    bcmRxTrapMplsUnknownLabel = 73,     /* Lookup key is not found in ELK/LEM. */
    bcmRxTrapMplsExtendP2pMplsx4 = 74,  /* Extended P2P service with 4 MPLS
                                           labels. */
    bcmRxTrapFrwrdIgmpMembershipQuery = 75, /* Forwarded packet is IGMP and first
                                           octet in the IGMP payload is 0x11. */
    bcmRxTrapFrwrdIgmpReportLeaveMsg = 76, /* Forwarded packet is IGMP and first
                                           octet in the IGMP payload is 0x12,
                                           0x16, 0x17, or 0x22. */
    bcmRxTrapFrwrdIgmpUndefined = 77,   /* Forwarded packet is IGMP and first
                                           octet in the IGMP payload is not
                                           0x11, 0x12, 0x16, 0x17, or 0x22. */
    bcmRxTrapFrwrdIcmpv6MldMcListenerQuery = 78, /* Forwarded packet is ICMPv6 with an
                                           MLD type, IPv6 packet with IP
                                           protocol 58 and the ICMPv6 type is
                                           130. */
    bcmRxTrapFrwrdIcmpv6MldReportDone = 79, /* Forwarded packet is ICMPv6 with an
                                           MLD type, IPv6 packet with IP
                                           protocol 58 and the ICMPv6 type is
                                           131,132 or 143. */
    bcmRxTrapFrwrdIcmpv6MldUndefined = 80, /* Forwarded packet is ICMPv6 with an
                                           MLD type, IPv6 packet with IP
                                           protocol 58 and the ICMPv6 type is
                                           other than 130,131,132 or 143. */
    bcmRxTrapIpv4VersionError = 81,     /* Version is different than 4. */
    bcmRxTrapIpv4ChecksumError = 82,    /*  IHL is 5 and the checksum over the
                                           first 20 bytes doesn't verify. */
    bcmRxTrapIpv4HeaderLengthError = 83, /* IHL (Internet Header Length) is less
                                           than 5. */
    bcmRxTrapIpv4TotalLengthError = 84, /* Total length is less than 20. */
    bcmRxTrapIpv4Ttl0 = 85,             /* TTL is equal to 0. */
    bcmRxTrapIpv4HasOptions = 86,       /* IHL (Internet Header Length) is
                                           greater than 5. */
    bcmRxTrapIpv4Ttl1 = 87,             /* In-TTL is 0. */
    bcmRxTrapIpv4SipEqualDip = 88,      /* Source-IP is equal to destination IP. */
    bcmRxTrapIpv4DipZero = 89,          /* Destination IP is 0. */
    bcmRxTrapIpv4SipIsMc = 90,          /* Source-IP is multicast. */
    bcmRxTrapIpv4TunnelTerminationAndFragmented = 91, /* Fragmented  IPv4 packet over an IPv4
                                           tunnel. */
    bcmRxTrapIpv6VersionError = 92,     /* Version is different than 6. */
    bcmRxTrapIpv6HopCount0 = 93,        /* Hop count (TTL) is 0. */
    bcmRxTrapIpv6HopCount1 = 94,        /* Hop count (TTL) is 1. */
    bcmRxTrapIpv6UnspecifiedDestination = 95, /* Forwarding header DIP = ::. */
    bcmRxTrapIpv6LoopbackAddress = 96,  /* DIP = ::1 or SIP = ::1. */
    bcmRxTrapIpv6MulticastSource = 97,  /* The MSB of the SIP = 0xFF. */
    bcmRxTrapIpv6NextHeaderNull = 98,   /* Next-protocol is zero. */
    bcmRxTrapIpv6UnspecifiedSource = 99, /* SIP = ::. */
    bcmRxTrapIpv6LocalLinkDestination = 100, /* Bits 127:118 of the destination-IP
                                           are equal to 0x3FA. */
    bcmRxTrapIpv6LocalSiteDestination = 101, /* Bits 127:118 of the DIP = 0x3FB
                                           (deprecated). */
    bcmRxTrapIpv6LocalLinkSource = 102, /* Bits 127:118 of the SIP = 0x3FA. */
    bcmRxTrapIpv6LocalSiteSource = 103, /* Bits 127:118 of the SIP = 0x3FB. */
    bcmRxTrapIpv6Ipv4CompatibleDestination = 104, /* Bits 127:32 of the DIP = 0. */
    bcmRxTrapIpv6Ipv4MappedDestination = 105, /* Bits 127:32 of the DIP are equal to
                                           0000_FFF_0000_0000_0000_0000. */
    bcmRxTrapIpv6MulticastDestination = 106, /* MSB of the DIP=0xFF. */
    bcmRxTrapMplsTtl0 = 107,            /* TTL is equal to 0. */
    bcmRxTrapMplsTtl1 = 108,            /* TTL is equal to 1. */
    bcmRxTrapTcpSnFlagsZero = 109,      /* L4 Sequence-Number and Flags (6) are
                                           both zero. */
    bcmRxTrapTcpSnZeroFlagsSet = 110,   /* L4 Sequence-Number is zero and either
                                           Flags. FIN, Flags. URG or FLAGS. PSH
                                           are set. */
    bcmRxTrapTcpSynFin = 111,           /* Both Flags. SYN and Flags. FIN are
                                           set. */
    bcmRxTrapTcpEqualPorts = 112,       /* Source-Port equals Destination-Port. */
    bcmRxTrapTcpFragmentIncompleteHeader = 113, /* L3 is IPv4 and IP-Header. Fragmented
                                           and IP-Header. Fragment-Offset zero
                                           and (IPv4-Header. Total-Length - 4 *
                                           IPv4-Header. IHL) is less than 20B. */
    bcmRxTrapTcpFragmentOffsetLt8 = 114, /* L3 is IPv4 and IP-Header. Fragmented
                                           and IP-Header. Fragment-Offset is
                                           less than 8. */
    bcmRxTrapUdpEqualPorts = 115,       /* Source-Port equals Destination-Port. */
    bcmRxTrapIcmpDataGt576 = 116,       /* L3 is IPv4 and (IPv4-Header.
                                           Total-Length - 4* IPv4-Header. IHL)
                                           is greater than 576B or layer-3 is
                                           IPv6 and IPv6-Header. Payload-Length
                                           is greater than 576B. */
    bcmRxTrapIcmpFragmented = 117,      /* IP-Header. Fragmented is set. */
    bcmRxTrapFailoverFacilityInvalid = 118, /* Both Destination-0-Valid and
                                           Destination-1-Valid are not set. */
    bcmRxTrapUcStrictRpfFail = 119,     /* UC-RPF-Mode is 'Strict' and OutRIF is
                                           not equal to packet InRIF . */
    bcmRxTrapMcExplicitRpfFail = 120,   /* RPF-Entry. Expected-InRIF is not
                                           equal to packet InRIF Relevant when
                                           FEC-Entry. MC-RPF-Mode is 'Explicit'. */
    bcmRxTrapMcUseSipRpfFail = 121,     /* Out-RIF is not equal to In-RIF when
                                           MC-RPF-Mode is 'Use-SIP-WITH-ECMP'
                                           Note: . */
    bcmRxTrapMcUseSipMultipath = 122,   /* Found RPF-ECMP-Group-Size > '1'
                                           Relevant when MC-RPF-Mode is
                                           'Use-SIP'. */
    bcmRxTrapIcmpRedirect = 123,        /* ICMP-Redirect is enabled,
                                           Forwarding-Code is IPv4|6-UC, and
                                           packet InRIF is equal to FEC-Entry.
                                           OutRIF. */
    bcmRxTrapOamp = 124,                /* . */
    bcmRxTrapOampTrapErr = 125,         /* Packet arrived to the OAMP with
                                           illegal trap code. */
    bcmRxTrapOampTypeErr = 126,         /* Packet arrived to the OAMP with
                                           illegal mep type. */
    bcmRxTrapOampRmepErr = 127,         /* Packet arrived to the OAMP with RMEP
                                           index miss. */
    bcmRxTrapOampMaidErr = 128,         /* Packet arrived to the OAMP with MAID
                                           miss. */
    bcmRxTrapOampMdlErr = 129,          /* Packet arrived to the OAMP with MDL
                                           miss. */
    bcmRxTrapOampCcmIntrvErr = 130,     /* Packet arrived to the OAMP with CCM
                                           interval miss. */
    bcmRxTrapOampMyDiscErr = 131,       /* Packet arrived to the OAMP with My
                                           Discriminator miss (BFD). */
    bcmRxTrapOampSrcIpErr = 132,        /* Packet arrived to the OAMP with
                                           source IP address miss (BFD). */
    bcmRxTrapOampYourDiscErr = 133,     /* Packet arrived to the OAMP with Your
                                           Discriminator miss (BFD). */
    bcmRxTrapOampSrcPortErr = 134,      /* Packet arrived to the OAMP with UDP
                                           source port miss (BFD). */
    bcmRxTrapOampRmepStateChange = 135, /* BFD packet arrived that does not
                                           match the current RMEP state. */
    bcmRxTrapOampParityErr = 136,       /* Parity error occurred in the OAMP. */
    bcmRxTrapOampTimestampErr = 137,    /* Packet arrived to the OAMP with
                                           timestamp miss. */
    bcmRxTrapOampProtection = 138,      /* OAMP protection packet. */
    bcmRxTrapOamEthAccelerated = 139,   /* . */
    bcmRxTrapOamMplsAccelerated = 140,  /* In T20E this trap code cannot be used
                                           in
                                           ppd_trap_frwrd_profile_info_set(),ppd_trap_snoop*_profile_info_set()
                                           as trap_ndx, it's only used as
                                           Trap-code in the packet header. */
    bcmRxTrapOamBfdIpTunnelAccelerated = 141, /* . */
    bcmRxTrapOamBfdPweAccelerated = 142, /* . */
    bcmRxTrapOamEthUpAccelerated = 143, /* . */
    bcmRxTrapEgPortNotVlanMember = 144, /* egress vlan membership. */
    bcmRxTrapEgHairPinFilter = 145,     /* . */
    bcmRxTrapEgSplitHorizonFilter = 146, /* . */
    bcmRxTrapEgUnknownDa = 147,         /* uc unknown DA. */
    bcmRxTrapEgMtuFilter = 148,         /* packet size > mtu. */
    bcmRxTrapEgPvlanFilter = 149,       /* private vlan filter. */
    bcmRxTrapEgDiscardFrameTypeFilter = 150, /* not acceptable frame type on port
                                           (tagged, untagged). */
    bcmRxTrapEgTrillHairPinFilter = 151, /* trill same in/out interface. */
    bcmRxTrapEgTrillBounceBack = 152,   /* prevent bounce back of trill
                                           terminated unicast packets by the
                                           egress router bridge in case of a DA
                                           not found. */
    bcmRxTrapEgTrillTtl0 = 153,         /* trill invalid ttl (egress). */
    bcmRxTrapEgIpmcTtlErr = 154,        /* IPv4 MC packet with invalid ttl. */
    bcmRxTrapEgCfmAccelerated = 155,    /* CFM packet at egress. */
    bcmRxTrapDssStacking = 156,         /* Trap according to Dss stacking denail
                                           (history Bitmap). */
    bcmRxTrapLagMulticast = 157,        /* Trap Lag Multicast Packets. */
    bcmRxTrapExEgCnm = 158,             /* CNM packet. */
    bcmRxTrapTrillDesignatedVlanNoMymac = 159, /* EoTrilloE packet is not designtated
                                           vlan but with my-mac, or designated
                                           vlan but without my-mac. Disable
                                           bridging for such packets. */
    bcmRxTrapAdjacentCheckFail = 160,   /* TRILL adjacent check fail. */
    bcmRxTrapFcoeSrcIdMismatchSa = 161, /* FCoE, where FC.SrC is mismatch
                                           Eth.SA. */
    bcmRxTrapSipMove = 162,             /* sip transplant. */
    bcmRxTrapOamY1731MplsTp = 163,      /* . */
    bcmRxTrapOamY1731Pwe = 164,         /* . */
    bcmRxTrapOamBfdIpv4 = 165,          /* . */
    bcmRxTrapOamBfdMpls = 166,          /* . */
    bcmRxTrapOamBfdPwe = 167,           /* . */
    bcmRxTrapOamBfdCcMplsTp = 168,      /* . */
    bcmRxTrapOamBfdCvMplsTp = 169,      /* . */
    bcmRxTrapOamLevel = 170,            /* OAM packet with mdlevel below highest
                                           MEP on active side. */
    bcmRxTrapOamPassive = 171,          /* OAM packet equal or below highest MEP
                                           level on passive side. */
    bcmRxTrap1588 = 172,                /* 1588 protocol packet. */
    bcmRxTrapMplsLabelIndexNoSupport = 173, /* No support to forward according to
                                           MPLS forth label. */
    bcmRxTrapDhcpv4Client = 174,        /* DHCP packet sent to client over
                                           IPv4oE. */
    bcmRxTrapDhcpv4Server = 175,        /* DHCP packet sent to server over
                                           IPv4oE. */
    bcmRxTrapEtherIpVersion = 176,      /* IPv4 version error, for
                                           IPv4oEtheroIPv4oEth packet. */
    bcmRxTrapEgressObjectAccessed = 177, /* Egress object entry was accessed due
                                           to packet lookup. */
    bcmRxTrapIcmpv6MldReportDone = 178, /* ICMPv6 packet with an MLD with done
                                           message. */
    bcmRxTrapIcmpv6MldUndefined = 179,  /* ICMPv6 packet with an MLD with other
                                           message. */
    bcmRxTrapFailover1Plus1Fail = 180,  /* 1 plus 1 protected LIF and failover
                                           status is down. */
    bcmRxTrapEgInvalidDestPort = 181,   /* Egress trap: Invalid out port number. */
    bcmRxTrapEgIpv4VersionError = 182,  /* Egress trap: Version is different
                                           than 4.. */
    bcmRxTrapEgIpv4ChecksumError = 183, /* Egress trap: IHL is 5 and the
                                           checksum over the first 20 bytes
                                           doesn't verify. */
    bcmRxTrapEgIpv4HeaderLengthError = 184, /* Egress trap: IHL (Internet Header
                                           Length) is less than 5. */
    bcmRxTrapEgIpv4TotalLengthError = 185, /* Egress trap: Total length is less
                                           than 20. */
    bcmRxTrapEgIpv4Ttl0 = 186,          /* Egress trap: TTL is equal to 0. */
    bcmRxTrapEgIpv4HasOptions = 187,    /* Egress trap: IHL (Internet Header
                                           Length) is greater than 5. */
    bcmRxTrapEgIpv4Ttl1 = 188,          /* Egress trap: In-TTL is 0. */
    bcmRxTrapEgIpv4SipEqualDip = 189,   /* Egress trap: Source-IP is equal to
                                           destination IP. */
    bcmRxTrapEgIpv4DipZero = 190,       /* Egress trap: Destination IP is 0. */
    bcmRxTrapEgIpv4SipIsMc = 191,       /* Egress trap: Source-IP is multicast. */
    bcmRxTrapEgIpv6UnspecifiedDestination = 192, /* Egress trap: Forwarding header DIP =
                                           ::. */
    bcmRxTrapEgIpv6LoopbackAddress = 193, /* Egress trap: DIP = ::1 or SIP = ::1. */
    bcmRxTrapEgIpv6MulticastSource = 194, /* Egress trap: The MSB of the SIP =
                                           0xFF. */
    bcmRxTrapEgIpv6UnspecifiedSource = 195, /* Egress trap: SIP = ::. */
    bcmRxTrapEgIpv6LocalLinkDestination = 196, /* Egress trap: Bits 127:118 of the
                                           destination-IP are equal to 0x3FA. */
    bcmRxTrapEgIpv6LocalSiteDestination = 197, /* Egress trap: Bits 127:118 of the DIP
                                           = 0x3FB (deprecated). */
    bcmRxTrapEgIpv6LocalLinkSource = 198, /* Egress trap: Bits 127:118 of the SIP
                                           = 0x3FA. */
    bcmRxTrapEgIpv6LocalSiteSource = 199, /* Egress trap: Bits 127:118 of the SIP
                                           = 0x3FB. */
    bcmRxTrapEgIpv6Ipv4CompatibleDestination = 200, /* Egress trap: Bits 127:32 of the DIP =
                                           0. */
    bcmRxTrapEgIpv6Ipv4MappedDestination = 201, /* Egress trap: Bits 127:32 of the DIP
                                           are equal to
                                           0000_FFF_0000_0000_0000_0000. */
    bcmRxTrapEgIpv6MulticastDestination = 202, /* Egress trap: MSB of the DIP=0xFF. */
    bcmRxTrapEgIpv6NextHeaderNull = 203, /* Egress trap: Next-protocol is zero. */
    bcmRxTrapUserDefine = 204,          /* User define traps. */
    bcmRxTrapArpIPUnknown = 205,        /* ARP request with unknown host
                                           address. */
    bcmRxTrapFcoeZoneCheckFail = 206,   /* Fcoe zone check failed. */
    bcmRxTrapArplookupFail = 207,       /* For ARP packet, lookup for VRF and
                                           TPA (IP) failed. */
    bcmRxTrapL2cpPeer = 208,            /* L2CP trapped to peer destination. */
    bcmRxTrapL2cpDrop = 209,            /* L2CP dropped. */
    bcmRxTrapMimMyBmacMulticastContinue = 210, /* Terminated BMAC header indicates
                                           Multicast. Continue on both BMAC
                                           header and CMAC header. */
    bcmRxTrapCount = 211                /* Must be last: enum count size. */
} bcm_rx_trap_t;

/* User-configurable, per-unit RX configuration. */
typedef struct bcm_rx_trap_config_s {
    uint32 flags;                   /* BCM_RX_TRAP_XXX FLAGS. */
    bcm_gport_t dest_port;          /* Destination port. */
    bcm_multicast_t dest_group;     /* Destination group. */
    int prio;                       /* Internal priority of the packet. */
    bcm_color_t color;              /* Color of the packet. */
    bcm_policer_t ether_policer_id; /* Ethernet Policer. */
    bcm_policer_t policer_id;       /* general policer id. */
    int counter_num;                /* counter. */
    int trap_strength;              /* Strength of this trap, strongest trap in
                                       processing holds. */
    int snoop_cmnd;                 /* snoop command. */
    int snoop_strength;             /* Strength of this trap, strongest snoop in
                                       processing holds. */
} bcm_rx_trap_config_t;

/* Initialize the rx_trap_config_t structure. */
extern void bcm_rx_trap_config_t_init(
    bcm_rx_trap_config_t *trap_config);

/* User-configurable, per-unit RX configuration. */
typedef struct bcm_rx_snoop_config_s {
    uint32 flags;               /* BCM_RX_SNOOP_XXX FLAGS. */
    bcm_gport_t dest_port;      /* Destination port. */
    bcm_multicast_t dest_group; /* Destination group. */
    int prio;                   /* Internal priority of the packet. */
    bcm_color_t color;          /* Color of the packet. */
    bcm_policer_t policer_id;   /* policer_id. */
    int counter_num;            /* counter. */
    int size;                   /* what portion of the packet to snoop to CPU,
                                   use -1 to indicate full packet snooping. */
    int probability;            /* snooping probability. Value represents
                                   percentage with percisionof a thousandth of a
                                   percent (100000 is 100.000%),  range 0 -
                                   100000. */
} bcm_rx_snoop_config_t;

/* Initialize the rx_snoop_config_t structure. */
extern void bcm_rx_snoop_config_t_init(
    bcm_rx_snoop_config_t *snoop_config);

#ifndef BCM_HIDE_DISPATCHABLE

/* rx_trap_type_create. */
extern int bcm_rx_trap_type_create(
    int unit, 
    int flags, 
    bcm_rx_trap_t type, 
    int *trap_id);

/* rx_trap_type_destroy. */
extern int bcm_rx_trap_type_destroy(
    int unit, 
    int trap_id);

/* rx_trap_set. */
extern int bcm_rx_trap_set(
    int unit, 
    int trap_id, 
    bcm_rx_trap_config_t *config);

/* rx_trap_get. */
extern int bcm_rx_trap_get(
    int unit, 
    int trap_id, 
    bcm_rx_trap_config_t *config);

/* rx_snoop_set. */
extern int bcm_rx_snoop_set(
    int unit, 
    int snoop_cmnd, 
    bcm_rx_snoop_config_t *config);

/* rx_snoop_get. */
extern int bcm_rx_snoop_get(
    int unit, 
    int snoop_cmnd, 
    bcm_rx_snoop_config_t *config);

/* rx_snoop_create. */
extern int bcm_rx_snoop_create(
    int unit, 
    int flags, 
    int *snoop_cmnd);

/* rx_trap_type_destroy. */
extern int bcm_rx_snoop_destroy(
    int unit, 
    int flags, 
    int snoop_cmnd);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Flags for bcm_rx_trap_t. */
#define BCM_RX_TRAP_UPDATE_DEST             0x00000001 /* update destination. */
#define BCM_RX_TRAP_UPDATE_PRIO             0x00000002 /* update priority. */
#define BCM_RX_TRAP_UPDATE_COLOR            0x00000004 /* update color. */
#define BCM_RX_TRAP_UPDATE_POLICER          0x00000008 /* update policer id. */
#define BCM_RX_TRAP_UPDATE_ETHERNET_POLICER 0x00000010 /* update Ethernet
                                                          policer. */
#define BCM_RX_TRAP_UPDATE_COUNTER          0x00000020 /* update counter. */
#define BCM_RX_TRAP_DEST_MULTICAST          0x00000040 /* destination is
                                                          multicast. */
#define BCM_RX_TRAP_TRAP                    0x00000080 /* if present packet is
                                                          trapped to CPU (with
                                                          trap information)
                                                          otherwise packet is
                                                          forwarded to
                                                          destination port/cpu. */
#define BCM_RX_TRAP_BYPASS_FILTERS          0x00000100 /* bypass filtering. */
#define BCM_RX_TRAP_LEARN_DISABLE           0x00000200 /* disable learning . */
#define BCM_RX_TRAP_WITH_ID                 0x00000400 /* Use the specified
                                                          trap/snoop id. */
#define BCM_RX_TRAP_REPLACE                 0x00000800 /* Replace config of
                                                          existing trap/snoop. */
#define BCM_RX_TRAP_POLICER_RESULT_INGRESS  0x00001000 /* User policer result on
                                                          ingress. */
#define BCM_RX_TRAP_POLICER_RESULT_EGRESS   0x00002000 /* User policer result on
                                                          egress. */

/* Flags for bcm_rx_snoop_t. */
#define BCM_RX_SNOOP_UPDATE_DEST            0x00000001 /* update destination. */
#define BCM_RX_SNOOP_UPDATE_PRIO            0x00000002 /* update priority. */
#define BCM_RX_SNOOP_UPDATE_COLOR           0x00000004 /* update color. */
#define BCM_RX_SNOOP_UPDATE_POLICER         0x00000008 /* update policer id. */
#define BCM_RX_SNOOP_UPDATE_ETHERNET_POLICER 0x00000010 /* update Ethernet
                                                          policer. */
#define BCM_RX_SNOOP_UPDATE_COUNTER         0x00000020 /* update counter. */
#define BCM_RX_SNOOP_DEST_MULTICAST         0x00000040 /* destination is
                                                          multicast. */
#define BCM_RX_SNOOP_WITH_ID                0x00000080 /* Use the specified
                                                          trap/snoop id. */
#define BCM_RX_SNOOP_REPLACE                0x00000100 /* Replace config of
                                                          existing trap/snoop. */
#define BCM_RX_SNOOP_POLICER_RESULT_INGRESS 0x00000200 /* User policer result on
                                                          ingress. */
#define BCM_RX_SNOOP_POLICER_RESULT_EGRESS  0x00000400 /* User policer result on
                                                          egress. */

#ifndef BCM_HIDE_DISPATCHABLE

/* Set mode specific redirection reasons for rx packets. */
extern int bcm_rx_redirect_reasons_set(
    int unit, 
    bcm_rx_redirect_t mode, 
    bcm_rx_reasons_t reasons);

#endif /* BCM_HIDE_DISPATCHABLE */

#endif /* __BCM_RX_H__ */
