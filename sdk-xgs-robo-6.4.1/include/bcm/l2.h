/*
 * $Id: ee939bf7ce667f7d190a746302cad13161e06272 $
 * 
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_L2_H__
#define __BCM_L2_H__

#include <bcm/types.h>

/* 
 * Flags for device-independent L2 address.
 * 
 * Special note on insert/delete/lookup-specific flags:
 * 
 *   BCM_L2_NATIVE
 *   BCM_L2_MOVE
 *   BCM_L2_FROM_NATIVE
 *   BCM_L2_TO_NATIVE
 *   BCM_L2_MOVE_PORT
 *   BCM_L2_LOCAL_CPU
 * 
 * On a move, two calls occur: delete and insert. The from native/to
 * native calls are set the same for both of these operations. On an age,
 * the move bit is not set and only one delete operation occurs.
 * 
 * Suggested application operation:
 * 
 *      Insert:  If native is set, send insert op to all units.
 *      Age:     If native is set, send delete operation to all units.
 *      Move:    Ignore delete indication and wait for insert operation.
 *               Treat insert like above.
 * 
 * That is, ignore move-delete operations; only forward other
 * operations if native.
 * 
 * The BCM_L2_LOCAL_CPU flag indicates the entry is for the local CPU on
 * the device. This is valid for _add operations only. Note that
 * BCM_L2_LOCAL_CPU is related to the L2_NATIVE value. L2_NATIVE is valid
 * on reads, L2_LOCAL_CPU is valid on move or write.
 */
#define BCM_L2_COS_SRC_PRI              0x00000001 /* Source COS has priority
                                                      over destination COS. */
#define BCM_L2_DISCARD_SRC              0x00000002 
#define BCM_L2_DISCARD_DST              0x00000004 
#define BCM_L2_COPY_TO_CPU              0x00000008 
#define BCM_L2_L3LOOKUP                 0x00000010 
#define BCM_L2_STATIC                   0x00000020 
#define BCM_L2_HIT                      0x00000040 
#define BCM_L2_TRUNK_MEMBER             0x00000080 
#define BCM_L2_MCAST                    0x00000100 
#define BCM_L2_REPLACE_DYNAMIC          0x00000200 
#define BCM_L2_SRC_HIT                  0x00000400 
#define BCM_L2_DES_HIT                  0x00000800 
#define BCM_L2_REMOTE_TRUNK             0x00001000 
#define BCM_L2_MIRROR                   0x00002000 
#define BCM_L2_SETPRI                   0x00004000 
#define BCM_L2_REMOTE_LOOKUP            0x00008000 
#define BCM_L2_NATIVE                   0x00010000 
#define BCM_L2_MOVE                     0x00020000 
#define BCM_L2_FROM_NATIVE              0x00040000 
#define BCM_L2_TO_NATIVE                0x00080000 
#define BCM_L2_MOVE_PORT                0x00100000 
#define BCM_L2_LOCAL_CPU                0x00200000 /* Entry is for the local CPU
                                                      on the device. */
#define BCM_L2_USE_FABRIC_DISTRIBUTION  0x00400000 /* Use specified fabric
                                                      distribution class. */
#define BCM_L2_PENDING                  0x00800000 
#define BCM_L2_LEARN_LIMIT_EXEMPT       0x01000000 
#define BCM_L2_LEARN_LIMIT              0x02000000 
#define BCM_L2_ENTRY_OVERFLOW           0x04000000 
#define BCM_L2_LEARN_LIMIT_EXEMPT_LOCAL 0x08000000 /* Only system wide MAC limit
                                                      counter will be
                                                      incremented. */

/* These are in bit order. */
#define BCM_L2_FLAGS_STR        \
{ \
    "SrcCOS", \
    "SrcDisc", \
    "DestDisc", \
    "CopyCPU", \
    "L3Lkup", \
    "Static", \
    "Hit", \
    "Trunk", \
    "Mcast", \
    "RplDyn", \
    "SrcHit", \
    "DestHit", \
    "RTrunk", \
    "Mirror", \
    "SetPri", \
    "RemoteLookup", \
    "Native", \
    "Move", \
    "FrNative", \
    "ToNative", \
    "MovePort", \
    "LclCPU", \
    "UseFabricDistribution", \
    "Pending", \
    "LearnLimitExempt", \
    "LearnLimit" \
} 

/* bcm_l2_flags_str */
extern char *bcm_l2_flags_str[];

/* bcm_l2_flags_count */
extern int bcm_l2_flags_count;

#define BCM_L2_AUTH_NONE            0          
#define BCM_L2_AUTH_STATIC_ACCEPT   4          
#define BCM_L2_AUTH_STATIC_REJECT   5          
#define BCM_L2_AUTH_SA_NUM          6          
#define BCM_L2_AUTH_SA_MATCH        7          

#define BCM_L2_VID_MASK_ALL     0x0fff     
#define BCM_L2_SRCPORT_MASK_ALL 0x3f       

#define BCM_L2_CALLBACK_DELETE      0          
#define BCM_L2_CALLBACK_ADD         1          
#define BCM_L2_CALLBACK_REPORT      2          
#define BCM_L2_CALLBACK_LEARN_EVENT 3          
#define BCM_L2_CALLBACK_AGE_EVENT   4          
#define BCM_L2_CALLBACK_MOVE_EVENT  5          

#define BCM_L2_ADDR_DIST_LEARN_EVENT        0x00000001 /* learning events */
#define BCM_L2_ADDR_DIST_STATION_MOVE_EVENT 0x00000002 /* station movement event */
#define BCM_L2_ADDR_DIST_AGED_OUT_EVENT     0x00000004 /* aged out events */
#define BCM_L2_ADDR_DIST_SET_LEARN_DISTRIBUTER 0x00000008 /* Send events to the
                                                          learning distributer */
#define BCM_L2_ADDR_DIST_SET_SHADOW_DISTRIBUTER 0x00000010 /* Send events to the
                                                          shadow distributer */

#define BCM_L2_LEARN_MSG_DEST_MULTICAST 0x00000001 /* The destination of the
                                                      learning message is
                                                      Multicast group
                                                      'dest_group' in use, if
                                                      not present then the
                                                      destination is uc and
                                                      'dest_port' in use
                                                      dst_mac_addr ,
                                                      src_mac_addr, ether_type,
                                                      vlan_prio, vlan. */
#define BCM_L2_LEARN_MSG_ETH_ENCAP      0x00000002 /* Learn message are
                                                      encapsulated with
                                                      Etherenet header. Use the
                                                      specified Ethernet
                                                      parameters */
#define BCM_L2_LEARN_MSG_LEARNING       0x00000004 /* The specified
                                                      configuration are for
                                                      message generated to
                                                      learning */
#define BCM_L2_LEARN_MSG_SHADOW         0x00000008 /* The specified
                                                      configuration are for
                                                      message generated to
                                                      manage a shadow of the ARL */

/* Device-independent L2 address structure. */
typedef struct bcm_l2_addr_s {
    uint32 flags;                       /* BCM_L2_xxx flags. */
    bcm_mac_t mac;                      /* 802.3 MAC address. */
    bcm_vlan_t vid;                     /* VLAN identifier. */
    int port;                           /* Zero-based port number. */
    int modid;                          /* XGS: modid. */
    bcm_trunk_t tgid;                   /* Trunk group ID. */
    bcm_cos_t cos_dst;                  /* COS based on dst addr. */
    bcm_cos_t cos_src;                  /* COS based on src addr. */
    bcm_multicast_t l2mc_group;         /* XGS: index in L2MC table. For SBX
                                           chips it is the Multicast Group index */
    bcm_pbmp_t block_bitmap;            /* XGS: blocked egress bitmap. */
    int auth;                           /* Used if auth enabled on port. */
    int group;                          /* Group number for FP. */
    bcm_fabric_distribution_t distribution_class; /* Fabric Distribution Class. */
    int encap_id;                       /* out logical interface */
} bcm_l2_addr_t;

/* Flags for device-independent L2 egress. */
#define BCM_L2_EGRESS_WITH_ID               0x00000001 /* Use the specified
                                                          Encap ID while
                                                          creating. */
#define BCM_L2_EGRESS_REPLACE               0x00000002 /* Replace config of
                                                          existing egress
                                                          object. */
#define BCM_L2_EGRESS_DEST_MAC_REPLACE      0x00000004 /* Replace dest MAC. */
#define BCM_L2_EGRESS_DEST_MAC_PREFIX5_REPLACE 0x00000008 /* Replace only 5 prefix
                                                          bytes of dest MAC. */
#define BCM_L2_EGRESS_SRC_MAC_REPLACE       0x00000010 /* Replace source MAC. */
#define BCM_L2_EGRESS_OUTER_VLAN_REPLACE    0x00000020 /* Replace outer vlan. */
#define BCM_L2_EGRESS_OUTER_PRIO_REPLACE    0x00000040 /* Replace outer tag
                                                          priority. */
#define BCM_L2_EGRESS_INNER_VLAN_REPLACE    0x00000080 /* Replace inner vlan. */
#define BCM_L2_EGRESS_INNER_PRIO_REPLACE    0x00000100 /* Replace inner tag
                                                          priority. */
#define BCM_L2_EGRESS_ETHERTYPE_REPLACE     0x00000200 /* Replace ethertype */
#define BCM_L2_EGRESS_DEST_PORT             0x00000400 /* Associate l2 egress
                                                          entry with a
                                                          particular dest port */
#define BCM_L2_EGRESS_OUTER_VLAN_ADD        0x00000800 /* add outer vlan, if set
                                                          then new vlan-tag is
                                                          added according to
                                                          outer_tpid,outer_prio,outer_vlan,
                                                          attributes */
#define BCM_L2_EGRESS_VLAN_QOS_MAP_REPLACE  0x00001000 /* Replace VLAN PCP-DEI
                                                          QOS settings */

/* Device-independent L2 egress structure. */
typedef struct bcm_l2_egress_s {
    uint32 flags;               /* BCM_L2_EGRESS_XXX flags. */
    bcm_mac_t dest_mac;         /* Destination MAC address to replace with. */
    bcm_mac_t src_mac;          /* Source MAC address to replace with. */
    bcm_vlan_t outer_vlan;      /* outer vlan tag to replace with. */
    bcm_vlan_t inner_vlan;      /* inner vlan tag to replace with. */
    bcm_ethertype_t ethertype;  /* Ethertype to replace with. */
    bcm_gport_t dest_port;      /* Destination gport to associate this l2 egress
                                   entry with */
    bcm_if_t encap_id;          /* Encapsulation index */
    uint16 outer_tpid;          /* outer vlan tag TPID */
    uint8 outer_prio;           /* outer vlan tag User Priority */
    uint16 inner_tpid;          /* inner vlan tag TPID */
    bcm_if_t l3_intf;           /* L3 interface (tunnel). Used only in Native
                                   Routing overlay protocols. */
    int vlan_qos_map_id;        /* VLAN PCP-DEI QoS settings. Used only in
                                   Native Routing overlay protocols. */
} bcm_l2_egress_t;

/* Flags for device-independent L2 cache address. */
#define BCM_L2_CACHE_CPU            0x00000001 /* Packet is copied to CPU. */
#define BCM_L2_CACHE_DISCARD        0x00000002 /* Packet is not switched. */
#define BCM_L2_CACHE_MIRROR         0x00000004 /* Packet is mirrored. */
#define BCM_L2_CACHE_L3             0x00000008 /* Packet is to be L3 routed. */
#define BCM_L2_CACHE_BPDU           0x00000010 /* Packet is BPDU. */
#define BCM_L2_CACHE_SETPRI         0x00000020 /* Internal prio from prio field. */
#define BCM_L2_CACHE_TRUNK          0x00000040 /* Destination is a trunk. */
#define BCM_L2_CACHE_REMOTE_LOOKUP  0x00000080 /* Remote L2 lookup requested. */
#define BCM_L2_CACHE_LEARN_DISABLE  0x00000100 /* Packet source address is not
                                                  learned for this destination
                                                  address. */
#define BCM_L2_CACHE_TUNNEL         0x00000200 /* Tunnel termination address. */
#define BCM_L2_CACHE_DESTPORTS      0x00000400 /* Packet is forwarded by
                                                  multiport L2 address. */
#define BCM_L2_CACHE_SUBTYPE        0x00000800 /* Slow protocol subtype to
                                                  match. */
#define BCM_L2_CACHE_LOOKUP         0x00001000 /* L2 lookup requested. */
#define BCM_L2_CACHE_MULTICAST      0x00002000 /* Destination is (flood)
                                                  multicast group. */
#define BCM_L2_CACHE_PROTO_PKT      0x00004000 /* Packet is protocol packets. */

/* Device-independent L2 cache address structure. */
typedef struct bcm_l2_cache_addr_s {
    uint32 flags;                   /* BCM_L2_CACHE_xxx flags. */
    bcm_mac_t mac;                  /* Destination MAC address to match. */
    bcm_mac_t mac_mask;             /* MAC address mask. */
    bcm_vlan_t vlan;                /* VLAN to match. */
    bcm_vlan_t vlan_mask;           /* VLAN mask. */
    bcm_port_t src_port;            /* Ingress port to match (BCM5660x). */
    bcm_port_t src_port_mask;       /* Ingress port mask (must be 0 if not
                                       BCM5660x). */
    bcm_module_t dest_modid;        /* Switch destination module ID. */
    bcm_port_t dest_port;           /* Switch destination port. */
    bcm_trunk_t dest_trunk;         /* Switch destination trunk ID. */
    int prio;                       /* Internal priority, use -1 to not set. */
    bcm_pbmp_t dest_ports;          /* Destination ports for Multiport L2
                                       address forwarding. */
    int lookup_class;               /* Classification class ID. */
    uint8 subtype;                  /* Slow protocol subtype to match. */
    bcm_if_t encap_id;              /* Encapsulation index. */
    bcm_multicast_t group;          /* Flood domain for L2CP. */
    bcm_ethertype_t ethertype;      /* Ethertype to match. */
    bcm_ethertype_t ethertype_mask; /* Mask. */
} bcm_l2_cache_addr_t;

/* Flags for L2 learn limit. */
#define BCM_L2_LEARN_LIMIT_SYSTEM           0x00000001 /* Limit is system wide. */
#define BCM_L2_LEARN_LIMIT_VLAN             0x00000002 /* Limit is on per VLAN
                                                          basis. */
#define BCM_L2_LEARN_LIMIT_PORT             0x00000004 /* Limit is on per port
                                                          basis. */
#define BCM_L2_LEARN_LIMIT_TRUNK            0x00000008 /* Limit is on per trunk
                                                          basis. */
#define BCM_L2_LEARN_LIMIT_ACTION_DROP      0x00000010 /* Drop if over limit. */
#define BCM_L2_LEARN_LIMIT_ACTION_CPU       0x00000020 /* Send to CPU if over
                                                          limit. */
#define BCM_L2_LEARN_LIMIT_ACTION_PREFER    0x00000040 /* Use system drop/CPU if
                                                          over both system limit
                                                          and non-system limit,
                                                          used by system wide
                                                          setting only. */
#define BCM_L2_LEARN_LIMIT_TUNNEL           0x00000080 /* Limit is on per tunnel
                                                          basis. */

/* L2 learn limit structure. */
typedef struct bcm_l2_learn_limit_s {
    uint32 flags;               /* BCM_L2_LEARN_LIMIT_xxx actions and
                                   qualifiers. */
    bcm_vlan_t vlan;            /* VLAN identifier. */
    bcm_port_t port;            /* Port number. */
    bcm_trunk_t trunk;          /* Trunk identifier. */
    bcm_tunnel_id_t tunnel_id;  /* Tunnel identifier. */
    int limit;                  /* Maximum number of learned entries, -1 for
                                   unlimited. */
} bcm_l2_learn_limit_t;

/* L2 learn message distribution info. */
typedef struct bcm_l2_learn_msgs_config_s {
    uint32 flags;               /* BCM_L2_LEARN_MSG_XXX flags. */
    bcm_gport_t dest_port;      /* Destination port. */
    bcm_multicast_t dest_group; /* Destination group. */
    bcm_vlan_t vlan;            /* L2: vlan identifier. set to invalid for
                                   untagged Ethernet */
    uint16 tpid;                /* L2: vlan TPID. */
    uint16 vlan_prio;           /* L2: vlan priority. */
    uint16 ether_type;          /* L2: type in Ethernet II frame or 802.1Q tag. */
    bcm_mac_t src_mac_addr;     /* L2: source MAC address. */
    bcm_mac_t dst_mac_addr;     /* L2: destination MAC address. */
} bcm_l2_learn_msgs_config_t;

/* Learning events distibution. */
typedef struct bcm_l2_addr_distribute_s {
    uint32 flags;   /* BCM_L2_ADDR_DIST_XXX flags. */
    bcm_vlan_t vid; /* VLAN or VPN identifier. */
} bcm_l2_addr_distribute_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Initialize the BCM L2 subsystem. */
extern int bcm_l2_init(
    int unit);

/* Clear the BCM L2 subsystem. */
extern int bcm_l2_clear(
    int unit);

/* Finalize the BCM L2 subsystem. */
extern int bcm_l2_detach(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

/* 
 * Initialize an L2 address structure to a specified MAC address and VLAN
 * ID.
 */
extern void bcm_l2_addr_t_init(
    bcm_l2_addr_t *l2addr, 
    const bcm_mac_t mac_addr, 
    bcm_vlan_t vid);

#define bcm_l2_addr_init        bcm_l2_addr_t_init 

#ifndef BCM_HIDE_DISPATCHABLE

/* Add an L2 address entry to the specified device. */
extern int bcm_l2_addr_add(
    int unit, 
    bcm_l2_addr_t *l2addr);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_L2_DELETE_STATIC        0x00000001 
#define BCM_L2_DELETE_PENDING       0x00000002 
#define BCM_L2_DELETE_NO_CALLBACKS  0x00000004 

#ifndef BCM_HIDE_DISPATCHABLE

/* Delete an L2 address entry from the specified device. */
extern int bcm_l2_addr_delete(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vid);

/* Delete L2 entries associated with a destination module/port. */
extern int bcm_l2_addr_delete_by_port(
    int unit, 
    bcm_module_t mod, 
    bcm_port_t port, 
    uint32 flags);

/* Delete L2 entries associated with a MAC address. */
extern int bcm_l2_addr_delete_by_mac(
    int unit, 
    bcm_mac_t mac, 
    uint32 flags);

/* Delete L2 entries associated with a VLAN. */
extern int bcm_l2_addr_delete_by_vlan(
    int unit, 
    bcm_vlan_t vid, 
    uint32 flags);

/* Delete L2 entries associated with a trunk. */
extern int bcm_l2_addr_delete_by_trunk(
    int unit, 
    bcm_trunk_t tid, 
    uint32 flags);

/* 
 * Delete L2 entries associated with a MAC address and a destination
 * module/port.
 */
extern int bcm_l2_addr_delete_by_mac_port(
    int unit, 
    bcm_mac_t mac, 
    bcm_module_t mod, 
    bcm_port_t port, 
    uint32 flags);

/* 
 * Delete L2 entries associated with a VLAN and a destination
 * module/port.
 */
extern int bcm_l2_addr_delete_by_vlan_port(
    int unit, 
    bcm_vlan_t vid, 
    bcm_module_t mod, 
    bcm_port_t port, 
    uint32 flags);

/* 
 * Delete L2 entries associated with a VLAN and a destination
 * module/port.
 */
extern int bcm_l2_addr_delete_by_vlan_trunk(
    int unit, 
    bcm_vlan_t vid, 
    bcm_trunk_t tid, 
    uint32 flags);

/* Check if an L2 entry is present in the L2 table. */
extern int bcm_l2_addr_get(
    int unit, 
    bcm_mac_t mac_addr, 
    bcm_vlan_t vid, 
    bcm_l2_addr_t *l2addr);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Dump a hardware-independent L2 address. */
extern void bcm_l2_addr_dump(
    bcm_l2_addr_t *l2e);

#ifndef BCM_HIDE_DISPATCHABLE

/* Dump the key portion of a hardware-independent L2 address. */
extern int bcm_l2_key_dump(
    int unit, 
    char *pfx, 
    bcm_l2_addr_t *entry, 
    char *sfx);

#endif /* BCM_HIDE_DISPATCHABLE */

/* 
 * Callback function used for receiving notification about insertions
 * into and deletions from the L2 table dynamically as they occur. Valid
 * operations are: delete, add, and report. A report with l2addr=NULL
 * indicates a scan completion of the L2 table.
 */
typedef void (*bcm_l2_addr_callback_t)(
    int unit, 
    bcm_l2_addr_t *l2addr, 
    int operation, 
    void *userdata);

#ifndef BCM_HIDE_DISPATCHABLE

/* Register/Unregister a callback routine for BCM L2 subsystem. */
extern int bcm_l2_addr_register(
    int unit, 
    bcm_l2_addr_callback_t callback, 
    void *userdata);

/* Register/Unregister a callback routine for BCM L2 subsystem. */
extern int bcm_l2_addr_unregister(
    int unit, 
    bcm_l2_addr_callback_t callback, 
    void *userdata);

/* Set/Get the age timer. */
extern int bcm_l2_age_timer_set(
    int unit, 
    int age_seconds);

/* Set/Get the age timer. */
extern int bcm_l2_age_timer_get(
    int unit, 
    int *age_seconds);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize an L2 learn message structure. */
extern void bcm_l2_learn_msgs_config_t_init(
    bcm_l2_learn_msgs_config_t *learn_msg_config);

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Set device to distribute learning message to other devices in system
 * and/or Monitoring CPU. The monitoring CPU may be connected by Ethernet
 * header and in this case the Petra-B also append network header to the
 * learning related messages.
 */
extern int bcm_l2_learn_msgs_config_set(
    int unit, 
    bcm_l2_learn_msgs_config_t *learn_msg_config);

/* 
 * Get device configuration for distribute learning message to other
 * devices in system and/or Monitoring CPU. The monitoring CPU may be
 * connected by Ethernet header and in this case the Petra-B also append
 * network header to the learning related messages.
 */
extern int bcm_l2_learn_msgs_config_get(
    int unit, 
    bcm_l2_learn_msgs_config_t *learn_msg_config);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize an L2 learn distribution structure. */
extern void bcm_l2_addr_distribute_t_init(
    bcm_l2_addr_distribute_t *distribution);

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Per VSI set which events (learn, station move (transplant), aged-out)
 * to inform CPU about.
 */
extern int bcm_l2_addr_msg_distribute_set(
    int unit, 
    bcm_l2_addr_distribute_t *distribution);

/* 
 * Per VSI get which events (learn, station move (transplant), aged-out)
 * to inform CPU about.
 */
extern int bcm_l2_addr_msg_distribute_get(
    int unit, 
    bcm_l2_addr_distribute_t *distribution);

/* Temporarily stop/restore L2 table from changing. */
extern int bcm_l2_addr_freeze(
    int unit);

/* Temporarily stop/restore L2 table from changing. */
extern int bcm_l2_addr_thaw(
    int unit);

/* 
 * Given an L2 address entry, return existing addresses which could
 * conflict.
 */
extern int bcm_l2_conflict_get(
    int unit, 
    bcm_l2_addr_t *addr, 
    bcm_l2_addr_t *cf_array, 
    int cf_max, 
    int *cf_count);

/* Determine if the given port is "native" from the point of view of L2. */
extern int bcm_l2_port_native(
    int unit, 
    int modid, 
    int port);

/* Initialize the L2 cache. */
extern int bcm_l2_cache_init(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize an L2 cache address structure. */
extern void bcm_l2_cache_addr_t_init(
    bcm_l2_cache_addr_t *addr);

#ifndef BCM_HIDE_DISPATCHABLE

/* Get number of L2 cache entries. */
extern int bcm_l2_cache_size_get(
    int unit, 
    int *size);

/* Set an L2 cache entry. */
extern int bcm_l2_cache_set(
    int unit, 
    int index, 
    bcm_l2_cache_addr_t *addr, 
    int *index_used);

/* Get an L2 cache entry. */
extern int bcm_l2_cache_get(
    int unit, 
    int index, 
    bcm_l2_cache_addr_t *addr);

/* Clear an L2 cache entry. */
extern int bcm_l2_cache_delete(
    int unit, 
    int index);

/* Clear all L2 cache entries. */
extern int bcm_l2_cache_delete_all(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize an l2 egress object. */
extern void bcm_l2_egress_t_init(
    bcm_l2_egress_t *egr);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create an l2 encapsulation index. */
extern int bcm_l2_egress_create(
    int unit, 
    bcm_l2_egress_t *egr);

/* Destroy an l2 encapsulation index. */
extern int bcm_l2_egress_destroy(
    int unit, 
    bcm_if_t encap_id);

/* Get l2 egress object configuration. */
extern int bcm_l2_egress_get(
    int unit, 
    bcm_if_t encap_id, 
    bcm_l2_egress_t *egr);

/* Find an encapsulation index with a specific l2 egress configuration. */
extern int bcm_l2_egress_find(
    int unit, 
    bcm_l2_egress_t *egr, 
    bcm_if_t *encap_id);

#endif /* BCM_HIDE_DISPATCHABLE */

/* l2 egress traverse callback */
typedef int (*bcm_l2_egress_traverse_cb)(
    int unit, 
    bcm_l2_egress_t *egr, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* Traverse L2 egress objects */
extern int bcm_l2_egress_traverse(
    int unit, 
    bcm_l2_egress_traverse_cb trav_fn, 
    void *user_data);

/* Add a destination L2 address to trigger tunnel processing. */
extern int bcm_l2_tunnel_add(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vlan);

/* Clear a destination L2 address used to trigger tunnel processing. */
extern int bcm_l2_tunnel_delete(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vlan);

/* Clear all destination L2 addresses used to trigger tunnel processing. */
extern int bcm_l2_tunnel_delete_all(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize an L2 learn limit structure. */
extern void bcm_l2_learn_limit_t_init(
    bcm_l2_learn_limit_t *limit);

#ifndef BCM_HIDE_DISPATCHABLE

/* Set/Get L2 addresses learn limit. */
extern int bcm_l2_learn_limit_set(
    int unit, 
    bcm_l2_learn_limit_t *limit);

/* Set/Get L2 addresses learn limit. */
extern int bcm_l2_learn_limit_get(
    int unit, 
    bcm_l2_learn_limit_t *limit);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_L2_LEARN_CLASS_MOVE 0x01       

#ifndef BCM_HIDE_DISPATCHABLE

/* Set/Get attributes for the specified L2 learning class. */
extern int bcm_l2_learn_class_set(
    int unit, 
    int lclass, 
    int lclass_prio, 
    uint32 flags);

/* Set/Get attributes for the specified L2 learning class. */
extern int bcm_l2_learn_class_get(
    int unit, 
    int lclass, 
    int *lclass_prio, 
    uint32 *flags);

/* Set/Get L2 learning class for the specified port. */
extern int bcm_l2_learn_port_class_set(
    int unit, 
    bcm_gport_t port, 
    int lclass);

#endif /* BCM_HIDE_DISPATCHABLE */

/* L2 Statistics. */
typedef enum bcm_l2_stat_e {
    bcmL2StatSourcePackets = 0, 
    bcmL2StatSourceBytes = 1, 
    bcmL2StatDestPackets = 2, 
    bcmL2StatDestBytes = 3, 
    bcmL2StatDropPackets = 4, 
    bcmL2StatDropBytes = 5 
} bcm_l2_stat_t;

#define BCM_STAT_CHECK_L2_STAT(type)  do { if ( ((type) < bcmL2StatSourcePackets) || ((type) > bcmL2StatDropBytes) ) { return (BCM_E_BADID); } } while (0) 

#ifndef BCM_HIDE_DISPATCHABLE

/* Get the specified L2 statistic from the chip. */
extern int bcm_l2_stat_get(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint64 *val);

/* Get the specified L2 statistic from the chip. */
extern int bcm_l2_stat_get32(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint32 *val);

/* 
 * Set the specified L2 statistic to the indicated value for the
 * specified L2 address.
 */
extern int bcm_l2_stat_set(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint64 val);

/* 
 * Set the specified L2 statistic to the indicated value for the
 * specified L2 address.
 */
extern int bcm_l2_stat_set32(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint32 val);

/* Enable/disable collection of statistics on the indicated L2 entry. */
extern int bcm_l2_stat_enable_set(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    int enable);

/* Set/Get L2 learning class for the specified port. */
extern int bcm_l2_learn_port_class_get(
    int unit, 
    bcm_gport_t port, 
    int *lclass);

#endif /* BCM_HIDE_DISPATCHABLE */

/* bcm_l2_traverse_cb */
typedef int (*bcm_l2_traverse_cb)(
    int unit, 
    bcm_l2_addr_t *info, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* Traverse L2 table */
extern int bcm_l2_traverse(
    int unit, 
    bcm_l2_traverse_cb trav_fn, 
    void *user_data);

/* 
 * The callback will be called on entries that match the given
 * match_addr, match_mask flags (similar to l2_replace)
 */
extern int bcm_l2_match_masked_traverse(
    int unit, 
    uint32 flags, 
    bcm_l2_addr_t *match_addr, 
    bcm_l2_addr_t *mask_addr, 
    bcm_l2_traverse_cb trav_fn, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Flags for l2_replace API */
#define BCM_L2_REPLACE_MATCH_STATIC         0x00000001 /* Replace L2 static
                                                          entries. */
#define BCM_L2_REPLACE_MATCH_MAC            0x00000002 /* Replace all L2 entries
                                                          matching given MAC
                                                          address */
#define BCM_L2_REPLACE_MATCH_VLAN           0x00000004 /* Replace all L2 entries
                                                          matching given VLAN id */
#define BCM_L2_REPLACE_MATCH_DEST           0x00000008 /* Replace all L2 entries
                                                          matching given modid
                                                          port/tgid */
#define BCM_L2_REPLACE_VPN_TYPE             0x00000010 /* Replace all VPN type
                                                          L2 entry */
#define BCM_L2_REPLACE_VLAN_AND_VPN_TYPE    0x00000020 /* Replace all VLAN and
                                                          VPN type L2 entry */
#define BCM_L2_REPLACE_DELETE               0x00000100 /* L2 replace will
                                                          perform delete
                                                          operation instead of
                                                          replace on matching
                                                          entries */
#define BCM_L2_REPLACE_NEW_TRUNK            0x00000200 /* New destination is a
                                                          trunk group */
#define BCM_L2_REPLACE_PENDING              0x00000400 /* Replace L2 pending
                                                          entries. */
#define BCM_L2_REPLACE_NO_CALLBACKS         0x00000800 /* Replace L2 entries
                                                          without callbacks. */
#define BCM_L2_REPLACE_LEARN_LIMIT          0x00001000 /* Force ALL entries
                                                          including static to be
                                                          counted for learn
                                                          limit */
#define BCM_L2_REPLACE_IGNORE_PENDING       0x00002000 /* Force the L2 replace
                                                          process to ignore the
                                                          pending status check. */
#define BCM_L2_REPLACE_PROTECTION_RING      0x00004000 /* Replace L2 protection
                                                          ring. */
#define BCM_L2_REPLACE_MIGRATE_PORT         0x00008000 /* Replace L2 port. */
#define BCM_L2_REPLACE_IGNORE_DISCARD_SRC   0x00010000 /* Match L2 entries with
                                                          given Discard on
                                                          source. */
#define BCM_L2_REPLACE_IGNORE_DES_HIT       0x00020000 /* Match L2 entries
                                                          ignoring hit-bit
                                                          indication. */
#define BCM_L2_REPLACE_DES_HIT_CLEAR        0x00040000 /* When set then reset
                                                          Hit-bit state. */
#define BCM_L2_REPLACE_DISCARD_SRC_SET      0x00080000 /* When set then set
                                                          Discard on source */
#define BCM_L2_REPLACE_DISCARD_SRC_CLEAR    0x00100000 /* When set then reset
                                                          Discard on source */
#define BCM_L2_REPLACE_AGE                  0x01000000 /* L2 replace will
                                                          perform age operation
                                                          instead of replace on
                                                          matching entries */
#define BCM_L2_REPLACE_MATCH_UC             0x02000000 /* L2 replace will be
                                                          performed on Unicast
                                                          entries */
#define BCM_L2_REPLACE_MATCH_MC             0x04000000 /* L2 replace will be
                                                          performed on Multicast
                                                          entries */

#ifndef BCM_HIDE_DISPATCHABLE

/* Replace L2 entries matching given criterions */
extern int bcm_l2_replace(
    int unit, 
    uint32 flags, 
    bcm_l2_addr_t *match_addr, 
    bcm_module_t new_module, 
    bcm_port_t new_port, 
    bcm_trunk_t new_trunk);

/* Replace by match_addr and mask_addr */
extern int bcm_l2_replace_match(
    int unit, 
    uint32 flags, 
    bcm_l2_addr_t *match_addr, 
    bcm_l2_addr_t *mask_addr, 
    bcm_l2_addr_t *replace_addr, 
    bcm_l2_addr_t *replace_mask_addr);

#endif /* BCM_HIDE_DISPATCHABLE */

/* L2 Station address info. */
typedef struct bcm_l2_station_s {
    uint32 flags;               /* BCM_L2_STATION_xxx flags. */
    int priority;               /* Entry priority. */
    bcm_mac_t dst_mac;          /* Destination MAC address to match. */
    bcm_mac_t dst_mac_mask;     /* Destination MAC address mask value. */
    bcm_vlan_t vlan;            /* VLAN to match. */
    bcm_vlan_t vlan_mask;       /* VLAN mask value. */
    bcm_port_t src_port;        /* Ingress port to match. */
    bcm_port_t src_port_mask;   /* Ingress port mask value. */
} bcm_l2_station_t;

/* Flags for bcm_l2_station_add/get APIs. */
#define BCM_L2_STATION_WITH_ID      (1 << 0)   /* Use the specified Station ID. */
#define BCM_L2_STATION_REPLACE      (1 << 1)   /* Replace an existing L2 Station
                                                  table entry. */
#define BCM_L2_STATION_IPV4         (1 << 2)   /* Subject packets matching this
                                                  entry to L3 processing. */
#define BCM_L2_STATION_IPV6         (1 << 3)   /* Subject packets matching this
                                                  entry to L3 processing. */
#define BCM_L2_STATION_ARP_RARP     (1 << 4)   /* Subject packets matching this
                                                  entry to ARP/RARP processing. */
#define BCM_L2_STATION_MPLS         (1 << 5)   /* Subject packets matching this
                                                  entry to MPLS processing. */
#define BCM_L2_STATION_MIM          (1 << 6)   /* Subject packets matching this
                                                  entry to MiM processing. */
#define BCM_L2_STATION_TRILL        (1 << 7)   /* Subject packets matching this
                                                  entry to Trill processing. */
#define BCM_L2_STATION_FCOE         (1 << 8)   /* Subject packets matching this
                                                  entry to FCoE processing. */
#define BCM_L2_STATION_OAM          (1 << 9)   /* Subject packets matching this
                                                  entry to OAM processing. */
#define BCM_L2_STATION_COPY_TO_CPU  (1 << 10)  /* Copy packet to CPU. */
#define BCM_L2_STATION_OLP          (1 << 11)  /* Subject packets matching this
                                                  entry to OAM-OLP header
                                                  processing. */
#define BCM_L2_STATION_XGS_MAC      (1 << 12)  /* Add this MAC address as source
                                                  MAC in the OLP header for
                                                  packets sent to OLP. */

/* Initialize L2 Station structure. */
extern void bcm_l2_station_t_init(
    bcm_l2_station_t *addr);

#ifndef BCM_HIDE_DISPATCHABLE

/* Add an entry to L2 Station Table. */
extern int bcm_l2_station_add(
    int unit, 
    int *station_id, 
    bcm_l2_station_t *station);

/* Delete an entry from L2 Station Table. */
extern int bcm_l2_station_delete(
    int unit, 
    int station_id);

/* Clear all L2 Station Table entries. */
extern int bcm_l2_station_delete_all(
    int unit);

/* Get L2 station entry detail from Station Table. */
extern int bcm_l2_station_get(
    int unit, 
    int station_id, 
    bcm_l2_station_t *station);

/* Get size of L2 Station Table. */
extern int bcm_l2_station_size_get(
    int unit, 
    int *size);

#endif /* BCM_HIDE_DISPATCHABLE */

/* L2 ring structure. */
typedef struct bcm_l2_ring_s {
    uint32 flags;                   /* flags */
    bcm_vlan_vector_t vlan_vector;  /* List of Vlans. */
    bcm_gport_t port0;              /* VLAN gport */
    bcm_gport_t port1;              /* VLAN gport */
} bcm_l2_ring_t;

/* Initialize an L2 ring structure. */
extern void bcm_l2_ring_t_init(
    bcm_l2_ring_t *l2_ring);

#ifndef BCM_HIDE_DISPATCHABLE

/* Replace an L2 ring with the provided configuration. */
extern int bcm_l2_ring_replace(
    int unit, 
    bcm_l2_ring_t *l2_ring);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Device-independent L2 SA authentication structure. */
typedef struct bcm_l2_auth_addr_s {
    uint32 flags;           /* BCM_L2_AUTH_XXX flags. */
    bcm_mac_t sa_mac;       /* SA MAC address to match. */
    bcm_vlan_t vlan;        /* VLAN to match. */
    bcm_port_t src_port;    /* ingress port to match. */
} bcm_l2_auth_addr_t;

/* The callback function called for each valid entry in l2-auth. */
typedef int (*bcm_l2_auth_traverse_cb)(
    int unit, 
    bcm_l2_auth_addr_t *info, 
    void *userdata);

#define BCM_L2_AUTH_CHECK_IN_PORT       0x00000001 /* check packet with sa_mac
                                                      received on the expected
                                                      src_port. */
#define BCM_L2_AUTH_CHECK_VLAN          0x00000002 /* check packet with sa_mac
                                                      received on the expected
                                                      vlan */
#define BCM_L2_AUTH_PERMIT_TAGGED_ONLY  0x00000004 /* permit only tagged packets */

/* 
 * Initialize an L2  SA authentication structure to a specified MAC
 * address and VLAN ID.
 */
extern void bcm_l2_auth_addr_t_init(
    bcm_l2_auth_addr_t *addr);

#ifndef BCM_HIDE_DISPATCHABLE

/* Add an L2 SA authentication entry to the specified device. */
extern int bcm_l2_auth_add(
    int unit, 
    bcm_l2_auth_addr_t *addr);

/* Check if an L2 SA authentication entry is present in the L2 table. */
extern int bcm_l2_auth_get(
    int unit, 
    bcm_l2_auth_addr_t *addr);

/* Delete an L2 address entry from the specified device. */
extern int bcm_l2_auth_delete(
    int unit, 
    bcm_l2_auth_addr_t *addr);

/* Delete an L2 address entry from the specified device. */
extern int bcm_l2_auth_delete_all(
    int unit);

/* Traverse L2 SA authentication objects */
extern int bcm_l2_auth_traverse(
    int unit, 
    bcm_l2_auth_traverse_cb trav_fn, 
    void *user_data);

/* 
 * The callback will be called on entries that match the given entry and
 * flags (similar to l2_replace)
 */
extern int bcm_l2_matched_traverse(
    int unit, 
    uint32 flags, 
    bcm_l2_addr_t *match_addr, 
    bcm_l2_traverse_cb trav_fn, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Flags for bcm_l2_traverse_match API. */
#define BCM_L2_TRAVERSE_MATCH_STATIC        (1 << 0)   /* Match L2 static
                                                          entries together with
                                                          all other entries, if
                                                          not present only
                                                          dynamic entries will
                                                          match */
#define BCM_L2_TRAVERSE_MATCH_MAC           (1 << 1)   /* Match L2 entries with
                                                          given MAC address */
#define BCM_L2_TRAVERSE_MATCH_VLAN          (1 << 2)   /* Match L2 entries with
                                                          given VLAN ID */
#define BCM_L2_TRAVERSE_MATCH_DEST          (1 << 3)   /* Match L2 entries with
                                                          given modid port/tgid */
#define BCM_L2_TRAVERSE_IGNORE_DISCARD_SRC  (1 << 4)   /* match entries ignoring
                                                          destination SA-discard
                                                          indication */
#define BCM_L2_TRAVERSE_IGNORE_DES_HIT      (1 << 5)   /* match entries ignoring
                                                          destination hit-bit
                                                          indication */
#define BCM_L2_TRAVERSE_IGNORE_SRC_HIT      (1 << 6)   /* match entries ignoring
                                                          source hit-bit
                                                          indication */
#define BCM_L2_TRAVERSE_MATCH_NATIVE        (1 << 7)   /* Match entries with
                                                          given local address
                                                          indication */

/* BCM_L2_MAC_PORT_* flags. */
#define BCM_L2_MAC_PORT_WITH_ID 0x00000001 /* create mac port with specified ID */
#define BCM_L2_MAC_PORT_REPLACE 0x00000002 /* Replace existing mac port */

/* MAC port type. */
typedef struct bcm_l2_mac_port_s {
    uint32 flags;               /* BCM_L2_MAC_PORT_xxx. */
    bcm_mac_t mac;              /* MAC address to match. */
    bcm_gport_t port;           /* Physical port / trunk */
    bcm_gport_t mac_port_id;    /* MAC GPORT ID. */
} bcm_l2_mac_port_t;

/* Initialize the MAC port structure. */
extern void bcm_l2_mac_port_t_init(
    bcm_l2_mac_port_t *mac_port);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create MAC port */
extern int bcm_l2_mac_port_create(
    int unit, 
    bcm_l2_mac_port_t *mac_port);

/* Destroy MAC port. */
extern int bcm_l2_mac_port_destroy(
    int unit, 
    bcm_gport_t mac_port_id);

/* Destroy all MAC ports. */
extern int bcm_l2_mac_port_destroy_all(
    int unit);

/* Get MAC Port information */
extern int bcm_l2_mac_port_get(
    int unit, 
    bcm_l2_mac_port_t *mac_port);

#endif /* BCM_HIDE_DISPATCHABLE */

/* MAC port traverse function prototype. */
typedef int (*bcm_l2_mac_port_traverse_cb)(
    int unit, 
    bcm_l2_mac_port_t *mac_port, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* Traverse MAC ports */
extern int bcm_l2_mac_port_traverse(
    int unit, 
    bcm_l2_mac_port_traverse_cb cb, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Struct to get gport forward info */
typedef struct bcm_l2_gport_forward_info_s {
    int phy_gport; 
    int encap_id; 
} bcm_l2_gport_forward_info_t;

/* Initialize bcm_l2_gport_forward_info_t struct */
extern void bcm_l2_gport_forward_info_t_init(
    bcm_l2_gport_forward_info_t *forward_info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Map gport-id to forwarding information */
extern int bcm_l2_gport_forward_info_get(
    int unit, 
    int gport_id, 
    bcm_l2_gport_forward_info_t *forward_info);

/* Purge L2 Entries for the specific set of (port,vlan) pairs. */
extern int bcm_l2_addr_delete_by_vlan_gport_multi(
    int unit, 
    uint32 flags, 
    int num_pairs, 
    bcm_vlan_t *vlan, 
    bcm_gport_t *gport);

#endif /* BCM_HIDE_DISPATCHABLE */

#endif /* __BCM_L2_H__ */
