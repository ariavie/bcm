/* vxbUsrCmdLine.c - source file for vxBus command-line builds */

/**********************************************
*
* Copyright (C) 2007-2008 Wind River Systems, Inc. All rights are reserved.
*
* The right to copy, distribute, modify, or
* otherwise make use of this software may be
* licensed only pursuant to the terms of an
* applicable Wind River license agreement.
*/

/*
 *
 *                 DO NOT EDIT
 *
 *
 * This file is automatically generated.
 *
 * If you have added/modified files in
 * /target/config/comps/src/hwif folder,
 * you need to re-create vxbUsrCmdLine.c.
 * Move to /target/config/comps/src/hwif and 
 * execute make vxbUsrCmdLine.c 
 */

#include <vxWorks.h>
#include "config.h"

#ifndef INCLUDE_VXBUS

/* vxBusIncluded: prevent compiler warning */

BOOL vxBusIncluded = FALSE;

#else /* INCLUDE_VXBUS */

BOOL vxBusIncluded = TRUE;

#ifndef PRJ_BUILD

#include <vxBusLib.h>
#include <hwif/vxbus/vxBus.h>

IMPORT void plbRegister(void);
IMPORT STATUS vxbDevInitInternal (void);
IMPORT STATUS vxbDevConnectInternal (void);

/* vxBus Device Driver */

IMPORT void lnPciRegister(void);

IMPORT void bmtPhyRegister(void);

IMPORT void brgPhyRegister(void);

#ifdef INCLUDE_VXB_CPM
#include "../src/hwif/h/resource/cpm.h"
#endif


IMPORT void dmPhyRegister(void);

#ifdef INCLUDE_FCC_VXB_END
#include "../src/hwif/h/end/fccVxbEnd.h"
#endif


IMPORT void fecRegister(void);

IMPORT void feiRegister(void);

#ifdef INCLUDE_GT64120A_PCI
extern void g64120aPciRegister (void);
#endif /* INCLUDE_GT64120A_PCI */

#ifdef INCLUDE_GT64120A_MF
extern void g64120aMfRegister (void);
#endif /* INCLUDE_GT64120A_MF */

IMPORT void geiRegister(void);

#ifdef	INCLUDE_GEI_HEND
extern void geiHEndRegister (void);
#endif	/* INCLUDE_GEI_HEND */

IMPORT void geiTbiPhyRegister(void);

IMPORT void genPhyRegister(void);

IMPORT void genTbiRegister(void);

IMPORT void iProcCcbTimerDrvRegister(void);

IMPORT void iProcPCIeRegister(void);

IMPORT void iProcVxbEndRegister(void);

IMPORT void icpRegister(void);

#ifdef DRV_PCIBUS_IXP4XX
extern void ixPciRegister (void);
#ifdef INCLUDE_END2
void vxbDmaEnd2BufIxp4xxPciInit (void);
#endif
#endif /* DRV_PCIBUS_IXP4XX */

IMPORT void lxtPhyRegister(void);

IMPORT void m83xxPciExRegister(void);
#ifdef DRV_RESOURCE_M85XXCCSR
extern void m85xxCCSRRegister(void);
#endif /* DRV_RESOURCE_M85XXCCSR */

#ifdef INCLUDE_M85XX_CPU
extern void m85xxCpuRegister(void);
#endif /* INCLUDE_M85XX_CPU */

#ifdef INCLUDE_M85XX_RAPIDIO
extern void m85xxRioRegister(void);
#endif /* INCLUDE_M85XX_RAPIDIO */

#ifdef INCLUDE_MCF5475_PCI
extern void mcf5475PciRegister (void);
#endif /* INCLUDE_MCF5475_PCI */

#ifdef INCLUDE_MDIO
#include "../src/hwif/h/mii/mdio.h"
#endif /* INCLUDE_MDIO */

IMPORT void motEtsecHEndRegister(void);

IMPORT void motFecHEndRegister(void);

IMPORT void motTsecHEndRegister(void);

IMPORT void mvfPhyRegister(void);

IMPORT void mvPhyRegister(void);

IMPORT void ynRegister(void);

IMPORT void eneRegister(void);

IMPORT void nseRegister(void);

IMPORT void nicRegister(void);

#ifdef INCLUDE_PENTIUM_PCI
extern void pentiumPciRegister (void);
#endif /* INCLUDE_PENTIUM_PCI */

#ifdef INCLUDE_PPC440GP_PCI
#include <busCtlr/ppc440gpPci.c>
#endif /* INCLUDE_PPC440GP_PCI */

IMPORT void qeFccHEndRegister(void);

IMPORT void rtlRegister(void);

IMPORT void rtgPhyRegister(void);

IMPORT void rtgRegister(void);

IMPORT void rtlPhyRegister(void);

IMPORT void sbeRegister(void);

#ifdef INCLUDE_SCC_VXB_END
IMPORT void sccRegister (void);
#endif


#ifdef INCLUDE_SPI4000_MDIO

#if !defined (INCLUDE_OCTEON_SPI4000) || !defined (INCLUDE_SPI4000_PHY)
#error "INCLUDE_SPI4000_MDIO requires INCLUDE_OCTEON_SPI4000 and INCLUDE_SPI4000_PHY"
#endif

IMPORT void spi4000MdioRegister(void);
#endif /* INCLUDE_SPI4000_MDIO */

#ifdef INCLUDE_SPI4000_PHY

#if !defined (INCLUDE_OCTEON_SPI4000) || !defined (INCLUDE_SPI4000_MDIO)
#error "INCLUDE_SPI4000_PHY requires INCLUDE_OCTEON_SPI4000 and INCLUDE_SPI4000_MDIO"
#endif

IMPORT void spi4000PhyRegister(void);
#endif /* INCLUDE_SPI4000_PHY */

IMPORT void elPciRegister(void);

#ifdef INCLUDE_TSEC_MDIO
#include "../src/hwif/h/mii/tsecMdio.h"
#endif /* INCLUDE_MDIO */

IMPORT void tsecRegister(void);

#ifdef INCLUDE_UCC_MDIO
#include "../src/hwif/h/mii/uccMdio.h"
#endif /* INCLUDE_MDIO */

IMPORT void vigPhyRegister(void);

IMPORT void ads5121eCpldIntCtlrRegister (void);

#ifdef DRV_TIMER_AMBA
extern void vxbAmbaTimerDrvRegister (void);
#endif


extern void vxbArmAxiPciRegister(void);

#ifdef DRV_ARM_GIC
extern void vxbArmGenIntCtlrRegister(void);
#endif /* DRV_ARM_GIC */

#ifdef DRV_ARM_MPCORE_TIMER
extern void armMpCoreTimerDrvRegister (void);
#endif


IMPORT void at91EmacRegister(void);
IMPORT void vxbAt91IntCtlrRegister(void);
IMPORT void vxbAt91SioRegister (void);
IMPORT void vxbAt91TimerDrvRegister (void);
#ifdef DRV_TIMER_CN3XXX
#include <timer/vxbCn3xxxTimer.c>
#endif


extern void vxbCns3xxxEndRegister (void);

#ifdef DRV_PCIBUS_CNS3XXX_EX
IMPORT void cns3xxxPcieRegister();
#endif /* DRV_PCIBUS_CNS3XXX_EX */


#ifdef DRV_TIMER_CNS3XXX
extern void vxbCns3xxxTimerDrvRegister (void);
#endif /* DRV_TIMER_CNS3XXX */


#ifdef DRV_SIO_COLDFIRE
extern void coldFireSioRegister (void);
#endif /* DRV_SIO_COLDFIRE */


extern void davinciEmacRegister(void); 

extern void vxbDavinciIntCtlrRegister(void);

extern void dv16550SioRegister (void);

extern void vxbDavinciTimerDrvRegister (void);

IMPORT void dcRegister(void);

IMPORT void dm9000aRegister (void);

#ifdef DRV_MII_DTEPHY
IMPORT void xlrXgmacRegister(void);
#endif


IMPORT void vxbDtsecEndRegister(void);

IMPORT void dtmRegister(void);

#ifdef INCLUDE_DUMMY_MDIO
IMPORT void dummyMdioRegister(void);
#endif

#ifdef DRV_EB_GIC
extern void vxbEbGenIntrCtlRegister(void);
#endif /* DRV_EB_GIC */

#ifdef DRV_INTCTLR_EPIC
extern void vxbEpicIntCtlrRegister (void);
#endif /* DRV_INTCTLR_EPIC */

IMPORT void etsecRegister(void);

#if defined (INCLUDE_ETSEC_VXB_END) && defined (INCLUDE_ETSEC_VXB_END2)
#error "INCLUDE_ETSEC_VXB_END and INCLUDE_ETSEC_VXB_END2 are both defined"
#endif

#if defined (INCLUDE_ETSEC_VXB_END2) && !defined (INCLUDE_END2)
#error "INCLUDE_ETSEC_VXB_END2 requires INCLUDE_END2"
#endif

IMPORT void etsecEnd2Register(void);

#ifdef DRV_NVRAM_FILE
IMPORT void vxbFileNvRamRegister(void);
#endif /* DRV_NVRAM_FILE */


IMPORT void fslAxeRegister (void);
#ifdef DRV_DMA_FSL
IMPORT void vxbFslDmaRegister (void);
#endif  /* DRV_DMA_FSL */

IMPORT void fslGpioRegister(void);

IMPORT void fslI2cRegister(void);

extern void vxbFslSataStorageRegister (void);

#if defined (INCLUDE_GEI825XX_VXB_END) && defined (INCLUDE_GEI825XX_VXB_END2)
#error "INCLUDE_GEI825XX_VXB_END and INCLUDE_GEI825XX_VXB_END2 are both defined"
#endif

#if defined (INCLUDE_GEI825XX_VXB_END2) && !defined (INCLUDE_END2)
#error "INCLUDE_GEI825XX_VXB_END2 requires INCLUDE_END2"
#endif

IMPORT void geiEnd2Register(void);

IMPORT void imRegister(void);

#ifdef DRV_KBD_I8042
extern void i8042vxbRegister (void);
#endif

#ifdef DRV_TIMER_I8253
    extern void vxbI8253TimerDrvRegister (void);
#endif /* DRV_TIMER_I8253 */

#ifdef DRV_INTCTLR_I8259
extern void vxbI8259IntCtlrRegister (void);
#endif /* DRV_INTCTLR_I8259 */


#ifdef INCLUDE_IPIIX4_MF
extern void vxbIPiix4MfRegister (void);
#endif


#ifdef INCLUDE_EMAC_VXB_END
#include "../src/hwif/h/end/vxbIbmEmacEnd.h"
#endif


#ifdef INCLUDE_VXB_IBM_MAL
extern void vxbMalRegister(void);
#endif /* INCLUDE_VXB_IBM_MAL */

#ifdef INCLUDE_VXB_IBM_RGMII
extern void rgmiiRegister(void);
#endif /* INCLUDE_VXB_IBM_RGMII */

#ifdef INCLUDE_VXB_IBM_TAH
extern void tahRegister(void);
#endif /* INCLUDE_VXB_IBM_TAH */

#ifdef INCLUDE_VXB_IBM_ZMII
extern void zmiiRegister(void);
#endif /* INCLUDE_VXB_IBM_ZMII */

extern void vxbImx31EpitTimerDrvRegister (void);

extern void vxbImx31GptTimerDrvRegister (void);

extern void vxbImx31IntCtlrRegister(void);

extern void vxbImxSioRegister (void);

#ifdef INCLUDE_DRV_STORAGE_INTEL_AHCI
    extern void vxbIntelAhciStorageRegister (void);
#endif /* INCLUDE_DRV_STORAGE_INTEL_AHCI */

#ifdef INCLUDE_DRV_STORAGE_INTEL_AHCI_SHOW
    extern STATUS ahciShowInit (void);
#endif /* INCLUDE_DRV_STORAGE_INTEL_AHCI_SHOW */

extern void vxbIntelEdmaRegister (void);

extern void vxbIntelGcuRegister (void);

#ifdef INCLUDE_DRV_STORAGE_INTEL_ICH
    extern void vxbIntelIchStorageRegister (void);
#endif /* INCLUDE_DRV_STORAGE_INTEL_ICH */

#ifdef INCLUDE_DRV_STORAGE_INTEL_ICH_SHOW
    extern STATUS ichAtaShowInit (void);
#endif /* INCLUDE_DRV_STORAGE_INTEL_ICH_SHOW */

#ifdef DRV_TIMER_IA_TIMESTAMP
extern void vxbIaTimestampDrvRegister(void);
#endif


IMPORT void vxbIntelTopcliffEndRegister(void);

IMPORT void iohRegister(void);

#ifdef DRV_INTCTLR_IOAPIC
extern void vxbIoApicIntrDrvRegister (void);
#endif /* DRV_INTCTLR_IOAPIC */

#ifdef DRV_SIO_IXP400
extern void ixp400SioRegister (void);
#endif /* DRV_SIO_IXP400 */

#ifdef DRV_TIMER_IXP400
extern void ixp400TimerDrvRegister (void);
#endif

IMPORT void vxbVirtualPciRegister (void);

#ifdef DRV_INTCTLR_LOAPIC
extern void vxbLoApicIntrDrvRegister (void);
#endif /* DRV_INTCTLR_LOAPIC */

#ifdef DRV_TIMER_LOAPIC
extern void vxbLoApicTimerDrvRegister(void);
#endif


IMPORT void lpc24xxEndRegister(void);
IMPORT void vxbLpc24xxIntCtlrRegister(void);
IMPORT void vxbLpc24xxTimerDrvRegister (void);
IMPORT void m512xDmaRegister(void);

IMPORT void m512xFecRegister(void);
IMPORT void m512xFifocRegister (void);
#ifdef DRV_DMA_COLDFIRE
IMPORT void m548xDmaDrvRegister (void);
#endif

#ifdef DRV_TIMER_COLDFIRE
extern void m54x5TimerDrvRegister (void);
#endif

IMPORT void m5xxxGPTimerRegister (void);

IMPORT void m5xxxPscSioRegister (void);

#ifdef DRV_VGA_M6845
extern void m6845vxbRegister (void);
#endif

#ifdef DRV_TIMER_M85XX
extern void m85xxTimerDrvRegister (void);
#endif /* DRV_TIMER_M85XX */   

#ifdef DRV_TIMER_MC146818
extern void vxbMc146818RtcDrvRegister (void);
#endif /* DRV_TIMER_MC146818 */   

#ifdef DRV_TIMER_MCF
extern void mcfPitTimerDrvRegister (void);
#endif

#ifdef DRV_INTCTLR_MIPS_CAV
#include <intCtlr/vxbMipsCavIntCtlr.c>
#endif /* DRV_INTCTLR_MIPS_CAV */

#ifdef DRV_INTCTLR_MIPS
extern void  vxbMipsIntCtlrRegister (void);
#endif /* DRV_INTCTLR_MIPS */

#ifdef DRV_INTCTLR_MIPS_MT_IPI
extern void vxbMipsMtIntCtlrRegister (void);
#endif /* DRV_INTCTLR_MIPS_MT_IPI */

#ifdef DRV_TIMER_MIPSR4K
    extern void vxbR4KTimerDrvRegister (void);
#endif /* DRV_TIMER_MIPSR4K */

#ifdef DRV_INTCTLR_MIPS_SBE
extern void vxbMipsSbIntCtlrRegister (void);
#endif /* DRV_INTCTLR_MIPS_SBE */

#ifdef DRV_INTCTLR_MIPS_XLR
extern void vxbMipsXlrIntCtlrRegister (void);
#endif /* DRV_INTCTLR_MIPS_XLR */

#ifdef DRV_INTCTLR_MPAPIC
extern void vxbMpApicDrvRegister (void);
#endif /* DRV_INTCTLR_MPAPIC */

#ifdef INCLUDE_MSC01_PCI
extern void vxbMsc01PciRegister(void);
#endif /* INCLUDE_MSC01_PCI */


IMPORT void myeRegister(void);

#ifdef DRV_SIO_NS16550
extern void ns16550SioRegister (void);
#endif /* DRV_SIO_NS16550 */

#ifdef INCLUDE_OCTEON_VXB_END

#ifdef INCLUDE_OCTEON_RGMII_VXB_END
#error "INCLUDE_OCTEON_VXB_END and INCLUDE_OCTEON_RGMII_VXB_END cannot both be included."
#endif
#if !defined (INCLUDE_OCTEON_RGMII) && !defined (INCLUDE_OCTEON_SPI4000)
#error "INCLUDE_OCTEON_VXB_END requires at least one of INCLUDE_OCTEON_RGMII or INCLUDE_OCTEON_SPI4000"
#endif
#if !defined (INCLUDE_END2)
#error "INCLUDE_OCTEON_VXB_END requires INCLUDE_END2"
#endif

IMPORT void octEndRegister(void);
#endif

#ifdef INCLUDE_OCTEON_MDIO
#include "../config/cav_cn3xxx_mipsi64r2sf/vxbOcteonMdio.h"
#endif


IMPORT void octPciRegister(void);


IMPORT void octPciExRegister(void);


#ifdef INCLUDE_OCTEON_RGMII_VXB_END
IMPORT void octRgmiiRegister (void);
#endif


#ifdef DRV_SIO_OCTEON
#include <sio/vxbOcteonSio.c>
#endif /* DRV_SIO_OCTEON */

IMPORT void vxbOmap2530IntCtlrRegister (void);

IMPORT void vxbOmap2530TimerDrvRegister (void);

IMPORT void omap35xxDmaRegister(void);

#ifdef DRV_INTCTLR_OMAP35XX
extern void vxbOmap35xxIntCtlr (void);
#endif /* DRV_INTCTLR_OMAP35XX */

IMPORT void omap35xxMmchsRegister (void);
#ifdef DRV_TIMER_OMAP35XX
extern void vxbOmap35xxTimerDrvRegister (void);
#endif /* DRV_TIMER_OMAP35XX */

IMPORT void vxbOmapL137IntCtlrRegister (void);

#ifdef DRV_TIMER_OPENPIC
IMPORT void openPicTimerDrvRegister(void);
#endif

IMPORT void ppc405TimerRegister (void);

IMPORT void ppc440TimerRegister (void);

IMPORT void ppc4xxPciRegister(void);

IMPORT void ppc4xxPciExRegister (void);

IMPORT void uicIntCtlrRegister (void);

#ifdef DRV_TIMER_DEC_PPC
extern void ppcDecTimerDrvRegister (void);
#endif

#ifdef DRV_INTCTLR_PPC
extern void ppcIntCtlrRegister (void);
#endif /* DRV_INTCTLR_PPC */

#ifdef DRV_TIMER_QUICC_PPC
extern void quiccTimerDrvRegister (void);
#endif

#ifdef	DRV_SIO_PRIMECELL
    extern void vxbPrimeCellSioRegister (void);
#endif	/* DRV_SIO_PRIMECELL */

extern void vxbPxa3xxGpioIntCtlrRegister(void);

extern void vxbPxa3xxIntCtlrRegister(void);

extern void vxbPxa3xxTimerRegister (void);

#ifdef DRV_INTCTLR_QE
#include <hwif/intCtlr/vxbQeIntCtlr.h>
#endif /* DRV_INTCTLR_QE */


IMPORT void bmanRegister(void);

IMPORT void fmanRegister(void);

IMPORT void fmanPrSpAsmInit(void);

IMPORT void lawRegister(void);

IMPORT void vxbQorIQPexRegister (void);

IMPORT void qmanRegister(void);

#ifdef DRV_INTCTLR_QUICC
#include <hwif/intCtlr/vxbQuiccIntCtlr.h>
#endif /* DRV_INTCTLR_QUICC */


#ifdef INCLUDE_XLR_GMAC_VXB_END
IMPORT void xlrGmacRegister(void);
#endif


#ifdef INCLUDE_RMI_MDIO
#include "../src/hwif/h/mii/vxbRmiMdio.h"
#endif /* INCLUDE_RMI_MDIO */

#ifdef DRV_VXBEND_XLRXGMAC
IMPORT void xlrXgmacRegister(void);
#endif


#ifdef DRV_STORAGE_SI31XX
    extern void vxbSI31xxStorageRegister (void);
#endif /* DRV_STORAGE_SI31XX */

#ifdef DRV_SIO_SB1
    extern void vxbSb1DuartSioRegister (void);
#endif /* DRV_SIO_SB1 */


#ifdef DRV_TIMER_SB1
extern void vxbSb1TimerDrvRegister (void);   
#endif


IMPORT void sdhcStorageRegister (void);

#ifdef DRV_TIMER_SH7700
extern void sh7700TimerDrvRegister (void);
#endif

#ifdef DRV_SIO_SHSCIF
extern void shScifSioRegister (void);
#endif /* DRV_SIO_SHSCIF */

#ifdef	INCLUDE_SIO_UTILS
#include <../config/comps/src/usrVxbSioChanUtil.c>
#endif	/* INCLUDE_SIO_UTILS */

#ifdef	DRV_SUPERIO_SMCFDC37X
    extern void vxbSmcFdc37xRegister (void);
#endif	/* DRV_SUPERIO_SMCFDC37X */

IMPORT void smeRegister(void);

IMPORT void smscRegister(void);

IMPORT void stmSpear13xxGmacRegister (void);

IMPORT void stmSpear13xxTimerRegister (void);
IMPORT void teiRegister(void);

#if defined (DRV_VXBEND_TEI82598) && defined (DRV_VXBEND2_TEI8259X)
#error "DRV_VXBEND_TEI82598 and DRV_VXBEND2_TEI8259X are both defined"
#endif

#if defined (DRV_VXBEND2_TEI8259X) && !defined (INCLUDE_END2)
#error "DRV_VXBEND2_TEI8259X requires INCLUDE_END2"
#endif

IMPORT void teiEnd2Register(void);

IMPORT void vxbTgecEndRegister(void);

IMPORT void tgmRegister(void);

extern void tiEmacRegister(void);

#if defined (INCLUDE_TSEC_VXB_END) && defined (INCLUDE_TSEC_VXB_END2)
#error "INCLUDE_TSEC_VXB_END and INCLUDE_TSEC_VXB_END2 are both defined"
#endif

#if defined (INCLUDE_TSEC_VXB_END2) && !defined (INCLUDE_END2)
#error "INCLUDE_TSEC_VXB_END2 requires INCLUDE_END2"
#endif

IMPORT void tsecEnd2Register(void);

IMPORT void uccRegister(void);

#ifdef INCLUDE_EHCI
extern void usbEhcdInstantiate (void );
extern int usbEhcdInit (void);
extern void vxbUsbEhciRegister (void);
#endif

#ifdef INCLUDE_OHCI
extern void usbOhciInstantiate (void );
extern STATUS usbOhcdInit (void);
extern void vxbUsbOhciRegister (void);
#endif

#ifdef INCLUDE_SYNOPSYSHCI
extern void usbSynopsysHcdInstantiate (void);
extern int usbSynopsysHcdInit (void);
extern void vxbUsbSynopsyshciRegister (void);
#endif

#ifdef INCLUDE_UHCI
extern void usbUhcdInstantiate (void );
extern int usbUhcdInit (void);
extern void vxbUsbUhciRegister (void);
#endif

/*
 * USB Initialization - the USBD must be initted before the host controller
 */
#ifdef INCLUDE_USB_INIT
IMPORT STATUS usbInit (void); 
#endif

IMPORT void vrRegister(void);

#ifdef DRV_INTCTRL_VIOAPIC
extern void vxbVioApicIntrDrvRegister (void);
#endif /* DRV_INTCTRL_VIOAPIC */

IMPORT void vxbVxSimIntCtlrRegister(void);

IMPORT void xlrCpldRegister();

#ifdef INCLUDE_XLR_FMN
IMPORT void xlrFmnRegister();
#endif

#ifdef INCLUDE_XLR_TIMER
extern void vxbXlrTimerDrvRegister (void);
#endif /* INCLUDE_XLR_TIMER */

#ifdef INCLUDE_XLR_PCI
IMPORT void xlrPciRegister(void); 
#endif


#ifdef DRV_PCIBUS_XLS_PCIEX
IMPORT void xlsPciExRegister(void); 
#endif /* DRV_PCIBUS_XLS_PCIEX */


IMPORT void wrsampleRegister(void);


/* vxBus Bus Controller Drivers */

#ifdef DRV_PCIBUS_M83XX
extern void m83xxPciRegister (void);
#endif /* DRV_PCIBUS_M83XX */


#ifdef DRV_PCIBUS_M85XX
extern void m85xxPciRegister (void);
#endif /* DRV_PCIBUS_M85XX */

#ifdef INCLUDE_MII_BUS
#include <mii/miiBus.h>
#endif

/* vxbPci.bc - VxBus PCI configuration */

/*
 * Copyright (c) 2008-2009, 2011 Wind River Systems, Inc.
 *
 * The right to copy, distribute or otherwise make use of this software
 * may be licensed only pursuant to the terms of an applicable Wind River
 * license agreement.
 */

/*
modification history
--------------------
01i,08apr11,y_c  updated vxbPciAutoDevProbe() to inherit bus attributes
                 from their bridge when the pciclass of the devices is
                 PCI_CLASS_PROCESSOR. (WIND00265094)
01h,05may09,e_d  updated vxbPciAutoMemAlloc() to return 1 if PCI 64 bit 
                 address autoconfiguration failed. Then the next base 
                 address register will be skipped. (CQ:WIND00164350)
01g,30oct08,h_k  updated vxbPciAutoFuncConfig() to exclude the devices set
                 PCI_AUTO_ATTR_DEV_EXCLUDE attribute from auto-config.
                 (CQ:142006)
                 fixed missing pciAutoDebug when PCI_AUTO_DEBUG is defined.
                 (CQ:141771)
01f,24oct08,h_k  fixed compile error with VXB_LEGACY_ACCESS.
01e,20aug08,h_k  fixed header paths.
01d,30jul08,h_k  fixed vxbPciAutoBusConfig() (CQ:129417)
                 added missing pciConfigModifyXxx(). (CQ:120805)
                 removed debug code from vxbPciAutoBusConfig().
01c,16jul08,tor  Fix cut-n-paste typos
01b,07jul08,dtr  Reset busno array before each bus controller is configured.
01a,08jul08,tor  created
*/

#ifdef INCLUDE_PCI_BUS

/* includes */

#include <vxWorks.h>
#include <vxBusLib.h>
#include <hwif/vxbus/vxBus.h>
#include <../src/hwif/h/vxbus/vxbAccess.h>
#include <hwif/vxbus/hwConf.h>
#include <hwif/util/hwMemLib.h>
#include <hwif/vxbus/vxbPciLib.h>
#include <../src/hwif/h/vxbus/vxbPciBus.h>
#include <../src/hwif/intCtlr/vxbIntDynaCtlrLib.h>
#include <drv/pci/pciConfigShow.h>
#include <drv/pci/pciHeaderDefs.h>
#include <pciClass.h>

#include <drv/pci/pciConfigLib.h>
#include <drv/pci/pciAutoConfigLib.h>
#include <drv/pci/pciIntLib.h>
#include <errnoLib.h>
#include <dllLib.h>
#include <iv.h>

#include <string.h>
#include <stdio.h>

#include <logLib.h>
#include <intLib.h>

#ifdef  PCI_AUTO_DEBUG
#define PCI_LOG_MSG(s, a, b, c, d, e, f) \
    do { \
        if (_func_logMsg != NULL) \
            { \
            (*_func_logMsg)(s, a, b, c, d, e, f); \
        if ( taskIdCurrent != NULL ) \
            taskDelay(10); \
            } \
    } while (FALSE)

#define PCI_AUTO_DEBUG_MSG(s, a, b, c, d, e, f) \
    do { \
    if ( pciAutoDebug == TRUE ) \
        { \
        PCI_LOG_MSG (s, a, b, c, d, e, f); \
        } \
    } while (FALSE)
#else   /* PCI_AUTO_DEBUG */
#define PCI_LOG_MSG(s, a, b, c, d, e, f)
#define PCI_AUTO_DEBUG_MSG(s, a, b, c, d, e, f)
#endif  /* PCI_AUTO_DEBUG */

#ifdef VXB_LEGACY_ACCESS
#ifdef  VXB_ACCESS_DEBUG 

    #define VXB_ACCESS_PCI_LOG_ERROR(fmt,a,b,c,d,e,f)  logMsg(fmt,a,b,c,d,e,f)

#else

    #define VXB_ACCESS_PCI_LOG_ERROR(fmt,a,b,c,d,e,f)

#endif

#define VXB_PCI_INIT_FLAGS_16(flags)                    \
    if ((flags & VXBAF_ENDIAN_MASK) == 0)                   \
       flags |= VXBAF_BYTE_ORDER_LE_16;

#define VXB_PCI_INIT_FLAGS_32(flags)                    \
    if ((flags & VXBAF_ENDIAN_MASK) == 0)                   \
       flags |= VXBAF_BYTE_ORDER_LE_32;

#define VXB_PCI_INIT_FLAGS_64(flags)                    \
    if ((flags & VXBAF_ENDIAN_MASK) == 0)                   \
       flags |= VXBAF_BYTE_ORDER_LE_64;

#define VXB_PCI_LE_CONVERT_16(flags, data)                          \
    {                                                               \
    /* initialize the flags */                      \
    VXB_PCI_INIT_FLAGS_16(flags);                   \
                                                                    \
    /*                                                              \
     * check if the data is in LE byte order. If it is not,         \
     * then perform the byte order conversion and update the flags  \
     */                                                             \
    if ((flags & VXBAF_ENDIAN_MASK) != VXBAF_BYTE_ORDER_LE_16)      \
        {                                                           \
        /* swap the bytes */                                        \
                                                                    \
        VXBAF_BYTE_SWAP_16(data);                                   \
                                                                    \
        /* clear the masks */                                       \
                                                                    \
        flags &= ~(VXBAF_ENDIAN_MASK);                              \
                                                                    \
        /* update the flags */                                      \
                                                                    \
        flags |= VXBAF_BYTE_ORDER_LE_16;                            \
                                                                    \
        /* Update the conversion bits */                            \
                                                                    \
        flags ^= (VXBAF_CONVERT_BYTE_ORDER);                        \
        }                                                           \
    }

#define VXB_PCI_LE_CONVERT_32(flags, data)                          \
    {                                       \
    /* initialize the flags */                      \
    VXB_PCI_INIT_FLAGS_32(flags);                   \
                                                                    \
    /*                                                              \
     * check if the data is in LE byte order. If it is not,         \
     * then perform the byte order conversion and update the flags  \
     */                                                             \
    if ((flags & VXBAF_ENDIAN_MASK) != VXBAF_BYTE_ORDER_LE_32)      \
        {                                                           \
                                                                    \
        /* swap the bytes */                                        \
                                                                    \
        VXBAF_BYTE_SWAP_32(data);                                   \
                                                                    \
        /* clear the masks */                                       \
                                                                    \
        flags &= ~(VXBAF_ENDIAN_MASK);                              \
                                                                    \
        /* update the flags */                                      \
                                                                    \
        flags |= VXBAF_BYTE_ORDER_LE_32;                            \
                                                                    \
        /* Update the conversion bits */                            \
                                                                    \
        flags ^= (VXBAF_CONVERT_BYTE_ORDER | VXBAF_CONVERT_SHORT_ORDER);    \
        }                                                           \
    }

#define VXB_PCI_LE_CONVERT_64(flags, data)                          \
    {                                                               \
    /* initialize the flags */                      \
    VXB_PCI_INIT_FLAGS_64(flags);                   \
                                                                    \
    /*                                                              \
     * check if the data is in LE byte order. If it is not,         \
     * then perform the byte order conversion and update the flags  \
     */                                                             \
    if ((flags & VXBAF_ENDIAN_MASK) != VXBAF_BYTE_ORDER_LE_64)      \
        {                                                           \
                                                                    \
        /* swap the bytes */                                        \
                                                                    \
        VXBAF_BYTE_SWAP_64(data);                                   \
                                                                    \
        /* clear the masks */                                       \
                                                                    \
        flags &= ~(VXBAF_ENDIAN_MASK);                              \
                                                                    \
        /* update the flags */                                      \
                                                                    \
        flags |= VXBAF_BYTE_ORDER_LE_64;                            \
                                                                    \
        /* Update the conversion bits */                            \
                                                                    \
        flags ^= (VXBAF_CONVERT_BYTE_ORDER | VXBAF_CONVERT_SHORT_ORDER |    \
                     VXBAF_CONVERT_LONG_ORDER);                     \
        }                                                           \
    }
#endif	/* VXB_LEGACY_ACCESS */

/* typedefs */
typedef STATUS (*VXB_PCI_INCLUDE_FUNC)(void *pSystem, PCI_LOC *pLoc, UINT devVend);
typedef UCHAR (*VXB_PCI_INT_ASSIGN_FUNC)(void *pSystem, PCI_LOC *pLoc, UINT devVend);
typedef void (*VXB_PCI_BRIDGE_PRE_CONFIG_FUNC)(void *pSystem, PCI_LOC *pLoc, UINT devVend);
typedef void (*VXB_PCI_BRIDGE_POST_CONFIG_FUNC)(void *pSystem, PCI_LOC *pLoc, UINT devVend);

IMPORT STATUS (*_func_pciAutoCfgCtl)    (void * pCookie, int cmd, void * pArg);
IMPORT STATUS (*_func_vxbPciAutoConfig) (VXB_DEVICE_ID busCtrlID);
IMPORT STATUS (*_func_PCIeRootForeach)
    (
    VXB_DEVICE_ID  busCtrlID,
    int     pciLocBus,          /* PCI bus of PCIe root */
    int     pciLocDevice,       /* PCI device of PCIe root */
    int     pciLocFunction,     /* PCI function of PCIe root */
    VXB_PCI_FOREACH_FUNC funcCheckRtn, /* routine to call for each PCI func */
    void *pArg                  /* argument to funcCheckRtn */
    );
IMPORT STATUS vxbPciIntDisconnect2
    (
    VXB_DEVICE_ID pDev,
    VOIDFUNCPTR *vector,        /* interrupt vector to attach to     */
    VOIDFUNCPTR routine,        /* routine to be called              */
    int parameter               /* routine parameter         */
    );

/* globals */

#ifdef PCI_AUTO_DEBUG
BOOL pciAutoDebug = TRUE;
#endif /* PCI_AUTO_DEBUG */

/* locals */

#ifdef VXB_LEGACY_ACCESS
/* forward declarations */

LOCAL STATUS    pciRegisterProbe
    (
    VXB_DEVICE_ID   pDevInfo,       /* device info */
    void    *       pRegBase,       /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset,     /* offset, in bytes, of register */
    UINT32          transactionSize,/* register size */
    char *          pProbeDatum,    /* value to write */
    char *          pRetVal,        /* value read back */
    UINT32 *        pFlags          /* flags */
    );
LOCAL STATUS    pciRegisterRead8
    (
    VXB_DEVICE_ID   devID,      /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT8 *         pDataBuf,   /* buffer to put data in */
    UINT32 *        pFlags      /* flags */
    );
LOCAL STATUS    pciRegisterRead16
    (
    VXB_DEVICE_ID   devID,      /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT16 *        pDataBuf,   /* buffer to put data in */
    UINT32 *        pFlags      /* flags */
    );
LOCAL STATUS    pciRegisterRead32
    (
    VXB_DEVICE_ID   devID,      /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT32 *        pDataBuf,   /* buffer to put data in */
    UINT32 *        pFlags      /* flags */
    );
LOCAL STATUS    pciRegisterRead64
    (
    VXB_DEVICE_ID   devID,      /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT64 *        pDataBuf,   /* buffer to put data in */
    UINT32 *        pFlags      /* flags */
    );
LOCAL STATUS    pciRegisterWrite8
    (
    VXB_DEVICE_ID   devID,      /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT8 *         pDataBuf,   /* buffer to copy data from */
    UINT32 *        pFlags      /* flags */
    );
LOCAL STATUS    pciRegisterWrite16
    (
    VXB_DEVICE_ID   devID,      /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT16 *        pDataBuf,   /* buffer to copy data from */
    UINT32 *        pFlags      /* flags */
    );
LOCAL STATUS    pciRegisterWrite32
    (
    VXB_DEVICE_ID   devID,      /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT32 *        pDataBuf,   /* buffer to copy data from */
    UINT32 *        pFlags      /* flags */
    );
LOCAL STATUS    pciRegisterWrite64
    (
    VXB_DEVICE_ID   devID,      /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT64 *        pDataBuf,   /* buffer to copy data from */
    UINT32 *        pFlags      /* flags */
    );
LOCAL STATUS    pciVolatileRegisterWrite
    (
    VXB_DEVICE_ID   devID,          /* device info */
    void *          pRegBase,       /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset,     /* offset, in bytes, of register */
    UINT32          transactionSize,/* transaction size, in bytes */
    char *          pDataBuf,   /* buffer to read-from/write-to */
    UINT32 *        pFlags          /* flags */
    );
LOCAL STATUS    pciVolatileRegisterRead
    (
    VXB_DEVICE_ID   devID,          /* device info */
    void *          pRegBase,       /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset,     /* offset, in bytes, of register */
    UINT32          transactionSize,/* transaction size, in bytes */
    char *          pDataBuf,   /* buffer to read-from */
    UINT32 *        pFlags          /* flags */
    );
LOCAL STATUS    pciDevControl
    (
    VXB_DEVICE_ID   devID,          /* device info */
    pVXB_DEVCTL_HDR pBusDevControl  /* parameter */
    );
LOCAL STATUS    pciVolatileRegisterWrite8
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT8 *         pDataBuf,   /* buffer to read-from/write-to */
    UINT32 *        pFlags      /* flags */
    );
LOCAL STATUS    pciVolatileRegisterWrite16
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT16 *        pDataBuf,   /* buffer to read-from/write-to */
    UINT32 *        pFlags      /* flags */
    );
LOCAL STATUS    pciVolatileRegisterWrite32
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT32 *        pDataBuf,   /* buffer to read-from/write-to */
    UINT32 *        pFlags      /* flags */
    );
LOCAL STATUS    pciVolatileRegisterWrite64
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT64 *        pDataBuf,   /* buffer to read-from/write-to */
    UINT32 *        pFlags      /* flags */
    );
LOCAL STATUS    pciBusIntEnable
    (
    VXB_DEVICE_ID       deviceID,              /* device info */
    pVXB_ACCESS_INTERRUPT_INFO  pPciIntrInfo   /* interrupt info */
    );
LOCAL STATUS    pciBusIntDisable
    (
    VXB_DEVICE_ID       deviceID,              /* device info */
    pVXB_ACCESS_INTERRUPT_INFO  pPciIntrInfo   /* interrupt info */
    );
LOCAL STATUS    pciBusIntAcknowledge
    (
    VXB_DEVICE_ID       deviceID,              /* device info */
    pVXB_ACCESS_INTERRUPT_INFO  pPciIntrInfo   /* interrupt info */
    );
LOCAL STATUS    pciBusIntConnect
    (
    VXB_DEVICE_ID       deviceID,              /* device info */
    pVXB_ACCESS_INTERRUPT_INFO  pPciIntrInfo   /* interrupt info */
    );
LOCAL STATUS    pciBusIntDisconnect
    (
    VXB_DEVICE_ID       deviceID,              /* device info */
    pVXB_ACCESS_INTERRUPT_INFO  pPciIntrInfo   /* interrupt info */
    );
LOCAL STATUS    pciBusIntVectorGet
    (
    VXB_DEVICE_ID       deviceID,               /* device info */
    pVXB_ACCESS_INT_VECTOR_GET  pPciIntVecInfo  /* interrupt vector info */
    );
LOCAL STATUS vxbPciLegacyCfgRead
    (
    VXB_DEVICE_ID       pDev,                   /* device info */
    UINT32              byteOffset,             /* offset into cfg space */
    UINT32              transactionSize,        /* transaction size */
    void *              pDataBuf                /* buffer to read/write */
    );
LOCAL STATUS vxbPciLegacyCfgWrite
    (
    VXB_DEVICE_ID       pDev,                   /* device info */
    UINT32              byteOffset,             /* offset into cfg space */
    UINT32              transactionSize,        /* transaction size */
    void *              pDataBuf                /* buffer to read/write */
    );

VXB_ACCESS_LIST pciBusAccessList =
    {
    VXB_BUSID_PCI,          /* PCI bus type */
    1,                      /* version number */
    NULL,                   /* cookie info */
    pciRegisterProbe,       /* to probe a register */
    pciRegisterRead8,       /* to read 8 bits from a register */
    pciRegisterRead16,      /* to read 16 bits from a register */
    pciRegisterRead32,      /* to read 32 bits from a register */
    pciRegisterRead64,      /* to read 64 bits from a register */
    pciRegisterWrite8,      /* to write 8 bits to a register */
    pciRegisterWrite16,     /* to write 16 bits to a register */
    pciRegisterWrite32,     /* to write 32 bits to a register */
    pciRegisterWrite64,     /* to write 64 bits to a register */
    pciVolatileRegisterWrite,   /* to write to a volatile register */
    pciVolatileRegisterRead,    /* to read from a volatile register */
    (VXB_FUNC_CFGRDWR_PTR) vxbPciLegacyCfgRead,
				/* to read from the configuration space */
    (VXB_FUNC_CFGRDWR_PTR) vxbPciLegacyCfgWrite,
				/* to write to the configuration space */
    pciDevControl           /* to perform device control operations */
    };

/******************************************************************************
*
* vxbPciLegacyCfgRead - vxbAccess legacy PCI config read support routine
*
* It performs a configuration space read on a given PCI target.
* If the target specification or register offset is invalid, it will return
* error.
*
* RETURNS: OK, or ERROR if target specification or register is invalid
*
* ERRNO: N/A
*/

LOCAL STATUS vxbPciLegacyCfgRead
    (
    VXB_DEVICE_ID	pDev,			/* device info */
    UINT32		byteOffset,		/* offset into cfg space */
    UINT32		transactionSize,	/* transaction size */
    void *		pDataBuf 	      	/* buffer to read/write */
    )
    {
    struct vxbPciDevice *	pPciDev;
    VXB_DEVICE_ID		pParent;
    FUNCPTR			methodRead;

    /* check if the pDev pointer is valid */

    VXB_ASSERT(pDev != NULL, ERROR)

    pPciDev = (struct vxbPciDevice *) pDev->pBusSpecificDevInfo;

    /* check if the pPciDev pointer is valid */

    VXB_ASSERT(pPciDev != NULL, ERROR)

    pParent = vxbDevParent (pDev);

    methodRead = vxbDevMethodGet (pParent, PCI_CONTROLLER_METHOD_CFG_READ);

    return (methodRead (pParent,
			pPciDev->pciBus,
			pPciDev->pciDev,
			pPciDev->pciFunc,
			byteOffset,
			transactionSize,
			pDataBuf));
    }

/******************************************************************************
*
* vxbPciLegacyCfgWrite - vxbAccess Legacy PCI config write support routine
*
* It performs a configuration space write on a given PCI target.
* If the target specification or register offset is invalid, it will return
* error.
*
* RETURNS: OK, or ERROR if target specification or register is invalid
*
* ERRNO: N/A
*/

LOCAL STATUS vxbPciLegacyCfgWrite
    (
    VXB_DEVICE_ID	pDev,			/* device info */
    UINT32		byteOffset,		/* offset into cfg space */
    UINT32		transactionSize,	/* transaction size */
    void *		pDataBuf 	      	/* buffer to write-to */
    )
    {
    struct vxbPciDevice *	pPciDev;
    VXB_DEVICE_ID		pParent;
    FUNCPTR			methodWrite;

    /* check if the pDev pointer is valid */

    VXB_ASSERT(pDev != NULL, ERROR)

    pPciDev = (struct vxbPciDevice *) pDev->pBusSpecificDevInfo;

    /* check if the pPciDev pointer is valid */

    VXB_ASSERT(pPciDev != NULL, ERROR)

    pParent = vxbDevParent (pDev);

    methodWrite = vxbDevMethodGet (pParent, PCI_CONTROLLER_METHOD_CFG_WRITE);

    return (methodWrite (pParent,
			 pPciDev->pciBus,
			 pPciDev->pciDev,
			 pPciDev->pciFunc,
			 byteOffset,
			 transactionSize,
			 pDataBuf));
    }

/******************************************************************************
*
* pciRegisterProbe - probe a register on a PCI device
*
* This routine is used by the driver to identify whether the device register
* is present and is available.
*
* RETURNS: OK on success, or ERROR if register is not present or unavailable
*
* ERRNO:
*/
LOCAL STATUS    pciRegisterProbe
    (
    VXB_DEVICE_ID   pDevInfo,       /* device info */
    void    *       pRegBase,       /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset,     /* offset, in bytes, of register */
    UINT32          transactionSize,/* register size */
    char *          pProbeDatum,    /* value to write */
    char *          pRetVal,        /* value read back */
    UINT32 *        pFlags          /* flags */
    )
    {
    STATUS          status = ERROR;
    int             count = 0;
    UINT32          bar;
    UINT32          flags;
    UINT32          value = 0xFFFFFFFF;
    struct vxbDev * pUpstreamDevPtr = NULL;
    UINT32 *        pActualRegBase;

    /* check the validity of the parameters */

    if ((pDevInfo == NULL)    || (transactionSize == 0) ||
        (pProbeDatum == NULL) || (pRetVal == (char *   )NULL) ||
        (pFlags == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterProbe: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device pointer */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterProbe : Invalid upstream \
                            device pointer\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * This condition is successful only if the driver resides directly
     * downstream from the PCI bus.
     */
    if ((*pFlags & VXBAF_NOT_FIRST_BUS) == 0)
        {
        /*
         * set the flag which prevents the other layers from
         * checking the validity of base address
         */

        *pFlags |= VXBAF_NOT_FIRST_BUS;

        /*
         * check if the address is valid by scanning through
         * all the pRegBase entries
         */

        for (count = 0; count < 6; count++)
            {
            if (pDevInfo->pRegBase[count] == pRegBase)
                {
                status = OK;
                break;
                }
            }

        /* return ERROR if the pRegBase element is not located */
        if (status != OK)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterProbe :pRegBase is invalid\n",
                                     0,0,0,0,0,0);
            return ERROR;
            }
        /*
         * The following steps try to validate the byteOffset
         * and transactionSize
         */

        /* lock out the interrupts before we manipulate the BAR register */

        vxbLockTake(&pDevInfo->devLock, VXB_LOCK_WRITER);

        /* indicate that no conversion is to be performed */

        flags = VXBAF_BYTE_ORDER_KNOWN;

        /*
         * The BAR register has to be written to 0xFFFFFFFF and then the value
         * read back from BAR register gives the size of memory mapped for the
         * PCI device
         */
       if (pDevInfo->pAccess->busCfgWrite(pDevInfo,
                                         (PCI_CFG_BASE_ADDRESS_0 + (4 * count)),
                                         4,
                                         (char *   )&value,
                                         &flags) != OK)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterProbe: Unable to write \
                                 0xFFFFFFFF to BAR", 0,0,0,0,0,0);

            /* release the lock */
            vxbLockGive(&pDevInfo->devLock, VXB_LOCK_WRITER);

            return ERROR;
            }

        /* re-initialize the flags */

        flags = VXBAF_BYTE_ORDER_KNOWN;

        /* read the BAR register contents */

        if (pDevInfo->pAccess->busCfgRead(pDevInfo,
                                        (PCI_CFG_BASE_ADDRESS_0 + (4 * count)),
                                        4,
                                        (char *   )&value,
                                        &flags) != OK)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterProbe:Unable to read BAR\n",
                                     0,0,0,0,0,0);

            /* release the lock */
            vxbLockGive(&pDevInfo->devLock, VXB_LOCK_WRITER);

            return ERROR;
            }

        /* retrieve the actual base address pointer array */

        pActualRegBase = (UINT32 *)(pDevInfo->pAccess->pCookie);

        /* reinitialize the flags */

        flags = VXBAF_BYTE_ORDER_KNOWN;

        /* retrieve the actual base address */

        bar = pActualRegBase[count];

        /* Write the actual base address */

        if (pDevInfo->pAccess->busCfgWrite(pDevInfo,
                                         (PCI_CFG_BASE_ADDRESS_0 + (4 * count)),
                                         4,
                                         (char *   )&bar,
                                         &flags) != OK)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterProbe:Unable to write \
                           bar value to BAR\n", 0,0,0,0,0,0);

            /* release the lock */
            vxbLockGive(&pDevInfo->devLock, VXB_LOCK_WRITER);

            return ERROR;
            }

        /* release the lock */

        vxbLockGive(&pDevInfo->devLock, VXB_LOCK_WRITER);

        /* calculation of the size of memory or the device - start */

        /* remove the encoding bits */

        if ((pActualRegBase[count] & PCI_BAR_SPACE_MASK) == PCI_BAR_SPACE_IO)
            value &= PCI_IOBASE_MASK;
        else
            value &= PCI_MEMBASE_MASK;

        /* update the flag based on the actual base address */

        if ((pActualRegBase[count] & PCI_BAR_SPACE_MASK)
                                     == PCI_BAR_SPACE_IO)
            *pFlags  |= VXBAF_IO_SPACE_OPERATION;

        /* reuse the count variable */

        count = 0;

	if(value != 0)
	    {
	    while((value & 0x01) == 0)
		{
		count++;
		value >>= 1;

		}
	    }
        value = 0x01 << count;

        /* calculation of the size of memory or the device - end */

        /* Check if the 'byteOffset' and 'transactionSize' are valid */

        if ((byteOffset >= value) ||
            ((byteOffset + transactionSize) >= value))
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterProbe :invalid size \
                                     or byteOffset\n", 0,0,0,0,0,0);
            return ERROR;
            }

        }

    /* if the byte order is already known, do not perform any conversion */

    if ((*pFlags & VXBAF_BYTE_ORDER_KNOWN) == 0)
        {
        /*
         * Perform the conversion on the value to be written,
         * based on the size and the flags value
         */

        switch (transactionSize)
            {
            case 2:
                VXB_PCI_LE_CONVERT_16 (*pFlags, (*((UINT16 *)pProbeDatum)));
                break;
            case 4:
                VXB_PCI_LE_CONVERT_32 (*pFlags, (*((UINT32 *)pProbeDatum)));
                break;
            case 8:
                VXB_PCI_LE_CONVERT_64 (*pFlags, (UINT64)(*pProbeDatum));
                break;
            default:
                break;
            }
        }

    /* call the upstream bus access routine to probe the register address */

    if (pUpstreamDevPtr->pAccess->vxbRegisterProbe (pUpstreamDevPtr,
                                                    pRegBase,
                                                    byteOffset,
                                                    transactionSize,
                                                    pProbeDatum,
                                                    pRetVal,
                                                    pFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterProbe : Upstream bus probe \
                    returned error\n", 0,0,0,0,0,0);
        return ERROR;
        }

    /* if the byte order is already known, do not perform any conversion */

    if ((*pFlags & VXBAF_BYTE_ORDER_KNOWN) == 0)
        {

        /* convert the data read based on the flags and size */

        switch (transactionSize)
            {
            case 2:
                VXB_PCI_LE_CONVERT_16 (*pFlags, (*((UINT16 *)pRetVal)));
                break;
            case 4:
                VXB_PCI_LE_CONVERT_32 (*pFlags, (*((UINT32 *)pRetVal)));
                break;
            case 8:
                VXB_PCI_LE_CONVERT_64 (*pFlags, (UINT64)(*pRetVal));
                break;
            default:
                break;
            }
        }

    /* return success */
    return OK;

    }

/******************************************************************************
*
* pciRegisterRead8 - read 8-bit value from a register
*
* This routine is used by the driver to read 8-bits from a PCI device register.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/
LOCAL STATUS    pciRegisterRead8
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT8 *         pDataBuf,   /* buffer to put data in */
    UINT32 *        pFlags      /* flags */
    )
    {
    struct vxbDev * pUpstreamDevPtr;
    BOOL        firstTime   = FALSE;
    UINT32  baseAddressIndex;
    UINT32  *pActualRegBase;

    /* check whether the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pRegBase  == NULL) ||
        (pDataBuf == NULL) ||
        (pFlags   == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead8: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device info */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead8: pUpstreamDevPtr is \
                                  invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * If this is the first time the function is called, set the flag
     * indicating that this is the first time.
     */
    if (*pFlags == 0)
        {
        firstTime = TRUE;
        *pFlags   = VXBAF_PREVENT_OPTIMIZATION;
        }


    /*
     * This condition will be successful only if the driver resides
     * directly downstream from the PCI bus
     */

    if ((*pFlags & VXBAF_NOT_FIRST_BUS) == 0)
        {
        /*
         * set the flag which prevents the other layers from
         * checking the validity of base address
         */

        *pFlags |= VXBAF_NOT_FIRST_BUS;

        /* check if the cookie pointer is valid */

        if (pDevInfo->pAccess->pCookie == NULL)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead8: \
                             Invalid cookie\n",0,0,0,0,0,0);
            return ERROR;
            }

        /*
         * Identify the index of the base address.
         * This loop can have a performance impact. The ideal way is to pass the
         * index as a parameter to this access routine. Considering the fact
         * that the index will not be used in the optimized version,
         * the delay due to this loop is acceptable.
         */

        for (baseAddressIndex = 0; baseAddressIndex < 6; baseAddressIndex++)
            {
            if (pDevInfo->pRegBase[baseAddressIndex] == pRegBase)
                {
                break;
                }
            }

        /* If the index in invalid, return ERROR */

        if (baseAddressIndex >= 6)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead8: \
                             baseAddressIndex is incorrect\n",0,0,0,0,0,0);
            return ERROR;
            }


        /* Based on the actual base address value, update the flags */

        pActualRegBase = (UINT32 *)(pDevInfo->pAccess->pCookie);

        /* update the flag based on the actual base address */

        if ((pActualRegBase[baseAddressIndex] & PCI_BAR_SPACE_MASK)
                                     == PCI_BAR_SPACE_IO)
            *pFlags  |= VXBAF_IO_SPACE_OPERATION;

        }

    /* call the upstream bus access routine to read 8 bits */

    if (pUpstreamDevPtr->pAccess->registerRead8 (pUpstreamDevPtr,
                                                 pRegBase,
                                                 byteOffset,
                                                 pDataBuf,
                                                 pFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead8: upstream bus \
                        access routine returned error\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * If the driver indicates that this is the first time this function
     * is called, then optimize the access function.
     */

    if (firstTime)
        {
        optimizeAccessFunction (*pFlags, pDevInfo->pAccess, OPT_REG_READ8);
        }

    return OK;
    }

/******************************************************************************
*
* pciRegisterRead16 - read 16-bit value from a register
*
* This routine is used by the driver to read 16-bits from a PCI device register.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/
LOCAL STATUS    pciRegisterRead16
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT16 *        pDataBuf,   /* buffer to put data in */
    UINT32 *        pFlags      /* flags */
    )
    {
    struct vxbDev * pUpstreamDevPtr;
    BOOL        firstTime   = FALSE;
    UINT32  baseAddressIndex;
    UINT32  *pActualRegBase;

    /* check whether the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pRegBase  == NULL) ||
        (pDataBuf == NULL) ||
        (pFlags   == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead16: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device info */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead16: pUpstreamDevPtr is \
                                  invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * If this is the first time the function is called, set the flag
     * indicating that this is the first time.
     */
    if (*pFlags == 0)
        {
        firstTime = TRUE;
        *pFlags = VXBAF_PREVENT_OPTIMIZATION;
        }

    /*
     * This condition will be successful only if the driver resides
     * directly downstream from the PCI bus
     */

    if ((*pFlags & VXBAF_NOT_FIRST_BUS) == 0)
        {
        /*
         * set the flag which prevents the other layers from
         * checking the validity of base address
         */

        *pFlags |= VXBAF_NOT_FIRST_BUS;

        /* update the expected flags */

        if (((*pFlags & VXBAF_BYTE_ORDER_KNOWN) == 0) &&
             ((*pFlags & VXBAF_ENDIAN_MASK) == 0))

            *pFlags |= VXBAF_BYTE_ORDER_LE_16;

        /* check if the cookie pointer is valid */

        if (pDevInfo->pAccess->pCookie == NULL)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead16: \
                             Invalid cookie\n",0,0,0,0,0,0);
            return ERROR;
            }

        /*
         * Identify the index of the base address.
         * This loop can have a performance impact. The ideal way is to pass the
         * index as a parameter to this access routine. Considering the fact
         * that the index will not be used in the optimized version,
         * the delay due to this loop is acceptable.
         */

        for (baseAddressIndex = 0; baseAddressIndex < 6; baseAddressIndex++)
            {
            if (pDevInfo->pRegBase[baseAddressIndex] == pRegBase)
                {
                break;
                }
            }

        /* If the index in invalid, return ERROR */

        if (baseAddressIndex >= 6)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead16: \
                             baseAddressIndex is incorrect\n",0,0,0,0,0,0);
            return ERROR;
            }


        /* Based on the actual base address value, update the flags */

        pActualRegBase = (UINT32 *)(pDevInfo->pAccess->pCookie);

        /* update the flag based on the actual base address */

        if ((pActualRegBase[baseAddressIndex] & PCI_BAR_SPACE_MASK)
                                     == PCI_BAR_SPACE_IO)
            *pFlags  |= VXBAF_IO_SPACE_OPERATION;

        }

    /* call the upstream bus access routine to read 16 bits */

    if (pUpstreamDevPtr->pAccess->registerRead16 (pUpstreamDevPtr,
                                                  pRegBase,
                                                  byteOffset,
                                                  pDataBuf,
                                                  pFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead16: upstream bus \
                        access routine returned error\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* if the byte order is already known, return from the function */

    if ((*pFlags & VXBAF_BYTE_ORDER_KNOWN) != 0)
        return OK;

    /* Perform the conversion and update the flags */
    VXB_PCI_LE_CONVERT_16 (*pFlags, *pDataBuf);

    /*
     * If the driver indicates that this is the first time this function
     * is called, then optimize the access function.
     */

    if (firstTime)
        {
        optimizeAccessFunction (*pFlags, pDevInfo->pAccess, OPT_REG_READ16);
        }

    return OK;
    }

/******************************************************************************
*
* pciRegisterRead32 - read 32-bit value from a register
*
* This routine is used by the driver to read 32-bits from a PCI device register.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/
LOCAL STATUS    pciRegisterRead32
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT32 *        pDataBuf,   /* buffer to put data in */
    UINT32 *        pFlags      /* flags */
    )
    {
    struct vxbDev * pUpstreamDevPtr;
    BOOL        firstTime   = FALSE;
    UINT32  baseAddressIndex;
    UINT32  *pActualRegBase;

    /* check whether the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pRegBase  == NULL) ||
        (pDataBuf == NULL) ||
        (pFlags   == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead32: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device info */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead32: pUpstreamDevPtr is \
                                  invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * If this is the first time the function is called, set the flag
     * indicating that this is the first time.
     */
    if (*pFlags == 0)
        {
        firstTime = TRUE;
        *pFlags = VXBAF_PREVENT_OPTIMIZATION;
        }

    /*
     * This condition will be successful only if the driver resides
     * directly downstream from the PCI bus
     */

    if ((*pFlags & VXBAF_NOT_FIRST_BUS) == 0)
        {
        /*
         * set the flag which prevents the other layers from
         * checking the validity of base address
         */

        *pFlags |= VXBAF_NOT_FIRST_BUS;

        /* update the expected flags */

        if (((*pFlags & VXBAF_BYTE_ORDER_KNOWN) == 0) &&
             ((*pFlags & VXBAF_ENDIAN_MASK) == 0))

            *pFlags |= VXBAF_BYTE_ORDER_LE_32;

        /* check if the cookie pointer is valid */

        if (pDevInfo->pAccess->pCookie == NULL)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead32: \
                             Invalid cookie\n",0,0,0,0,0,0);
            return ERROR;
            }

        /*
         * Identify the index of the base address.
         * This loop can have a performance impact. The ideal way is to pass the
         * index as a parameter to this access routine. Considering the fact
         * that the index will not be used in the optimized version,
         * the delay due to this loop is acceptable.
         */

        for (baseAddressIndex = 0; baseAddressIndex < 6; baseAddressIndex++)
            {
            if (pDevInfo->pRegBase[baseAddressIndex] == pRegBase)
                {
                break;
                }
            }

        /* If the index in invalid, return ERROR */

        if (baseAddressIndex >= 6)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead32: \
                             baseAddressIndex is incorrect\n",0,0,0,0,0,0);
            return ERROR;
            }


        /* Based on the actual base address value, update the flags */

        pActualRegBase = (UINT32 *)(pDevInfo->pAccess->pCookie);

        /* update the flag based on the actual base address */

        if ((pActualRegBase[baseAddressIndex] & PCI_BAR_SPACE_MASK)
                                     == PCI_BAR_SPACE_IO)
            *pFlags  |= VXBAF_IO_SPACE_OPERATION;

        }

    /* call the upstream bus access routine to read 32 bits */

    if (pUpstreamDevPtr->pAccess->registerRead32 (pUpstreamDevPtr,
                                                  pRegBase,
                                                  byteOffset,
                                                  pDataBuf,
                                                  pFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead32: upstream bus \
                        access routine returned error\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* if the byte order is already known, return from the function */

    if ((*pFlags & VXBAF_BYTE_ORDER_KNOWN) != 0)
        return OK;


    /* Perform the conversion and update the flags */

    VXB_PCI_LE_CONVERT_32 (*pFlags, *pDataBuf);

    /*
     * If the driver indicates that this is the first time this function
     * is called, then optimize the access function
     */

    if (firstTime)
        {
        optimizeAccessFunction (*pFlags, pDevInfo->pAccess, OPT_REG_READ32);
        }

    return OK;
    }

/******************************************************************************
*
* pciRegisterRead64 - read 64-bit value from a register
*
* This routine is used by the driver to read 64-bits from a PCI device register.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/

LOCAL STATUS    pciRegisterRead64
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT64 *        pDataBuf,   /* buffer to put data in */
    UINT32 *        pFlags      /* flags */
    )
    {
    struct vxbDev * pUpstreamDevPtr;
    BOOL        firstTime = FALSE;
    UINT32  baseAddressIndex;
    UINT32  *pActualRegBase;

    /* check whether the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pRegBase  == NULL) ||
        (pDataBuf == NULL) ||
        (pFlags   == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead64: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device info */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead64: pUpstreamDevPtr is \
                                  invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * If this is the first time the function is called, set the flag
     * indicating that this is the first time.
     */
    if (*pFlags == 0)
        {
        firstTime = TRUE;
        *pFlags = VXBAF_PREVENT_OPTIMIZATION;
        }

    /*
     * This condition will be successful only if the driver resides
     * directly downstream from the PCI bus
     */

    if ((*pFlags & VXBAF_NOT_FIRST_BUS) == 0)
        {
        /*
         * set the flag which prevents the other layers from
         * checking the validity of base address
         */

        *pFlags |= VXBAF_NOT_FIRST_BUS;

        /* update the expected flags */

        if (((*pFlags & VXBAF_BYTE_ORDER_KNOWN) == 0) &&
             ((*pFlags & VXBAF_ENDIAN_MASK) == 0))

            *pFlags |= VXBAF_BYTE_ORDER_LE_64;

        /* check if the cookie pointer is valid */

        if (pDevInfo->pAccess->pCookie == NULL)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead64: \
                             Invalid cookie\n",0,0,0,0,0,0);
            return ERROR;
            }

        /*
         * Identify the index of the base address.
         * This loop can have a performance impact. The ideal way is to pass the
         * index as a parameter to this access routine. Considering the fact
         * that the index will not be used in the optimized version,
         * the delay due to this loop is acceptable.
         */

        for (baseAddressIndex = 0; baseAddressIndex < 6; baseAddressIndex++)
            {
            if (pDevInfo->pRegBase[baseAddressIndex] == pRegBase)
                {
                break;
                }
            }

        /* If the index in invalid, return ERROR */

        if (baseAddressIndex >= 6)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead64: \
                             baseAddressIndex is incorrect\n",0,0,0,0,0,0);
            return ERROR;
            }


        /* Based on the actual base address value, update the flags */

        pActualRegBase = (UINT32 *)(pDevInfo->pAccess->pCookie);

        /* update the flag based on the actual base address */

        if ((pActualRegBase[baseAddressIndex] & PCI_BAR_SPACE_MASK)
                                     == PCI_BAR_SPACE_IO)
            *pFlags  |= VXBAF_IO_SPACE_OPERATION;

        }

    /* call the upstream bus access routine to read 64 bits */

    if (pUpstreamDevPtr->pAccess->registerRead64 (pUpstreamDevPtr,
                                                  pRegBase,
                                                  byteOffset,
                                                  pDataBuf,
                                                  pFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterRead64: upstream bus \
                        access routine returned error\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* if the byte order is already known, return from the function */

    if ((*pFlags & VXBAF_BYTE_ORDER_KNOWN) != 0)
        return OK;

    /* Perform the conversion and update the flags */

    VXB_PCI_LE_CONVERT_64 (*pFlags, *pDataBuf);

    /*
     * If the driver indicates that this is the first time this function
     * is called, then optimize the access function.
     */

    if (firstTime)
        {
        optimizeAccessFunction (*pFlags, pDevInfo->pAccess, OPT_REG_READ64);
        }

    return OK;
    }

/******************************************************************************
*
* pciRegisterWrite8 - write 8-bits to a register
*
* This routine is used by the driver to write 8-bits to a PCI device register.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/
LOCAL STATUS    pciRegisterWrite8
(
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT8 *         pDataBuf,   /* data to write */
    UINT32 *        pFlags      /* flags */
    )
    {
    UINT32      temporaryFlags = 0;
    struct vxbDev * pUpstreamDevPtr;
    UINT8           dataRead = 0;
    BOOL        firstTime = FALSE;
    UINT32  baseAddressIndex;
    UINT32 *    pActualRegBase;

    /* check whether the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pRegBase  == NULL) ||
        (pDataBuf == NULL) ||
        (pFlags   == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite8: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device pointer */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite8: pUpstreamDevPtr is \
                                  invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * If this is the first time the function is called, set the flag
     * indicating that this is the first time.
     */
    if (*pFlags == 0)
        {
        firstTime = TRUE;
        *pFlags = VXBAF_PREVENT_OPTIMIZATION;
        }

    /*
     * This condition will be successful only if the driver resides
     * directly downstream from the PCI bus
     */

    if ((*pFlags & VXBAF_NOT_FIRST_BUS) == 0)
        {
        /*
         * set the flag which prevents the other layers from
         * checking the validity of base address
         */

        *pFlags |= VXBAF_NOT_FIRST_BUS;

        /* check if the cookie pointer is valid */

        if (pDevInfo->pAccess->pCookie == NULL)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite8: \
                             Invalid cookie\n",0,0,0,0,0,0);
            return ERROR;
            }

        /*
         * Identify the index of the base address.
         * This loop can have a performance impact. The ideal way is to pass the
         * index as a parameter to this access routine. Considering the fact
         * that the index will not be used in the optimized version,
         * the delay due to this loop is acceptable.
         */

        for (baseAddressIndex = 0; baseAddressIndex < 6; baseAddressIndex++)
            {
            if (pDevInfo->pRegBase[baseAddressIndex] == pRegBase)
                {
                break;
                }
            }

        /* If the index in invalid, return ERROR */

        if (baseAddressIndex >= 6)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite8: \
                             baseAddressIndex is incorrect\n",0,0,0,0,0,0);
            return ERROR;
            }


        /* Based on the actual base address value, update the flags */

        pActualRegBase = (UINT32 *)(pDevInfo->pAccess->pCookie);

        /* update the flag based on the actual base address */

        if ((pActualRegBase[baseAddressIndex] & PCI_BAR_SPACE_MASK)
                                     == PCI_BAR_SPACE_IO)
            {
            *pFlags  |= VXBAF_IO_SPACE_OPERATION;
            temporaryFlags = VXBAF_IO_SPACE_OPERATION; /* For the write flush */
            }

        }

    /* call the upstream bus access routine to write 8 bits */

    if (pUpstreamDevPtr->pAccess->registerWrite8 (pUpstreamDevPtr,
                                                  pRegBase,
                                                  byteOffset,
                                                  pDataBuf,
                                                  pFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite8: upstream bus \
                        access routine returned error\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * We need to read back from the register to flush the posting for write
     * use the temporary flags variable.
     */

    temporaryFlags |= (VXBAF_PREVENT_OPTIMIZATION | VXBAF_BYTE_ORDER_KNOWN);

    if (pUpstreamDevPtr->pAccess->registerRead8 (pUpstreamDevPtr,
                                                 pRegBase,
                                                 byteOffset,
                                                 &dataRead,
                                                 &temporaryFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite8: reading back \
        from the register failed\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* discard the data read */

    /*
     * If this is the first time this function is called,
     * then optimize the access function
     */
    if (firstTime)
        {

        /* call the function to optimize this operation */

        optimizeAccessFunction (*pFlags,
                                pDevInfo->pAccess,
                                OPT_REG_WRITE_READ_BACK_8);
        }

    return OK;
    }

/******************************************************************************
*
* pciRegisterWrite16 - write 16-bits to a register
*
* This routine is used by the driver to write 16-bits to a PCI device register.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/

LOCAL STATUS    pciRegisterWrite16
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT16 *        pDataBuf,   /* data to write */
    UINT32 *        pFlags      /* flags */
    )
    {
    UINT32      temporaryFlags = 0;
    struct vxbDev * pUpstreamDevPtr;
    UINT16          dataRead = 0;
    BOOL        firstTime = FALSE;
    UINT32  baseAddressIndex;
    UINT32 *    pActualRegBase;

    /* check whether the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pRegBase  == NULL) ||
        (pDataBuf == NULL) ||
        (pFlags   == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite16: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device pointer */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite16: pUpstreamDevPtr is \
                                  invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * If this is the first time the function is called, set the flag
     * indicating that this is the first time.
     */
    if (*pFlags == 0)
        {
        firstTime = TRUE;
        *pFlags = VXBAF_PREVENT_OPTIMIZATION;
        }

    /*
     * This condition will be successful only if the driver resides
     * directly downstream from the PCI bus
     */

    if ((*pFlags & VXBAF_NOT_FIRST_BUS) == 0)
        {

        /*
         * set the flag which prevents the other layers from
         * checking the validity of base address
         */

        *pFlags |= VXBAF_NOT_FIRST_BUS;

        /* check if the cookie pointer is valid */

        if (pDevInfo->pAccess->pCookie == NULL)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite16: \
                             Invalid cookie\n",0,0,0,0,0,0);
            return ERROR;
            }

        /*
         * Identify the index of the base address.
         * This loop can have a performance impact. The ideal way is to pass the
         * index as a parameter to this access routine. Considering the fact
         * that the index will not be used in the optimized version,
         * the delay due to this loop is acceptable.
         */

        for (baseAddressIndex = 0; baseAddressIndex < 6; baseAddressIndex++)
            {
            if (pDevInfo->pRegBase[baseAddressIndex] == pRegBase)
                {
                break;
                }
            }

        /* If the index in invalid, return ERROR */

        if (baseAddressIndex >= 6)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite16: \
                             baseAddressIndex is incorrect\n",0,0,0,0,0,0);
            return ERROR;
            }


        /* Based on the actual base address value, update the flags */

        pActualRegBase = (UINT32 *)(pDevInfo->pAccess->pCookie);

        /* update the flag based on the actual base address */

        if ((pActualRegBase[baseAddressIndex] & PCI_BAR_SPACE_MASK)
                                     == PCI_BAR_SPACE_IO)
            {
            *pFlags  |= VXBAF_IO_SPACE_OPERATION;
            temporaryFlags = VXBAF_IO_SPACE_OPERATION; /* For the write flush */
            }

        }

    /* if the byte order is already known, do not perform any conversion */

    if ((*pFlags & VXBAF_BYTE_ORDER_KNOWN) == 0)
        /* Perform the conversion and update the flags */

        VXB_PCI_LE_CONVERT_16 (*pFlags, *pDataBuf);

    /* call the upstream bus access routine to write 16 bits */

    if (pUpstreamDevPtr->pAccess->registerWrite16 (pUpstreamDevPtr,
                                                   pRegBase,
                                                   byteOffset,
                                                   pDataBuf,
                                                   pFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite16: upstream bus \
                        access routine returned error\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * We need to read back from the register to flush the posting for write
     * use the temporary flags variable.
     */

    temporaryFlags |= (VXBAF_PREVENT_OPTIMIZATION | VXBAF_BYTE_ORDER_KNOWN);

    /* call the upstream bus access routine to read 16 bits */

    if (pUpstreamDevPtr->pAccess->registerRead16 (pUpstreamDevPtr,
                                                  pRegBase,
                                                  byteOffset,
                                                  &dataRead,
                                                  &temporaryFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite16: reading back \
        from the register failed\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* discard the data read */

    /*
     * If this is the first time this function is called,
     * then optimize the access function
     */
    if (firstTime)
        {
        /* call the function to optimize this operation */

        optimizeAccessFunction (*pFlags,
                                pDevInfo->pAccess,
                                OPT_REG_WRITE_READ_BACK_16);

        }

    return OK;
    }

/******************************************************************************
*
* pciRegisterWrite32 - write 32-bits to a register
*
* This routine is used by the driver to write 32-bits to a PCI device register.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/

LOCAL STATUS    pciRegisterWrite32
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT32 *        pDataBuf,   /* data to write */
    UINT32 *        pFlags      /* flags */
    )
    {
    UINT32      temporaryFlags = 0;
    struct vxbDev * pUpstreamDevPtr;
    UINT32          dataRead = 0;
    BOOL        firstTime = FALSE;
    UINT32  baseAddressIndex;
    UINT32 *    pActualRegBase;

    /* check whether the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pRegBase  == NULL) ||
        (pDataBuf == NULL) ||
        (pFlags   == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite32: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device pointer */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite32: pUpstreamDevPtr is \
                                  invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * If this is the first time the function is called, set the flag
     * indicating that this is the first time.
     */
    if (*pFlags == 0)
        {
        firstTime = TRUE;
        *pFlags = VXBAF_PREVENT_OPTIMIZATION;
        }

    /*
     * This condition will be successful only if the driver resides
     * directly downstream from the PCI bus
     */

    if ((*pFlags & VXBAF_NOT_FIRST_BUS) == 0)
        {

        /*
         * set the flag which prevents the other layers from
         * checking the validity of base address
         */

        *pFlags |= VXBAF_NOT_FIRST_BUS;

        /* check if the cookie pointer is valid */

        if (pDevInfo->pAccess->pCookie == NULL)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite32: \
                             Invalid cookie\n",0,0,0,0,0,0);
            return ERROR;
            }

        /*
         * Identify the index of the base address.
         * This loop can have a performance impact. The ideal way is to pass the
         * index as a parameter to this access routine. Considering the fact
         * that the index will not be used in the optimized version,
         * the delay due to this loop is acceptable.
         */

        for (baseAddressIndex = 0; baseAddressIndex < 6; baseAddressIndex++)
            {
            if (pDevInfo->pRegBase[baseAddressIndex] == pRegBase)
                {
                break;
                }
            }

        /* If the index in invalid, return ERROR */

        if (baseAddressIndex >= 6)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite32: \
                             baseAddressIndex is incorrect\n",0,0,0,0,0,0);
            return ERROR;
            }


        /* Based on the actual base address value, update the flags */

        pActualRegBase = (UINT32 *)(pDevInfo->pAccess->pCookie);

        /* update the flag based on the actual base address */

        if ((pActualRegBase[baseAddressIndex] & PCI_BAR_SPACE_MASK)
                                     == PCI_BAR_SPACE_IO)
            {
            *pFlags  |= VXBAF_IO_SPACE_OPERATION;
            temporaryFlags = VXBAF_IO_SPACE_OPERATION; /* For the write flush */
            }

        }

    /* if the byte order is already known, do not perform any conversion */

    if ((*pFlags & VXBAF_BYTE_ORDER_KNOWN) == 0)

        /* Perform the conversion and update the flags */

        VXB_PCI_LE_CONVERT_32 (*pFlags, *pDataBuf);

    /* call the upstream bus access routine to write 32 bits */

    if (pUpstreamDevPtr->pAccess->registerWrite32 (pUpstreamDevPtr,
                                                   pRegBase,
                                                   byteOffset,
                                                   pDataBuf,
                                                   pFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite32: upstream bus \
                        access routine returned error\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * We need to read back from the register to flush the posting for write
     * use the temporary flags variable.
     */

    temporaryFlags |= (VXBAF_PREVENT_OPTIMIZATION | VXBAF_BYTE_ORDER_KNOWN);

    /* call the upstream bus access routine to read 32-bits */

    if (pUpstreamDevPtr->pAccess->registerRead32 (pUpstreamDevPtr,
                                                  pRegBase,
                                                  byteOffset,
                                                  &dataRead,
                                                  &temporaryFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite32: reading back \
        from the register failed\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* discard the data read */

    /*
     * If this is the first time this function is called,
     * then optimize the access function
     */
    if (firstTime)
        {
        /* call the function to optimize this operation */

        optimizeAccessFunction (*pFlags,
                                pDevInfo->pAccess,
                                OPT_REG_WRITE_READ_BACK_32);
        }

    return OK;
    }

/******************************************************************************
*
* pciRegisterWrite64 - write 64-bits to a register
*
* This routine is used by the driver to write 64-bits to a PCI device register.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/

LOCAL STATUS    pciRegisterWrite64
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT64 *        pDataBuf,   /* data to write */
    UINT32 *        pFlags      /* flags */
    )
    {
    UINT32      temporaryFlags = 0;
    struct vxbDev * pUpstreamDevPtr;
    UINT64      dataRead = 0;
    BOOL        firstTime = FALSE;
    UINT32  baseAddressIndex;
    UINT32 *    pActualRegBase;

    /* check whether the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pRegBase  == NULL) ||
        (pDataBuf == NULL) ||
        (pFlags   == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite64: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device pointer */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite64: pUpstreamDevPtr is \
                                  invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * If this is the first time the function is called, set the flag
     * indicating that this is the first time.
     */
    if (*pFlags == 0)
        {
        firstTime = TRUE;
        *pFlags = VXBAF_PREVENT_OPTIMIZATION;
        }

    /*
     * This condition will be successful only if the driver resides
     * directly downstream from the PCI bus
     */

    if ((*pFlags & VXBAF_NOT_FIRST_BUS) == 0)
        {
        /*
         * set the flag which prevents the other layers from
         * checking the validity of base address
         */

        *pFlags |= VXBAF_NOT_FIRST_BUS;

        /* check if the cookie pointer is valid */

        if (pDevInfo->pAccess->pCookie == NULL)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite64: \
                             Invalid cookie\n",0,0,0,0,0,0);
            return ERROR;
            }

        /*
         * Identify the index of the base address.
         * This loop can have a performance impact. The ideal way is to pass the
         * index as a parameter to this access routine. Considering the fact
         * that the index will not be used in the optimized version,
         * the delay due to this loop is acceptable.
         */

        for (baseAddressIndex = 0; baseAddressIndex < 6; baseAddressIndex++)
            {
            if (pDevInfo->pRegBase[baseAddressIndex] == pRegBase)
                {
                break;
                }
            }

        /* If the index in invalid, return ERROR */

        if (baseAddressIndex >= 6)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite64: \
                             baseAddressIndex is incorrect\n",0,0,0,0,0,0);
            return ERROR;
            }


        /* Based on the actual base address value, update the flags */

        pActualRegBase = (UINT32 *)(pDevInfo->pAccess->pCookie);

        /* update the flag based on the actual base address */

        if ((pActualRegBase[baseAddressIndex] & PCI_BAR_SPACE_MASK)
                                     == PCI_BAR_SPACE_IO)
            {
            *pFlags  |= VXBAF_IO_SPACE_OPERATION;
            temporaryFlags = VXBAF_IO_SPACE_OPERATION; /* For the write flush */
            }
        }

    /* if the byte order is already known, do not perform any conversion */

    if ((*pFlags & VXBAF_BYTE_ORDER_KNOWN) == 0)
        /* Perform the conversion and update the flags */

        VXB_PCI_LE_CONVERT_64 (*pFlags, *pDataBuf);

    /* call the upstream bus access routine to write 64 bits */

    if (pUpstreamDevPtr->pAccess->registerWrite64 (pUpstreamDevPtr,
                                                   pRegBase,
                                                   byteOffset,
                                                   pDataBuf,
                                                   pFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite64: upstream bus \
                        access routine returned error\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * We need to read back from the register to flush the posting for write
     * use the temporary flags variable.
     */

    temporaryFlags |= (VXBAF_PREVENT_OPTIMIZATION | VXBAF_BYTE_ORDER_KNOWN);

    /* call the upstream bus access routine to read 64 bits */

    if (pUpstreamDevPtr->pAccess->registerRead64 (pUpstreamDevPtr,
                                                  pRegBase,
                                                  byteOffset,
                                                  &dataRead,
                                                  &temporaryFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciRegisterWrite64: reading back \
        from the register failed\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* discard the data read */

    /*
     * If this is the first time this function is called,
     * then optimize the access function
     */
    if (firstTime)
        {
        /* call the function to optimize this operation */

        optimizeAccessFunction (*pFlags,
                                pDevInfo->pAccess,
                                OPT_REG_WRITE_READ_BACK_64);

        }

    return OK;
    }

/******************************************************************************
*
* pciVolatileRegisterWrite - write to a volatile register
*
* This routine is used to write to a volatile register and read back the data
* from the volatile register.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/
LOCAL STATUS    pciVolatileRegisterWrite
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT32          transactionSize,/* transaction size, in bytes*/
    char *          pDataBuf,   /* buffer to read-from/write-to */
    UINT32 *        pFlags      /* flags */
    )
    {
    STATUS  status = ERROR;

    /* based on the size of data read/write, call the corresponding function */

    switch (transactionSize)
        {
        case 1:
            /* call the function to write 8-bits to a volatile register */

            status = pciVolatileRegisterWrite8 (pDevInfo,
                                                pRegBase,
                                                byteOffset,
                                                (UINT8 *)pDataBuf,
                                                pFlags);
            break;
        case 2:
            /* call the function to write 16-bits to a volatile register */

            status = pciVolatileRegisterWrite16 (pDevInfo,
                                                 pRegBase,
                                                 byteOffset,
                                                 (UINT16 *)pDataBuf,
                                                 pFlags);

            break;
        case 4:
            /* call the function to write 32-bits to a volatile register */

            status = pciVolatileRegisterWrite32 (pDevInfo,
                                                 pRegBase,
                                                 byteOffset,
                                                 (UINT32 *)pDataBuf,
                                                 pFlags);
            break;

        case 8:
            /* call the function to write 64-bits to a volatile register */

            status = pciVolatileRegisterWrite64 (pDevInfo,
                                                 pRegBase,
                                                 byteOffset,
                                                 (UINT64 *)pDataBuf,
                                                 pFlags);
            break;
        default:
            break;

        }
    return status;
    }

/******************************************************************************
*
* pciVolatileRegisterRead - read from a volatile register
*
* This routine is used to read from a volatile register. This function does
* not split the read into multiple transactions.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/

LOCAL STATUS    pciVolatileRegisterRead
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT32          transactionSize,/* transaction size, in bytes */
    char *          pDataBuf,   /* buffer to read-from */
    UINT32 *        pFlags      /* flags */
    )
    {
    struct vxbDev * pUpstreamDevPtr;
    UINT32  baseAddressIndex;
    UINT32 *    pActualRegBase;

    /* check whether the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pRegBase  == NULL) ||
        (pDataBuf == NULL) ||
        (pFlags   == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterRead: \
                              Invalid parameter\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device pointer */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterRead: pUpstreamDevPtr \
                            is invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* update the expected flags if flag value is 0 */

    if (*pFlags == 0)
        {
        switch (transactionSize)
            {
            case    2:
                *pFlags = VXBAF_BYTE_ORDER_LE_16;
                break;
            case    4:
                *pFlags = VXBAF_BYTE_ORDER_LE_32;
                break;
            case    8:
                *pFlags = VXBAF_BYTE_ORDER_LE_64;
                break;
            default :
                break;
            }
        }


    /*
     * This condition will be successful only if the driver resides
     * directly downstream from the PCI bus
     */

    if ((*pFlags & VXBAF_NOT_FIRST_BUS) == 0)
        {
        /*
         * set the flag which prevents the other layers from
         * checking the validity of base address
         */

        *pFlags |= VXBAF_NOT_FIRST_BUS;

        /* update the flags */

        if (((*pFlags & VXBAF_BYTE_ORDER_KNOWN) == 0) &&
             ((*pFlags & VXBAF_ENDIAN_MASK) == 0))

            {
            switch (transactionSize)
                {
                case    2:
                    *pFlags |= VXBAF_BYTE_ORDER_LE_16;
                    break;
                case    4:
                    *pFlags |= VXBAF_BYTE_ORDER_LE_32;
                    break;
                case    8:
                    *pFlags |= VXBAF_BYTE_ORDER_LE_64;
                    break;
                default :
                    break;
                }
            }

        /* check if the cookie pointer is valid */

        if (pDevInfo->pAccess->pCookie == NULL)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterRead: \
                             Invalid cookie\n",0,0,0,0,0,0);
            return ERROR;
            }

        /*
         * Identify the index of the base address.
         * This loop can have a performance impact. The ideal way is to pass the
         * index as a parameter to this access routine. Considering the fact
         * that the index will not be used in the optimized version,
         * the delay due to this loop is acceptable.
         */

        for (baseAddressIndex = 0; baseAddressIndex < 6; baseAddressIndex++)
            {
            if (pDevInfo->pRegBase[baseAddressIndex] == pRegBase)
                {
                break;
                }
            }

        /* If the index in invalid, return ERROR */

        if (baseAddressIndex >= 6)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterRead: \
                             baseAddressIndex is incorrect\n",0,0,0,0,0,0);
            return ERROR;
            }


        /* Based on the actual base address value, update the flags */

        pActualRegBase = (UINT32 *)(pDevInfo->pAccess->pCookie);

        /* update the flag based on the actual base address */

        if ((pActualRegBase[baseAddressIndex] & PCI_BAR_SPACE_MASK)
                                     == PCI_BAR_SPACE_IO)
            *pFlags  |= VXBAF_IO_SPACE_OPERATION;

        }

    /* call the upstream bus access routine for read */

    if (pUpstreamDevPtr->pAccess->volRegRead (pUpstreamDevPtr,
                                              pRegBase,
                                              byteOffset,
                                              transactionSize,
                                              pDataBuf,
                                              pFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterRead: upstream bus \
                    access routine vol read returned error\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* if the byte order is already known, return from the function */

    if ((*pFlags & VXBAF_BYTE_ORDER_KNOWN) != 0)
        return OK;

    /* based on the transaction size, perform the conversion on the data */

    switch (transactionSize)
        {
        case    2:
            VXB_PCI_LE_CONVERT_16 (*pFlags, (*(UINT16 *)pDataBuf));
            break;
        case    4:
            VXB_PCI_LE_CONVERT_32 (*pFlags, (*(UINT32 *)pDataBuf));
            break;
        case    8:
            VXB_PCI_LE_CONVERT_64 (*pFlags, (*(UINT64 *)pDataBuf));
            break;
        default :
            break;
        }

    return OK;
    }

/******************************************************************************
*
* pciVolatileRegisterWrite8 - write 8-bits to a volatile register
*
* This routine is used to write 8-bits and subsequently read back the
* 8-bits from the volatile register.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/
LOCAL STATUS    pciVolatileRegisterWrite8
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT8 *         pDataBuf,   /* buffer to read-from/write-to */
    UINT32 *        pFlags      /* flags */
    )
    {
    struct vxbDev * pUpstreamDevPtr;
    UINT32  baseAddressIndex;
    UINT32 *    pActualRegBase;

    /* check whether the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pRegBase  == NULL) ||
        (pDataBuf == NULL) ||
        (pFlags   == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite8: \
                              Invalid parameter\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device pointer */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite8: pUpstreamDevPtr \
                            is invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * This condition will be successful only if the driver resides
     * directly downstream from the PCI bus
     */

    if ((*pFlags & VXBAF_NOT_FIRST_BUS) == 0)
        {
        /*
         * set the flag which prevents the other layers from
         * checking the validity of base address
         */

        *pFlags |= VXBAF_NOT_FIRST_BUS;

        /* check if the cookie pointer is valid */

        if (pDevInfo->pAccess->pCookie == NULL)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite8: \
                             Invalid cookie\n",0,0,0,0,0,0);
            return ERROR;
            }

        /*
         * Identify the index of the base address.
         * This loop can have a performance impact. The ideal way is to pass the
         * index as a parameter to this access routine. Considering the fact
         * that the index will not be used in the optimized version,
         * the delay due to this loop is acceptable.
         */

        for (baseAddressIndex = 0; baseAddressIndex < 6; baseAddressIndex++)
            {
            if (pDevInfo->pRegBase[baseAddressIndex] == pRegBase)
                {
                break;
                }
            }

        /* If the index in invalid, return ERROR */

        if (baseAddressIndex >= 6)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite8: \
                             baseAddressIndex is incorrect\n",0,0,0,0,0,0);
            return ERROR;
            }


        /* Based on the actual base address value, update the flags */

        pActualRegBase = (UINT32 *)(pDevInfo->pAccess->pCookie);

        /* update the flag based on the actual base address */

        if ((pActualRegBase[baseAddressIndex] & PCI_BAR_SPACE_MASK)
                                     == PCI_BAR_SPACE_IO)
            *pFlags  |= VXBAF_IO_SPACE_OPERATION;

        }

    /* call the upstream bus access routine to write 8 bits */

    if (pUpstreamDevPtr->pAccess->volRegWrite (pUpstreamDevPtr,
                                               pRegBase,
                                               byteOffset,
                                               1,
                                               (char *    )pDataBuf,
                                               pFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite8: upstream bus \
                    access routine for write returned error\n",0,0,0,0,0,0);
        return ERROR;
        }

    return OK;
    }

/******************************************************************************
*
* pciVolatileRegisterWrite16 - write 16-bits to a volatile register
*
* This routine is used to write 16-bits and subsequently read back the
* 16-bits from the volatile register.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/
LOCAL STATUS    pciVolatileRegisterWrite16
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT16 *        pDataBuf,   /* buffer to read-from/write-to */
    UINT32 *        pFlags      /* flags */
    )
    {
    struct vxbDev * pUpstreamDevPtr;
    UINT32  baseAddressIndex;
    UINT32 *    pActualRegBase;

    /* check whether the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pRegBase  == NULL) ||
        (pDataBuf == NULL) ||
        (pFlags   == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite16: \
              Invalid parameter\n", 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device pointer */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite16: \
        pUpstreamDevPtr is invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * This condition will be successful only if the driver resides
     * directly downstream from the PCI bus
     */

    if ((*pFlags & VXBAF_NOT_FIRST_BUS) == 0)
        {
        /*
         * set the flag which prevents the other layers from
         * checking the validity of base address
         */

        *pFlags |= VXBAF_NOT_FIRST_BUS;

        /* check if the cookie pointer is valid */

        if (pDevInfo->pAccess->pCookie == NULL)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite16: \
                             Invalid cookie\n",0,0,0,0,0,0);
            return ERROR;
            }

        /*
         * Identify the index of the base address.
         * This loop can have a performance impact. The ideal way is to pass the
         * index as a parameter to this access routine. Considering the fact
         * that the index will not be used in the optimized version,
         * the delay due to this loop is acceptable.
         */

        for (baseAddressIndex = 0; baseAddressIndex < 6; baseAddressIndex++)
            {
            if (pDevInfo->pRegBase[baseAddressIndex] == pRegBase)
                {
                break;
                }
            }

        /* If the index in invalid, return ERROR */

        if (baseAddressIndex >= 6)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite16: \
                             baseAddressIndex is incorrect\n",0,0,0,0,0,0);
            return ERROR;
            }


        /* Based on the actual base address value, update the flags */

        pActualRegBase = (UINT32 *)(pDevInfo->pAccess->pCookie);

        /* update the flag based on the actual base address */

        if ((pActualRegBase[baseAddressIndex] & PCI_BAR_SPACE_MASK)
                                     == PCI_BAR_SPACE_IO)
            *pFlags  |= VXBAF_IO_SPACE_OPERATION;

        }

    /* if the byte order is already known, do not perform any conversion */

    if ((*pFlags & VXBAF_BYTE_ORDER_KNOWN) == 0)
        /* Perform the conversion and update the flags */

        VXB_PCI_LE_CONVERT_16 (*pFlags, *pDataBuf);

    /*
     * call the upstream bus access routine to write
     * 16 bits to volatile register
     */

    if (pUpstreamDevPtr->pAccess->volRegWrite (pUpstreamDevPtr,
                                               pRegBase,
                                               byteOffset,
                                               2,
                                               (char *    )pDataBuf,
                                               pFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite16: upstream bus \
                        access routine returned error\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* if the byte order is already known, do not perform any conversion */

    if ((*pFlags & VXBAF_BYTE_ORDER_KNOWN) == 0)
        /* Perform the conversion and update the flags */

        VXB_PCI_LE_CONVERT_16 (*pFlags, *pDataBuf);

    return OK;
    }

/******************************************************************************
*
* pciVolatileRegisterWrite32 - write 32-bits to a volatile register
*
* This routine is used to write 32-bits and subsequently read back the
* 32-bits from the volatile register.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/
LOCAL STATUS    pciVolatileRegisterWrite32
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT32 *        pDataBuf,   /* buffer to read-from/write-to */
    UINT32 *        pFlags      /* flags */
    )
    {
    struct vxbDev * pUpstreamDevPtr;
    UINT32  baseAddressIndex;
    UINT32 *    pActualRegBase;

    /* check whether the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pRegBase  == NULL) ||
        (pDataBuf == NULL) ||
        (pFlags   == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite32: \
              Invalid parameter\n", 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device pointer */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite32: \
        pUpstreamDevPtr is invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * This condition will be successful only if the driver resides
     * directly downstream from the PCI bus
     */

    if ((*pFlags & VXBAF_NOT_FIRST_BUS) == 0)
        {
        /*
         * set the flag which prevents the other layers from
         * checking the validity of base address
         */

        *pFlags |= VXBAF_NOT_FIRST_BUS;

        /* check if the cookie pointer is valid */

        if (pDevInfo->pAccess->pCookie == NULL)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite32: \
                             Invalid cookie\n",0,0,0,0,0,0);
            return ERROR;
            }

        /*
         * Identify the index of the base address.
         * This loop can have a performance impact. The ideal way is to pass the
         * index as a parameter to this access routine. Considering the fact
         * that the index will not be used in the optimized version,
         * the delay due to this loop is acceptable.
         */

        for (baseAddressIndex = 0; baseAddressIndex < 6; baseAddressIndex++)
            {
            if (pDevInfo->pRegBase[baseAddressIndex] == pRegBase)
                {
                break;
                }
            }

        /* If the index in invalid, return ERROR */

        if (baseAddressIndex >= 6)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite32: \
                             baseAddressIndex is incorrect\n",0,0,0,0,0,0);
            return ERROR;
            }


        /* Based on the actual base address value, update the flags */

        pActualRegBase = (UINT32 *)(pDevInfo->pAccess->pCookie);

        /* update the flag based on the actual base address */

        if ((pActualRegBase[baseAddressIndex] & PCI_BAR_SPACE_MASK)
                                     == PCI_BAR_SPACE_IO)
            *pFlags  |= VXBAF_IO_SPACE_OPERATION;

        }

    /* if the byte order is already known, do not perform any conversion */

    if ((*pFlags & VXBAF_BYTE_ORDER_KNOWN) == 0)

        /* Perform the conversion and update the flags */

        VXB_PCI_LE_CONVERT_32 (*pFlags, *pDataBuf);

    /*
     * call the upstream bus access routine to write
     * 32 bits to volatile register
     */

    if (pUpstreamDevPtr->pAccess->volRegWrite (pUpstreamDevPtr,
                                               pRegBase,
                                               byteOffset,
                                               4,
                                               (char *    )pDataBuf,
                                               pFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite32: upstream bus \
                        access routine returned error\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* if the byte order is already known, do not perform any conversion */

    if ((*pFlags & VXBAF_BYTE_ORDER_KNOWN) == 0)

        /* Perform the conversion and update the flags */

        VXB_PCI_LE_CONVERT_32 (*pFlags, *pDataBuf);

    return OK;
    }

/******************************************************************************
*
* pciVolatileRegisterWrite64 - write 64-bits to a volatile register
*
* This routine is used to write 64-bits and subsequently read back the
* 64-bits from the volatile register.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/
LOCAL STATUS    pciVolatileRegisterWrite64
    (
    VXB_DEVICE_ID   pDevInfo,   /* device info */
    void *          pRegBase,   /* VXB_DEVICE::pRegBase[] entry */
    UINT32          byteOffset, /* offset, in bytes, of register */
    UINT64 *        pDataBuf,   /* buffer to read-from/write-to */
    UINT32 *        pFlags      /* flags */
    )
    {
    struct vxbDev * pUpstreamDevPtr;
    UINT32  baseAddressIndex;
    UINT32 *    pActualRegBase;

    /* check whether the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pRegBase  == NULL) ||
        (pDataBuf == NULL) ||
        (pFlags   == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite64: \
              Invalid parameter\n", 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device pointer */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite64: \
        pUpstreamDevPtr is invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /*
     * This condition will be successful only if the driver resides
     * directly downstream from the PCI bus
     */

    if ((*pFlags & VXBAF_NOT_FIRST_BUS) == 0)
        {
        /*
         * set the flag which prevents the other layers from
         * checking the validity of base address
         */

        *pFlags |= VXBAF_NOT_FIRST_BUS;

        /* check if the cookie pointer is valid */

        if (pDevInfo->pAccess->pCookie == NULL)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite64: \
                             Invalid cookie\n",0,0,0,0,0,0);
            return ERROR;
            }

        /*
         * Identify the index of the base address.
         * This loop can have a performance impact. The ideal way is to pass the
         * index as a parameter to this access routine. Considering the fact
         * that the index will not be used in the optimized version,
         * the delay due to this loop is acceptable.
         */

        for (baseAddressIndex = 0; baseAddressIndex < 6; baseAddressIndex++)
            {
            if (pDevInfo->pRegBase[baseAddressIndex] == pRegBase)
                {
                break;
                }
            }

        /* If the index in invalid, return ERROR */

        if (baseAddressIndex >= 6)
            {
            VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite64: \
                             baseAddressIndex is incorrect\n",0,0,0,0,0,0);
            return ERROR;
            }


        /* Based on the actual base address value, update the flags */

        pActualRegBase = (UINT32 *)(pDevInfo->pAccess->pCookie);

        /* update the flag based on the actual base address */

        if ((pActualRegBase[baseAddressIndex] & PCI_BAR_SPACE_MASK)
                                     == PCI_BAR_SPACE_IO)
            *pFlags  |= VXBAF_IO_SPACE_OPERATION;

        }

    /* if the byte order is already known, do not perform any conversion */

    if ((*pFlags & VXBAF_BYTE_ORDER_KNOWN) == 0)

        /* Perform the conversion and update the flags */

        VXB_PCI_LE_CONVERT_64 (*pFlags, data);

    /*
     * call the upstream bus access routine to write
     * 64 bits to volatile register
     */

    if (pUpstreamDevPtr->pAccess->volRegWrite (pUpstreamDevPtr,
                                               pRegBase,
                                               byteOffset,
                                               8,
                                               (char *    )pDataBuf,
                                               pFlags) != OK)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciVolatileRegisterWrite64: upstream bus \
                        access routine returned error\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* if the byte order is already known, do not perform any conversion */

    if ((*pFlags & VXBAF_BYTE_ORDER_KNOWN) == 0)
        /* Perform the conversion and update the flags */

        VXB_PCI_LE_CONVERT_64 (*pFlags, *pDataBuf);

    return OK;
    }

/******************************************************************************
*
* pciDevControl - perform device control operations
*
* This routine is used to perform device control operations which are not
* covered as part of function pointers.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/
LOCAL STATUS    pciDevControl
    (
    VXB_DEVICE_ID   devID,          /* device info */
    pVXB_DEVCTL_HDR pBusDevControl  /* parameter */
    )
    {
    STATUS  status = ERROR;

    /* check the validity of the parameters */

    if ((devID == NULL) ||
        (pBusDevControl == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciDevControl: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;

        }

    /* Based on the access identifier, call the corresponding function */

    switch (pBusDevControl->vxbAccessId)
        {
        case    VXB_ACCESS_INT_ENABLE:

            /* call the function to enable the PCI device interrupt */

            status = pciBusIntEnable (devID,
                                      (pVXB_ACCESS_INTERRUPT_INFO)pBusDevControl);
            break;

        case    VXB_ACCESS_INT_DISABLE:

            /* call the function to disable the PCI device interrupt */

            status = pciBusIntDisable (devID,
                                       (pVXB_ACCESS_INTERRUPT_INFO)pBusDevControl);
            break;

        case    VXB_ACCESS_INT_ACKNOWLEDGE:

            /* call the function to acknowledge the interrupt */

            status = pciBusIntAcknowledge (devID,
                                           (pVXB_ACCESS_INTERRUPT_INFO)pBusDevControl);
            break;

        case    VXB_ACCESS_INT_CONNECT:

            /* call the function to connect an ISR function */

            status = pciBusIntConnect (devID,
                                       (pVXB_ACCESS_INTERRUPT_INFO)pBusDevControl);
            break;

        case    VXB_ACCESS_INT_DISCONN:

            /* call the function to disconnect an ISR function */

            status = pciBusIntDisconnect (devID,
                                          (pVXB_ACCESS_INTERRUPT_INFO)pBusDevControl);
            break;

        case    VXB_ACCESS_INT_VEC_GET:

            /* call the function to get the interrupt vector */

            status = pciBusIntVectorGet (devID,
                                         (pVXB_ACCESS_INT_VECTOR_GET)pBusDevControl);
            break;

        default:
            break;
        }

    /* return the status */

    return status;
    }

/******************************************************************************
*
* pciBusIntEnable - enable a PCI device interrupt
*
* This routine enables interrupts along the path from the device to the
* processor.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/
LOCAL STATUS    pciBusIntEnable
    (
    VXB_DEVICE_ID               pDevInfo,       /* device info */
    pVXB_ACCESS_INTERRUPT_INFO  pPciIntrInfo    /* interrupt info */
    )
    {
    STATUS      status = ERROR;
    struct pciIntrEntry *pInterruptInfo = NULL;
    struct vxbDev * pUpstreamDevPtr = NULL;

    /* check if the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pPciIntrInfo == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntEnable: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the interrupt information */

    pInterruptInfo = (struct pciIntrEntry *)pDevInfo->pIntrInfo;

    /* check if the pointers are valid */

    if ((pInterruptInfo == NULL) ||
        (pPciIntrInfo->intIndex >= pInterruptInfo->numVectors))

        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntEnable: \
                    Invalid pointer information\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device pointer */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntEnable: \
        pUpstreamDevPtr is invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* modify the index */

    pPciIntrInfo->intIndex =
          pInterruptInfo->intVecInfo[pPciIntrInfo->intIndex].index;

    /* call the upstream device's access function */

    status = pUpstreamDevPtr->pAccess->vxbDevControl
             (pUpstreamDevPtr,
              (pVXB_DEVCTL_HDR)pPciIntrInfo);

    return status;
    }

/******************************************************************************
*
* pciBusIntDisable - disable a PCI device interrupt
*
* This routine disables interrupts along the path from the device to the
* processor.
*
* RETURNS: ERROR, always
*
* ERRNO:
*/
LOCAL STATUS    pciBusIntDisable
    (
    VXB_DEVICE_ID               pDevInfo,       /* device info */
    pVXB_ACCESS_INTERRUPT_INFO  pPciIntrInfo    /* interrupt info */
    )
    {
    STATUS      status = ERROR;
    struct pciIntrEntry *pInterruptInfo = NULL;
    struct vxbDev * pUpstreamDevPtr = NULL;

    /* check if the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pPciIntrInfo == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntDisable: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the interrupt information */

    pInterruptInfo = (struct pciIntrEntry *)pDevInfo->pIntrInfo;

    /* check if the pointers are valid */

    if ((pInterruptInfo == NULL) ||
        (pPciIntrInfo->intIndex >= pInterruptInfo->numVectors))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntDisable: \
                    Invalid pointer information\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device pointer */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntDisable: \
        pUpstreamDevPtr is invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* modify the index */

    pPciIntrInfo->intIndex =
          pInterruptInfo->intVecInfo[pPciIntrInfo->intIndex].index;

    /* call the upstream device's access function */

    status = pUpstreamDevPtr->pAccess->vxbDevControl
             (pUpstreamDevPtr,
             (pVXB_DEVCTL_HDR)pPciIntrInfo);

    return status;

    }

/******************************************************************************
*
* pciBusIntAcknowledge - acknowledge and clear an interrupt
*
* This routine acknowledges and clears an interrupt on the interrupt
* controller. It does not clear the interrupt on the device.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/
LOCAL STATUS    pciBusIntAcknowledge
    (
    VXB_DEVICE_ID               pDevInfo,       /* device info */
    pVXB_ACCESS_INTERRUPT_INFO  pPciIntrInfo    /* interrupt info */
    )
    {
    STATUS      status = ERROR;
    struct pciIntrEntry *pInterruptInfo = NULL;
    struct vxbDev * pUpstreamDevPtr = NULL;

    /* check if the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pPciIntrInfo == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntAcknowledge: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the interrupt information */

    pInterruptInfo = (struct pciIntrEntry *)pDevInfo->pIntrInfo;

    /* check if the pointers are valid */

    if (pInterruptInfo == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntAcknowledge: \
                    Invalid pointer information\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the upstream bus device pointer */

    VXBAF_RETRIEVE_UPSTREAM_BUS_PTR(pDevInfo, pUpstreamDevPtr);

    /* check if the upstream bus device pointer is valid */

    if (pUpstreamDevPtr == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntAcknowledge: \
        pUpstreamDevPtr is invalid\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* modify the index */

    pPciIntrInfo->intIndex =
          pInterruptInfo->intVecInfo[pPciIntrInfo->intIndex].index;

    /* call the upstream device's access function */

    status = pUpstreamDevPtr->pAccess->vxbDevControl
             (pUpstreamDevPtr,
              (pVXB_DEVCTL_HDR)pPciIntrInfo);

    return status;

    }

/******************************************************************************
*
* pciBusIntConnect - connect an ISR to the device interrupt
*
* This routine connects an ISR to the device interrupt.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/
LOCAL STATUS    pciBusIntConnect
    (
    VXB_DEVICE_ID               pDevInfo,       /* device info */
    pVXB_ACCESS_INTERRUPT_INFO  pPciIntrInfo    /* interrupt info */
    )
    {
    struct pciIntrEntry *pInterruptInfo = NULL;

    /* check if the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pPciIntrInfo == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntConnect: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the interrupt information */

    pInterruptInfo = (struct pciIntrEntry *)pDevInfo->pIntrInfo;

    /* check if the address is valid */

    if (pInterruptInfo == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntConnect: \
                    Invalid pointer information\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* check if the index is valid */

    if (pPciIntrInfo->intIndex >= pInterruptInfo->numVectors)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntConnect: \
                    Invalid interrupt index\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* call the pciIntLib function to connect the ISR */

    return vxbPciIntConnect(pDevInfo,
    (VOIDFUNCPTR *)(pInterruptInfo->intVecInfo[pPciIntrInfo->intIndex].intVector),
    (VOIDFUNCPTR)pPciIntrInfo->pISR,
    (int)pPciIntrInfo->pParameter);

    }

/******************************************************************************
*
* pciBusIntDisconnect - disconnect an ISR to the device interrupt
*
* This routine disconnects an ISR from the device interrupt.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/
LOCAL STATUS    pciBusIntDisconnect
    (
    VXB_DEVICE_ID               pDevInfo,       /* device info */
    pVXB_ACCESS_INTERRUPT_INFO  pPciIntrInfo    /* interrupt info */
    )
    {

    struct pciIntrEntry *pInterruptInfo = NULL;

    /* check if the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pPciIntrInfo == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntDisConnect: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the interrupt information */

    pInterruptInfo = (struct pciIntrEntry *)pDevInfo->pIntrInfo;

    /* check if the address is valid */

    if (pInterruptInfo == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntDisConnect: \
                    Invalid pointer information\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* check if the index is valid */

    if (pPciIntrInfo->intIndex >= pInterruptInfo->numVectors)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntDisConnect: \
                    Invalid interrupt index\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* call the pciIntLib function to connect the ISR */

    return vxbPciIntDisconnect2 (pDevInfo,
				 (VOIDFUNCPTR *)(pInterruptInfo->
						 intVecInfo[pPciIntrInfo->intIndex].intVector),
				 (VOIDFUNCPTR)(pPciIntrInfo->pISR),
				 (int)(pPciIntrInfo->pParameter));

    }

/******************************************************************************
*
* pciBusIntVectorGet - get interrupt vector information
*
* This routine retrieves the interrupt vector information based on the index
* value.
*
* RETURNS: OK on success, or ERROR otherwise
*
* ERRNO:
*/

LOCAL STATUS    pciBusIntVectorGet
    (
    VXB_DEVICE_ID               pDevInfo,       /* device info */
    pVXB_ACCESS_INT_VECTOR_GET  pPciIntVecInfo  /* interrupt info */
    )
    {
    struct pciIntrEntry *pInterruptInfo = NULL;

    /* check if the parameters are valid */

    if ((pDevInfo == NULL) ||
        (pPciIntVecInfo == NULL))
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntVectorGet: Invalid parameter\n",
                                 0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the interrupt information */

    pInterruptInfo = (struct pciIntrEntry *)pDevInfo->pIntrInfo;

    /* check if the address is valid */

    if (pInterruptInfo == NULL)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntVectorGet: \
                    Invalid pointer information\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* check if the index is valid */

    if (pPciIntVecInfo->intIndex >= pInterruptInfo->numVectors)
        {
        VXB_ACCESS_PCI_LOG_ERROR("pciBusIntVectorGet: \
                    Invalid interrupt index\n",0,0,0,0,0,0);
        return ERROR;
        }

    /* retrieve the vector information from the index */

    pPciIntVecInfo->pIntVector =
    (VOIDFUNCPTR)(pInterruptInfo->
                  intVecInfo[pPciIntVecInfo->intIndex].intVector);

    return OK;
    }
#endif /* VXB_LEGACY_ACCESS */

/********************************************************************************
*
* vxbPciAccessInit - initialize the PCI bus default access
*
* RETURNS: OK, or ERROR
*
* ERRNO
*/

pVXB_ACCESS_LIST vxbPciAccessInit
    (
    struct vxbDev * pDev
    )
    {
    pVXB_ACCESS_LIST pAccessList = NULL;
#ifdef	VXB_LEGACY_ACCESS
    FUNCPTR     pFuncAccessOverride;

    pAccessList = (pVXB_ACCESS_LIST) hwMemAlloc(sizeof(*pAccessList));
    if ( pAccessList == NULL )
        return(NULL);

    *pAccessList = pciBusAccessList;

    /*
     * retrieve the method from the PCI controller to update the controller
     * specific function pointers
     */

    pFuncAccessOverride = vxbDevMethodGet (pDev,
                                  (UINT32)busCtlrAccessOverride_desc);

    /* If the function pointer is not NULL, call the function */

    if (pFuncAccessOverride != NULL)
        (*pFuncAccessOverride) (pDev, pAccessList);

#endif	/* VXB_LEGACY_ACCESS */

    return(pAccessList);
    }

/* externs */

IMPORT STATUS vxbPciFindClass
    (
    VXB_DEVICE_ID busCtrlID,
    int    classCode,   /* 24-bit class code */
    int    index,       /* desired instance of device */
    int *  pBusNo,      /* bus number */
    int *  pDeviceNo,   /* device number */
    int *  pFuncNo      /* function number */
    );
IMPORT STATUS vxbPciDevConfig
    (
    VXB_DEVICE_ID busCtrlID,
    int pciBusNo,          /* PCI bus number */
    int pciDevNo,          /* PCI device number */
    int pciFuncNo,         /* PCI function number */
    UINT32 devIoBaseAdrs,  /* device IO base address */
    UINT32 devMemBaseAdrs, /* device memory base address */
    UINT32 command         /* command to issue */
    );
IMPORT STATUS vxbPciConfigExtCapFind
    (
    VXB_DEVICE_ID busCtrlID,
    UINT8 extCapFindId,    /* Extended capabilities ID to search for */
    int bus,               /* PCI bus number */
    int device,            /* PCI device number */
    int function,          /* PCI function number */
    UINT8 * pOffset        /* returned config space offset */
    );
IMPORT STATUS vxbPciFindDevice
    (
    VXB_DEVICE_ID busCtrlID,
    int    vendorId,    /* vendor ID */
    int    deviceId,    /* device ID */
    int    index,       /* desired instance of device */
    int *  pBusNo,      /* bus number */
    int *  pDeviceNo,   /* device number */
    int *  pFuncNo      /* function number */
    );
IMPORT STATUS vxbPciIntDisconnect
    (
    VXB_DEVICE_ID pDev,
    VOIDFUNCPTR *vector,        /* interrupt vector to attach to     */
    VOIDFUNCPTR routine         /* routine to be called              */
    );

IMPORT VXB_DEVICE_ID globalBusCtrlID;

#define PCI_VXB_BUSID 0x40
#undef SPECIAL_CYCLE_SUPPORTED

#ifndef PCI_AUTO_MAX_FUNCTIONS
# define PCI_AUTO_MAX_FUNCTIONS 32
#endif /* PCI_AUTO_MAX_FUNCTIONS */

#define NO_ALLOCATION  0xffffffff

#ifdef	VXB_LEGACY_ACCESS
#define VXB_PCI_BUS_CFG_READ_INTERNAL(pDev, byteOffset,		\
				      transactionSize, pData)	\
    vxbPciLegacyCfgRead (pDev, byteOffset, transactionSize, pData)

#define VXB_PCI_BUS_CFG_WRITE_INTERNAL(pDev, byteOffset,	\
				       transactionSize, pData)	\
    vxbPciLegacyCfgWrite (pDev, byteOffset, transactionSize, pData)
#else	/* VXB_LEGACY_ACCESS */
#define VXB_PCI_BUS_CFG_READ_INTERNAL(pDev, byteOffset,		\
				      transactionSize, pData)	\
    vxbPciDevCfgRead(pDev, byteOffset, transactionSize, pData)

#define VXB_PCI_BUS_CFG_WRITE_INTERNAL(pDev, byteOffset,	\
				       transactionSize, pData)	\
    vxbPciDevCfgWrite(pDev, byteOffset, transactionSize, *(pData))
#endif	/* VXB_LEGACY_ACCESS */

/* Defines for IntLib */

#ifndef INT_NUM_IRQ0
#   define INT_NUM_IRQ0 0
#endif /* INT_NUM_IRQ0 */

#ifndef PCI_INT_BASE
#   define PCI_INT_BASE INT_NUM_IRQ0
#endif /* INT_NUM_IRQ0 */

#ifndef PCI_INT_LINES
#   ifdef PCI_IRQ_LINES /* backward compatibility */
#   define PCI_INT_LINES    PCI_IRQ_LINES
#   else
#   define PCI_INT_LINES    32
#   endif
#endif

#if PCI_INT_LINES > 32
#error PCI INT LINES must be 32 or less
#endif

/*
 * This maps a system vector to a PCI irq number, in the range
 * 0 to (PCI_INT_LINES - 1)
 */

#ifndef PCI_INT_VECTOR_TO_IRQ
#define PCI_INT_VECTOR_TO_IRQ(vector)                   \
    (IVEC_TO_INUM(vector) - PCI_INT_BASE)
#endif /* PCI_INT_VECTOR_TO_IRQ */

#define PCI_CONFIG_ABSENT_F 0xffff
#define PCI_CONFIG_ABSENT_0 0x0000

#ifdef	INCLUDE_PCI_BUS_AUTOCONF

/*
 * if main host bridge bridges directly to bus1 not bus0 we need to
 * remember this for intAssign for P2P bridges
 */

LOCAL BOOL vxbPciFirstTimeBus1=TRUE;
LOCAL BOOL vxbPciBusArray[256];
LOCAL BOOL vxbPciBusAllocFirstTime = TRUE;

typedef struct pciAutoConfigOpts
    {
    /* copy of pSystem from pciAutoConfig() interface */
    UINT pciMem32;              /* 32 bit prefetchable memory location */
    UINT pciMem32Size;          /* 32 bit prefetchable memory size */
    UINT pciMemIo32;            /* 32 bit non-prefetchable memory location */
    UINT pciMemIo32Size;        /* 32 bit non-prefetchable memory size */
    UINT pciIo32;               /* 32 bit io location */
    UINT pciIo32Size;           /* 32 bit io size */
    UINT pciIo16;               /* 16 bit io location */
    UINT pciIo16Size;           /* 16 bit io size */
    int maxBus;                 /* Highest subbus number */
    int cacheSize;              /* cache line size */
    UINT maxLatency;            /* max latency */
    BOOL autoIntRouting;        /* automatic routing strategy */
    VXB_PCI_INCLUDE_FUNC                includeRtn;
    VXB_PCI_INT_ASSIGN_FUNC             intAssignRtn;
    VXB_PCI_BRIDGE_PRE_CONFIG_FUNC      bridgePreConfigInit;
    VXB_PCI_BRIDGE_POST_CONFIG_FUNC     bridgePostConfigInit;
    PCI_ROLL_CALL_FUNC          pciRollcallRtn;

    /* new stuff not available in the obsolete PCI_AUTO_CONFIG_OPTS structure */

    BOOL                pciConfigInit;          /* internal use only */
    /* Fast Back TO Back Enable */
    BOOL                pciFBBEnable;           /* Enabled for system */
    BOOL                pciFBBActive;           /* implemented all cards & turned on */
    /* memory allocation */
    UINT32              pciMemBusMinRes;        /* minimum to reserve per bus */
    UINT32              pciMemBusExtraRes;      /* extra to reserve per bus */
    UINT32              pciMemMax;              /* maximum total to reserve */
    UINT32              pciMem32Used;           /* total 32-bit mem actually used */
    UINT32              pciMemIo32Used;         /* total 32-bit IOmem used */
    UINT32              pciIo32Used;            /* total 32-bit IO space used */
    UINT32              pciIo16Used;            /* total 16-bit IO space used */
    PCI_MEM_BUS_EXTRA_FUNC pciMemBusExtraFunc;  /* per bus, function to calculate */
    /* misc functions */
    PCI_LOGMSG_FUNC     pciLogMsgFunc;          /* safe logMsg() func */
    PCI_MAX_LAT_FUNC    pciMaxLatFunc;          /* MAX_LAT calc each device */
    void *              pciMaxLatPArg;          /* user-supplied arg */
    /* PCI_AUTO_MAX_FUNCTIONS */
    PCI_LOC *           pFuncList;              /* user-supplied space */
    int                 numFuncListEntries;     /* number of entries available */
    BOOL                minimizeResources;      /* sort resource requirements */
    VXB_DEVICE_ID       busCtrlID;
    } PCI_AUTO_CONFIG_OPTS;

LOCAL PCI_AUTO_CONFIG_OPTS defaultPciAutoConfigOpts =
    {
    /* pSystem */
    0,		/* pciMem32 */
    0,		/* pciMem32Size */
    0,		/* pciMemIo32 */
    0,		/* pciMemIo32Size */
    0,		/* pciIo32 */
    0,		/* pciIo32Size */
    0, 		/* pciIo16 */
    0,		/* pciIo16Size */
    0,		/* maxBus */
    0,		/* cacheSize */
    0,		/* maxLatency */
    FALSE,	/* autoIntRouting */
    NULL,	/* includeRtn */
    NULL,	/* intAssignRtn */
    NULL,	/* bridgePreConfigInit */
    NULL,	/* bridgePostConfigInit */
    NULL,	/* pciRollCallRtn */
    FALSE,	/* is this structure valid? */
    FALSE,	/* Fast Back To Back enabled */
    FALSE,	/* Fast Back To Back active */
    0,		/* mem 32-bit min to reserve */
    0,		/* mem 32-bit extra to reserve */
    0,		/* max total 32-bit memory */
    0,		/* actual 32-bit mem used */
    0,		/* actual 32-bit IOmem used */
    0,		/* actual 32-bit IO space used */
    0,		/* actual 16-bit IO space used */
    NULL,	/* per bus func to calculate extra mem */
    NULL,	/* logMsg() function */
    NULL,	/* function to calc MAX_LAT */
    NULL,	/* pArg for pciMaxLatFunc() */
    NULL,	/* pFuncList */
    0,		/* number of entries available in pFuncList */
    FALSE,	/* minimize resources */
    NULL        /* Bus Controller Device ID */
    };

/* forward declarations */

#ifdef PCI_AUTO_STATIC_LIST
LOCAL PCI_LOC vxbPciAutoLocalFuncList[PCI_AUTO_MAX_FUNCTIONS];
#endif /* PCI_AUTO_STATIC_LIST */

LOCAL int lastPciListSize;
LOCAL PCI_LOC *pLastPciList;

LOCAL UCHAR vxbPciAutoIntRoutingTable[4];

void * vxbPciAutoConfigLibInit
    (
    void * pArg				/* reserved for future use */
    );
STATUS vxbPciAutoCfg
    (
    void *pCookie/* cookie returned by vxbPciAutoConfigLibInit() */
    );
STATUS vxbPciAutoCfgCtl
    (
    void *      pCookie,          /* system configuration information */
    int	        cmd,              /* command word */
    void *      pArg              /* argument for the cmd */
    );
LOCAL PCI_LOC * vxbPciAutoListCreate
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,
    int *pListSize
    );
LOCAL UINT vxbPciAutoBusProbe
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,
    UINT priBus,
    UINT secBus,
    PCI_LOC*  pPciLoc,
    PCI_LOC** ppPciList,
    int * pListSize
    );
LOCAL UINT vxbPciAutoDevProbe
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,
    UINT bus,
    UCHAR offset,
    UCHAR inheritAttrib,
    PCI_LOC **ppPciList,
    int * pListSize
    );
void vxbPciAutoFuncEnable
    (
    PCI_AUTO_CONFIG_OPTS * pSys,	  /* for backwards compatibility */
    PCI_LOC * pFunc       /* input: Pointer to PCI function structure */
    );
UINT vxbPciAutoRegConfig
    (
    PCI_AUTO_CONFIG_OPTS *pSys,		/* backwards compatibility */
    PCI_LOC *pPciFunc,		/* Pointer to function in device list */
    UINT baseAddr,		/* Offset of base PCI address */
    UINT nSize,			/* Size and alignment requirements */
    UINT addrInfo		/* PCI address type information	*/
    );
STATUS vxbPciAutoAddrAlign
    (
    UINT32 base,		/* base of available memory */
    UINT32 limit,		/* last addr of available memory */
    UINT32 reqSize,		/* required size */
    UINT32 *pAlignedBase	/* output: aligned address put here */
    );
LOCAL void vxbPciAutoFuncConfigAll
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,
    PCI_LOC *pPciList,
    UINT nSize
    );
LOCAL UCHAR vxbPciAutoIntAssign
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,
    PCI_LOC * pFunc
    );
LOCAL void vxbPciAutoDevConfig
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,
    UINT bus,
    PCI_LOC **ppPciList,
    UINT *nSize
    );
LOCAL void vxbPciAutoFuncConfig
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,
    PCI_LOC * pPciFunc
    );
LOCAL UINT vxbPciAutoIoAlloc
    (
    PCI_AUTO_CONFIG_OPTS * pPciSys,
    PCI_LOC *pPciFunc,
    UINT *pAlloc,
    UINT nSize
    );
LOCAL UINT vxbPciAutoMemAlloc
    (
    PCI_AUTO_CONFIG_OPTS * pPciSys,
    PCI_LOC * pPciFunc,
    UINT * pAlloc,
    UINT size,
    UINT addrInfo
    );
LOCAL void vxbPciAutoBusConfig
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,
    PCI_LOC * pPciLoc,
    PCI_LOC **ppPciList,
    UINT *nSize
    );
LOCAL void vxbPciAutoCardBusConfig
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,
    PCI_LOC * pPciLoc,
    PCI_LOC **ppPciList,
    UINT *nSize
    );
LOCAL STATUS vxbPciAutoCfgFunc
    (
    void *pCookie
    );
LOCAL STATUS vxbPciAutoConfigFBBEnable
    (
    PCI_AUTO_CONFIG_OPTS *	pOpts
    );
LOCAL STATUS vxbPciAutoConfigFBBDisable
    (
    PCI_AUTO_CONFIG_OPTS *	pOpts
    );
LOCAL STATUS vxbPciFBBFuncClear
    (
    VXB_DEVICE_ID busCtrlID,
    UINT bus,
    UINT device,
    UINT function,
    void *pArg
    );
LOCAL STATUS vxbPciFBBFuncSet
    (
    VXB_DEVICE_ID busCtrlID,
    UINT bus,
    UINT device,
    UINT function,
    void *pArg
    );
LOCAL STATUS vxbPciFBBFuncCheck
    (
    VXB_DEVICE_ID busCtrlID,
    UINT bus,
    UINT device,
    UINT function,
    void *pArg
    );

#endif /* INCLUDE_PCI_BUS_AUTOCONF */

#ifdef	INCLUDE_PCI_BUS_SHOW
LOCAL void vxbPciDheaderPrint
    (
    PCI_HEADER_DEVICE * pD
    );

LOCAL void vxbPciBheaderPrint
    (
    PCI_HEADER_BRIDGE * pB
    );

LOCAL void vxbPciCBheaderPrint
    (
    PCI_HEADER_CB_BRIDGE * pCB
    );

LOCAL void vxbCapabShow
    (
    VXB_DEVICE_ID,
    UINT,
    UINT,
    UINT,
    UINT8
    );
#endif	/* INCLUDE_PCI_BUS_SHOW */

#ifdef USE_PCI_SIMULATOR
LOCAL STATUS vxbPciCfgReadInternal
    (
    VXB_DEVICE_ID       pDev,                   /* device info */
    UINT8               busNo,
    UINT8               devNo,
    UINT8               funcNo,
    UINT32              byteOffset,             /* offset into cfg space */
    UINT32              transactionSize,        /* transaction size */
    void *              pData                   /* buffer to read/write */
    );

LOCAL STATUS vxbPciCfgWriteInternal
    (
    VXB_DEVICE_ID       pDev,                   /* device info */
    UINT8               busNo,
    UINT8               devNo,
    UINT8               funcNo,
    UINT32              byteOffset,             /* offset into cfg space */
    UINT32              transactionSize,        /* transaction size */
    UINT32              data                    /* data to write */
    );

void vxbPciAutoConfigListShow
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,
    PCI_LOC *pLoc,
    int num
    );
#endif /* USE_PCI_SIMULATOR */

#ifdef INCLUDE_PCI_OLD_CONFIG_ROUTINES
extern STATUS pciIntConnect	(VOIDFUNCPTR * vec, VOIDFUNCPTR rtn, int arg);
extern STATUS pciIntDisconnect	(VOIDFUNCPTR * vec, VOIDFUNCPTR rtn);
extern STATUS pciIntDisconnect2(VOIDFUNCPTR * vec, VOIDFUNCPTR rtn, int arg);
#endif /* INCLUDE_PCI_OLD_CONFIG_ROUTINES */

/******************************************************************************
*
* vxbPciBusCfgRead - Read from PCI configuration space
*
* This routine reads from PCI configuration space.  It is intended for
* internal use only
*
* RETURNS: OK, or ERROR if configuration space read fails
*
* ERRNO: N/A
*
* NOMANUAL
*/

STATUS vxbPciBusCfgRead
    (
    VXB_DEVICE_ID       pDev,            /* device info */
    UINT32              byteOffset,      /* offset into cfg space */
    UINT32              transactionSize, /* transaction size */
    void *              pDataBuf         /* buffer to read/write */
    )
    {
    STATUS retVal;

    retVal = VXB_PCI_BUS_CFG_READ_INTERNAL(pDev, byteOffset,
                                           transactionSize,
					   pDataBuf);

    return(retVal);
    }

/******************************************************************************
*
* vxbPciBusCfgWrite - Write to PCI configuration space
*
* This routine writes to PCI configuration space.  It is intended for
* internal use only
*
* RETURNS: OK, or ERROR if configuration space write fails
*
* ERRNO: N/A
*
* NOMANUAL
*/

STATUS vxbPciBusCfgWrite
    (
    VXB_DEVICE_ID       pDev,            /* device info */
    UINT32              byteOffset,      /* offset into cfg space */
    UINT32              transactionSize, /* transaction size */
    void *              pDataBuf         /* buffer to read/write */
    )
    {
    STATUS retVal;

#ifdef	VXB_LEGACY_ACCESS
    retVal = VXB_PCI_BUS_CFG_WRITE_INTERNAL(pDev, byteOffset,
					    transactionSize, pDataBuf);
#else	/* VXB_LEGACY_ACCESS*/

    switch (transactionSize)
        {
	case 1:
	    retVal = VXB_PCI_BUS_CFG_WRITE_INTERNAL(pDev, byteOffset,
                                           	    transactionSize,
					   	    (UINT8 *)pDataBuf);
	    break;
	case 2:
	    retVal = VXB_PCI_BUS_CFG_WRITE_INTERNAL(pDev, byteOffset,
                                           	    transactionSize,
					   	    (UINT16 *)pDataBuf);
	    break;
	case 4:
	    retVal = VXB_PCI_BUS_CFG_WRITE_INTERNAL(pDev, byteOffset,
                                           	    transactionSize,
					   	    (UINT32 *)pDataBuf);
	    break;
	default:
	    return(ERROR);
	}
#endif	/* VXB_LEGACY_ACCESS */

    return(retVal);
    }

/******************************************************************************
*
* pciIntVectorToIRQ - Convert from a vector to an IRQ
*
* This routine converts from a vector to an IRQ.  It is intended for
* internal use only
*
* RETURNS: the IRQ number corresponding to the supplied vector
*
* ERRNO: N/A
*
* NOMANUAL
*/

int pciIntVectorToIRQ
    (
    VOIDFUNCPTR * vector
    )
    {
    return(PCI_INT_VECTOR_TO_IRQ (vector));
    }

/******************************************************************************
*
* vxbDevAccessAnnounce - Initialize access structures for new devices
*
* This routine initializes the access structure for new VxBus PCI devices
*
* RETURNS: OK, or ERROR if the access structure could not be allocated
*
* ERRNO: N/A
*/

STATUS vxbDevAccessAnnounce
    (
    VXB_DEVICE_ID pDev,
    struct pciDevAnnounceInfo * p
    )
    {
#ifdef  VXB_LEGACY_ACCESS
    /* initialize access structure */

    pDev->pAccess = (pVXB_ACCESS_LIST)hwMemAlloc(sizeof(VXB_ACCESS_LIST));
    if ( pDev->pAccess == NULL )
        {
        vxbDevStructFree(pDev);
        return(ERROR);
        }

    bcopy((char *)p->pMethods, (char *)pDev->pAccess, sizeof(VXB_ACCESS_LIST));
#endif  /* VXB_LEGACY_ACCESS */
    return(OK);
    }

#ifdef INCLUDE_PCI_OLD_CONFIG_ROUTINES
/*******************************************************************************
*
* pciConfigInByte - read one byte from the PCI configuration space
*
* This routine reads one byte from the PCI configuration space
*
* RETURNS: OK, or ERROR if this library is not initialized
*
* ERRNO
*
*/

STATUS pciConfigInByte
    (
    int	busNo,    /* bus number */
    int	deviceNo, /* device number */
    int	funcNo,	  /* function number */
    int	offset,	  /* offset into the configuration space */
    UINT8 * pData /* data read from the offset */
    )
    {
    return(vxbPciConfigInByte(globalBusCtrlID,busNo,deviceNo,funcNo,offset,pData));
    }

/*******************************************************************************
*
* pciConfigInWord - read one word from the PCI configuration space
*
* This routine reads one word from the PCI configuration space
*
* RETURNS: OK, or ERROR if this library is not initialized
*
* ERRNO
*
*/

STATUS pciConfigInWord
    (
    int	busNo,    /* bus number */
    int	deviceNo, /* device number */
    int	funcNo,	  /* function number */
    int	offset,	  /* offset into the configuration space */
    UINT16 * pData /* data read from the offset */
    )
    {
    return(vxbPciConfigInWord(globalBusCtrlID,busNo,deviceNo,funcNo,offset,pData));
    }

/*******************************************************************************
*
* pciConfigInLong - read one longword from the PCI configuration space
*
* This routine reads one longword from the PCI configuration space
*
* RETURNS: OK, or ERROR if this library is not initialized
*
* ERRNO
*
*/

STATUS pciConfigInLong
    (
    int	busNo,    /* bus number */
    int	deviceNo, /* device number */
    int	funcNo,	  /* function number */
    int	offset,	  /* offset into the configuration space */
    UINT32 * pData /* data read from the offset */
    )
    {
    return(vxbPciConfigInLong(globalBusCtrlID,busNo,deviceNo,funcNo,offset,pData));
    }

/*******************************************************************************
*
* pciConfigOutByte - write one byte to the PCI configuration space
*
* This routine writes one byte to the PCI configuration space.
*
* RETURNS: OK, or ERROR if this library is not initialized
*
* ERRNO
*
*/

STATUS pciConfigOutByte
    (
    int	busNo,    /* bus number */
    int	deviceNo, /* device number */
    int	funcNo,   /* function number */
    int	offset,   /* offset into the configuration space */
    UINT8 data    /* data written to the offset */
    )
    {
    return(vxbPciConfigOutByte(globalBusCtrlID,busNo,deviceNo,funcNo,offset,data));
    }

/*******************************************************************************
*
* pciConfigOutWord - write one 16-bit word to the PCI configuration space
*
* This routine writes one 16-bit word to the PCI configuration space.
*
* RETURNS: OK, or ERROR if this library is not initialized
*
* ERRNO
*
*/

STATUS pciConfigOutWord
    (
    int	busNo,    /* bus number */
    int	deviceNo, /* device number */
    int	funcNo,   /* function number */
    int	offset,   /* offset into the configuration space */
    UINT16 data    /* data written to the offset */
    )
    {
    return(vxbPciConfigOutWord(globalBusCtrlID,busNo,deviceNo,funcNo,offset,data));
    }

/*******************************************************************************
*
* pciConfigOutLong - write one longword to the PCI configuration space
*
* This routine writes one longword to the PCI configuration space.
*
* RETURNS: OK, or ERROR if this library is not initialized
*
* ERRNO
*
*/

STATUS pciConfigOutLong
    (
    int	busNo,    /* bus number */
    int	deviceNo, /* device number */
    int	funcNo,   /* function number */
    int	offset,   /* offset into the configuration space */
    UINT32 data    /* data written to the offset */
    )
    {
    return(vxbPciConfigOutLong(globalBusCtrlID,busNo,deviceNo,funcNo,offset,data));
    }

/*****************************************************************************
*
* pciConfigModifyLong - Perform a masked longword register update
*
* This function writes a field into a PCI configuration header without
* altering any bits not present in the field.  It does this by first
* doing a PCI configuration read (into a temporary location) of the PCI
* configuration header word which contains the field to be altered.
* It then alters the bits in the temporary location to match the desired
* value of the field.  It then writes back the temporary location with
* a configuration write.  All configuration accesses are long and the
* field to alter is specified by the "1" bits in the 'bitMask' parameter.
*
* Be careful to using pciConfigModifyLong for updating the Command and
* status register.  The status bits must be written back as zeroes, else
* they will be cleared.  Proper use involves including the status bits in
* the mask value, but setting their value to zero in the data value.
*
* The following example will set the PCI_CMD_IO_ENABLE bit without clearing any
* status bits.  The macro PCI_CMD_MASK includes all the status bits as
* part of the mask.  The fact that PCI_CMD_MASTER doesn't include these bits,
* causes them to be written back as zeroes, therefore they aren't cleared.
*
* \cs
*    pciConfigModifyLong (b,d,f,PCI_CFG_COMMAND,
*                 (PCI_CMD_MASK | PCI_CMD_IO_ENABLE), PCI_CMD_IO_ENABLE);
* \ce
*
* Use of explicit longword read and write operations for dealing with any
* register containing "write 1 to clear" bits is sound policy.
*
* RETURNS: OK if operation succeeds, ERROR if operation fails.
*
* ERRNO
*
* \NOMANUAL
*/

STATUS pciConfigModifyLong
    (
    int busNo,          /* bus number */
    int deviceNo,       /* device number */
    int funcNo,         /* function number */
    int offset,         /* offset into the configuration space */
    UINT32 bitMask,     /* Mask which defines field to alter */
    UINT32 data         /* data written to the offset */
    )
    {
    return (vxbPciConfigModifyLong (globalBusCtrlID, busNo, deviceNo, funcNo,
				    offset, bitMask, data));
    }

/*****************************************************************************
*
* pciConfigModifyWord - Perform a masked longword register update
*
* This function writes a field into a PCI configuration header without
* altering any bits not present in the field.  It does this by first
* doing a PCI configuration read (into a temporary location) of the PCI
* configuration header word which contains the field to be altered.
* It then alters the bits in the temporary location to match the desired
* value of the field.  It then writes back the temporary location with
* a configuration write.  All configuration accesses are long and the
* field to alter is specified by the "1" bits in the 'bitMask' parameter.
*
* Do not use this routine to modify any register that contains 'write 1
* to clear' type of status bits in the same longword.  This specifically
* applies to the command register.  Modify byte operations could potentially
* be implemented as longword operations with bit shifting and masking.  This
* could have the effect of clearing status bits in registers that aren't being
* updated.  Use pciConfigInLong and pciConfigOutLong, or pciModifyLong,
* to read and update the entire longword.
*
* RETURNS: OK if operation succeeds.  ERROR if operation fails.
*
* ERRNO
*
* \NOMANUAL
*/

STATUS pciConfigModifyWord
    (
    int busNo,          /* bus number */
    int deviceNo,       /* device number */
    int funcNo,         /* function number */
    int offset,         /* offset into the configuration space */
    UINT16 bitMask,     /* Mask which defines field to alter */
    UINT16 data         /* data written to the offset */
    )
    {
    return (vxbPciConfigModifyWord (globalBusCtrlID, busNo, deviceNo, funcNo,
				    offset, bitMask, data));
    }

/*****************************************************************************
*
* pciConfigModifyByte - Perform a masked longword register update
*
* This function writes a field into a PCI configuration header without
* altering any bits not present in the field.  It does this by first
* doing a PCI configuration read (into a temporary location) of the PCI
* configuration header word which contains the field to be altered.
* It then alters the bits in the temporary location to match the desired
* value of the field.  It then writes back the temporary location with
* a configuration write.  All configuration accesses are long and the
* field to alter is specified by the "1" bits in the 'bitMask' parameter.
*
* Do not use this routine to modify any register that contains 'write 1
* to clear' type of status bits in the same longword.  This specifically
* applies to the command register.  Modify byte operations could potentially
* be implemented as longword operations with bit shifting and masking.  This
* could have the effect of clearing status bits in registers that aren't being
* updated.  Use pciConfigInLong and pciConfigOutLong, or pciModifyLong,
* to read and update the entire longword.
*
* RETURNS: OK if operation succeeds, ERROR if operation fails.
*
* ERRNO
*
* \NOMANUAL
*/

STATUS pciConfigModifyByte
    (
    int busNo,          /* bus number */
    int deviceNo,       /* device number */
    int funcNo,         /* function number */
    int offset,         /* offset into the configuration space */
    UINT8 bitMask,      /* Mask which defines field to alter */
    UINT8 data          /* data written to the offset */
    )
    {
    return (vxbPciConfigModifyByte (globalBusCtrlID, busNo, deviceNo, funcNo,
				    offset, bitMask, data));
    }

/**********************************************************************
*
* pciConfigForeachFunc - check condition on specified bus
*
* pciConfigForeachFunc() discovers the PCI functions present on the
* bus and calls a specified C-function for each one.  If the
* function returns ERROR, further processing stops.
*
* pciConfigForeachFunc() does not affect any HOST<->PCI
* bridge on the system.
*
* ERRNO: not set
*
* RETURNS: OK normally, or ERROR if funcCheckRtn() doesn't return OK.
*
*/

STATUS pciConfigForeachFunc
    (
    UINT8 bus,			    /* bus to start on */
    BOOL recurse,		    /* if TRUE, do subordinate busses */
    PCI_FOREACH_FUNC funcCheckRtn,  /* routine to call for each PCI func */
    void *pArg			    /* argument to funcCheckRtn */
    )
    {
    int     pciLocBus;  /* PCI bus/device/function structure */
    int     pciLocDevice;   /* PCI bus/device/function structure */
    int     pciLocFunction; /* PCI bus/device/function structure */
    int     device;     /* loop over devices */
    int     function;   /* loop over functions */
    UINT    devVend;
    UINT16  pciClass;   /* PCI class/subclass contents */
    int     status;
    UINT8   btemp;
    UINT8   secBus;     /* secondary bus, for recursion */
    UINT16  hostBridge = (PCI_CLASS_BRIDGE_CTLR<<8) |
                         PCI_SUBCLASS_HOST_PCI_BRIDGE;

    /* Begin the scanning process at [bus,0,0] */

    pciLocBus = (UINT8)bus;
    pciLocDevice = (UINT8)0;
    pciLocFunction = (UINT8)0;

    /* discover devices and perform check */

    /* Locate each active function on the current bus */

    for (device = 0; device < PCI_MAX_DEV; device++)
        {
        pciLocDevice = device;

        /* Check each function until an unused one is detected */

        for (function = 0; function < PCI_MAX_FUNC; function++)
            {
            pciLocFunction = function;

            /* Check for a valid device/vendor number */
            pciConfigInLong (pciLocBus, pciLocDevice, pciLocFunction,
                             PCI_CFG_VENDOR_ID, &devVend);

            /* If function 0 then check next dev else check next function */
            if ( ((devVend & 0x0ffff) == PCI_CONFIG_ABSENT_F) ||
                 ((devVend & 0x0ffff) == PCI_CONFIG_ABSENT_0) )
                {
                if (function == 0)
                    {
                    break;  /* non-existent device, go to next device */
                    }
                else
                    {
                    continue;  /* function empty, try the next function */
                    }
                }

            /* Check to see if this function belongs to a PCI-PCI bridge */
            pciConfigInWord (pciLocBus, pciLocDevice, pciLocFunction,
                             PCI_CFG_SUBCLASS, &pciClass);

            if ( pciClass != hostBridge )
                {
                /* call specified function */
                status = (*funcCheckRtn)(pciLocBus, pciLocDevice,
                                         pciLocFunction, pArg);
                if ( status != OK )
                    return(ERROR);
                }

            if ( recurse )
                {
                /* if P2P bridge, check that bus recursively */
                if ( (pciClass == ((PCI_CLASS_BRIDGE_CTLR << 8) + PCI_SUBCLASS_P2P_BRIDGE)) ||
                     (pciClass == ((PCI_CLASS_BRIDGE_CTLR << 8) + PCI_SUBCLASS_CARDBUS_BRIDGE)))
                    {
                    pciConfigInByte (pciLocBus, pciLocDevice, pciLocFunction,
                                     PCI_CFG_SECONDARY_BUS, &secBus);


                    if ( secBus > 0 )
                        status = pciConfigForeachFunc(secBus, recurse,
                                                      funcCheckRtn, pArg);
                    else
                        status = OK;

                    if ( status != OK )
                        return(ERROR);
                    }
                }

            /* Proceed to next device if this is a single function device */
            if (function == 0)
                {
                pciConfigInByte (pciLocBus, pciLocDevice, pciLocFunction,
                                 PCI_CFG_HEADER_TYPE, &btemp);
                if ((btemp & PCI_HEADER_MULTI_FUNC) == 0)
                    {
                    break; /* No more functions - proceed to next PCI device */
                    }
                }
            }
        }

    return(OK);
    }

/*******************************************************************************
*
* pciIntConnect - connect the interrupt handler to the PCI interrupt.
*
* This routine connects an interrupt handler to a shared PCI interrupt vector.
* A link list is created for each shared interrupt used in the system.  It
* is created when the first interrupt handler is attached to the vector.
* Subsequent calls to pciIntConnect just add their routines to the
* linked list for that vector.
*
* RETURNS:
* OK, or ERROR if the interrupt handler cannot be built.
*
* ERRNO
*
*/

STATUS pciIntConnect
    (
    VOIDFUNCPTR *vector,        /* interrupt vector to attach to     */
    VOIDFUNCPTR routine,        /* routine to be called              */
    int parameter               /* parameter to be passed to routine */
    )
    {
    return(vxbPciIntConnect(globalBusCtrlID,vector,routine,parameter));
    }

/*******************************************************************************
*
* pciIntDisconnect - disconnect the interrupt handler (OBSOLETE)
*
* This routine disconnects the interrupt handler from the PCI interrupt line.
*
* In a system where one driver and one ISR services multiple devices, this
* routine removes all instances of the ISR because it completely ignores the
* parameter argument used to install the handler.
*
* NOTE: Use of this routine is discouraged and will be obsoleted in the future.
* New code should use the pciIntDisconnect2() routine instead.
*
* RETURNS:
* OK, or ERROR if the interrupt handler cannot be removed.
*
* ERRNO
*
*/

STATUS pciIntDisconnect
    (
    VOIDFUNCPTR *vector,        /* interrupt vector to attach to     */
    VOIDFUNCPTR routine         /* routine to be called              */
    )
    {
    return(vxbPciIntDisconnect(globalBusCtrlID,vector,routine));
    }

/*******************************************************************************
*
* pciIntDisconnect2 - disconnect the interrupt handler
*
* This routine disconnects the interrupt handler from the PCI interrupt line.
*
* Use this routine in a system where one driver and one ISR services
* multiple devices.
*
*
* RETURNS:
* OK, or ERROR if the interrupt handler cannot be removed.
*
* ERRNO
*
*/

STATUS pciIntDisconnect2
      (
      VOIDFUNCPTR *vector,        /* interrupt vector to attach to     */
      VOIDFUNCPTR routine,         /* routine to be called              */
      int arg
      )
      {
      return(vxbPciIntDisconnect2(globalBusCtrlID, vector, routine, arg));
      }

/*******************************************************************************
*
* pciFindDevice - find the nth device with the given device & vendor ID
*
* This routine finds the nth device with the given device & vendor ID.
*
* RETURNS:
* OK, or ERROR if the deviceId and vendorId didn't match.
*
* ERRNO
*
*/

STATUS pciFindDevice
    (
    int    vendorId,    /* vendor ID */
    int    deviceId,    /* device ID */
    int    index,       /* desired instance of device */
    int *  pBusNo,      /* bus number */
    int *  pDeviceNo,   /* device number */
    int *  pFuncNo      /* function number */
    )
    {
    return(vxbPciFindDevice(globalBusCtrlID,vendorId,deviceId,index,pBusNo,pDeviceNo,pFuncNo));
    }

/*******************************************************************************
*
* pciConfigExtCapFind - find extended capability in ECP linked list
*
* It calls the underlying vxbPciConfigExtCapFind with globalBusCtrlID.
* SEE ALSO pciConfigEnable.
*
* RETURNS: OK if Extended Capability found, ERROR otherwise
*
* ERRNO
*
*/

STATUS pciConfigExtCapFind
    (
    UINT8 extCapFindId,
    int bus,
    int device,
    int function,
    UINT8 * pOffset
    )
    {
    return(vxbPciConfigExtCapFind (globalBusCtrlID,extCapFindId,bus, device,
			    function, pOffset));
    }

/******************************************************************************
*
* pciDevConfig - configure a device on a PCI bus
*
* It calls the underlying vxbPciDevConfig with globalBusCtrlID.
* See pciConfigEnable.
*
* RETURNS: OK always.
*
* ERRNO
*
*/
STATUS pciDevConfig
    (
    int pciBusNo,
    int pciDevNo,
    int pciFuncNo,
    UINT32 devIoBaseAdrs,
    UINT32 devMemBaseAdrs,
    UINT32 command
    )
    {
    return(vxbPciDevConfig (globalBusCtrlID, pciBusNo, pciDevNo,
			    pciFuncNo, devIoBaseAdrs, devMemBaseAdrs,
			    command));
    }

/*******************************************************************************
*
* pciFindClass - find the nth occurrence of a device by PCI class code.
*
* This routine finds the nth device with the given 24-bit PCI class code
* (class subclass prog_if).
*
* The classcode arg of must be carefully constructed from class and sub-class
* macros.
*
* Example : To find an ethernet class device, construct the classcode arg
* as follows:
*
* \cs
*     ((PCI_CLASS_NETWORK_CTLR << 16 | PCI_SUBCLASS_NET_ETHERNET << 8))
* \ce
*
* RETURNS:
* OK, or ERROR if the class didn't match.
*
* ERRNO
*
*/

STATUS pciFindClass
    (
    int    classCode,   /* 24-bit class code */
    int    index,       /* desired instance of device */
    int *  pBusNo,      /* bus number */
    int *  pDeviceNo,   /* device number */
    int *  pFuncNo      /* function number */
    )
    {
    if(globalBusCtrlID==NULL)
	return(ERROR);

    return(vxbPciFindClass(globalBusCtrlID, classCode,index,
			   pBusNo, pDeviceNo, pFuncNo));
    }

#ifdef INCLUDE_PCI_BUS_AUTOCONF
/**********************************************************************
*
* pciAutoCfgCtl - set or get autoConfigLib options
*
* This gets or sets the autoConfigLib options.
*
* RETURNS: OK, or ERROR if the command or argument is invalid.
*
* SEE ALSO : vxbPciAutoCfgCtl
*
*/

STATUS pciAutoCfgCtl
    (
    void *      pCookie,          /* system configuration information */
    int	        cmd,              /* command word */
    void *      pArg              /* argument for the cmd */
    )
    {
    return(vxbPciAutoCfgCtl(pCookie,cmd,pArg));
    }
#endif /* INCLUDE_PCI_BUS_AUTOCONF */
#endif /* INCLUDE_PCI_OLD_CONFIG_ROUTINES */

/******************************************************************************
*
* vxbAccessFree - Free VxBus access structure
*
* This routine frees the access structure for VxBus PCI devices
*
* RETURNS: N/A
*
* ERRNO: N/A
*/

void vxbAccessFree
    (
    VXB_DEVICE_ID pDev
    )
    {
#ifdef  VXB_LEGACY_ACCESS
    hwMemFree((char *)(pDev->pAccess));
#endif  /* VXB_LEGACY_ACCESS */
    }

/******************************************************************************
*
* vxbPciAccessCookieSet - Initialize cookie used by legacy access
*
* This routine sets the cookie used for legacy access
*
* RETURNS: N/A
*
* ERRNO: N/A
*/

void vxbPciAccessCookieSet
    (
    VXB_DEVICE_ID pDev,
    UINT32 * pBaseAddr
    )
    {
#ifdef  VXB_LEGACY_ACCESS
    /* store the pointer to the array in the access structure */

    pDev->pAccess->pCookie = (void *)pBaseAddr;
#endif  /* VXB_LEGACY_ACCESS */
    }

/******************************************************************************
*
* pciCfgInit - Initialize configuration-specific aspects of VxBus PCI support
*
* This routine performs initialization that depends on the system
* configuration.
*
* RETURNS: N/A
*
* ERRNO: N/A
*/

void pciCfgInit(void)
    {
#ifdef  INCLUDE_PCI_BUS_AUTOCONF
#  ifdef INCLUDE_PCI_OLD_CONFIG_ROUTINES
    /* set function binds for auto-configuration */

    _func_pciAutoCfgCtl    = pciAutoCfgCtl;
#  endif /* INCLUDE_PCI_OLD_CONFIG_ROUTINES */

    _func_vxbPciAutoConfig = vxbPciAutoConfig;
#endif  /* INCLUDE_PCI_BUS_AUTOCONF */
    }

#ifdef	INCLUDE_PCI_BUS_SHOW

/*******************************************************************************
*
* pciDevShow - show information about PCI device
*
* RETURNS: OK, or ERROR if there's an error
*
* ERRNO
*/

void pciDevShow
    (
    struct vxbDev * pDev  /* Device information */
    )
    {
    struct vxbPciDevice *  pPciDev;

    pPciDev = (struct vxbPciDevice *)pDev->pBusSpecificDevInfo;
    printf("pDev @ 0x%08x   [%d,%d,%d]\n",
           (int)pDev, pPciDev->pciBus,
           pPciDev->pciDev, pPciDev->pciFunc);
    printf("\tdevID\t= 0x%04x\n", pPciDev->pciDevId);
    printf("\tvendID\t= 0x%04x\n", pPciDev->pciVendId);
    }
#endif	/* INCLUDE_PCI_BUS_SHOW */

#ifdef INCLUDE_PCI_ITERATE
/******************************************************************************
*
* vxbPciIterate - call a routine for each populated bus, device, and function
*
* This function calls a <routine> with prototype
*
* \cs
* STATUS iterFunc
*     (
*     VXB_DEVICE_ID busCtrlID,
*     UINT32 bus,
*     UINT32 device,
*     UINT32 func,
*     void * context,
*     );
* \ce
*
* for each bus number (no greater than <maxBusNum>), device, and function,
* populated with a PCI device.
*
* If iterFunc() returns a value other than OK, the scan stops. The value
* passed as the last argument of iterFunc is the <context> argument to
* pciIterate().
*
* If <maxBusNum> is greater than the <pPciConfig->pciMaxBus> global, <pPciConfig->pciMaxBus> is used
* as the upper limit.
*
* RETURNS:
* OK, or ERROR if <routine> is NULL or the PCI library is not initialized.
*
*
* ERRNO
*
*\NOMANUAL
*/

STATUS vxbPciIterate
    (
    VXB_DEVICE_ID busCtrlID,
    STATUS (*routine) (VXB_DEVICE_ID,UINT32, UINT32, UINT32, void *), /* function to call */
    void * context,                                     /* context argument */
    int maxBusNum                                       /* max. bus number */
    )
    {
    int    busNo;
    int    deviceNo;
    int    funcNo;
    UINT32 classCodeReg;
    UINT32 vendor;
    UINT8  header;

    if(busCtrlID == NULL)
	return(ERROR);

    if (pPciConfig->pciLibInitStatus != OK || routine == NULL)  /* sanity check */
        return ERROR;


    if (maxBusNum > pPciConfig->pciMaxBus)
        maxBusNum = pPciConfig->pciMaxBus;

    for (busNo = 0; busNo <= maxBusNum; busNo++)
        {
        for (deviceNo = 0; deviceNo < PCI_MAX_DEV; deviceNo++)
            {
            for (funcNo = 0; funcNo < PCI_MAX_FUNC; funcNo++)
                {

                /* avoid a special bus cycle */

                if ((deviceNo == 0x1f) && (funcNo == 0x07))
                    continue; /* next function (and device) */

                vxbPciConfigInLong (busCtrlID,busNo, deviceNo, funcNo, PCI_CFG_VENDOR_ID,
                                 &vendor);

                /*
                 * If nonexistent device, skip to next, only look at
                 * vendor ID field for existence check
                 */

                if ((vendor & 0xffff) == 0xffff)
                    {
                    if (funcNo == 0)
                        break; /* next device */
                    continue;  /* next function */
                    }

                vxbPciConfigInLong (busCtrlID,busNo, deviceNo, funcNo, PCI_CFG_REVISION,
                                 &classCodeReg);

                if (routine (busCtrlID,busNo, deviceNo, funcNo, context) != OK)
                    goto out;

                /* go to next if current device is single function */

                vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_HEADER_TYPE,
                                 &header);
                if ((header & PCI_HEADER_MULTI_FUNC) == 0 && funcNo == 0)
                    break; /* next device */
                }
            }
        }

    out:

    return(OK);
    }
#endif /* INCLUDE_PCI_ITERATE */

#ifndef USE_PCI_SIMULATOR
/******************************************************************************
*
* vxbPciCfgReadInternal - Internal PCI config read support routine
*
* It performs a configuration space read on a given PCI target.
* If the target specification or register offset is invalid, it will return
* error.
*
* RETURNS: OK, or ERROR if target specification or register is invalid
*
* ERRNO: N/A
*/

LOCAL STATUS vxbPciCfgReadInternal
    (
    VXB_DEVICE_ID	pDev,			/* device info */
    UINT8		busNo,
    UINT8		devNo,
    UINT8		funcNo,
    UINT32		byteOffset,		/* offset into cfg space */
    UINT32		transactionSize,	/* transaction size */
    void *		pData 		      	/* buffer to read/write */
    )
    {
    STATUS		status;
    FUNCPTR		methodRead;

#ifdef	VXB_LEGACY_ACCESS

    /* check if the pDev pointer is valid */

    VXB_ASSERT(pDev != NULL, ERROR)

    methodRead = vxbDevMethodGet (pDev, PCI_CONTROLLER_METHOD_CFG_READ);

    status = (STATUS) methodRead (pDev,
				  busNo,
				  devNo,
				  funcNo,
				  byteOffset,
				  transactionSize,
				  pData);
#else	/* VXB_LEGACY_ACCESS */
    PCI_HARDWARE	pciDev;
    PCI_HARDWARE *	pPciDev = (PCI_HARDWARE *) &pciDev;

    /* check if the pDev pointer is valid */

    VXB_ASSERT(pDev != NULL, ERROR)

    pPciDev->pciBus  = busNo;
    pPciDev->pciDev  = devNo;
    pPciDev->pciFunc = funcNo;

    methodRead = vxbDevMethodGet (pDev, PCI_CONTROLLER_METHOD_DEV_CFG_READ);

    status = (STATUS) methodRead (pDev,
				  pPciDev,
				  byteOffset,
				  transactionSize,
				  pData);
#endif	/* VXB_LEGACY_ACCESS */

    if (status != OK)
	{
	switch (transactionSize)
	    {
	    case 1:
		*(UINT8 *)  pData = 0xff;
		break;

	    case 2:
		*(UINT16 *) pData = 0xffff;
		break;

	    case 4:
		*(UINT32 *) pData = 0xffffffff;
		break;

	    default:
		break;
	    }
	}

    return (status);
    }

/******************************************************************************
*
* vxbPciCfgWriteInternal - Internal PCI config write support routine
*
* It performs a configuration space write on a given PCI target.
* If the target specification or register offset is invalid, it will return
* error.
*
* RETURNS: OK, or ERROR if target specification or register is invalid
*
* ERRNO: N/A
*/

LOCAL STATUS vxbPciCfgWriteInternal
    (
    VXB_DEVICE_ID	pDev,			/* device info */
    UINT8		busNo,
    UINT8		devNo,
    UINT8		funcNo,
    UINT32		byteOffset,		/* offset into cfg space */
    UINT32		transactionSize,	/* transaction size */
    UINT32		data		      	/* data to write */
    )
    {
    STATUS		status;
    FUNCPTR		methodWrite;
#ifdef	VXB_LEGACY_ACCESS
    void * pData;

    /* check if the pDev pointer is valid */

    VXB_ASSERT(pDev != NULL, ERROR)

    methodWrite = vxbDevMethodGet (pDev, PCI_CONTROLLER_METHOD_CFG_WRITE);

#if	(_BYTE_ORDER == _BIG_ENDIAN)
    switch (transactionSize)
	{
	case 1:
	    data = data << 24;
	    break;

	case 2:
	    data = data << 16;
	    break;

	case 4:
	    break;

	default:
	    return (ERROR);
	}
#endif	/* _BYTE_ORDER == _BIG_ENDIAN */

    pData = (void *) &data;

    status = (STATUS) methodWrite (pDev,
				   busNo,
				   devNo,
				   funcNo,
				   byteOffset,
				   transactionSize,
				   (void *) pData);
#else	/* VXB_LEGACY_ACCESS */
    PCI_HARDWARE	pciDev;
    PCI_HARDWARE *	pPciDev = (PCI_HARDWARE *) &pciDev;

    /* check if the pDev pointer is valid */

    VXB_ASSERT(pDev != NULL, ERROR)

    pPciDev->pciBus  = busNo;
    pPciDev->pciDev  = devNo;
    pPciDev->pciFunc = funcNo;

    methodWrite = vxbDevMethodGet (pDev, PCI_CONTROLLER_METHOD_DEV_CFG_WRITE);

    status = (STATUS) methodWrite (pDev,
				   pPciDev,
				   byteOffset,
				   transactionSize,
				   data);
#endif	/* VXB_LEGACY_ACCESS */

    return (status);
    }

/*******************************************************************************
*
* vxbPciConfigInByte - read one byte from the PCI configuration space
*
* This routine reads one byte from the PCI configuration space
*
* RETURNS: OK, or ERROR if this library is not initialized
*
* ERRNO
*
*/

STATUS vxbPciConfigInByte
    (
    VXB_DEVICE_ID busCtrlID,
    int	busNo,    /* bus number */
    int	deviceNo, /* device number */
    int	funcNo,	  /* function number */
    int	offset,	  /* offset into the configuration space */
    UINT8 * pData /* data read from the offset */
    )
    {
    return (vxbPciCfgReadInternal (busCtrlID,
				   (UINT8) busNo,
				   (UINT8) deviceNo,
				   (UINT8) funcNo,
				   (UINT32) offset,
				   1,
				   (void *) pData));
    }

/*******************************************************************************
*
* vxbPciConfigInWord - read one word from the PCI configuration space
*
* This routine reads one word from the PCI configuration space
*
* RETURNS: OK, or ERROR if this library is not initialized
*
* ERRNO
*
*/

STATUS vxbPciConfigInWord
    (
    VXB_DEVICE_ID busCtrlID,
    int	busNo,      /* bus number */
    int	deviceNo,   /* device number */
    int	funcNo,     /* function number */
    int	offset,     /* offset into the configuration space */
    UINT16 * pData  /* data read from the offset */
    )
    {
    return (vxbPciCfgReadInternal (busCtrlID,
				   (UINT8) busNo,
				   (UINT8) deviceNo,
				   (UINT8) funcNo,
				   (UINT32) offset,
				   2,
				   (void *) pData));
    }

/*******************************************************************************
*
* vxbPciConfigInLong - read one longword from the PCI configuration space
*
* This routine reads one longword from the PCI configuration space
*
* RETURNS: OK, or ERROR if this library is not initialized
*
* ERRNO
*
*/

STATUS vxbPciConfigInLong
    (
    VXB_DEVICE_ID  busCtrlID,
    int	busNo,     /* bus number */
    int	deviceNo,  /* device number */
    int	funcNo,    /* function number */
    int	offset,    /* offset into the configuration space */
    UINT32 * pData /* data read from the offset */
    )
    {
    return (vxbPciCfgReadInternal (busCtrlID,
				   (UINT8) busNo,
				   (UINT8) deviceNo,
				   (UINT8) funcNo,
				   (UINT32) offset,
				   4,
				   (void *) pData));
    }

/*******************************************************************************
*
* vxbPciConfigOutByte - write one byte to the PCI configuration space
*
* This routine writes one byte to the PCI configuration space.
*
* RETURNS: OK, or ERROR if this library is not initialized
*
* ERRNO
*
*/

STATUS vxbPciConfigOutByte
    (
    VXB_DEVICE_ID busCtrlID,
    int	busNo,    /* bus number */
    int	deviceNo, /* device number */
    int	funcNo,   /* function number */
    int	offset,   /* offset into the configuration space */
    UINT8 data    /* data written to the offset */
    )
    {
    return (vxbPciCfgWriteInternal (busCtrlID,
				    (UINT8) busNo,
				    (UINT8) deviceNo,
				    (UINT8) funcNo,
				    (UINT32) offset,
				    1,
				    (UINT32) data));
    }

/*******************************************************************************
*
* vxbPciConfigOutWord - write one 16-bit word to the PCI configuration space
*
* This routine writes one 16-bit word to the PCI configuration space.
*
* RETURNS: OK, or ERROR if this library is not initialized
*
* ERRNO
*
*/

STATUS vxbPciConfigOutWord
    (
    VXB_DEVICE_ID busCtrlID,
    int	busNo,    /* bus number */
    int	deviceNo, /* device number */
    int	funcNo,   /* function number */
    int	offset,   /* offset into the configuration space */
    UINT16 data   /* data written to the offset */
    )
    {
    return (vxbPciCfgWriteInternal (busCtrlID,
				    (UINT8) busNo,
				    (UINT8) deviceNo,
				    (UINT8) funcNo,
				    (UINT32) offset,
				    2,
				    (UINT32) data));
    }

/*******************************************************************************
*
* vxbPciConfigOutLong - write one longword to the PCI configuration space
*
* This routine writes one longword to the PCI configuration space.
*
* RETURNS: OK, or ERROR if this library is not initialized
*
* ERRNO
*
*/

STATUS vxbPciConfigOutLong
    (
    VXB_DEVICE_ID busCtrlID,
    int	busNo,    /* bus number */
    int	deviceNo, /* device number */
    int	funcNo,   /* function number */
    int	offset,   /* offset into the configuration space */
    UINT32 data   /* data written to the offset */
    )
    {
    return (vxbPciCfgWriteInternal (busCtrlID,
				    (UINT8) busNo,
				    (UINT8) deviceNo,
				    (UINT8) funcNo,
				    (UINT32) offset,
				    4,
				    data));
    }

/*****************************************************************************
*
* vxbPciConfigModifyLong - Perform a masked longword register update
*
* This function writes a field into a PCI configuration header without
* altering any bits not present in the field.  It does this by first
* doing a PCI configuration read (into a temporary location) of the PCI
* configuration header word which contains the field to be altered.
* It then alters the bits in the temporary location to match the desired
* value of the field.  It then writes back the temporary location with
* a configuration write.  All configuration accesses are long and the
* field to alter is specified by the "1" bits in the 'bitMask' parameter.
*
* Be careful to using vxbPciConfigModifyLong for updating the Command and
* status register.  The status bits must be written back as zeroes, else
* they will be cleared.  Proper use involves including the status bits in
* the mask value, but setting their value to zero in the data value.
*
* The following example will set the PCI_CMD_IO_ENABLE bit without clearing any
* status bits.  The macro PCI_CMD_MASK includes all the status bits as
* part of the mask.  The fact that PCI_CMD_MASTER doesn't include these bits,
* causes them to be written back as zeroes, therefore they aren't cleared.
*
* \cs
*    vxbPciConfigModifyLong (b,d,f,PCI_CFG_COMMAND,
*                 (PCI_CMD_MASK | PCI_CMD_IO_ENABLE), PCI_CMD_IO_ENABLE);
* \ce
*
* Use of explicit longword read and write operations for dealing with any
* register containing "write 1 to clear" bits is sound policy.
*
* RETURNS: OK if operation succeeds, ERROR if operation fails.
*
* ERRNO
*
*/

STATUS vxbPciConfigModifyLong
    (
    VXB_DEVICE_ID       busCtrlID,
    int busNo,          /* bus number */
    int deviceNo,       /* device number */
    int funcNo,         /* function number */
    int offset,         /* offset into the configuration space */
    UINT32 bitMask,     /* Mask which defines field to alter */
    UINT32 data         /* data written to the offset */
    )
    {
    UINT32 temp;
    STATUS stat;
    int key;

    /* check for library initialization or unaligned access */
    if(busCtrlID == NULL)
	return(ERROR);

    key = intCpuLock ();

    stat = vxbPciConfigInLong (busCtrlID,busNo, deviceNo, funcNo, offset, &temp);

    if (stat == OK)
        {
        temp = (temp & ~bitMask) | (data & bitMask);
        stat = vxbPciConfigOutLong (busCtrlID, busNo, deviceNo, funcNo, offset, temp);
        }

    intCpuUnlock (key);

    return (stat);
    }


/*****************************************************************************
*
* vxbPciConfigModifyWord - Perform a masked longword register update
*
* This function writes a field into a PCI configuration header without
* altering any bits not present in the field.  It does this by first
* doing a PCI configuration read (into a temporary location) of the PCI
* configuration header word which contains the field to be altered.
* It then alters the bits in the temporary location to match the desired
* value of the field.  It then writes back the temporary location with
* a configuration write.  All configuration accesses are long and the
* field to alter is specified by the "1" bits in the 'bitMask' parameter.
*
* Do not use this routine to modify any register that contains 'write 1
* to clear' type of status bits in the same longword.  This specifically
* applies to the command register.  Modify byte operations could potentially
* be implemented as longword operations with bit shifting and masking.  This
* could have the effect of clearing status bits in registers that aren't being
* updated.  Use vxbPciConfigInLong and vxbPciConfigOutLong, or pciModifyLong,
* to read and update the entire longword.
*
* RETURNS: OK if operation succeeds.  ERROR if operation fails.
*
* ERRNO
*
*/

STATUS vxbPciConfigModifyWord
    (
    VXB_DEVICE_ID busCtrlID,
    int busNo,          /* bus number */
    int deviceNo,       /* device number */
    int funcNo,         /* function number */
    int offset,         /* offset into the configuration space */
    UINT16 bitMask,     /* Mask which defines field to alter */
    UINT16 data         /* data written to the offset */
    )
    {
    UINT16 temp;
    STATUS stat;
    int key;

    if(busCtrlID == NULL)
	return(ERROR);

    /* check for library initialization or unaligned access */


    key = intCpuLock ();

    stat = vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, offset, &temp);

    if (stat == OK)
        {
        temp = (temp & ~bitMask) | (data & bitMask);
        stat = vxbPciConfigOutWord (busCtrlID, busNo, deviceNo, funcNo, offset, temp);
        }

    intCpuUnlock (key);

    return (stat);
    }



/*****************************************************************************
*
* vxbPciConfigModifyByte - Perform a masked longword register update
*
* This function writes a field into a PCI configuration header without
* altering any bits not present in the field.  It does this by first
* doing a PCI configuration read (into a temporary location) of the PCI
* configuration header word which contains the field to be altered.
* It then alters the bits in the temporary location to match the desired
* value of the field.  It then writes back the temporary location with
* a configuration write.  All configuration accesses are long and the
* field to alter is specified by the "1" bits in the 'bitMask' parameter.
*
* Do not use this routine to modify any register that contains 'write 1
* to clear' type of status bits in the same longword.  This specifically
* applies to the command register.  Modify byte operations could potentially
* be implemented as longword operations with bit shifting and masking.  This
* could have the effect of clearing status bits in registers that aren't being
* updated.  Use vxbPciConfigInLong and vxbPciConfigOutLong, or pciModifyLong,
* to read and update the entire longword.
*
* RETURNS: OK if operation succeeds, ERROR if operation fails.
*
* ERRNO
*
*/

STATUS vxbPciConfigModifyByte
    (
    VXB_DEVICE_ID       busCtrlID,
    int busNo,          /* bus number */
    int deviceNo,       /* device number */
    int funcNo,         /* function number */
    int offset,         /* offset into the configuration space */
    UINT8 bitMask,      /* Mask which defines field to alter */
    UINT8 data          /* data written to the offset */
    )
    {
    UINT8 temp;
    STATUS stat;
    int key;

    if(busCtrlID == NULL)
	return(ERROR);

    key = intCpuLock ();

    stat = vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, offset, &temp);

    if (stat == OK)
        {
        temp = (temp & ~bitMask) | (data & bitMask);
        stat = vxbPciConfigOutByte (busCtrlID, busNo, deviceNo, funcNo, offset, temp);
        }

    intCpuUnlock (key);

    return(stat);

    }

/*******************************************************************************
*
* pciSpecialCycle - generate a special cycle with a message
*
* This routine generates a special cycle with a message.
*
* RETURNS: OK, or ERROR if this library is not initialized
*
* ERRNO
*
*/

STATUS vxbPciSpecialCycle
    (
    VXB_DEVICE_ID  busCtrlID,
    int	busNo,     /* bus number */
    UINT32 message /* data driven onto AD[31:0] */
    )
    {
    return (OK);
    }
#endif /* USE_PCI_SIMULATOR */

/**** AutoConfigStart */
#ifdef INCLUDE_PCI_BUS_AUTOCONF

/*********************************************************************
*
* vxbPciBusAlloc - allocate bus number for bridge
*
* RETURNS: int
*
* ERRNO
*/
LOCAL int vxbPciBusAlloc
    (
    int priBus
    )
    {
    int bus;

    if(vxbPciBusAllocFirstTime)
	{
	vxbPciBusAllocFirstTime= FALSE;
	bzero((char*)vxbPciBusArray,sizeof(vxbPciBusArray));
	}

    for (bus=priBus+1;bus<256;bus++)
	{
	if(vxbPciBusArray[bus]==FALSE)
	    {
	    vxbPciBusArray[bus]=TRUE;
	    return(bus);
	    }
	}

    return(0xff);
    }

/****************************************************************
*
* vxbPciAutoConfig - set standard parameters & initialize PCI
*
*  This function reads PCI parameters from a PCI bridge
*  controller's HCF record in the BSP-provided hwconf.c file.
*  It calls the appropriate vxbPciAutoConfigLib routines to
*  initialize the PCI bus.
*/

STATUS vxbPciAutoConfig
    (
    VXB_DEVICE_ID busCtrlID
    )
    {
    HCF_DEVICE * pHcf;
    UINT32       param;
    void *       pParam;
    void *       pCookie;
    STATUS       stat;

    if(busCtrlID == NULL)
	return(ERROR);

    pHcf = hcfDeviceGet(busCtrlID);

    if ( pHcf == NULL )
	{
        return(ERROR);
	}

    pCookie = vxbPciAutoConfigLibInit(NULL);

    if ( pCookie == NULL )
        return(ERROR);


    globalBusCtrlID = busCtrlID;

    vxbPciBusAllocFirstTime=TRUE;

    memset(vxbPciAutoIntRoutingTable,0xff,sizeof(UCHAR)*4);

    pParam = NULL;
    pParam = (void*)busCtrlID;
    vxbPciAutoCfgCtl(pCookie, PCI_VXB_BUSID, pParam);

    pParam = NULL;
    /*
     * resourceDesc {
     * The mem32Addr resource specifies the base address
     * of the 32-bit memory space. }
     */
    stat = devResourceGet(pHcf, "mem32Addr", HCF_RES_ADDR, &pParam);
    vxbPciAutoCfgCtl(pCookie, PCI_MEM32_LOC_SET, pParam);

    param = 0;
    /*
     * resourceDesc {
     * The mem32Size resource specifies the size
     * of the 32-bit memory space. }
     */
    stat = devResourceGet(pHcf, "mem32Size", HCF_RES_INT, (void *)&param);
    vxbPciAutoCfgCtl(pCookie, PCI_MEM32_SIZE_SET, (void *)param);

    pParam = NULL;
    /*
     * resourceDesc {
     * The memIo32Addr resource specifies the base address
     * of the 32-bit non-prefetchable memory space. }
     */
    stat = devResourceGet(pHcf, "memIo32Addr", HCF_RES_ADDR, &pParam);
    vxbPciAutoCfgCtl(pCookie, PCI_MEMIO32_LOC_SET, pParam);

    param = 0;
    /*
     * resourceDesc {
     * The memIo32Size resource specifies the size
     * of the 32-bit non-prefetchable memory space. }
     */
    stat = devResourceGet(pHcf, "memIo32Size", HCF_RES_INT, (void *)&param);
    vxbPciAutoCfgCtl(pCookie, PCI_MEMIO32_SIZE_SET, (void *)param);

    pParam = NULL;
    /*
     * resourceDesc {
     * The io32Addr resource specifies the base address
     * of the 32-bit I/O space. }
     */
    stat = devResourceGet(pHcf, "io32Addr", HCF_RES_ADDR, &pParam);
    vxbPciAutoCfgCtl(pCookie, PCI_IO32_LOC_SET, pParam);

    param = 0;
    /*
     * resourceDesc {
     * The io32Size resource specifies the size
     * of the 32-bit I/O space. }
     */
    stat = devResourceGet(pHcf, "io32Size", HCF_RES_INT, (void *)&param);
    vxbPciAutoCfgCtl(pCookie, PCI_IO32_SIZE_SET, (void *)param);

    pParam = NULL;
    /*
     * resourceDesc {
     * The io16Addr resource specifies the base address
     * of the 16-bit I/O space. }
     */
    stat = devResourceGet(pHcf, "io16Addr", HCF_RES_ADDR, &pParam);
    vxbPciAutoCfgCtl(pCookie, PCI_IO16_LOC_SET, pParam);

    param = 0;
    /*
     * resourceDesc {
     * The io16Size resource specifies the size
     * of the 16-bit I/O space. }
     */
    stat = devResourceGet(pHcf, "io16Size", HCF_RES_INT, (void *)&param);
    vxbPciAutoCfgCtl(pCookie, PCI_IO16_SIZE_SET, (void *)param);

    param = 0;
    /*
     * resourceDesc {
     * The maxBusSet resource specifies the maximum
     * number of busses to be supported. }
     */
    stat = devResourceGet(pHcf, "maxBusSet", HCF_RES_INT, (void *)&param);
    vxbPciAutoCfgCtl(pCookie, PCI_MAX_BUS_SET, (void *)param);

    param = 0;
    /*
     * resourceDesc {
     * The cacheSize resource specifies the PCI cache
     * line size. }
     */
    stat = devResourceGet(pHcf, "cacheSize", HCF_RES_INT, (void *)&param);
    vxbPciAutoCfgCtl(pCookie, PCI_CACHE_SIZE_SET, (void *)param);

    param = 0;
    /*
     * resourceDesc {
     * The maxLatAllSet resource specifies a constant
     * maximum latency value for all cards, if no
     * function has been specified with maxLatencyFuncSet. }
     */
    stat = devResourceGet(pHcf, "maxLatAllSet", HCF_RES_INT, (void *)&param);
    vxbPciAutoCfgCtl(pCookie, PCI_MAX_LAT_ALL_SET, (void *)param);

    param = 0;
    /*
     * resourceDesc {
     * The autoIntRouteSet resource enables or disables
     * automatic interrupt routing across bridges
     * during the autoconfig process. }
     */
    stat = devResourceGet(pHcf, "autoIntRouteSet", HCF_RES_INT, (void *)&param);
    vxbPciAutoCfgCtl(pCookie, PCI_AUTO_INT_ROUTE_SET, (void *)param);

    pParam = NULL;
    /*
     * resourceDesc {
     * The msgLogSet resource specifies a routine which is called to print
     * warning or error messages from vxbPciAutoConfigLib if logMsg() has
     * not been initialized at the time vxbPciAutoConfigLib is used. The
     * specified routine must accept arguments in the same format as logMsg(),
     * but it does not necessarily need to print the actual message. }
     */
    stat = devResourceGet(pHcf, "msgLogSet", HCF_RES_ADDR, &pParam);
    vxbPciAutoCfgCtl(pCookie, PCI_MSG_LOG_SET, pParam);

    pParam = NULL;
    /*
     * resourceDesc {
     * The maxLatencyFuncSet resource specifies a routine which is
     * called for each function present on the bus
     * when discovery takes place.  The routine must accept four
     * arguments, specifying bus, device, function, and a user-supplied
     * argument of type void *.  See PCI_MAX_LATENCY_ARG_SET.  The routine
     * should return a UINT8 value, which will be put into the MAX_LAT
     * field of the header structure.  The user supplied routine must
     * return a valid value each time it is called. There is no mechanism
     * for any ERROR condition, but a default value can be returned in
     * such a case. Default = NULL. }
     */
    stat = devResourceGet(pHcf, "maxLatencyFuncSet", HCF_RES_ADDR, &pParam);
    vxbPciAutoCfgCtl(pCookie, PCI_MAX_LATENCY_FUNC_SET, pParam);

    pParam = NULL;
    /*
     * resourceDesc {
     * The maxLatencyArgSet resource specifies the fourth argument to be
     * passed when the routine specified in PCI_MAX_LATENCY_FUNC_SET is
     * called. }
     */
    stat = devResourceGet(pHcf, "maxLatencyArgSet", HCF_RES_ADDR, &pParam);
    vxbPciAutoCfgCtl(pCookie, PCI_MAX_LATENCY_ARG_SET, pParam);

    pParam = NULL;
    /*
     * resourceDesc {
     * The includeFuncSet resource specifies an optional routine to be called
     * by PCI AutoConfig for each and every function encountered
     * in the scan phase, to determine whether each function
     * should be auto-configured.  The routine takes as input both the
     * bus-device-function tuple, and a 32-bit quantity containing both
     * the PCI vendorID and deviceID of the function.  The BSP
     * developer may use any combination of the input data to ascertain
     * whether a device is to be excluded from the autoconfig process.
     * The exclusion routine then returns ERROR if a device is to be
     * excluded, and OK if a device is to be included in the
     * autoconfiguration process. }
     */
    stat = devResourceGet(pHcf, "includeFuncSet", HCF_RES_ADDR, &pParam);
    vxbPciAutoCfgCtl(pCookie, PCI_INCLUDE_FUNC_SET, pParam);

    pParam = NULL;
    /*
     * resourceDesc {
     * The intAssignFuncSet resource specifies an optional routine which can
     * be used to assign specific interrupt level values to
     * particular functions.  The routine takes as input both the
     * bus-device-function tuple, and an 8-bit quantity containing the
     * contents of the interrupt Pin register from the PCI configuration
     * header of the device under consideration.  The interrupt pin
     * register specifies which of the four PCI Interrupt request lines
     * available are connected.  This routine may use any combination
     * of these data to ascertain the interrupt level.  This value is
     * returned from the function, and  is programmed into the interrupt
     * line register of the function's PCI configuration header. }
     */
    stat = devResourceGet(pHcf, "intAssignFuncSet", HCF_RES_ADDR, &pParam);
    vxbPciAutoCfgCtl(pCookie, PCI_INT_ASSIGN_FUNC_SET, pParam);

    pParam = NULL;
    /*
     * resourceDesc {
     * The bridgePreConfigFuncSet resource specifies an optional bridge
     * pre-configuration pass initialization routine which is
     * provided so that the BSP Developer can initialize a bridge device
     * prior to the configuration pass on the bus that the bridge
     * implements.  This optional user-specified routine takes as
     * input both the bus-device-function tuple, and a 32-bit quantity
     * containing both the PCI deviceID and vendorID of the device.
     * This routine may use any combination of these input data to
     * ascertain any special initialization requirements of a particular
     * type of bridge at a specified geographic location. }
     */
    stat = devResourceGet(pHcf, "bridgePreConfigFuncSet", HCF_RES_ADDR, &pParam);
    vxbPciAutoCfgCtl(pCookie, PCI_BRIDGE_PRE_CONFIG_FUNC_SET, pParam);

    pParam = NULL;
    /*
     * resourceDesc {
     * The bridgePostConfigFuncSet resource specifies an optional bridge
     * post-configuration pass initialization routine which is
     * provided so that the BSP Developer can initialize a bridge device
     * after the configuration pass on the bus that the bridge
     * implements.  This optional user-specified routine takes as
     * input both the bus-device-function tuple, and a 32-bit quantity
     * containing both the PCI deviceID and vendorID of the device.
     * This routine may use any combination of these input data to
     * ascertain any special initialization requirements of a particular
     * type of bridge at a specified geographic location. }
     */
    stat = devResourceGet(pHcf, "bridgePostConfigFuncSet", HCF_RES_ADDR, &pParam);
    vxbPciAutoCfgCtl(pCookie, PCI_BRIDGE_POST_CONFIG_FUNC_SET, pParam);

    pParam = NULL;
    /*
     * resourceDesc {
     * The rollcallFuncSet resource specifies an optional roll call
     * routine, to delay PCI initialization until all devices
     * have had time to initialize.  If a roll call routine has
     * been configured, before any configuration is actually done,
     * the roll call routine is called repeatedly until it returns
     * TRUE.  A return value of TRUE indicates that all of the
     * PCI devices which are going to appear on the busses have
     * appeared and we can proceed with PCI bus configuration. }
     */
    stat = devResourceGet(pHcf, "rollcallFuncSet", HCF_RES_ADDR, &pParam);
    vxbPciAutoCfgCtl(pCookie, PCI_ROLLCALL_FUNC_SET, pParam);

    stat = vxbPciAutoCfg(pCookie);

    return(OK);
    }

/**********************************************************************
*
* vxbPciAutoConfigLibInit - initialize PCI autoconfig library
*
* vxbPciAutoConfigLib initialization function.
*
* RETURNS: A cookie for use by subsequent vxbPciAutoConfigLib function
* calls.
*
* ERRNO
*
*/

void * vxbPciAutoConfigLibInit
    (
    void * pArg				/* reserved for future use */
    )
    {
    PCI_AUTO_CONFIG_OPTS* pOpts;

    pOpts = (PCI_AUTO_CONFIG_OPTS*)hwMemAlloc(sizeof(PCI_AUTO_CONFIG_OPTS));

    if(pOpts == NULL)
	return (NULL);

    bcopy((char*)&defaultPciAutoConfigOpts,(char*)pOpts,sizeof(PCI_AUTO_CONFIG_OPTS));


    pOpts->pciConfigInit = TRUE;

    return((void *)pOpts);
    }

/******************************************************************************
*
* vxbPciAutoCfg - Automatically configure all nonexcluded PCI headers
*
* Top level function in the PCI configuration process.
*
* CALLING SEQUENCE:
* \cs
* pCookie = vxbPciAutoConfigLibInit(NULL);
* vxbPciAutoCfgCtl(pCookie, COMMAND, VALUE);
*  ...
* vxbPciAutoCfgCtl(pCookie, COMMAND, VALUE);
* vxbPciAutoCfg(pCookie);
* \ce
*
* For ease in converting from the old interface to the new one,
* a vxbPciAutoCfgCtl() command PCI_PSYSTEM_STRUCT_COPY has been
* implemented.  This can be used just like any other vxbPciAutoCfgCtl()
* command, and it initializes all the values in pSystem.  If
* used, it should be the first call to vxbPciAutoCfgCtl().
*
* For a description of the COMMANDs and VALUEs to vxbPciAutoCfgCtl(), see
* the vxbPciAutoCfgCtl() documentation.
*
* For all nonexcluded PCI functions on all PCI bridges, this routine
* automatically configures the PCI configuration headers for PCI
* devices and subbridges.  The fields that are programmed are:
*
* \ml
* \m 1.
* Status register.
* \m 2.
* Command Register.
* \m 3.
* Latency timer.
* \m 4.
* Cache Line size.
* \m 5.
* Memory and/or I/O base address and limit registers.
* \m 6.
* Primary, secondary, subordinate bus number (for PCI-PCI bridges).
* \m 7.
* Expansion ROM disable.
* \m 8.
* Interrupt Line.
* \me
*
* ALGORITHM
* Probe PCI config space and create a list of available PCI functions.
* Call device exclusion function, if registered, to exclude/include device.
* Disable all devices before we initialize any.
* Allocate and assign PCI space to each device.
* Calculate and set interrupt line value.
* Initialize and enable each device.
*
* RETURNS: N/A
*
* ERRNO
*
*/

STATUS vxbPciAutoCfg
    (
    void *pCookie		/* cookie returned by vxbPciAutoConfigLibInit() */
    )
    {
    PCI_AUTO_CONFIG_OPTS *pSystem;

    pSystem = (PCI_AUTO_CONFIG_OPTS *)pCookie;

    if ( pSystem->pciConfigInit != TRUE )
	{
	return(ERROR);
	}

    vxbPciAutoCfgFunc(pCookie);


    /* check FBB Enable & activate if appropriate */
    if ( pSystem->pciFBBEnable == TRUE )
	{
	if ( vxbPciAutoConfigFBBEnable(pSystem) == OK )
	    {
    	    pSystem->pciFBBActive = TRUE;
	    }
	else
	    {
	    PCI_AUTO_DEBUG_MSG("vxbPciAutoCfg(): fast back-to-back NOT enabled\n",
			1,2,3,4,5,6);
	    }
	}


    return(OK);
    }

/**********************************************************************
*
* vxbPciAutoCfgCtl - set or get vxbPciAutoConfigLib options
*
* vxbPciAutoCfgCtl() can be considered analogous to ioctl()
* calls: the call takes arguments of (1) a pCookie, returned by
* vxbPciAutoConfigLibInit().  (2) A command,
* macros for which are defined in vxbPciAutoConfigLib.h.  And, (3)
* an argument, the type of which depends on the specific command,
* but will always fit in a pointer variable.  Currently, only
* globally effective commands are implemented.
*
* The commands available are:
*
* \is
* \i 'PCI_FBB_ENABLE - BOOL * pArg'
* \i 'PCI_FBB_DISABLE - void'
* \i 'PCI_FBB_UPDATE - BOOL * pArg'
* \i 'PCI_FBB_STATUS_GET - BOOL * pArg'
* Enable and disable the functions which check Fast Back To Back
* functionality.  PCI_FBB_UPDATE is for use with dynamic/HA
* applications.  It first disables FBB on all functions, then enables
* FBB on all functions, if appropriate.  In HA applications, it should
* be called any time a card is added or removed.  The BOOL pointed to
* by pArg for PCI_FBB_ENABLE and PCI_FBB_UPDATE is set to TRUE if all
* cards allow FBB functionality and FALSE if either any card does not
* allow FBB functionality or if FBB is disabled.  The BOOL pointed to
* by pArg for PCI_FBB_STATUS_GET is set to TRUE if PCI_FBB_ENABLE has
* been called and FBB is enabled, even if FBB is not activated on any
* card.  It is set to FALSE otherwise.
*
* NOTE: In the current implementation, FBB is enabled or disabled on
* the entire bus.  If any device anywhere on the bus cannot support
* FBB, then it is not enabled, even if specific sub-busses
* could support it.
*
* \i 'PCI_MAX_LATENCY_FUNC_SET - FUNCPTR * pArg'
* This routine is called for each function present on the bus
* when discovery takes place.  The routine must accept four
* arguments, specifying bus, device, function, and a user-supplied
* argument of type void *.  See PCI_MAX_LATENCY_ARG_SET.  The routine
* should return a UINT8 value, which will be put into the MAX_LAT
* field of the header structure.  The user supplied routine must
* return a valid value each time it is called. There is no mechanism
* for any ERROR condition, but a default value can be returned in
* such a case. Default = NULL.
*
* \i 'PCI_MAX_LATENCY_ARG_SET - void * pArg'
* When the routine specified in PCI_MAX_LATENCY_FUNC_SET is called,
* this will be passed to it as the fourth argument.
*
* \i 'PCI_MAX_LAT_ALL_SET - int pArg'
* Specifies a constant max latency value for all cards, if no
* function has been specified with PCI_MAX_LATENCY_FUNC_SET..
*
* \i 'PCI_MAX_LAT_ALL_GET - UINT * pArg'
* Retrieves the value of max latency for all cards, if no function
* has been specified with PCI_MAX_LATENCY_FUNC_SET. Otherwise, the
* integer pointed to by pArg is set to the value 0xffffffff.
*
* \i 'PCI_MSG_LOG_SET - FUNCPTR * pArg'
* The argument specifies a routine which is called to print warning
* or error messages from vxbPciAutoConfigLib if logMsg() has not been
* initialized at the time vxbPciAutoConfigLib is used. The specified
* routine must accept arguments in the same format as logMsg(), but
* it does not necessarily need to print the actual message. An
* example of this routine is presented below, which saves the message
* into a safe memory space and turns on an LED. This command is useful
* for BSPs which call vxbPciAutoCfg() before message logging is enabled.
* Note that after logMsg() is configured, output goes to logMsg() even
* if this command has been called. Default = NULL.
*
* \cs
* /@ sample PCI_MSG_LOG_SET function @/
* int pciLogMsg(char *fmt,int a1,int a2,int a3,int a4,int a5,int a6)
*     {
*     int charsPrinted;
*
*     sysLedOn(4);
*     charsPrinted = sprintf (sysExcMsg, fmt, a1, a2, a3, a4, a5, a6);
*     sysExcMsg += charsPrinted;
*     return (charsPrinted);
*     }
* \ce
*
* \i 'PCI_MAX_BUS_GET - int * pArg'
* During autoconfiguration, the library maintains a counter with
* the highest numbered bus. This can be retrieved by
* \cs
* vxbPciAutoCfgCtl(pCookie, PCI_MAX_BUS_GET, &maxBus)
* \ce
*
* \i 'PCI_CACHE_SIZE_SET - int pArg'
* Sets the pci cache line size to the specified value.  See
* CONFIGURATION SPACE PARAMETERS in the vxbPciAutoConfigLib
* documentation for more details.
*
* \i 'PCI_CACHE_SIZE_GET - int * pArg'
* Retrieves the value of the pci cache line size.
*
* \i 'PCI_AUTO_INT_ROUTE_SET - BOOL pArg'
* Enables or disables automatic interrupt routing across bridges
* during the autoconfig process.  See "INTERRUPT ROUTING ACROSS
* PCI-TO-PCI BRIDGES" in the vxbPciAutoConfigLib documentation for more
* details.
*
* \i 'PCI_AUTO_INT_ROUTE_GET - BOOL * pArg'
* Retrieves the status of automatic interrupt routing.
*
* \i 'PCI_MEM32_LOC_SET - UINT32 pArg'
* Sets the base address of the PCI 32-bit memory space.  Normally,
* this is given by the BSP constant PCI_MEM_ADRS.
*
* \i 'PCI_MEM32_SIZE_SET - UINT32 pArg'
* Sets the maximum size to use for the PCI 32-bit memory space.
* Normally, this is given by the BSP constant PCI_MEM_SIZE.
*
* \i 'PCI_MEM32_SIZE_GET - UINT32 * pArg'
* After autoconfiguration has been completed, this retrieves
* the actual amount of space which has been used for the
* PCI 32-bit memory space.
*
* \i 'PCI_MEMIO32_LOC_SET - UINT32 pArg'
* Sets the base address of the PCI 32-bit non-prefetch memory space.
* Normally, this is given by the BSP constant PCI_MEMIO_ADRS.
*
* \i 'PCI_MEMIO32_SIZE_SET - UINT32 pArg'
* Sets the maximum size to use for the PCI 32-bit non-prefetch memory
* space.  Normally, this is given by the BSP constant
* PCI_MEMIO_SIZE.
*
* \i 'PCI_MEMIO32_SIZE_GET - UINT32 * pArg'
* After autoconfiguration has been completed, this retrieves
* the actual amount of space which has been used for the PCI
* 32-bit non-prefetch memory space.
*
* \i 'PCI_IO32_LOC_SET - UINT32 pArg'
* Sets the base address of the PCI 32-bit I/O space.
* Normally, this is given by the BSP constant PCI_IO_ADRS.
*
* \i 'PCI_IO32_SIZE_SET - UINT32 pArg'
* Sets the maximum size to use for the PCI 32-bit I/O space.
* Normally, this is given by the BSP constant PCI_IO_SIZE.
*
* \i 'PCI_IO32_SIZE_GET - UINT32 * pArg'
* After autoconfiguration has been completed, this retrieves
* the actual amount of space which has been used for the PCI
* 32-bit I/O space.
*
* \i 'PCI_IO16_LOC_SET - UINT32 pArg'
* Sets the base address of the PCI 16-bit I/O space.
* Normally, this is given by the BSP constant PCI_ISA_IO_ADRS
*
* \i 'PCI_IO16_SIZE_SET - UINT32 pArg'
* Sets the maximum size to use for the PCI 16-bit I/O space.
* Normally, this is given by the BSP constant PCI_ISA_IO_SIZE
*
* \i 'PCI_IO16_SIZE_GET - UINT32 * pArg'
* After autoconfiguration has been completed, this retrieves
* the actual amount of space which has been used for the PCI
* 16-bit I/O space.
*
* \i 'PCI_INCLUDE_FUNC_SET - FUNCPTR * pArg'
* The device inclusion routine is specified by assigning a function
* pointer with the PCI_INCLUDE_FUNC_SET vxbPciAutoCfgCtl() command:
* \cs
* vxbPciAutoCfgCtl(pSystem, PCI_INCLUDE_FUNC_SET,sysPciAutoconfigInclude);
* \ce
* This optional user-supplied routine takes as input both the
* bus-device-function tuple, and a 32-bit quantity containing both
* the PCI vendorID and deviceID of the function.  The function
* prototype for this function is shown below:
* \cs
* STATUS sysPciAutoconfigInclude
*     (
*     PCI_AUTO_CONFIG_OPTS *pSys,
*     PCI_LOC *pLoc,
*     UINT devVend
*     );
* \ce
* This optional user-specified routine is called by PCI AutoConfig
* for each and every function encountered in the scan phase.  The BSP
* developer may use any combination of the input data to ascertain
* whether a device is to be excluded from the autoconfig process.
* The exclusion routine then returns ERROR if a device is to be
* excluded, and OK if a device is to be included in the
* autoconfiguration process.
*
* Note that PCI-to-PCI Bridges may not be excluded, regardless of the
* value returned by the BSP device inclusion routine.  The return
* value is ignored for PCI-to-PCI bridges.
*
* The Bridge device will be always be configured with proper primary,
* secondary, and subordinate bus numbers in the device scanning phase
* and proper I/O and Memory aperture settings in the configuration
* phase of autoconfig regardless of the value returned by the BSP
* device inclusion routine.
*
* \i 'PCI_INT_ASSIGN_FUNC_SET - FUNCPTR * pArg'
* The interrupt assignment routine is specified by assigning a
* function pointer with the PCI_INCLUDE_FUNC_SET vxbPciAutoCfgCtl()
* command:
* \cs
* vxbPciAutoCfgCtl(pCookie, PCI_INT_ASSIGN_FUNC_SET, sysPciAutoconfigIntrAssign);
* \ce
* This optional user-specified routine takes as input both the
* bus-device-function tuple, and an 8-bit quantity containing the
* contents of the interrupt Pin register from the PCI configuration
* header of the device under consideration.  The interrupt pin
* register specifies which of the four PCI Interrupt request lines
* available are connected.  The function prototype for this function
* is shown below:
* \cs
* UCHAR sysPciAutoconfigIntrAssign
*     (
*     PCI_AUTO_CONFIG_OPTS *pSys,
*     PCI_LOC *pLoc,
*     UCHAR pin
*     );
* \ce
*
* This routine may use any combination of these data to ascertain the
* interrupt level.  This value is returned from the function, and
* is programmed into the interrupt line register of the
* function's PCI configuration header. In this manner, device drivers
* may subsequently read this register in order to calculate the
* appropriate interrupt vector which to attach an interrupt service
* routine.
*
* \i 'PCI_BRIDGE_PRE_CONFIG_FUNC_SET - FUNCPTR * pArg'
* The bridge pre-configuration pass initialization routine is
* provided so that the BSP Developer can initialize a bridge device
* prior to the configuration pass on the bus that the bridge
* implements.  This routine is specified by calling vxbPciAutoCfgCtl()
* with the PCI_BRIDGE_PRE_CONFIG_FUNC_SET command:
* \cs
* vxbPciAutoCfgCtl(pCookie, PCI_BRIDGE_PRE_CONFIG_FUNC_SET,
*         sysPciAutoconfigPreEnumBridgeInit);
* \ce
* This optional user-specified routine takes as input both the
* bus-device-function tuple, and a 32-bit quantity containing both
* the PCI deviceID and vendorID of the device.  The function prototype
* for this function is shown below:
* \cs
* STATUS sysPciAutoconfigPreEnumBridgeInit
*     (
*     PCI_AUTO_CONFIG_OPTS *pSys,
*     PCI_LOC *pLoc,
*     UINT devVend
*     );
* \ce
* This routine may use any combination of these input data to
* ascertain any special initialization requirements of a particular
* type of bridge at a specified geographic location.
*
* \i 'PCI_BRIDGE_POST_CONFIG_FUNC_SET - FUNCPTR * pArg'
* The bridge post-configuration pass initialization routine is
* provided so that the BSP Developer can initialize the bridge device
* after the bus that the bridge implements has been enumerated.  This
* routine is specified by calling vxbPciAutoCfgCtl() with the
* PCI_BRIDGE_POST_CONFIG_FUNC_SET command
* \cs
* vxbPciAutoCfgCtl(pCookie, PCI_BRIDGE_POST_CONFIG_FUNC_SET,
*         sysPciAutoconfigPostEnumBridgeInit);
* \ce
* This optional user-specified routine takes as input both the
* bus-device-function tuple, and a 32-bit quantity containing both
* the PCI deviceID and vendorID of the device.  The function prototype
* for this function is shown below:
* \cs
* STATUS sysPciAutoconfigPostEnumBridgeInit
*     (
*     PCI_AUTO_CONFIG_OPTS *pSys,
*     PCI_LOC *pLoc,
*     UINT devVend
*     );
* \ce
* This routine may use any combination of these input data to
* ascertain any special initialization requirements of a particular
* type of bridge at a specified geographic location.
*
* \i 'PCI_ROLLCALL_FUNC_SET - FUNCPTR * pArg'
* The specified routine will be configured as a roll call routine.
*
* If a roll call routine has been configured, before any
* configuration is actually done, the roll call routine is called
* repeatedly until it returns TRUE.  A return value of TRUE indicates
* that either (1) the specified number and type of devices named in
* the roll call list have been found during PCI bus enumeration or
* (2) the timeout has expired without finding all of the specified
* number and type of devices.  In either case, it is assumed that all
* of the PCI devices which are going to appear on the busses have
* appeared and we can proceed with PCI bus configuration.
*
* \i 'PCI_TEMP_SPACE_SET - char * pArg'
* This command is not currently implemented.  It allows the user to
* set aside memory for use during vxbPciAutoConfigLib execution, e.g.
* memory set aside using USER_RESERVED_MEM.  After PCI configuration
* has been completed, the memory can be added to the system memory
* pool using memAddToPool().
*
* \i 'PCI_MINIMIZE_RESOURCES'
* This command is not currently implemented.  It specifies that
* vxbPciAutoConfigLib minimize requirements for memory and I/O space.
*
* \i 'PCI_PSYSTEM_STRUCT_COPY - PCI_AUTO_CONFIG_OPTS * pArg'
* This command has been added for ease of converting from the old
* interface to the new one.  This will set each value as specified in
* the pSystem structure.  If the PCI_AUTO_CONFIG_OPTS structure has already
* been filled, the vxbPciAutoConfig(pSystem) call can be changed
* to:
* \cs
* void *pCookie;
* pCookie = vxbPciAutoConfigLibInit(NULL);
* vxbPciAutoCfgCtl(pCookie, PCI_PSYSTEM_STRUCT_COPY, (void *)pSystem);
* vxbPciAutoCfgFunc(pCookie);
* \ce
*
* The fields of the PCI_AUTO_CONFIG_OPTS structure are defined below.  For more
* information about each one, see the paragraphs above and the
* documentation for vxbPciAutoConfigLib.
* \is
* \i 'pciMem32'
* Specifies the 32-bit prefetchable memory pool base address.
*
* \i 'pciMem32Size'
* Specifies the 32-bit prefetchable memory pool size.
*
* \i 'pciMemIo32'
* Specifies the 32-bit non-prefetchable memory pool base address.
*
* \i 'pciMemIo32Size'
* Specifies the 32-bit non-prefetchable memory pool size
*
* \i 'pciIo32'
* Specifies the 32-bit I/O pool base address.
*
* \i 'pciIo32Size'
* Specifies the 32-bit I/O pool size.
*
* \i 'pciIo16'
* Specifies the 16-bit I/O pool base address.
*
* \i 'pciIo16Size'
* Specifies the 16-bit I/O pool size.
*
* \i 'includeRtn'
* Specifies the device inclusion routine.
*
* \i 'intAssignRtn'
* Specifies the interrupt assignment routine.
*
* \i 'autoIntRouting'
* Can be set to TRUE to configure vxbPciAutoConfig() only to
* call the BSP interrupt routing routine for devices on bus number 0.
* Setting autoIntRoutine to FALSE will configure vxbPciAutoConfig()
* to call the BSP interrupt routing routine for every device
* regardless of the bus on which the device resides.
* \ie
* \ie
*
* RETURNS: OK, or ERROR if the command or argument is invalid.
*
* ERRNO
* \is
* \i EINVAL
* if pCookie is not NULL or cmd is not recognized
* \ie
*
*/

STATUS vxbPciAutoCfgCtl
    (
    void *      pCookie,          /* system configuration information */
    int	        cmd,              /* command word */
    void *      pArg              /* argument for the cmd */
    )
    {
    PCI_AUTO_CONFIG_OPTS *        pSystem;
    PCI_AUTO_CONFIG_OPTS *  pOpts;

    if ( pCookie == NULL )
        {
        errnoSet(EINVAL);
        return(ERROR);
        }
    pOpts = (PCI_AUTO_CONFIG_OPTS *)pCookie;

    switch (cmd)
        {
        case PCI_PSYSTEM_STRUCT_COPY:
            /* copy from pSystem to pOpt */
            if ( pArg == NULL )
                {
                errnoSet(EINVAL);
                return(ERROR);
                }
            pSystem = (PCI_AUTO_CONFIG_OPTS *)pArg;
            pOpts->pciMem32 = pSystem->pciMem32;
            pOpts->pciMem32Size = pSystem->pciMem32Size;
            pOpts->pciMemIo32 = pSystem->pciMemIo32;
            pOpts->pciMemIo32Size = pSystem->pciMemIo32Size;
            pOpts->pciIo32 = pSystem->pciIo32;
            pOpts->pciIo32Size = pSystem->pciIo32Size;
            pOpts->pciIo16 = pSystem->pciIo16;
            pOpts->pciIo16Size = pSystem->pciIo16Size;
            pOpts->maxBus = pSystem->maxBus;
            pOpts->cacheSize = pSystem->cacheSize;
            pOpts->maxLatency = pSystem->maxLatency;
            pOpts->autoIntRouting = pSystem->autoIntRouting;
            pOpts->includeRtn = pSystem->includeRtn;
            pOpts->intAssignRtn = pSystem->intAssignRtn;
            pOpts->bridgePreConfigInit = pSystem->bridgePreConfigInit;
            pOpts->bridgePostConfigInit = pSystem->bridgePostConfigInit;
            pOpts->pciRollcallRtn = pSystem->pciRollcallRtn;
            break;

        case PCI_MINIMIZE_RESOURCES:
            pOpts->minimizeResources = (BOOL)pArg;
            break;


        case PCI_FBB_ENABLE:
            pOpts->pciFBBEnable = TRUE;
            pOpts->pciFBBActive = FALSE;
            if ( vxbPciAutoConfigFBBEnable(pOpts) == OK )
                {
                pOpts->pciFBBActive = TRUE;
                }
            if ( pArg != NULL )
                {
                (*(BOOL *)pArg) = pOpts->pciFBBActive;
                }
            break;

        case PCI_FBB_DISABLE:
            if ( ( pOpts->pciFBBEnable == TRUE ) || ( pOpts->pciFBBActive == TRUE ) )
                {
                vxbPciAutoConfigFBBDisable(pOpts);
                pOpts->pciFBBActive = FALSE;
                }
            pOpts->pciFBBEnable = FALSE;
            break;

        case PCI_FBB_UPDATE:
            if ( ( pOpts->pciConfigInit == TRUE ) &&
                 ( pOpts->pciFBBEnable == TRUE ) )
                {
                pOpts->pciFBBActive = vxbPciAutoConfigFBBEnable(pOpts);
                }
            if ( pArg != NULL )
                {
                (*(BOOL *)pArg) = pOpts->pciFBBActive;
                }
            break;


        case PCI_FBB_STATUS_GET:
            (*(BOOL *)pArg) = pOpts->pciFBBEnable;
            break;

        case PCI_MAX_LATENCY_FUNC_SET:
            pOpts->pciMaxLatFunc = (PCI_MAX_LAT_FUNC)pArg;
            break;

        case PCI_MAX_LATENCY_ARG_SET:
            pOpts->pciMaxLatPArg = pArg;
            break;

        case PCI_MSG_LOG_SET:
            pOpts->pciLogMsgFunc = (FUNCPTR)pArg;
            break;

        case PCI_MAX_BUS_SET:
            pOpts->maxBus = (int)pArg;
            break;

        case PCI_MAX_BUS_GET:
            (*(int *)pArg) = pOpts->maxBus;
            break;

        case PCI_CACHE_SIZE_SET:
            pOpts->cacheSize = (int)pArg;
            break;

        case PCI_CACHE_SIZE_GET:
            *(int *)pArg = pOpts->cacheSize;
            break;

        case PCI_MAX_LAT_ALL_SET:
            pOpts->maxLatency = (UINT)pArg;
            break;

        case PCI_MAX_LAT_ALL_GET:
            if ( pOpts->pciMaxLatFunc == NULL )
                *(UINT *)pArg = pOpts->maxLatency;
            else
                *(UINT *)pArg = 0xffffffff;
            break;

        case PCI_AUTO_INT_ROUTE_SET:
            pOpts->autoIntRouting = (BOOL)pArg;
            break;

        case PCI_AUTO_INT_ROUTE_GET:
            *(BOOL *)pArg = pOpts->autoIntRouting;
            break;

        case PCI_MEM32_LOC_SET:
            pOpts->pciMem32 = (UINT)pArg;
            break;

        case PCI_MEM32_SIZE_SET:
            pOpts->pciMem32Size = (UINT)pArg;
            break;

        case PCI_MEM32_SIZE_GET:
            (*(UINT32 *)pArg) = pOpts->pciMem32Used;
            break;

        case PCI_MEMIO32_LOC_SET:
            pOpts->pciMemIo32 = (UINT)pArg;
            break;

        case PCI_MEMIO32_SIZE_SET:
            pOpts->pciMemIo32Size = (UINT)pArg;
            break;

        case PCI_MEMIO32_SIZE_GET:
            *(UINT *)pArg = pOpts->pciMemIo32Used;
            break;

        case PCI_IO32_LOC_SET:
            pOpts->pciIo32 = (UINT)pArg;
            break;

        case PCI_IO32_SIZE_SET:
            pOpts->pciIo32Size = (UINT)pArg;
            break;

        case PCI_IO32_SIZE_GET:
            *(UINT *)pArg = pOpts->pciIo32Used;
            break;

        case PCI_IO16_LOC_SET:
            pOpts->pciIo16 = (UINT)pArg;
            break;

        case PCI_IO16_SIZE_SET:
            pOpts->pciIo16Size = (UINT)pArg;
            break;

        case PCI_IO16_SIZE_GET:
            *(UINT *)pArg = pOpts->pciIo16Used;
            break;

        case PCI_INCLUDE_FUNC_SET:
            pOpts->includeRtn = (VXB_PCI_INCLUDE_FUNC)pArg;
            break;

        case PCI_INT_ASSIGN_FUNC_SET:
            pOpts->intAssignRtn = (VXB_PCI_INT_ASSIGN_FUNC)pArg;
            break;

        case PCI_BRIDGE_PRE_CONFIG_FUNC_SET:
            pOpts->bridgePreConfigInit = (VXB_PCI_BRIDGE_PRE_CONFIG_FUNC)pArg;
            break;

        case PCI_BRIDGE_POST_CONFIG_FUNC_SET:
            pOpts->bridgePostConfigInit = (VXB_PCI_BRIDGE_POST_CONFIG_FUNC)pArg;
            break;

        case PCI_ROLLCALL_FUNC_SET:
            pOpts->pciRollcallRtn = (FUNCPTR)pArg;
            break;

        case PCI_TEMP_SPACE_SET:
            pOpts->pFuncList = ((PCI_MEM_PTR *)pArg)->pMem;
            pOpts->numFuncListEntries = ((PCI_MEM_PTR *)pArg)->memSize / sizeof(PCI_LOC);
            break;
	case PCI_VXB_BUSID:
	    pOpts->busCtrlID = pArg;
	    break;

        default:
            errnoSet(EINVAL);
            return(ERROR);
        }

    return(OK);
    }

#ifdef USE_PCI_SIMULATOR
/****************************************************************
*
* vxbPciAutoConfigListShow - show the devices in the list
*
* This routine shows the devices which are available in the list.
*
* RETURNS: OK, or ERROR if pCookie is not valid.
*
* ERRNO
*/

void vxbPciAutoConfigListShow
    (
    PCI_LOC *pLoc,
    int num
    )
    {
    if ( _func_logMsg == NULL )
        return;
    while ( num >= 0 )
        {
        (*_func_logMsg)("[%d,%d,%d] bar%d 0x%08x in %s space\n",
                           pLoc->bus, pLoc->device, pLoc->function, 4,5,6);
	taskDelay(10);
        pLoc++;
        num--;
        }
    }
#endif /* USE_PCI_SIMULATOR */

/****************************************************************
*
* vxbPciAutoCfgFunc - the actual guts of vxbPciAutoCfg
*
* The functions vxbPciAutoConfig() and vxbPciAutoCfg() are both
* wrapper functions to go around this function.  The actual
* work is done by this function.
*
* ALGORITHM
* Probe PCI config space and create a list of available PCI functions.
* Call device exclusion function, if registered, to exclude/include device.
* Disable all devices before we initialize any.
* Allocate and assign PCI space to each device.
* Calculate and set interrupt line value.
* Initialize and enable each device.
*
* RETURNS: OK, or ERROR if pCookie is not valid.
*
* ERRNO
*
*/

LOCAL STATUS vxbPciAutoCfgFunc
    (
    void *pCookie		/* cookie returned by vxbPciAutoConfigLibInit() */
    )
    {
    PCI_AUTO_CONFIG_OPTS *  pSystem; /* named for backward compatibility */

    PCI_LOC* pPciList;      /* Pointer to PCI include list	*/
    int listSize;       /* Size of PCI include list	*/
    BOOL rollcallSuccess;   /* has pciRollcallRtn() succeeded? */

    /* Input parameter sanity checking */

    if (pCookie == NULL)
        {
        errnoSet(EINVAL);
        return(ERROR);
        }

    pSystem = (PCI_AUTO_CONFIG_OPTS *)pCookie;

    /*
     * If a roll-call routine has been configured, call the roll-call
     * routine repeatedly until it returns TRUE.  A return value
     * of TRUE indicates that either (1) the specified number and
     * type of devices named in the roll call list have been found
     * during PCI bus enumeration or (2) the timeout has expired
     * without finding all of the specified number and type of
     * devices.  In either case, we will assume that all of the PCI
     * devices which are going to appear on the busses have appeared
     * and we can proceed with PCI bus configuration.
     */

    if (pSystem->pciRollcallRtn != NULL)
        {
        rollcallSuccess = FALSE;
        while ( ! rollcallSuccess )
            {

            /*
             * Probe all PCI busses dynamically creating a function list
             * of all functions found.  Excluded devices are skipped over.
             */

            pPciList = vxbPciAutoListCreate (pSystem, &listSize);

            /* Perform roll call function, if we pass, exit the loop */

            if ( (*pSystem->pciRollcallRtn)() == OK )
                rollcallSuccess = TRUE;

#ifdef PCI_AUTO_RECLAIM_LIST
            hwMemFree(pPciList);
#endif /* PCI_AUTO_RECLAIM_LIST */

            if ( rollcallSuccess == TRUE )
                break;
            }
        }

    /*
     * Probe all PCI busses dynamically creating a function list
     * of all functions found.  Excluded devices are skipped over.
     */

    pPciList = vxbPciAutoListCreate (pSystem, &listSize);

    vxbPciAutoFuncConfigAll (pSystem, pPciList, listSize);

    lastPciListSize = listSize;
    pLastPciList = pPciList;

    /* If the function list is malloc'ed at runtime, then release it */

#if defined(PCI_AUTO_RECLAIM_LIST)
#if defined(PCI_AUTO_STATIC_LIST)
#error "Can't do PCI_AUTO_RECLAIM_LIST with PCI_AUTO_STATIC_LIST"
#endif
    hwMemFree(pPciList);

    lastPciListSize = 0;
    pLastPciList = NULL;
#endif

    return(OK);
    }

/******************************************************************************
*
* vxbPciAutoListCreate - probe for all functions and make a PCI probe list
*
* This routine creates a dynamic probelist containing all PCI functions
* located in the PCI configuration hierarchy. In addition, it assigns
* base addresses for the 32-bit prefetchable memory allocation pool,
* the 32-bit non-prefetchable memory allocation pool, the 32-bit I/O
* allocation pool, and the 16-bit I/O allocation pool. When I/O space
* or memory space is actually assigned (not in this routine), the space
* allocation will begin with the base address in each of these categories
* and proceed to higher numbered addresses.
*
* Note that 20-bit memory space is not currently handled as a special case.
*
* RETURNS: A pointer to a newly populated PCI device list.
*
* ERRNO
*
*/

LOCAL PCI_LOC * vxbPciAutoListCreate
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,     /* cookie returned by vxbPciAutoConfigLibInit() */
    int *pListSize			/* size of the PCI_LOC list */
    )
    {
    PCI_LOC  pciLoc;        /* PCI bus/device/function structure */
    PCI_LOC *pPciList;
    PCI_LOC *pRetPciList;
    UCHAR    busAttr;

    /* Initialize the list pointer in preparation for probing */

#if defined(PCI_AUTO_STATIC_LIST)
    pPciList = vxbPciAutoLocalFuncList;
    pRetPciList = pPciList;
#else

    pPciList = (PCI_LOC*)hwMemAlloc(sizeof(PCI_LOC) *  PCI_AUTO_MAX_FUNCTIONS);

    if (pPciList == NULL)
        {
        return NULL;
        }
    pRetPciList = pPciList;
#endif

    lastPciListSize = 0;
    *pListSize = 0;

    /* Begin the scanning process at [0,0,0] */

    pciLoc.bus = (UINT8)0;
    pciLoc.device = (UINT8)0;
    pciLoc.function = (UINT8)0;

    /*
     * Note that the host bridge is assumed to support prefetchable memory
     * (PCI_AUTO_ATTR_BUS_PREFETCH) and only assumed to support 32-bit I/O
     * addressing (PCI_AUTO_ATTR_BUS_4GB_IO) if pciIo32Size is non-zero.
     */


    if (pSystem->pciIo32Size == 0)
        busAttr = PCI_AUTO_ATTR_BUS_PREFETCH;
    else
        busAttr = PCI_AUTO_ATTR_BUS_4GB_IO | PCI_AUTO_ATTR_BUS_PREFETCH;

    PCI_AUTO_DEBUG_MSG("Auto Dev Probe\n",
                           1,2,3,4,5,6);

    vxbPciAutoDevProbe (pSystem, pciLoc.bus, (UCHAR)0,
			busAttr, &pPciList, pListSize);


    return(pRetPciList);
    }

/******************************************************************************
*
* vxbPciAutoDevReset - quiesce a PCI device and reset all writeable status bits
*
* This routine turns 'off' a PCI device by disabling the Memory decoders, I/O
* decoders, and Bus Master capability.  The routine also resets all writeable
* status bits in the status word that follows the command word sequentially
* in PCI config space by performing a longword access.
*
* RETURNS: OK, always.
*
* ERRNO
*
*/

STATUS vxbPciAutoDevReset
    (
    PCI_AUTO_CONFIG_OPTS * pSystem, /* needed for config info */
    PCI_LOC * pPciLoc	/* device to be reset */
    )
    {
    /* Disable the device and reset all writeable status bits */


    vxbPciConfigOutWord (pSystem->busCtrlID,
			 pPciLoc->bus, pPciLoc->device,
			 pPciLoc->function,
			 PCI_CFG_COMMAND, 0x0000);

    vxbPciConfigOutWord (pSystem->busCtrlID,
			 pPciLoc->bus, pPciLoc->device,
			 pPciLoc->function,
			 PCI_CFG_STATUS, 0xffff);
    return OK;
    }

/******************************************************************************
*
* vxbPciAutoBusNumberSet - set the primary, secondary, and subordinate bus number
*
* This routine sets the primary, secondary, and subordinate bus numbers for
* a device that implements the Type 1 PCI Configuration Space Header.
*
* This routine has external visibility to enable it to be used by BSP
* Developers for initialization of PCI Host Bridges that may implement
* registers similar to those found in the Type 1 Header.
*
* RETURNS: OK, always
*
* ERRNO
*
*/

STATUS vxbPciAutoBusNumberSet
    (
    PCI_AUTO_CONFIG_OPTS * pSystem, /* needed for config info */
    PCI_LOC * pPciLoc,		/* device affected */
    UINT primary,		/* primary bus specification */
    UINT secondary,		/* secondary bus specification */
    UINT subordinate		/* subordinate bus specification */
    )
    {
    UINT workvar = 0;   /* Working variable		*/

    workvar = (subordinate << 16) + (secondary << 8) + primary;

    /* longword write */

    vxbPciConfigModifyLong (pSystem->busCtrlID,
			    pPciLoc->bus,
			    pPciLoc->device,
			    pPciLoc->function,
			    PCI_CFG_PRIMARY_BUS,
			    0x00ffffff,
			    workvar);

    return OK;
    }

/******************************************************************************
*
* vxbPciAutoBusProbe - configure a bridge and probe all devices behind it
*
* This routine assigns an initial range of subordinate busses to a
* PCI bridge, searches for functions under this bridge, and then
* updates the range assignment to the correct value.  It calls
* vxbPciAutoDevProbe() which in turn calls this function in a recursive
* manner.  In addition to actually programming the PCI-PCI bridge
* headers with correct bus numbers, the 'pciLoc' list of functions
* is extended as each new PCI function is found.
*
* RETURNS: The subordinate bus number.
*
* ERRNO
*
*/

LOCAL UINT vxbPciAutoBusProbe
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,	/* PCI system information	*/
    UINT priBus,		/* Primary PCI bus		*/
    UINT secBus,		/* Secondary PCI bus		*/
    PCI_LOC*  pPciLoc,		/* PCI address of this bridge	*/
    PCI_LOC** ppPciList,	/* Pointer to next PCI location	*/
				/* entry pointer		*/
    int * pListSize		/* number of PCI_LOC entries    */
    )
    {
    UINT subBus = 0xff; /* Highest subordinate PCI bus	*/
    UCHAR offset = 0;   /* Interrupt routing offset for this bus*/
    /* Disable I/O, Mem, and upstream transactions / reset status bits */

    (void)vxbPciAutoDevReset (pSystem,pPciLoc);

    /* Set the bus numbers, subordinate bus is 0xff */

    (void)vxbPciAutoBusNumberSet (pSystem,pPciLoc, priBus, secBus, 0xff);

    PCI_AUTO_DEBUG_MSG("vxbPciAutoBusProbe: using bridge [%d,%d,%d,0x%02x]\n",
                       (pPciLoc->bus),
                       (pPciLoc->device),
                       (pPciLoc->function),
                       (pPciLoc->attribute),
                       0,
                       0
                      );

    /* Probe all devices on this bus */

    PCI_AUTO_DEBUG_MSG("vxbPciAutoBusProbe: calling vxbPciAutoDevProbe on bus [%d]\n",
                       secBus, 0, 0, 0, 0, 0);

    /*
     * Compute the route offset for this bridge: if this bridge is
     * on bus zero (primary bus = zero) then its contribution is null,
     * otherwise it depends on its location on the bus and on the
     * contribution of all of the upper Pci-To-Pci Bridges.
     */

    pPciLoc->offset += (priBus > 0) ? (pPciLoc->device % 4) : 0;
    offset = pPciLoc->offset;

    PCI_AUTO_DEBUG_MSG("vxbPciAutoBusProbe: int route offset for bridge is [%d]\n",
                       offset, 0, 0, 0, 0, 0);

    subBus = vxbPciAutoDevProbe (pSystem, secBus, offset, (pPciLoc->attribute),
                              ppPciList, pListSize);

    /* Set the range assignment to cover the correct range of busses */

    PCI_AUTO_DEBUG_MSG("vxbPciAutoBusProbe: post-config subordinate bus as [%d]\n",
                       subBus, 0, 0, 0, 0, 0);

    (void)vxbPciAutoBusNumberSet (pSystem,pPciLoc, priBus, secBus, subBus);

    /* Return the highest subordinate bus */

    return subBus;

    }

/******************************************************************************
*
* vxbPciAutoDevProbe - probe all devices on a single PCI bus
*
* This routine probes a single PCI bus and adds each detected PCI function
* to the function list.  In case a PCI-PCI bridge is found, vxbPciAutoBusProbe()
* is called to probe that bus.  vxbPciAutoBusProbe() in turn calls this function
* in a recursive manner until all busses have been probed.
*
* RETURNS: Highest subordinate bus number found during probing process.
*
* ERRNO
*
*/

LOCAL UINT vxbPciAutoDevProbe
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,	/* PCI system info			*/
    UINT bus,			/* current bus number to probe		*/
    UCHAR offset,		/* bridge contrib to int vector xlation */
    UCHAR inheritAttrib,	/* attributes inherited from bridge 	*/
    PCI_LOC **ppPciList,	/* Pointer to next PCI location entry	*/
    int * pListSize		/* Number of PCI_LOC's currently in list*/
    )
    {
    PCI_LOC pciLoc;     /* PCI bus/device/function structure	*/
    UINT16 pciclass;        /* PCI class/subclass contents		*/
    UINT dev_vend;      /* Device/Vendor identifier		*/
    int device;         /* Device location			*/
    int function;       /* Function location			*/
    int subBus;         /* Highest subordinate PCI bus		*/
    UCHAR btemp;        /* Temporary holding area		*/
    UINT temp;

    /* Initialize variables */

    bzero ((char *)&pciLoc, sizeof (PCI_LOC));
    pciLoc.bus = bus;

    PCI_AUTO_DEBUG_MSG("Inside Auto Dev Probe bus 0x%x maxBus 0x%x\n",
		       bus,pSystem->maxBus,3,4,5,6);

    /* This is a workaround where the host bridge secondary bus may be the
     * primary bus. We must probe it to see if no bridge is found. */


    subBus = bus;
    /* if attributes indicate a host bus, then set equal to pciLoc.attrib */
    /* Locate each active function on the current bus */
    pciLoc.bus = subBus;

    for (device = 0; device < PCI_MAX_DEV; device++)
	{
	pciLoc.device = device;

	/* Check each function until an unused one is detected */

	for (function = 0; function < PCI_MAX_FUNC; function++)
	    {
	    pciLoc.function = function;

	    /* Check for a valid device/vendor number */

	    vxbPciConfigInLong (pSystem->busCtrlID,
				pciLoc.bus, pciLoc.device,
				pciLoc.function,
				PCI_CFG_VENDOR_ID, &dev_vend);


	    /* If function 0 then check next dev else check next function */

	    if ( ((dev_vend & 0x0000ffff) == PCI_CONFIG_ABSENT_F) ||
		 ((dev_vend & 0x0000ffff) == PCI_CONFIG_ABSENT_0) )
		{
		if (function == 0)
		    {
		    break;  /* non-existent device, goto next device */
		    }
		else
		    {
		    continue;  /* function empty, try the next function */
		    }
		}

	    PCI_AUTO_DEBUG_MSG("Inside Auto Dev Probe Valid %d %d %d\n",
			       subBus,device,function,4,5,6);

	    /* store the translation offset for the int routing */

	    pciLoc.offset = offset;
	    pciLoc.attribute = 0;

	    /* Check to see if this function belongs to a PCI-PCI bridge */

	    vxbPciConfigInWord (pSystem->busCtrlID,
				pciLoc.bus, pciLoc.device,
				pciLoc.function,
				PCI_CFG_SUBCLASS, &pciclass);

	    /* Set Bridge device attributes for this device */
	    if((pciclass & 0xff00) == (PCI_CLASS_PROCESSOR << 8))
		{
		UINT8 devCapID,cap_id,cap_id_next;

		/*Check for PCI Express ROOT Complex */
		vxbPciConfigInByte (pSystem->busCtrlID, pciLoc.bus,
				    pciLoc.device, pciLoc.function,
				    PCI_CFG_CAP_PTR, &devCapID);

		/* Longword Align */
		devCapID &= ~0x03;

		while (devCapID)
		    {
		    vxbPciConfigInByte (pSystem->busCtrlID,
					pciLoc.bus,
					pciLoc.device,
					pciLoc.function,
					devCapID,
					&cap_id);

		    vxbPciConfigInByte (pSystem->busCtrlID,
					pciLoc.bus,
					pciLoc.device,
					pciLoc.function,
					devCapID+1,
					&cap_id_next);

		    /* longword align */
		    cap_id_next &= ~0x03;

		    /* Enhancement: Dump specific capabilities regs */
		    if (cap_id == PCI_EXT_CAP_EXP)
			{
			UINT16 capReg,type;
			/* Root complex */
			vxbPciConfigInWord (pSystem->busCtrlID,
					    pciLoc.bus,
					    pciLoc.device,
					    pciLoc.function,
					    devCapID | PCI_EXP_CAP_REG,
					    &capReg);

			type = (capReg & PCI_EXP_CAP_PORT_TYPE) >> 4;

			if(type == PCI_EXP_TYPE_ROOT_PORT)
			    {
			    PCI_AUTO_DEBUG_MSG("Found PCIe Root Complex host\n",1,2,3,4,5,6);
			    /* Setup and probe this bridge device but do
			       not try to configure as setup of host
			       bridge done by bus controller driver. */

			    pciLoc.attribute |= inheritAttrib;
			    pciLoc.attribute |= PCI_AUTO_ATTR_BUS_PCI |
						PCI_AUTO_ATTR_DEV_EXCLUDE |
						PCI_AUTO_ATTR_BUS_HOST;
			    }
			}

		    devCapID = cap_id_next;

		    }

        /* Mask off all but bus attribute bits to inherit */

        inheritAttrib &= (PCI_AUTO_ATTR_BUS_4GB_IO |
                             PCI_AUTO_ATTR_BUS_PREFETCH);

        /* devices inherit bus attributes from their bridge */

        pciLoc.attribute |= inheritAttrib;

		}
	    else if (pciclass == ((PCI_CLASS_BRIDGE_CTLR << 8) + PCI_SUBCLASS_HOST_PCI_BRIDGE))
		{
		pciLoc.attribute |= ( PCI_AUTO_ATTR_DEV_EXCLUDE |
				      PCI_AUTO_ATTR_BUS_HOST );
		}
	    /* ISA Bridge */

	    else if (pciclass == ((PCI_CLASS_BRIDGE_CTLR << 8) + PCI_SUBCLASS_ISA_BRIDGE))
		{
		pciLoc.attribute |= PCI_AUTO_ATTR_BUS_ISA;
		}
	    /* Display Device */
	    else if (pciclass == (PCI_CLASS_DISPLAY_CTLR << 8))
		{
		pciLoc.attribute |= PCI_AUTO_ATTR_DEV_DISPLAY;

		/* Mask off all but bus attribute bits to inherit */

		inheritAttrib &=   ( PCI_AUTO_ATTR_BUS_4GB_IO |
				     PCI_AUTO_ATTR_BUS_PREFETCH );
		/* devices inherit bus attributes from their bridge */

		pciLoc.attribute |= inheritAttrib;

		PCI_AUTO_DEBUG_MSG("vxbPciAutoDevProbe: inheriting attribute 0x%x to\
                                        local attribute 0x%x (bus %d)\n",
				   inheritAttrib, pciLoc.attribute, pciLoc.bus, 0, 0, 0);
		}
	    else if ((pciclass == ((PCI_CLASS_BRIDGE_CTLR << 8) +
				   PCI_SUBCLASS_P2P_BRIDGE)) ||
		     (pciclass == ((PCI_CLASS_BRIDGE_CTLR << 8) + PCI_SUBCLASS_CARDBUS_BRIDGE)))
		/* PCI-to-CardBus bridge */
		/* PCI-to-PCI Bridge */
		{
		/* Setup and probe this bridge device */

		pciLoc.attribute |= PCI_AUTO_ATTR_BUS_PCI;
		/*
		 * Check for 32 bit I/O addressability,
		 * but only if the parent bridge supports it
		 */

		if (inheritAttrib & PCI_AUTO_ATTR_BUS_4GB_IO)
		    {
		    vxbPciConfigInByte (pSystem->busCtrlID,
					pciLoc.bus,
					pciLoc.device,
					pciLoc.function,
					PCI_CFG_IO_BASE, &btemp);

		    if ((btemp & 0x0F) == 0x01)
			{
			vxbPciConfigInByte
			  (pSystem->busCtrlID,
			   pciLoc.bus,
			   pciLoc.device, pciLoc.function,
			   PCI_CFG_IO_LIMIT, &btemp);
			if ((btemp & 0x0F) == 0x01)
			    {
			    pciLoc.attribute |= PCI_AUTO_ATTR_BUS_4GB_IO;
			    PCI_AUTO_DEBUG_MSG("vxbPciAutoDevProbe: 4G I/O \n",
					       0, 0, 0, 0, 0, 0);
			    }
			}
		    }

		/* Disable prefetch */

		vxbPciConfigModifyLong (pSystem->busCtrlID,
					pciLoc.bus,
					pciLoc.device,
					pciLoc.function,
					PCI_CFG_PRE_MEM_BASE,
					0xfff0fff0, 0x0000fff0);

		vxbPciConfigOutLong (pSystem->busCtrlID,pciLoc.bus,
				     pciLoc.device,
				     pciLoc.function,
				     PCI_CFG_PRE_MEM_LIMIT_U, 0);

		vxbPciConfigOutLong (pSystem->busCtrlID,
				     pciLoc.bus,
				     pciLoc.device,
				     pciLoc.function,
				     PCI_CFG_PRE_MEM_BASE_U, 0xffffffff);

		/* Check for Prefetch memory support */

		if (inheritAttrib & PCI_AUTO_ATTR_BUS_PREFETCH)
		    {
		    vxbPciConfigInLong  (pSystem->busCtrlID,
					 pciLoc.bus,
					 pciLoc.device,
					 pciLoc.function,
					 PCI_CFG_PRE_MEM_BASE, &temp);

		    /* PF Registers return 0 if PF is not implemented */

		    if (temp != 0)
			{
			pciLoc.attribute |= PCI_AUTO_ATTR_BUS_PREFETCH;
			PCI_AUTO_DEBUG_MSG("vxbPciAutoDevProbe: PF present\n",
					   0, 0, 0, 0, 0, 0);
			}
		    }
		}
	    else
		{

		/* Mask off all but bus attribute bits to inherit */

		inheritAttrib &=   ( PCI_AUTO_ATTR_BUS_4GB_IO |
				     PCI_AUTO_ATTR_BUS_PREFETCH );

		/* devices inherit bus attributes from their bridge */

		pciLoc.attribute |= inheritAttrib;

		}


	    /* Add this function to the PCI function list */

	    if (*pListSize < PCI_AUTO_MAX_FUNCTIONS)
		{
		memcpy (*ppPciList, &pciLoc, sizeof (PCI_LOC));
		(*ppPciList)++;
		(*pListSize)++;
		}

	    /* If the device is a PCI-to-PCI bridge, then scan behind it */

	    if (pciLoc.attribute & PCI_AUTO_ATTR_BUS_PCI)
		{

		PCI_AUTO_DEBUG_MSG("vxbPciAutoDevProbe: scanning bus[%d]\n",
				   (subBus+1), 0, 0, 0, 0, 0 );

		bus = vxbPciAutoBusProbe (pSystem, subBus,
					  vxbPciBusAlloc(subBus), &pciLoc,
					  ppPciList, pListSize);
		}


	    /* Proceed to next device if this is a single function device */

	    if (function == 0)
		{
		vxbPciConfigInByte (pSystem->busCtrlID,
				    pciLoc.bus, pciLoc.device,
				    pciLoc.function,
				    PCI_CFG_HEADER_TYPE, &btemp);
		if ((btemp & PCI_HEADER_MULTI_FUNC) == 0)
		    {
		    break; /* No more functions - proceed to next PCI device */
		    }

		}

	    }
	}

    return(bus);
    }

/******************************************************************************
*
* vxbPciAutoFuncConfigAll - configure all PCI functions contained in list
*
* This routine initializes all PCI functions within the specified
* list.  This may be anything from a full list to a single entry.
*
* RETURNS: N/A
*
* ERRNO
*
*/

LOCAL void vxbPciAutoFuncConfigAll
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,	/* PCI system info */
    PCI_LOC *pPciList,		        /* input: Pointer to first function   */
    UINT nSize			            /* input: Number of functions to init */
    )
    {
    PCI_LOC *pPciFunc;  /* Pointer to next function */
    UINT nLoop;         /* Loop control variable    */
    UINT nEnd;          /* End of function list     */

    /* Disable all devices before we initialize any */

    /* Allocate and assign PCI space to each device */

    pPciFunc = pPciList;
    nEnd = nSize;
    vxbPciAutoDevConfig (pSystem, pPciList->bus, &pPciFunc, &nEnd);

    /* Enable each device on the device list */

    pPciFunc = pPciList;
    for (nLoop = 0; nLoop < nSize; nLoop++)
        {
        vxbPciAutoFuncEnable (pSystem, pPciFunc);
        pPciFunc++;
        }

    }

/******************************************************************************
*
* vxbPciAutoFuncDisable - disable a specific PCI function
*
* This routine clears the I/O, mem, master, & ROM space enable bits
* for a single PCI function.
*
* The PCI spec says that devices should normally clear these by default after
* reset but in actual practice, some PCI devices do not fully comply.  This
* routine ensures that the devices have all been disabled before configuration
* is started.
*
* RETURNS: N/A
*
* ERRNO
*
*/

void vxbPciAutoFuncDisable
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,
    PCI_LOC *pPciFunc		/* input: Pointer to PCI function struct */
    )
    {
    UCHAR cTemp;			/* Temporary storage */
    UINT16 wTemp;

    if ((pPciFunc->attribute) & PCI_AUTO_ATTR_DEV_EXCLUDE)
        {
        return;
        }

    PCI_AUTO_DEBUG_MSG("vxbPciAutoFuncDisable: disable device [%d,%d,%d,0x%02x]\n",
                       (pPciFunc->bus),
                       (pPciFunc->device),
                       (pPciFunc->function),
                       (pPciFunc->attribute),
                       0,
                       0
                      );

    /* Disable Memory, I/O, and Bus Mastering, save status bits */

    wTemp = (PCI_CMD_IO_ENABLE | PCI_CMD_MEM_ENABLE | PCI_CMD_MASTER_ENABLE );

    vxbPciConfigModifyWord (pSystem->busCtrlID,
			    pPciFunc->bus, pPciFunc->device,
			    pPciFunc->function,
			    PCI_CFG_COMMAND, wTemp, 0x0);

    /* Disable header dependent fields */

    vxbPciConfigInByte (pSystem->busCtrlID,
			pPciFunc->bus, pPciFunc->device,
			pPciFunc->function,
			PCI_CFG_HEADER_TYPE, &cTemp);

    cTemp &= PCI_HEADER_TYPE_MASK;

    switch (cTemp)
        {
        case PCI_HEADER_TYPE0:  /* non PCI-PCI bridge */

            /*
             * Disable Expansion ROM address decode for the device.
             * Note that no mem space is allocated for the Expansion
             * ROM, so a re-enable later should NOT be done.
             */

            vxbPciConfigModifyLong (pSystem->busCtrlID,
				    pPciFunc->bus, pPciFunc->device,
				    pPciFunc->function, PCI_CFG_EXPANSION_ROM,
				    0x1, 0);
            break;

        case PCI_HEADER_PCI_PCI:    /* PCI-PCI bridge */

            vxbPciConfigModifyLong (pSystem->busCtrlID,
				    pPciFunc->bus, pPciFunc->device,
				    pPciFunc->function, PCI_CFG_ROM_BASE,
				    0x1, 0);
            break;

        default:
            break;
        }

    return;
    }

/******************************************************************************
*
* vxbPciAutoFuncEnable - perform final configuration and enable a function
*
* Depending upon whether the device is included, this routine initializes
* a single PCI function as follows:
*
* Initialize the cache line size register
* Initialize the PCI-PCI bridge latency timers
* Enable the master PCI bit for non-display devices
* Set the interrupt line value with the value from the BSP.
*
* RETURNS: N/A
*
* ERRNO
*
*/


void vxbPciAutoFuncEnable
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,	  /* for backwards compatibility */
    PCI_LOC * pFunc       /* input: Pointer to PCI function structure */
    )
    {
    UINT16 pciClass;	  /* PCI class/subclass contents */
    UCHAR intLine = 0xff; /* Interrupt "Line" value           */
    UINT8 maxLatency;	  /* MAX_LAT value for this function */

    /*
    * automatically call vxbPciAutoConfigLibInit() for
    * backwards compatibility if vxbPciAutoConfig() was
    * used.
    */
   /* Initialize the cache line size register */

    vxbPciConfigOutByte (pSystem->busCtrlID,
			 pFunc->bus, pFunc->device, pFunc->function,
			 PCI_CFG_CACHE_LINE_SIZE, pSystem->cacheSize);


    /* Initialize the latency timer */

    /*
    *  If MAX_LAT function supplied by BSP, call it to calculate
    *  the value of MAX_LAT for each function individually.
    *  Otherwise, use the default value for all functions.
    */
    if ( ( pSystem->pciConfigInit == TRUE ) &&
         ( pSystem->pciMaxLatFunc != NULL ) )
        {
        /* find value by calling user-supplied function */
        maxLatency = (*pSystem->pciMaxLatFunc)
                     (pFunc->bus,pFunc->device,pFunc->function,
                      pSystem->pciMaxLatPArg);
        }
    else
        {
        /* use default value */
        maxLatency = pSystem->maxLatency;
        }


    vxbPciConfigOutByte (pSystem->busCtrlID,
			 pFunc->bus, pFunc->device, pFunc->function,
			 PCI_CFG_LATENCY_TIMER, maxLatency);


  /* Get the PCI class code */

    vxbPciConfigInWord (pSystem->busCtrlID,
			pFunc->bus, pFunc->device, pFunc->function,
			PCI_CFG_SUBCLASS, &pciClass);

    /* Enable Bus Mastering (preserve status bits) */

    vxbPciConfigModifyWord (pSystem->busCtrlID,
			    pFunc->bus, pFunc->device, pFunc->function,
			    PCI_CFG_COMMAND,
			    PCI_CMD_MASTER_ENABLE,
			    PCI_CMD_MASTER_ENABLE);

    /*
     * If an interrupt assignment routine is registered, assign the
     * interrupt and record interrupt line in config header, else
     * write 0xff (default value) to the interrupt line reg
     */

    intLine = vxbPciAutoIntAssign (pSystem, pFunc);

    vxbPciConfigOutByte (pSystem->busCtrlID,
			 pFunc->bus, pFunc->device, pFunc->function,
			 PCI_CFG_DEV_INT_LINE, intLine);



    /* Reset all writeable status bits */

    vxbPciConfigOutWord (pSystem->busCtrlID,
			 pFunc->bus, pFunc->device, pFunc->function,
			 PCI_CFG_STATUS, (UINT16)0xFFFF);

    return;
    }

/******************************************************************************
*
* vxbPciAutoIntAssign - compute the interrupt number for a given PCI device
*
* This routine computes the interrupt number for a PCI device identified
* by the parameter <pFunc>.
*
* The algorithm used is the following: if the device is on the PCI bus 0,
* then the bsp interrupt assign routine (if any) is called to get the
* actual IRQ number used.  In addition, if the device is a Pci-To-Pci
* Bridge, then this routine populates a routing table that will be used
* later for all of the PCI devices on its every subordinate buses.
* Conversely, if the device sits on any PCI bus other than bus 0, this
* routines only looks at that table.  The index used depends not
* only on the device's location on the bus, but also on the routing offset
* of the most immediate Pci-To-Pci Bridge.  This offset, in turn, is based
* on its location in the PCI hierarchy and was computed earlier by the
* PCI configuration process.  However, the user may skip this automatic
* interrupt assignment process by simply setting the variable autoIntRouting
* in the relevant PCI_AUTO_CONFIG_OPTS structure to FALSE.  In this case the bsp
* interrupt assign routine will be called to get the IRQ number for the device.
*
* RETURNS: The interrupt number associated with the device.
*
* ERRNO
*
*/

LOCAL UCHAR vxbPciAutoIntAssign
    (
    PCI_AUTO_CONFIG_OPTS * pSystem, /* PCI system info */
    PCI_LOC * pFunc       /* input: Pointer to PCI function structure */
    )
    {
    UCHAR retVal = 0xFF;
    UCHAR        intPin;        /* Interrupt "Pin" value            */

    vxbPciConfigInByte (pSystem->busCtrlID,
			pFunc->bus, pFunc->device, pFunc->function,
			PCI_CFG_DEV_INT_PIN, &intPin);

    /*
     * if the bsp provides interrupt routing for all PCI devices,
     * then there's no need of any computation whatsoever
     */

    if ((!(pSystem->autoIntRouting)) && (intPin != 0))
        {
        if ((pSystem->intAssignRtn) != NULL )
            {
            retVal = (pSystem->intAssignRtn) ((PCI_AUTO_CONFIG_OPTS *)pSystem, pFunc, intPin);

            return(retVal);
            }

        }


    /* default interrupt routing: let's find out the IRQ for this device */

    switch (pFunc->bus)
        {

	case 0:

            if (((pSystem->intAssignRtn) != NULL) && (intPin != 0))
                {
                retVal = (pSystem->intAssignRtn) ((PCI_SYSTEM *)pSystem, pFunc, intPin);
                }

            /*
             * if this is a P2P Bridge, then populate its interrupt
             * routing table.  This will be used later for all the devices
             * belonging to its every subordinate bus
             */

            if (((pFunc->attribute) & PCI_AUTO_ATTR_BUS_PCI) > 0)
                {
                int i = 0;

                for (i = 0; i < 4; i++)
                    {
                    if ((pSystem->intAssignRtn) != NULL )
                        {
                        vxbPciAutoIntRoutingTable [i]  = (pSystem->intAssignRtn)
                                                      ((PCI_SYSTEM *)pSystem, pFunc, (i+1));
                        }
                    }

                }

            break;
	case 1:

	    /* This is the case where no PCI-PCI bridge was used to get to
	       bus 1. For PowerPC PCI Ex RC it seems to be common the host
	       is a bridge. We also need to make sure we  */
	    if((vxbPciAutoIntRoutingTable[0] == 0xff) || (vxbPciFirstTimeBus1 == FALSE))
		{

		if (((pSystem->intAssignRtn) != NULL) && (intPin != 0))
		    {
		    retVal = (pSystem->intAssignRtn) ((PCI_SYSTEM *)pSystem, pFunc, intPin);
		    }

		/*
		 * if this is a P2P Bridge, then populate its interrupt
		 * routing table.  This will be used later for all the devices
		 * belonging to its every subordinate bus
		 */

		if (((pFunc->attribute) & PCI_AUTO_ATTR_BUS_PCI) > 0)
		    {
		    int i = 0;

		    if(vxbPciFirstTimeBus1)
			vxbPciFirstTimeBus1 = FALSE;

		    for (i = 0; i < 4; i++)
			{
			if ((pSystem->intAssignRtn) != NULL )
			    {
			    vxbPciAutoIntRoutingTable [i]  = (pSystem->intAssignRtn)
			      ((PCI_SYSTEM *)pSystem, pFunc, (i+1));
			    }
			}

		    }
		break;
		}

            /* the routing table is populated already just drop through */

        default:
            retVal = vxbPciAutoIntRoutingTable [(((pFunc->device) + (intPin - 1)
                                               + (pFunc->offset)) % 4)];
            break;
        }

    PCI_AUTO_DEBUG_MSG("vxbPciAutoIntAssign: int for [%d,%d,%d] pin %d is [%d]\n",
                       pFunc->bus, pFunc->device, pFunc->function, intPin, retVal, 0);

    return retVal;
    }

/******************************************************************************
*
* vxbPciAutoGetNextClass - find the next device of specific type from probe list
*
* The function uses the probe list which was built during the probing
* process.  Using configuration accesses, it searches for the
* occurrence of the device subject to the 'class' and 'mask'
* restrictions outlined below.  Setting 'class' to zero and 'mask' to
* zero allows searching the entire set of devices found regardless of
* class.
*
* RETURNS: TRUE if a device was found, else FALSE.
*
* ERRNO
*
*/

STATUS vxbPciAutoGetNextClass
    (
    PCI_AUTO_CONFIG_OPTS *pSystem,	/* for backwards compatibility */
    PCI_LOC *pPciFunc,  /* output: Contains the BDF of the device found */
    UINT *index,        /* Zero-based device instance number */
    UINT pciClass,      /* class code field from the PCI header */
    UINT mask           /* mask is ANDed with the class field */
    )
    {
    UINT i;
    UINT idx = *index;
    UINT classCode;
    UINT nSize;
    PCI_LOC *pciList;

    /*
     * automatically call vxbPciAutoConfigLibInit() for
     * backwards compatibility if vxbPciAutoConfig() was
     * used.
     */
    nSize = (UINT)lastPciListSize;
    pciList = pLastPciList;

    PCI_AUTO_DEBUG_MSG("\nvxbPciAutoGetNextClass: index[%d] listSiz[%d]\n",
                       *index, nSize, 0, 0, 0, 0);
    PCI_AUTO_DEBUG_MSG("                     pciClass[0x%08x], mask[0x%08x]\n",
                       pciClass, mask, 0, 0, 0, 0);


    for (i = idx; i < nSize; i++)
        {

        /* Grab the class code 24-bit field */

        vxbPciConfigInLong (pSystem->busCtrlID,
			    (UINT)pciList[i].bus, (UINT)pciList[i].device,
			    (UINT)pciList[i].function, (PCI_CFG_CLASS & 0xfc),
			    &classCode);

        classCode >>= 8;        /* Isolate class code in low order bits */

        if ((classCode & mask) == (pciClass & mask))
            {
            *index = i;
            *pPciFunc = pciList[i];


            return(TRUE);
            }

        }

    return(FALSE);
    }

/******************************************************************************
*
* vxbPciAutoDevConfig - allocate memory and I/O space to PCI function
*
* This routine allocates memory and I/O space to functions on an
* individual PCI bus.
*
* LIMITATIONS
* Do not sort the include function list before this routine is
* called.  This routine requires each function in the list to be in the
* same order as the probe occurred.
*
* RETURNS: N/A
*
* ERRNO
*
*/

LOCAL void vxbPciAutoDevConfig
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,  /* PCI system info */
    UINT bus,		/* Current bus number	   */
    PCI_LOC **ppPciList,	/* Pointer to function list */
    UINT *nSize		/* Number of remaining funcs */
    )
    {
    PCI_LOC *pPciFunc;  /* Pointer to PCI function	   */
    UINT nextBus;       /* Bus where function is located   */
    UINT16 pciClass;        /* Class field of function	   */

    /* Process each function within the list */

    while (*nSize > 0)
        {

        /* Setup local variables */

        pPciFunc = *ppPciList;
        nextBus = pPciFunc->bus;

        /* Decrease recursion depth if this function is on a parent bus */


        if (nextBus < bus)
            {
            return;
            }

	(*ppPciList)++;
	(*nSize)--;


	vxbPciAutoFuncConfig (pSystem, pPciFunc);

	/* Allocate and assign space to functions on this bus */

        /* Increase recursion depth if this function is a PCI-PCI bridge */

        vxbPciConfigInWord (pSystem->busCtrlID,
			    pPciFunc->bus, pPciFunc->device, pPciFunc->function,
			    PCI_CFG_SUBCLASS, &pciClass);



        switch (pciClass)
            {
            case ((PCI_CLASS_BRIDGE_CTLR << 8) + PCI_SUBCLASS_CARDBUS_BRIDGE):

                vxbPciAutoCardBusConfig (pSystem, pPciFunc, ppPciList, nSize);
                break;

            case (( PCI_CLASS_BRIDGE_CTLR << 8) + PCI_SUBCLASS_P2P_BRIDGE ):
                /* PCI-PCI bridge functions increase recursion depth */

                vxbPciAutoBusConfig (pSystem, pPciFunc, ppPciList, nSize);
                break;

            default:
                /* Maintain current recursion depth */

                break;
            }
        }
    }

/******************************************************************************
*
* vxbPciAutoFuncConfig - assign memory and/or I/O space to single function
*
* This routine allocates and assigns memory and/or I/O space to a
* single PCI function.	 Allocations are made for each implemented
* base address register (BAR) in the PCI configuration header.
*
* RETURNS: N/A
*
* ERRNO
*
*/

LOCAL void vxbPciAutoFuncConfig
    (
    PCI_AUTO_CONFIG_OPTS * pSystem, /* cookie returned by vxbPciAutoConfigLibInit() */
    PCI_LOC * pPciFunc	/* input: "Include list" pointer to function */
    )
    {
    UINT baMax;     /* Total number of base addresses    */
    UINT baI;       /* Base address register index	     */
    UINT baseAddr;      /* PCI Offset of base address        */
    UINT readVar;       /* Contents of base address register */
    UINT addrInfo;      /* PCI address type information      */
    UINT sizeMask;      /* LSbit for size calculation        */
    UCHAR headerType;   /* Read from PCI config header	     */
    UINT dev_vend;

    /* If there is a function, then consult the exclusion routine */
    PCI_AUTO_DEBUG_MSG("vxbPciAutoFuncConfig:[%x,%x,%d,0x%02x]\n",
                       (pSystem->includeRtn),
                       (pSystem->pciMemIo32Size),
		       0,0,
                       0,
                       0
                      );

    if ( (pSystem->includeRtn) != NULL )
        {
        vxbPciConfigInLong (pSystem->busCtrlID,
			    pPciFunc->bus, pPciFunc->device,
			    pPciFunc->function,
			    PCI_CFG_VENDOR_ID, &dev_vend);

        if ( ((pSystem->includeRtn) ((PCI_AUTO_CONFIG_OPTS *)pSystem, pPciFunc, dev_vend)) == ERROR )
            {
            if ((pPciFunc->attribute & PCI_AUTO_ATTR_BUS_PCI) == 0)
                pPciFunc->attribute |= PCI_AUTO_ATTR_DEV_EXCLUDE;

	    if (pPciFunc->attribute & PCI_AUTO_ATTR_DEV_EXCLUDE)
                {
                PCI_AUTO_DEBUG_MSG("vxbPciAutoFuncConfig: exc [%d,%d,%d,0x%02x]\n",
                                   pPciFunc->bus, pPciFunc->device, pPciFunc->function,
                                   pPciFunc->attribute,0,0);
                return;
                }
            }
        }

    /* Disable the function */

    vxbPciAutoFuncDisable (pSystem,pPciFunc);

    vxbPciConfigInByte (pSystem->busCtrlID,
			pPciFunc->bus, pPciFunc->device,
			pPciFunc->function,
			PCI_CFG_HEADER_TYPE, &headerType);

    headerType &= 0x7f;


    /* Determine the number of base address registers present */

    PCI_AUTO_DEBUG_MSG("vxbPciAutoFuncConfig: 0x%x 0x%x 0x%x 0x%x0x%x 0x%x \n",
		       pSystem->busCtrlID,
		       pPciFunc->bus,
		       pPciFunc->device,
		       pPciFunc->function,
		       PCI_CFG_HEADER_TYPE,
		       headerType);

    switch (headerType)
        {
        case PCI_HEADER_TYPE0:
            baMax = 6;
            break;

        case PCI_HEADER_PCI_PCI:
            baMax = 2;
            break;

        case PCI_HEADER_PCI_CARDBUS:
            baMax = 1;
            break;

        default:
            baMax = 0;
            break;
        }

    /* Allocate Memory or I/O space for each implemented base addr register */

    for (baI = 0; baI < baMax; baI++)
        {
        /* Get the base address register contents */

        baseAddr = PCI_CFG_BASE_ADDRESS_0 + (baI * 4);

        vxbPciConfigOutLong (pSystem->busCtrlID,
			     pPciFunc->bus, pPciFunc->device,
			     pPciFunc->function,
			     baseAddr, 0xFFFFFFFF);

        vxbPciConfigInLong (pSystem->busCtrlID,
			    pPciFunc->bus, pPciFunc->device,
			    pPciFunc->function,
			    baseAddr, &readVar);

        /* Go to the next BAR when an unimplemented one (BAR==0) is found */

        if (readVar == 0)
            {
            continue;
            }

        /* Mask off all but space, memory type, and prefetchable bits */

        addrInfo = readVar & PCI_BAR_ALL_MASK;

        /* Check for type, setup mask variables (based on type) */
        if ((addrInfo & PCI_BAR_SPACE_MASK) == PCI_BAR_SPACE_IO)
            {
            PCI_AUTO_DEBUG_MSG("vxbPciAutoFuncConfig: IO Space found at BAR[%d]\n",
                               baI, 0, 0, 0, 0, 0);
            sizeMask = (1 << 2);
            }
        else
            {
            PCI_AUTO_DEBUG_MSG("vxbPciAutoFuncConfig: MemSpace found at BAR[%d]\n",
                               baI, 0, 0, 0, 0, 0);
            sizeMask = (1 << 4);
            }
        /* Loop until we find a bit set or until we run out of bits */

        for (; sizeMask; sizeMask <<= 1)
            {
            /* is this bit set? if not, keep looking */

            if (readVar & sizeMask)
                {
                baI += vxbPciAutoRegConfig (pSystem, pPciFunc, baseAddr, sizeMask,
                                         addrInfo);
                break;
                }
            }
        }
    }

/******************************************************************************
*
* vxbPciAutoRegConfig - assign PCI space to a single PCI base address register
*
* This routine allocates and assigns PCI space (either memory or I/O)
* to a single PCI base address register.
*
* RETURNS: Returns (1) if BAR supports mapping anywhere in 64-bit address space.
* Returns (0) otherwise.
*
* ERRNO
*
*/

UINT vxbPciAutoRegConfig
    (
    PCI_AUTO_CONFIG_OPTS *pSystem,		/* backwards compatibility */
    PCI_LOC *pPciFunc,		/* Pointer to function in device list */
    UINT baseAddr,		/* Offset of base PCI address */
    UINT nSize,			/* Size and alignment requirements */
    UINT addrInfo		/* PCI address type information	*/
    )
    {
    UINT addr;          /* Working address variable */
    UINT spaceEnable = 0;   /* PCI space enable bit */
    UINT baseaddr_mask;     /* Mask for base address register */
    UINT register64Bit;     /* 64 bit register flag */


    /* Select the appropriate PCI address space for this register */

    if ((addrInfo & PCI_BAR_SPACE_MASK) == PCI_BAR_SPACE_IO)
        {

        /* Configure this register for PCI I/O space */

        spaceEnable = PCI_CMD_IO_ENABLE;
        baseaddr_mask = 0xFFFFFFFC;
        register64Bit = vxbPciAutoIoAlloc (pSystem, pPciFunc, &addr, nSize);
        }
    else
        {

        /* Configure this register for PCI memory space */

        spaceEnable = PCI_CMD_MEM_ENABLE;
        baseaddr_mask = 0xFFFFFFF0;
        register64Bit = vxbPciAutoMemAlloc (pSystem, pPciFunc, &addr, nSize,
                                         addrInfo);
        }

    /*
     * Do not exceed the upper boundary! If this occurs, all we can
     * do here is return, as this is called early in the initialization
     * process, before I/O is available to print error messages.
     */

    if (addr != NO_ALLOCATION)
        {

        /* Program the base address register */

        PCI_AUTO_DEBUG_MSG("vxbPciAutoRegConfig:[0x%08x] written to BAR[0x%08x]\n",
                           addr, baseAddr, 0, 0, 0, 0);

        vxbPciConfigModifyLong (pSystem->busCtrlID,
				pPciFunc->bus, pPciFunc->device,
				pPciFunc->function, baseAddr,
				baseaddr_mask, addr);

        if (register64Bit)
            {

            /*
             * Write the base address for 64-bit addressable memory devices:
             * initialize the next base address register to zero, the PReP
             * address map does support physical addresses above 4GB (i.e.,
             * 32-bit address space)
             */

            vxbPciConfigOutLong (pSystem->busCtrlID,
				 pPciFunc->bus, pPciFunc->device,
				 pPciFunc->function,
				 baseAddr + 4, 0);
            }

        /* Set the appropriate enable bit, preserve status bits */

        vxbPciConfigModifyWord (pSystem->busCtrlID,
				pPciFunc->bus, pPciFunc->device,
				pPciFunc->function, PCI_CFG_COMMAND,
				spaceEnable, spaceEnable);
        }


    return(register64Bit);
    }

/******************************************************************************
*
* vxbPciAutoIoAlloc - select appropriate I/O space for device
*
* This routine determines which PCI I/O space (16-bit or 32-bit) to assign
* to a particular function.  Note that functions located on subordinate
* busses must be  assigned to the 16 bit PCI I/O space due to 16 bit
* decoder limitations of certain bridges and functions.  The PCI
* specification limits each I/O base address register to 256 bytes, so
* this size should not be a problem.
*
* RETURNS: 0, indicating I/O space not located anywhere in 64-bit space.
*
* ERRNO
*
*/

LOCAL UINT vxbPciAutoIoAlloc
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,	/* PCI system structure	  */
    PCI_LOC *pPciFunc,	/* input: Pointer to PCI function element     */
    UINT *pAlloc,		/* output: Pointer to PCI space alloc pointer */
    UINT nSize		/* requested size (power of 2) */
    )
    {
    UINT * pBase;
    UINT32 alignedBase;
    UINT32 sizeAdj;
    UINT * pAvail = NULL;
    STATUS retStat = ERROR;

    /* Assign this register to PCI I/O space */

    if ((pPciFunc->bus == 0) &&
        ((pPciFunc->attribute & PCI_AUTO_ATTR_BUS_4GB_IO) != 0))
        {
        PCI_AUTO_DEBUG_MSG("vxbPciAutoIoAlloc: 32-bit I/O\n", 0, 0, 0, 0, 0, 0);
        pBase = &(pSystem->pciIo32);
        pAvail = &(pSystem->pciIo32Size);
        }
    else
        {
        PCI_AUTO_DEBUG_MSG("vxbPciAutoIoAlloc: 16-bit I/O\n", 0, 0, 0, 0, 0, 0);
        pBase = &(pSystem->pciIo16);
        pAvail = &(pSystem->pciIo16Size);
        }

    /* Adjust for alignment */

    if (*pAvail > 0)
        {
        retStat = vxbPciAutoAddrAlign (*pBase,
                                    (*pBase + *pAvail),
                                    nSize,
                                    &alignedBase);
        }

    /* If the space is exhausted, then return an invalid pointer */

    if (retStat == ERROR)
        {
        PCI_LOG_MSG("Warning: PCI I/O allocation failed\n",
                    0, 0, 0, 0, 0, 0);
        *pAlloc = NO_ALLOCATION;
        return 0;
        }

    PCI_AUTO_DEBUG_MSG("vxbPciAutoIoAlloc: Pre/Post alloc: \n",
                       0, 0, 0, 0, 0, 0);
    PCI_AUTO_DEBUG_MSG("  Pre: pBase[0x%08x], pAvail[0x%08x]\n",
                       (int)(*pBase), (int)(*pAvail), 0, 0, 0, 0);

    *pAlloc  = alignedBase;
    sizeAdj = (alignedBase - *pBase) + nSize;
    *pBase  += sizeAdj;
    *pAvail -= sizeAdj;

    /* update size used in option struct */
    if ((pPciFunc->bus == 0) &&
        ((pPciFunc->attribute & PCI_AUTO_ATTR_BUS_4GB_IO) != 0))
        {
        pSystem->pciIo32Used += sizeAdj;
        }
    else
        {
        pSystem->pciIo16Used += sizeAdj;
        }

    PCI_AUTO_DEBUG_MSG("  Post: pBase[0x%08x], pAvail[0x%08x]\n",
                       (int)(*pBase), (int)(*pAvail), 0, 0, 0, 0);

    return 0; /* can't have 64 bit i/o addresses */
    }

/******************************************************************************
*
* vxbPciAutoMemAlloc - select appropriate memory space for device
*
* This routine determines which PCI memory space pool to use for assignment
* to a particular function.  Note that functions located on subordinate
* busses must be  assigned to the 32 bit PCI memory space due to 32 bit
* requirements of functions using more than 1MB memory space.
*
* LIMITATIONS
* Does not support 64-bit Memory space
*
* RETURNS: Returns 1 if 64-bit addressable memory space.
* Returns zero (0) otherwise.
*
* ERRNO
*
*/

LOCAL UINT vxbPciAutoMemAlloc
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,	/* PCI system structure */
    PCI_LOC * pPciFunc, 	/* Pointer to PCI function element     */
    UINT * pAlloc,   	/* Pointer to PCI space alloc pointer */
    UINT size,		/* space requested (power of 2)  */
    UINT addrInfo		/* PCI address type information	      */
    )
    {
    UINT register64Bit = 0;	/* 64 bit register flag */
    UINT * pBase;
    UINT * pAvail;
    UINT32 alignedBase;
    UINT32 sizeAdj;
    STATUS retStat = ERROR;
    UINT32 * pUpdate;

    /* Process address attribute info */

    switch (addrInfo & (UINT)PCI_BAR_MEM_TYPE_MASK )
        {
        case PCI_BAR_MEM_BELOW_1MB:
            break;

        case PCI_BAR_MEM_ADDR64:
            /*
             * Check for a 64-bit addressable memory device, currently
             * the PReP address map does not support physical addresses
             * above 4Gb (i.e., 32-bits), so the configuration process
             * will initialize the upper base register to zero (i.e.,
             * the safe thing to do), so for right now we'll skip the
             * next base address register which belongs to the 64-bit
             * pair of 32-bit base address registers.
             */

            register64Bit = 1;
            break;

        case PCI_BAR_MEM_ADDR32:
            break;

        case PCI_BAR_MEM_RESERVED:
            /* fall through */

        default:
            *pAlloc = NO_ALLOCATION;
            return 0;
        }

    if ( (addrInfo & PCI_BAR_MEM_PREFETCH) &&
         ((pPciFunc->attribute) & PCI_AUTO_ATTR_BUS_PREFETCH) )
        {
        PCI_AUTO_DEBUG_MSG("vxbPciAutoMemAlloc: PF Mem requested"
                           "\n", 0, 0, 0, 0, 0, 0);

        pBase = &(pSystem->pciMem32);
        pAvail = &(pSystem->pciMem32Size);
        pUpdate = &(pSystem->pciMem32Used);

        if (*pAvail > 0)
            {
            retStat = vxbPciAutoAddrAlign (*pBase,
                                        (*pBase + *pAvail),
                                        size,
                                        &alignedBase);
            }

        if (retStat == ERROR)
            {

            /* If no PF memory available, then try conventional */

            PCI_AUTO_DEBUG_MSG("vxbPciAutoMemAlloc: No PF Mem available"
                               "Trying MemIO\n", 0, 0, 0, 0, 0, 0);

            pBase = &(pSystem->pciMemIo32);
            pAvail = &(pSystem->pciMemIo32Size);
            pUpdate = &(pSystem->pciMemIo32Used);

            if (*pAvail > 0)
                {
                retStat = vxbPciAutoAddrAlign (*pBase,
                                            (*pBase + *pAvail),
                                            size,
                                            &alignedBase);
                }

            if (retStat == ERROR)
                {
                PCI_LOG_MSG("Warning: PCI PF Mem alloc failed\n",
                            0, 0, 0, 0, 0, 0);
                *pAlloc = NO_ALLOCATION;
                return register64Bit;
                }
            }
        }
    else
        {

        /* Use 32-bit Non-Prefetch Memory */
        pBase = &(pSystem->pciMemIo32);
        pAvail = &(pSystem->pciMemIo32Size);
        pUpdate = &(pSystem->pciMemIo32Used);

        if (*pAvail > 0)
            {
            retStat = vxbPciAutoAddrAlign (*pBase,
                                        (*pBase + *pAvail),
                                        size,
                                        &alignedBase);
            }

        if (retStat == ERROR)
            {
            PCI_LOG_MSG("Warning: PCI Memory allocation failed\n",
                        0, 0, 0, 0, 0, 0);
            *pAlloc = NO_ALLOCATION;
            return register64Bit;
            }
        }

    PCI_AUTO_DEBUG_MSG("vxbPciAutoMemAlloc: \n", 0, 0, 0, 0, 0, 0);
    PCI_AUTO_DEBUG_MSG("  Pre: pBase[0x%08x], pAvail[0x%08x]\n",
                       (int)(*pBase), (int)(*pAvail), 0, 0, 0, 0);

    *pAlloc  = alignedBase;
    sizeAdj = (alignedBase - *pBase) + size;
    *pBase  += sizeAdj;
    *pAvail -= sizeAdj;

    /* update size used in option struct */
    *pUpdate += sizeAdj;

    PCI_AUTO_DEBUG_MSG("  Post: pBase[0x%08x], pAvail[0x%08x]\n",
                       (int)(*pBase), (int)(*pAvail), 0, 0, 0, 0);

    return register64Bit;
    }

/******************************************************************************
*
* vxbPciAutoBusConfig - set mem and I/O registers for a single PCI-PCI bridge
*
* This routine	sets up memory and I/O base/limit registers for
* an individual PCI-PCI bridge.
*
* PCI/PCI bridges require that memory space assigned to functions
* on the secondary bus reside in one common block defined by a memory
* base register and a memory limit register, and I/O space assigned to
* functions on the secondary bus must reside in one common block defined
* by an I/O base register and an I/O limit register.  This effectively
* prevents the use of 32 bit PCI I/O space on subordinate (non-zero)
* busses due to the 16 bit decoder limitations of certain bridges and
* functions.
*
* Note that functions which use 20 bit memory decoders must be placed
* on bus zero, or this code will have to be modified to impose a 20 bit
* restriction on all subordinate busses (since some PCI devices allocate
* huge memory spaces, a 1MB total restriction is unacceptable).
*
* Also note that this code does not provide prefetchable memory support
* at this time.
*
* Warning: do not sort the include function list before this routine is
* called.  This routine requires each function in the list to be in the
* same order as the probe occurred.
*
* RETURNS: N/A
*
* ERRNO
*
*/
LOCAL void vxbPciAutoBusConfig
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,	/* PCI system info */
    PCI_LOC * pPciLoc,		/* PCI address of this bridge */
    PCI_LOC **ppPciList,	/* Pointer to function list pointer */
    UINT *nSize			/* Number of remaining functions */
    )
    {
    UCHAR bus;			/* Bus number for current bus */
    UINT8 maxLatency;		/* MAX_LAT value */
    UINT dev_vend;
#ifdef	PCI_AUTO_DEBUG
    UINT32 debugTmp;
    UINT32 debugTmp2;
    UINT32 debugTmp3;
#endif	/* PCI_AUTO_DEBUG */
    UINT32 alignedBase;

    /* If it exists, call the user-defined pre-config pass bridge init */

    if ((pSystem->bridgePreConfigInit) != NULL )
        {
        vxbPciConfigInLong (pSystem->busCtrlID,
			    pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			    PCI_CFG_VENDOR_ID, &dev_vend);

        (pSystem->bridgePreConfigInit) ((PCI_AUTO_CONFIG_OPTS *)pSystem, pPciLoc, dev_vend);
        }

    /* Clear the secondary status bits */

    vxbPciConfigModifyLong (pSystem->busCtrlID,
			    pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			    PCI_CFG_IO_BASE, 0xffff0000, 0xffff0000);

    /* If Prefetch supported, then pre-configure 32-bit PF Memory Base Addr */

    if ( (pPciLoc->attribute & PCI_AUTO_ATTR_BUS_PREFETCH)
         && (pSystem->pciMem32Size > 0) )
        {

        PCI_AUTO_DEBUG_MSG("vxbPciAutoBusConfig: Configuring prefetch aperture\n",
                           0, 0, 0, 0, 0, 0);

        vxbPciAutoAddrAlign(pSystem->pciMem32,
                         (pSystem->pciMem32 + pSystem->pciMem32Size),
                         0x100000,
                         &alignedBase);

        PCI_AUTO_DEBUG_MSG("PF Mem Base orig[0x%08x] new[0x%08x] adj[0x%08x]\n",
                           (pSystem->pciMem32),
                           alignedBase,
                           (alignedBase - (pSystem->pciMem32)),
                           0,
                           0,
                           0
                          );

        (pSystem->pciMem32Used) += (alignedBase - (pSystem->pciMem32));
        (pSystem->pciMem32Size) -= (alignedBase - (pSystem->pciMem32));
        (pSystem->pciMem32) = alignedBase;

        /* 64-bit Prefetch memory not supported at this time */

        vxbPciConfigOutLong (pSystem->busCtrlID,
			     pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			     PCI_CFG_PRE_MEM_BASE_U, 0);

        vxbPciConfigModifyLong (pSystem->busCtrlID,
				pPciLoc->bus,pPciLoc->device,
				pPciLoc->function,
				PCI_CFG_PRE_MEM_BASE, 0x0000fff0,
				(pSystem->pciMem32 >> (20-4))
				);

#ifdef	PCI_AUTO_DEBUG
        vxbPciConfigInLong (pSystem->busCtrlID,
			    pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			    PCI_CFG_PRE_MEM_BASE,
			    &debugTmp2);

        debugTmp = ((debugTmp2 & 0x0000fff0) << 16);

        PCI_AUTO_DEBUG_MSG("vxbPciAutoBusConfig: PF Mem Base [0x%08x]\n",
                           debugTmp, 0, 0, 0, 0, 0);
#endif	/* PCI_AUTO_DEBUG */
        }

    /* Pre-configure 16-bit I/O Base Address */

    if ((pSystem->pciIo16Size) > 0)
        {
        vxbPciAutoAddrAlign(pSystem->pciIo16,
                         (pSystem->pciIo16 + pSystem->pciIo16Size),
                         0x1000,
                         &alignedBase);

        PCI_AUTO_DEBUG_MSG("I/O 16 Base orig[0x%08x] new[0x%08x] adj[0x%08x]\n",
                           (pSystem->pciIo16),
                           alignedBase,
                           (alignedBase - (pSystem->pciIo16)),
                           0,
                           0,
                           0
                          );

        (pSystem->pciIo16Used) += (alignedBase - (pSystem->pciIo16));
        (pSystem->pciIo16Size) -= (alignedBase - (pSystem->pciIo16));
        (pSystem->pciIo16) = alignedBase;

        vxbPciConfigModifyLong (pSystem->busCtrlID,
				pPciLoc->bus, pPciLoc->device, pPciLoc->function,
				PCI_CFG_IO_BASE, 0x000000f0,
				(pSystem->pciIo16 >> (12-4))
				);

        vxbPciConfigModifyLong (pSystem->busCtrlID,
				pPciLoc->bus, pPciLoc->device, pPciLoc->function,
				PCI_CFG_IO_BASE_U, 0x0000ffff,
				(pSystem->pciIo16 >> 16)
				);

#ifdef	PCI_AUTO_DEBUG
        vxbPciConfigInLong (pSystem->busCtrlID,
			    pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			    PCI_CFG_IO_BASE,
			    &debugTmp);

        vxbPciConfigInLong (pSystem->busCtrlID,
			    pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			    PCI_CFG_IO_BASE_U,
			    &debugTmp2);

        debugTmp3 = (((debugTmp & (UINT32)0xf0) << (12-4)) & 0x0000ffff);
        debugTmp = debugTmp3 | ((debugTmp2 << 16) & 0xffff0000);

        PCI_AUTO_DEBUG_MSG("vxbPciAutoBusConfig: IO16 Base Address [0x%08x]\n",
                           debugTmp, 0, 0, 0, 0, 0);
#endif	/* PCI_AUTO_DEBUG */
        }

    /* Pre-configure 32-bit Non-prefetchable Memory Base Address */

    if ((pSystem->pciMemIo32Size) > 0)
        {

        vxbPciAutoAddrAlign(pSystem->pciMemIo32,
                         (pSystem->pciMemIo32 + pSystem->pciMemIo32Size),
                         0x100000,
                         &alignedBase);

        PCI_AUTO_DEBUG_MSG("Memory Base orig[0x%08x] new[0x%08x] adj[0x%08x]\n",
                           (pSystem->pciMemIo32),
                           alignedBase,
                           (alignedBase - (pSystem->pciMemIo32)),
                           0,
                           0,
                           0
                          );

        (pSystem->pciMemIo32Used) += (alignedBase - (pSystem->pciMemIo32));
        (pSystem->pciMemIo32Size) -= (alignedBase - (pSystem->pciMemIo32));
        (pSystem->pciMemIo32) = alignedBase;

        vxbPciConfigModifyLong (pSystem->busCtrlID,
				pPciLoc->bus, pPciLoc->device, pPciLoc->function,
				PCI_CFG_MEM_BASE, 0x0000fff0,
				(pSystem->pciMemIo32 >> (20-4))
				);

#ifdef	PCI_AUTO_DEBUG
        vxbPciConfigInLong (pSystem->busCtrlID,
			    pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			    PCI_CFG_MEM_BASE,
			    &debugTmp2);

        debugTmp = ((debugTmp2 & 0x0000fff0) << 16);

        PCI_AUTO_DEBUG_MSG("vxbPciAutoBusConfig: Mem Base Address [0x%08x]\n",
                           debugTmp, 0, 0, 0, 0, 0);
#endif	/* PCI_AUTO_DEBUG */
        }

    /* Configure devices on the bus implemented by this bridge */

    vxbPciConfigInByte (pSystem->busCtrlID,
			pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			PCI_CFG_SECONDARY_BUS, &bus);


    vxbPciAutoDevConfig (pSystem, bus, ppPciList, nSize);

    /* Post-configure 32-bit I/O Limit Address */

    if ((pSystem->pciIo16Size) > 0)
        {

        vxbPciAutoAddrAlign(pSystem->pciIo16,
                         (pSystem->pciIo16 + pSystem->pciIo16Size),
                         0x1000,
                         &alignedBase);

        PCI_AUTO_DEBUG_MSG("I/O 16 Lim orig[0x%08x] new[0x%08x] adj[0x%08x]\n",
                           (pSystem->pciIo16),
                           alignedBase,
                           (alignedBase - (pSystem->pciIo16)),
                           0,
                           0,
                           0
                          );

        (pSystem->pciIo16Used) += (alignedBase - (pSystem->pciIo16));
        (pSystem->pciIo16Size) -= (alignedBase - (pSystem->pciIo16));
        (pSystem->pciIo16) = alignedBase;

        vxbPciConfigModifyLong (pSystem->busCtrlID,
				pPciLoc->bus, pPciLoc->device,
				pPciLoc->function,
				PCI_CFG_IO_BASE, 0x0000f000,
				(pSystem->pciIo16 - 1)
				);

        vxbPciConfigModifyLong (pSystem->busCtrlID,
				pPciLoc->bus, pPciLoc->device,
				pPciLoc->function,
				PCI_CFG_IO_BASE_U, 0xffff0000,
				(pSystem->pciIo16 - 1)
				);

#ifdef	PCI_AUTO_DEBUG
        vxbPciConfigInLong (pSystem->busCtrlID,
			    pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			    PCI_CFG_IO_BASE,
			    &debugTmp);

        vxbPciConfigInLong (pSystem->busCtrlID,
			    pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			    PCI_CFG_IO_BASE_U,
			    &debugTmp2);

        debugTmp3 = debugTmp & 0x0000f000;
        debugTmp = debugTmp3 | (debugTmp2 & 0xffff0000);
        debugTmp |= 0x00000FFF;

        PCI_AUTO_DEBUG_MSG("vxbPciAutoBusConfig: IO Limit [0x%08x]\n",
                           debugTmp, 0, 0, 0, 0, 0);
#endif	/* PCI_AUTO_DEBUG */
        }

    /* Post-configure 32-bit Non-prefetchable Memory Limit Address */

    if ((pSystem->pciMemIo32Size) > 0)
        {

        vxbPciAutoAddrAlign(pSystem->pciMemIo32,
                         (pSystem->pciMemIo32 + pSystem->pciMemIo32Size),
                         0x100000,
                         &alignedBase);

        PCI_AUTO_DEBUG_MSG("MemIo Lim orig[0x%08x] new[0x%08x] adj[0x%08x]\n",
                           (pSystem->pciMemIo32),
                           alignedBase,
                           (alignedBase - (pSystem->pciMemIo32)),
                           0,
                           0,
                           0
                          );

        (pSystem->pciMemIo32Used) += (alignedBase - (pSystem->pciMemIo32));
        (pSystem->pciMemIo32Size) -= (alignedBase - (pSystem->pciMemIo32));
        (pSystem->pciMemIo32) = alignedBase;

        vxbPciConfigModifyLong (pSystem->busCtrlID,
				pPciLoc->bus, pPciLoc->device,
				pPciLoc->function,
				PCI_CFG_MEM_BASE, 0xfff00000,
				(pSystem->pciMemIo32 - 1)
				);

#ifdef	PCI_AUTO_DEBUG
        vxbPciConfigInLong (pSystem->busCtrlID,
			    pPciLoc->bus, pPciLoc->device,
			    pPciLoc->function,
			    PCI_CFG_MEM_BASE,
			    &debugTmp2);

        debugTmp = (debugTmp2 & 0xfff00000);
        debugTmp |= 0x000FFFFF;

        PCI_AUTO_DEBUG_MSG("vxbPciAutoBusConfig: MemIo Limit [0x%08x]\n",
                           debugTmp, 0, 0, 0, 0, 0);
#endif	/* PCI_AUTO_DEBUG */
        }

    /* Post-configure 32-bit Prefetchable Memory Address */

    if ( (pPciLoc->attribute & PCI_AUTO_ATTR_BUS_PREFETCH) &&
         ((pSystem->pciMem32Size) > 0) )
        {

        vxbPciAutoAddrAlign(pSystem->pciMem32,
                         (pSystem->pciMem32 + pSystem->pciMem32Size),
                         0x100000,
                         &alignedBase);

        PCI_AUTO_DEBUG_MSG("PF Lim orig[0x%08x] new[0x%08x] adj[0x%08x]\n",
                           (pSystem->pciMem32),
                           alignedBase,
                           (alignedBase - (pSystem->pciMem32)),
                           0,
                           0,
                           0
                          );

        (pSystem->pciMem32Used) += (alignedBase - (pSystem->pciMem32));
        (pSystem->pciMem32Size) -= (alignedBase - (pSystem->pciMem32));
        (pSystem->pciMem32) = alignedBase;

        /* 64-bit Prefetchable memory not supported at this time */

        vxbPciConfigOutLong (pSystem->busCtrlID,
			     pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			     PCI_CFG_PRE_MEM_LIMIT_U, 0);

        vxbPciConfigModifyLong (pSystem->busCtrlID,
				pPciLoc->bus, pPciLoc->device,
				pPciLoc->function,
				PCI_CFG_PRE_MEM_BASE, 0xfff00000,
				(pSystem->pciMem32 - 1)
				);

#ifdef	PCI_AUTO_DEBUG
        vxbPciConfigInLong (pSystem->busCtrlID,
			    pPciLoc->bus, pPciLoc->device,
			    pPciLoc->function,
			    PCI_CFG_PRE_MEM_BASE,
			    &debugTmp2);

        debugTmp = (debugTmp2 & 0xfff00000);
        debugTmp |= 0x000FFFFF;

        PCI_AUTO_DEBUG_MSG("vxbPciAutoBusConfig: PF Mem Limit [0x%08x]\n",
                           debugTmp, 0, 0, 0, 0, 0);
#endif	/* PCI_AUTO_DEBUG */
        }

    if ((pSystem->bridgePostConfigInit) != NULL )
        {
        vxbPciConfigInLong (pSystem->busCtrlID,
			    pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			    PCI_CFG_VENDOR_ID, &dev_vend);

        (pSystem->bridgePostConfigInit) ((PCI_AUTO_CONFIG_OPTS *)pSystem, pPciLoc, dev_vend);
        }

    /* Initialize primary and secondary PCI-PCI bridge latency timers */

    /*
    *  If MAX_LAT function supplied by BSP, call it to calculate
    *  the value of MAX_LAT for each function individually.
    *  Otherwise, use the default value for all functions.
    */
    if ( ( pSystem->pciConfigInit == TRUE ) &&
         ( pSystem->pciMaxLatFunc != NULL ) )
        {
        /* find value by calling user-supplied function */
        maxLatency = (*pSystem->pciMaxLatFunc)
                     (pPciLoc->bus,pPciLoc->device,pPciLoc->function,
                      pSystem->pciMaxLatPArg);
        }
    else
        {
        /* use default value */
        maxLatency = pSystem->maxLatency;
        }

    /* actually set MAX_LAT for this function */
    vxbPciConfigOutByte (pSystem->busCtrlID,
			 pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			 PCI_CFG_SEC_LATENCY, maxLatency);


    /* Clear status bits turn on downstream and upstream (master) mem,IO */

    vxbPciConfigOutWord (pSystem->busCtrlID,
			 pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			 PCI_CFG_COMMAND,
			 PCI_CMD_IO_ENABLE | PCI_CMD_MEM_ENABLE |
			 PCI_CMD_MASTER_ENABLE
			 );
    vxbPciConfigOutWord (pSystem->busCtrlID,
			 pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			 PCI_CFG_STATUS,
			 0xffff
			 );
    }



    /* These should be controlled by vxbPciAutoCfgCtl */
#define PCI_CARDBUS_IO16_SIZE		0x1000
#define PCI_CARDBUS_MEMIO32_SIZE	(1 * 1024 * 1024)
#define PCI_CARDBUS_MEM32_SIZE		(1 * 1024 * 1024)
/******************************************************************************
*
* vxbPciAutoCardBusConfig - set mem and I/O registers for a single PCI-Cardbus bridge
*
* SYNOPSIS
* \cs
* LOCAL void vxbPciAutoCardBusConfig
*     (
*     PCI_AUTO_CONFIG_OPTS * pSystem,     /@ PCI system info @/
*     PCI_LOC              * pPciLoc,     /@ PCI address of this bridge @/
*     PCI_LOC             ** ppPciList,   /@ Pointer to function list pointer @/
*     UINT                 * nSize        /@ Number of remaining functions @/
*     )
* \ce
*
* This routine sets up memory and I/O base/limit registers for
* an individual PCI-Cardbus bridge.
*
* Cardbus bridges have four windows - 2 memory windows and 2 IO
* windows. The 2 memory windows can be setup individually for either
* prefetchable or non-prefetchable memory accesses.
*
* Since PC Cards can be inserted at any time, and are not necessarily
* present when this code is run, the code does not probe any further
* after encountering a Cardbus bridge. Instead, the code allocates
* default window sizes for the Cardbus bridge. Three windows are used:
*
* \ss
* Memory #0:			Prefetch memory
* Memory #1:			Non-prefetch memory
* IO #0:			IO
* IO #1:			Unused
* \se
*
* Warning: do not sort the include function list before this routine is
* called.  This routine requires each function in the list to be in the
* same order as the probe occurred.
*
* ERRNO
*
* RETURNS: N/A
*
*/
LOCAL void vxbPciAutoCardBusConfig
    (
    PCI_AUTO_CONFIG_OPTS * pSystem,	/* PCI system info */
    PCI_LOC * pPciLoc,		/* PCI address of this bridge */
    PCI_LOC **ppPciList,	/* Pointer to function list pointer */
    UINT *nSize			/* Number of remaining functions */
    )
    {
    UINT8 maxLatency;		/* MAX_LAT value */
    UINT dev_vend;
    UINT32 alignedBase;
    UINT32 pciCardBusIo16Size = PCI_CARDBUS_IO16_SIZE;
    UINT32 pciCardBusMemIo32Size = PCI_CARDBUS_MEMIO32_SIZE;
    UINT32 pciCardBusMem32Size = PCI_CARDBUS_MEM32_SIZE;
    UINT32 sizeAdj;

    /* Make sure devices are inactive by placing them in reset */

    vxbPciConfigModifyWord (pSystem->busCtrlID,
			    pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			    PCI_CFG_BRIDGE_CONTROL,
			    PCI_CFG_CB_RESET, PCI_CFG_CB_RESET);


    /* If it exists, call the user-defined pre-config pass bridge init */

    if ((pSystem->bridgePreConfigInit) != NULL )
        {
        vxbPciConfigInLong (pSystem->busCtrlID,
			    pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			    PCI_CFG_VENDOR_ID, &dev_vend);

        (pSystem->bridgePreConfigInit) ((PCI_AUTO_CONFIG_OPTS *)pSystem, pPciLoc, dev_vend);
        }

    /* Clear the secondary status bits */

    vxbPciConfigModifyLong (pSystem->busCtrlID,
			    pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			    PCI_CFG_CB_CAP_PTR, 0xffff0000, 0xffff0000);

    /* If Prefetch supported, then configure 32-bit PF Memory Base Addr */

    if ( (pPciLoc->attribute & PCI_AUTO_ATTR_BUS_PREFETCH)
         && (pSystem->pciMem32Size > 0) )
        {

        PCI_AUTO_DEBUG_MSG("vxbPciAutoBusConfig: Configuring prefetch aperture\n",
                           0, 0, 0, 0, 0, 0);

        vxbPciAutoAddrAlign(pSystem->pciMem32,
                         (pSystem->pciMem32 + pSystem->pciMem32Size),
                         pciCardBusMem32Size,
                         &alignedBase);

        PCI_AUTO_DEBUG_MSG("PF Mem Base orig[0x%08x] new[0x%08x] adj[0x%08x]\n",
                           (pSystem->pciMem32),
                           alignedBase,
                           (alignedBase - (pSystem->pciMem32)),
                           0,
                           0,
                           0
                          );

        sizeAdj = alignedBase - (pSystem->pciMem32) + pciCardBusMem32Size;

        (pSystem->pciMem32Used) += sizeAdj;
        (pSystem->pciMem32Size) -= sizeAdj;
        (pSystem->pciMem32) += sizeAdj;

        /* Use Memory base #0 for prefetch memory */

        vxbPciConfigOutLong (pSystem->busCtrlID,
			     pPciLoc->bus,pPciLoc->device,pPciLoc->function,
			     PCI_CFG_CB_MEM_BASE_0, alignedBase);

        PCI_AUTO_DEBUG_MSG("vxbPciAutoBusConfig: PF Mem Base [0x%08x]\n",
                           pSystem->pciMem32, 0, 0, 0, 0, 0);

        /* Set limit register */

        vxbPciConfigOutLong (pSystem->busCtrlID,
			     pPciLoc->bus,pPciLoc->device,pPciLoc->function,
			     PCI_CFG_CB_MEM_LIMIT_0, alignedBase);

        /* Enable prefetch memory window 0 */

        vxbPciConfigModifyWord (pSystem->busCtrlID,
				pPciLoc->bus,pPciLoc->device,
				pPciLoc->function,
				PCI_CFG_BRIDGE_CONTROL, PCI_CFG_CB_PREFETCH0,
				PCI_CFG_CB_PREFETCH0);
        }

    /* Configure 16-bit I/O Base Address */

    if ((pSystem->pciIo16Size) > 0)
        {
        vxbPciAutoAddrAlign(pSystem->pciIo16,
                         (pSystem->pciIo16 + pSystem->pciIo16Size),
                         pciCardBusIo16Size,
                         &alignedBase);

        PCI_AUTO_DEBUG_MSG("I/O 16 Base orig[0x%08x] new[0x%08x] adj[0x%08x]\n",
                           (pSystem->pciIo16),
                           alignedBase,
                           (alignedBase - (pSystem->pciIo16)),
                           0,
                           0,
                           0
                          );

        sizeAdj = alignedBase - (pSystem->pciIo16) + pciCardBusIo16Size;

        (pSystem->pciIo16Used) += sizeAdj;
        (pSystem->pciIo16Size) -= sizeAdj;
        (pSystem->pciIo16) += sizeAdj;

        /* Use IO base #0 for 16-bit I/O */

        vxbPciConfigOutLong (pSystem->busCtrlID,
			     pPciLoc->bus, pPciLoc->device,
			     pPciLoc->function,
			     PCI_CFG_CB_IO_BASE_0, alignedBase);

        PCI_AUTO_DEBUG_MSG("vxbPciAutoBusConfig: IO16 Base Address [0x%08x]\n",
                           pSystem->pciIo16, 0, 0, 0, 0, 0);

        /* Set limit register */

        vxbPciConfigOutLong (pSystem->busCtrlID,
			     pPciLoc->bus,pPciLoc->device,pPciLoc->function,
			     PCI_CFG_CB_IO_LIMIT_0, alignedBase);

        }

    /* Configure 32-bit Non-prefetchable Memory Base Address */

    if ((pSystem->pciMemIo32Size) > 0)
        {
        vxbPciAutoAddrAlign(pSystem->pciMemIo32,
			    (pSystem->pciMemIo32 + pSystem->pciMemIo32Size),
			    pciCardBusMemIo32Size,
			    &alignedBase);

        PCI_AUTO_DEBUG_MSG("Memory Base orig[0x%08x] new[0x%08x] adj[0x%08x]\n",
                           (pSystem->pciMemIo32),
                           alignedBase,
                           (alignedBase - (pSystem->pciMemIo32)),
                           0,
                           0,
                           0
                          );

        sizeAdj = alignedBase - (pSystem->pciMemIo32) + pciCardBusMemIo32Size;

        (pSystem->pciMemIo32Used) += sizeAdj;
        (pSystem->pciMemIo32Size) -= sizeAdj;
        (pSystem->pciMemIo32) += sizeAdj;

        /* Use Memory base #1 for 32-bit non-prefetch memory */

        vxbPciConfigOutLong (pSystem->busCtrlID,
			     pPciLoc->bus, pPciLoc->device,
			     pPciLoc->function,
			     PCI_CFG_CB_MEM_BASE_1, alignedBase);

        PCI_AUTO_DEBUG_MSG("vxbPciAutoBusConfig: Mem Base Address [0x%08x]\n",
                           pSystem->pciMemIo32, 0, 0, 0, 0, 0);

        /* Set limit register */

        vxbPciConfigOutLong (pSystem->busCtrlID,
			     pPciLoc->bus,pPciLoc->device,
			     pPciLoc->function,
			     PCI_CFG_CB_MEM_LIMIT_1,
			     alignedBase);

        /* Disable prefetch memory window 1 */

        vxbPciConfigModifyWord (pSystem->busCtrlID,
				pPciLoc->bus,pPciLoc->device,
				pPciLoc->function,
				PCI_CFG_BRIDGE_CONTROL, PCI_CFG_CB_PREFETCH1,
				0);
        }

    /* Initialize primary and secondary PCI-CardBus bridge latency timers */

    /*
    *  If MAX_LAT function supplied by BSP, call it to calculate
    *  the value of MAX_LAT for each function individually.
    *  Otherwise, use the default value for all functions.
    */
    if ( ( pSystem->pciConfigInit == TRUE ) &&
         ( pSystem->pciMaxLatFunc != NULL ) )
        {
        /* find value by calling user-supplied function */
        maxLatency = (*pSystem->pciMaxLatFunc)
                     (pPciLoc->bus,pPciLoc->device,pPciLoc->function,
                      pSystem->pciMaxLatPArg);
        }
    else
        {
        /* use default value */
        maxLatency = pSystem->maxLatency;
        }

    /* actually set MAX_LAT for this function */
    vxbPciConfigOutByte (pSystem->busCtrlID,
			 pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			 PCI_CFG_SEC_LATENCY, maxLatency);


    /* Clear status bits turn on downstream and upstream (master) mem,IO */

    vxbPciConfigOutWord (pSystem->busCtrlID,
			 pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			 PCI_CFG_COMMAND,
			 PCI_CMD_IO_ENABLE | PCI_CMD_MEM_ENABLE  |
			 PCI_CMD_MASTER_ENABLE
                     );
    vxbPciConfigOutWord (pSystem->busCtrlID,
			 pPciLoc->bus, pPciLoc->device, pPciLoc->function,
			 PCI_CFG_STATUS,
			 0xffff
                     );

    }

/*******************************************************************************
*
* vxbPciAutoAddrAlign - align a PCI address and check boundary conditions
*
* This routine handles address alignment/checking.
*
* RETURNS: OK, or ERROR if available memory has been exceeded.
*
* ERRNO
*
*/

STATUS vxbPciAutoAddrAlign
    (
    UINT32 base,		/* base of available memory */
    UINT32 limit,		/* last addr of available memory */
    UINT32 reqSize,		/* required size */
    UINT32 *pAlignedBase	/* output: aligned address put here */
    )
    {
    UINT32 sizeMask;
    UINT32 alignAdjust;

    /* make the size mask */

    sizeMask = reqSize - 1;

    PCI_AUTO_DEBUG_MSG("vxbPciAutoAddrAlign: sizemask[%08x]\n",sizeMask,0,0,0,0,0);

    /* see if the address needs to be adjusted */

    if ((base & sizeMask) > 0)
        {
        alignAdjust = reqSize - (base & sizeMask);
        PCI_AUTO_DEBUG_MSG ("vxbPciAutoAddrAlign: adjustment [%08x]\n",alignAdjust,
                            0,0,0,0,0);
        }
    else
        {
        PCI_AUTO_DEBUG_MSG("vxbPciAutoAddrAlign: already aligned\n",0,0,0,0,0,0);
        alignAdjust = 0;
        }

    /* see if the aligned base exceeds the resource boundary */

    if ( ((base + alignAdjust) < base) ||
         ((base + alignAdjust) > limit) )
        {
        PCI_AUTO_DEBUG_MSG ("vxbPciAutoAddrAlign: base + adjustment [%08x]"
                            " exceeds limit [%08x]\n", (base + alignAdjust),
                            limit,
                            0,0,0,0);
        return ERROR;
        }

    *pAlignedBase = base + alignAdjust;

    /* see if the aligned base+size exceeds the resource boundary */

    if ( ((base + alignAdjust + reqSize) < base) ||
         ((base + alignAdjust + reqSize) > limit) )
        {
        PCI_AUTO_DEBUG_MSG ("vxbPciAutoAddrAlign: base + adjustment + req [%08x]"
                            " exceeds limit [%08x]\n",
                            (base + alignAdjust + reqSize),limit,0,0,0,0);
        return ERROR;
        }

    PCI_AUTO_DEBUG_MSG ("vxbPciAutoAddrAlign: new aligned base [%08x]\n",
                        (base + alignAdjust),0,0,0,0,0);

    return OK;
    }


/**********************************************************************
*
* vxbPciFBBFuncSet - enable Fast Back To Back on specified function
*
* vxbPciFBBFuncSet() turns on FBB on the specified function.  This function
* is intended for use with pciConfigForeachFunc().
*
* If the device fails to return a valid status word, then
* return ERROR without modifying FBB enable.
*
* ERRNO: N/A
*
* RETURNS: OK, or ERROR if fast back to back is not supported.
*/

LOCAL STATUS vxbPciFBBFuncSet
    (
    VXB_DEVICE_ID busCtrlID,
    UINT	bus,		/* bus */
    UINT	device,		/* device */
    UINT	function,	/* function */
    void *	pArg		/* not used */
    )
    {
    UINT16	pciStatus;	/* PCI status register */

    if(busCtrlID == NULL)
	return(ERROR);

    /* check if this device supports Fast Back To Back */
    vxbPciConfigInWord (busCtrlID,
			bus, device, function, PCI_CFG_STATUS, &pciStatus);
    if ( ! ( pciStatus & PCI_STATUS_FAST_BB ) )
        return(ERROR);

    /* turn FBB on */
    vxbPciConfigModifyWord (busCtrlID,
			    bus, device, function, PCI_CFG_COMMAND,
			    PCI_CMD_FBTB_ENABLE,
			    PCI_CMD_FBTB_ENABLE);
    return(OK);
    }

/**********************************************************************
*
* vxbPciFBBFuncCheck - check Fast Back To Back on specified function
*
* vxbPciFBBFuncCheck() checks whether the function supports FBB
*
* If the device fails to return a valid status word, then
* return ERROR without modifying FBB enable.
*
* ERRNO: N/A
*
* RETURNS: OK, or ERROR if fast back to back is not supported.
*
*/

LOCAL STATUS vxbPciFBBFuncCheck
    (
    VXB_DEVICE_ID busCtrlID,
    UINT	bus,		/* bus */
    UINT	device,		/* device */
    UINT	function,	/* function */
    void *	pArg		/* not used */
    )
    {
    UINT16	pciStatus;	/* PCI status register */

    if(busCtrlID == NULL)
	return(ERROR);

    /* check if this device supports Fast Back To Back */
    vxbPciConfigInWord (busCtrlID,
			bus, device, function,
			PCI_CFG_STATUS, &pciStatus);
    if ( ! ( pciStatus & PCI_STATUS_FAST_BB ) )
        return(ERROR);

    return(OK);
    }

/**********************************************************************
*
* vxbPciFBBFuncClear - disable Fast Back To Back on specified function
*
* vxbPciFBBFuncClear() turns off FBB on the specified function.
*
* ERRNO: N/A
*
* RETURNS: OK, always.
*
*/

LOCAL STATUS vxbPciFBBFuncClear
    (
    VXB_DEVICE_ID busCtrlID,
    UINT	bus,		/* bus */
    UINT	device,		/* device */
    UINT	function,	/* function */
    void *	pArg		/* not used */
    )
    {
    UINT16	pciStatus;	/* PCI status register */

    if(busCtrlID == NULL)
	return(ERROR);

    /* check if this device supports Fast Back To Back */
    vxbPciConfigInWord (busCtrlID,
			bus, device, function, PCI_CFG_STATUS, &pciStatus);
    if ( pciStatus & PCI_STATUS_FAST_BB )
        {
        /* turn FBB off */
        vxbPciConfigModifyWord (busCtrlID,
				bus, device, function, PCI_CFG_COMMAND,
				PCI_CMD_FBTB_ENABLE, 0);
        }
    return(OK);
    }

/**********************************************************************
*
* vxbPciAutoConfigFBBEnable - enable Fast Back To Back
*
* vxbPciAutoConfigFBBEnable() discovers the functions present
* and verifies that each of them can support FBB.  At any time,
* if it finds a device which cannot handle FBB, it returns ERROR.
* If all listed devices do support FBB, then it makes a second
* pass through the list, and enables FBB on all listed functions.
*
* If any device fails to return a valid status word, then
* vxbPciAutoConfigFBBEnable() will immediately return ERROR without
* modifying FBB enable on any cards which have already been enabled
* and without finishing the list.
*
* ERRNO:
* EINVAL if FBB is not enabled
*
* RETURNS: OK, or ERROR if fast back to back has not been enabled.
*
*/

LOCAL STATUS vxbPciAutoConfigFBBEnable
    (
    PCI_AUTO_CONFIG_OPTS *	pSystem /* system configuration information */
    )
    {
    STATUS status;

    if ( pSystem->pciFBBEnable != TRUE )
        {
        errnoSet(EINVAL);
        return(ERROR);
        }


    /* discover devices and check for FBB implemented */
    status = vxbPciFBBFuncCheck(pSystem->busCtrlID,0,0,0,NULL);
    if ( status != OK )
        return(ERROR);


    status = vxbPciConfigForeachFunc(pSystem->busCtrlID,0, TRUE, (VXB_PCI_FOREACH_FUNC)vxbPciFBBFuncCheck, NULL);
    if ( status != OK )
        return(ERROR);


    /* all are FBB aware, so enable devices */
    status = vxbPciFBBFuncSet(pSystem->busCtrlID,0,0,0,NULL);
    if ( status != OK )
        return(status);

    status = vxbPciConfigForeachFunc(pSystem->busCtrlID,0, TRUE, (VXB_PCI_FOREACH_FUNC)vxbPciFBBFuncSet, NULL);

    return(status);
    }

/**********************************************************************
*
* vxbPciAutoConfigFBBDisable - disable Fast Back To Back
*
* vxbPciAutoConfigFBBDisable() goes through the list of PCI functions
* and disables FBB on all listed functions.
*
* If any device fails to return a valid status word, then
* vxbPciAutoConfigFBBDisable() will continue disabling FBB on the
* remaining functions, but will return ERROR after finishing.
*
* ERRNO: N/A
*
* RETURNS: OK, or ERROR if fast back to back was not previously enabled.
*
*/

LOCAL STATUS vxbPciAutoConfigFBBDisable
    (
    PCI_AUTO_CONFIG_OPTS *	pSystem /* system configuration information */
    )
    {
    STATUS status;

    if ( pSystem->pciFBBEnable != TRUE )
        {
        return(ERROR);
        }
    pSystem->pciFBBEnable = FALSE;

    /* discover devices and disable FBB */
    status = vxbPciConfigForeachFunc(pSystem->busCtrlID,0, TRUE, (VXB_PCI_FOREACH_FUNC)vxbPciFBBFuncClear, NULL);

    return(status);
    }

/* backward compatibility functions */


#endif /* INCLUDE_PCI_BUS_AUTOCONF */




#ifdef INCLUDE_PCI_BUS_SHOW
/*******************************************************************************
*
* vxbPciConfigShowInit - initialize the show routines
*
* This routine is used to pull in all routines in this library.
*
* \NOMANUAL
*
* RETURNS: N/A
*
* ERRNO
*/

void vxbPciConfigShowInit (void)
    {
    return;
    }

/*******************************************************************************
*
* vxbPciDeviceShow - print information about PCI devices
*
* This routine prints information about the PCI devices on a given PCI bus
* segment (specified by <busNo>).
*
* RETURNS: OK, or ERROR if the library is not initialized.
*
* ERRNO
*/

STATUS vxbPciDeviceShow
    (
    VXB_DEVICE_ID busCtrlID,
    int busNo       /* bus number */
    )
    {
    int deviceNo;
    UINT16 vendorId = 0;
    UINT16 deviceId = 0;
    UINT32 classCode = 0;
    UINT8 headerType = 0;
    int func=0;
    VXB_DEVICE_ID childID=(VXB_DEVICE_ID)NULL;
    struct vxbPciDevice localPciDevice;
    struct vxbPciDevice *pPciDevice;

    if(busCtrlID == NULL)
	return(ERROR);

    /* Assume we can use bus 0 device 0 func 0 to load pci info */


    /* check for library initialization or unaligned access */

    localPciDevice.pciBus = 0;
    localPciDevice.pciFunc = 0;
    localPciDevice.pciDev = 0;
    localPciDevice.devID = NULL;

    if(busCtrlID->busID == VXB_BUSID_PCI)
	busCtrlID = vxbDevParent(busCtrlID);

    if(localPciDevice.devID==NULL)
	localPciDevice.devID = busCtrlID;

    childID = localPciDevice.devID;

    pPciDevice = ((struct vxbPciDevice *)childID->pBusSpecificDevInfo);

    printf ("Scanning functions of each PCI device on bus %d\n", busNo);
    printf ("bus       device    function  vendorID  deviceID  class/rev\n");

    for (deviceNo=0; deviceNo < PCI_MAX_DEV; deviceNo++)
        {
        for (func = 0; func < 8; func++)
            {
            /* avoid a special bus cycle */
	    vendorId = 0xffff;

            if ((deviceNo == 0x1f) && (func == 0x07))
                continue;

            vxbPciConfigInWord (busCtrlID, busNo, deviceNo, func, PCI_CFG_VENDOR_ID,
                             (UINT16 *)&vendorId);

            /*
             * There are two ways to find out an empty device.
             * 1. check Master Abort bit after the access.
             * 2. check whether the read value is 0xffff.
             * Since I didn't see the Master Abort bit of the host/PCI bridge
             * changing, I use the second method.
             */

            if (vendorId == 0xffff)
                {
                if (func == 0)
                    break; /* next device */
                continue;  /* next function */
                }

	    deviceId = 0xffff;
            vxbPciConfigInWord (busCtrlID, busNo, deviceNo, func, PCI_CFG_DEVICE_ID,
                             (UINT16 *)&deviceId);

            vxbPciConfigInLong (busCtrlID, busNo, deviceNo, func, PCI_CFG_REVISION,
                             &classCode);

            vxbPciConfigInByte (busCtrlID, busNo, deviceNo, func, PCI_CFG_HEADER_TYPE,
                             &headerType);

            printf ("%7d   %6d    %8d   0x%04x    0x%04x  0x%08x\n",
                    busNo, deviceNo, func, vendorId, deviceId, classCode);

            if (func == 0 && (headerType & PCI_HEADER_MULTI_FUNC) == 0)
                break; /* next device */
            }
        }

    return (OK);
    }

/*******************************************************************************
*
* vxbPciHeaderShow - print a header of the specified PCI device
*
* This routine prints a header of the PCI device specified by busNo, deviceNo,
* and funcNo.
*
* RETURNS: OK, or ERROR if this library is not initialized.
*
* ERRNO
*/

STATUS vxbPciHeaderShow
    (
    VXB_DEVICE_ID busCtrlID,
    int busNo,      /* bus number */
    int deviceNo,   /* device number */
    int funcNo      /* function number */
    )
    {
    PCI_HEADER_DEVICE headerDevice;
    PCI_HEADER_BRIDGE headerBridge;
    PCI_HEADER_CB_BRIDGE headerCBBridge;
    PCI_HEADER_DEVICE * pD = &headerDevice;
    PCI_HEADER_BRIDGE * pB = &headerBridge;
    PCI_HEADER_CB_BRIDGE * pCB = &headerCBBridge;

    if(busCtrlID == NULL)
	return(ERROR);

    vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_HEADER_TYPE,
                     (UINT8 *)&pD->headerType);

    if (pD->headerType & 0x01)      /* PCI-to-PCI bridge */
        {
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_VENDOR_ID,
                         (UINT16 *)&pB->vendorId);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_DEVICE_ID,
                         (UINT16 *)&pB->deviceId);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_COMMAND,
                         (UINT16 *)&pB->command);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_STATUS,
                         (UINT16 *)&pB->status);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_REVISION,
                         (UINT8 *)&pB->revisionId);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_PROGRAMMING_IF,
                         (UINT8 *)&pB->progIf);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_SUBCLASS,
                         (UINT8 *)&pB->subClass);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CLASS,
                         (UINT8 *)&pB->classCode);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CACHE_LINE_SIZE,
                         (UINT8 *)&pB->cacheLine);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_LATENCY_TIMER,
                         (UINT8 *)&pB->latency);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_HEADER_TYPE,
                         (UINT8 *)&pB->headerType);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BIST,
                         (UINT8 *)&pB->bist);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BASE_ADDRESS_0,
                         (UINT32 *)&pB->base0);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BASE_ADDRESS_1,
                         (UINT32 *)&pB->base1);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_PRIMARY_BUS,
                         (UINT8 *)&pB->priBus);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_SECONDARY_BUS,
                         (UINT8 *)&pB->secBus);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_SUBORDINATE_BUS,
                         (UINT8 *)&pB->subBus);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_SEC_LATENCY,
                         (UINT8 *)&pB->secLatency);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_IO_BASE,
                         (UINT8 *)&pB->ioBase);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_IO_LIMIT,
                         (UINT8 *)&pB->ioLimit);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_SEC_STATUS,
                         (UINT16 *)&pB->secStatus);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_MEM_BASE,
                         (UINT16 *)&pB->memBase);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_MEM_LIMIT,
                         (UINT16 *)&pB->memLimit);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_PRE_MEM_BASE,
                         (UINT16 *)&pB->preBase);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_PRE_MEM_LIMIT,
                         (UINT16 *)&pB->preLimit);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_PRE_MEM_BASE_U,
                         (UINT32 *)&pB->preBaseUpper);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_PRE_MEM_LIMIT_U,
                         (UINT32 *)&pB->preLimitUpper);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_IO_BASE_U,
                         (UINT16 *)&pB->ioBaseUpper);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_IO_LIMIT_U,
                         (UINT16 *)&pB->ioLimitUpper);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_ROM_BASE,
                         (UINT32 *)&pB->romBase);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BRG_INT_LINE,
                         (UINT8 *)&pB->intLine);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BRG_INT_PIN,
                         (UINT8 *)&pB->intPin);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BRIDGE_CONTROL,
                         (UINT16 *)&pB->control);
        vxbPciBheaderPrint (pB);

        if (pB->status & PCI_STATUS_NEW_CAP)
            vxbCapabShow (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CAP_PTR);

        }
    else if ((pD->headerType & PCI_HEADER_TYPE_MASK) == PCI_HEADER_PCI_CARDBUS)
        {
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_VENDOR_ID,
                         (UINT16 *)&pCB->vendorId);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_DEVICE_ID,
                         (UINT16 *)&pCB->deviceId);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_COMMAND,
                         (UINT16 *)&pCB->command);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_STATUS,
                         (UINT16 *)&pCB->status);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_REVISION,
                         (UINT8 *)&pCB->revisionId);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_PROGRAMMING_IF,
                         (UINT8 *)&pCB->progIf);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_SUBCLASS,
                         (UINT8 *)&pCB->subClass);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CLASS,
                         (UINT8 *)&pCB->classCode);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CACHE_LINE_SIZE,
                         (UINT8 *)&pCB->cacheLine);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_LATENCY_TIMER,
                         (UINT8 *)&pCB->latency);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_HEADER_TYPE,
                         (UINT8 *)&pCB->headerType);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BIST,
                         (UINT8 *)&pCB->bist);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BASE_ADDRESS_0,
                         (UINT32 *)&pCB->base0);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CB_CAP_PTR,
                         (UINT8 *)&pCB->capPtr);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CB_SEC_STATUS,
                         (UINT16 *)&pCB->secStatus);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_PRIMARY_BUS,
                         (UINT8 *)&pCB->priBus);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_SECONDARY_BUS,
                         (UINT8 *)&pCB->secBus);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_SUBORDINATE_BUS,
                         (UINT8 *)&pCB->subBus);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_SEC_LATENCY,
                         (UINT8 *)&pCB->secLatency);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CB_MEM_BASE_0,
                         (UINT32 *)&pCB->memBase0);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CB_MEM_LIMIT_0,
                         (UINT32 *)&pCB->memLimit0);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CB_MEM_BASE_1,
                         (UINT32 *)&pCB->memBase1);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CB_MEM_LIMIT_1,
                         (UINT32 *)&pCB->memLimit1);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CB_IO_BASE_0,
                         (UINT32 *)&pCB->ioBase0);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CB_IO_LIMIT_0,
                         (UINT32 *)&pCB->ioLimit0);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CB_IO_BASE_1,
                         (UINT32 *)&pCB->ioBase1);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CB_IO_LIMIT_1,
                         (UINT32 *)&pCB->ioLimit1);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BRG_INT_LINE,
                         (UINT8 *)&pCB->intLine);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BRG_INT_PIN,
                         (UINT8 *)&pCB->intPin);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BRIDGE_CONTROL,
                         (UINT16 *)&pCB->control);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CB_SUB_VENDOR_ID,
                         (UINT16 *)&pCB->subVendorId);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CB_SUB_SYSTEM_ID,
                         (UINT16 *)&pCB->subSystemId);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CB_16BIT_LEGACY,
                         (UINT32 *)&pCB->legacyBase);
        vxbPciCBheaderPrint (pCB);

        if (pCB->status & PCI_STATUS_NEW_CAP)
            vxbCapabShow (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CB_CAP_PTR);

        }
    else                    /* PCI device */
        {
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_VENDOR_ID,
                         (UINT16 *)&pD->vendorId);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_DEVICE_ID,
                         (UINT16 *)&pD->deviceId);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_COMMAND,
                         (UINT16 *)&pD->command);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_STATUS,
                         (UINT16 *)&pD->status);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_REVISION,
                         (UINT8 *)&pD->revisionId);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_PROGRAMMING_IF,
                         (UINT8 *)&pD->progIf);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_SUBCLASS,
                         (UINT8 *)&pD->subClass);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CLASS,
                         (UINT8 *)&pD->classCode);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CACHE_LINE_SIZE,
                         (UINT8 *)&pD->cacheLine);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_LATENCY_TIMER,
                         (UINT8 *)&pD->latency);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_HEADER_TYPE,
                         (UINT8 *)&pD->headerType);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BIST,
                         (UINT8 *)&pD->bist);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BASE_ADDRESS_0,
                         (UINT32 *)&pD->base0);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BASE_ADDRESS_1,
                         (UINT32 *)&pD->base1);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BASE_ADDRESS_2,
                         (UINT32 *)&pD->base2);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BASE_ADDRESS_3,
                         (UINT32 *)&pD->base3);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BASE_ADDRESS_4,
                         (UINT32 *)&pD->base4);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_BASE_ADDRESS_5,
                         (UINT32 *)&pD->base5);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CIS,
                         (UINT32 *)&pD->cis);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_SUB_VENDER_ID,
                         (UINT16 *)&pD->subVendorId);
        vxbPciConfigInWord (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_SUB_SYSTEM_ID,
                         (UINT16 *)&pD->subSystemId);
        vxbPciConfigInLong (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_EXPANSION_ROM,
                         (UINT32 *)&pD->romBase);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_DEV_INT_LINE,
                         (UINT8 *)&pD->intLine);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_DEV_INT_PIN,
                         (UINT8 *)&pD->intPin);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_MIN_GRANT,
                         (UINT8 *)&pD->minGrant);
        vxbPciConfigInByte (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_MAX_LATENCY,
                         (UINT8 *)&pD->maxLatency);
        vxbPciDheaderPrint (pD);

        if (pD->status & PCI_STATUS_NEW_CAP)
            vxbCapabShow (busCtrlID, busNo, deviceNo, funcNo, PCI_CFG_CAP_PTR);
        }

    return (OK);
    }


/*******************************************************************************
*
* vxbPciFindDeviceShow - find a PCI device and display the information
*
* This routine finds a device by deviceId, then displays the information.
*
* RETURNS: OK, or ERROR if this library is not initialized.
*
* ERRNO
*/

STATUS vxbPciFindDeviceShow
    (
    VXB_DEVICE_ID busCtrlID,
    int vendorId,   /* vendor ID */
    int deviceId,   /* device ID */
    int index       /* desired instance of device */
    )
    {
    int busNo;
    int deviceNo;
    int funcNo;

    if(busCtrlID == NULL)
	return(ERROR);

    if (vxbPciFindDevice (busCtrlID, vendorId, deviceId, index, &busNo, &deviceNo, &funcNo)
        == OK)
        {
        printf ("deviceId = 0x%.8x\n", deviceId);
        printf ("vendorId = 0x%.8x\n", vendorId);
        printf ("index =    0x%.8x\n", index);
        printf ("busNo =    0x%.8x\n", busNo);
        printf ("deviceNo = 0x%.8x\n", deviceNo);
        printf ("funcNo =   0x%.8x\n", funcNo);
        return(OK);
        }
    return (ERROR);
    }

/*******************************************************************************
*
* vxbPciFindClassShow - find a device by 24-bit class code
*
* This routine finds a device by its 24-bit PCI class code, then prints its
* information.
*
* RETURNS: OK, or ERROR if this library is not initialized.
*
* ERRNO
*/

STATUS vxbPciFindClassShow
    (
    VXB_DEVICE_ID busCtrlID,
    int classCode,  /* 24-bit class code */
    int index       /* desired instance of device */
    )
    {
    int busNo;
    int deviceNo;
    int funcNo;

    if(busCtrlID == NULL)
	return(ERROR);

    if (vxbPciFindClass (busCtrlID, classCode, index, &busNo, &deviceNo, &funcNo) == OK)
        {
        printf ("class code = 0x%.8x\n", classCode);
        printf ("index =      0x%.8x\n", index);
        printf ("busNo =      0x%.8x\n", busNo);
        printf ("deviceNo =   0x%.8x\n", deviceNo);
        printf ("funcNo =     0x%.8x\n", funcNo);
        return(OK);
        }
    return (ERROR);
    }

/*******************************************************************************
*
* vxbPciDheaderPrint - print a PCI device header
*
* This routine prints a PCI device header.
*
* RETURNS: N/A
*
* ERRNO
*/

LOCAL void vxbPciDheaderPrint
    (
    PCI_HEADER_DEVICE * pD
    )
    {
    printf ("vendor ID =                   0x%.4x\n", (ushort_t)pD->vendorId);
    printf ("device ID =                   0x%.4x\n", (ushort_t)pD->deviceId);
    printf ("command register =            0x%.4x\n", (ushort_t)pD->command);
    printf ("status register =             0x%.4x\n", (ushort_t)pD->status);
    printf ("revision ID =                 0x%.2x\n", (uchar_t)pD->revisionId);
    printf ("class code =                  0x%.2x\n", (uchar_t)pD->classCode);
    printf ("sub class code =              0x%.2x\n", (uchar_t)pD->subClass);
    printf ("programming interface =       0x%.2x\n", (uchar_t)pD->progIf);
    printf ("cache line =                  0x%.2x\n", (uchar_t)pD->cacheLine);
    printf ("latency time =                0x%.2x\n", (uchar_t)pD->latency);
    printf ("header type =                 0x%.2x\n", (uchar_t)pD->headerType);
    printf ("BIST =                        0x%.2x\n", (uchar_t)pD->bist);
    printf ("base address 0 =              0x%.8x\n", pD->base0);
    printf ("base address 1 =              0x%.8x\n", pD->base1);
    printf ("base address 2 =              0x%.8x\n", pD->base2);
    printf ("base address 3 =              0x%.8x\n", pD->base3);
    printf ("base address 4 =              0x%.8x\n", pD->base4);
    printf ("base address 5 =              0x%.8x\n", pD->base5);
    printf ("cardBus CIS pointer =         0x%.8x\n", pD->cis);
    printf ("sub system vendor ID =        0x%.4x\n", (ushort_t)pD->subVendorId);
    printf ("sub system ID =               0x%.4x\n", (ushort_t)pD->subSystemId);
    printf ("expansion ROM base address =  0x%.8x\n", pD->romBase);
    printf ("interrupt line =              0x%.2x\n", (uchar_t)pD->intLine);
    printf ("interrupt pin =               0x%.2x\n", (uchar_t)pD->intPin);
    printf ("min Grant =                   0x%.2x\n", (uchar_t)pD->minGrant);
    printf ("max Latency =                 0x%.2x\n", (uchar_t)pD->maxLatency);
    }

/*******************************************************************************
*
* vxbPciBheaderPrint - print a PCI-to-PCI bridge header
*
* This routine prints a PCI-to-PCI bridge header.
*
* RETURNS: N/A
*
* ERRNO
*/

LOCAL void vxbPciBheaderPrint
    (
    PCI_HEADER_BRIDGE * pB
    )
    {
    printf ("vendor ID =                   0x%.4x\n", (ushort_t)pB->vendorId);
    printf ("device ID =                   0x%.4x\n", (ushort_t)pB->deviceId);
    printf ("command register =            0x%.4x\n", (ushort_t)pB->command);
    printf ("status register =             0x%.4x\n", (ushort_t)pB->status);
    printf ("revision ID =                 0x%.2x\n", (uchar_t)pB->revisionId);
    printf ("class code =                  0x%.2x\n", (uchar_t)pB->classCode);
    printf ("sub class code =              0x%.2x\n", (uchar_t)pB->subClass);
    printf ("programming interface =       0x%.2x\n", (uchar_t)pB->progIf);
    printf ("cache line =                  0x%.2x\n", (uchar_t)pB->cacheLine);
    printf ("latency time =                0x%.2x\n", (uchar_t)pB->latency);
    printf ("header type =                 0x%.2x\n", (uchar_t)pB->headerType);
    printf ("BIST =                        0x%.2x\n", (uchar_t)pB->bist);
    printf ("base address 0 =              0x%.8x\n", pB->base0);
    printf ("base address 1 =              0x%.8x\n", pB->base1);
    printf ("primary bus number =          0x%.2x\n", (uchar_t)pB->priBus);
    printf ("secondary bus number =        0x%.2x\n", (uchar_t)pB->secBus);
    printf ("subordinate bus number =      0x%.2x\n", (uchar_t)pB->subBus);
    printf ("secondary latency timer =     0x%.2x\n", (uchar_t)pB->secLatency);
    printf ("IO base =                     0x%.2x\n", (uchar_t)pB->ioBase);
    printf ("IO limit =                    0x%.2x\n", (uchar_t)pB->ioLimit);
    printf ("secondary status =            0x%.4x\n", (ushort_t)pB->secStatus);
    printf ("memory base =                 0x%.4x\n", (ushort_t)pB->memBase);
    printf ("memory limit =                0x%.4x\n", (ushort_t)pB->memLimit);
    printf ("prefetch memory base =        0x%.4x\n", (ushort_t)pB->preBase);
    printf ("prefetch memory limit =       0x%.4x\n", (ushort_t)pB->preLimit);
    printf ("prefetch memory base upper =  0x%.8x\n", pB->preBaseUpper);
    printf ("prefetch memory limit upper = 0x%.8x\n", pB->preLimitUpper);
    printf ("IO base upper 16 bits =       0x%.4x\n", (ushort_t)pB->ioBaseUpper);
    printf ("IO limit upper 16 bits =      0x%.4x\n", (ushort_t)pB->ioLimitUpper);
    printf ("expansion ROM base address =  0x%.8x\n", pB->romBase);
    printf ("interrupt line =              0x%.2x\n", (uchar_t)pB->intLine);
    printf ("interrupt pin =               0x%.2x\n", (uchar_t)pB->intPin);
    printf ("bridge control =              0x%.4x\n", (ushort_t)pB->control);
    }

/*******************************************************************************
*
* vxbPciCBheaderPrint - print a PCI-to-CardBus bridge header
*
* This routine prints a PCI-to-CardBus bridge header.
*
* RETURNS: N/A
*
* ERRNO
*/

LOCAL void vxbPciCBheaderPrint
    (
    PCI_HEADER_CB_BRIDGE * pCB
    )
    {
    printf ("vendor ID =                   0x%.4x\n", (ushort_t)pCB->vendorId);
    printf ("device ID =                   0x%.4x\n", (ushort_t)pCB->deviceId);
    printf ("command register =            0x%.4x\n", (ushort_t)pCB->command);
    printf ("status register =             0x%.4x\n", (ushort_t)pCB->status);
    printf ("revision ID =                 0x%.2x\n", (uchar_t)pCB->revisionId);
    printf ("class code =                  0x%.2x\n", (uchar_t)pCB->classCode);
    printf ("sub class code =              0x%.2x\n", (uchar_t)pCB->subClass);
    printf ("programming interface =       0x%.2x\n", (uchar_t)pCB->progIf);
    printf ("cache line =                  0x%.2x\n", (uchar_t)pCB->cacheLine);
    printf ("latency time =                0x%.2x\n", (uchar_t)pCB->latency);
    printf ("header type =                 0x%.2x\n", (uchar_t)pCB->headerType);
    printf ("BIST =                        0x%.2x\n", (uchar_t)pCB->bist);
    printf ("base address 0 =              0x%.8x\n", pCB->base0);
    printf ("capabilities pointer =        0x%.2x\n", (uchar_t)pCB->capPtr);
    printf ("secondary status =            0x%.4x\n", (ushort_t)pCB->secStatus);
    printf ("primary bus number =          0x%.2x\n", (uchar_t)pCB->priBus);
    printf ("secondary bus number =        0x%.2x\n", (uchar_t)pCB->secBus);
    printf ("subordinate bus number =      0x%.2x\n", (uchar_t)pCB->subBus);
    printf ("secondary latency timer =     0x%.2x\n", (uchar_t)pCB->secLatency);
    printf ("memory base 0 =               0x%.8x\n", pCB->memBase0);
    printf ("memory limit 0 =              0x%.8x\n", pCB->memLimit0);
    printf ("memory base 1 =               0x%.8x\n", pCB->memBase1);
    printf ("memory limit 1 =              0x%.8x\n", pCB->memLimit1);
    printf ("IO base 0 =                   0x%.8x\n", pCB->ioBase0);
    printf ("IO limit 0 =                  0x%.8x\n", pCB->ioLimit0);
    printf ("IO base 1 =                   0x%.8x\n", pCB->ioBase1);
    printf ("IO limit 1 =                  0x%.8x\n", pCB->ioLimit1);
    printf ("interrupt line =              0x%.2x\n", (uchar_t)pCB->intLine);
    printf ("interrupt pin =               0x%.2x\n", (uchar_t)pCB->intPin);
    printf ("bridge control =              0x%.4x\n", (ushort_t)pCB->control);
    printf ("sub system vendor ID =        0x%.4x\n", (ushort_t)pCB->subVendorId);
    printf ("sub system ID =               0x%.4x\n", (ushort_t)pCB->subSystemId);
    printf ("16 bit legacy mode base =     0x%.8x\n", pCB->legacyBase);
    }

/*********************************************************************
*
* vxbPciFuncBarShow - show the value contained in a BAR
*
* This function decodes the value of a single BAR on a single
* bus, device, function, and displays the information.
*
* RETURNS: N/A
*
* ERRNO
*/

LOCAL void vxbPciFuncBarShow
    (
    VXB_DEVICE_ID busCtrlID,
    int bus,            /* bus */
    int device,         /* device */
    int function,       /* function */
    int barNo           /* BAR index */
    )
    {
    UINT32 barVal;
    int space;
    int prefetch;
    int offset;

    if(busCtrlID == NULL)
	return;

    offset = PCI_CFG_BASE_ADDRESS_0 + (barNo * sizeof(UINT32));
    vxbPciConfigInLong(busCtrlID,bus, device, function,
                    offset, &barVal);

    /* check if BAR implemented */
    if ( barVal == 0 || barVal == 0xffffffff )
        return;

    if ( ( barVal & 0x01 ) == 0x01 )
        printf("\tbar%d in I/O space @ 0x%08x\n",
               barNo, (barVal & (~0x00000001)));
    else
        {
        prefetch = ( barVal >> 3 ) & 0x01;
        space = (barVal >> 1 ) & 0x03;
        barVal = barVal & ~ 0x0f;
        printf("\tbar%d in %s%s mem space @ 0x%08x\n", barNo,
               prefetch ? "prefetchable " : "",
               ( space == 0x00 ) ? "32-bit" :
               ( space == 0x02) ? "64-bit" :
               "reserved",
               barVal);
        }
    }

/*********************************************************************
*
* vxbPciStatusWordShow - show the decoded value of the status word
*
* This routine reads the status word from the specified
* bus, device, function, and displays the information.
*
* RETURNS: OK, always.
*
* ERRNO
*/

LOCAL STATUS vxbPciStatusWordShow
    (
    VXB_DEVICE_ID busCtrlID,
    int bus,        /* bus */
    int device,     /* device */
    int function    /* function */
    )
    {
    UINT16 status;

    if(busCtrlID == NULL)
	return(ERROR);

    vxbPciConfigInWord (busCtrlID, bus, device, function, PCI_CFG_STATUS, &status);

    printf("\tstatus=0x%04x (", status);

    if ( status & PCI_STATUS_NEW_CAP )
        printf(" CAP");

    if ( status & PCI_STATUS_66_MHZ )
        printf(" 66MHZ");

    if ( status & PCI_STATUS_UDF )
        printf(" UDF");

    if ( status & PCI_STATUS_FAST_BB )
        printf(" FBTB");

    if ( status & PCI_STATUS_DATA_PARITY_ERR )
        printf(" DATA_PARITY_ERR");

    printf(" DEVSEL=%x", ((status & 0x0600) >> 9 ));

    if ( status & PCI_STATUS_TARGET_ABORT_GEN )
        printf(" TGT_ABORT_GEN");

    if ( status & PCI_STATUS_TARGET_ABORT_RCV )
        printf(" TGT_ABORT_RCV");

    if ( status & PCI_STATUS_MASTER_ABORT_RCV )
        printf(" MSTR_ABORT_RCV");

    if ( status & PCI_STATUS_ASSERT_SERR )
        printf(" ASSERT_SERR");

    if ( status & PCI_STATUS_PARITY_ERROR )
        printf(" PARITY_ERR");

    printf(" )\n");

    return(OK);
    }

/*********************************************************************
*
* vxbPciCmdWordShow - show the decoded value of the command word
*
* This routine reads the command word from the specified
* bus, device, function, and displays the information.
*
* RETURNS: OK, always.
*
* ERRNO
*/

LOCAL STATUS vxbPciCmdWordShow
    (
    VXB_DEVICE_ID busCtrlID,
    int bus,        /* bus */
    int device,     /* device */
    int function    /* function */
    )
    {
    UINT16 command;

    if(busCtrlID == NULL)
	return(ERROR);

    vxbPciConfigInWord (busCtrlID, bus,device,function,
                     PCI_CFG_COMMAND, &command);

    printf("\tcommand=0x%04x (", command);

    if ( command & PCI_CMD_IO_ENABLE )
        printf(" IO_ENABLE");

    if ( command & PCI_CMD_MEM_ENABLE )
        printf(" MEM_ENABLE");

    if ( command & PCI_CMD_MASTER_ENABLE )
        printf(" MASTER_ENABLE");

    if ( command & PCI_CMD_MON_ENABLE )
        printf(" MON_ENABLE");

    if ( command & PCI_CMD_WI_ENABLE )
        printf(" WI_ENABLE");

    if ( command & PCI_CMD_SNOOP_ENABLE )
        printf(" SNOOP_ENABLE");

    if ( command & PCI_CMD_PERR_ENABLE )
        printf(" PERR_ENABLE");

    if ( command & PCI_CMD_WC_ENABLE )
        printf(" WC_ENABLE");

    if ( command & PCI_CMD_SERR_ENABLE )
        printf(" SERR_ENABLE");

    if ( command & PCI_CMD_FBTB_ENABLE )
        printf(" FBTB_ENABLE");

    printf(" )\n");
    return(OK);
    }

/*********************************************************************
*
* vxbPciConfigStatusWordShow - show the decoded value of the status word
*
* This routine reads the value of the status word for the specified
* bus, device, function and displays the information.
*
* RETURNS: OK, always.
*
* ERRNO
*/

STATUS vxbPciConfigStatusWordShow
    (
    VXB_DEVICE_ID busCtrlID,
    int bus,        /* bus */
    int device,     /* device */
    int function,   /* function */
    void *pArg      /* ignored */
    )
    {
    if(busCtrlID == NULL)
	return(ERROR);

    printf("[%d,%d,%d] ",bus,device,function);
    vxbPciStatusWordShow(busCtrlID, bus,device,function);
    return(OK);
    }

/*********************************************************************
*
* vxbPciConfigCmdWordShow - show the decoded value of the command word
*
* This routine reads the value of the command word for the specified
* bus, device, function and displays the information.
*
* RETURNS: OK, always.
*
* ERRNO
*/

STATUS vxbPciConfigCmdWordShow
    (
    VXB_DEVICE_ID busCtrlID,
    int bus,        /* bus */
    int device,     /* device */
    int function,   /* function */
    void *pArg      /* ignored */
    )
    {
    if(busCtrlID == NULL)
	return(ERROR);

    printf("[%d,%d,%d] ",bus,device,function);
    vxbPciCmdWordShow(busCtrlID, bus,device,function);
    return(OK);
    }

/*********************************************************************
*
* vxbPciConfigFuncShow - show configuration details about a function
*
* This routine reads various information from the specified
* bus, device, function, and displays the information.
*
* RETURNS: OK, always.
*
* ERRNO
*/

STATUS vxbPciConfigFuncShow
    (
    VXB_DEVICE_ID busCtrlID,
    int bus,        /* bus */
    int device,     /* device */
    int function,   /* function */
    void *pArg      /* ignored */
    )
    {
    UINT8  clsCode;
    UINT8  subClass;
    UINT8  secBus;
    int    numBars = 6; /* most devices have 6, but not bridges */
    UINT16 memBase;
    UINT16 memLimit;
    UINT32 memBaseU;
    UINT32 memLimitU;
    UINT8  ioBase;
    UINT8  ioLimit;
    UINT16 ioBaseU;
    UINT16 ioLimitU;
    UINT8  headerType;
    UINT16 cmdReg;
    int i;

    if(busCtrlID == NULL)
	return(ERROR);

    printf("[%d,%d,%d] type=",bus,device,function);
    vxbPciConfigInByte (busCtrlID, bus, device, function,
                     PCI_CFG_CLASS, &clsCode);

    vxbPciConfigInByte (busCtrlID, bus,device,function,
                    PCI_CFG_HEADER_TYPE, &headerType);

    if ( ( headerType & PCI_HEADER_TYPE_MASK ) == 1 )
        {
        /* type 1 header has only 2 BARs */
        numBars = 2;
        }

    if ((headerType & PCI_HEADER_TYPE_MASK) == PCI_HEADER_PCI_CARDBUS)
        {
        /* CardBus bridge header has 1 BAR */
        numBars = 1;
        }

    switch (clsCode)
        {
        case PCI_CLASS_PRE_PCI20:     printf("BEFORE_STD\n"); break;
        case PCI_CLASS_MASS_STORAGE:  printf("MASS STORAGE\n"); break;
        case PCI_CLASS_NETWORK_CTLR:  printf("NET_CNTLR\n"); break;
        case PCI_CLASS_DISPLAY_CTLR:  printf("DISP_CNTLR\n"); break;
        case PCI_CLASS_MMEDIA_DEVICE: printf("MULTI_MEDIA\n"); break;
        case PCI_CLASS_MEM_CTLR:      printf("MEM_CNTLR\n"); break;
        case PCI_CLASS_COMM_CTLR:     printf("COMMUNICATION\n"); break;
        case PCI_CLASS_BASE_PERIPH:   printf("PERIPHERAL\n"); break;
        case PCI_CLASS_INPUT_DEVICE:  printf("INPUT\n"); break;
        case PCI_CLASS_DOCK_DEVICE:   printf("DOCKING STATION\n"); break;
        case PCI_CLASS_PROCESSOR:     printf("PROCESSOR\n"); break;
        case PCI_CLASS_SERIAL_BUS:    printf("SERIAL BUS\n"); break;
        case PCI_CLASS_WIRELESS:      printf("WIRELESS\n"); break;
        case PCI_CLASS_INTLGNT_IO:    printf("INTELLIGENT_IO\n"); break;
        case PCI_CLASS_SAT_COMM:      printf("SATELLITE\n"); break;
        case PCI_CLASS_EN_DECRYPTION: printf("ENCRYPTION DEV\n"); break;
        case PCI_CLASS_DAQ_DSP:       printf("DATA ACQUISITION DEV\n"); break;
        case PCI_CLASS_UNDEFINED:     printf("OTHER DEVICE\n"); break;

        case PCI_CLASS_BRIDGE_CTLR:
            secBus = 0;
            vxbPciConfigInByte (busCtrlID, bus, device, function,
                             PCI_CFG_SUBCLASS, &subClass);

            switch (subClass)
                {
                case PCI_SUBCLASS_HOST_PCI_BRIDGE:
                    printf("HOST");
                    break;

                case PCI_SUBCLASS_ISA_BRIDGE:
                    printf("ISA");
                    break;

                case PCI_SUBCLASS_EISA_BRIDGE:
                    printf("EISA");
                    break;

                case PCI_SUBCLASS_MCA_BRIDGE:
                    printf("MC");
                    break;

                case PCI_SUBCLASS_P2P_BRIDGE:
                    printf("P2P");
                    vxbPciConfigInByte (busCtrlID, bus, device, function,
                                     PCI_CFG_SECONDARY_BUS, &secBus);
                    break;

                case PCI_SUBCLASS_PCMCIA_BRIDGE:
                    printf("PCMCIA");
                    break;

                case PCI_SUBCLASS_CARDBUS_BRIDGE:
                    printf("CARDBUS");
                    vxbPciConfigInByte (busCtrlID, bus, device, function,
                                     PCI_CFG_SECONDARY_BUS, &secBus);
                    break;

                case PCI_SUBCLASS_RACEWAY_BRIDGE:
                    printf("RACEWAY");
                    break;

                default:
                    printf("UNKNOWN (0x%02x)", subClass);
                    break;
                }

            printf(" BRIDGE");
            if ( secBus != 0 )
                {
                printf(" to [%d,0,0]", secBus);
                printf("\n");

                vxbPciConfigInWord (busCtrlID, bus,device,function,
                                PCI_CFG_COMMAND, &cmdReg);

                if (subClass == PCI_SUBCLASS_CARDBUS_BRIDGE)
                    {
                    UINT32 memBase;
                    UINT32 memLimit;
                    UINT32 ioBase;
                    UINT32 ioLimit;

                    printf ("\tbase/limit:\n");

                    if (cmdReg & PCI_CMD_MEM_ENABLE)
                        {
                        for (i = 0; i < 2; i++)
                            {
                            vxbPciConfigInLong (busCtrlID, bus, device, function,
                                             PCI_CFG_CB_MEM_BASE_0 + i * 8,
                                             &memBase);
                            vxbPciConfigInLong (busCtrlID, bus, device, function,
                                             PCI_CFG_CB_MEM_LIMIT_0 + i * 8,
                                             &memLimit);
                            printf ("\t  mem%d=0x%08x/0x%08x\n", i,
                                    memBase, memLimit | 0x0fff);
                            }
                        }

                    if (cmdReg & PCI_CMD_IO_ENABLE)
                        {
                        for (i = 0; i < 2; i++)
                            {
                            vxbPciConfigInLong (busCtrlID, bus, device, function,
                                             PCI_CFG_CB_IO_BASE_0 + i * 8,
                                             &ioBase);
                            vxbPciConfigInLong (busCtrlID, bus, device, function,
                                             PCI_CFG_CB_IO_LIMIT_0 + i * 8,
                                             &ioLimit);
                            printf ("\t  I/O%d=0x%08x/0x%08x\n", i,
                                    ioBase, ioLimit);
                            }
                        }

                    break;
                    }

                if ( cmdReg & PCI_CMD_MEM_ENABLE )
                    {
                    vxbPciConfigInWord (busCtrlID, bus,device,function,
                                    PCI_CFG_MEM_BASE, &memBase);
                    vxbPciConfigInWord (busCtrlID, bus,device,function,
                                    PCI_CFG_MEM_LIMIT, &memLimit);
                    printf("\tbase/limit:\n");
                    printf("\t  mem=   0x%04x0000/0x%04xffff\n",
                           memBase & 0xfff0, memLimit | 0x000f);

                    vxbPciConfigInWord (busCtrlID, bus,device,function,
                                    PCI_CFG_PRE_MEM_BASE, &memBase);
                    vxbPciConfigInWord (busCtrlID, bus,device,function,
                                    PCI_CFG_PRE_MEM_LIMIT, &memLimit);
                    if ( ( memBase & 0x000f ) == 0x0001 )
                        {
                        /* 64-bit memory */
                        vxbPciConfigInLong (busCtrlID, bus,device,function,
                                        PCI_CFG_PRE_MEM_BASE_U,
                                        &memBaseU);
                        vxbPciConfigInLong (busCtrlID, bus,device,function,
                                        PCI_CFG_PRE_MEM_LIMIT_U,
                                        &memLimitU);
                        printf("\t  preMem=0x%08x%04x0000/"
                               "0x%08x%04xffff\n",
                               memBaseU, memBase & 0xfff0,
                               memLimitU, memLimit | 0x000f);
                        }
                    else
                        printf("\t  preMem=0x%04x0000/0x%04xffff\n",
                               memBase & 0xfff0, memLimit | 0x000f);
                    }

                if ( cmdReg & PCI_CMD_IO_ENABLE )
                    {
                    vxbPciConfigInByte (busCtrlID, bus,device,function,
                                    PCI_CFG_IO_BASE, &ioBase);
                    vxbPciConfigInByte (busCtrlID, bus,device,function,
                                    PCI_CFG_IO_LIMIT, &ioLimit);
                    if ( ( ioBase & 0x0f ) == 0x01 )
                        {
                        /* 32-bit I/O */
                        vxbPciConfigInWord (busCtrlID, bus,device,function,
                                        PCI_CFG_IO_BASE_U, &ioBaseU);
                        vxbPciConfigInWord (busCtrlID, bus,device,function,
                                        PCI_CFG_IO_LIMIT_U, &ioLimitU);
                        printf("\t  I/O=   0x%04x%02x00/0x%04x%02xff\n",
                               ioBaseU, (ioBase & 0xf0),
                               ioLimitU, (ioLimit | 0x0f));
                        }
                    else
                        printf("\t  I/O=   0x%02x00/0x%02xff\n",
                               (ioBase & 0xf0), (ioLimit | 0x0f));
                    }
                }
            else
                printf("\n");

            break;

        default:
            printf("UNKNOWN!\n");
        }

    vxbPciStatusWordShow(busCtrlID,bus, device, function);
    vxbPciCmdWordShow(busCtrlID,bus, device, function);

    for (i = 0; i < numBars; i++)
        vxbPciFuncBarShow(busCtrlID,bus, device, function, i);

    return(OK);
    }

/*********************************************************************
*
* vxbPcixCapabShow - show the PCI-X capabilities
*
* This routine displays the PCI-X specific information.
*
* RETURNS: N/A
*
* ERRNO
*/
LOCAL void vxbPcixCapabShow
    (
    VXB_DEVICE_ID busCtrlID,
    UINT        bus,           /* bus */
    UINT        device,        /* device */
    UINT        function,       /* function */
    UINT        offset         /* offset of capability */
    )
    {
    UINT8 headerType;
    UINT16 cmd, status, secStat;
    UINT32 stat, upstr, dwnstr;

    if(busCtrlID == NULL)
	return;

    vxbPciConfigInByte (busCtrlID, bus, device, function, PCI_CFG_HEADER_TYPE,
                     &headerType);

    switch (headerType)
        {
        case PCI_HEADER_TYPE0: /* Regular Device */
            {
            printf("PCI-X \n");
            vxbPciConfigInWord (busCtrlID, bus, device, function, offset + PCI_X_CMD, &cmd);
            vxbPciConfigInLong (busCtrlID, bus, device, function, offset + PCI_X_STATUS, &stat);

            printf("\tCommand: 0x%04x\n", cmd);
            printf("\tStatus:  0x%08x\n", stat);
            break;
            }
        case PCI_HEADER_TYPE_BRIDGE:
            {
            printf("PCI-X bridge \n");
            vxbPciConfigInWord (busCtrlID, bus, device, function, offset + PCI_X_SECSTAT, &secStat);
            vxbPciConfigInWord (busCtrlID, bus, device, function, offset + PCI_X_PRISTAT, &status);
            vxbPciConfigInLong (busCtrlID, bus, device, function, offset + PCI_X_UP_SXACTION_CTRL, &upstr);
            vxbPciConfigInLong (busCtrlID, bus, device, function, offset + PCI_X_DWN_SXACTION_CTRL, &dwnstr);

            printf("\tSecondary Status:   0x%04x\n", secStat);
            printf("\tPrimary Status:     0x%08x\n", status);
            printf("\tUpstream Control:   0x%08x\n", upstr);
            printf("\tDownstream Control: 0x%08x\n", dwnstr);
            break;
            }
        }
    }

/*********************************************************************
*
* vxbMsiCapabShow - show the MSI capabilities
*
* This routine displays the MSI specific information.
*
* RETURNS: N/A
*
* ERRNO
*/
LOCAL void vxbMsiCapabShow
    (
    VXB_DEVICE_ID busCtrlID,
    UINT        bus,           /* bus */
    UINT        device,        /* device */
    UINT        function,      /* function */
    UINT        offset         /* offset of capability */
    )
    {
    UINT8 ctlReg;
    UINT16 data;
    UINT32 addr;

    if(busCtrlID == NULL)
	return;

    vxbPciConfigInByte (busCtrlID, bus, device, function, offset + PCI_MSI_CTL, &ctlReg);

    printf("Message Signaled Interrupts: 0x%x %s, %s, MMC: %d MME: %d\n", offset,
           (ctlReg & PCI_MSI_CTL_ENABLE) == 0x00  ? "Disabled" : "Enabled",
           (ctlReg & PCI_MSI_CTL_64BIT)  == 0x00  ? "32-bit" : "64-bit",
           (ctlReg & PCI_MSI_CTL_MSG_ALLOC) >> 4,
           (ctlReg & PCI_MSI_CTL_MSG_MAX) >> 1);

        printf("\tAddress: ");
        if (ctlReg & PCI_MSI_CTL_64BIT)
          {
            vxbPciConfigInLong (busCtrlID, bus, device, function, offset + PCI_MSI_ADDR_HI, &addr);
            vxbPciConfigInWord (busCtrlID, bus, device, function, offset + PCI_MSI_DATA_64, &data);
            printf("%08x", addr);
          }
        else
            vxbPciConfigInWord (busCtrlID, bus, device, function, offset + PCI_MSI_DATA_32, &data);

        vxbPciConfigInLong (busCtrlID, bus, device, function, offset + PCI_MSI_ADDR_LO, &addr);
        printf("%08x  Data: 0x%04x\n", addr, data);

    }



/*********************************************************************
*
* latL0s - return string for latency levels
*
* RETURNS: string for latency levels
*
* ERRNO
*/

LOCAL const char *latL0s
    (
    int latVal
    )
    {
      static const char *lat[] =
          {
          "<64ns",
          "<128ns",
          "<256ns",
          "<512ns",
          "<1us",
          "<2us",
          "<4us",
          ">4us"
           };
      return lat[latVal];
    }

/*********************************************************************
*
* latL1 - return string for latency levels
*
* RETURNS: string for latency levels
*
* ERRNO
*/
LOCAL const char *latL1
    (
    int latVal
    )
    {
    static const char *lat[] =
        {
        "<1us",
        "<2us",
        "<4us",
        "<8us",
        "<16us",
        "<32us",
        "<64us",
        ">64us"
        };
    return lat[latVal];
    }

/*********************************************************************
*
* limScale - returns scaling value from negative power
*
* RETURNS:  scaling value from negative power
*
* ERRNO
*/

LOCAL int limScale
    (
    int scaleVal
    )
    {
    static const int scale[4] =
    {
    0,
    -1,
    -2,
    -3
    };
    return scale[scaleVal];
    }

/*********************************************************************
*
* vxbPcieDevCap - show the PCIe Device capabilities
*
* This routine displays the PCI Express Device capabilities
* information.
*
* RETURNS: N/A
*
* ERRNO
*/
LOCAL void vxbPcieDevCap
    (
    VXB_DEVICE_ID busCtrlID,
    UINT        bus,           /* bus */
    UINT        device,        /* device */
    UINT        function,      /* function */
    UINT        offset,        /* offset of capability */
    UINT        type           /* device type */
    )
    {
    UINT32 devCap;
    UINT16 devCtl;

    if(busCtrlID == NULL)
	return;

    vxbPciConfigInLong (busCtrlID, bus, device, function, offset + PCI_EXP_DEVCAP_REG, &devCap);

    printf("\tDevice: Max Payload: %d bytes",
           128 << (devCap & PCI_EXP_DEVCAP_PAYLOAD));
    if (devCap & PCI_EXP_DEVCAP_PHANTOM)
        printf(", Phantom Funcs %d msb",
               (devCap & PCI_EXP_DEVCAP_PHANTOM) >> 3);
    printf(", Extended Tag: %d-bit\n",
           ((devCap & PCI_EXP_DEVCAP_EXT_TAG) >> 5) == 0 ? 5:8);

    printf("\t\tAcceptable Latency: L0 - %s, L1 - %s\n",
           latL0s((devCap & PCI_EXP_DEVCAP_L0S) >> 6),
           latL1((devCap & PCI_EXP_DEVCAP_L1) >> 9));

    if ((type == PCI_EXP_TYPE_ENDPOINT) ||
        (type == PCI_EXP_TYPE_LEG_END)  ||
        (type == PCI_EXP_TYPE_UPSTREAM) ||
        (type == PCI_EXP_TYPE_PCI2EXP))
        {
        if (devCap & PCI_EXP_DEVCAP_ATTN_BUTTON)
            printf("\tAttn Button");
        if (devCap & PCI_EXP_DEVCAP_ATTN_IND)
            printf(", Attn Indicator");
        if (devCap & PCI_EXP_DEVCAP_PWR_IND)
            printf(", Pwr Indicator\n");
        }

    if (type == PCI_EXP_TYPE_UPSTREAM)
        printf("\tSlot Power Limit (Watts) %d e%d\n",
               ((devCap & PCI_EXP_DEVCAP_PWR_VAL_LIMIT) >> 18),
                limScale((devCap & PCI_EXP_DEVCAP_PWR_SCL_LIMIT) >> 26));

    vxbPciConfigInWord (busCtrlID, bus, device, function, offset + PCI_EXP_DEVCTL_REG, &devCtl);

    printf("\t\tErrors Enabled: ");
    if (devCtl &  PCI_EXP_DEVCTL_CERR_ENB)
        printf(" Correctable");
    if (devCtl &  PCI_EXP_DEVCTL_NFERR_ENB)
        printf(" Non-Fatal");
    if (devCtl &  PCI_EXP_DEVCTL_FERR_ENB)
        printf(" Fatal");
    if (devCtl &  PCI_EXP_DEVCTL_URREP_ENB)
        printf(" Unsupported Request");
    if (devCtl &  PCI_EXP_DEVCTL_RLX_ORD_ENB)
        printf("Relaxed Ordering");
    if (devCtl &  PCI_EXP_DEVCTL_EXT_TAG)
        printf(" Extended Tag");
    if (devCtl &  PCI_EXP_DEVCTL_PHANTOM)
        printf(" Phantom Funcs");
    if (devCtl &  PCI_EXP_DEVCTL_AUX_PM_ENB)
        printf(" AUX Pwr PM");
    if (devCtl &  PCI_EXP_DEVCTL_NOSNOOP_ENB)
        printf(" No Snoop");

    printf("\n\t\t");

    if (devCtl & PCI_EXP_DEVCTL_PAYLOAD)
        printf("Max Payload %d bytes ",
               128 << ((devCtl & PCI_EXP_DEVCTL_PAYLOAD) >> 5));
    if (devCtl & PCI_EXP_DEVCTL_READ_REQ)
        printf("Max Read Request %d bytes\n",
               128 << ((devCtl & PCI_EXP_DEVCTL_READ_REQ) >> 12));

    }

/*********************************************************************
*
* limSpeed - returns string for speed
*
* RETURNS:   string for speed
*
* ERRNO
*/
LOCAL char *linkSpeed
    (
    UINT speed
    )
    {
    switch (speed)
        {
        case 1:
            return "2.5Gb/s";
        default:
            return "unknown";
        }
    }

/*********************************************************************
*
* aspm - returns string for latency level
*
* RETURNS:   string for latency level
*
* ERRNO
*/
LOCAL char *aspm
    (
    int val
    )
    {
    switch (val)
        {
        case 1:
            return "L0s";
        case 3:
            return "L0s & L1";
        default:
            return "unknown";
        }
    }

/*********************************************************************
*
* aspmEnable - returns string for which level is enabled
*
* RETURNS:  string for which level is enabled
*
* ERRNO
*/
LOCAL const char *aspmEnable
    (
    int val
    )
    {
    static const char *enab[] =
        {
        "Disabled",
        "L0s",
        "L1",
        "L0s & L1"
        };
    return enab[val];
    }

/*********************************************************************
*
* vxbPcieLinkCap - show the PCIe Link capabilities
*
* This routine displays the PCI Express Link capabilities
* information.
*
* RETURNS: N/A
*
* ERRNO
*/
LOCAL void vxbPcieLinkCap
    (
    VXB_DEVICE_ID busCtrlID,
    UINT        bus,           /* bus */
    UINT        device,        /* device */
    UINT        function,      /* function */
    UINT        offset,        /* offset of capability */
    UINT        type           /* device type */
    )
    {
    UINT32 lnkCap;
    UINT16 lnkVal;

    if(busCtrlID == NULL)
	return;

    vxbPciConfigInLong (busCtrlID, bus, device, function, offset + PCI_EXP_LNKCAP_REG, &lnkCap);

    printf("\tLink: MAX Speed - %s, MAX Width - by %d Port - %d ASPM - %s\n",
           linkSpeed(lnkCap & PCI_EXP_LNKCAP_LNK_SPD),
           (lnkCap & PCI_EXP_LNKCAP_LNK_WDTH) >> 4,
           lnkCap >> 24,
           aspm((lnkCap & PCI_EXP_LNKCAP_ASPM)>>10) );

    printf("\t\tLatency: L0s - %s, L1 - %s\n",
           latL0s((lnkCap & PCI_EXP_LNKCAP_L0S_LAT) >> 12),
           latL1((lnkCap & PCI_EXP_LNKCAP_L1_LAT) >> 15));

    vxbPciConfigInWord (busCtrlID, bus, device, function, offset + PCI_EXP_LNKCTL_REG, &lnkVal);

    printf("\t\tASPM - %s,", aspmEnable(lnkVal & PCI_EXP_LNKCTL_ASPM));

    if ((type == PCI_EXP_TYPE_ROOT_PORT) ||
        (type == PCI_EXP_TYPE_ENDPOINT)  ||
        (type == PCI_EXP_TYPE_LEG_END))

        printf(" RCB - %dbytes", lnkVal & PCI_EXP_LNKCTL_RCB ? 128 : 64);

    if (lnkVal & PCI_EXP_LNKCTL_LNK_DIS)
        printf(" Link Disabled");

    if (lnkVal & PCI_EXP_LNKCTL_CCC)
        printf(" Common Clock");

    if (lnkVal & PCI_EXP_LNKCTL_EXT_SYNC)
        printf(" Extended Sync");

    printf("\n");

    vxbPciConfigInWord (busCtrlID, bus, device, function, offset + PCI_EXP_LNKSTA_REG, &lnkVal);
    printf("\t\tSpeed - %s, Width - by %d\n",
           linkSpeed(lnkVal & PCI_EXP_LNKSTA_LNK_SPD),
           (lnkVal & PCI_EXP_LNKSTA_LNK_WDTH) >> 4);
    }

/*********************************************************************
*
* indicator - returns string for incator state
*
* RETURNS:  string for indicator state
*
* ERRNO
*/

LOCAL const char *indicator
    (
    int val
    )
    {
    static const char *state[] =
        {
        "Unknown",
        "On",
        "Blink",
        "Off"
        };
    return state[val];
    }

/*********************************************************************
*
* vxbPcieSlotCap - displays the PCI express slot capabilities
*
* RETURNS:  N/A
*
* ERRNO
*/
LOCAL void vxbPcieSlotCap
    (
    VXB_DEVICE_ID busCtrlID,
    UINT        bus,           /* bus */
    UINT        device,        /* device */
    UINT        function,      /* function */
    UINT        offset         /* offset of capability */
    )
    {
    UINT32 sltCap;
    UINT16 sltCtl;

    if(busCtrlID == NULL)
	return;

    vxbPciConfigInLong (busCtrlID, bus, device, function, offset + PCI_EXP_SLTCAP_REG, &sltCap);

    printf("\tSlot:");
    if (sltCap & PCI_EXP_SLTCAP_ATTN_BUT)
        printf(" Attn Button");
    if (sltCap & PCI_EXP_SLTCAP_PWR_CTL)
        printf(" Power Controller");
    if (sltCap & PCI_EXP_SLTCAP_MRL)
        printf(" MRL Sensor");
    if (sltCap & PCI_EXP_SLTCAP_PWR_IND)
        printf(" Pwr Indicator");
    if (sltCap & PCI_EXP_SLTCAP_HPL_CAP)
        printf(" Hot-Plug");
    if (sltCap & PCI_EXP_SLTCAP_HPL_SUP)
        printf(" Hot-Plug Surprise");

    printf("\t\tSlot #%d, MAX Slot Power Limit (Watts) %d e%d\n",
           sltCap >> 19,
           ((sltCap & PCI_EXP_SLTCAP_PWR_VAL_LIMIT) >> 7),
           limScale((sltCap & PCI_EXP_SLTCAP_PWR_SCL_LIMIT) >> 15));

    vxbPciConfigInWord (busCtrlID, bus, device, function, offset + PCI_EXP_SLTCTL_REG, &sltCtl);

    printf("\tEnabled:");
    if (sltCtl & PCI_EXP_SLTCTL_ATTN_BUT_ENB)
        printf(" Attn Button Pressed");
    if (sltCtl & PCI_EXP_SLTCTL_PWRFLT_DET_ENB)
        printf(" Power Fault Detected");
    if (sltCtl & PCI_EXP_SLTCTL_MRLSNSR_ENB)
        printf(" MRL Sensor Changed");
    if (sltCtl & PCI_EXP_SLTCTL_PRES_DET_ENB)
        printf(" Presence Detect");
    if (sltCtl & PCI_EXP_SLTCTL_CCMPLT_ENB)
        printf(" Cmd Complete Int");
    if (sltCtl & PCI_EXP_SLTCTL_HPLINT_ENB)
        printf(" Hot-Plug Int");

     printf("\n");

    if (sltCtl & PCI_EXP_SLTCTL_ATTN_INDCTL)
        printf("\t\tAttn Indicator %s",
               indicator((sltCtl & PCI_EXP_SLTCTL_ATTN_INDCTL) >> 6));
    if (sltCtl & PCI_EXP_SLTCTL_PWR_INDCTL)
        printf(" Power Indicator %s",
               indicator((sltCtl & PCI_EXP_SLTCTL_PWR_INDCTL) >> 8));
    if (sltCtl & PCI_EXP_SLTCTL_PWR_CTLRCTL)
        printf(" Power Controller %s",
               (sltCtl & PCI_EXP_SLTCTL_PWR_INDCTL) >> 10 == 0 ?
               "on":"off");
    }

/*********************************************************************
*
* vxbPcieCapabShow - show the MSI capabilities
*
* This routine displays the MSI specific information.
*
* RETURNS: N/A
*
* ERRNO
*/
LOCAL void vxbPcieCapabShow
    (
    VXB_DEVICE_ID busCtrlID,
    UINT        bus,           /* bus */
    UINT        device,        /* device */
    UINT        function,      /* function */
    UINT        offset         /* offset of capability */
    )
    {
    UINT16 capReg, type, slot = 0;

    printf("PCIe: ");

    if(busCtrlID == NULL)
	return;

    vxbPciConfigInWord (busCtrlID, bus, device, function, offset + PCI_EXP_CAP_REG, &capReg);

    type = (capReg & PCI_EXP_CAP_PORT_TYPE) >> 4;

        switch (type)
          {
          case PCI_EXP_TYPE_ENDPOINT:
            printf("Endpoint");
            break;
          case PCI_EXP_TYPE_LEG_END:
            printf("Legacy Endpoint");
            break;
          case PCI_EXP_TYPE_ROOT_PORT:
            slot = capReg & PCI_EXP_CAP_SLOT_ADDON;
            printf("Root Port");
            if (slot)
               printf("- Slot");
            break;
          case PCI_EXP_TYPE_UPSTREAM:
            printf("Upstream Port");
            break;
          case PCI_EXP_TYPE_DOWNSTREAM:
             slot = capReg & PCI_EXP_CAP_SLOT_ADDON;
            printf("Downstream Port");
            if (slot)
               printf("- Slot");
            break;
          case PCI_EXP_TYPE_PCI2EXP:
            printf("PCI/PCI-X to Express Bridge");
            break;
          default:
            printf("Unknown");
        }
        printf(", IRQ %d\n", (capReg & PCI_EXP_CAP_IRQ) >> 9);

        vxbPcieDevCap(busCtrlID, bus, device, function, offset, type);

        vxbPcieLinkCap(busCtrlID, bus, device, function, offset, type);

        if (slot)
          vxbPcieSlotCap(busCtrlID, bus, device, function, offset);

    if (type == PCI_EXP_TYPE_ROOT_PORT)
        {
        vxbPciConfigInWord (busCtrlID, bus, device, function, offset + PCI_EXP_RTCTL_REG, &capReg);

        printf("\tRoot Control Enabled: ");
        if ( capReg & PCI_EXP_RTCTL_SECE_ENB)
            printf("Correctable ");
        if ( capReg & PCI_EXP_RTCTL_SENFE_ENB)
            printf("System Error (NF) ");
        if ( capReg & PCI_EXP_RTCTL_SEFE_ENB)
            printf("System Error (F) ");
        if ( capReg & PCI_EXP_RTCTL_PMEI_ENB)
            printf("PME Interrupt ");
        printf("\n");
        }

    }

/*********************************************************************
*
* vxbCapabShow - show the PCI capabilities
*
* This routine reads the capabilities pointer ID, traverses the
* capability linked list till the pointer is null, and prints the
* information.
*
* RETURNS: N/A
*
* ERRNO
*/
LOCAL void vxbCapabShow
    (
    VXB_DEVICE_ID busCtrlID,
    UINT        bus,            /* bus */
    UINT        device,         /* device */
    UINT        function,       /* function */
    UINT8       capOffset       /* Capabilities Ptr Offset */
    )
    {
    UINT8 devCapID, cap_id, cap_id_next;

    if(busCtrlID == NULL)
	return;

    /* Capabilities List Implemented: Get first capability ID */

    vxbPciConfigInByte (busCtrlID, bus, device, function, capOffset, &devCapID);

    /* Longword Align */
    devCapID &= ~0x03;

    while (devCapID)
        {
        printf("Capabilities - ");
        vxbPciConfigInByte (busCtrlID, bus, device, function, devCapID, &cap_id);
        vxbPciConfigInByte (busCtrlID, bus, device, function, devCapID+1, &cap_id_next);

        /* longword align */
        cap_id_next &= ~0x03;

        /* Enhancement: Dump specific capabilities regs */
        if (cap_id == 0xff)
            /* Get Out - something is wrong */
            break;

        switch (cap_id)
            {
            case PCI_EXT_CAP_PCI_PM:
                printf("Power Management \n");
                break;
            case PCI_EXT_CAP_AGP:
                printf("AGP ");
                break;
            case PCI_EXT_CAP_VPD:
                printf("Vital Product Data \n");
                break;
            case PCI_EXT_CAP_SLOTID:
                printf("Slot ID \n");
                break;
            case PCI_EXT_CAP_MSI:
                vxbMsiCapabShow(busCtrlID, bus, device, function, devCapID);
                break;
            case PCI_EXT_CAP_HOT_SWAP:
                printf("cPCI Hot Swap \n");
                break;
            case PCI_EXT_CAP_PCIX:
                vxbPcixCapabShow(busCtrlID, bus, device, function, devCapID);
                break;
            case PCI_EXT_CAP_DBG_PORT:
                printf("Debug Port \n");
                break;
            case PCI_EXT_CAP_CPCI_RES:
                printf("cPCI Resource \n");
                break;
            case PCI_EXT_CAP_HPC:
                printf("PCI Hot Plug \n");
                break;
            case PCI_EXT_CAP_EXP:
                vxbPcieCapabShow(busCtrlID,bus, device, function, devCapID);
                break;
            case PCI_EXT_CAP_MSIX:
                printf("MSI-X \n");
                break;
            default:
                printf("%02x Unknown\n", cap_id);
            }
        devCapID = cap_id_next;
        }
    printf("\n");
}


/*********************************************************************
*
* vxbPciConfigTopoShow - show PCI topology
*
* This routine traverses the PCI bus and prints assorted information
* about every device found.  The information is intended to present
* the topology of the PCI bus.  In includes: (1) the device type, (2)
* the command and status words, (3) for PCI to PCI bridges the memory
* and I/O space configuration, and (4) the values of all implemented
* BARs.
*
* RETURNS: N/A
*
* ERRNO
*/

void vxbPciConfigTopoShow
    (
    VXB_DEVICE_ID busCtrlID
    )
    {
    if(busCtrlID == NULL)
	return;

    vxbPciConfigForeachFunc(busCtrlID,0,TRUE,vxbPciConfigFuncShow,NULL);
    }

/*******************************************************************************
*
* pciDeviceShow - print information about PCI devices
*
* This routine prints information about the PCI devices on a given PCI bus
* segment (specified by <busNo>).
*
* RETURNS: OK, or ERROR if the library is not initialized.
*
* ERRNO
*/

STATUS pciDeviceShow
    (
    int busNo       /* bus number */
    )
    {
    if(globalBusCtrlID==NULL)
	return(ERROR);

    return(vxbPciDeviceShow (globalBusCtrlID,busNo));
    };

/*******************************************************************************
*
* pciHeaderShow - print a header of the specified PCI device
*
* This routine prints a header of the PCI device specified by busNo, deviceNo,
* and funcNo.
*
* RETURNS: OK, or ERROR if this library is not initialized.
*
* ERRNO
*/

STATUS pciHeaderShow
    (
    int busNo,      /* bus number */
    int deviceNo,   /* device number */
    int funcNo      /* function number */
    )
    {
    if(globalBusCtrlID==NULL)
	return(ERROR);

    return(vxbPciHeaderShow (globalBusCtrlID,busNo,deviceNo,funcNo));
    };

/*******************************************************************************
*
* pciFindDeviceShow - find a PCI device and display the information
*
* This routine finds a device by deviceId, then displays the information.
*
* RETURNS: OK, or ERROR if this library is not initialized.
*
* ERRNO
*/

STATUS pciFindDeviceShow
    (
    int vendorId,   /* vendor ID */
    int deviceId,   /* device ID */
    int index       /* desired instance of device */
    )
    {
    if(globalBusCtrlID==NULL)
	return(ERROR);

    return(vxbPciFindDeviceShow(globalBusCtrlID,vendorId,deviceId,index));
    };

/*********************************************************************
*
* pciConfigStatusWordShow - show the decoded value of the status word
*
* This routine reads the value of the status word for the specified
* bus, device, function and displays the information.
*
* RETURNS: OK, always.
*
* ERRNO
*/

STATUS pciConfigStatusWordShow
    (
    int bus,        /* bus */
    int device,     /* device */
    int function,   /* function */
    void *pArg      /* ignored */
    )
    {
    if(globalBusCtrlID==NULL)
	return(ERROR);

    return(vxbPciConfigStatusWordShow(globalBusCtrlID,bus,device,function,pArg));
    }

/*********************************************************************
*
* pciConfigCmdWordShow - show the decoded value of the command word
*
* This routine reads the value of the command word for the specified
* bus, device, function and displays the information.
*
* RETURNS: OK, always.
*
* ERRNO
*/

STATUS pciConfigCmdWordShow
    (
    int bus,        /* bus */
    int device,     /* device */
    int function,   /* function */
    void *pArg      /* ignored */
    )
    {
    if(globalBusCtrlID==NULL)
	return(ERROR);

    return(vxbPciCmdWordShow(globalBusCtrlID,bus,device,function));
    }

/*******************************************************************************
*
* pciFindClassShow - find a device by 24-bit class code
*
* This routine finds a device by its 24-bit PCI class code, then prints its
* information.
*
* RETURNS: OK, or ERROR if this library is not initialized.
*
* ERRNO
*/

STATUS pciFindClassShow
    (
    int classCode,  /* 24-bit class code */
    int index       /* desired instance of device */
    )
    {
    if(globalBusCtrlID==NULL)
	return(ERROR);


    return(vxbPciFindClassShow (globalBusCtrlID,classCode,index));

    }

/*********************************************************************
*
* pciConfigFuncShow - show configuration details about a function
*
* This routine reads various information from the specified
* bus, device, function, and displays the information.
*
* RETURNS: OK, always.
*
* ERRNO
*/

STATUS pciConfigFuncShow
    (
    int bus,        /* bus */
    int device,     /* device */
    int function,   /* function */
    void *pArg      /* ignored */
    )
    {
    if(globalBusCtrlID==NULL)
	return(ERROR);

    return(vxbPciConfigFuncShow (globalBusCtrlID,bus,device,function,pArg));
    };


/*********************************************************************
*
* pciConfigTopoShow - show PCI topology
*
* This routine traverses the PCI bus and prints assorted information
* about every device found.  The information is intended to present
* the topology of the PCI bus.  In includes: (1) the device type, (2)
* the command and status words, (3) for PCI to PCI bridges the memory
* and I/O space configuration, and (4) the values of all implemented
* BARs.
*
* RETURNS: N/A
*
* ERRNO
*/

STATUS pciConfigTopoShow(void)
    {
    if(globalBusCtrlID==NULL)
	return(ERROR);

    vxbPciConfigTopoShow(globalBusCtrlID);

    return(OK);

    }
#endif /* INCLUDE_PCI_BUS_SHOW */
#endif /* INCLUDE_PCI_BUS */

#ifdef INCLUDE_PPC440GX_PCI
extern void vxbPpc440gxPciRegister(void);
#endif /* INCLUDE_PPC440GX_PCI */

#ifdef INCLUDE_RAPIDIO_BUS
IMPORT STATUS rapidIoRegister (void);
#endif /* INCLUDE_RAPIDIO_BUS */

#ifdef DRV_PCI_SH77XX
    extern void sh77xxPciRegister (void);
#endif /* DRV_PCI_SH77XX */



/* vxBus Utility Modules */

IMPORT void drvUnloadLibInit(void);

/* include hardware interface memory allocation scheme */
#ifdef INCLUDE_HWMEM_ALLOC
#ifndef HWMEM_POOL_SIZE
#define HWMEM_POOL_SIZE 50000
#endif /* HWMEM_POOL_SIZE */
#ifndef INIT_HWMEMPOOL_IN_BSP 
char  hwMemPool[HWMEM_POOL_SIZE];
IMPORT void hwMemLibInit(void);
IMPORT STATUS hwMemPoolCreate(char *  pMem, int size);
#endif /* INIT_HWMEMPOOL_IN_BSP */
#endif /* INCLUDE_HWMEM_ALLOC */

#ifdef INCLUDE_QUICC_ENGINE_UTILS
extern void quiccEngineRegister(void);
#endif

/* Buffer support for drivers with on-device DMA engines */
#ifdef INCLUDE_DMA_SYS
IMPORT void vxbDmaBufInit (void);
IMPORT void vxbDmaLibInit (void);
#endif /* INCLUDE_DMA_SYS */

#ifdef INCLUDE_INTCTLR_DYNAMIC_LIB
extern void vxbIntDynaCtlrInit();
#endif /* INCLUDE_INTCTLR_DYNAMIC_LIB */

IMPORT void vxbLegacyIntInit();

#ifdef INCLUDE_NON_VOLATILE_RAM
extern void vxbNonVolLibInit (void);
#endif /* INCLUDE_NON_VOLATILE_RAM */

IMPORT void vxbShowLibInit (void);
IMPORT void vxbIntCtlrShowInit (void);

/* vxbSmSupport.uc - support for shared memory  */

/*
 * Copyright (c) 2005-2008 Wind River Systems, Inc.
 *
 * The right to copy, distribute, modify or otherwise make use
 * of this software may be licensed only pursuant to the terms
 * of an applicable Wind River license agreement.
 */

/*
modification history
--------------------
01g,01jul08,tor  library build
01f,04sep07,pdg  corrected apigen errors
01e,15aug07,h_k  removed sharedMemSupportAPIGet_desc.
01d,07aug07,dtr  Move hooks definition to here.
01c,13jun07,tor  remove VIRT_ADDR
01b,12may06,dgp  doc: fix name/description formatting, ERROR -> ERRNO
01a,04jun05,dtr  File created.
*/

/*
DESCRIPTION

This library implements the hardware interface memory management,

INCLUDE FILES : vxbSmSupport.h
*/

#ifdef INCLUDE_VXBUS_SM_SUPPORT

/* includes */

#include <vxWorks.h>
#include <vxBusLib.h>
#include <logLib.h>
#include <stdio.h>
#include <string.h>
#include <hwif/vxbus/vxBus.h>
#include <hwif/vxbus/hwConf.h>
#include <hwif/util/vxbSmSupport.h>

/* hooks */

void (*vxbBusTasClearHook)(char*) = NULL;
BOOL (*vxbBusTasHook)(char*) = NULL;
STATUS (*vxbBusIntGenHook)(int,int) = NULL;
STATUS (*vxbBusIntAckHook)(int) = NULL;

/* Shared Memory Support Functions  */

/*********************************************************
*
* sysBusTasClear - clear a reservation for a particular address
*
* This routine clears a reservation for a particular address. If no direct 
* hook is available, it calls the VxBus helper function to find the correct 
* call.
*
* RETURNS: NONE
*
* ERRNO:
*/

void sysBusTasClear
    (
    volatile char * adrs
    )
    {
    if ( vxbBusTasClearHook != NULL )
        {
	(*vxbBusTasClearHook)((char*)adrs);
	return;
	}

    vxbDevIterate((FUNCPTR)sysBusTasClearHelper, (void*)adrs, VXB_ITERATE_INSTANCES);
    }

/*********************************************************
*
* sysBusTasClearHelper - locate and clear a reservation for a particular address 
*
* This routine clears a reservation for a particular address 
* by calling all devices which support this functionality.
*
* RETURNS: NONE
*
* ERRNO:
*/
void sysBusTasClearHelper
    (
    VXB_DEVICE_ID	pInst,
    void *		adrs
    )
    {
    FUNCPTR				method;
    struct sharedMemSupportAPI *	pApi;

    method = vxbDevMethodGet(pInst, (UINT32)&sharedMemSupportAPIGet_desc[0]);
    if ( method != NULL )
        {
	pApi = (struct sharedMemSupportAPI *)(*method)(pInst, (char *)adrs);
	if ( ( pApi != NULL ) && ( pApi->tasClear != NULL ) )
	    (*pApi->tasClear)(adrs);
	}
    }

/*********************************************************
*
* sysBusTas - establish a reservation for a particular address
* 
* This routine establishes a reservation for a particular address. If no 
* direct hook is available, it calls the VxBus helper function to find 
* the correct call.
*
* RETURNS: NONE
*
* ERRNO:
*/
BOOL sysBusTas
    (
    char * adrs
    )
    {
    UINT32 tasArgs[2];
    BOOL state;

    /* Pass address to TAS function */
    tasArgs[0] = (UINT32)adrs;
    
    if ( vxbBusTasHook != NULL )
        {
	state = (*vxbBusTasHook)(adrs);
	return(state);
	}

    vxbDevIterate((FUNCPTR)sysBusTasHelper, (void*)tasArgs, VXB_ITERATE_INSTANCES);
    /* Requires state TRUE/FALSE returned for SM interface */
    state = tasArgs[1];
    
    return(state);
    }

/*********************************************************
*
* sysBusTasHelper - locate the correct device to do TAS
*
* This routine iterates through all VxBus devices to find the correct device 
* to do TAS.
*
* RETURNS: TRUE/FALSE via tasArgs 
*
* ERRNO:
*/
void sysBusTasHelper
    (
    VXB_DEVICE_ID	pInst,
    UINT32*		tasArgs
    )
    {
    BOOL state = FALSE;
    FUNCPTR				method;
    struct sharedMemSupportAPI *	pApi;
    char* adrs;

    adrs = (char*) tasArgs[0];

    method = vxbDevMethodGet(pInst, (UINT32)&sharedMemSupportAPIGet_desc[0]);

    if ( method != NULL )
        {
	pApi = (struct sharedMemSupportAPI *)(*method)(pInst, (char *)adrs);
	if ( ( pApi != NULL ) && ( pApi->tas != NULL ) )
	    {
	    state = (*pApi->tas)(adrs);
	    tasArgs[1] = state;

	    }
	}

    }

/*********************************************************
*
* sysBusIntGen - call interrupt generator function hook
* 
* This routine either calls interrupt generator function hook directly
* or calls VxBus helper to find the correct device and then calls the
* interrupt generator function hook. 
*
* RETURNS: STATUS
*
* ERRNO:
*/
STATUS sysBusIntGen
    (
    int level,          /* interrupt level to generate   */
    int vector          /* interrupt vector for interrupt*/
    )
    {
    UINT32 pArgs[2];
    STATUS status = OK;
    if ( vxbBusIntGenHook != NULL )
        {
	status = (*vxbBusIntGenHook)(level,vector);
	return(status);
	}

    pArgs[0] = level;
    pArgs[1] = vector;

    vxbDevIterate((FUNCPTR)sysBusIntGenHelper, (void*)&pArgs[0], VXB_ITERATE_INSTANCES);

    return(OK);

    }

/*********************************************************
*
* sysBusIntGenHelpr - locate the correct call to generate an interrupt
*
* This routine iterates through all devices looking for the correct 
* call to generate the interrupt.
*
* RETURNS: NONE
*
* ERRNO:
*/
void sysBusIntGenHelper
    (
    VXB_DEVICE_ID	pInst,
    void *		pArgs
    )
    {
    FUNCPTR				method;
    struct sharedMemSupportAPI *	pApi;
    UINT32 *args  = (UINT32*)pArgs;


    method = vxbDevMethodGet(pInst, (UINT32)&sharedMemSupportAPIGet_desc[0]);
    if ( method != NULL )
        {
	pApi = (struct sharedMemSupportAPI *)(*method)(pInst, (char *)pArgs);
	if ( ( pApi != NULL ) && ( pApi->intGen != NULL ) )
	    (*pApi->intGen)(args[0],args[1]);
	}
    }

/*********************************************************
*
* sysBusIntAck - acknowledge an interrupt
*
* This routine calls a hook or helper function to acknowledge interrupt.
* 
* RETURNS: OK
*
* ERRNO:
*/
int sysBusIntAck
    (
    int intLevel        /* interrupt level to acknowledge*/
    )
    {
    STATUS status;

    if ( vxbBusIntAckHook != NULL )
        {
	status = (*vxbBusIntAckHook)(intLevel);
	return(status);
	}

    vxbDevIterate((FUNCPTR)sysBusIntAckHelper, (void*)intLevel, VXB_ITERATE_INSTANCES);

    return(OK);

    }

/*********************************************************
*
* sysBusIntAckHelpr - locate the correct call to acknowledge an interrupt
*
* This routine iterates through all devices looking for the correct 
* call to acknowledge an interrupt.
*
* RETURNS: NONE
*
* ERRNO:
*/
void sysBusIntAckHelper
    (
    VXB_DEVICE_ID	pInst,
    int 		intLevel
    )
    {
    FUNCPTR				method;
    struct sharedMemSupportAPI *	pApi;

    method = vxbDevMethodGet(pInst, (UINT32)&sharedMemSupportAPIGet_desc[0]);
    if ( method != NULL )
        {
	pApi = (struct sharedMemSupportAPI *)(*method)(pInst, (char *)intLevel);
	if ( ( pApi != NULL ) && ( pApi->intAck != NULL ) )
	    (*pApi->intAck)(intLevel);
	}
    }


/*********************************************************
*
* sysMailboxConnect - TBD
*
* RETURNS: STATUS
*
* ERRNO:
*/
STATUS sysMailboxConnect
    (
    FUNCPTR isr,
    int level
    )
    {
    return(OK);
    }

/*********************************************************
*
* sysMailboxEnable - TBD
*
* RETURNS: STATUS
*
* ERRNO:
*/
STATUS sysMailboxEnable
    (
    char * level
    )
    {
    return(OK);
    }

/*******************************************************************************
*
* bootLineAdrsGet -  retrieve boot line address from BSP configuration
*
*  This routine returns the address of the boot line, available from
*  the BSP macro BOOT_LINE_ADRS.
*
*  RETURNS: the value of BOOT_LINE_ADRS, specified by the BSP
*
*  ERRNO: not set
*/

char * bootLineAdrsGet(void)
    {
    return(BOOT_LINE_ADRS);
    }

/*******************************************************************************
*
* localMemLocalAdrsGet - Return the value of LOCAL_MEM_LOCAL_ADRS
*
*  This routine roeturns the address specified in the BSP by
*  the LOCAL_MEM_LOCAL_ADRS macro
*
*  RETURNS: the value of LOCAL_MEM_LOCAL_ADRS specified by the BSP,
*           or -1 if not specified
*
*  ERRNO: not set
*/

char * localMemLocalAdrsGet(void)
    {
#ifdef LOCAL_MEM_LOCAL_ADRS
    return(LOCAL_MEM_LOCAL_ADRS);
#else /* LOCAL_MEM_LOCAL_ADRS */
    return((char *)-1);
#endif /* LOCAL_MEM_LOCAL_ADRS */
    }

/***********************************************************************
*
* smEndFlagsGet - Return optional SMEND flags
*
*  This routine returns the flag bits for optional components
*  used by shared memory.
*
*  RETURNS: the flag bits corresponding to optional
*           shared memory components
*
*  ERRNO: not set
*/

UINT32 smEndFlagsGet()
    {
    UINT32 configFlag = 0;

#ifdef INCLUDE_SM_SEQ_ADDR
        configFlag |= SMEND_SM_SEQ_ADDR;
#endif /* INCLUDE_SM_SEQ_ADDR */

#ifdef INCLUDE_PROXY_SERVER
        configFlag |= SMEND_PROXY_SERVER_FLAG;
#endif /* INCLUDE_PROXY_SERVER */

#ifdef INCLUDE_PROXY_CLIENT
        configFlag |= SMEND_PROXY_CLIENT_FLAG;
#endif /* INCLUDE_PROXY_CLIENT */

#ifdef INCLUDE_PROXY_DEFAULT_ADDR
        configFlag |= SMEND_PROXY_DEFAULT_ADDR_FLAG;
#endif /* INCLUDE_PROXY_DEFAULT_ADDR */

    return(configFlag);
    }

#endif /* INCLUDE_VXBUS_SM_SUPPORT */

#ifdef INCLUDE_TIMER_SYS
#include <../config/comps/src/usrVxbTimerSys.c>
IMPORT void vxbSysClkLibInit();
#  ifdef INCLUDE_AUX_CLK
IMPORT void vxbAuxClkLibInit();
#  endif /* INCLUDE_AUX_CLK */
#  ifdef INCLUDE_TIMESTAMP
IMPORT void vxbTimestampLibInit();
#  endif /* INCLUDE_TIMESTAMP */
IMPORT void vxbDelayLibInit();
#else  /* INCLUDE_TIMER_SYS */
#  ifdef INCLUDE_TIMER_STUB
IMPORT void vxbTimerStubInit();
#  endif /* INCLUDE_TIMER_STUB */
#endif /* INCLUDE_TIMER_SYS */

/* vxbVerChk.uc -- VxBus version check */

/*
 * Copyright (C) 2008  Wind River Systems, Inc. All rights are reserved.
 * 
 * The right to copy, distribute, modify, or otherwise make use
 * of this software may be licensed only pursuant to the terms
 * of an applicable Wind River license agreement.
 */

/* 
modification history
--------------------
01d,15aug08,h_k  reverted the version check.
01c,23jul08,h_k  temporary workaround for the VxBus version check. (CQ:128598)
01b,10jul08,tor  prohibit drivers using pAccess (<ver4.0.0) from registering
01a,01may08,tor  created
*/

/*
DESCRIPTION

This module contains code to check the version of drivers
when registering, and ensure that no driver successfully
registers if it makes use of facilities that are not present
in the current configuration.

This module must be compiled in the context of a project or
BSP.
*/

/* includes */

#include <vxWorks.h>
#include <vxBusLib.h>
#include <hwif/vxbus/vxBus.h>

/* defines */

/* typedefs */

/* globals */

/* locals */

/* forward declarations */

/*********************************************************************
*
* vxbDrvVerCheck - Check for valid driver version
*
*  This routine checks a VxBus driver to ensure that the current
*  VxBus configuration will support the services that the driver
*  uses.
*
* RETURNS: OK or ERROR
*
* ERRNO
*/

STATUS vxbDrvVerCheck
    (
    struct vxbDevRegInfo * pDevInfo /* per-bus recognition info */
    )
    {
    /* no forward compatability */

    if ( VXB_VER_MAJOR(pDevInfo->vxbVersion) > 4 )
        return(ERROR);

#ifndef VXB_LEGACY_ACCESS

    /*
     * register access changed with VxBus version 4.0.0.  The older
     * device register access mechanism, using pDev->pAccess, is no longer
     * available.  Instead, drivers use vxbRead*() and vxbWrite*().
     *
     * If VXB_LEGACY_ACCESS is not configured, then any driver
     * attempting to use pDev->pAccess
     * may cause serious consequences to the system.
     */

    if ( VXB_VER_MAJOR(pDevInfo->vxbVersion) < 4 )
        return(ERROR);

#else /* VXB_LEGACY_ACCESS */

    /*
     * If VXB_LEGACY_ACCESS is configured, then pDev->pAccess is
     * available and we can accept earlier drivers.  However,
     * we still reject prototype version drivers.
     */

    if ( pDevInfo->vxbVersion < VXBUS_VERSION_1 )
        return(ERROR);

#endif /* VXB_LEGACY_ACCESS */

    return(OK);
    }



/*******************************************
*
* hardWareInterFaceBusInit - initialize bus
*/

void hardWareInterFaceBusInit (void)
    {
    /* initialize bus subsystem */

    vxbLibInit();

#ifdef INCLUDE_DOWNLOADABLE_DRIVERS
    drvUnloadLibInit();
#endif /* INCLUDE_DOWNLOADABLE_DRIVERS */

#ifdef INCLUDE_QUICC_ENGINE_UTILS
    quiccEngineRegister();
#endif

#ifdef INCLUDE_DMA_SYS
    vxbDmaBufInit();
    vxbDmaLibInit();
#endif

#ifdef INCLUDE_NON_VOLATILE_RAM
    vxbNonVolLibInit();
#endif /* INCLUDE_NON_VOLATILE_RAM */

#ifdef INCLUDE_VXBUS_SHOW
    vxbShowLibInit ();
#endif /* INCLUDE_VXBUS_SHOW */

#if defined (INCLUDE_INTCTLR_LIB) && defined (INCLUDE_INTCTLR_SHOW)
    vxbIntCtlrShowInit ();
#endif /* INCLUDE_INTCTLR_LIB && INCLUDE_INTCTLR_SHOW */

#ifdef INCLUDE_VXBUS_SM_SUPPORT
    smEndRegister();
#endif


    /*
     * initialize processor local bus
     * PLB: always included
     */

    plbRegister();

    /* bus registration */

#ifdef DRV_PCIBUS_M83XX
    m83xxPciRegister ();		/* M83xx PCI host controller */
#endif /* DRV_PCIBUS_M83XX */

#ifdef DRV_PCIBUS_M85XX
    m85xxPciRegister ();		/* M85xx PCI host controller */
#endif /* DRV_PCIBUS_M85XX */

#ifdef INCLUDE_MII_BUS
    miiBusRegister();
#endif

#ifdef INCLUDE_PCI_BUS
    pciRegister();
#endif /* INCLUDE_PCI_BUS */

#ifdef INCLUDE_PPC440GX_PCI
    vxbPpc440gxPciRegister();   /* PowerPC 440GX PCI host controller */
#endif /* INCLUDE_PPC440GX_PCI */

#ifdef INCLUDE_RAPIDIO_BUS
    rapidIoRegister();
#endif /* INCLUDE_RAPIDIO_BUS */

#ifdef DRV_PCI_SH77XX
    sh77xxPciRegister();
#endif /* DRV_PCI_SH77XX */


    /* driver registration */

#ifdef INCLUDE_AM79C97X_VXB_END
    lnPciRegister();
#endif

#ifdef INCLUDE_BCM52XXPHY
    bmtPhyRegister();
#endif

#ifdef INCLUDE_BCM54XXPHY
    brgPhyRegister();
#endif

#ifdef INCLUDE_VXB_CPM
    cpmRegister();
#endif


#ifdef INCLUDE_DM9161PHY
    dmPhyRegister();
#endif

#ifdef INCLUDE_FCC_VXB_END
   fccRegister();
#endif


#ifdef INCLUDE_FEC_VXB_END
    fecRegister();
#endif /* INCLUDE_FEC_VXB_END */

#ifdef INCLUDE_FEI8255X_VXB_END
    feiRegister();
#endif

#ifdef INCLUDE_GT64120A_PCI
    g64120aPciRegister ();
#endif /* INCLUDE_GT64120A_PCI */

#ifdef INCLUDE_GT64120A_MF
    g64120aMfRegister ();
#endif /* INCLUDE_GT64120A_MF */

#ifdef INCLUDE_GEI825XX_VXB_END
    geiRegister();
#endif

#ifdef INCLUDE_GEI_HEND
    geiHEndRegister();
#endif /* INCLUDE_GEI_HEND */

#ifdef INCLUDE_GEITBIPHY
    geiTbiPhyRegister();
#endif

#ifdef INCLUDE_GENERICPHY
    genPhyRegister();
#endif

#ifdef INCLUDE_GENERICTBIPHY
    genTbiRegister();
#endif

#ifdef DRV_TIMER_IPROC_CCB
    iProcCcbTimerDrvRegister ();
#endif /* DRV_TIMER_IPROC_CCB */

#ifdef DRV_IPROC_PCIE
    iProcPCIeRegister ();		/* iProc PCIe host controller */
#endif /* DRV_IPROC_PCIE */

#ifdef DRV_VXBEND_IPROC
    iProcVxbEndRegister();
#endif

#ifdef INCLUDE_ICP175CPHY
    icpRegister();
#endif

#ifdef DRV_PCIBUS_IXP4XX
    ixPciRegister ();		/* IXP4xx PCI host controller */
#ifdef INCLUDE_END2
    vxbDmaEnd2BufIxp4xxPciInit ();
#endif
#endif /* DRV_PCIBUS_IXP4XX */

#ifdef INCLUDE_LXT972PHY
    lxtPhyRegister();
#endif

#ifdef DRV_PCIBUS_M83XX_EX
    m83xxPciExRegister ();		/* M83xx PCI host controller */
#endif /* DRV_PCIBUS_M83XX */

#ifdef DRV_RESOURCE_M85XXCCSR
    m85xxCCSRRegister();
#endif /* DRV_RESOURCE_M85XXCCSR */

#ifdef INCLUDE_M85XX_CPU
    m85xxCpuRegister();
#endif /* INCLUDE_M85XX_CPU */

#ifdef INCLUDE_M85XX_RAPIDIO
    m85xxRioRegister();
#endif /* INCLUDE_M85XX_RAPIDIO */

#ifdef INCLUDE_MCF5475_PCI
    mcf5475PciRegister();
#endif /* INCLUDE_MCF5475_PCI */

#ifdef INCLUDE_MDIO
    mdioRegister();
#endif /* mdioRegister */


#ifdef INCLUDE_MOT_ETSEC_HEND
    motEtsecHEndRegister();
#endif /* INCLUDE_MOT_ETSEC_HEND */

#ifdef INCLUDE_MOT_FEC_HEND
    motFecHEndRegister();
#endif /* INCLUDE_MOT_FEC_HEND */

#ifdef INCLUDE_MOT_TSEC_HEND
    motTsecHEndRegister();
#endif /* INCLUDE_MOT_TSEC_HEND */

#ifdef INCLUDE_MV88E1113PHY
    mvfPhyRegister();
#endif

#ifdef INCLUDE_MV88E1X11PHY
    mvPhyRegister();
#endif

#ifdef INCLUDE_MVYUKONII_VXB_END
    ynRegister();
#endif

#ifdef INCLUDE_NE2000_VXB_END
    eneRegister();
#endif

#ifdef INCLUDE_NS8381X_VXB_END
    nseRegister();
#endif /* INCLUDE_NS8381X_VXB_END */

#ifdef INCLUDE_NS83902_VXB_END
    nicRegister();
#endif /* INCLUDE_NS83902_VXB_END */

#ifdef INCLUDE_PENTIUM_PCI
    pentiumPciRegister();       /* pcPentium PCI host controller */
#endif /* INCLUDE_PENTIUM_PCI */

#ifdef INCLUDE_PPC440GP_PCI
    ppc440gpPciRegister();              /* PowerPC 440GP PCI host controller */
#endif /* INCLUDE_PPC440GP_PCI */

#ifdef INCLUDE_QE_FCC_HEND
    qeFccHEndRegister();
#endif /* INCLUDE_QE_FCC_HEND */

#ifdef INCLUDE_RTL8139_VXB_END
    rtlRegister();
#endif

#ifdef INCLUDE_RTL8169PHY
    rtgPhyRegister();
#endif

#ifdef INCLUDE_RTL8169_VXB_END
    rtgRegister();
#endif

#ifdef INCLUDE_RTL8201PHY
    rtlPhyRegister();
#endif

#ifdef INCLUDE_SBE_VXB_END
    sbeRegister();
#endif

#ifdef INCLUDE_SCC_VXB_END
   sccRegister();
#endif /* INCLUDE_SCC_VXB_END */


#ifdef INCLUDE_SPI4000_MDIO
    spi4000MdioRegister();
#endif

#ifdef INCLUDE_SPI4000_PHY
    spi4000PhyRegister();
#endif

#ifdef INCLUDE_TC3C905_VXB_END
    elPciRegister();
#endif /* INCLUDE_TC3C905_VXB_END */

#ifdef INCLUDE_TSEC_MDIO
    tmRegister();
#endif /* mdioRegister */


#ifdef INCLUDE_TSEC_VXB_END
    tsecRegister();
#endif /* INCLUDE_TSEC_VXB_END */

#ifdef INCLUDE_UCC_MDIO
    umRegister();
#endif /* mdioRegister */


#ifdef INCLUDE_VSC82XXPHY
    vigPhyRegister();
#endif

#ifdef DRV_INTCTLR_ADS5121E_CPLD
    ads5121eCpldIntCtlrRegister ();
#endif /* DRV_INTCTLR_ADS5121E_CPLD */

#ifdef DRV_TIMER_AMBA
    vxbAmbaTimerDrvRegister ();
#endif


#ifdef DRV_PCIBUS_ARMAXI
    vxbArmAxiPciRegister ();
#endif /* DRV_PCIBUS_ARMAXI */

#ifdef DRV_ARM_GIC
    vxbArmGenIntCtlrRegister ();
#endif /* DRV_ARM_GIC */

#ifdef DRV_ARM_MPCORE_TIMER
    armMpCoreTimerDrvRegister ();
#endif /* DRV_ARM_MPCORE_TIMER */


#ifdef DRV_VXBEND_AT91EMAC
    at91EmacRegister();
#endif /* DRV_VXBEND_AT91EMAC */

#ifdef DRV_INTCTLR_AT91
    vxbAt91IntCtlrRegister();
#endif /* DRV_INTCTLR_AT91 */
    

#ifdef DRV_SIO_AT91
    vxbAt91SioRegister();
#endif /* DRV_SIO_AT91 */

#ifdef DRV_TIMER_AT91
    vxbAt91TimerDrvRegister ();
#endif

#ifdef DRV_TIMER_CN3XXX
    vxbCn3xxxTimerDrvRegister ();
#endif
    

#ifdef INCLUDE_CNS3XXX_VXB_END
    vxbCns3xxxEndRegister ();
#endif /* INCLUDE_CNS3XXX_VXB_END */

#ifdef DRV_PCIBUS_CNS3XXX_EX
     cns3xxxPcieRegister();
#endif /* DRV_PCIBUS_CNS3XXX_EX */

#ifdef DRV_TIMER_CNS3XXX
    vxbCns3xxxTimerDrvRegister ();
#endif /* DRV_TIMER_CNS3XXX */


#ifdef DRV_SIO_COLDFIRE
    coldFireSioRegister();
#endif

#ifdef DRV_VXBEND_DAVINCI_EMAC
    davinciEmacRegister();
#endif

#ifdef DRV_INTCTLR_DAVINCI
    vxbDavinciIntCtlrRegister();
#endif /* DRV_INTCTLR_DAVINCI */
    

#ifdef DRV_SIO_DAVINCI
    dv16550SioRegister();
#endif /* DRV_SIO_DAVINCI */

#ifdef DRV_TIMER_DAVINCI
    vxbDavinciTimerDrvRegister ();
#endif

#ifdef DRV_VXBEND_DC2114X
    dcRegister();
#endif /* DRV_VXBEND_DC2114X */

#ifdef DRV_VXBEND_DM9000A
    dm9000aRegister ();
#endif /* DRV_VXBEND_DM9000A */

#ifdef DRV_MII_DTEPHY
    dtePhyRegister();
#endif


#ifdef DRV_VXBEND_DTSEC
    vxbDtsecEndRegister();
#endif /* DRV_VXBEND_DTSEC */

#ifdef DRV_MII_DTSEC_MDIO
    dtmRegister();
#endif

#ifdef INCLUDE_DUMMY_MDIO
    dummyMdioRegister();
#endif

#ifdef DRV_EB_GIC
    vxbEbGenIntrCtlRegister ();
#endif /* DRV_EB_GIC C*/

#ifdef DRV_INTCTLR_EPIC
    vxbEpicIntCtlrRegister();
#endif /* DRV_INTCTLR_EPIC */

#ifdef INCLUDE_ETSEC_VXB_END
    etsecRegister();
#endif /* INCLUDE_ETSEC_VXB_END */

#ifdef INCLUDE_ETSEC_VXB_END2
    etsecEnd2Register();
#endif /* INCLUDE_ETSEC_VXB_END2 */

#ifdef DRV_NVRAM_FILE
    vxbFileNvRamRegister();
#endif /* DRV_NVRAM_FILE */


#ifdef DRV_FW_FSL_AXE
    fslAxeRegister ();
#endif /* DRV_FW_FSL_AXE */

#ifdef DRV_DMA_FSL
    vxbFslDmaRegister();
#endif /* DRV_DMA_FSL */

#ifdef DRV_RESOURCE_FSLGPIO
    fslGpioRegister();
#endif /* DRV_RESOURCE_FSLGPIO */

#ifdef DRV_RESOURCE_FSLI2C
    fslI2cRegister();
#endif /* DRV_RESOURCE_FSLI2C */

#ifdef DRV_STORAGE_FSLSATA
    vxbFslSataStorageRegister ();
#endif


#ifdef INCLUDE_GEI825XX_VXB_END2
    geiEnd2Register();
#endif /* INCLUDE_GEI825XX_VXB_END2 */

#ifdef DRV_MII_I2C_MDIO
    imRegister();
#endif

#ifdef DRV_KBD_I8042
    i8042vxbRegister ();
#endif /* DRV_KBD_I8042 */

#ifdef DRV_TIMER_I8253
    vxbI8253TimerDrvRegister ();
#endif


#ifdef DRV_INTCTLR_I8259
    vxbI8259IntCtlrRegister  ();
#endif /* DRV_INTCTLR_I8259 */ 
    

#ifdef INCLUDE_IPIIX4_MF
    vxbIPiix4MfRegister ();
#endif /* INCLUDE_PIIX4_MF */


#ifdef INCLUDE_EMAC_VXB_END
    vxbEmacRegister();
#endif /* INCLUDE_EMAC_VXB_END */

#ifdef INCLUDE_VXB_IBM_MAL
    vxbMalRegister();
#endif /* INCLUDE_VXB_IBM_MAL */

#ifdef INCLUDE_VXB_IBM_RGMII
    rgmiiRegister();
#endif /* INCLUDE_VXB_IBM_RGMII */

#ifdef INCLUDE_VXB_IBM_TAH
    tahRegister();
#endif /* INCLUDE_VXB_IBM_TAH */

#ifdef INCLUDE_VXB_IBM_ZMII
    zmiiRegister();
#endif /* INCLUDE_VXB_IBM_ZMII */

#ifdef DRV_TIMER_IMX31EPIT
    vxbImx31EpitTimerDrvRegister ();
#endif /* DRV_TIMER_IMX31EPIT */  

#ifdef DRV_TIMER_IMX31GPT
    vxbImx31GptTimerDrvRegister ();
#endif /* DRV_TIMER_IMX31GPT */  

#ifdef DRV_INTCTLR_IMX31
    vxbImx31IntCtlrRegister();
#endif /* DRV_INTCTLR_IMX31 */

#ifdef DRV_SIO_IMX
    vxbImxSioRegister();
#endif /* DRV_SIO_IMX */

#ifdef INCLUDE_DRV_STORAGE_INTEL_AHCI
    vxbIntelAhciStorageRegister ();
#endif

#ifdef INCLUDE_DRV_STORAGE_INTEL_AHCI_SHOW
    ahciShowInit ();
#endif

#ifdef DRV_DMA_INTEL_EDMA 
    vxbIntelEdmaRegister ();
#endif /* DRV_DMA_INTEL_EDMA */

#ifdef DRV_MII_INTEL_GCU
    vxbIntelGcuRegister ();
#endif /* DRV_MII_INTEL_GCU */

#ifdef INCLUDE_DRV_STORAGE_INTEL_ICH
    vxbIntelIchStorageRegister ();
#endif

#ifdef INCLUDE_DRV_STORAGE_INTEL_ICH_SHOW
    ichAtaShowInit ();
#endif

#ifdef DRV_TIMER_IA_TIMESTAMP
    vxbIaTimestampDrvRegister ();
#endif

#ifdef DRV_VXBEND_INTELTOPCLIFF
    vxbIntelTopcliffEndRegister();
#endif /* DRV_VXBEND_INTELTOPCLIFF */

#ifdef DRV_RESOURCE_INTELTOPCLIFF_IOH
    iohRegister();
#endif /* DRV_RESOURCE_INTELTOPCLIFF_IOH */

#ifdef DRV_INTCTLR_IOAPIC
    vxbIoApicIntrDrvRegister ();
#endif /* DRV_INTCTLR_IOAPI C*/

#ifdef DRV_SIO_IXP400
    ixp400SioRegister();
#endif /* DRV_SIO_IXP400 */

#ifdef DRV_TIMER_IXP400
    ixp400TimerDrvRegister ();
#endif

#ifdef DRV_PCI_VIRTUAL
    vxbVirtualPciRegister();
#endif /* DRV_PCI_VIRTUAL */

#ifdef DRV_INTCTLR_LOAPIC
    vxbLoApicIntrDrvRegister ();
#endif /* DRV_INTCTLR_LOAPIC */

#ifdef DRV_TIMER_LOAPIC
    vxbLoApicTimerDrvRegister ();
#endif

#ifdef DRV_VXBEND_LPC24XXEMAC
    lpc24xxEndRegister();
#endif /* DRV_VXBEND_LPC24XXEMAC */
#ifdef DRV_INTCTL_LPC24XX
    vxbLpc24xxIntCtlrRegister();
#endif /* DRV_INTCTL_LPC24XX */
#ifdef DRV_TIMER_LPC24XX
    vxbLpc24xxTimerDrvRegister ();
#endif /* DRV_TIMER_LPC24XX */

#ifdef DRV_DMA_M512X
    m512xDmaRegister();
#endif

#ifdef INCLUDE_M512XFEC_VXB_END
    m512xFecRegister();
#endif

#ifdef DRV_MF_M512X_FIFOC
    m512xFifocRegister ();
#endif /* DRV_MF_M512X_FIFOC */
#ifdef DRV_DMA_COLDFIRE
    m548xDmaDrvRegister ();
#endif /* DRV_DMA_COLDFIRE */

#ifdef DRV_TIMER_COLDFIRE
    m54x5TimerDrvRegister ();
#endif

#ifdef DRV_TIMER_M5XXX_GPT
    m5xxxGPTimerRegister();
#endif /* DRV_TIMER_M5XXX_GPT */

#ifdef DRV_SIO_M5XXX_PSC
    m5xxxPscSioRegister();
#endif /* DRV_SIO_M5XXX_PSC */

#ifdef DRV_VGA_M6845
    m6845vxbRegister ();
#endif /* DRV_VGA_M6845 */

#ifdef DRV_TIMER_M85XX
    m85xxTimerDrvRegister ();
#endif /* DRV_TIMER_M85XX */  
    

#ifdef DRV_TIMER_MC146818
    vxbMc146818RtcDrvRegister ();
#endif /* DRV_TIMER_MC146818 */  
    

#ifdef DRV_TIMER_MCF
    mcfPitTimerDrvRegister ();
#endif

#ifdef DRV_INTCTLR_MIPS_CAV
    vxbMipsCavIntCtlrRegister ();
#endif /* DRV_INTCTLR_MIPS_CAV */
    

#ifdef DRV_INTCTLR_MIPS
    vxbMipsIntCtlrRegister ();
#endif /* DRV_INTCTLR_MIPS */
    

#ifdef DRV_INTCTLR_MIPS_MT_IPI
    vxbMipsMtIntCtlrRegister ();
#endif /* DRV_INTCTLR_MIPS_MT_IPI */
    

#ifdef DRV_TIMER_MIPSR4K
    vxbR4KTimerDrvRegister ();
#endif /* DRV_TIMER_MIPSR4K */

#ifdef DRV_INTCTLR_MIPS_SBE
    vxbMipsSbIntCtlrRegister ();
#endif /* DRV_INTCTLR_MIPS_SBE */
    

#ifdef DRV_INTCTLR_MIPS_XLR
    vxbMipsXlrIntCtlrRegister ();
#endif /* DRV_INTCTLR_MIPS_XLR */
    

#ifdef DRV_INTCTLR_MPAPIC
    vxbMpApicDrvRegister ();
#endif /* DRV_INTCTLR_MPAPIC */

#ifdef INCLUDE_MSC01_PCI
    vxbMsc01PciRegister ();
#endif



#ifdef DRV_VXBEND_MYRILANAI
    myeRegister();
#endif

#ifdef DRV_SIO_NS16550
    ns16550SioRegister();
#endif /* DRV_SIO_NS16550 */

#ifdef INCLUDE_OCTEON_VXB_END
    octEndRegister();
#endif

#ifdef INCLUDE_OCTEON_MDIO
    octeonMdioRegister();
#endif


#ifdef DRV_PCIBUS_OCTEON
    octPciRegister();
#endif /* DRV_PCIBUS_OCTEON */


#ifdef DRV_PCIBUS_OCTEON_PCIEX
    octPciExRegister();
#endif /* DRV_PCIBUS_OCTEON_PCIEX */


#ifdef INCLUDE_OCTEON_RGMII_VXB_END
    octRgmiiRegister();
#endif


#ifdef DRV_SIO_OCTEON
    octeonSioRegister();
#endif /* DRV_SIO_OCTEON */

#ifdef DRV_INTCTLR_OMAP2530
    vxbOmap2530IntCtlrRegister ();
#endif /* DRV_INTCTLR_OMAP2530 */

#ifdef DRV_TIMER_OMAP2530
    vxbOmap2530TimerDrvRegister ();
#endif /* DRV_TIMER_OMAP2530 */

#ifdef DRV_DMA_OMAP35XX
    omap35xxDmaRegister();
#endif

#ifdef DRV_INTCTLR_OMAP35XX
    vxbOmap35xxIntCtlrRegister ();
#endif /* DRV_INTCTLR_OMAP35XX */

#ifdef DRV_STORAGE_OMAP35XX_MMCHS
    omap35xxMmchsRegister ();
#endif /* DRV_STORAGE_OMAP35XX_MMCHS */
#ifdef DRV_TIMER_OMAP35XX
    vxbOmap35xxTimerDrvRegister ();
#endif /* DRV_TIMER_OMAP35XX */

#ifdef DRV_INTCTLR_OMAPL137
    vxbOmapL137IntCtlrRegister ();
#endif /* DRV_INTCTLR_OMAPL137 */

#ifdef DRV_TIMER_OPENPIC
    openPicTimerDrvRegister ();
#endif

#ifdef DRV_TIMER_PPC405
    ppc405TimerRegister ();
#endif /* DRV_TIMER_PPC405 */

#ifdef DRV_TIMER_PPC440
    ppc440TimerRegister ();
#endif /* DRV_TIMER_PPC440 */

#ifdef DRV_PCIBUS_PPC4XX_PCI
    ppc4xxPciRegister();
#endif /* DRV_PCIBUS_PPC4XX_PCI */

#ifdef DRV_PCIBUS_PPC4XX_PCIEX
    ppc4xxPciExRegister ();
#endif /* DRV_PCIBUS_PPC4XX_PCIEX */

#ifdef DRV_INTCTLR_UIC
    uicIntCtlrRegister ();
#endif /* DRV_INTCTLR_UIC */

#ifdef DRV_TIMER_DEC_PPC
    ppcDecTimerDrvRegister ();
#endif

#ifdef DRV_INTCTLR_PPC
    ppcIntCtlrRegister();
#endif /* DRV_INTCTLR_PPC */

#ifdef DRV_TIMER_QUICC_PPC
    quiccTimerDrvRegister ();
#endif
    

#ifdef	DRV_SIO_PRIMECELL
    vxbPrimeCellSioRegister();
#endif	/* DRV_SIO_PRIMECELL */

#ifdef DRV_INTCTLR_PXA3XXGPIO
    vxbPxa3xxGpioIntCtlrRegister();
#endif /* DRV_INTCTLR_PXA3XXGPIO */
#ifdef DRV_INTCTLR_PXA3XX
    vxbPxa3xxIntCtlrRegister();
#endif /* DRV_INTCTLR_PXA3XX */
    

#ifdef DRV_TIMER_PXA3XX
    vxbPxa3xxTimerRegister ();
#endif /* DRV_TIMER_PXA3XX */

#ifdef DRV_INTCTLR_QE
    vxbQeIntCtlrRegister();
#endif /* DRV_INTCTLR_QE */

#ifdef DRV_RESOURCE_QORIQBMAN
    bmanRegister();
#endif /* DRV_RESOURCE_QORIQBMAN */

#ifdef DRV_RESOURCE_QORIQFMAN
    fmanRegister();
#endif /* DRV_RESOURCE_QORIQFMAN */

#ifdef DRV_RESOURCE_QORIQFMAN_SOFTPARSE_ASSEMBLER
    fmanPrSpAsmInit ();
#endif /* DRV_RESOURCE_QORIQFMAN_SOFTPARSE_ASSEMBLER */

#ifdef DRV_RESOURCE_QORIQLAW
    lawRegister();
#endif /* DRV_RESOURCE_QORIQLAW */

#ifdef DRV_PCIBUS_QORIQ_PCIEX
    vxbQorIQPexRegister ();
#endif /* DRV_PCIBUS_QORIQ_PCIEX */

#ifdef DRV_RESOURCE_QORIQQMAN
    qmanRegister();
#endif /* DRV_RESOURCE_QORIQQMAN */

#ifdef DRV_INTCTLR_QUICC
    vxbQuiccIntCtlrRegister();
#endif /* DRV_INTCTLR_QUICC  */

#ifdef INCLUDE_XLR_GMAC_VXB_END
    xlrGmacRegister();
#endif


#ifdef INCLUDE_RMI_MDIO
    rmRegister();
#endif

#ifdef DRV_VXBEND_XLRXGMAC
    xlrXgmacRegister();
#endif


#ifdef DRV_STORAGE_SI31XX
    vxbSI31xxStorageRegister ();
#endif


#ifdef DRV_SIO_SB1
    vxbSb1DuartSioRegister();
#endif /* DRV_SIO_SB1 */
    

#ifdef DRV_TIMER_SB1
    vxbSb1TimerDrvRegister ();
#endif
    

#ifdef DRV_STORAGE_SDHC
    sdhcStorageRegister ();
#endif /* DRV_STORAGE_SDHC */

#ifdef DRV_TIMER_SH7700
    sh7700TimerDrvRegister ();
#endif

#ifdef DRV_SIO_SHSCIF
    shScifSioRegister();
#endif /* DRV_SIO_SHSCIF */

#ifdef	DRV_SUPERIO_SMCFDC37X
    vxbSmcFdc37xRegister();
#endif	/* DRV_SUPERIO_SMCFDC37X */

#ifdef INCLUDE_SMSCLAN9118_VXB_END
    smeRegister();
#endif

#ifdef INCLUDE_SMSCLAN91C111_VXB_END
    smscRegister();
#endif

#ifdef DRV_VXBEND_STMSPEAR13XX_GEMAC
    stmSpear13xxGmacRegister ();
#endif /* DRV_VXBEND_STMSPEAR13XX_GEMAC */

#ifdef DRV_TIMER_STMSPEAR13XX
    stmSpear13xxTimerRegister ();
#endif /* DRV_TIMER_STMSPEAR13XX */

#ifdef DRV_VXBEND_TEI82598
    teiRegister();
#endif

#ifdef DRV_VXBEND2_TEI8259X
    teiEnd2Register();
#endif /* DRV_VXBEND2_TEI8259X */

#ifdef DRV_VXBEND_TGEC
    vxbTgecEndRegister();
#endif /* DRV_VXBEND_TGEC */

#ifdef DRV_MII_TGEC_MDIO
    tgmRegister();
#endif

#ifdef DRV_VXBEND_TI_EMAC
    tiEmacRegister();
#endif

#ifdef INCLUDE_TSEC_VXB_END2
    tsecEnd2Register();
#endif /* INCLUDE_TSEC_VXB_END2*/

#ifdef INCLUDE_UCC_VXB_END
    uccRegister();
#endif /* INCLUDE_UCC_VXB_END */

#ifdef INCLUDE_EHCI
	usbEhcdInstantiate();
#endif
#ifdef INCLUDE_EHCI_INIT
	/* Register the Ehci with vxBus */
	vxbUsbEhciRegister ();
#endif

#ifdef INCLUDE_OHCI
	usbOhciInstantiate();
#endif
#ifdef INCLUDE_OHCI_INIT
	/* Register the Ohci with vxBus */
	vxbUsbOhciRegister ();
#endif

#ifdef INCLUDE_SYNOPSYSHCI
	usbSynopsysHcdInstantiate();
#endif
#ifdef INCLUDE_SYNOPSYSHCI_INIT
	/* Register the SynopsysHci with vxBus */
	vxbUsbSynopsysHciRegister ();
#endif

#ifdef INCLUDE_UHCI
	usbUhcdInstantiate();
#endif
#ifdef INCLUDE_UHCI_INIT
	/* Register the Uhci with vxBus */
	vxbUsbUhciRegister ();
#endif

#ifdef DRV_VXBEND_VIARHINE
    vrRegister();
#endif /* DRV_VXBEND_VIARHINE */

#ifdef DRV_INTCTRL_VIOAPIC
    vxbVioApicIntrDrvRegister ();
#endif /* DRV_INTCTRL_VIOAPIC*/

#ifdef DRV_INTCTLR_VXSIM
    vxbVxSimIntCtlrRegister();
#endif /* DRV_INTCTLR_VXSIM */


#ifdef DRV_RESOURCE_XLRCPLD
    xlrCpldRegister();
#endif


#ifdef INCLUDE_XLR_FMN
    xlrFmnRegister();
#endif


#ifdef INCLUDE_XLR_TIMER
    vxbXlrTimerDrvRegister ();
#endif /* INCLUDE_XLR_TIMER */
    

#ifdef INCLUDE_XLR_PCI
    xlrPciRegister();
#endif


#ifdef DRV_PCIBUS_XLS_PCIEX
    xlsPciExRegister();
#endif /* DRV_PCIBUS_XLS_PCIEX */


#ifdef DRV_DEMO_WRSAMPLE
    wrsampleRegister();
#endif /* DRV_DEMO_WRSAMPLE */


    /* probe devices and create instances */

    vxbInit();

    }

/*********************************************
*
* hardWareInterFaceInit - HWIF Pre-Kernel Init
*/

void hardWareInterFaceInit (void)
    {

#ifdef INCLUDE_HWMEM_ALLOC
#ifndef INIT_HWMEMPOOL_IN_BSP
    /* Pre-Kernel Memory Allocation */
    hwMemLibInit();
    hwMemPoolCreate(&hwMemPool[0], HWMEM_POOL_SIZE);
#define INIT_HWMEMPOOL_GLOBAL
#endif /* INIT_HWMEMPOOL_IN_BSP */
#endif /* INCLUDE_HWMEM_ALLOC */

#ifdef INCLUDE_INTCTLR_DYNAMIC_LIB
	vxbIntDynaCtlrInit();
#endif /* INCLUDE_INTCTLR_DYNAMIC_LIB */

#ifdef	INCLUDE_TIMER_SYS
    usrVxbTimerSysInit ();
#endif	/* INCLUDE_TIMER_SYS */


    /* bus subsystem initialization */
    hardWareInterFaceBusInit();

#ifdef INCLUDE_TIMER_SYS
    vxbSysClkLibInit();
#  ifdef INCLUDE_AUX_CLK
    vxbAuxClkLibInit();
#  endif /* INCLUDE_AUX_CLK */
#  ifdef INCLUDE_TIMESTAMP
    vxbTimestampLibInit();
#  endif /* INCLUDE_TIMESTAMP */
    vxbDelayLibInit();
#else  /* INCLUDE_TIMER_SYS */
#  ifdef INCLUDE_TIMER_STUB
    vxbTimerStubInit();
#  endif /* INCLUDE_TIMER_STUB */
#endif /* INCLUDE_TIMER_SYS */


    }


/*********************************************
*
* vxbDevInit - HWIF Post-Kernel Init
*/

STATUS vxbDevInit (void)
    {
    int status;
#ifdef INCLUDE_VXB_LEGACY_INTERRUPTS
    vxbLegacyIntInit();
#endif /* INCLUDE_VXB_LEGACY_INTERRUPTS */


#ifdef INCLUDE_USB_INIT
	usbInit ();

	/* 
 	 * The following initializatino routines perform initialization of 
 	 * data structures only.  vxBus will invoke the internal initialization.
 	 *
 	 * The host controller driver must be initialized after the USBD.
 	 *
 	 */
	#ifdef INCLUDE_EHCI_INIT
		/* Initialize global data structures */
		usbEhcdInit ();
	#endif
	#ifdef INCLUDE_OHCI_INIT
		/* Initialize global data structures */
		usbOhcdInit ();
	#endif
	#ifdef INCLUDE_UHCI_INIT
		/* Initialize global data structures */
		usbUhcdInit ();
	#endif
	#ifdef INCLUDE_SYNOPSYSHCI_INIT
		/* Initialize global data structures */
	    usbSynopsysHcdInit ();
	#endif

#endif 			/* INCLUDE_USB_INIT */


    /* bus Device Initialization */
    status = vxbDevInitInternal();

    return (status);
    }

/*********************************************
*
* vxbDevConnect - HWIF Post-Kernel Connection
*/

STATUS vxbDevConnect (void)
    {
    int status;

    /* Bus Device Connection */
    status = vxbDevConnectInternal();

    return (status);
    }

#endif /* PRJ_BUILD */
#endif /* INCLUDE_VXBUS */
