#
# $Id: config.bcm,v 1.124 Broadcom SDK $
# $Copyright: Copyright 2012 Broadcom Corporation.
# This program is the proprietary software of Broadcom Corporation
# and/or its licensors, and may only be used, duplicated, modified
# or distributed pursuant to the terms and conditions of a separate,
# written license agreement executed between you and Broadcom
# (an "Authorized License").  Except as set forth in an Authorized
# License, Broadcom grants no license (express or implied), right
# to use, or waiver of any kind with respect to the Software, and
# Broadcom expressly reserves all rights in and to the Software
# and all intellectual property rights therein.  IF YOU HAVE
# NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
# IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
# ALL USE OF THE SOFTWARE.  
#  
# Except as expressly set forth in the Authorized License,
#  
# 1.     This program, including its structure, sequence and organization,
# constitutes the valuable trade secrets of Broadcom, and you shall use
# all reasonable efforts to protect the confidentiality thereof,
# and to use this information only in connection with your use of
# Broadcom integrated circuit products.
#  
# 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
# PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
# REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
# OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
# DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
# NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
# ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
# CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
# OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
# 
# 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
# BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
# INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
# ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
# TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
# THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
# WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
# ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
#
# Sample Properties file used for Broadcom StrataSwitch.
# Each entry in the file consists of a single line of the form:
#	<Parameter>=<Value>
#
# See the file $SDK/doc/properties.txt for more documentation about how
# to use properties.
#
# To allow different properties for different units or chips,
# each property is looked up with the following suffixes in order:
#	.<unit-num>		(e.g. "foo.0")
#	.<CHIP_TYPE>		(e.g. foo.BCM5680_B0)
#	.<CHIP_GROUP>		(e.g. foo.BCM5680)
#	<nothing>		(e.g. foo)
#
# The per-port properties are looked up with various port related
# suffixes in the following order:
#	_<port_name>		phy_null_fe0
#	_<port_type>		phy_null_fe
#	_<port_number>		phy_null_port1
#	<nothing>		phy_null
#
# Port numbers start are counted from 1 up to the number of enabled
# ports on the chip.
#
# The per-port properties also have the unit or chip based suffixes
# described above added as well.
#
# White space is NOT ignored, but blank lines are ignored.
# Lines starting with '#' are comments and are ignored.
#
# All properties not specified have default values.  Our convention
# here is to comment out properties that are best left at their
# default, and to show the default value in the comment when feasible.
#
# In the Broadcom Command Monitor, the 'config' command may be used to
# add and delete properties and manage them in non-volatile storage.
#

# Station mac address used for management through the switch ports
# itself. If using the CPU network interface, the NVRAM setting is used
# for MAC address assignment.

#station_mac_address=00:00:00:00:01:00

# Station IP address used for management through the switch ports
# itself. If using the CPU network interface, the NVRAM setting is used
# for IP address assignment.

#station_ip_address=192.168.1.0

# Station IP netmast used for management through the switch ports
# itself. If using the CPU network interface, the NVRAM setting is used
# for netmask assignment.

#station_ip_netmask=255.255.255.0

# Station host name used for management through the switch ports
# itself. If using the CPU network interface, the NVRAM setting is used
# for host name assignment.

#station_hostname=StrataSwitch

# Define default OS / SAL
#os=vxworks

# Enable polled IRQ mode (useful for board bringup and debugging).
# IRQs will be polled from a dedicated thread and hardware interrupts
# will remain disabled.
#polled_irq_mode=0

# The priority of the IRQ poll thread as well as the minimum delay
# between IRQ polls can be configured if needed.
#polled_irq_delay=0
#polled_irq_priority=100

#
# Board Configuration Properties
#
# These are not per-unit and are not used by the driver.
# They are used by scripts such as rc.soc and sanity.
#

# Black Knight
#black_knight=1

# White Knight (SDK5690P24S)
#white_knight=1

# Galahad (SDK5690R24)
#galahad=1

# Merlin (SDK5690R24S)
#merlin=1

# Lancelot (SDK5690R48S)
#lancelot=1

# Guenevere (BCM95695P24SX)
#guenevere=1

# Hercules 8-port (SDK5670K8)
#herc8=1

#
# Driver Configuration Properties
#

#Allow PLL bypass mode to be configured.
#pll_bypass.<unit-num>=0

# debug can be set to initial DK_XXX mask to use on booting.

#debug=0x10000

# If reload support is compiled in, the buffer size must be large enough
# for the platform.  Our worst-case platform is Herculynx with eight
# BCM5673s at nearly 300k apiece.

#reload_buffer_size=3145728
#reload_file_name=flash:reload.dat

# Allow filtering to be disabled in hardware if not being used.
# Also, tables will not be cleared which can save time in simulation.

#filter_enable=1

# MMU SDRAM configuration

#mmu_sdram_enable=1
#mmu_sdram_width=128

# For BCM5605, DLL values may need tuning.
#mmu_sdram_dll0=4
#mmu_sdram_dll1=0xd
#mmu_sdram_dll2=7

# For all other chips, DLL values should be 0.
#mmu_sdram_dll0=0
#mmu_sdram_dll1=0
#mmu_sdram_dll2=0

# Control 5615 MISCCONFIG2.SDCLK_133MHZ_EN (external vs internal SDRAM clock)
#mmu_sdram_clock_external=1

# HOLBLOCKINGMARKER and INGRESSBACKPRESSURE configuration.
# These can be used to set the initial value of these registers in
# StrataSwitch and G-Switch devices based on port type.

#mmu_hbm_fe=
#mmu_hbm_ge=
#mmu_hbm_cpu=
#mmu_ibp_fe=
#mmu_ibp_ge=
#mmu_ibp_cpu=

# L3 switching enable

#l3_enable=1
#ipmc_enable=1
#ipmc_do_vlan=1

# Trunk extension control
# For BCM5695, enables 128 trunk groups (affects HiGig header format).
# Currently, this property must be commented out (or =0) if non-BCM5695
# switch devices are connected via the HiGig port (fabric devices OK).
#trunk_extend=1

# Multicast ranges

# The Higig2 header format concatenates the broadcast, multicast, and
# IP multicast indices into one generic multicast index.  The mapping
# between the individual indices and the combined index is specified by
# these.  The default values are indicated.

# higig2_multicast_vlan_range=4096
# higig2_multicast_l2_range=4096
# higig2_multicast_l3_range=4096

# In BCM568xx and BCM567xx devices, the some L2 and L3 multicast
# information is stored in a shared resource.  These specify the
# division of this resource.

# multicast_l2_range=4096
# multicast_l3_range=4096

# pbmp_valid allows assigning a port bitmap of valid ports.
# Any port not in the bitmap is assumed to not exist.
# Default value is PBMP_ALL(unit), all ports including CPU.
# The cpu port cannot be disabled.
# For BCM5671 this now defaults to 0x14b automatically (ports 1,3,6,8,CPU).
#
#pbmp_valid.0=0x14b

# higig2_hdr_mode_<port> allows a HG port to default to HiGig2
# encapsulation, instead of HiGig.  This is only available on devices
# which support HiGig2.
#higig2_hdr_mode_hg0=1
# Uncomment the following line to make all HG ports default to HiGig2.
#higig2_hdr_mode=1


# pbmp_xport_xe is used to specify if a XPORT block is configured as xe port
# By default, an XPORT block is treated as HG port.
#pbmp_xport_xe.0=0x00000000
# Uncomment the following line instead to set all XPORTs to XE ports.
#pbmp_xport_xe.0=0x0f000000
# On 568xx devices, the XPORT block defaults to XE ports.  Uncomment the
# following line to change all ports to HG ports.  A specific bitmap
# may be provided to select some XE and some HG ports, with the set
# bits initialized to HG ports.  Note that HG and XE ports may be
# exchanged through the bcm_port_encap_set API.
#pbmp_xport_xe.0=0x00000000

# pbmp_gport_stack is used to specify if a stack capable GE port is
# configured as stack port
# By default, a stack capable GE port is configured as stack port.
#pbmp_gport_stack.0=0x00000006
# Uncomment the following line instead to set all GE ports as regular
# front panel Ethernet ports.
#pbmp_gport_stack.0=0x00000000

# pbmp_loopback is used to specify if a HIGIG/HIGIG-LITE port is
# configured as loopback port
# Uncomment the following line instead to set all HIGIG/HIGIG-LITE ports as regular
# front panel Ethernet ports.
#pbmp_loopback.0=0x3c000000

# If phy_enable is set to 0, all ports will use the null PHY driver.
# This is useful for simulations on Quickturn.

#phy_enable=1

# Override the MDIO bus address to access a phy for a particular port
#port_phy_addr_xe0.0=24

# If phy_null_<port> is set to 1, the port will use the null PHY driver.
# This is useful for configuring direct-connect GMII links such as the
# chip-to-chip links on a 48-port board (example shown for 48 port board).

#phy_null_ge0.0=1
#phy_null_ge1.1=1

# If phy_simul_<port> is set to 1, the port will use the simulation
# PHY driver.

#phy_simul_ge0.0=1
#phy_simul_ge1.1=1

# Turbo port configuration (example shown for 48 port board)
# Drive strength and phase control may be overridden from defaults.
# All are controllable on a per-port basis.

#turbo_ge0.0=1
#turbo_ge1.1=1
#turbo_drv=0
#turbo_phase=0

# I/O Voltage selection. (per-port controllable)
# BCM5645B0 and later default turbo_iov to 1 for 2.5V
# board design may require that gig_iov be 1 for 2.5V

#turbo_iov=0
#gig_iov=0

# TBI vs. GMII configuration

#if_tbi_ge0.0=1
#if_tbi_ge1.1=1

# Serdes Autonegotiation configuration
# This per-port parameter specifies what will happen if autonegotiation is
# on but the remote partner is not autonegotiating.  If the value is zero,
# we will not link.  If the value is non-zero, we will link.

#phy_serdes_autos=0

# Per-port parameter indicating the only PHY is 5690 SERDES directly
# connected to a fiber module.  This is needed on 24-port 5690 SDKs
# which have resistors configuration to bypass external 5434/5464.
# SERDES is used automatically if no PHY is detected on the MDIO.

#phy_5690_ge10=0
#phy_5690_ge11=0

# Per-port parameter indicating the only PHY is 56XXX SERDES directly
# connected to a fiber module.  This is needed on boards which have
# which have resistors configuration to bypass external 5434/5464.
# SERDES is used automatically if no PHY is detected on the MDIO.

#phy_56xxx_ge10=0
#phy_56xxx_ge11=0

# The per-port parameter phy_5464S must be set if a BCM5464S or 5464SR
# is used.  This is needed because the PHY device ID is the same for all
# of 5464/5464R/5464S/5464SR.

#phy_5464S_ge8=0
#phy_5464S_ge9=0
#phy_5464S_ge10=0
#phy_5464S_ge11=0

# The per-port parameter phy_8706 must be set if a BCM8706 or BCM8726
# is used. This is needed because the PHY device ID is the same for
# 8704/8706/8726.
#phy_8706_xe0=0

# Fiber vs. copper autodetection enable
#
# This property defaults to 1 for the 5421S and 5464S.
# This property defaults to 0 for the 5464.

#phy_automedium_ge0.0=1
#phy_automedium_ge1.1=1

# Fiber vs. copper preference
#
# When automedium is enabled, phy_fiber_pref indicates which medium to
# prefer if BOTH are active.  Selects fiber (1) or copper (0).
#
# When automedium is disabled, phy_fiber_pref indicates which medium to
# use.  Selects fiber (1) or copper (0).

#phy_fiber_pref_ge0.0=1
#phy_fiber_pref_ge1.1=1

# This parameter can be used to skip probing for an external PHY connected
# to a 5673 and just use the internal phy.
#phy_5673_xe0=0

# Per-port parameter on maximum time to wait for PHY autoneg busy condition.
#phy_autoneg_timeout=250000

# Per-port phy LED control values (currently only used by 546x phy driver)
# see 546x phy data sheets:
# ledN_mode are LED selector values from phy reg 0x1x[011101, 01110]
# led_ctrl is phy reg 0x1x[01001]
#phy_led1_mode=0
#phy_led2_mode=1
#phy_led3_mode=3
#phy_led4_mode=6
#phy_led_ctrl=0x8

# Per-port control of fiber signal detection (for 546x phys)
#	0	use the phy's default as signal detect
#	1	use PECL SD as signal detect (default on 5461)
#	4	use LED4 as signal detect (default on 5464)
#	10	use EN_10B as signal detect
# Negating value treats signal detect as loss of signal without
# needing an external inverter on the board
#
# In ROBO devices all fiber port through external GE PHY in SDK/SVK board were 
#  designed as active low on the SD pin. Thus this property definition is 
#  advised to set to 'phy_fiber_detect=-4' for the ROBO SDK/SVK board or 
#  reference board of fiber medium through external PHY(546x and 
#  5482 phys)
#phy_fiber_detect=1

# phy53115_a0 sw-workaround for the link issue at AN+100TX mode
#	0	disable this SW workaround.
#	1	enable this SW workaround.
#phy_53115_an100tx_war=0

# phy53115_b0 sw-workaround for the interoperability issue.
#	0	disable this SW workaround.
#	1	enable this SW workaround.
# --- This SW-WAR also active for fixing bcm53118_a0 at IOP problem.
#phy_53115_b0_iop_war=0

# Initial number of COS queues bcm_init() configures the chip for.
#bcm_num_cos=4

# XQ distribution weighting (relative) for each COSQ.
#
# Some SOC devices allow weighted distribution of XQs among the COSQs.
# The portion of a port's XQs allocated to any one COSQ is defined
# by that COSQ's weight value divided by the sum of all applicable
# weight values.
#
# A weight of 0 disables that COSQ. Non-zero weights must start at COSQ0
# and occupy contiguous COSQs.
#
# Ideally, the sum of all weight values should add up to the smallest
# power of 2 possible.

#mmu_xq_weight_cos0=1
#mmu_xq_weight_cos1=1
#mmu_xq_weight_cos2=1
#mmu_xq_weight_cos3=1
#mmu_xq_weight_cos4=1
#mmu_xq_weight_cos5=1
#mmu_xq_weight_cos6=1
#mmu_xq_weight_cos7=1

# Per-XQ packet aging.
#
# Some SOC devices allow independent packet aging behavior among the COSQs.
#
# An aging value of 0 disables packet aging for that COSQ. Non-zero values
# define the maximum age of a packet (for a COSQ), in milliseconds.
#
# The underlying hardware determines the supported granularity, as well
# as the maximum ratio of the longest aging value to the smallest
# (nonzero) aging value.

#mmu_xq_aging_cos0=1000
#mmu_xq_aging_cos1=1000
#mmu_xq_aging_cos2=1000
#mmu_xq_aging_cos3=1000
#mmu_xq_aging_cos4=1000
#mmu_xq_aging_cos5=1000
#mmu_xq_aging_cos6=1000
#mmu_xq_aging_cos7=1000

# MMU Configuration for 56500 style memory managers.
# Includes 56100, 56300, 56200, 53700 familes of devices.
#
# Default MMU xq (packet) controls allow for 8 queues to be used
# even less than 8 are currently configured.  If less than 8 queues
# will ever be used then the remaining queues mmu_xq_weight_cosN
# values should be set to 0.  A 4 queue configuration should set
# mmu_xq_weight_cosN=0 for N=4, 5, 6, 7.
#
# The defaults are indicated here.
#
#mmu_flow_percent=90
#				percentage of per-port cells useable
#				before flow control starts
#mmu_flow_fanin=4
#				number of simulteneous senders to each
#				port for flow control purposes
#mmu_red_drop_percent=60
#mmu_yellow_drop_percent=80
#				percentage of per-port/per-cos packets
#				used before red or yellow packets will
#				be dropped
#mmu_static_bytes=1536
#				per-port/per-cos static reserved limit.
#				Rounded up from bytes to next cell size.
#				Remaining cells are put in dynamic pool.
#				If 0, then mmu_static_percent is used.
#mmu_static_percent=50
#				Percentage of per-port/per-cos cells to
#				use as static reserved limit.
#				Remaining cells are put in dynamic pool.
#				Only used if mmu_static_bytes is 0.
#mmu_reset_bytes=3072
#				(1536 * 2)
#				offset from dynamic cell set limits for
#				reset (enable) limits.
#				Rounded up from bytes to next cell size.
#mmu_overcommit=1
#				non-stack port overcommit factor for
#				dynamic pool
#mmu_overcommit_stack=2
#				stack port overcommit factor for
#				dynamic pool.  If 0, then use the
#				mmu_overcommit value for stack ports

#
# Linkscan
#

# Specify ports on which bcm_init will run linkscan (default all).
#bcm_linkscan_pbmp=

# If non-zero, bcm_init() will start linkscan
#bcm_linkscan_interval=250000

# If linkscan detects more than bcm_linkscan_maxerr consecutive errors,
# then it disables scanning of that port for bcm_linkscan_errtime usec.
# This is mainly to prevent infinite error messages from scrolling by.
# Use bcm_linkscan_maxerr=0 to disable this feature.
#bcm_linkscan_maxerr=5
#bcm_linkscan_errdelay=10000000

#
# BCM Statistics Collection
#
# Set bitmap of ports on which stat collection will be enabled.
# Default is all ports.

#bcm_stat_pbmp=

# Set interval on which stat collection will be performed.
# Setting this to 0 will prevent counters from being started.
#bcm_stat_interval=1000000

# Flag values to be ORd together:
#   0x0 indicates that counter DMA should NOT be used
#   0x1 indicates that counter DMA should be used (default).
#bcm_stat_flags=0x1

# Threshold value for oversize (*OVR) frame size.
# Values over 1518 affect the *OVR statistics computation
#bcm_stat_jumbo=1518

# Size of ARL DMA buffer

#arldma_size=1024

# Timeout for hardware-accelerated ARL delete operations including:
# delete by port, delete by port+modid, delete by VLAN, delete by trunk.
#arl_clean_timeout_usec=5000000

# L2 table is DMAed into memory to search for entries to delete
# when no hardware assists are available.  DMA is done in smaller
# parts to minimize memory use.  Must be power of 2.
#l2delete_chunks=64

# Enable L2X shadowing into AVL tree.
#l2xmsg_avl=1

# Synchronize the L2X table in chunks to spread out the work over
# time and save memory on size of DMA buffer.  Must be power of 2.
#l2xmsg_chunks=8

# Period between synchronizations of the software L2X shadow table
# with the hardware (5690 only).  The thread actually runs every
# l2xmsg_thread_usec/l2xmsg_chunks microseconds.

#l2xmsg_thread_usec=3000000

# The l2xmsg thread will call back to the user any time an L2X address
# is added, removed, or changed.  However, if only the hit bit changes,
# it will not call back unless l2x_msg_shadow_hit_bits is set to 1.
#l2xmsg_shadow_hit_bits=0

# Mode control to select L2 Table DMA mode aka L2MODE_POLL (0) or
# L2MOD_FIFO mechanism aka L2MODE_FIFO (1) for L2 table change notification.
#l2xmsg_mode=0

# Enable L2X address grouping
#l2_group_enable=0

# Run s/w based L2 aging
#run_l2_sw_aging=1

# Set default maximum number of entry moves for dual hash tables
#dual_hash_recurse_depth=1

# Set default maximum number of entry moves for multi hash tables
#multi_hash_recurse_depth=1

# Memory Built-In-Self-Test (BIST) timeout in milliseconds

#bist_timeout_msec=1000

# Normally, the system will use polling for register/memory S-Channel
# operations and interrupts for time-consuming operations such as ARL
# insert/delete.  If this schan_intr_enable is set to 0, polling will be
# used for ALL operations.

#schan_intr_enable=1

# Length of time to block the S-Channel error interrupt after one occurs.
# Prevents monopolizing the CPU (use 0 to disable any blocking).
#schan_error_block_usec=250000

# S-Channel operation timeout in microseconds.  Note that ARL
# insert/delete messages can take a while if the ARL is highly active.

#schan_timeout_usec=300000

# If miim_intr_enable variable is set to 1, the system will use
# interrupts for MII operations since they take a while (70 usec or so).
# If this variable is set to 0, polling will be used for all MII
# operations.

#miim_intr_enable=1

# MIIM operation timeout in microseconds

#miim_timeout_usec=100000

# Diagnostics loopback (tr 17 through tr 24) timeout in seconds for
# link up

#diag_lb_link_timeout=15

# Diagnostics loopback (tr 17 through tr 24) timeout in seconds for
# loopback packet reception

#diag_lb_packet_timeout=5

# Diagnostics loopback - if set to TRUE, all receive buffers are filled
# with 0xdeadbeef before DMAing into them.  It is slow, but then you will
# know if loopback miscompares are due to skipped PCI writes.
#diag_lb_fill_rx=0

# Packet watcher thread priority
#diag_pw_thread_pri=100

# Tab width for diagnostics (especially 'show counters')
#diag_tabs=8

# ASCII comma character for show counters
# Use 44 for comma, 46 for period, 0 for none
#diag_comma=44

# arl_static_ff indicates that a static entry of VLAN TAG 0xfff must be
# made in the ARL for proper operation, on chips where applicable.

#arl_static_ff=1

# The ARL lookup command (on chips supporting it) may fail and require
# retry in the event the ARL is extra busy.

#arl_lookup_tries=100

# Limit the number of ARL messages/sec the software will process, to
# keep it from hogging the CPU.  Set to 0 to disable.
# Does not apply to L2X shadow table (see l2xmsg_thread_usec instead).

#arl_rate_limit=3000

# Delay this long after an ARL message overrun before a lengthy ARL-
# resync process.  Setting to 0 to disables resync, in peril of getting
# an inconsistent ARL message stream and/or corrupt L2 shadow table.

#arl_resync_delay=3000000

# Maximum number of consecutive S-channel errors the counter collection
# code will tolerate before the counter thread gives up and exits.

#soc_ctr_maxerr=5

# Skip hardware reset (CMIC_CONFIG.RESET_CPS) when calling soc_reset().
# This means that e.g. 'init soc' will NOT perform a hard reset.

#soc_skip_reset=1

# Packet DMA abort timeout

#pdma_timeout_usec=500000

# Counter DMA collection pass timeout in microseconds

#cdma_timeout_usec=100000

# Table DMA operation timeout in microseconds

#tdma_timeout_usec=1000000

# Table DMA operation should use interrupt rather than poll for completion

#tdma_intr_enable=1

# Table SLAM DMA operation timeout in microseconds

#tslam_timeout_usec=1000000

# Table SLAM DMA operation should use interrupt rather than poll for completion

#tslam_intr_enable=1

# Enable/Disable SLAM DMA
#tslam_dma_enable=1

# Enable/Disable TABLE DMA
#table_dma_enable=1

# gbpfull_warn_enable enables a warning message to be printed on GBPFULL
# interrupt.  gbpfull_warn_time sets the minimum number of seconds
# between successive GBPFULL messages, to avoid flooding the terminal.
# These variables take affect only after the "init" command is run.

#gbpfull_warn_enable=1
#gbpfull_warn_time=5

# Select memory tests run by cfapinit (default MT_PAT_FIVES and MT_PAT_AS)
#cfap_tests=12

# Memory scan: max errors, and max DMA buffer size in entries
#mem_scan_maxerr=8
#mem_scan_chunk_size=256

# Miscellaneous thread priorities; 0 is highest and 255 is lowest

#counter_thread_pri=50
#arlmsg_thread_pri=50
#l2xmsg_thread_pri=50
#mem_scan_thread_pri=50
#linkscan_thread_pri=50
#bcm_tx_thread_pri=50
#bcm_rx_thread_pri=200
#l2age_thread_pri=150
#error_thread_pri=50

# When a link goes down for any reason, the driver waits for all packets
# to that port to drain from the MMU before continuing.  There is a
# timeout in case the packet count is non-zero AND non-decrementing.

#lccdrain_timeout_usec=250000

# PCI device/rev ID override allows you to pretend you are running
# on a different chip (e.g. force 5605 driver to run on 5615)
# NOTE: this one is actually in sysconf.c, not the driver.

#pci_override_dev=0x5605
#pci_override_rev=1

# Generic SOC configuration registers located at reserved addresses in
# PCI configuration space (usually address 0x44 and 0x48). Any arbitrary
# 32-bit hex value may be specified.
# NOTE: these settings only work with the VxWorks driver and are provided
# for debugging purposes only.

#pci_conf_soccfg0=0x0
#pci_conf_soccfg1=0x0

# Use crytal input for LCPLL
#xgxs_lcpll_xtal_refclk=0

# Fusion core reference clock selection
# External Clock = 0, Internal LCPLL = 1
#xgxs_lcpll=1

# Fusion core LCPLL clock speed selection - 10Gbps = 0, 12Gbps = 1
#xgxs_lcpll_12gbps=0

# Unicore 10G parallel detect (10/12 Gbps legacy speed detection)
#xgxs_pdetect_10g=1

# Fusion/Uni core preemphasis, driver current and  pre-driver current
# values 0-15 (can be changed per-port)
#xgxs_preemphasis=1
#xgxs_driver_current=1
#xgxs_pre_driver_current=1

# Fusion PLL lock range value 0-15 (can be changed per-port)
#xgxs_plllock=15

# Remap XGXS rx and tx lanes to desired mapping. Four bits were used for
# specifying each lane in the format of Lane 0 (bit 15-12), Lane 1 (bit 11-8),
# lane 2 (bit 7-4), and lane 3 (bit 3-0).
# For example, to reverse the tx lane mapping in 3, 2, 1, 0 order,
# set xgxs_tx_lane_map=0x3210.
# efault setting is.
#xgxs_tx_lane_map=0x0123
#xgxs_rx_lane_map=0x0123

# Serdes reference clock selection
# External Clock = 0, Internal LCPLL = 1
#serdes_lcpll=0

# Combo Serdes core preemhasis, driver current and pre-driver current
# values 0-15 (can be changed per-port)
# serdes_preemphasis=1
# serdes_driver_current=1
# serdes_pre_driver_current=1

# switch serdes SGMII master/slave mode configuration.  Default is slave.
# serdes_sgmii_master=0

# 10G PHY core preemphasis, driver current and pre-driver current
# values 0-15 (can be changed per-port) for SFP+ application.
#phy_preemphasis=1
#phy_driver_current=1
#phy_pre_driver_current=1

# Unicore Serdes SGMII/fiber auto-detect (can be changed per-port)
# Note that auto-detect only works when auto-negotiation is enabled.
# If auto-detect or auto-negotiation is off then fiber_pref=0 will
# select SGMII and fiber_pref=1 (default) will select fiber.
#serdes_automedium=1
#serdes_fiber_pref=1

# Enable SGMII autonegotiation between the SOC and PHY if the
# SOC supports SGMII autonegotiation. This feature is not enabled by
# default.
#phy_sgmii_autoneg_ge0.0=1

# By default, 5670 will be configured to accept the maximum number of
# packets per port, but may drop them if resources are oversubscribed due
# to activity from other ports.  If lossless mode is enabled, 5670 will
# instead be configured to accept packets only if sufficient processing
# resources are guaranteed for all ports.  This may decrease overall
# throughput, but no accepted packets will be dropped.

#lossless_mode=0

#24c64 EEPROM and XFP share the same I2C slave address. Set this to
#1 to treat the #device found at this slave address as XFP.
#i2c_nvram_skip=0

#PCF8574 lpt2 and LTC4258 poe3 share the same I2C slave address. Set
#this to 1 to treat the device found at this slave address as POE.
#i2c_hclk_skip=0

#PD63000 init power setting. Set this to 1 for 100W; otherwise
#default of 37W is used.
#i2c_poe_power=0

#Set this to 1 for 189 MHz core, 25 MHz reference used for 12G in 5675.
#core_clock_12G=0

#Set this to 1 for 5670 compatiable mirror behavior in 5675.
#mirror_5670_mode=0

#BCM5675 HOL blocking avoidance mode (jitter and hysteresis)
#Set this to 1 to enable jitter for comparing low cell/packet count thresholds
#mmu_hol_jitter=0
#Set this to 1 to enable hysteresis with recommended default low thresholds
#mmu_hol_hysteresis=0

#Swap XAUI lanes between phy8703/BCM5670 and BCM5673(lynxalot board)
#phy_xaui_rx_lane_swap=0

#Flip XAUI lane TX polarity 8706 (all Lanes) and XGXS16G serdes
#value of 1 - Flip TX polarity on all the 4 lanes.
#value of 0x000F - Flip TX polarity on lane 0.
#value of 0x00F0 - Flip TX polarity on lane 1.
#value of 0x0F00 - Flip TX polarity on lane 2.
#value of 0xF000 - Flip TX polarity on lane 3.
#phy_xaui_tx_polarity_flip=0

#Invert PCS TX output to PMD. Supported only on BCM8705 PHY.
#phy_tx_invert_ge0.0=0
#phy_rx_invert_ge0.0=0

#phy_port_primary_and_offset specifies the base port and phy index of a multi slice phy chip.
#phy_port_primary_and_offset_<port>=0xPPOO 0xPP=primary port number 0xOO=offset of the slice
#For example, for ports ge0-ge3 Primary Port number is 02 (address of base/first port) 
#phy_port_primary_and_offset_ge0=0x0200 primary port number=0x02 offset=00
#phy_port_primary_and_offset_ge1=0x0201 primary port number=0x02 offset=01
#phy_port_primary_and_offset_ge2=0x0202 primary port number=0x02 offset=02
#phy_port_primary_and_offset_ge3=0x0203 primary port number=0x02 offset=03

#Port property to set BCM5488 family PHY to operate in class A half amplitude
#mode.
#phy_half_pwr_mode_ge0.0=10    Enable half amplitude for all speed.
#phy_half_pwr_mode_ge0.0=100   Enable half amplitude for all speed.
#phy_half_pwr_mode_ge0.0=1000  Enable half amplitude for Giga speed.

#Port property to set BCM5488 family PHY to operate in class A/B low power
#mode. Accept value 0(lowest power) to 7(highest power).
#phy_low_power_mode_ge0.0=0

#Port Property to transform CX4 pinout to Higig pinout on 5650x/5660x
#cx4_to_higig=0

# 8704 and 8705 XFP clock
# 8704 and 8705 can provide the clock for the XFPs (thus eliminating the need
# for an external clock. By default we enable it, but if you are not using it,
# it should be disabled.
#phy_xfp_clock=1

# 8705 WAN support
# 8705 PHY driver can support both LAN and WAN mode. The default setting
# is LAN mode.
#phy_wan_mode_xe0=1

# The following optical controls manage to force various PHY signal on
# BCM8703/4/5
# Control Active Optical Enable output level.
#force_opttxenblvl=0

# Control Active Optical Reset output level.
#force_opttxrstlvl=0

# Control Active Laser Bias Fault level.
#force_optbiasfltlvl=0

# Control Active Temperature level.
#force_opttempfltlvl=0

# Control Active Laser Power Fault level.
#force_optprfltlvl=0

# Control Active TX fault level.
#force_opttxfltlvl=0

# Control Active Laser Loss of light level.
#force_optrxloslvl=0

# Control Active RX fault level.
#force_optrxfltlvl=0

# Control Active TX on level.
#force_opttxonlvl=0

# BCM5665L and BCM5666L support
# The BCM5665L and BCM5666L device IDs are 0x5665, same as the BCM5665.
# However, these devices do not support the upper 24 FE ports.
# The following property must be used to invalidate them.
#pbmp_valid.BCM5665=0x010000001fffffff

# BCM5665 family debug mode - bypass MCU, allows diagnostics such as
# loopback to be run without initializing the MCU (but requires small
# packet sizes and counts).
#bypass_mcu=1

# BCM5665 MCU configuration
# See bcm5665 DDR bring up flow chart for MCU tuning procedure
# These are the default values:

# These are valid for BCM5650/55/65:
#mcu_drv_str0_ch0=1
#mcu_drv_str1_ch0=0
#mcu_pad_data_class2_ch0=1
#mcu_pad_data_drive_ch0=3
#mcu_pad_data_slew_ch0=3
#mcu_pad_addr_class2_ch0=0
#mcu_pad_addr_drive_ch0=3
#mcu_pad_addr_slew_ch0=3
#mcu_delay_dqi_adj_dir_ch0=1
#mcu_delay_dqi_adj_val_ch0=3
#mcu_delay_addr_adj_dir_ch0=1
#mcu_delay_addr_adj_val_ch0=0

#mcu_drv_str0_ch1=1
#mcu_drv_str1_ch1=0
#mcu_pad_data_class2_ch1=1
#mcu_pad_data_drive_ch1=3
#mcu_pad_data_slew_ch1=3
#mcu_pad_addr_class2_ch1=0
#mcu_pad_addr_drive_ch1=3
#mcu_pad_addr_slew_ch1=3
#mcu_delay_dqi_adj_dir_ch1=1
#mcu_delay_dqi_adj_val_ch1=3
#mcu_delay_addr_adj_dir_ch1=1
#mcu_delay_addr_adj_val_ch1=0

# These following are only for BCM5665:
#mcu_drv_str0_ch2=1
#mcu_drv_str1_ch2=0
#mcu_pad_data_class2_ch2=1
#mcu_pad_data_drive_ch2=3
#mcu_pad_data_slew_ch2=3
#mcu_pad_addr_class2_ch2=0
#mcu_pad_addr_drive_ch2=3
#mcu_pad_addr_slew_ch2=3
#mcu_delay_dqi_adj_dir_ch2=1
#mcu_delay_dqi_adj_val_ch2=3
#mcu_delay_addr_adj_dir_ch2=1
#mcu_delay_addr_adj_val_ch2=0

#mcu_drv_str0_ch3=1
#mcu_drv_str1_ch3=0
#mcu_pad_data_class2_ch3=1
#mcu_pad_data_drive_ch3=3
#mcu_pad_data_slew_ch3=3
#mcu_pad_addr_class2_ch3=0
#mcu_pad_addr_drive_ch3=3
#mcu_pad_addr_slew_ch3=3
#mcu_delay_dqi_adj_dir_ch3=1
#mcu_delay_dqi_adj_val_ch3=3
#mcu_delay_addr_adj_dir_ch3=1
#mcu_delay_addr_adj_val_ch3=0

# The values may be set for all channels (though a channel-specific setting
# will override these):
#mcu_drv_str0=1
#mcu_drv_str1=0
#mcu_pad_data_class2=1
#mcu_pad_data_drive=3
#mcu_pad_data_slew=3
#mcu_pad_addr_class2=0
#mcu_pad_addr_drive=3
#mcu_pad_addr_slew=3
#mcu_delay_dqi_adj_dir=1
#mcu_delay_dqi_adj_val=3
#mcu_delay_addr_adj_dir=1
#mcu_delay_addr_adj_val=0

# BCM5665 MCU 16bit DDR configuration
#mcu_16bit_ddr=1

# BCM5665 family filter sizes
# The FE port filters on 5665/50/55 may be configured for two mask/rule sizes
# 256 rules and 16 masks (default)
# 128 rules and 24 masks
# Use this to select the 128/24 configuation for the chip.
#filter_resize=1

#
# Stacking related defines; see stk.soc for board related defines
#
#stkvlan=4092
#stkcos=7
#stkports="(0,24) (0,25)"
#
# Bitmap to indicate reserved modid's system wide
#stk_rsvd_modids=0

# Command memory controls
#memcmd_timeout_usec=10000000
#memcmd_intr_enable=1

# Timeout value in microseconds for BCM5660x search engine initialization
#seer_init_timeout_usec=50000

# Control to disable parity messages
#parity_enable=0

# Control to disable parity correction
#parity_correction=0

# Set BCM5660x external packet buffer to 500 MHz instead of 600 MHz
#pll600_slowclk=1

# For MCU Channel 0 only (0x2 for Channel 1 only)
#mcu_channel_bitmap=0x1

# MCU tuning parameters (Default values)
#mcu_tcrd=7
#mcu_tcwd=8
#mcu_twl=6
#mcu_dll90_offset_tx=3
#mcu_dll90_offset3=1
#mcu_dll90_offset2=1
#mcu_dll90_offset1=1
#mcu_dll90_offset0_qk=1
#mcu_dll90_offset_qkb=1
#mcu_sel_early2_3=0
#mcu_sel_early2_2=0
#mcu_sel_early2_1=0
#mcu_sel_early2_0=0
#mcu_sel_early1_3=1
#mcu_sel_early1_2=1
#mcu_sel_early1_1=1
#mcu_sel_early1_0=1
#mcu_odt_imp_enable=1

# Channel 0 only
#mcu_tcrd_ch0=7
#mcu_tcwd_ch0=8
#mcu_twl_ch0=6
#mcu_dll90_offset_tx_ch0=3
#mcu_dll90_offset3_ch0=1
#mcu_dll90_offset2_ch0=1
#mcu_dll90_offset1_ch0=1
#mcu_dll90_offset0_qk_ch0=1
#mcu_dll90_offset_qkb_ch0=1
#mcu_sel_early2_3_ch0=0
#mcu_sel_early2_2_ch0=0
#mcu_sel_early2_1_ch0=0
#mcu_sel_early2_0_ch0=0
#mcu_sel_early1_3_ch0=1
#mcu_sel_early1_2_ch0=1
#mcu_sel_early1_1_ch0=1
#mcu_sel_early1_0_ch0=1
#mcu_odt_imp_enable_ch0=1
#mcu_ovrd_sm_en_ch0=0
#mcu_phase_sel_ch0=0

# Channel 1 only
#mcu_tcrd_ch1=7
#mcu_tcwd_ch1=8
#mcu_twl_ch1=6
#mcu_dll90_offset_tx_ch1=3
#mcu_dll90_offset3_ch1=1
#mcu_dll90_offset2_ch1=1
#mcu_dll90_offset1_ch1=1
#mcu_dll90_offset0_qk_ch1=1
#mcu_dll90_offset_qkb_ch1=1
#mcu_sel_early2_3_ch1=0
#mcu_sel_early2_2_ch1=0
#mcu_sel_early2_1_ch1=0
#mcu_sel_early2_0_ch1=0
#mcu_sel_early1_3_ch1=1
#mcu_sel_early1_2_ch1=1
#mcu_sel_early1_1_ch1=1
#mcu_sel_early1_0_ch1=1
#mcu_odt_imp_enable_ch1=1
#mcu_ovrd_sm_en_ch1=0
#mcu_phase_sel_ch1=0

# DDR72 tuning parameters (Default values)
#ddr72_dll90_offset_tx=4
#ddr72_dll90_offset3=4
#ddr72_dll90_offset2=4
#ddr72_dll90_offset1=4
#ddr72_dll90_offset0_qk=4
#ddr72_dll90_offset_qkb=4
#ddr72_sel_early2_3=0
#ddr72_sel_early2_2=0
#ddr72_sel_early2_1=0
#ddr72_sel_early2_0=0
#ddr72_sel_early1_3=1
#ddr72_sel_early1_2=1
#ddr72_sel_early1_1=1
#ddr72_sel_early1_0=1
#ddr72_ovrd_sm_en=0
#ddr72_phase_sel=0

# QDR36 tuning parameters (Default values)
#qdr36_dll90_offset_tx=4
#qdr36_dll90_offset_qk=4
#qdr36_dll90_offset_qkb=4
#qdr36_sel_early2_1=0
#qdr36_sel_early2_0=0
#qdr36_sel_early1_1=1
#qdr36_sel_early1_0=1
#qdr36_ovrd_sm_en=0
#qdr36_phase_sel=0

#BCAM tuning
#seer_tunnel_sam=2

# Memory configuration

# No external mem (Default)
#seer_ext_table_cfg=0

# 512K L2
#seer_ext_table_cfg=1

# 256K LPM
#seer_ext_table_cfg=2

# 192K L4
#seer_ext_table_cfg=3

# 96K L4
#seer_ext_table_cfg=4

# 256K LPM 128K L4
#seer_ext_table_cfg=5

# 384K LPM 64K L4
#seer_ext_table_cfg=6

# 128K LPM 64K L4 (QDR testing)
#seer_ext_table_cfg=7

# 192K LPM 32K L4
#seer_ext_table_cfg=8

# 448K LPM
#seer_ext_table_cfg=9

# 896K LPM
#seer_ext_table_cfg=10

# No TCAM
#seer_ext_tcam_select=0

# Type 1 TCAM
#seer_ext_tcam_select=1

# Type 2 TCAM
#seer_ext_tcam_select=2

# All L2
#seer_host_hash_table_cfg=0

# Half L2, Half V4
#seer_host_hash_table_cfg=1

# Half L2, Quarter V4, Quarter V6 (Default)
#seer_host_hash_table_cfg=2

# Half L2, Half V6
#seer_host_hash_table_cfg=3

# Quarter L2, Half V4, Quarter V6
#seer_host_hash_table_cfg=4

# Quarter L2, Quarter V4, Half V6
#seer_host_hash_table_cfg=5

# All V4
#seer_host_hash_table_cfg=6

# Half V4, Half V6
#seer_host_hash_table_cfg=7

# All V6
#seer_host_hash_table_cfg=8

# All MAC_VLAN
#seer_mvl_hash_table_cfg=0

# Half MAC_VLAN, Half MYSTATION (Default)
#seer_mvl_hash_table_cfg=1

# All MYSTATION
#seer_mvl_hash_table_cfg=2


# External memory timing
#seer_hse_em_latency7=0

#seer_cse_em_latency7=0

# This setting may be used to change the number of LPM entries caches
# when performing traversals of the tables.  Increasing this number
# uses more memory for increased speed.
#seer_lpm_traverse_entries=100

# On BCM5662x devices, enable external TCAM lookup on XPORT block
# (back-panel ports) instead of XGPORT block (front-panel ports)
#ext_lookup_on_xport=1

# 72-bit external L2 forward table
#ext_l2_fwd_table_size=0

# 72-bit external IPv4 forward table
#ext_ip4_fwd_table_size=0

# 72-bit external IPv6 64-bit prefix length forward table
#ext_ip6u_fwd_table_size=0

# 144-bit external IPv6 128-bit prefix length forward table
#ext_ip6_fwd_table_size=0

# 288-bit external L2 ACL table
#ext_l2_acl_table_size=0

# 288-bit external IPv4 ACL table
#ext_ip4_acl_table_size=0

# 360-bit external IPv6 ACL table
#ext_ip6s_acl_table_size=0

# 432-bit external IPv6 ACL table
#ext_ip6f_acl_table_size=0

# 144-bit external L2 ACL table
#ext_l2c_acl_table_size=0

# 144-bit external IPv4 ACL table
#ext_ip4c_acl_table_size=0

# 144-bit external IPv6 ACL table
#ext_ip6c_acl_table_size=0

# 432-bit external L2 + IPv4 ACL table
#ext_l2ip4_acl_table_size=0

# 432-bit external L2 + IPv6 ACL table
#ext_l2ip6_acl_table_size=0

# External TCAM PLL frequency
#ext_tcam_mode=500

# External SRAM PLL frequency
#ext_sram_mode=334

# External TCAM mode, 0 for 6 cycles per pakcet, 1 for 4 cycles per packet
#ext_tcam_mode=0

# External SRAM mode, 0 for 1.5 clock latency, 1 for 2 clock latency
#ext_sram_mode=1

# External associated data mode:
# 1: 250 MHz, L2 table in ES0
# 2: 250 MHz, L2 table in ES1
# 3: 250 MHz, L3 table in ES0
# 4: 250 MHz, L3 table in ES1
# 5: 250 MHz, L2 and L3 table in ES0
# 6: 250 MHz, L2 and L3 table in ES1
# 7: 334 MHz, ACL table in ES0
# 8: 334 MHz, ACL table in ES1
# 9: 250 MHz, ACL table in both ES0 and ES1
# 10: 250 MHz, L2 and ACL table in both ES0 and ES1
# 11: 250 MHz, L3 and ACL table in both ES0 and ES1
# 12: 334 MHz, L2 and L3 and ACL table in both ES0 and ES1
#ext_ad_mode=12

# External IPv6 forwarding search key selection
# 0 for 72-bit, 1 for 144-bit
#ext_ip6_fwd_key=0

# External ACL search key selection for L2 packet
# 0 for disable, 1 for 288-bit, 2 for 144-bit
#ext_l2_acl_key=1

# External ACL search key selection for IPv4 packet
# 0 for disable, 1 for 288-bit, 2 for 144-bit, 3 for using both L2 and IP4 key,
# 4 for using L2 key
#ext_ip4_acl_key=1

# External ACL search key selection for IPV6 packet
# 0 for disable, 1 for 360-bit, 2 for 432-bit, 3 for 144-bit,
# 4 for using both L2 and IP6 key, 5 for using L2 key
#ext_ip6_acl_key=1

# RCPU master unit. This is unit which is used to inject pkts to slave rcpu device.
#rcpu_master_unit=0

# switch port connected to slave RCPU device.
#rcpu_port=3

# RCPU vlanid
#rcpu_vlan=1

# Use OOB (out of band) channel for sending/receiving rcpu packets
#rcpu_use_oob=1

# Mac driver/unit to use
#rcpu_oob_channel

# Valid ports on which RCPU packets can be receied by slave device.
#rcpu_rx_pbmp=0x4

# Enable diag shell port mapping. Port names will be assigned in
# dport order, and the BCM shell will list multiple ports in
# dport order regardless of the internal port numbering.
#dport_map_enable=1

# Port names for each port type (fe, ge, etc.) will increment
# by one starting at zero, e.g. if a switch has four xe ports
# with dport numbers 24, 25, 26, and 27, they will be named
# xe0, xe1, xe2, and xe3. In non-indexed mode the ports would
# be named xe24, xe25, xe26, and xe27.
#dport_map_indexed=1

# Traditionally, specifying a raw number instead of a port name
# in the diag shell will be parsed as if port numbers are counted
# from 1 up to the number of enabled ports. Typically this would
# mean that for a gigabit switch, port 1 would correspond to ge0,
# and so forth. Setting this flag causes raw port numbers to be
# parsed as internal port numbers.
#dport_map_direct=0

# Map dport number <dport> to internal port number <port>.
#dport_map_port_<port>=<dport>

# Port number and bandwidth assignment.
# For example, portmap_5=9:40:EQ assigns physical port 9 as port 5, the
# maximum bandwidth is 40Gb, the port is expected to support extended queueing.
#portmap_<port>=<physical port number>:<bandwidth in Gb>[:EQ]

# Flex port config per port group in terms of number of lanes per port in the group.
# This can be used to configure the flex ports in any mode at system init time.
# For example portgroup_0=1 creates 4 ports with single lane each in port group 0.
# Valid values for num_lanes are 1, 2, 4.
#portgroup_<group_no>=<num_lanes>

# Enable translation of physical port numbers within the BCM layer.
# This feature allows a new device to emulate an older similar
# device even if the physical port map is different. Note that
# translation support must be compiled in as well.
#bcm_xlate_api_port_enable=1

# Specify a BCM port translation map.
#bcm_xlate_port_map=bcm56524_to_bcm56504
#bcm_xlate_port_map=bcm56620_to_bcm56504
#bcm_xlate_port_map=bcm56630_to_bcm56504
#bcm_xlate_port_map=bcm56524_single_modid
#bcm_xlate_port_map=bcm56636_single_modid
#bcm_xlate_port_map=bcm56636_single_modid_alt

# Allow customized BCM translation maps. The example below will
# map physical port 2 to BCM port 0.
#bcm_xlate_port_2=0

# Enable translation of system port numbers to physical port numbers
# in hardware (if supported by the switch device). This feature may
# be used to complement the BCM API translation feature, but can
# also be used to limit the use of module IDs on devices with 32 or
# fewer ports in case some physical port numbers reside beyond 31.
#bcm_xlate_sysport_enable=0

# Convenience variable that can be used to turn off both physical
# and system port mapping. This variable overrides the dedicated
# variables described above.
#bcm_xlate_port_enable=1

# Interval (in usecs) at which the port monitor thread will run.
# The port monitor can be used to handle workarounds which are
# required only with specific equipment configurations.
#portmon_interval=0

# Select whether to always attach the corresponding Serdes shadow
# driver for Raptor and Raven devices. Note that when deciding
# which driver to attach, MDIO accesses are also verified indepedently
# and checked for corruption. If corruption is detected, the
# shadow driver is attached regardless of this property.
# To always attach the shadow driver for a port:
#serdes_shadow_driver_<port>=1

############################################################################
#  BCM5321 / BCM5320 Selection
############################################################################
# Select either BCM5321 or BCM5320(16 / 8 ports of BCM5324 family)
############################################################################

# It is BCM5321
# bcm5321=1

# It is BCM5320
# bcm5320=1

#  BCM5321 / BCM5320 Selection

#MACSEC PHY properties
#The following proporties are effective on MACSEC capable PHYs. Currently
#BCM54580 family based PHYs are MACSEC capable.

#Enable MACSEC feature on the MACSEC phys.
#macsec_enable

#MACSEC device address. MACSEC devices address, used to adress MACSEC core.
#This is MDIO address that is being assigned to MACSEC core. The MDIO address
#gets programmed to MACSEC PHY during initialization if MACSEC is enabled.
#macsec_dev_addr

#A MACSEC phy could be an integrated PHYs with multiple ports. This property
#is needed to identify the index of each PHY port.
#macsec_port_index

#Define port bitmap of FE ports that use 100-FX mode.
#pbmp_fe_100fx=0xffffff

#
# CES Properties
#
# ces_port_tdm_proto - This property selects the TDM protocol to be used for the TDM ports.
# Valid values are T1 and E1, default is T1.
#ces_port_tdm_proto=E1

#
# RX COS queues (5644x)
#
# Queues assignment to share across host CPU and uControllers.
# By default, all 48 queues are assigned to the host CPU.  The sum
# of all queues must be equal to 48.
#
#num_queues_pci=48
#num_queues_uc0=0
#num_queues_uc1=0
#

#
# BFD
#
# BFD COS queue.  Default is highest available queue assigned to the uC
# where the BFD application is running on.
#bfd_cosq=
#
# Maximum number of BFD sessions
#bfd_num_sessions=256
#
# Maximum number of Simple Password and SHA1 keys
#bfd_simple_password_keys=0
#bfd_sha1_keys=0
#

#
# Triumph3 ESM
#
# Specifying MDIO port addresses for the external tcams. tcam0 default is 1
# tcam1 default is 2 for broadcom boards.
# port_phy_addr_ext_tcam0
# port_phy_addr_ext_tcam1
#

# Memory table size configs in terms of the widest entry type.
#l2_mem_entries=<>
#l3_mem_entries=<>
#vlan_xlate_mem_entries=<>
#egr_vlan_xlate_mem_entries=<>
#mpls_mem_entries=<>

#
# Accelerated Linkscan
#
# Enables accelerated linkscan mode on given port.
# This feature is not enabled by default.
# This is a per-port property.
# rx_fast_los_link_<port>
# rx_fast_los_link_xe=1
# rx_fast_los_link=1
#
# Indicates the time interval in usecs when linkscan is in accelerated mode.
# rx_fast_los_usec=100000
#
# Indicates the maximum number of times Linkscan will poll in
# accelerated mode without a status change in any accelerated mode ports.
# rx_fast_los_poll_count_max=10

