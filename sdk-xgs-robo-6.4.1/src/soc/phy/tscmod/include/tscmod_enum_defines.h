/*----------------------------------------------------------------------
 * $Id: tscmod_enum_defines.h,v 1.16 Broadcom SDK $
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * Broadcom Corporation                                                 
 * Proprietary and Confidential information                             
 * All rights reserved                                                  
 * This source file is the property of Broadcom Corporation, and        
 * may not be copied or distributed in any isomorphic form without the  
 * prior written consent of Broadcom Corporation.                       
 *--------------------------------------------------------------------- 
 * Description: This file is automatically generated. It contains enums,
 * elems, and doxygen comments needed for SerDes Configuration programs.
 *--------------------------------------------------------------------- 
 * CVS INFORMATION:                                                     
 * Please see inc/enum_desc.txt for CVS information.                    
 *----------------------------------------------------------------------
 */

/* This file is automatically generated. Do not modify it. Modify the
 * inc/enum_desc.txt to change enums, elems, or comments. For issues about
 * the process that creates this file contact the tscmod development team.
 */

#ifndef _TSCMOD_ENUM_DEFINES_H
#define _TSCMOD_ENUM_DEFINES_H

/*! \enum tscmod_lane_select 

A '1' in the latter part of the enum name signifies that the lane is selected.
Other parameters in the TSC context will decide what to do with the
selected  lane(s). In most cases we either enable or disable a feature on the
selected lanes.

In the future, multiple lanes can be supported with a single call (for example,
disable autoneg on lanes 1,  and 3. only.)
But currently Tier1s only support operations on a single lane. If multiple
lanes need to be programmed, multiple calls to Tier1s should be made.

Lane selection is enumerated to avoid wrong selection of lanes.

In the future release, we can select all lanes, but not be in broadcast mode.
Currently lane_select is set to TSCMOD_LANE_BCST to broadcast to all lanes.

Note that when you write, data is broadcast to registers of all lanes. But when
you read in broadcast mode, the value of the register in lane 0 is returned.

*/

typedef enum {
  TSCMOD_LANE_0_0_0_1        = 0   ,  /*!< lane number  0       selected   */
  TSCMOD_LANE_0_0_1_0              ,  /*!< lane number  1       selected   */
  TSCMOD_LANE_0_0_1_1              ,  /*!< lane numbers 0,1     selected   */
  TSCMOD_LANE_0_1_0_0              ,  /*!< lane number  2       selected   */
  TSCMOD_LANE_0_1_0_1              ,  /*!< lane numbers 2,0     selected   */
  TSCMOD_LANE_0_1_1_0              ,  /*!< lane numbers 2,1     selected   */
  TSCMOD_LANE_0_1_1_1              ,  /*!< lane numbers 2,1,0   selected   */
  TSCMOD_LANE_1_0_0_0              ,  /*!< lane number  3       selected   */
  TSCMOD_LANE_1_0_0_1              ,  /*!< lane numbers 3,0     selected   */
  TSCMOD_LANE_1_0_1_0              ,  /*!< lane numbers 3,1     selected   */
  TSCMOD_LANE_1_0_1_1              ,  /*!< lane numbers 3,1,0   selected   */
  TSCMOD_LANE_1_1_0_0              ,  /*!< lane numbers 3,2     selected   */
  TSCMOD_LANE_1_1_0_1              ,  /*!< lane numbers 3,2,0   selected   */
  TSCMOD_LANE_1_1_1_0              ,  /*!< lane numbers 3,2,1   selected   */
  TSCMOD_LANE_1_1_1_1              ,  /*!< lane numbers 3,2,1,0 selected   */
  TSCMOD_LANE_BCST                 ,  /*!< lane numbers 3,2,1,0 BCST       */
  TSCMOD_LANE_ILLEGAL                /*!< Illegal (programmatic boundary) */
} tscmod_lane_select;

/*! \def CNT_tscmod_lane_select Types of enum tscmod_lane_select */
#define CNT_tscmod_lane_select 17

/*!
\brief
This array returns the string version of the enum #tscmod_lane_select when indexed by the
enum var.

*/
extern char* e2s_tscmod_lane_select [CNT_tscmod_lane_select];
/*!
\brief
This array associates the enum #tscmod_lane_select enum with a bit mask.
The index is the #tscmod_lane_select enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/
extern int e2n_tscmod_lane_select [CNT_tscmod_lane_select];
/*! \enum tscmod_spd_intfc_type 

All legal speed-interface combination are encapsulated in this enum

There are 42 speed and interface combinations allowed for a logical TSC
port. Names and speeds are self explanatory.

Speed and interface selection is combined because we don't want the speeds
to be incompatible with interface.

*/

typedef enum {
  TSCMOD_SPD_ZERO            = 0   ,  /*!< Illegal value (programmatic boundary)      */
  TSCMOD_SPD_10_SGMII              ,  /*!< 10Mb SGMII (serial)                        */
  TSCMOD_SPD_100_SGMII             ,  /*!< 100Mb SGMII (serial)                       */
  TSCMOD_SPD_1000_SGMII            ,  /*!< 1Gb SGMII (serial)                         */
  TSCMOD_SPD_2500                  ,  /*!< 2.5Gb (BRCM prop.) based on 1000BASE-X     */
  TSCMOD_SPD_5000                  ,  /*!< 5Gb XFI type                               */
  TSCMOD_SPD_10000_XFI             ,  /*!< 10Gb serial XFI                            */
  TSCMOD_SPD_10600_XFI_HG          ,  /*!< 10.5Gb serial XFI (HgSOLO)                 */
  TSCMOD_SPD_10000_HI              ,  /*!< 10Gb XAUI HiG (BRCM prop.)                 */
  TSCMOD_SPD_10000                 ,  /*!< 10Gb XAUI                                  */
  TSCMOD_SPD_12000_HI              ,  /*!< 10Gb XAUI HiG (BRCM prop.)                 */
  TSCMOD_SPD_13000                 ,  /*!< 13Gb XAUI (BRCM prop.)                     */
  TSCMOD_SPD_15000                 ,  /*!< 15Gb XAUI (BRCM prop.)                     */
  TSCMOD_SPD_16000                 ,  /*!< 16Gb XAUI (BRCM prop.)                     */
  TSCMOD_SPD_20000                 ,  /*!< 20Gb XAUI (BRCM prop.)                     */
  TSCMOD_SPD_20000_SCR             ,  /*!< 20Gb XAUI scrambled output                 */
  TSCMOD_SPD_21000                 ,  /*!< 21Gb XAUI (BRCM prop.)                     */
  TSCMOD_SPD_25455                 ,  /*!< 25Gb XAUI (BRCM prop.) 64/66 codec         */
  TSCMOD_SPD_31500                 ,  /*!< 31.5Gb quad lane XAUI (BRCM prop.)         */
  TSCMOD_SPD_40G_X4                ,  /*!< 40Gb quad lane XAUI (BRCM prop.)           */
  TSCMOD_SPD_42G_X4                ,  /*!< 40Gb quad lane XAUI (BRCM prop.) HiG       */
  TSCMOD_SPD_40G_MLD               ,  /*!< 40Gb quad lane  MLD                        */
  TSCMOD_SPD_42G_MLD               ,  /*!< 42Gb quad lane  MLD                        */
  TSCMOD_SPD_10000_X2              ,  /*!< 10Gb dual lane CSCO                        */
  TSCMOD_SPD_10000_HI_DXGXS        ,  /*!< 10Gb dual lane XGXS HiG (BRCM prop.)       */
  TSCMOD_SPD_10000_DXGXS           ,  /*!< 10Gb dual lane XGXS (BRCM prop.)           */
  TSCMOD_SPD_10000_HI_DXGXS_SCR       ,  /*!< 10Gb dual lane scrambled output HiG        */
  TSCMOD_SPD_10000_DXGXS_SCR       ,  /*!< 10Gb dual lane scrambled output            */
  TSCMOD_SPD_10500_HI_DXGXS        ,  /*!< 10.5Gb dual lane XGXS HiG (BRCM prop.)     */
  TSCMOD_SPD_12773_HI_DXGXS        ,  /*!< 12.73Gb dual lane XGXS HiG (BRCM prop.)    */
  TSCMOD_SPD_12773_DXGXS           ,  /*!< 12.73Gb dual lane XGXS (BRCM prop.)        */
  TSCMOD_SPD_15750_HI_DXGXS        ,  /*!< 15.75Gb scrambled dual lane HiG(BRCM prop) */
  TSCMOD_SPD_20G_MLD_DXGXS         ,  /*!< 20Gb dual lane MLD                         */
  TSCMOD_SPD_21G_HI_MLD_DXGXS       ,  /*!< 20Gb dual lane HiG MLD                     */
  TSCMOD_SPD_20G_DXGXS             ,  /*!< 20Gb dual lane BRCM                        */
  TSCMOD_SPD_21G_HI_DXGXS          ,  /*!< 21.2Gb dual HiG(BRCM prop.)(20+plldiv=70)  */
  TSCMOD_SPD_100G_CR10             ,  /*!< 100G                                       */
  TSCMOD_SPD_120G_CR12             ,  /*!< 120G                                       */
  TSCMOD_SPD_ILLEGAL                 /*!< Illegal value (programmatic boundary)      */
} tscmod_spd_intfc_type;

/*! \def CNT_tscmod_spd_intfc_type Types of enum tscmod_spd_intfc_type */
#define CNT_tscmod_spd_intfc_type 39

/*!
\brief
This array returns the string version of the enum #tscmod_lane_select when indexed by the
enum var.

*/
extern char* e2s_tscmod_spd_intfc_type [CNT_tscmod_spd_intfc_type];
/*!
\brief
This array associates the enum #tscmod_lane_select enum with a bit mask.
The index is the #tscmod_lane_select enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/
extern int e2n_tscmod_spd_intfc_type [CNT_tscmod_spd_intfc_type];
/*! \enum tscmod_regacc_type 

Types of MDIO to access TSC registers. 22 (32 registers) and 45 are
supported. Picking 22 automatically selects BRCM prop.) clause 22 mode
with extensions for 64K registers.  Actual clause 22 is not yet supported.

*/

typedef enum {
  TSCMOD_MDIO_CL22           = 0   ,  /*!< IEEE clause 22 (BRCM prop.) based MDIO */
  TSCMOD_MDIO_CL45                 ,  /*!< IEEE clause 45 based MDIO */
  TSCMOD_MDIO_CL22_IEEE            ,  /*!< IEEE clause 22 (not BRCM prop.) based MDIO */
  TSCMOD_MDIO_PCB                  ,  /*!< For verilog only (drive parallel bus) */
  TSCMOD_MDIO_TOTSC                ,  /*!< TO_TSC bus */
  TSCMOD_MDIO_ILLEGAL                /*!<  */
} tscmod_regacc_type;

/*! \def CNT_tscmod_regacc_type Types of enum tscmod_regacc_type */
#define CNT_tscmod_regacc_type 6

/*!
\brief
This array returns the string version of the enum #tscmod_mdio_type when indexed
by the enum var.

*/
extern char* e2s_tscmod_regacc_type [CNT_tscmod_regacc_type];
/*! \enum tscmod_port_type 

This is the port mode type enumeration.

TSC can be configured in single port mode (i.e. TSC is one single port) or
multilane mode (i.e. TSC has more than one port (2, 3, or 4) that are
controlled individually.

*/

typedef enum {
  TSCMOD_SINGLE_PORT         = 0   ,  /*!< single port mode: 4 channels as one logical port */
  TSCMOD_MULTI_PORT                ,  /*!< Each channel is one logical port */
  TSCMOD_DXGXS                     ,  /*!< Each paired channel(0-1, 2-3) is one logical port */
  TSCMOD_PORT_MODE_ILLEGAL           /*!<  */
} tscmod_port_type;

/*! \def CNT_tscmod_port_type Types of enum tscmod_port_type */
#define CNT_tscmod_port_type 4

/*!
\brief
This array returns the string version of the enum #tscmod_port_type when indexed
by the enum var.

*/
extern char* e2s_tscmod_port_type [CNT_tscmod_port_type];
/*! \enum tscmod_os_type 

Oversampling type. The oversampling is fixed for single port. But can be configured
in multilane mode to either 0S5 or OS8

*/

typedef enum {
  TSCMOD_OS1                 = 0   ,  /*!< Hardly ever used. */
  TSCMOD_OS2                       ,  /*!< Hardly ever used. */
  TSCMOD_OS3                       ,  /*!< Hardly ever used. */
  TSCMOD_OS3p3                     ,  /*!< Hardly ever used. */
  TSCMOD_OS5                       ,  /*!< TSC Independent mode can have OS5 or OS8 */
  TSCMOD_OS6                       ,  /*!< This mode is exclusive to QUAD_SGMII */
  TSCMOD_OS_IND_LANE               ,  /*!< This mode is exclusive to XENIA */
  TSCMOD_OS8                       ,  /*!< TSC Independent mode can have OS5 or OS8 */
  TSCMOD_OS8p25                    ,  /*!< TSC Independent mode can have OS5 or OS8 */
  TSCMOD_OS_ILLEGAL                  /*!<  */
} tscmod_os_type;

/*! \def CNT_tscmod_os_type Types of enum tscmod_os_type */
#define CNT_tscmod_os_type 10

/*!
\brief
This array returns the string version of the enum #tscmod_port_type when indexed
by the enum var.

*/
extern char* e2s_tscmod_os_type [CNT_tscmod_os_type];
/*! \enum tscmod_duplex_type 

tscmod_duplex_type Duplex types (only half and full duplex supported)

*/

typedef enum {
  TSCMOD_SIMPLEX             = 0   ,  /*!< This is never used in TSC or any modern PHY chips */
  TSCMOD_HALF_DUPLEX               ,  /*!< This is relevent only for 1G and below */
  TSCMOD_DUPLEX                    ,  /*!< This is default for 10G and above */
  TSCMOD_DUPLEX_ILLEGAL              /*!< Illegal value. programmatic boundary. */
} tscmod_duplex_type;

/*! \def CNT_tscmod_duplex_type Types of enum tscmod_duplex_type */
#define CNT_tscmod_duplex_type 4

/*!
\brief
This array returns the string version of the enum #tscmod_port_type when indexed
by the enum var.

*/
extern char* e2s_tscmod_duplex_type [CNT_tscmod_duplex_type];
/*! \enum tscmod_diag_type 

tscmod_diag_type enumerates categories of diagnostic data.
has many intermediate stages between down and up. This enum is work in progress


<table cellspacing=0>
<tr><td colspan=3><B>'per_lane_control' bit-mappings</B></td></tr>

<tr><td><B>Type</B></td><td><B>Description</B></td><td><B>Scope</B></td></tr>

<tr><td>General</td>
<td> single/multi port, Device and Revision Id, VCO settings, Firmware state
and version, active/passive lanes, MDIO type. PLL info, Oversampling Info</td>
<td>Device</td></tr>

<tr><td>Link</td>
<td> Speeds, oversampling, interface, forced/Autoneg, link status, sync
status, RX sequencer on/off </td>
<td>Lane</td></tr>

<tr><td>Autoneg</td>
<td> Local and remote advertisement, link status, cl73/37/BAM info </td>
<td>Lane</td></tr>

<tr><td>Internal Traffic</td>
<td> PRBS type, CJPat Type, Prog_data value, Any associated recorded errors,
and misc. info (IPG etc.)</td>
<td>Lane </td></tr>

<tr>
<td>DFE</td>
<td>Equalization info, Tap settings. (pre/post/overrides), peaking filter values </td>
<td>Lane</td></tr>

<tr><td>IEEE info</td>
<td>Clause 72, FEC</td>
<td>Lane</td></tr>

<tr><td>Topology</td>
<td>Looping info (Gloop/rloop), lane swapping, polarity swap info</td>
<td>Device</td></tr>

<tr><td>EEE</td>
<td>EEE full, passthru modes, some window values?</td>
<td>Lane</td></tr>

<tr><td>Eye Margin</td>
<td>Eye margin measurement (readout only)</td>
<td>Lane</td></tr>

<tr><td>All</td>
<td>All of the above. Except eye margin.</td>
<td>Device</td></tr>

</table>


*/

typedef enum {
  TSCMOD_DIAG_GENERAL        = 0x00001 ,  /*!< General device wide information.         */
  TSCMOD_DIAG_LINK           = 0x00002 ,  /*!< Link specific info.                      */
  TSCMOD_DIAG_ANEG           = 0x00004 ,  /*!< Autoneg specific info.                   */
  TSCMOD_DIAG_TFC            = 0x00008 ,  /*!< State of tx/rx internal tfc              */
  TSCMOD_DIAG_DFE            = 0x00010 ,  /*!< DFE related info.                        */
  TSCMOD_DIAG_SLICERS        = 0x00020 ,  /*!< P1, M1, D  slicer values. */
  TSCMOD_DIAG_TX_AMPS        = 0x00040 ,  /*!< Idriver, Predriver, post2_coef */
  TSCMOD_DIAG_TX_TAPS        = 0x00080 ,  /*!< Pre, Main, Post */
  TSCMOD_DIAG_RX_TAPS        = 0x00100 ,  /*!< PF,  VGA, TAP1 through TAP5 */
  TSCMOD_DIAG_IEEE           = 0x00200 ,  /*!< IEEE related info                        */
  TSCMOD_DIAG_TOPOLOGY       = 0x00400 ,  /*!< Loopbacks etc.                           */
  TSCMOD_DIAG_EEE            = 0x00800 ,  /*!< EEE                                      */
  TSCMOD_DIAG_EYE            = 0x01000 ,  /*!< eye margin msmt                          */
  TSCMOD_DIAG_SPEED          = 0x02000 ,  /*!< sub-category of TSCMOD_DIAG_LINK(for SDK) */
  TSCMOD_DIAG_TX_LOOPBACK    = 0x04000 ,  /*!< sub-category of TSCMOD_DIAG_TOPOLOGY(for SDK) */
  TSCMOD_DIAG_RX_LOOPBACK    = 0x08000 ,  /*!< sub-category of TSCMOD_DIAG_TOPOLOGY(for SDK) */
  TSCMOD_DIAG_RX_PPM         = 0x10000 ,  /*!< ppm offset that receiver is tracking */
  TSCMOD_DIAG_PRBS           = 0x20000 ,  /*!< prbs info */
  TSCMOD_DIAG_RX_SIGDET      = 0x40000 ,  /*!< Per lane rx signal detect info. */
  TSCMOD_DIAG_POKE           = 0x80000 ,  /*!< poke debug function */
  TSCMOD_DIAG_CL72           =0x100000 ,  /*!< CL72 status function */
  TSCMOD_DIAG_PLL            =0x200000 ,  /*!< PLL status function */
  TSCMOD_DIAG_PMD            =0x400000 ,  /*!< PMD status function */
  TSCMOD_DIAG_HG             =0x800000 ,  /*!< HG status function */
  TSCMOD_DIAG_ALL            =0xffffff ,  /*!< Everything but eye margin                */
  TSCMOD_DIAG_ILLEGAL        = 0x00000   /*!< Illegal value. programmatic boundary.    */
} tscmod_diag_type;

/*! \def CNT_tscmod_diag_type Types of enum tscmod_diag_type */
#define CNT_tscmod_diag_type 26

/*!
\brief
This array returns the string version of the enum #tscmod_port_type when indexed
by the enum var.

*/
extern char* e2s_tscmod_diag_type [CNT_tscmod_diag_type];
/*! \enum tscmod_diag_idx_type 

tscmod_diag_idx_type enumerates categories of diagnostic data.
has many intermediate stages between down and up. This enum mirrors with tscmod_diag_type
for string printing.


*/

typedef enum {
  TSCMOD_DIAG_GENERAL_IDX    = 0   ,  /*!< General device wide information.                 */
  TSCMOD_DIAG_LINK_IDX             ,  /*!< Link specific info.                              */
  TSCMOD_DIAG_ANEG_IDX             ,  /*!< Autoneg specific info.                           */
  TSCMOD_DIAG_TFC_IDX              ,  /*!< State of tx/rx internal tfc                      */
  TSCMOD_DIAG_DFE_IDX              ,  /*!< DFE related info.                                */
  TSCMOD_DIAG_SLICERS_IDX          ,  /*!< P1, M1, D  slicer values.                        */
  TSCMOD_DIAG_TX_AMPS_IDX          ,  /*!< Idriver, Predriver, post2_coef                   */
  TSCMOD_DIAG_TX_TAPS_IDX          ,  /*!< Pre, Main, Post                                  */
  TSCMOD_DIAG_RX_TAPS_IDX          ,  /*!< PF,  VGA, TAP1 through TAP5                      */
  TSCMOD_DIAG_IEEE_IDX             ,  /*!< IEEE related info                                */
  TSCMOD_DIAG_TOPOLOGY_IDX         ,  /*!< Loopbacks etc.                                   */
  TSCMOD_DIAG_EEE_IDX              ,  /*!< EEE                                              */
  TSCMOD_DIAG_EYE_IDX              ,  /*!< eye margin msmt                                  */
  TSCMOD_DIAG_SPEED_IDX            ,  /*!< sub-category of TSCMOD_DIAG_LINK(for SDK)        */
  TSCMOD_DIAG_TX_LOOPBACK_IDX       ,  /*!< sub-category of TSCMOD_DIAG_TOPOLOGY(for SDK)    */
  TSCMOD_DIAG_RX_LOOPBACK_IDX       ,  /*!< sub-category of TSCMOD_DIAG_TOPOLOGY(for SDK)    */
  TSCMOD_DIAG_RX_PPM_IDX           ,  /*!< ppm offset that receiver is tracking             */
  TSCMOD_DIAG_PRBS_IDX             ,  /*!< prbs info                                        */
  TSCMOD_DIAG_RX_SIGDET_IDX        ,  /*!< Per lane rx signal detect info.                  */
  TSCMOD_DIAG_POKE_IDX             ,  /*!< poke debug function */
  TSCMOD_DIAG_CL72_IDX             ,  /*!< CL72 status function */  
  TSCMOD_DIAG_PLL_IDX              ,  /*!< PLL status function */  
  TSCMOD_DIAG_PMD_IDX              ,  /*!< PMD status function */  
  TSCMOD_DIAG_HG_IDX              ,  /*!< HG status function   */
  TSCMOD_DIAG_ALL_IDX              ,  /*!< Everything but eye margin                        */
  TSCMOD_DIAG_IDX_ILLEGAL            /*!< Illegal value. programmatic boundary.            */
} tscmod_diag_idx_type;

/*! \def CNT_tscmod_diag_idx_type Types of enum tscmod_diag_idx_type */
#define CNT_tscmod_diag_idx_type 26

/*!
\brief
This array returns the string version of the enum #tscmod_port_type when indexed
by the enum var.

*/
extern char* e2s_tscmod_diag_idx_type [CNT_tscmod_diag_idx_type];
/*!
\brief
This array associates the enum #tscmod_lane_select enum with a bit mask.
The index is the #tscmod_lane_select enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/
extern int e2n_tscmod_diag_idx_type [CNT_tscmod_diag_idx_type];
/*! \enum tscmod_diag_an_type 

tscmod_diag_an_type enumerates different modes used in TSCMOD_DIAG_ANEG.


*/

typedef enum {
  TSCMOD_DIAG_AN_DONE        = 0   ,  /*!< AN completion check. */
  TSCMOD_DIAG_AN_HCD               ,  /*!< AN HCD speed check. */
  TSCMOD_DIAG_AN_MODE              ,  /*!< AN MODE info. */
  TSCMOD_DIAG_AN_TYPE_ILLEGAL         /*!< Illegal value. programmatic boundary. */
} tscmod_diag_an_type;

/*! \def CNT_tscmod_diag_an_type Types of enum tscmod_diag_an_type */
#define CNT_tscmod_diag_an_type 4

/*!
\brief
This array returns the string version of the enum #tscmod_port_type when indexed
by the enum var.

*/
extern char* e2s_tscmod_diag_an_type [CNT_tscmod_diag_an_type];
/*! \enum tscmod_diag_general_type 

tscmod_diag_general_type enumerates different modes used in TSCMOD_DIAG_GENERAL.


*/

typedef enum {
  TSCMOD_DIAG_G_INFO         = 0   ,
  TSCMOD_DIAG_G_PORT               ,  /*!< port diag. */
  TSCMOD_DIAG_G_CFG                ,  /*!< port cfg diag. */
  TSCMOD_DIAG_G_SPEED              ,  /*!< speed diag. */
  TSCMOD_DIAG_G_AN                 ,  /*!< an diag. */
  TSCMOD_DIAG_G_DSC                ,  /*!< dsc diag. */
  TSCMOD_DIAG_G_DSC_CFG            ,  /*!< dsc related cfg. */
  TSCMOD_DIAG_G_UCODE              ,  /*!< ucode FSM */
  TSCMOD_DIAG_G_PATTERN            ,  /*!< test patterns */
  TSCMOD_DIAG_G_PATH               ,  /*!< loopback, polarity, swap  */
  TSCMOD_DIAG_G_PMAPMD             ,  /*!< PMA/PMD */
  TSCMOD_DIAG_G_CL72               ,  /*!< CL72 */
  TSCMOD_DIAG_G_MISC1              ,  /*!< TBD  */
  TSCMOD_DIAG_G_MISC2              ,  /*!< TBD */
  TSCMOD_DIAG_G_MISC3              ,  /*!< TBD */
  TSCMOD_DIAG_G_TYPE_ILLEGAL         /*!< Illegal value. programmatic boundary. */
} tscmod_diag_general_type;

/*! \def CNT_tscmod_diag_general_type Types of enum tscmod_diag_general_type */
#define CNT_tscmod_diag_general_type 16

/*!
\brief
This array returns the string version of the enum #tscmod_port_type when indexed
by the enum var.

*/
extern char* e2s_tscmod_diag_general_type [CNT_tscmod_diag_general_type];
/*! \enum tscmod_aspd_type 

tscmod_aspd_type enumerates SW actual speed.


*/

typedef enum {
  TSCMOD_ASPD_10M            = 0   ,  /*!< Actual speed info                 */
  TSCMOD_ASPD_100M                 ,  /*!<  */
  TSCMOD_ASPD_1000M                ,  /*!<  */
  TSCMOD_ASPD_2p5G_X1              ,  /*!<  */
  TSCMOD_ASPD_5G_X4                ,  /*!<  */
  TSCMOD_ASPD_6G_X4                ,  /*!<  */
  TSCMOD_ASPD_10G_X4               ,  /*!<  */
  TSCMOD_ASPD_10G_CX4              ,  /*!<  */
  TSCMOD_ASPD_12G_X4               ,  /*!<  */
  TSCMOD_ASPD_12p5G_X4             ,  /*!<  */
  TSCMOD_ASPD_13G_X4               ,  /*!<  */
  TSCMOD_ASPD_15G_X4               ,  /*!<  */
  TSCMOD_ASPD_16G_X4               ,  /*!<  */
  TSCMOD_ASPD_1G_KX1               ,  /*!<  */
  TSCMOD_ASPD_10G_KX4              ,  /*!<  */
  TSCMOD_ASPD_10G_KR1              ,  /*!<  */
  TSCMOD_ASPD_5G_X1                ,  /*!<  */
  TSCMOD_ASPD_6p36G_X1             ,  /*!<  */
  TSCMOD_ASPD_20G_CX4              ,  /*!<  */
  TSCMOD_ASPD_21G_X4               ,  /*!<  */
  TSCMOD_ASPD_25p45G_X4            ,  /*!<  */
  TSCMOD_ASPD_10G_X2_NOSCRAMBLE       ,  /*!<  */
  TSCMOD_ASPD_10G_CX2_NOSCRAMBLE       ,  /*!<  */
  TSCMOD_ASPD_10p5G_X2             ,  /*!<  */
  TSCMOD_ASPD_10p5G_CX2_NOSCRAMBLE       ,  /*!<  */
  TSCMOD_ASPD_12p7G_X2             ,  /*!<  */
  TSCMOD_ASPD_12p7G_CX2            ,  /*!<  */
  TSCMOD_ASPD_10G_X1               ,  /*!<  */
  TSCMOD_ASPD_40G_X4               ,  /*!<  */
  TSCMOD_ASPD_20G_X2               ,  /*!<  */
  TSCMOD_ASPD_20G_CX2              ,  /*!<  */
  TSCMOD_ASPD_10G_SFI              ,  /*!<  */
  TSCMOD_ASPD_31p5G_X4             ,  /*!<  */
  TSCMOD_ASPD_32p7G_X4             ,  /*!<  */
  TSCMOD_ASPD_20G_X4               ,  /*!<  */
  TSCMOD_ASPD_10G_X2               ,  /*!<  */
  TSCMOD_ASPD_10G_CX2              ,  /*!<  */
  TSCMOD_ASPD_12G_SCO_R2           ,  /*!<  */
  TSCMOD_ASPD_10G_SCO_X2           ,  /*!<  */
  TSCMOD_ASPD_40G_KR4              ,  /*!<  */
  TSCMOD_ASPD_40G_CR4              ,  /*!<  */
  TSCMOD_ASPD_100G_CR10            ,  /*!<  */
  TSCMOD_ASPD_5G_X2                ,  /*!<  */
  TSCMOD_ASPD_15p75G_X2            ,  /*!<  */
  TSCMOD_ASPD_2G_FC                ,  /*!<  */
  TSCMOD_ASPD_4G_FC                ,  /*!<  */
  TSCMOD_ASPD_8G_FC                ,  /*!<  */
  TSCMOD_ASPD_10G_CX1              ,  /*!<  */
  TSCMOD_ASPD_1G_CX1               ,  /*!<  */
  TSCMOD_ASPD_20G_KR2              ,  /*!<  */
  TSCMOD_ASPD_20G_CR2              ,  /*!<  */
  TSCMOD_ASPD_TYPE_ILLEGAL           /*!< Illegal value. programmatic boundary. */
} tscmod_aspd_type;

/*! \def CNT_tscmod_aspd_type Types of enum tscmod_aspd_type */
#define CNT_tscmod_aspd_type 52

/*!
\brief
This array returns the string version of the enum #tscmod_port_type when indexed
by the enum var.

*/
extern char* e2s_tscmod_aspd_type [CNT_tscmod_aspd_type];
/*!
\brief
This array associates the enum #tscmod_lane_select enum with a bit mask.
The index is the #tscmod_lane_select enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/
extern int e2n_tscmod_aspd_type [CNT_tscmod_aspd_type];
/*! \enum tscmod_model_type 

tscmod_model_type enumerates different generations and  revisions of TSC.
Note that we pretty much only look at different versions of TSC.

We rely on all the information being in the SERDES_ID register.


*/

typedef enum {
  TSCMOD_WC                  = 0   ,  /*!< Generic TSC (any model) */
  TSCMOD_A0                        ,  /*!< TSC Version A0 */
  TSCMOD_MODEL_TYPE_ILLEGAL          /*!< Illegal value. programmatic boundary. */
} tscmod_model_type;

/*! \def CNT_tscmod_model_type Types of enum tscmod_model_type */
#define CNT_tscmod_model_type 3

/*!
\brief
This array returns the string version of the enum #tscmod_port_type when indexed
by the enum var.

*/
extern char* e2s_tscmod_model_type [CNT_tscmod_model_type];
/*! \enum tscmod_an_type 

tscmod_an_type enumerates different types of autoneg modes in TSC.

*/

typedef enum {
  TSCMOD_AN_NONE             = 0   ,  /*!< TSC autoneg not enabled */
  TSCMOD_CL73                      ,  /*!< TSC autoneg CL73 enable */
  TSCMOD_CL37                      ,  /*!< TSC autoneg CL37 enable */
  TSCMOD_CL37_10G                  ,  /*!< TSC autoneg CL37 enable, BR 10G */
  TSCMOD_CL73_BAM                  ,  /*!< TSC autoneg CL73 enable with Brcm Aneg Mode */
  TSCMOD_CL37_BAM                  ,  /*!< TSC autoneg CL37 enable with  Brcm Aneg Mode */
  TSCMOD_CL37_SGMII                ,  /*!< TSC autoneg for SGMII  */
  TSCMOD_HPAM                      ,  /*!< TSC autoneg for HP aneg */
  TSCMOD_AN_TYPE_ILLEGAL             /*!< Illegal value. programmatic boundary. */
} tscmod_an_type;

/*! \def CNT_tscmod_an_type Types of enum tscmod_an_type */
#define CNT_tscmod_an_type 9

/*!
\brief
This array returns the string version of the enum #tscmod_port_type when indexed
by the enum var.

*/
extern char* e2s_tscmod_an_type [CNT_tscmod_an_type];
/*! \enum tscmod_tech_ability 

tscmod_tech_ability enumerates different types of speed advertisements in the
basic autoneg page. Currently for CL73 and others, but excluding CL37BAM.

Currently all speeds have the following bit positions in tscmod_st

\li TSCMOD_ABILITY_1G_KX            Bit Pos: 0
\li TSCMOD_ABILITY_10G_KX4          Bit Pos: 1
\li TSCMOD_ABILITY_10G_KR           Bit Pos: 2
\li TSCMOD_ABILITY_40G_KR4          Bit Pos: 3
\li TSCMOD_ABILITY_40G_CR4          Bit Pos: 4
\li TSCMOD_ABILITY_100G_CR10        Bit Pos: 5
\li TSCMOD_ABILITY_20G_KR2          Bit Pos: 6
\li TSCMOD_ABILITY_20G_CR2          Bit Pos: 7


*/

typedef enum {
  TSCMOD_ABILITY_1G_KX       = 0   ,  /*!< CL73 speed 1G_KX ease        */
  TSCMOD_ABILITY_10G_KX4           ,  /*!< please write comments        */
  TSCMOD_ABILITY_10G_KR            ,  /*!< please write comments        */
  TSCMOD_ABILITY_40G_KR4           ,  /*!< please write comments        */
  TSCMOD_ABILITY_40G_CR4           ,  /*!< please write comments        */
  TSCMOD_ABILITY_100G_CR10         ,  /*!< please write comments        */
  TSCMOD_ABILITY_20G_KR2           ,  /*!< please write comments        */
  TSCMOD_ABILITY_20G_CR2           ,  /*!< please write comments        */
  TSCMOD_ABILITY_ILLEGAL             /*!< Illegal. Programmatic boundary */
} tscmod_tech_ability;

/*! \def CNT_tscmod_tech_ability Types of enum tscmod_tech_ability */
#define CNT_tscmod_tech_ability 9

/*!
\brief
This array returns the string version of the enum #tscmod_port_type when indexed
by the enum var.

*/
extern char* e2s_tscmod_tech_ability [CNT_tscmod_tech_ability];
/*!
\brief
This array associates the enum #tscmod_lane_select enum with a bit mask.
The index is the #tscmod_lane_select enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/
extern int e2n_tscmod_tech_ability [CNT_tscmod_tech_ability];
/*! \enum tscmod_cl37bam_ability 

tscmod_cl37bam_ability enumerates different types of speed advertisements in the
basic autoneg page. Currently for CL37BAM only.

Currently all speeds have the following bit positions in tscmod_st


\li TSCMOD_BAM37ABL_2P5G             Bit Pos: 0
\li TSCMOD_BAM37ABL_5G_X4            Bit Pos: 1
\li TSCMOD_BAM37ABL_6G_X4            Bit Pos: 2
\li TSCMOD_BAM37ABL_10G_HIGIG        Bit Pos: 3
\li TSCMOD_BAM37ABL_10G_CX4          Bit Pos: 4
\li TSCMOD_BAM37ABL_12G_X4           Bit Pos: 5
\li TSCMOD_BAM37ABL_12P5_X4          Bit Pos: 6
\li TSCMOD_BAM37ABL_13G_X4           Bit Pos: 7
\li TSCMOD_BAM37ABL_15G_X4           Bit Pos: 8
\li TSCMOD_BAM37ABL_16G_X4           Bit Pos: 9
\li TSCMOD_BAM37ABL_20G_X4_CX4       Bit Pos: 10
\li TSCMOD_BAM37ABL_20G_X4           Bit Pos: 11
\li TSCMOD_BAM37ABL_21G_X4           Bit Pos: 12
\li TSCMOD_BAM37ABL_25P455G          Bit Pos: 13
\li TSCMOD_BAM37ABL_31P5G            Bit Pos: 14
\li TSCMOD_BAM37ABL_32P7G            Bit Pos: 15
\li TSCMOD_BAM37ABL_40G              Bit Pos: 16
\li TSCMOD_BAM37ABL_10G_X2_CX4       Bit Pos: 17
\li TSCMOD_BAM37ABL_10G_DXGXS        Bit Pos: 18
\li TSCMOD_BAM37ABL_10P5G_DXGXS      Bit Pos: 19
\li TSCMOD_BAM37ABL_12P7_DXGXS       Bit Pos: 20
\li TSCMOD_BAM37ABL_15P75G_R2        Bit Pos: 21
\li TSCMOD_BAM37ABL_20G_X2_CX4       Bit Pos: 22
\li TSCMOD_BAM37ABL_20G_X2           Bit Pos: 23


*/

typedef enum {
  TSCMOD_BAM37ABL_2P5G       = 0   ,  /*!< X1 BRCM                      */
  TSCMOD_BAM37ABL_5G_X4            ,  /*!< BRCM                      */
  TSCMOD_BAM37ABL_6G_X4            ,  /*!< BRCM                      */
  TSCMOD_BAM37ABL_10G_HIGIG        ,  /*!< HG (10G_X4)          */
  TSCMOD_BAM37ABL_10G_CX4          ,  /*!< (10G_X4_CX4)      */
  TSCMOD_BAM37ABL_12G_X4           ,  /*!< HG                   */
  TSCMOD_BAM37ABL_12P5_X4          ,  /*!< HG                   */
  TSCMOD_BAM37ABL_13G_X4           ,  /*!< HG                   */
  TSCMOD_BAM37ABL_15G_X4           ,  /*!< HG                   */
  TSCMOD_BAM37ABL_16G_X4           ,  /*!< HG                   */
  TSCMOD_BAM37ABL_20G_X4_CX4       ,  /*!< XAUI 8b10b scram(20G_X4S)    */
  TSCMOD_BAM37ABL_20G_X4           ,  /*!< HG                   */
  TSCMOD_BAM37ABL_21G_X4           ,  /*!< HG                   */
  TSCMOD_BAM37ABL_25P455G          ,  /*!< X4      HG                   */
  TSCMOD_BAM37ABL_31P5G            ,  /*!< X4      HG                   */
  TSCMOD_BAM37ABL_32P7G            ,  /*!< X4      HG                   */
  TSCMOD_BAM37ABL_40G              ,  /*!< X4 BRCM HG (40G_X4)          */
  TSCMOD_BAM37ABL_10G_X2_CX4       ,  /*!< 10G_X2_CX4       */
  TSCMOD_BAM37ABL_10G_DXGXS        ,  /*!< 10G_X2           */
  TSCMOD_BAM37ABL_10P5G_DXGXS       ,  /*!< 10P5_X2          */
  TSCMOD_BAM37ABL_12P7_DXGXS       ,  /*!< 12P7_X2          */
  TSCMOD_BAM37ABL_15P75G_R2        ,  /*!< 15P75_X2         */
  TSCMOD_BAM37ABL_20G_X2_CX4       ,  /*!< 20G_X2_CX4       */
  TSCMOD_BAM37ABL_20G_X2           ,  /*!< 20G_X2           */
  TSCMOD_BAM37ABL_ILLEGAL            /*!< Illegal. Programmatic boundary */
} tscmod_cl37bam_ability;

/*! \def CNT_tscmod_cl37bam_ability Types of enum tscmod_cl37bam_ability */
#define CNT_tscmod_cl37bam_ability 25

/*!
\brief
This array returns the string version of the enum #tscmod_port_type when indexed
by the enum var.

*/
extern char* e2s_tscmod_cl37bam_ability [CNT_tscmod_cl37bam_ability];
/*!
\brief
This array associates the enum #tscmod_lane_select enum with a bit mask.
The index is the #tscmod_lane_select enum value.  The value for each entry is
interpreted as follows.  If bit [n] is 1, then lane [n] is enabled; if bit [n]
is 0, then lane [n] is disabled.  By enabled, we mean that such-and-such
function is to be called for a lane; by disabled, we mean that such-and-such
function is not to be called for a lane.  So a value of 0xF indicates that all
lanes or enabled, while 0x5 indicates that only lanes 0 and 2 are enabled.

*/
extern int e2n_tscmod_cl37bam_ability [CNT_tscmod_cl37bam_ability];
/*! \enum tscmod_eye_direction 

The direction of slicer changing always moves from the middle of the eye.
Currently all speeds have the following bit positions in tscmod_st

\li TSCMOD_EYE_VU: Vertical,   Upward direction
\li TSCMOD_EYE_VD: Vertical,   Downward direction
\li TSCMOD_EYE_HL: Horizontal, Left  direction
\li TSCMOD_EYE_HR: Horizontal, Right direction


*/

typedef enum {
  TSCMOD_EYE_VU              = 0   ,  /*!< Vertical,   Upward direction */
  TSCMOD_EYE_VD                    ,  /*!< Vertical,   Downward direction */
  TSCMOD_EYE_HL                    ,  /*!< Horizontal, Left  direction */
  TSCMOD_EYE_HR                    ,  /*!< Horizontal, Right direction */
  TSCMOD_EYE_ILLEGAL                 /*!< Programmatic illegal boundary. */
} tscmod_eye_direction;

/*! \def CNT_tscmod_eye_direction Types of enum tscmod_eye_direction */
#define CNT_tscmod_eye_direction 5

/*!
\brief
This array returns the string version of the enum #tscmod_port_type when indexed
by the enum var.

*/
extern char* e2s_tscmod_eye_direction [CNT_tscmod_eye_direction];
#endif /* _TSCMOD_ENUM_DEFINES_H */
