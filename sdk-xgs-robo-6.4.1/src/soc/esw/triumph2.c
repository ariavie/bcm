/*
 * $Id: triumph2.c,v 1.155 Broadcom SDK $
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * File:        triumph2.c
 * Purpose:
 * Requires:    
 */

#include <sal/core/boot.h>
#include <shared/bsl.h>
#include <soc/firebolt.h>
#include <soc/bradley.h>
#include <soc/triumph.h>
#include <soc/triumph2.h>
#include <soc/drv.h>
#include <soc/mem.h>
#include <soc/hash.h>
#include <soc/lpm.h>
#include <soc/error.h>
#include <soc/debug.h>
#include <soc/devids.h>
#include <soc/register.h>
#include <soc/cmic.h>
#include <soc/mem.h>
#include <soc/soc_ser_log.h>

#ifdef BCM_TRIUMPH2_SUPPORT

/*
 * Triumph2 chip driver functions.  
 */
soc_functions_t soc_triumph2_drv_funs = {
    soc_triumph2_misc_init,
    soc_triumph2_mmu_init,
    soc_triumph2_age_timer_get,
    soc_triumph2_age_timer_max_get,
    soc_triumph2_age_timer_set,
};

typedef enum {
    _SOC_PARITY_INFO_TYPE_GENERIC,
    _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
    _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
    _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER,
    _SOC_PARITY_INFO_TYPE_DUAL_PARITY,
    _SOC_PARITY_INFO_TYPE_MMU_PARITY,
    _SOC_PARITY_INFO_TYPE_MMUIPMC,
    _SOC_PARITY_INFO_TYPE_MMUWRED,
    _SOC_PARITY_INFO_TYPE_OAM, /* Not parity, but same interrupt */
    _SOC_PARITY_INFO_TYPE_SER, /* Parity error from CMIC SER module */
    _SOC_PARITY_INFO_TYPE_NUM
}_soc_parity_info_type_t;

typedef struct _soc_parity_info_s {
    soc_field_t enable_field;
    soc_field_t error_field;
    char *msg;
    soc_mem_t mem;
    _soc_parity_info_type_t type;
    soc_reg_t control_reg;
    soc_reg_t intr_status0_reg;
    soc_reg_t intr_status1_reg; /* Also SBE force for ECC */
    soc_reg_t nack_status0_reg;
    soc_reg_t nack_status1_reg; /* Also DBE force for ECC */
}_soc_parity_info_t;

/*
 *    _SOC_PARITY_INFO_TYPE_SINGLE_PARITY
 *      PARITY_EN
 *      ENTRY_IDX, MULTIPLE_ERR, PARITY_ERR
 *
 *    _SOC_PARITY_INFO_TYPE_SINGLE_ECC
 *      ECC_EN
 *      ENTRY_IDX, DOUBLE_BIT_ERR, MULTIPLE_ERR, ECC_ERR
 *
 *    _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER
 *      PARITY_EN
 *      PORT_IDX, COUNTER_IDX, MULTIPLE_ERR, PARITY_ERR
 *
 *    _SOC_PARITY_INFO_TYPE_DUAL_PARITY
 *      PARITY_EN
 *      BUCKET_IDX, MULTIPLE_ERR, PARITY_ERR_BM
 */

STATIC _soc_parity_info_t _soc_tr2_ip0_parity_info[] = {
    {   PARITY_ENf, VXLT_PAR_ERRf, NULL,
        VLAN_XLATEm, _SOC_PARITY_INFO_TYPE_DUAL_PARITY,
        VLAN_XLATE_PARITY_CONTROLr,
        VLAN_XLATE_PARITY_STATUS_INTR_0r, VLAN_XLATE_PARITY_STATUS_INTR_1r,
        VLAN_XLATE_PARITY_STATUS_NACK_0r, VLAN_XLATE_PARITY_STATUS_NACK_1r},
    {   PARITY_ENf, VFP_POLICY_PAR_ERRf, NULL,
        VFP_POLICY_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        VFP_POLICY_PARITY_CONTROLr,
        VFP_POLICY_PARITY_STATUS_INTRr, INVALIDr,
        VFP_POLICY_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, VLAN_PROT_PAR_ERRf, NULL,
        VLAN_PROTOCOL_DATAm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        VLAN_PROT_PARITY_CONTROLr,
        VLAN_PROT_PARITY_STATUS_INTRr, INVALIDr,
        VLAN_PROT_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, VLAN_SUBNET_PAR_ERRf, NULL,
        VLAN_SUBNET_DATA_ONLYm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        VLAN_SUBNET_PARITY_CONTROLr,
        VLAN_SUBNET_PARITY_STATUS_INTRr, INVALIDr,
        VLAN_SUBNET_PARITY_STATUS_NACKr, INVALIDr},
    {   ECC_ENf, PORT_TABLE_PAR_ERRf, NULL,
        PORT_TABm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        PORT_TABLE_ECC_CONTROLr,
        PORT_TABLE_ECC_STATUS_INTRr, INVALIDr,
        PORT_TABLE_ECC_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, SYS_CONFIG_PAR_ERRf, NULL,
        SYSTEM_CONFIG_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        SYSTEM_CONFIG_PARITY_CONTROLr,
        SYSTEM_CONFIG_PARITY_STATUS_INTRr, INVALIDr,
        SYSTEM_CONFIG_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, LMEP_PAR_ERRf, NULL,
        LMEPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        LMEP_PARITY_CONTROLr,
        LMEP_PARITY_STATUS_INTRr, INVALIDr,
        LMEP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, CPU_TS_POLICY_PAR_ERRf, NULL,
        CPU_TS_MAPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        CPU_TS_PARITY_CONTROLr,
        CPU_TS_PARITY_STATUS_INTRr, INVALIDr,
        CPU_TS_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, VLAN_RANGE_PAR_ERRf, NULL,
        ING_VLAN_RANGEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        VLAN_RANGE_PARITY_CONTROLr,
        VLAN_RANGE_PARITY_STATUS_INTRr, INVALIDr,
        VLAN_RANGE_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, MOD_MAP_PAR_ERRf, NULL,
        ING_MOD_MAP_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        MOD_MAP_PARITY_CONTROLr,
        MOD_MAP_PARITY_STATUS_INTRr, INVALIDr,
        MOD_MAP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, FP_UDF_PAR_ERRf, NULL,
        FP_UDF_OFFSETm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        FP_UDF_PARITY_CONTROLr,
        FP_UDF_PARITY_STATUS_INTRr, INVALIDr,
        FP_UDF_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, L3_TUNNEL_PAR_ERRf, NULL,
        L3_TUNNELm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        L3_TUNNEL_PARITY_CONTROLr,
        L3_TUNNEL_PARITY_STATUS_INTRr, INVALIDr,
        L3_TUNNEL_PARITY_STATUS_NACKr, INVALIDr},
    {   ECC_ENf, WLAN_SVP_PAR_ERRf, NULL,
        WLAN_SVP_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        WLAN_SVP_ECC_CONTROLr,
        WLAN_SVP_ECC_STATUS_INTRr, INVALIDr,
        WLAN_SVP_ECC_STATUS_NACKr, INVALIDr},
    {   ECC_ENf, SRC_TRUNK_PAR_ERRf, NULL,
        SOURCE_TRUNK_MAP_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        SRC_TRUNK_ECC_CONTROLr,
        SRC_TRUNK_ECC_STATUS_INTRr, INVALIDr,
        SRC_TRUNK_ECC_STATUS_NACKr, INVALIDr},
    {   ECC_ENf, LPORT_PAR_ERRf, NULL,
        LPORT_TABm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        LPORT_ECC_CONTROLr,
        LPORT_ECC_STATUS_INTRr, INVALIDr,
        LPORT_ECC_STATUS_NACKr, INVALIDr},
    {   ECC_ENf, IARB_PKT_ERRf, "Iarb packet ecc error",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        IARB_PKT_ECC_CONTROLr,
        IARB_PKT_ECC_STATUS_INTRr, INVALIDr,
        INVALIDr, INVALIDr},
    {   ECC_ENf, IARB_HDR_ERRf, "Iarb header ecc error",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        IARB_HDR_ECC_CONTROLr,
        IARB_HDR_ECC_STATUS_INTRr, INVALIDr,
        INVALIDr, INVALIDr},
    {   INVALIDf, INVALIDf}, /* table terminator */
};

STATIC _soc_parity_info_t _soc_tr2_ip1_parity_info[] = {
    {   PARITY_ENf, VLAN_PAR_ERRf, NULL,
        VLAN_TABm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        VLAN_PARITY_CONTROLr,
        VLAN_PARITY_STATUS_INTRr, INVALIDr,
        VLAN_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, SVP_PAR_ERRf, NULL,
        SOURCE_VPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        SOURCE_VP_PARITY_CONTROLr,
        SOURCE_VP_PARITY_STATUS_INTRr, INVALIDr,
        SOURCE_VP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, L3_IIF_PAR_ERRf, NULL,
        L3_IIFm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        L3_IIF_PARITY_CONTROLr,
        L3_IIF_PARITY_STATUS_INTRr, INVALIDr,
        L3_IIF_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, MPLS_ENTRY_PAR_ERRf, NULL,
        MPLS_ENTRYm, _SOC_PARITY_INFO_TYPE_DUAL_PARITY,
        MPLS_ENTRY_PARITY_CONTROLr,
        MPLS_ENTRY_PARITY_STATUS_INTR_0r, MPLS_ENTRY_PARITY_STATUS_INTR_1r,
        MPLS_ENTRY_PARITY_STATUS_NACK_0r, MPLS_ENTRY_PARITY_STATUS_NACK_1r},
    {   PARITY_ENf, L2_ENTRY_PAR_ERRf, NULL,
        L2Xm, _SOC_PARITY_INFO_TYPE_DUAL_PARITY,
        L2_ENTRY_PARITY_CONTROLr,
        L2_ENTRY_PARITY_STATUS_INTR_0r, L2_ENTRY_PARITY_STATUS_INTR_1r,
        L2_ENTRY_PARITY_STATUS_NACK_0r, L2_ENTRY_PARITY_STATUS_NACK_1r},
    {   PARITY_ENf, L3_ENTRY_PAR_ERRf, NULL,
        L3_ENTRY_ONLYm, _SOC_PARITY_INFO_TYPE_DUAL_PARITY,
        L3_ENTRY_PARITY_CONTROLr,
        L3_ENTRY_PARITY_STATUS_INTR_0r, L3_ENTRY_PARITY_STATUS_INTR_1r,
        L3_ENTRY_PARITY_STATUS_NACK_0r, L3_ENTRY_PARITY_STATUS_NACK_1r},
    {   PARITY_ENf, L3_DEFIP_DATA_PAR_ERRf, NULL,
        L3_DEFIP_DATA_ONLYm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        L3_DEFIP_DATA_PARITY_CONTROLr,
        L3_DEFIP_DATA_PARITY_STATUS_INTRr, INVALIDr,
        L3_DEFIP_DATA_PARITY_STATUS_NACKr, INVALIDr},
    /*  { IESMIF_INTRf },  special conditions interrupts
     { INVALIDf, IESMIF_INTRf, "ESM interface error",
     INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
     INVALIDr,
     INVALIDr, INVALIDr,
     INVALIDr, INVALIDr }, */
    {   PARITY_ENf, ING_PRI_CNG_MAP_INTRf, NULL,
        ING_PRI_CNG_MAPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        ING_PRI_CNG_MAP_PARITY_CONTROLr,
        ING_PRI_CNG_MAP_PARITY_STATUS_INTRr, INVALIDr,
        ING_PRI_CNG_MAP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, L2_MOD_FIFO_INTRf, NULL,
        L2_MOD_FIFOm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        L2_MOD_FIFO_PARITY_CONTROLr,
        L2_MOD_FIFO_PARITY_STATUS_INTRr, INVALIDr,
        L2_MOD_FIFO_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, L2_USER_ENTRY_DATA_INTRf, NULL,
        L2_USER_ENTRY_DATA_ONLYm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        L2_USER_ENTRY_DATA_PARITY_CONTROLr,
        L2_USER_ENTRY_DATA_PARITY_STATUS_INTRr, INVALIDr,
        L2_USER_ENTRY_DATA_PARITY_STATUS_NACKr, INVALIDr},
    /*  { L3LU_ERB_INTRf },  special conditions interrupts
     { INVALIDf, L3LU_ERB_INTRf, "Fatal ESM error",
     INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
     INVALIDr,
     INVALIDr, INVALIDr,
     INVALIDr, INVALIDr }, */
    {   PARITY_ENf, PORT_OR_TRUNK_MAC_COUNT_INTRf, NULL,
        PORT_OR_TRUNK_MAC_COUNTm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        PORT_OR_TRUNK_MAC_COUNT_PARITY_CONTROLr,
        PORT_OR_TRUNK_MAC_COUNT_PARITY_STATUS_INTRr, INVALIDr,
        PORT_OR_TRUNK_MAC_COUNT_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, PORT_OR_TRUNK_MAC_LIMIT_INTRf, NULL,
        PORT_OR_TRUNK_MAC_LIMITm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        PORT_OR_TRUNK_MAC_LIMIT_PARITY_CONTROLr,
        PORT_OR_TRUNK_MAC_LIMIT_PARITY_STATUS_INTRr, INVALIDr,
        PORT_OR_TRUNK_MAC_LIMIT_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, VFI_INTRf, NULL,
        VFIm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        VFI_PARITY_CONTROLr,
        VFI_PARITY_STATUS_INTRr, INVALIDr,
        VFI_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, VLAN_MPLS_INTRf, NULL,
        VLAN_MPLSm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        VLAN_MPLS_PARITY_CONTROLr,
        VLAN_MPLS_PARITY_STATUS_INTRr, INVALIDr,
        VLAN_MPLS_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, VLAN_OR_VFI_MAC_COUNT_INTRf,NULL,
        VLAN_OR_VFI_MAC_COUNTm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        VLAN_OR_VFI_MAC_COUNT_PARITY_CONTROLr,
        VLAN_OR_VFI_MAC_COUNT_PARITY_STATUS_INTRr, INVALIDr,
        VLAN_OR_VFI_MAC_COUNT_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, VLAN_OR_VFI_MAC_LIMIT_INTRf, NULL,
        VLAN_OR_VFI_MAC_LIMITm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        VLAN_OR_VFI_MAC_LIMIT_PARITY_CONTROLr,
        VLAN_OR_VFI_MAC_LIMIT_PARITY_STATUS_INTRr, INVALIDr,
        VLAN_OR_VFI_MAC_LIMIT_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, VLAN_STG_INTRf, NULL,
        STG_TABm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        VLAN_STG_PARITY_CONTROLr,
        VLAN_STG_PARITY_STATUS_INTRr, INVALIDr,
        VLAN_STG_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, VRF_INTRf, NULL,
        VRFm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        VRF_PARITY_CONTROLr,
        VRF_PARITY_STATUS_INTRr, INVALIDr,
        VRF_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, VFI_1_INTRf, NULL,
        VFI_1m, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        VFI_1_PARITY_CONTROLr,
        VFI_1_PARITY_STATUS_INTRr, INVALIDr,
        VFI_1_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, L3_DEFIP_128_DATA_PAR_ERRf, NULL,
        L3_DEFIP_128_DATA_ONLYm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        L3_DEFIP_128_DATA_PARITY_CONTROLr,
        L3_DEFIP_128_DATA_PARITY_STATUS_INTRr, INVALIDr,
        L3_DEFIP_128_DATA_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, DSCP_PAR_ERRf, NULL,
        DSCP_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        DSCP_TABLE_PARITY_CONTROLr,
        DSCP_TABLE_PARITY_STATUS_INTRr, INVALIDr,
        DSCP_TABLE_PARITY_STATUS_NACKr, INVALIDr},
    {   INVALIDf, INVALIDf}, /* table terminator */
};

STATIC _soc_parity_info_t _soc_tr2_ip2_parity_info[] = {
    {   PARITY_ENf, FP_FIELD_SEL_PAR_ERRf, NULL,
        FP_PORT_FIELD_SELm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        FP_FIELD_SEL_PARITY_CONTROLr,
        FP_FIELD_SEL_PARITY_STATUS_INTRr, INVALIDr,
        FP_FIELD_SEL_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, TTL_FN_PAR_ERRf, NULL,
        TTL_FNm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        TTL_FN_PARITY_CONTROLr,
        TTL_FN_PARITY_STATUS_INTRr, INVALIDr,
        TTL_FN_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, TOS_FN_PAR_ERRf, NULL,
        TOS_FNm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        TOS_FN_PARITY_CONTROLr,
        TOS_FN_PARITY_STATUS_INTRr, INVALIDr,
        TOS_FN_PARITY_STATUS_NACKr, INVALIDr},

    /* Start of parity-unrelated OAM faults */

    {   ANY_RMEP_TLV_PORT_DOWN_INTRf, ANY_RMEP_TLV_PORT_DOWN_INTRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_OAM,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},

    {   ANY_RMEP_TLV_PORT_UP_INTRf, ANY_RMEP_TLV_PORT_UP_INTRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_OAM,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},

    {   ANY_RMEP_TLV_INTERFACE_DOWN_INTRf, ANY_RMEP_TLV_INTERFACE_DOWN_INTRf,
        NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_OAM,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},

    {   ANY_RMEP_TLV_INTERFACE_UP_INTRf, ANY_RMEP_TLV_INTERFACE_UP_INTRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_OAM,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},

    {   XCON_CCM_DEFECT_INTRf, XCON_CCM_DEFECT_INTRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_OAM,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},

    {   ERROR_CCM_DEFECT_INTRf, ERROR_CCM_DEFECT_INTRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_OAM,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},

    {   SOME_RDI_DEFECT_INTRf, SOME_RDI_DEFECT_INTRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_OAM,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},

    {   SOME_RMEP_CCM_DEFECT_INTRf, SOME_RMEP_CCM_DEFECT_INTRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_OAM,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},

    /* End of parity-unrelated OAM faults */

    {   PARITY_ENf, IFP_POLICY_PAR_ERRf, NULL,
        FP_POLICY_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        IFP_POLICY_PARITY_CONTROLr,
        IFP_POLICY_PARITY_STATUS_INTRr, INVALIDr,
        IFP_POLICY_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, IFP_STORM_PAR_ERRf, NULL,
        FP_STORM_CONTROL_METERSm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        IFP_STORM_CONTROL_PARITY_CONTROLr,
        IFP_STORM_CONTROL_PARITY_STATUS_INTRr, INVALIDr,
        IFP_STORM_CONTROL_PARITY_STATUS_NACKr, INVALIDr},
    
    {   PARITY_ENf, NHOP_PAR_ERRf, NULL,
        INITIAL_ING_L3_NEXT_HOPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        INITIAL_NHOP_PARITY_CONTROLr,
        INITIAL_NHOP_PARITY_STATUS_INTRr, INVALIDr,
        INITIAL_NHOP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, ECMP_GRP_PAR_ERRf, NULL,
        INITIAL_L3_ECMP_COUNTm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        INI_ECMP_GRP_PARITY_CONTROLr,
        INI_ECMP_GRP_PARITY_STATUS_INTRr, INVALIDr,
        INI_ECMP_GRP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, L3_ECMP_PAR_ERRf, NULL,
        INITIAL_L3_ECMPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        INI_L3_ECMP_PARITY_CONTROLr,
        INI_L3_ECMP_PARITY_STATUS_INTRr, INVALIDr,
        INI_L3_ECMP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, ING_DVP_PAR_ERRf, NULL,
        ING_DVP_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        ING_DVP_PARITY_CONTROLr,
        ING_DVP_PARITY_STATUS_INTRr, INVALIDr,
        ING_DVP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, PROT_NHI_PAR_ERRf, NULL,
        INITIAL_PROT_NHI_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        INI_PROT_NHI_PARITY_CONTROLr,
        INI_PROT_NHI_PARITY_STATUS_INTRr, INVALIDr,
        INI_PROT_NHI_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, PORT_CBL_PAR_ERRf, NULL,
        PORT_CBL_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        PORT_CBL_PARITY_CONTROLr,
        PORT_CBL_PARITY_STATUS_INTRr, INVALIDr,
        PORT_CBL_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, L3_IPMC_1_PAR_ERRf, NULL,
        L3_IPMC_1m, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        L3_IPMC_1_PARITY_CONTROLr,
        L3_IPMC_1_PARITY_STATUS_INTRr, INVALIDr,
        L3_IPMC_1_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, MA_INDEX_PAR_ERRf, NULL,
        MA_INDEXm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        MA_INDEX_PARITY_CONTROLr,
        MA_INDEX_PARITY_STATUS_INTRr, INVALIDr,
        MA_INDEX_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, RMEP_PAR_ERRf, NULL,
        RMEPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        RMEP_PARITY_CONTROLr,
        RMEP_PARITY_STATUS_INTRr, INVALIDr,
        RMEP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, MAID_PAR_ERRf, NULL,
        MAID_REDUCTIONm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        MAID_PARITY_CONTROLr,
        MAID_PARITY_STATUS_INTRr, INVALIDr,
        MAID_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, MA_STATE_PAR_ERRf, NULL,
        MA_STATEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        MA_STATE_PARITY_CONTROLr,
        MA_STATE_PARITY_STATUS_INTRr, INVALIDr,
        MA_STATE_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, EXT_IFP_ACT_PAR_ERRf, NULL,
        EXT_IFP_ACTION_PROFILEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EXT_IFP_ACT_PARITY_CONTROLr,
        EXT_IFP_ACT_PARITY_STATUS_INTRr, INVALIDr,
        EXT_IFP_ACT_PARITY_STATUS_NACKr, INVALIDr},
    {   INVALIDf, INVALIDf}, /* table terminator */
};

STATIC _soc_parity_info_t _soc_tr2_ip3_parity_info[] = {
    {   PARITY_ENf, ING_NHOP_PAR_ERRf, NULL,
        ING_L3_NEXT_HOPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        ING_L3_NEXT_HOP_PARITY_CONTROLr,
        ING_L3_NEXT_HOP_PARITY_STATUS_INTRr, INVALIDr,
        ING_L3_NEXT_HOP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, ING_IPFIX_SESS_PAR_ERRf, NULL,
        ING_IPFIX_SESSION_TABLEm, _SOC_PARITY_INFO_TYPE_DUAL_PARITY,
        ING_IPFIX_SESSION_PARITY_CONTROLr,
        ING_IPFIX_SESSION_PARITY_STATUS_INTR_0r, ING_IPFIX_SESSION_PARITY_STATUS_INTR_1r,
        ING_IPFIX_SESSION_PARITY_STATUS_NACK_0r, ING_IPFIX_SESSION_PARITY_STATUS_NACK_1r},
    {   PARITY_ENf, ING_IPFIX_EXPORT_PAR_ERRf, NULL,
        ING_IPFIX_EXPORT_FIFOm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        ING_IPFIX_EXPORT_FIFO_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        ING_IPFIX_EXPORT_FIFO_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, ING_IPFIX_EOP_PAR_ERRf, NULL,
        ING_IPFIX_EOP_BUFFERm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        ING_IPFIX_EOP_BUF_PARITY_CONTROLr,
        ING_IPFIX_EOP_BUF_PARITY_STATUS_INTRr, INVALIDr,
        ING_IPFIX_EOP_BUF_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, ING_IPFIX_FLOW_PAR_ERRf, NULL,
        ING_IPFIX_FLOW_RATE_METER_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        ING_IPFIX_FLOW_PARITY_CONTROLr,
        ING_IPFIX_FLOW_PARITY_STATUS_INTRr, INVALIDr,
        ING_IPFIX_FLOW_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, ICONTROL_OPCODE_BITMAP_PAR_ERRf, "Icontrol opcode bitmap register",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        ICONTROL_OPCODE_BITMAP_PARITY_CONTROLr,
        ICONTROL_OPCODE_BITMAP_PARITY_STATUS_INTRr, INVALIDr,
        ICONTROL_OPCODE_BITMAP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, L3_IPMC_REMAP_PAR_ERRf, NULL,
        L3_IPMC_REMAPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        L3_IPMC_REMAP_PARITY_CONTROLr,
        L3_IPMC_REMAP_PARITY_STATUS_INTRr, INVALIDr,
        L3_IPMC_REMAP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, L3_IPMC_PAR_ERRf, NULL,
        L3_IPMCm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        L3_IPMC_PARITY_CONTROLr,
        L3_IPMC_PARITY_STATUS_INTRr, INVALIDr,
        L3_IPMC_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, L2MC_PAR_ERRf, NULL,
        L2MCm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        L2MC_PARITY_CONTROLr,
        L2MC_PARITY_STATUS_INTRr, INVALIDr,
        L2MC_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, IFP_REDIRECTION_PROFILE_PAR_ERRf, NULL,
        IFP_REDIRECTION_PROFILEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        IFP_REDIRECTION_PROFILE_PARITY_CONTROLr,
        IFP_REDIRECTION_PROFILE_PARITY_STATUS_INTRr, INVALIDr,
        IFP_REDIRECTION_PROFILE_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, L3_ECMP_GROUP_PAR_ERRf, NULL,
        L3_ECMP_COUNTm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        L3_ECMP_GROUP_PARITY_CONTROLr,
        L3_ECMP_GROUP_PARITY_STATUS_INTRr, INVALIDr,
        L3_ECMP_GROUP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, L3_ECMP_PAR_ERRf, NULL,
        L3_ECMPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        L3_ECMP_PARITY_CONTROLr,
        L3_ECMP_PARITY_STATUS_INTRr, INVALIDr,
        L3_ECMP_PARITY_STATUS_NACKr, INVALIDr},
    {   INVALIDf, INVALIDf}, /* table terminator */
};

STATIC _soc_parity_info_t _soc_tr2_ip3_1_parity_info[] = {
    {   PARITY_ENf, EGR_MASK_PAR_ERRf, NULL,
        EGR_MASKm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_MASK_PARITY_CONTROLr,
        EGR_MASK_PARITY_STATUS_INTRr, INVALIDr,
        EGR_MASK_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, TRUNK_EGR_MASK_PAR_ERRf, NULL,
        TRUNK_EGR_MASKm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        TRUNK_EGR_MASK_PARITY_CONTROLr,
        TRUNK_EGR_MASK_PARITY_STATUS_INTRr, INVALIDr,
        TRUNK_EGR_MASK_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, TRUNK_BITMAP_PAR_ERRf, NULL,
        TRUNK_BITMAPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        TRUNK_BITMAP_TABLE_PARITY_CONTROLr,
        TRUNK_BITMAP_TABLE_PARITY_STATUS_INTRr, INVALIDr,
        TRUNK_BITMAP_TABLE_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, TRUNK_GROUP_PAR_ERRf, NULL,
        TRUNK_GROUPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        TRUNK_GROUP_PARITY_CONTROLr,
        TRUNK_GROUP_PARITY_STATUS_INTRr, INVALIDr,
        TRUNK_GROUP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, NONUCAST_TRUNK_BLOCK_MASK_PAR_ERRf, NULL,
        NONUCAST_TRUNK_BLOCK_MASKm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        NONUCAST_TRUNK_BLOCK_MASK_PARITY_CONTROLr,
        NONUCAST_TRUNK_BLOCK_MASK_PARITY_STATUS_INTRr, INVALIDr,
        NONUCAST_TRUNK_BLOCK_MASK_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, MAC_BLOCK_TABLE_PAR_ERRf, NULL,
        MAC_BLOCKm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        MAC_BLOCK_TABLE_PARITY_CONTROLr,
        MAC_BLOCK_TABLE_PARITY_STATUS_INTRr, INVALIDr,
        MAC_BLOCK_TABLE_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, MODPORT_MAP_SW_PAR_ERRf, NULL,
        MODPORT_MAP_SWm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        MODPORT_MAP_SW_PARITY_CONTROLr,
        MODPORT_MAP_SW_PARITY_STATUS_INTRr, INVALIDr,
        MODPORT_MAP_SW_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, MODPORT_MAP_MIRROR_PAR_ERRf, NULL,
        MODPORT_MAP_MIRRORm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        MODPORT_MAP_MIRROR_PARITY_CONTROLr,
        MODPORT_MAP_MIRROR_PARITY_STATUS_INTRr, INVALIDr,
        MODPORT_MAP_MIRROR_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, MODPORT_MAP_MIRROR_1_PAR_ERRf, NULL,
        MODPORT_MAP_MIRROR_1m, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        MODPORT_MAP_MIRROR_1_PARITY_CONTROLr,
        MODPORT_MAP_MIRROR_1_PARITY_STATUS_INTRr, INVALIDr,
        MODPORT_MAP_MIRROR_1_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, SRC_MODID_INGRESS_BLOCK_PAR_ERRf, NULL,
        SRC_MODID_INGRESS_BLOCKm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        SRC_MODID_INGRESS_BLOCK_PARITY_CONTROLr,
        SRC_MODID_INGRESS_BLOCK_PARITY_STATUS_INTRr, INVALIDr,
        SRC_MODID_INGRESS_BLOCK_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, SRC_MODID_EGRESS_PAR_ERRf, NULL,
        SRC_MODID_EGRESSm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        SRC_MODID_EGRESS_PARITY_CONTROLr,
        SRC_MODID_EGRESS_PARITY_STATUS_INTRr, INVALIDr,
        SRC_MODID_EGRESS_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, ALTERNATE_EMIRROR_BITMAP_PAR_ERRf, NULL,
        ALTERNATE_EMIRROR_BITMAPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        ALTERNATE_EMIRROR_BITMAP_PARITY_CONTROLr,
        ALTERNATE_EMIRROR_BITMAP_PARITY_STATUS_INTRr, INVALIDr,
        ALTERNATE_EMIRROR_BITMAP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, PORT_LAG_FAILOVER_SET_PAR_ERRf, NULL,
        PORT_LAG_FAILOVER_SETm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        PORT_LAG_FAILOVER_SET_PARITY_CONTROLr,
        PORT_LAG_FAILOVER_SET_PARITY_STATUS_INTRr, INVALIDr,
        PORT_LAG_FAILOVER_SET_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, VLAN_PROFILE_2_PAR_ERRf, NULL,
        VLAN_PROFILE_2m, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        VLAN_PROFILE_2_PARITY_CONTROLr,
        VLAN_PROFILE_2_PARITY_STATUS_INTRr, INVALIDr,
        VLAN_PROFILE_2_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, L3_MTU_VALUES_PAR_ERRf, NULL,
        L3_MTU_VALUESm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        L3_MTU_VALUES_PARITY_CONTROLr,
        L3_MTU_VALUES_PARITY_STATUS_INTRr, INVALIDr,
        L3_MTU_VALUES_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, ING_PW_TERM_SEQ_NUM_PAR_ERRf, NULL,
        ING_PW_TERM_SEQ_NUMm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        ING_PW_TERM_SEQ_NUM_PARITY_CONTROLr,
        ING_PW_TERM_SEQ_NUM_PARITY_STATUS_INTRr, INVALIDr,
        ING_PW_TERM_SEQ_NUM_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, ING_SERVICE_COUNTER_TABLE_PAR_ERRf, NULL,
        ING_SERVICE_COUNTER_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        ING_SERVICE_COUNTER_TABLE_PARITY_CONTROLr,
        ING_SERVICE_COUNTER_TABLE_PARITY_STATUS_INTRr, INVALIDr,
        ING_SERVICE_COUNTER_TABLE_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, ING_VINTF_COUNTER_TABLE_PAR_ERRf, NULL,
        ING_VINTF_COUNTER_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        ING_VINTF_COUNTER_TABLE_PARITY_CONTROLr,
        ING_VINTF_COUNTER_TABLE_PARITY_STATUS_INTRr, INVALIDr,
        ING_VINTF_COUNTER_TABLE_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, VLAN_COS_MAP_PAR_ERRf, NULL,
        VLAN_COS_MAPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        VLAN_COS_MAP_PARITY_CONTROLr,
        VLAN_COS_MAP_PARITY_STATUS_INTRr, INVALIDr,
        VLAN_COS_MAP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, E2E_HOL_STATUS_PAR_ERRf, NULL,
        E2E_HOL_STATUSm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        E2E_HOL_STATUS_PARITY_CONTROLr,
        E2E_HOL_STATUS_PARITY_STATUS_INTRr, INVALIDr,
        E2E_HOL_STATUS_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, E2E_HOL_STATUS_1_PAR_ERRf, NULL,
        E2E_HOL_STATUS_1m, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        E2E_HOL_STATUS_1_PARITY_CONTROLr,
        E2E_HOL_STATUS_1_PARITY_STATUS_INTRr, INVALIDr,
        E2E_HOL_STATUS_1_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, UNKNOWN_UCAST_BLOCK_MASK_PAR_ERRf,
        "UNKNOWN_UCAST_BLOCK_MASK",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        UNKNOWN_UCAST_BLOCK_MASK_PARITY_CONTROLr,
        UNKNOWN_UCAST_BLOCK_MASK_PARITY_STATUS_INTRr, INVALIDr,
        UNKNOWN_UCAST_BLOCK_MASK_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, UNKNOWN_MCAST_BLOCK_MASK_PAR_ERRf,
        "UNKNOWN_MCAST_BLOCK_MASK",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        UNKNOWN_MCAST_BLOCK_MASK_PARITY_CONTROLr,
        UNKNOWN_MCAST_BLOCK_MASK_PARITY_STATUS_INTRr, INVALIDr,
        UNKNOWN_MCAST_BLOCK_MASK_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, BCAST_BLOCK_MASK_PAR_ERRf, "BCAST_BLOCK_MASK",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        BCAST_BLOCK_MASK_PARITY_CONTROLr,
        BCAST_BLOCK_MASK_PARITY_STATUS_INTRr, INVALIDr,
        BCAST_BLOCK_MASK_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, KNOWN_MCAST_BLOCK_MASK_PAR_ERRf,
        "KNOWN_MCAST_BLOCK_MASK",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        KNOWN_MCAST_BLOCK_MASK_PARITY_CONTROLr,
        KNOWN_MCAST_BLOCK_MASK_PARITY_STATUS_INTRr, INVALIDr,
        KNOWN_MCAST_BLOCK_MASK_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, ING_EGRMSKBMAP_PAR_ERRf, "ING_EGRMSKBMAP",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        ING_EGRMSKBMAP_PARITY_CONTROLr,
        ING_EGRMSKBMAP_PARITY_STATUS_INTRr, INVALIDr,
        ING_EGRMSKBMAP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, LOCAL_SW_DISABLE_DEFAULT_PBM_PAR_ERRf,
        "LOCAL_SW_DISABLE_DEFAULT_PBM",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        LOCAL_SW_DISABLE_DEFAULT_PBM_PARITY_CONTROLr,
        LOCAL_SW_DISABLE_DEFAULT_PBM_PARITY_STATUS_INTRr, INVALIDr,
        LOCAL_SW_DISABLE_DEFAULT_PBM_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PAR_ERRf,
        "LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PARITY_CONTROLr,
        LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PARITY_STATUS_INTRr, INVALIDr,
        LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, IMIRROR_BITMAP_PAR_ERRf, "IMIRROR_BITMAP",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        IMIRROR_BITMAP_PARITY_CONTROLr,
        IMIRROR_BITMAP_PARITY_STATUS_INTRr, INVALIDr,
        IMIRROR_BITMAP_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, UNKNOWN_HGI_BITMAP_PAR_ERRf, "UNKNOWN_HGI_BITMAP",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        UNKNOWN_HGI_BITMAP_PARITY_CONTROLr,
        UNKNOWN_HGI_BITMAP_PARITY_STATUS_INTRr, INVALIDr,
        UNKNOWN_HGI_BITMAP_PARITY_STATUS_NACKr, INVALIDr},
    {   INVALIDf, INVALIDf}, /* table terminator */
};

STATIC _soc_parity_info_t _soc_tr2_ip3_2_parity_info[] = {
    {   PARITY_ENf, EMIRROR_CONTROL_PAR_ERRf, "EMIRROR_CONTROL",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EMIRROR_CONTROL_PARITY_CONTROLr,
        EMIRROR_CONTROL_PARITY_STATUS_INTRr, INVALIDr,
        EMIRROR_CONTROL_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, EMIRROR_CONTROL1_PAR_ERRf, "EMIRROR_CONTROL1",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EMIRROR_CONTROL1_PARITY_CONTROLr,
        EMIRROR_CONTROL1_PARITY_STATUS_INTRr, INVALIDr,
        EMIRROR_CONTROL1_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, EMIRROR_CONTROL2_PAR_ERRf, "EMIRROR_CONTROL2",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EMIRROR_CONTROL2_PARITY_CONTROLr,
        EMIRROR_CONTROL2_PARITY_STATUS_INTRr, INVALIDr,
        EMIRROR_CONTROL2_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, EMIRROR_CONTROL3_PAR_ERRf, "EMIRROR_CONTROL3",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EMIRROR_CONTROL3_PARITY_CONTROLr,
        EMIRROR_CONTROL3_PARITY_STATUS_INTRr, INVALIDr,
        EMIRROR_CONTROL3_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, SW2_EOP_BUFFER_A_PAR_ERRf, "SW2_EOP_BUFFER_A",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        SW2_EOP_BUFFER_A_PARITY_CONTROLr,
        SW2_EOP_BUFFER_A_PARITY_STATUS_INTRr, INVALIDr,
        INVALIDr, INVALIDr},
    {   PARITY_ENf, SW2_EOP_BUFFER_B_PAR_ERRf, "SW2_EOP_BUFFER_B",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        SW2_EOP_BUFFER_B_PARITY_CONTROLr,
        SW2_EOP_BUFFER_B_PARITY_STATUS_INTRr, INVALIDr,
        INVALIDr, INVALIDr},
    {   PARITY_ENf, SW2_EOP_BUFFER_C_PAR_ERRf, "SW2_EOP_BUFFER_C",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        SW2_EOP_BUFFER_C_PARITY_CONTROLr,
        SW2_EOP_BUFFER_C_PARITY_STATUS_INTRr, INVALIDr,
        INVALIDr, INVALIDr},
    {   PARITY_ENf, IP_COUNTERS_PAR_ERRf, "IP_COUNTERS",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER,
        IP_COUNTERS_PARITY_CONTROLr,
        IP_COUNTERS_PARITY_STATUS_INTRr, INVALIDr,
        IP_COUNTERS_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, RDBGC_MEM_INST0_PAR_ERRf, "RDBGC0",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER,
        RDBGC_MEM_INST0_PARITY_CONTROLr,
        RDBGC_MEM_INST0_PARITY_STATUS_INTRr, INVALIDr,
        RDBGC_MEM_INST0_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, RDBGC_MEM_INST1_PAR_ERRf, "RDBGC1",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER,
        RDBGC_MEM_INST1_PARITY_CONTROLr,
        RDBGC_MEM_INST1_PARITY_STATUS_INTRr, INVALIDr,
        RDBGC_MEM_INST1_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, RDBGC_MEM_INST2_PAR_ERRf, "RDBGC2",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER,
        RDBGC_MEM_INST2_PARITY_CONTROLr,
        RDBGC_MEM_INST2_PARITY_STATUS_INTRr, INVALIDr,
        RDBGC_MEM_INST2_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, HG_COUNTERS_PAR_ERRf, "HG_COUNTERS",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER,
        HG_COUNTERS_PARITY_CONTROLr,
        HG_COUNTERS_PARITY_STATUS_INTRr, INVALIDr,
        HG_COUNTERS_PARITY_STATUS_NACKr, INVALIDr},
    {   INVALIDf, INVALIDf}, /* table terminator */
};

STATIC _soc_parity_info_t _soc_tr2_ep0_parity_info[] = {
    {   EGR_L3_NEXT_HOP_PARITY_ENf, EGR_NHOP_PAR_ERRf, NULL,
        EGR_L3_NEXT_HOPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_EL3_PARITY_CONTROLr,
        EGR_L3_NEXT_HOP_PARITY_STATUS_INTRr, INVALIDr,
        EGR_L3_NEXT_HOP_PARITY_STATUS_NACKr, INVALIDr},
    {   EGR_L3_INTF_PARITY_ENf, EGR_L3_INTF_PAR_ERRf, NULL,
        EGR_L3_INTFm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_EL3_PARITY_CONTROLr,
        EGR_L3_INTF_PARITY_STATUS_INTRr, INVALIDr,
        EGR_L3_INTF_PARITY_STATUS_NACKr, INVALIDr},
    {   EGR_MPLS_VC_AND_SWAP_LABEL_PARITY_ENf, EGR_MPLS_LABEL_PAR_ERRf, NULL,
        EGR_MPLS_VC_AND_SWAP_LABEL_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_EL3_PARITY_CONTROLr,
        EGR_MPLS_VC_AND_SWAP_LABEL_PARITY_STATUS_INTRr, INVALIDr,
        EGR_MPLS_VC_AND_SWAP_LABEL_PARITY_STATUS_NACKr, INVALIDr},
    {   EGR_VLAN_PARITY_ENf, EGR_VLAN_PAR_ERRf, NULL,
        EGR_VLANm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_VLAN_PARITY_CONTROLr,
        EGR_VLAN_PARITY_STATUS_INTRr, INVALIDr,
        EGR_VLAN_PARITY_STATUS_NACKr, INVALIDr},
    {   EGR_VLAN_STG_PARITY_ENf, EGR_VLAN_STG_PAR_ERRf, NULL,
        EGR_VLAN_STGm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_VLAN_PARITY_CONTROLr,
        EGR_VLAN_STG_PARITY_STATUS_INTRr, INVALIDr,
        EGR_VLAN_STG_PARITY_STATUS_NACKr, INVALIDr},
    {   EGR_IP_TUNNEL_PARITY_ENf, EGR_IP_TUNNEL_PAR_ERRf, NULL,
        EGR_IP_TUNNELm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_VLAN_PARITY_CONTROLr,
        EGR_IP_TUNNEL_PARITY_STATUS_INTRr, INVALIDr,
        EGR_IP_TUNNEL_PARITY_STATUS_NACKr, INVALIDr},
    {   EGR_VLAN_XLATE_PARITY_ENf, EGR_VLAN_XLATE_PAR_ERRf, NULL,
        EGR_VLAN_XLATEm, _SOC_PARITY_INFO_TYPE_DUAL_PARITY,
        EGR_VLAN_PARITY_CONTROLr,
        EGR_VLAN_XLATE_PARITY_STATUS_INTR_0r, EGR_VLAN_XLATE_PARITY_STATUS_INTR_1r,
        EGR_VLAN_XLATE_PARITY_STATUS_NACK_0r, EGR_VLAN_XLATE_PARITY_STATUS_NACK_1r},
    {   FRAGMENT_ID_ECC_ENf, EGR_FRAGMENT_ID_TABLE_ECC_ERRf, NULL,
        EGR_FRAGMENT_ID_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        EGR_EIPT_ECC_CONTROLr,
        EGR_FRAGMENT_ID_ECC_STATUS_INTRr, INVALIDr,
        EGR_FRAGMENT_ID_ECC_STATUS_NACKr, INVALIDr},
    {   EHG_QOS_MAPPING_ECC_ENf, EGR_EHG_QOS_MAP_TABLE_ECC_ERRf, NULL,
        EGR_EHG_QOS_MAPPING_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        EGR_EIPT_ECC_CONTROLr,
        EGR_EHG_QOS_MAPPING_ECC_STATUS_INTRr, INVALIDr,
        EGR_EHG_QOS_MAPPING_ECC_STATUS_NACKr, INVALIDr},
    {   FRAG_HEADER_ECC_ENf, EGR_FRAG_HEADER_TABLE_ECC_ERRf, "EGR_FRAG_HEADER",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        EGR_EIPT_ECC_CONTROLr,
        EGR_FRAG_HEADER_ECC_STATUS_INTRr, INVALIDr,
        INVALIDr, INVALIDr},
    {   FRAG_PACKET_ECC_ENf, EGR_FRAG_PKT_TABLE_ECC_ERRf, "EGR_FRAG_PACKET",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        EGR_EHCPM_ECC_PARITY_CONTROLr,
        EGR_FRAG_PACKET_ECC_STATUS_INTRr, INVALIDr,
        INVALIDr, INVALIDr},
    {   MOD_MAP_PARITY_ENf, EGR_MOD_MAP_TABLE_PAR_ERRf, NULL,
        EGR_MOD_MAP_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_EHCPM_ECC_PARITY_CONTROLr,
        EGR_MOD_MAP_PARITY_STATUS_INTRr, INVALIDr,
        EGR_MOD_MAP_PARITY_STATUS_NACKr, INVALIDr},
    {   EGR_MAC_DA_PROFILE_PARITY_ENf, EGR_MAC_DA_PROFILE_PAR_ERRf, NULL,
        EGR_MAC_DA_PROFILEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_EL3_PARITY_CONTROLr,
        EGR_MAC_DA_PROFILE_PARITY_STATUS_INTRr, INVALIDr,
        EGR_MAC_DA_PROFILE_PARITY_STATUS_NACKr, INVALIDr},
    {   EGR_WLAN_DVP_PARITY_ENf, EGR_WLAN_DVP_PAR_ERRf, NULL,
        EGR_WLAN_DVPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_EL3_PARITY_CONTROLr,
        EGR_WLAN_DVP_PARITY_STATUS_INTRr, INVALIDr,
        EGR_WLAN_DVP_PARITY_STATUS_NACKr, INVALIDr},
    {   EGR_VFI_PARITY_ENf, EGR_VFI_PAR_ERRf, NULL,
        EGR_VFIm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_EL3_PARITY_CONTROLr,
        EGR_VFI_PARITY_STATUS_INTRr, INVALIDr,
        EGR_VFI_PARITY_STATUS_NACKr, INVALIDr},
    {   EGR_IPMC_PARITY_ENf, EGR_IPMC_PAR_ERRf, NULL,
        EGR_IPMCm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_EL3_PARITY_CONTROLr,
        EGR_IPMC_PARITY_STATUS_INTRr, INVALIDr,
        EGR_IPMC_PARITY_STATUS_NACKr, INVALIDr},
    {   EGR_MPLS_EXP_MAPPING_2_PARITY_ENf, EGR_MPLS_EXP_MAPPING_2_PAR_ERRf,
        NULL,
        EGR_MPLS_EXP_MAPPING_2m, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_VLAN_PARITY_CONTROLr,
        EGR_MPLS_EXP_MAPPING_2_PARITY_STATUS_INTRr, INVALIDr,
        EGR_MPLS_EXP_MAPPING_2_PARITY_STATUS_NACKr, INVALIDr},
    {   EGR_MPLS_PRI_MAPPING_PARITY_ENf, EGR_MPLS_PRI_MAPPING_PAR_ERRf, NULL,
        EGR_MPLS_PRI_MAPPINGm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_VLAN_PARITY_CONTROLr,
        EGR_MPLS_PRI_MAPPING_PARITY_STATUS_INTRr, INVALIDr,
        EGR_MPLS_PRI_MAPPING_PARITY_STATUS_NACKr, INVALIDr},
    {   EGR_PRI_CNG_MAP_PARITY_ENf, EGR_PRI_CNG_MAP_PAR_ERRf, NULL,
        EGR_PRI_CNG_MAPm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_VLAN_PARITY_CONTROLr,
        EGR_PRI_CNG_MAP_PARITY_STATUS_INTRr, INVALIDr,
        EGR_PRI_CNG_MAP_PARITY_STATUS_NACKr, INVALIDr},
    {   EGR_DSCP_TABLE_PARITY_ENf, EGR_DSCP_TABLE_PAR_ERRf, NULL,
        EGR_DSCP_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_VLAN_PARITY_CONTROLr,
        EGR_DSCP_TABLE_PARITY_STATUS_INTRr, INVALIDr,
        EGR_DSCP_TABLE_PARITY_STATUS_NACKr, INVALIDr},
    {   EMOP_BUFFER_ECC_ENf, EGR_EMOP_BUFFER_ECC_ERRf, "EGR_EPMOD",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        EGR_EPMOD_ECC_CONTROLr,
        EGR_EMOP_BUFFER_ECC_STATUS_INTRr, INVALIDr,
        INVALIDr, INVALIDr},
    {   PARITY_ENf, EGR_IPFIX_EXPORT_PAR_ERRf, NULL,
        EGR_IPFIX_EXPORT_FIFOm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_IPFIX_EXPORT_FIFO_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        EGR_IPFIX_EXPORT_FIFO_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, EGR_IPFIX_SESS_PAR_ERRf, NULL,
        EGR_IPFIX_SESSION_TABLEm, _SOC_PARITY_INFO_TYPE_DUAL_PARITY,
        EGR_IPFIX_SESSION_PARITY_CONTROLr,
        EGR_IPFIX_SESSION_PARITY_STATUS_INTR_0r, EGR_IPFIX_SESSION_PARITY_STATUS_INTR_1r,
        EGR_IPFIX_SESSION_PARITY_STATUS_NACK_0r, EGR_IPFIX_SESSION_PARITY_STATUS_NACK_1r},
    {   PARITY_ENf, EGR_IPFIX_EOP_PAR_ERRf, NULL,
        EGR_IPFIX_EOP_BUFFERm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_IPFIX_EOP_BUF_PARITY_CONTROLr,
        EGR_IPFIX_EOP_BUF_PARITY_STATUS_INTRr, INVALIDr,
        EGR_IPFIX_EOP_BUF_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, EGR_EFP_PW_INIT_COUNTER_PAR_ERRf, NULL,
        EGR_PW_INIT_COUNTERSm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EGR_PW_INIT_COUNTERS_PARITY_CONTROLr,
        EGR_PW_INIT_COUNTERS_PARITY_STATUS_INTRr, INVALIDr,
        EGR_PW_INIT_COUNTERS_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, EGR_EFP_POLICY_TABLE_PAR_ERRf, NULL,
        EFP_POLICY_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EFP_POLICY_PARITY_CONTROLr,
        EFP_POLICY_PARITY_STATUS_INTRr, INVALIDr,
        EFP_POLICY_PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, EGR_EFP_METER_TABLE_PAR_ERRf, NULL,
        EFP_METER_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EFP_METER_PARITY_CONTROLr,
        EFP_METER_PARITY_STATUS_INTRr, INVALIDr,
        EFP_METER_PARITY_STATUS_NACKr, INVALIDr},
    {   PERQ_PAR_ENf, EGR_PERQ_XMT_COUNTERS_PAR_ERRf, "EGR_PERQ_XMT_COUNTERS",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EDATABUF_PARITY_CONTROLr,
        EGR_PERQ_XMT_COUNTERS_STATUS_INTRr, INVALIDr,
        EGR_PERQ_XMT_COUNTERS_STATUS_NACKr, INVALIDr},
    {   VINTFCTR_PAR_ENf, EGR_VINTF_COUNTER_TABLE_PAR_ERRf, NULL,
        EGR_VINTF_COUNTER_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EDATABUF_PARITY_CONTROLr,
        EGR_VINTF_COUNTER_TABLE_STATUS_INTRr, INVALIDr,
        EGR_VINTF_COUNTER_TABLE_STATUS_NACKr, INVALIDr},
    {   SVCCTR_PAR_ENf, EGR_SERVICE_COUNTER_TABLE_PAR_ERRf, NULL,
        EGR_SERVICE_COUNTER_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EDATABUF_PARITY_CONTROLr,
        EGR_SERVICE_COUNTER_TABLE_STATUS_INTRr, INVALIDr,
        EGR_SERVICE_COUNTER_TABLE_STATUS_NACKr, INVALIDr},
    {   EFPCTR_PAR_ENf, EGR_FP_COUNTER_TABLE_PAR_ERRf, NULL,
        EFP_COUNTER_TABLEm, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY,
        EDATABUF_PARITY_CONTROLr,
        EGR_FP_COUNTER_TABLE_STATUS_INTRr, INVALIDr,
        EGR_FP_COUNTER_TABLE_STATUS_NACKr, INVALIDr},
    {   INVALIDf, INVALIDf}, /* table terminator */
};

STATIC _soc_parity_info_t _soc_tr2_ep1_parity_info[] = {
    {   STATS_PAR_ENf, EGR_STATS_COUNTER_TABLE_PAR_ERRf, "Egress stats",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER,
        EDATABUF_PARITY_CONTROLr,
        EGR_STATS_COUNTER_TABLE_STATUS_INTRr, INVALIDr,
        EGR_STATS_COUNTER_TABLE_STATUS_NACKr, INVALIDr},
    {   INITBUF_ECC_ENf, EGR_INITBUF_ECC_ERRf, "EGR_INITBUF",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        EGR_EHCPM_ECC_PARITY_CONTROLr,
        EGR_INITBUF_ECC_STATUS_INTRr, INVALIDr,
        INVALIDr, INVALIDr},
    
    {   INVALIDf, INVALIDf}, /* table terminator */
};

#if 0 
STATIC _soc_parity_info_t _soc_tr2_edb_parity_info[] = {
    {   STATS_PAR_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   LB_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   CM_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   SP_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   XP3_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   XP2_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   XP1_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   XP0_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   XQP5_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   XQP4_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   XQP3_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   XQP2_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   XQP1_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   XQP0_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   GP1_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   GP0_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   RESIDBUF_ECC_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   EFPCTR_PAR_ENf, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        EDATABUF_PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   INVALIDf, INVALIDf}, /* table terminator */
};
#endif

STATIC _soc_parity_info_t _soc_tr2_xqp_parity_info[] = {
    {   EHG_TX_DATAf, EHG_TX_DATAf, NULL,
        XQPORT_EHG_TX_TUNNEL_DATAm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        XQPORT_PARITY_CONTROLr,
        XQPORT_EHG_TX_DATA_PARITY_STATUS_INTRr, XQPORT_FORCE_SINGLE_BIT_ERRORr,
        XQPORT_EHG_TX_DATA_PARITY_STATUS_NACKr, XQPORT_FORCE_DOUBLE_BIT_ERRORr},
    
    {   XQBOD_RXFIFOf, XQBOD_RXFIFOf, "XQBOD_RXFIFO",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        XQPORT_PARITY_CONTROLr,
        XQPORT_XQBOD_RXFIFO_PARITY_STATUS_INTRr, XQPORT_FORCE_SINGLE_BIT_ERRORr,
        INVALIDr, XQPORT_FORCE_DOUBLE_BIT_ERRORr},
    {   XQBODE_TXFIFOf, XQBODE_TXFIFOf, "XQBODE_TXFIFO",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        XQPORT_PARITY_CONTROLr,
        XQPORT_XQBODE_TXFIFO_PARITY_STATUS_INTRr, XQPORT_FORCE_SINGLE_BIT_ERRORr,
        INVALIDr, XQPORT_FORCE_DOUBLE_BIT_ERRORr},
    {   INVALIDf, INVALIDf}, /* table terminator */
};

STATIC _soc_parity_info_t _soc_tr2_gp_parity_info[] = {
    {   EHG_TX_DATAf, EHG_TX_DATAf, NULL,
        GPORT_EHG_TX_TUNNEL_DATAm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        GPORT_PARITY_CONTROLr,
        GPORT_EHG_TX_DATA_PARITY_STATUS_INTRr, GPORT_FORCE_SINGLE_BIT_ERRORr,
        GPORT_EHG_TX_DATA_PARITY_STATUS_NACKr, GPORT_FORCE_DOUBLE_BIT_ERRORr},
    
    {   GBOD_RXFIFOf, GBOD_RXFIFOf, "GBOD_RXFIFO",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        GPORT_PARITY_CONTROLr,
        GPORT_GBOD_RXFIFO_PARITY_STATUS_INTRr, GPORT_FORCE_SINGLE_BIT_ERRORr,
        INVALIDr, GPORT_FORCE_DOUBLE_BIT_ERRORr},
    {   GBODE_TXFIFOf, GBODE_TXFIFOf, "GBODE_TXFIFO",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        GPORT_PARITY_CONTROLr,
        GPORT_GBODE_TXFIFO_PARITY_STATUS_INTRr, GPORT_FORCE_SINGLE_BIT_ERRORr,
        INVALIDr, GPORT_FORCE_DOUBLE_BIT_ERRORr},
    {   INVALIDf, INVALIDf}, /* table terminator */
};

STATIC _soc_parity_info_t _soc_tr2_xp_parity_info[] = {
    {   RX_FIFO_MEM_ECC_ENf, RX_FIFO_MEM_ERRf, "XPORT_RX_FIFO_MEM",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        XPORT_ECC_CONTROLr,
        XPORT_RX_FIFO_MEM_ECC_STATUSr, XPORT_FORCE_SINGLE_BIT_ERRORr,
        INVALIDr, XPORT_FORCE_DOUBLE_BIT_ERRORr},
    {   TX_FIFO_MEM_ECC_ENf, TX_FIFO_MEM_ERRf, "XPORT_TX_FIFO_MEM",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        XPORT_ECC_CONTROLr,
        XPORT_TX_FIFO_MEM_ECC_STATUSr, XPORT_FORCE_SINGLE_BIT_ERRORr,
        INVALIDr, XPORT_FORCE_DOUBLE_BIT_ERRORr},
    {   INVALIDf, INVALIDf}, /* table terminator */
};

STATIC _soc_parity_info_t _soc_tr2_sp_parity_info[] = {
    {   RX_FIFO_MEM_ECC_ENf, RX_FIFO_MEM_ERRf, "SPORT_RX_FIFO_MEM",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        SPORT_ECC_CONTROLr,
        SPORT_RX_FIFO_MEM_ECC_STATUSr, SPORT_FORCE_SINGLE_BIT_ERRORr,
        INVALIDr, SPORT_FORCE_DOUBLE_BIT_ERRORr},
    {   TX_FIFO_MEM_ECC_ENf, TX_FIFO_MEM_ERRf, "SPORT_TX_FIFO_MEM",
        INVALIDm, _SOC_PARITY_INFO_TYPE_SINGLE_ECC,
        SPORT_ECC_CONTROLr,
        SPORT_TX_FIFO_MEM_ECC_STATUSr, SPORT_FORCE_SINGLE_BIT_ERRORr,
        INVALIDr, SPORT_FORCE_DOUBLE_BIT_ERRORr},
    {   INVALIDf, INVALIDf}, /* table terminator */
};

#if 0 
STATIC _soc_parity_info_t _soc_tr2_ut_parity_info[] = {
    {   f, f, NULL, /* Need parity enable */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        _PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   PARITY_ENf, NULL,
        m, _SOC_PARITY_INFO_TYPE_SINGLE_PARITY, 
        _PARITY_CONTROLr,
        _PARITY_STATUS_INTRr, INVALIDr,
        _PARITY_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, NULL,
        m, _SOC_PARITY_INFO_TYPE_SINGLE_ECC, 
        _ECC_CONTROLr,
        _ECC_STATUS_INTRr, INVALIDr,
        _ECC_STATUS_NACKr, INVALIDr},
    {   PARITY_ENf, NULL,
        m, _SOC_PARITY_INFO_TYPE_DUAL_PARITY, 
        _PARITY_CONTROLr,
        _PARITY_STATUS_INTR_0r, _PARITY_STATUS_INTR_1r,
        _PARITY_STATUS_NACK_0r, _PARITY_STATUS_NACK_1r},
    {   PARITY_ENf, NULL,
        m, _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER, 
        _PARITY_CONTROLr,
        _PARITY_STATUS_INTRr, INVALIDr,
        _PARITY_STATUS_NACKr, INVALIDr},
    {   f, f, NULL, /* Need INTR_STATUS field */
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        _PARITY_CONTROLr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   PARITY_ENf, NULL, INVALIDm, _SOC_PARITY_INFO_TYPE_NUM}, /* table terminator */
};
#endif

/*
 * Is DEQ_CBPERRPTRr for MMU_CBPDATA0 - MMU_CBPDATA31 (15-bit address)?
 * How does MMU_CELLCHKm (15-bit address) report parity error?
 */
STATIC _soc_parity_info_t _soc_tr2_mmu_parity_info[] = {
    {   AGING_CTR_PAR_ERR_ENf, AGING_CTR_PAR_ERRf, NULL,
        MMU_AGING_CTRm, _SOC_PARITY_INFO_TYPE_MMU_PARITY,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   AGING_EXP_PAR_ERR_ENf, AGING_EXP_PAR_ERRf, NULL,
        MMU_AGING_EXPm, _SOC_PARITY_INFO_TYPE_MMU_PARITY,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   CCP_PAR_ERR_ENf, CCP_PAR_ERRf, NULL,
        MMU_CCP_MEMm, _SOC_PARITY_INFO_TYPE_MMU_PARITY,
        INVALIDr,
        CCPPARITYERRORPTRr, INVALIDr,
        INVALIDr, INVALIDr},
    {   CFAP_PAR_ERR_ENf, CFAP_PAR_ERRf, NULL,
        MMU_CFAP_MEMm, _SOC_PARITY_INFO_TYPE_MMU_PARITY,
        INVALIDr,
        CFAPPARITYERRORPTRr, INVALIDr,
        INVALIDr, INVALIDr},
    {   CFAP_MEM_FAIL_ENf, CFAP_MEM_FAILf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   DEQ_RDEHDR_ERR_ENf, DEQ_RDEHDR_ERRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_MMU_PARITY,
        INVALIDr,
        DEQ_RDEHDRERRPTRr, INVALIDr,
        INVALIDr, INVALIDr},
    {   DEQ_PKTHDR0_ERR_ENf, DEQ_PKTHDR0_ERRf, NULL,
        MMU_CBPPKTHEADER0_MEM0m, _SOC_PARITY_INFO_TYPE_MMU_PARITY,
        INVALIDr,
        DEQ_PKTHDR0ERRPTRr, INVALIDr,
        INVALIDr, INVALIDr},
    {   DEQ0_NOT_IP_ERR_ENf, DEQ0_NOT_IP_ERRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   DEQ0_CELLCRC_ERR_ENf, DEQ0_CELLCRC_ERRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   START_BY_START_ERR_ENf, START_BY_START_ERRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   MEM1_IPMC_TBL_PAR_ERR_ENf, MEM1_IPMC_TBL_PAR_ERRf, "MMU_IPMC_GROUP_TBL",
        INVALIDm, _SOC_PARITY_INFO_TYPE_MMUIPMC,
        INVALIDr,
        MEM1_IPMCGRP_TBL_PARITYERRORPTRr, MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr,
        INVALIDr, INVALIDr},
    {   MEM1_VLAN_TBL_PAR_ERR_ENf, MEM1_VLAN_TBL_PAR_ERRf, NULL,
        MMU_IPMC_VLAN_TBLm, _SOC_PARITY_INFO_TYPE_MMU_PARITY,
        INVALIDr,
        MEM1_IPMCVLAN_TBL_PARITYERRORPTRr, MEM1_IPMCVLAN_TBL_PARITYERROR_STATUSr,
        INVALIDr, INVALIDr},
    {   TOQ0_PKTHDR1_PAR_ERR_ENf, TOQ0_PKTHDR1_PAR_ERRf, NULL,
        MMU_CBPPKTHEADER1_MEM0m, _SOC_PARITY_INFO_TYPE_MMU_PARITY,
        INVALIDr,
        TOQ_PKTHDR1ERRPTRr, INVALIDr,
        INVALIDr, INVALIDr},
    {   TOQ0_PKTLINK_PAR_ERR_ENf, TOQ0_PKTLINK_PAR_ERRf, NULL,
        MMU_PKTLINK0m, _SOC_PARITY_INFO_TYPE_MMU_PARITY,
        INVALIDr,
        TOQ_PKTLINKERRPTRr, INVALIDr,
        INVALIDr, INVALIDr},
    {   TOQ0_CELLLINK_PAR_ERR_ENf, TOQ0_CELLLINK_PAR_ERRf, NULL,
        MMU_CELLLINKm, _SOC_PARITY_INFO_TYPE_MMU_PARITY,
        INVALIDr,
        TOQ_CELLLINKERRPTRr, INVALIDr,
        INVALIDr, INVALIDr},
    /* what memory is this for? */
    {   TOQ0_IPMC_TBL_PAR_ERR_ENf, TOQ0_IPMC_TBL_PAR_ERRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        INVALIDr,
        TOQ_IPMCGRPERRPTR0r, INVALIDr,
        INVALIDr, INVALIDr},
    /* what memory is this for? */
    {   TOQ0_VLAN_TBL_PAR_ERR_ENf, TOQ0_VLAN_TBL_PAR_ERRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        INVALIDr,
        TOQ_IPMCVLANERRPTRr, INVALIDr,
        INVALIDr, INVALIDr},
    /* what is this memory ? use EGRSHAPEPARITYERRORPTRr for status? */
    {   MTRO_PAR_ERR_ENf, MTRO_PAR_ERRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   PFAP_PAR_ERR_ENf, PFAP_PAR_ERRf, NULL,
        MMU_PFAP_MEMm, _SOC_PARITY_INFO_TYPE_MMU_PARITY,
        INVALIDr,
        PFAPPARITYERRORPTRr, INVALIDr,
        INVALIDr, INVALIDr},
    {   PFAP_MEM_FAIL_ENf, PFAP_MEM_FAILf, NULL,
        MMU_PFAP_MEMm, _SOC_PARITY_INFO_TYPE_GENERIC,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   WRED_PAR_ERR_ENf, WRED_PAR_ERRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_MMUWRED,
        INVALIDr,
        WRED_PARITY_ERROR_INFOr, WRED_PARITY_ERROR_BITMAPr,
        INVALIDr, INVALIDr},
    {   DEQ_PKTHDR2_ERR_ENf, DEQ_PKTHDR2_PAR_ERRf, NULL,
        MMU_CBPPKTHEADER2m, _SOC_PARITY_INFO_TYPE_MMU_PARITY,
        INVALIDr,
        DEQ_PKTHDR2ERRPTRr, INVALIDr,
        INVALIDr, INVALIDr},
    /* what memory is this for? use E2EFC_PARITYERRORPTRr.PTRf for index */
    {   E2EFC_ERR_ENf, E2EFC_PAR_ERRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   WAMU_ERR_ENf, WAMU_PAR_ERRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   PQE_ERR_ENf, PQE_PAR_ERRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   RDE_ERR_ENf, RDE_PAR_ERRf, NULL,
        INVALIDm, _SOC_PARITY_INFO_TYPE_GENERIC,
        INVALIDr,
        INVALIDr, INVALIDr,
        INVALIDr, INVALIDr},
    {   INVALIDf, INVALIDf}, /* table terminator */
};

STATIC struct {
    uint32 cpi_bit;
    soc_block_t blocktype;
    soc_reg_t enable_reg;
    soc_reg_t status_reg;
    _soc_parity_info_t *info;
}_soc_tr2_parity_group_info[] = {
    {   0x00001, SOC_BLK_MMU, MEM_FAIL_INT_ENr, MEM_FAIL_INT_STATr, _soc_tr2_mmu_parity_info},
    {   0x00002, SOC_BLK_EPIPE, EP_INTR0_ENABLEr, EP_INTR0_STATUSr, _soc_tr2_ep0_parity_info},
    {   0x00002, SOC_BLK_EPIPE, EP_INTR1_ENABLEr, EP_INTR1_STATUSr, _soc_tr2_ep1_parity_info},
    {   0x00004, SOC_BLK_IPIPE, IP0_INTR_ENABLEr, IP0_INTR_STATUSr, _soc_tr2_ip0_parity_info},
    {   0x00008, SOC_BLK_IPIPE, IP1_INTR_ENABLEr, IP1_INTR_STATUSr, _soc_tr2_ip1_parity_info},
    {   0x00010, SOC_BLK_IPIPE, IP2_INTR_ENABLEr, IP2_INTR_STATUSr, _soc_tr2_ip2_parity_info},
    {   0x00020, SOC_BLK_IPIPE, IP3_INTR_ENABLEr, IP3_INTR_STATUSr, _soc_tr2_ip3_parity_info},
    {   0x00020, SOC_BLK_IPIPE, IP3_INTR_ENABLE_1r, IP3_INTR_STATUS_1r, _soc_tr2_ip3_1_parity_info},
    {   0x00020, SOC_BLK_IPIPE, IP3_INTR_ENABLE_2r, IP3_INTR_STATUS_2r, _soc_tr2_ip3_2_parity_info},
    /* { 0x00040, PCIE_REPLAY_PERR, }, */
    {   0x00080, SOC_BLK_GPORT, GPORT_INTR_ENABLEr, GPORT_INTR_STATUSr, _soc_tr2_gp_parity_info}, /* x2 */
    {   0x00200, SOC_BLK_XQPORT, XQPORT_INTR_ENABLEr, XQPORT_INTR_STATUSr, _soc_tr2_xqp_parity_info}, /* x6 */
    {   0x08000, SOC_BLK_GXPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr, _soc_tr2_xp_parity_info}, /* x4 */
    {   0x80000, SOC_BLK_SPORT, SPORT_INTR_ENABLEr, SPORT_INTR_STATUSr, _soc_tr2_sp_parity_info},
    {   0}, /* table terminator */
};

STATIC soc_triumph2_oam_handler_t oam_handler[SOC_MAX_NUM_DEVICES];

static int _stat_error_fixed[SOC_MAX_NUM_DEVICES];

#define _SOC_SER_REG 1
#define _SOC_SER_MEM 0

typedef struct _ser_nack_reg_mem_s {
    int reg_mem;
    soc_reg_t reg;
    soc_mem_t mem;
} _ser_nack_reg_mem_t;

static soc_ser_functions_t _tr2_ser_functions;

STATIC int
_soc_triumph_parity_block_port(int unit, soc_block_t block, soc_port_t *port)
{
    *port = SOC_BLOCK_PORT(unit, block);
    if ((*port != REG_PORT_ANY) && !SOC_PORT_VALID(unit, *port)) {
        return SOC_E_PORT;
    }

    return SOC_E_NONE;
}

STATIC int
_soc_triumph2_parity_enable(int unit, int enable)
{
    int group, table;
    uint32 addr, group_enable, regval, misc_cfg,
    cmic_enable = 0, cpi_blk_bit;
    _soc_parity_info_t *info;
    soc_reg_t group_reg, reg;
    soc_port_t block_port;
    soc_field_t enable_field;
    soc_block_t blk;

    /* loop through each group */
    for (group = 0; _soc_tr2_parity_group_info[group].cpi_bit; group++) {
        info = _soc_tr2_parity_group_info[group].info;
        group_reg = _soc_tr2_parity_group_info[group].enable_reg;
        group_enable = 0;

        cpi_blk_bit = _soc_tr2_parity_group_info[group].cpi_bit;

        SOC_BLOCK_ITER(unit, blk,
                _soc_tr2_parity_group_info[group].blocktype) {
            if (_soc_triumph_parity_block_port(unit, blk, &block_port) < 0) {
                cpi_blk_bit <<= 1;
                continue;
            }

            /* loop through each table in the group */
            for (table = 0; info[table].enable_field != INVALIDf; table++) {
                /* handle different parity error reporting style */
                switch (info[table].type) {
                    case _SOC_PARITY_INFO_TYPE_GENERIC:
                    case _SOC_PARITY_INFO_TYPE_MMU_PARITY:
                    case _SOC_PARITY_INFO_TYPE_MMUIPMC:
                    case _SOC_PARITY_INFO_TYPE_MMUWRED:
                    case _SOC_PARITY_INFO_TYPE_OAM:
                    enable_field = info[table].enable_field;
                    break;
                    case _SOC_PARITY_INFO_TYPE_SINGLE_PARITY:
                    case _SOC_PARITY_INFO_TYPE_SINGLE_ECC:
                    case _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER:
                    case _SOC_PARITY_INFO_TYPE_DUAL_PARITY:
                    reg = info[table].control_reg;
                    if (!SOC_REG_IS_VALID(unit, reg)) {
                        continue;
                    }
                    addr = soc_reg_addr(unit, reg, block_port, 0);
                    SOC_IF_ERROR_RETURN(soc_reg32_read(unit, addr, &regval));
                    soc_reg_field_set(unit, reg, &regval,
                            info[table].enable_field,
                            enable ? 1 : 0);
                    SOC_IF_ERROR_RETURN(soc_reg32_write(unit, addr, regval));
                    enable_field = info[table].error_field;
                    break;
                    default:
                    enable_field = INVALIDf;
                    break;
                } /* handle different parity error reporting style */
                if (enable_field != INVALIDf) {
                    soc_reg_field_set(unit, group_reg, &group_enable,
                            enable_field, enable ? 1 : 0);
                }
            } /* loop through each table in the group */
            if (!SOC_REG_IS_VALID(unit, group_reg)) {
                cpi_blk_bit <<= 1;
                continue;
            }
            addr = soc_reg_addr(unit, group_reg, block_port, 0);
            SOC_IF_ERROR_RETURN(soc_reg32_write(unit, addr, group_enable));
            cmic_enable |= cpi_blk_bit;
            cpi_blk_bit <<= 1;
        }
    } /* loop through each group */

    /* Special extras for debug */
    SOC_IF_ERROR_RETURN(WRITE_ERB_INTR_ENABLEr(unit, 0x1f));
    SOC_IF_ERROR_RETURN(WRITE_IESMIF_INTR_ENABLEr(unit, 0x7fff));

    SOC_IF_ERROR_RETURN(WRITE_EP_DATAPATH_INTR_ENABLEr(unit, 0xffff));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_CHIP_PARITY_INTR_ENABLEr(unit,
                    cmic_enable));

    /* MMU enables */
    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &misc_cfg));
    soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg, PARITY_STAT_CLEARf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, misc_cfg));

    soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg, PARITY_CHK_ENf, 1);
    soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg, PARITY_GEN_ENf, 1);
    soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg, PARITY_STAT_CLEARf, 0);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, misc_cfg));

    SOC_IF_ERROR_RETURN(READ_MEM_FAIL_INT_STATr(unit, &regval));
    soc_intr_enable(unit, IRQ_MEM_FAIL);

    return SOC_E_NONE;
}

int
_soc_triumph2_mem_parity_control(int unit, soc_mem_t mem,
        int copyno, int enable)
{
    int group, table;
    uint32 cpi_blk_bit, misc_cfg;
    _soc_parity_info_t *info;
    soc_reg_t group_reg, reg;
    soc_port_t block_port;
    soc_field_t enable_field;
    soc_block_t blk;

    if (!soc_property_get(unit, spn_PARITY_ENABLE, TRUE)) {
        /* Parity checking is not enabled, nothing to do */
        return SOC_E_NONE;
    }

    /* Convert component/aggregate memories to the table for which
     * the parity registers correspond. */
    switch(mem) {
        case VLAN_SUBNETm:
            mem = VLAN_SUBNET_DATA_ONLYm; /* Should be VLAN_SUBNET? */
            break;
        case L2_ENTRY_ONLYm:
            mem = L2Xm;
            break;
        case L2_USER_ENTRY_ONLYm:
        case L2_USER_ENTRY_DATA_ONLYm:
            mem = L2_USER_ENTRYm;
            break;
        case L3_DEFIPm:
            mem = L3_DEFIP_DATA_ONLYm;
            break;
        case L3_DEFIP_128m:
            mem = L3_DEFIP_128_DATA_ONLYm;
            break;
        case EGR_IP_TUNNEL_IPV6m:
        case EGR_IP_TUNNEL_MPLSm:
            mem = EGR_IP_TUNNELm;
            break;
        default:
            /* Do nothing, keep memory as provided */
            break;
    }

    /* loop through each group */
    for (group = 0; _soc_tr2_parity_group_info[group].cpi_bit; group++) {
        info = _soc_tr2_parity_group_info[group].info;
        group_reg = _soc_tr2_parity_group_info[group].enable_reg;
        cpi_blk_bit = _soc_tr2_parity_group_info[group].cpi_bit;

        SOC_BLOCK_ITER(unit, blk,
                _soc_tr2_parity_group_info[group].blocktype) {
            if (_soc_triumph_parity_block_port(unit, blk, &block_port) < 0) {
                cpi_blk_bit <<= 1;
                continue;
            }
            if ((copyno != MEM_BLOCK_ANY) && (blk != copyno)) {
                cpi_blk_bit <<= 1;
                continue;
            }

            /* loop through each table in the group */
            for (table = 0; info[table].enable_field != INVALIDf; table++) {
                if (mem != info[table].mem) {
                    continue;
                }

                /* handle different parity error reporting style */
                switch (info[table].type) {
                    case _SOC_PARITY_INFO_TYPE_GENERIC:
                    case _SOC_PARITY_INFO_TYPE_MMU_PARITY:
                    case _SOC_PARITY_INFO_TYPE_MMUIPMC:
                    case _SOC_PARITY_INFO_TYPE_MMUWRED:
                    enable_field = info[table].enable_field;
                    SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, group_reg, block_port,
                                    enable_field,
                                    enable ? 1 : 0));
                    break;
                    case _SOC_PARITY_INFO_TYPE_SINGLE_PARITY:
                    case _SOC_PARITY_INFO_TYPE_SINGLE_ECC:
                    case _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER:
                    case _SOC_PARITY_INFO_TYPE_DUAL_PARITY:
                    reg = info[table].control_reg;
                    if (!SOC_REG_IS_VALID(unit, reg)) {
                        return SOC_E_NONE;
                    }
                    SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, reg, block_port,
                                    info[table].enable_field,
                                    enable ? 1 : 0));
                    break;
                    default:
                    enable_field = INVALIDf;
                    break;
                } /* handle different parity error reporting style */
            } /* loop through each table in the group */
            cpi_blk_bit <<= 1;
        }
    } /* loop through each group */

    /* MMU controls */
    if (enable) {
        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &misc_cfg));
        soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg,
                PARITY_STAT_CLEARf, 1);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, misc_cfg));

        soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg, PARITY_CHK_ENf, 1);
        soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg, PARITY_GEN_ENf, 1);
        soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg,
                PARITY_STAT_CLEARf, 0);
        soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg, METERING_CLK_ENf, 1);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, misc_cfg));
    } else {
        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &misc_cfg));
        soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg, PARITY_CHK_ENf, 0);
        soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg, PARITY_GEN_ENf, 0);
        soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg, METERING_CLK_ENf, 0);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, misc_cfg));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_triumph2_process_single_parity_error(int unit, int group,
        soc_port_t block_port, int table,
        int schan, char *msg, soc_block_t blk)
{
    _soc_parity_info_t *info;
    soc_reg_t status_reg;
    uint32 addr, reg_val;
    int index, multiple, error;
    _soc_ser_correct_info_t spci = {0};

    info = _soc_tr2_parity_group_info[group].info;

    status_reg = schan ? info[table].nack_status0_reg :
    info[table].intr_status0_reg;
    if (status_reg == INVALIDr) {
        return SOC_E_INTERNAL;
    }
    addr = soc_reg_addr(unit, status_reg, block_port, 0);
    SOC_IF_ERROR_RETURN(soc_reg32_read(unit, addr, &reg_val));
    index = soc_reg_field_get(unit, status_reg, reg_val, ENTRY_IDXf);
    multiple = soc_reg_field_get(unit, status_reg, reg_val, MULTIPLE_ERRf);
    error = soc_reg_field_get(unit, status_reg, reg_val, PARITY_ERRf);

    if (error) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d %s entry %d parity error\n"),
                   unit, msg, index));
        if (multiple) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d %s has multiple parity errors\n"),
                       unit, msg));
        }
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d %s: parity hardware inconsistency\n"),
                   unit, msg));
    }
    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
            _SOC_PARITY_INFO_TYPE_SINGLE_PARITY, info[table].mem,
            info[table].error_field);

    if (info[table].mem != INVALIDm) {
        spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
        spci.reg = INVALIDr;
        spci.mem = info[table].mem;
        spci.blk_type = blk;
        spci.index = index;
        (void)soc_ser_correction(unit, &spci);
    }

    /* Clear parity status */
    SOC_IF_ERROR_RETURN(soc_reg32_write(unit, addr, 0));
    return SOC_E_NONE;
}

STATIC int
_soc_triumph2_process_single_ecc_error(int unit, int group,
        soc_port_t block_port, int table,
        int schan, char *msg, soc_block_t blk)
{
    _soc_parity_info_t *info;
    soc_reg_t status_reg;
    uint32 addr, reg_val;
    int index, double_bit, multiple, error;
    _soc_ser_correct_info_t spci = {0};

    info = _soc_tr2_parity_group_info[group].info;

    status_reg = schan ? info[table].nack_status0_reg :
    info[table].intr_status0_reg;
    if (status_reg == INVALIDr) {
        return SOC_E_INTERNAL;
    }
    addr = soc_reg_addr(unit, status_reg, block_port, 0);
    SOC_IF_ERROR_RETURN(soc_reg32_read(unit, addr, &reg_val));
    index = soc_reg_field_get(unit, status_reg, reg_val, ENTRY_IDXf);
    double_bit = soc_reg_field_get(unit, status_reg,
            reg_val, DOUBLE_BIT_ERRf);
    multiple = soc_reg_field_get(unit, status_reg, reg_val, MULTIPLE_ERRf);
    error = soc_reg_field_get(unit, status_reg, reg_val, ECC_ERRf);

    if (error) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d %s entry %d %s ECC error\n"),
                   unit, msg, index, double_bit ? "double-bit" : ""));
        if (multiple) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d %s has multiple ECC errors\n"),
                       unit, msg));
        }
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d %s: parity hardware inconsistency\n"),
                   unit, msg));
    }
    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
            _SOC_PARITY_INFO_TYPE_SINGLE_ECC, info[table].mem,
            info[table].error_field);

    if (info[table].mem != INVALIDm) {
        if (double_bit) {
            spci.double_bit = 1;
        }
        spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
        spci.reg = INVALIDr;
        spci.mem = info[table].mem;
        spci.blk_type = blk;
        spci.index = index;
        (void)soc_ser_correction(unit, &spci);
    }

    /* Clear parity status */
    SOC_IF_ERROR_RETURN(soc_reg32_write(unit, addr, 0));
    return SOC_E_NONE;
}

#define _SOC_TR2_ING_CTR_ERR_NUM    0x1C
char *_soc_triumph2_ingress_counter_error_map[_SOC_TR2_ING_CTR_ERR_NUM] = {
    "RIPD4", /* 0x00 */
    "RIPC4", /* 0x01 */
    "RIPHE4", /* 0x02 */
    "IMRP4", /* 0x03 */
    "RIPD6", /* 0x04 */
    "RIPC6", /* 0x05 */
    "RIPHE6", /* 0x06 */
    "IMRP6", /* 0x07 */
    "RDISC", /* 0x08 */
    "RUC", /* 0x09 */
    "RPORTD", /* 0x0A */
    "RDBGC0", /* 0x0B */
    "RDBGC1", /* 0x0C */
    "RDBGC2", /* 0x0D */
    "RDBGC3", /* 0x0E */
    "RDBGC4", /* 0x0F */
    NULL, /* 0x10, N/A */
    "IUNHGI", /* 0x11 */
    "ICTRL", /* 0x12 */
    "IBCAST", /* 0x13 */
    "ILTOMC", /* 0x14 */
    "IIPMC", /* 0x15 */
    "IUNKOPC", /* 0x16 */
    NULL, /* 0x17, N/A */
    "RDBGC5", /* 0x18 */
    "RDBGC6", /* 0x19 */
    "RDBGC7", /* 0x1A */
    "RDBGC8", /* 0x1B */
    /* num */ /*  0x1C */
};

#define _SOC_TR2_EGR_CTR_ERR_NUM    0xC
char *_soc_triumph2_egress_counter_error_map[_SOC_TR2_EGR_CTR_ERR_NUM] = {
    "TDBGC0", /* 0x00 */
    "TDBGC1", /* 0x01 */
    "TDBGC2", /* 0x02 */
    "TDBGC3", /* 0x03 */
    "TDBGC4", /* 0x04 */
    "TDBGC5", /* 0x05 */
    "TDBGC6", /* 0x06 */
    "TDBGC7", /* 0x07 */
    "TDBGC8", /* 0x08 */
    "TDBGC9", /* 0x09 */
    "TDBGC10", /* 0x0A */
    "TDBGC11", /* 0x0B */
    /* num */ /* 0x0C */
};

STATIC int
_soc_triumph2_process_single_counter_error(int unit, int group,
        soc_port_t block_port, int table,
        int schan, char *msg, soc_block_t blk)
{
    soc_cmap_t *cmap;
    _soc_parity_info_t *info;
    soc_reg_t status_reg, counter_reg;
    soc_port_t error_port;
    uint32 addr, reg_val;
    int counter_idx, multiple;
    char *ctr_str = NULL;
    _soc_ser_correct_info_t spci = {0};

    info = _soc_tr2_parity_group_info[group].info;

    status_reg = schan ? info[table].nack_status0_reg :
    info[table].intr_status0_reg;
    if (status_reg == INVALIDr) {
        return SOC_E_INTERNAL;
    }
    addr = soc_reg_addr(unit, status_reg, block_port, 0);
    SOC_IF_ERROR_RETURN(soc_reg32_read(unit, addr, &reg_val));
    error_port = soc_reg_field_get(unit, status_reg, reg_val, PORT_IDXf);
    counter_idx = soc_reg_field_get(unit, status_reg,
            reg_val, COUNTER_IDXf);
    multiple = soc_reg_field_get(unit, status_reg, reg_val, MULTIPLE_ERRf);

    if (soc_reg_field_get(unit, status_reg, reg_val, PARITY_ERRf)) {
        if (info[table].control_reg != EDATABUF_PARITY_CONTROLr) { /*ingress */
            if (counter_idx < _SOC_TR2_ING_CTR_ERR_NUM) {
                ctr_str =
                _soc_triumph2_ingress_counter_error_map[counter_idx];
            }
        } else { /* egress */
            if (counter_idx < _SOC_TR2_EGR_CTR_ERR_NUM) {
                ctr_str =
                _soc_triumph2_egress_counter_error_map[counter_idx];
            }
        }
        if (ctr_str != NULL) {
            cmap = soc_port_cmap_get(unit, error_port);
            counter_reg = cmap->cmap_base[counter_idx].reg;
            if (SOC_REG_IS_VALID(unit, counter_reg)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d %s port %d %s parity error\n"),
                           unit, msg, error_port, ctr_str));
                if (multiple) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "unit %d %s has multiple parity errors\n"),
                               unit, msg));
                }
                spci.flags = SOC_SER_SRC_REG | SOC_SER_REG_MEM_KNOWN;
                spci.reg = counter_reg;
                spci.mem = INVALIDm;
                spci.blk_type = blk;
                spci.port = error_port;
                (void)soc_ser_correction(unit, &spci);
                _stat_error_fixed[unit]++;
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d %s: parity hardware inconsistency\n"),
                           unit, msg));
            }
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d %s: parity hardware counter index invalid\n"),
                       unit, msg));
        }
    } else if (!schan) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d %s: parity hardware inconsistency\n"),
                   unit, msg));
    }
    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
            _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER, info[table].mem,
            info[table].error_field);

    /* Clear parity status */
    SOC_IF_ERROR_RETURN(soc_reg32_write(unit, addr, 0));
    return SOC_E_NONE;
}

STATIC int
_soc_triumph2_process_dual_parity_error(int unit, int group,
        soc_port_t block_port, int table,
        int schan, char *msg, soc_block_t blk)
{
    _soc_parity_info_t *info;
    soc_reg_t status_reg;
    uint32 addr, reg_val, bitmap;
    int index, bucket_index, multiple, ix, bits, size;
    _soc_ser_correct_info_t spci;

    info = _soc_tr2_parity_group_info[group].info;

    for (ix = 0; ix < 2; ix ++) {
        if (ix == 1) {
            status_reg = schan ? info[table].nack_status1_reg :
            info[table].intr_status1_reg;
        } else {
            status_reg = schan ? info[table].nack_status0_reg :
            info[table].intr_status0_reg;
        }

        if (status_reg == INVALIDr) {
            continue;
        }

        addr = soc_reg_addr(unit, status_reg, block_port, 0);
        SOC_IF_ERROR_RETURN(soc_reg32_read(unit, addr, &reg_val));
        bucket_index =
        soc_reg_field_get(unit, status_reg, reg_val, BUCKET_IDXf);
        multiple =
        soc_reg_field_get(unit, status_reg, reg_val, MULTIPLE_ERRf);
        bitmap =
        soc_reg_field_get(unit, status_reg, reg_val, PARITY_ERR_BMf);
        size = soc_reg_field_length(unit, status_reg, PARITY_ERR_BMf);

        if (bitmap != 0) {
            for (bits = 0; bits < size; bits++) {
                if (bitmap & (1 << bits)) {
                    index =
                    bucket_index * size * 2 + bits + (ix * size);
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "unit %d %s entry %d parity error\n"),
                               unit, msg, index));
                    sal_memset(&spci, 0, sizeof(spci));
                    spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
                    spci.reg = INVALIDr;
                    spci.mem = info[table].mem;
                    spci.blk_type = blk;
                    spci.index = index;
                    (void)soc_ser_correction(unit, &spci);
                }
            }

            if (multiple) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d %s has multiple parity errors\n"),
                           unit, msg));
            }

            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                    _SOC_PARITY_INFO_TYPE_DUAL_PARITY, info[table].mem,
                    info[table].error_field);
        }

        /* Clear parity status */
        SOC_IF_ERROR_RETURN(soc_reg32_write(unit, addr, 0));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_triumph2_process_mmu_parity_error(int unit, int group,
        soc_port_t block_port, int table,
        char *msg)
{
    _soc_parity_info_t *info;
    soc_reg_t status_reg, index_reg;
    uint32 addr, reg_val;
    int index;

    info = _soc_tr2_parity_group_info[group].info;

    status_reg = info[table].intr_status1_reg;
    index_reg = info[table].intr_status0_reg;
    if (index_reg == INVALIDr) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d %s parity error\n"),
                              unit, msg));
        return SOC_E_NONE;
    }
    if (status_reg != INVALIDr) {
        addr = soc_reg_addr(unit, status_reg, block_port, 0);
        SOC_IF_ERROR_RETURN(soc_reg32_read(unit, addr, &reg_val));
        if (reg_val == 0) {
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                    _SOC_PARITY_INFO_TYPE_MMU_PARITY,
                    info[table].mem, info[table].error_field);
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d %s: parity hardware inconsistency\n"),
                       unit, msg));
            return SOC_E_NONE;
        }
    }
    addr = soc_reg_addr(unit, index_reg, block_port, 0);
    SOC_IF_ERROR_RETURN(soc_reg32_read(unit, addr, &reg_val));
    index = reg_val;

    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
            _SOC_PARITY_INFO_TYPE_MMU_PARITY, info[table].mem,
            info[table].error_field);
    LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "unit %d %s entry %d parity error\n"),
               unit, msg, index));
    /* update soc stats for some cases */
    if (info[table].error_field == CCP_PAR_ERRf) {
        SOC_CONTROL(unit)->stat.err_cpcrc++;
    } else if (info[table].error_field == CFAP_PAR_ERRf) {
        SOC_CONTROL(unit)->stat.err_cfap++;
    }

    return SOC_E_NONE;
}

STATIC int
_soc_triumph2_process_parity_error(int unit)
{
    int group, table, index, size;
    uint32 addr, cmic_status, group_status, status,
    group_enable, cpi_blk_bit;
    uint32 entry_idx;
    _soc_parity_info_t *info;
    soc_reg_t group_reg, reg;
    soc_port_t block_port;
    soc_block_t blk;
    char *msg;
    soc_triumph2_oam_handler_t oam_handler_snapshot;

    SOC_IF_ERROR_RETURN(READ_CMIC_CHIP_PARITY_INTR_STATUSr(unit,
                    &cmic_status));

    /* loop through each group */
    for (group = 0; _soc_tr2_parity_group_info[group].cpi_bit; group++) {
        info = _soc_tr2_parity_group_info[group].info;
        group_reg = _soc_tr2_parity_group_info[group].status_reg;
        cpi_blk_bit = _soc_tr2_parity_group_info[group].cpi_bit;

        SOC_BLOCK_ITER(unit, blk,
                _soc_tr2_parity_group_info[group].blocktype) {
            if (_soc_triumph_parity_block_port(unit, blk, &block_port) < 0) {
                cpi_blk_bit <<= 1;
                continue;
            }
            if (!(cmic_status & cpi_blk_bit)) {
                cpi_blk_bit <<= 1;
                continue;
            }

            addr = soc_reg_addr(unit, group_reg, block_port, 0);
            SOC_IF_ERROR_RETURN(soc_reg32_read(unit, addr, &group_status));

            /* loop through each table in the group */
            for (table = 0; info[table].error_field != INVALIDf; table++) {
                if (!soc_reg_field_valid(unit, group_reg,
                                info[table].error_field) &&
                        (info[table].mem != INVALIDm)) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "unit %d %s has bad error field\n"),
                                          unit, SOC_MEM_NAME(unit, info[table].mem)));
                    continue;
                }

                if (!soc_reg_field_get(unit, group_reg, group_status,
                                info[table].error_field)) {
                    continue;
                }
                if (info[table].msg) {
                    msg = info[table].msg;
                } else if (info[table].mem != INVALIDm) {
                    msg = SOC_MEM_NAME(unit, info[table].mem);
                } else {
                    msg = SOC_FIELD_NAME(unit, info[table].error_field);
                }

                /* handle different parity error reporting style */
                switch (info[table].type) {
                    case _SOC_PARITY_INFO_TYPE_GENERIC:
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                            _SOC_PARITY_INFO_TYPE_GENERIC,
                            info[table].mem,
                            info[table].error_field);

                    if (info[table].enable_field == START_BY_START_ERR_ENf) {
                        uint64 rr64;
                        uint32 msw;
                        uint32 lsw;
                        uint32 regval;

                        /* Clear the start-by-start port bitmap */
                        SOC_IF_ERROR_RETURN
                        (READ_START_BY_START_ERROR_64r(unit, &rr64));
                        COMPILER_64_TO_32_HI(msw, rr64);
                        COMPILER_64_TO_32_LO(lsw, rr64);
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d START_BY_START_ERRROR = 0x%x%08x\n"),
                                   unit, msw, lsw));
                        COMPILER_64_ZERO(rr64);
                        SOC_IF_ERROR_RETURN
                        (WRITE_START_BY_START_ERROR_64r(unit, rr64));

                        /* Clear the start-by-start error indication*/
                        SOC_IF_ERROR_RETURN(READ_MEM_FAIL_INT_STATr(unit, &regval));
                        soc_reg_field_set(unit, MEM_FAIL_INT_STATr, &regval,
                                          START_BY_START_ERRf, 0);
                        SOC_IF_ERROR_RETURN(WRITE_MEM_FAIL_INT_STATr(unit, regval));
                    }

                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "unit %d %s asserted\n"),
                                          unit, msg));
                    break;
                    case _SOC_PARITY_INFO_TYPE_SINGLE_PARITY:
                    SOC_IF_ERROR_RETURN
                    (_soc_triumph2_process_single_parity_error(unit,
                                    group, block_port, table, FALSE, msg, -1));
                    break;
                    case _SOC_PARITY_INFO_TYPE_SINGLE_ECC:
                    SOC_IF_ERROR_RETURN
                    (_soc_triumph2_process_single_ecc_error(unit,
                                    group, block_port, table, FALSE, msg, -1));
                    break;
                    case _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER:
                    SOC_IF_ERROR_RETURN
                    (_soc_triumph2_process_single_counter_error(unit,
                                    group, block_port, table, FALSE, msg, -1));
                    break;
                    case _SOC_PARITY_INFO_TYPE_DUAL_PARITY:
                    SOC_IF_ERROR_RETURN
                    (_soc_triumph2_process_dual_parity_error(unit,
                                    group, block_port, table, FALSE, msg, -1));
                    break;
                    case _SOC_PARITY_INFO_TYPE_MMU_PARITY:
                    SOC_IF_ERROR_RETURN
                    (_soc_triumph2_process_mmu_parity_error(unit,
                                    group, block_port, table, msg));
                    break;
                    case _SOC_PARITY_INFO_TYPE_MMUIPMC:
                    /*
                     * status0 (MEM1_IPMCGRP_TBL_PARITYERRORPTRr) is index
                     * status1 (MEM1_IPMCGRP_TBL_PARITYERROR_STATUSr) is table id
                     *         MMU_IPMC_GROUP_TBL0m - MMU_IPMC_GROUP_TBL8m
                     */
                    reg = info[table].intr_status1_reg;
                    addr = soc_reg_addr(unit, reg, block_port, 0);
                    SOC_IF_ERROR_RETURN(soc_reg32_read(unit, addr, &status));
                    size = soc_reg_field_length(unit, reg, STATUSf);
                    reg = info[table].intr_status0_reg;
                    for (index = 0; index < size; index++, status >>= 1) {
                        if (!(status & 1)) {
                            continue;
                        }
                        addr = soc_reg_addr(unit, reg, block_port, index);
                        SOC_IF_ERROR_RETURN(soc_reg32_read(unit, addr,
                                        &entry_idx));
                        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                                _SOC_PARITY_INFO_TYPE_MMUIPMC,
                                info[table].mem,
                                info[table].error_field);

                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d %s%d entry %d parity error\n"),
                                   unit, msg, index, entry_idx));
                    }
                    break;
                    case _SOC_PARITY_INFO_TYPE_MMUWRED:
                    /*
                     * status0 (WRED_PARITY_ERROR_INFOr) is index
                     * status1 (WRED_PARITY_ERROR_BITMAPr) is table id
                     */
                    reg = info[table].intr_status0_reg;
                    addr = soc_reg_addr(unit, reg, block_port, 0);
                    SOC_IF_ERROR_RETURN(soc_reg32_read(unit, addr,
                                    &entry_idx));
                    reg = info[table].intr_status1_reg;
                    addr = soc_reg_addr(unit, reg, block_port, 0);
                    SOC_IF_ERROR_RETURN(soc_reg32_read(unit, addr, &status));
                    if (status & 0x000003) {
                        msg = "WRED_CFG_CELL";
                    } else if (status & 0x00000c) {
                        msg = "WRED_THD_0_CELL";
                    } else if (status & 0x000030) {
                        msg = "WRED_THD_1_CELL";
                    } else if (status & 0x0000c0) {
                        msg = "WRED_CFG_PACKET";
                    } else if (status & 0x000300) {
                        msg = "WRED_THD_0_PACKET";
                    } else if (status & 0x000c00) {
                        msg = "WRED_THD_1_PACKET";
                    } else if (status & 0x003000) {
                        msg = "WRED_PORT_CFG_CELL";
                    } else if (status & 0x00c000) {
                        msg = "WRED_PORT_THD_0_CELL";
                    } else if (status & 0x030000) {
                        msg = "WRED_PORT_THD_1_CELL";
                    } else if (status & 0x0c0000) {
                        msg = "WRED_PORT_CFG_PACKET";
                    } else if (status & 0x300000) {
                        msg = "WRED_PORT_THD_0_PACKET";
                    } else if (status & 0xc00000) {
                        msg = "WRED_PORT_THD_1_PACKET";
                    } else {
                        break;
                    }
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                            _SOC_PARITY_INFO_TYPE_MMUWRED,
                            info[table].mem, info[table].error_field);
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "unit %d %s entry %d parity error\n"),
                               unit, msg, entry_idx));
                    break;
                    case _SOC_PARITY_INFO_TYPE_OAM:
                    /* OAM isn't parity-related but shares an interrupt */

                    oam_handler_snapshot = oam_handler[unit];

                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                            _SOC_PARITY_INFO_TYPE_OAM,
                            info[table].mem, info[table].error_field);

                    if (oam_handler_snapshot != NULL)
                    {
                        SOC_IF_ERROR_RETURN(oam_handler_snapshot(unit,
                                        info[table].error_field));
                    }

                    break;
                    default:
                    break;
                } /* handle different parity error reporting style */
            } /* loop through each table in the group */

            reg = _soc_tr2_parity_group_info[group].enable_reg;
            addr = soc_reg_addr(unit, reg, block_port, 0);
            SOC_IF_ERROR_RETURN(soc_reg32_read(unit, addr, &group_enable));
            group_enable &= ~group_status;
            SOC_IF_ERROR_RETURN(soc_reg32_write(unit, addr, group_enable));
            group_enable |= group_status;
            SOC_IF_ERROR_RETURN(soc_reg32_write(unit, addr, group_enable));
        } /* loop through each block for the group */
    } /* loop through each group */

    return SOC_E_NONE;
}

void
soc_triumph2_parity_error(void *unit_vp, void *d1, void *d2,
        void *d3, void *d4)
{
    int unit = PTR_TO_INT(unit_vp);

    _soc_triumph2_process_parity_error(unit);
    sal_usleep(1000); /* Don't reenable too soon */
    soc_intr_enable(unit, IRQ_MEM_FAIL);
}

STATIC int
_soc_triumph2_mem_nack_error_process(int unit, _ser_nack_reg_mem_t nack_reg_mem, int block)
{
    int group, table;
    _soc_parity_info_t *info;
    soc_port_t block_port;
    soc_block_t blk;
    char *msg;

    if ((nack_reg_mem.mem == INVALIDm) && (nack_reg_mem.reg_mem == _SOC_SER_MEM)) {
        return SOC_E_PARAM;
    }

    /* loop through each group */
    for (group = 0; _soc_tr2_parity_group_info[group].cpi_bit; group++) {
        info = _soc_tr2_parity_group_info[group].info;

        SOC_BLOCK_ITER(unit, blk,
                _soc_tr2_parity_group_info[group].blocktype) {
            if (block != SOC_BLOCK_INFO(unit, blk).schan) {
                continue;
            }
            if (_soc_triumph_parity_block_port(unit, blk, &block_port) < 0) {
                continue;
            }
            /* loop through each table in the group */
            for (table = 0; info[table].error_field != INVALIDf; table++) {
                if ((info[table].type != _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER) && 
                    (nack_reg_mem.reg_mem == _SOC_SER_REG)) {
                    continue;
                }
                if ((info[table].mem != nack_reg_mem.mem) && (nack_reg_mem.reg_mem == _SOC_SER_MEM)) {
                    continue;
                }
                if (info[table].nack_status0_reg == INVALIDr) {
                    return SOC_E_NOT_FOUND;
                }
                if (info[table].msg) {
                    msg = info[table].msg;
                } else { /* mem must be valid to get her */
                    msg = SOC_MEM_NAME(unit, info[table].mem);
                }

                /* handle different parity error reporting style */
                switch (info[table].type) {
                    case _SOC_PARITY_INFO_TYPE_SINGLE_PARITY:
                    SOC_IF_ERROR_RETURN
                    (_soc_triumph2_process_single_parity_error(unit,
                                    group, block_port, table, TRUE, msg, blk));
                    break;
                    case _SOC_PARITY_INFO_TYPE_SINGLE_ECC:
                    SOC_IF_ERROR_RETURN
                    (_soc_triumph2_process_single_ecc_error(unit,
                                    group, block_port, table, TRUE, msg, blk));
                    break;
                    case _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER:
                    SOC_IF_ERROR_RETURN
                    (_soc_triumph2_process_single_counter_error(unit,
                                    group, block_port, table, TRUE, msg, blk));
                    break;
                    case _SOC_PARITY_INFO_TYPE_DUAL_PARITY:
                    SOC_IF_ERROR_RETURN
                    (_soc_triumph2_process_dual_parity_error(unit,
                                    group, block_port, table, TRUE, msg, blk));
                    break;
                    default:
                    break;
                } /* handle different parity error reporting style */
            } /* loop through each table in the group */
        } /* loop through each block of the group */
    } /* loop through each group */

    return SOC_E_NONE;
}

void
soc_triumph2_stat_nack(int unit, int *fixed)
{
    int rv;
    _ser_nack_reg_mem_t nack_reg_mem;

    nack_reg_mem.reg_mem = _SOC_SER_REG;
    nack_reg_mem.mem = INVALIDm;
    nack_reg_mem.reg = INVALIDr;
    _stat_error_fixed[unit] = 0;

    if ((rv = _soc_triumph2_mem_nack_error_process(unit, nack_reg_mem, 0)) < 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d STAT SCHAN NACK analysis failure.\n"), unit));
    }
    *fixed = _stat_error_fixed[unit];
}

void
soc_triumph2_mem_nack(void *unit_vp, void *addr_vp, void *blk_vp,
        void *d3, void *d4)
{
    int rv, unit = PTR_TO_INT(unit_vp);
    uint32 address = PTR_TO_INT(addr_vp);
    uint32 block = PTR_TO_INT(blk_vp);
    uint32 offset = 0, min_addr = 0, max_addr = 0;
    _ser_nack_reg_mem_t nack_reg_mem;
    soc_regaddrinfo_t ainfo;

    nack_reg_mem.reg_mem = PTR_TO_INT(d3);
    nack_reg_mem.mem = INVALIDm;
    nack_reg_mem.reg = INVALIDr;

    if (nack_reg_mem.reg_mem == _SOC_SER_REG) {
        if (address) {
            soc_regaddrinfo_get(unit, &ainfo, address);
            nack_reg_mem.reg = ainfo.reg;
        }
    } else {
        offset = address & ~0xC0f00000; /* Strip block ID */

        nack_reg_mem.mem = soc_addr_to_mem(unit, address, &block);
        if (nack_reg_mem.mem == INVALIDm) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d mem decode failed "
                                  "SCHAN NACK analysis failure\n"), unit));
            return;
        }
        min_addr = max_addr = SOC_MEM_INFO(unit, nack_reg_mem.mem).base;
        min_addr += SOC_MEM_INFO(unit, nack_reg_mem.mem).index_min;
        max_addr += SOC_MEM_INFO(unit, nack_reg_mem.mem).index_max;

        /* Convert component/aggregate memories to the table for which
         * the parity registers correspond. */
        switch(nack_reg_mem.mem) {
        case VLAN_SUBNETm:
            nack_reg_mem.mem = VLAN_SUBNET_DATA_ONLYm; /* Should be VLAN_SUBNET? */
        break;
        case L2_ENTRY_ONLYm:
            nack_reg_mem.mem = L2Xm;
            break;
        case L2_USER_ENTRY_ONLYm:
        case L2_USER_ENTRY_DATA_ONLYm:
            nack_reg_mem.mem = L2_USER_ENTRYm;
            break;
        case L3_DEFIPm:
            nack_reg_mem.mem = L3_DEFIP_DATA_ONLYm;
            break;
        case L3_DEFIP_128m:
            nack_reg_mem.mem = L3_DEFIP_128_DATA_ONLYm;
            break;
        case EGR_IP_TUNNEL_IPV6m:
        case EGR_IP_TUNNEL_MPLSm:
            nack_reg_mem.mem = EGR_IP_TUNNELm;
            break;
        case L3_ENTRY_IPV4_UNICASTm:
        case L3_ENTRY_IPV4_MULTICASTm:
        case L3_ENTRY_IPV6_MULTICASTm:
        case L3_ENTRY_IPV6_UNICASTm:
            nack_reg_mem.mem = L3_ENTRY_ONLYm;
            break;
        default:
            /* Do nothing, keep memory as provided */
            break;
        }
    }


    if ((rv = _soc_triumph2_mem_nack_error_process(unit, nack_reg_mem, block)) < 0) {
        if (nack_reg_mem.reg_mem == _SOC_SER_REG) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d REG SCHAN NACK analysis failure\n"),
                       unit));
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d %s entry %d SCHAN NACK analysis failure\n"),
                       unit, SOC_MEM_NAME(unit, nack_reg_mem.mem),
                       min_addr - offset));
        }
    }
}

STATIC int
_soc_triumph2_mem_ecc_force(int unit, soc_port_t block_port,
        _soc_parity_info_t *info)
{
    soc_reg_t force_sbe_reg, force_dbe_reg;
    soc_field_t force_field;

    force_field = info->error_field;
    if (force_field == RX_FIFO_MEM_ERRf) {
        force_field = RX_FIFO_MEMf;
    } else if (force_field == TX_FIFO_MEM_ERRf) {
        force_field = TX_FIFO_MEMf;
    }

    force_sbe_reg = info->intr_status1_reg;
    force_dbe_reg = info->nack_status1_reg;

    /* Single-bit error force */
    if (SOC_REG_IS_VALID(unit, force_sbe_reg) &&
            soc_reg_field_valid(unit, force_sbe_reg, force_field)) {
        SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, force_sbe_reg,
                        block_port, force_field, 1));
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d %s.%s not valid\n"),
                   unit,
                   SOC_REG_IS_VALID(unit, force_sbe_reg) ?
                   SOC_REG_NAME(unit, force_sbe_reg) : "Unknown",
                   soc_reg_field_valid(unit, force_sbe_reg, force_field) ?
                   SOC_FIELD_NAME(unit, force_field) : "Unknown"));
    }

    sal_usleep(1000); /* Wait for interrupt-mode logic to kick in */

    /* Double-bit error force */
    if (SOC_REG_IS_VALID(unit, force_dbe_reg) &&
            soc_reg_field_valid(unit, force_dbe_reg, force_field)) {
        SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, force_dbe_reg,
                        block_port, force_field, 1));
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d %s.%s not valid\n"),
                   unit, SOC_REG_NAME(unit, force_dbe_reg),
                   SOC_FIELD_NAME(unit, force_field)));
    }

    return SOC_E_NONE;
}

int
_soc_triumph2_mem_nack_error_test(int unit, _soc_ser_test_t test_type, int *testErrors)
{
    int group, table, rv;
    _soc_parity_info_t *info;
    soc_mem_t mem;
    soc_port_t block_port;
    soc_block_t blk;
    uint32 testCount = 0;

    /* loop through each group */
    for (group = 0; _soc_tr2_parity_group_info[group].cpi_bit; group++) {
        info = _soc_tr2_parity_group_info[group].info;

        SOC_BLOCK_ITER(unit, blk,
                _soc_tr2_parity_group_info[group].blocktype) {
            if (_soc_triumph_parity_block_port(unit, blk, &block_port) < 0) {
                continue;
            }

            for (table = 0; info[table].error_field != INVALIDf; table++) {
                mem = info[table].mem;
                if (mem == INVALIDm) {
                    continue;
                }
                if ((info[table].control_reg == INVALIDr) ||
                        !soc_reg_field_valid(unit, info[table].control_reg,
                                info[table].enable_field)) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "unit %d %s has no parity toggle\n"),
                               unit, SOC_MEM_NAME(unit, mem)));
                    continue;
                }
                switch (info[table].type) {
                    case _SOC_PARITY_INFO_TYPE_SINGLE_PARITY:
                    case _SOC_PARITY_INFO_TYPE_SINGLE_COUNTER:
                    case _SOC_PARITY_INFO_TYPE_DUAL_PARITY:
                    break;
                    case _SOC_PARITY_INFO_TYPE_SINGLE_ECC:
                    if (block_port != REG_PORT_ANY) {
                        /* Force registers exist */
                        SOC_IF_ERROR_RETURN
                        (_soc_triumph2_mem_ecc_force(unit, block_port,
                                        &(info[table])));
                    }
                    break;
                    default:
                    /* No field to check. */
                    continue;
                }
                testCount++;
                rv = ser_test_mem_pipe(unit,info[table].control_reg, -1,
                                  info[table].enable_field, mem, INVALIDf,
                                  test_type, blk, block_port,
                                  _SOC_ACC_TYPE_PIPE_ANY, testErrors);
                if (rv != SOC_E_NONE) {
                    LOG_CLI((BSL_META_U(unit,
                                        "Error during TCAM test.\n")));
                    continue;
                }
            }
        }
    }
    LOG_CLI((BSL_META_U(unit,
                        "Hardware SER memories tested: %u\n"),testCount));
    return SOC_E_NONE;
}

/* SER processing for TCAMs */
STATIC _soc_ser_parity_info_t _soc_tr2_ser_parity_info[] = {
    { EFP_TCAMm, _SOC_SER_PARITY_MODE_2BITS,
      CMIC_SER_START_ADDR_0r, CMIC_SER_END_ADDR_0r,
      CMIC_SER_MEM_ADDR_0r, CMIC_SER_PARITY_MODE_SELr,
      RANGE_0_PARITY_BITSf, -1, INVALIDr, 0, 0, 0, 0},
    { EGR_ERSPANm, _SOC_SER_PARITY_MODE_2BITS,
      CMIC_SER_START_ADDR_1r, CMIC_SER_END_ADDR_1r,
      CMIC_SER_MEM_ADDR_1r, CMIC_SER_PARITY_MODE_SELr,
      RANGE_1_PARITY_BITSf, -1, INVALIDr, 0, 0, 0, 0},
    { FP_SLICE_MAPm, _SOC_SER_PARITY_MODE_2BITS,
      CMIC_SER_START_ADDR_2r, CMIC_SER_END_ADDR_2r,
      CMIC_SER_MEM_ADDR_2r, CMIC_SER_PARITY_MODE_SELr,
      RANGE_2_PARITY_BITSf, -1, INVALIDr, 0, 0, 0, 0},
    { FP_TCAMm, _SOC_SER_PARITY_MODE_2BITS,
      CMIC_SER_START_ADDR_3r, CMIC_SER_END_ADDR_3r,
      CMIC_SER_MEM_ADDR_3r, CMIC_SER_PARITY_MODE_SELr,
      RANGE_3_PARITY_BITSf, -1, INVALIDr, 0, 0, 0, 0},
    { ING_IPFIX_PROFILEm, _SOC_SER_PARITY_MODE_2BITS,
      CMIC_SER_START_ADDR_4r, CMIC_SER_END_ADDR_4r,
      CMIC_SER_MEM_ADDR_4r, CMIC_SER_PARITY_MODE_SELr,
      RANGE_4_PARITY_BITSf, -1, INVALIDr, 0, 0, 0, 0},
    { MPLS_STATION_TCAMm, _SOC_SER_PARITY_MODE_2BITS,
      CMIC_SER_START_ADDR_5r, CMIC_SER_END_ADDR_5r,
      CMIC_SER_MEM_ADDR_5r, CMIC_SER_PARITY_MODE_SELr,
      RANGE_5_PARITY_BITSf, -1, INVALIDr, 0, 0, 0, 0},
    { VFP_TCAMm, _SOC_SER_PARITY_MODE_2BITS,
      CMIC_SER_START_ADDR_6r, CMIC_SER_END_ADDR_6r,
      CMIC_SER_MEM_ADDR_6r, CMIC_SER_PARITY_MODE_SELr,
      RANGE_6_PARITY_BITSf, -1, INVALIDr, 0, 0, 0, 0},
    
    { INVALIDm, _SOC_SER_PARITY_MODE_NUM},
};

#define SOC_TR2_SER_MEM_AVAILABLE       (2048 * 32)  /* bits */

STATIC int
_soc_triumph2_ser_init(int unit)
{
    return soc_ser_init(unit, _soc_tr2_ser_parity_info,
            SOC_TR2_SER_MEM_AVAILABLE);
}

int
soc_triumph2_ser_mem_clear(int unit, soc_mem_t mem)
{
    return soc_ser_mem_clear(unit, _soc_tr2_ser_parity_info, mem);
}

void
soc_triumph2_ser_fail(int unit)

{
    soc_process_ser_parity_error(unit, _soc_tr2_ser_parity_info,
            _SOC_PARITY_INFO_TYPE_SER);
    return;
}

typedef struct _soc_esm_intr_reg_info_s {
    soc_field_t error_field;
    char *msg;
    soc_reg_t detail_reg[3];
}_soc_esm_intr_reg_info_t;

STATIC _soc_esm_intr_reg_info_t _soc_tr2_etu_intr_reg_info[] = {
    {   ILL_SRAM_ACCf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   SBUS_REQACK_ERRf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   BKGND_PROC_SECf, NULL,
        {   ETU_BKGND_PROC_SEC_INFOr, INVALIDr, INVALIDr}},
    {   BKGND_PROC_ERRf, NULL,
        {   ETU_BKGND_PROC_ERR_INFOr, INVALIDr, INVALIDr}},
    {   SBUS_CMD_SECf, NULL, {ETU_SBUS_CMD_SEC_INFOr, INVALIDr, INVALIDr}},
    {   SBUS_CMD_ERRf, NULL,
        {   ETU_SBUS_CMD_ERR_INFO1r, ETU_SBUS_CMD_ERR_INFO2r, INVALIDr}},
    {   ET_DPEO_PERRf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   ET_S1_MWS_ERRf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   ET_S0_MWS_ERRf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   ET_S1_NORV_ERRf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   ET_S0_NORV_ERRf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   ET_S1_RBUS_PERRf, NULL, {ETU_S1_RBUS_PERR_INFOr, INVALIDr, INVALIDr}},
    {   ET_S0_RBUS_PERRf, NULL, {ETU_S0_RBUS_PERR_INFOr, INVALIDr, INVALIDr}},
    /* PPA_COMPLETEf */
    /* ET_INST_REQ_COMPLETEf */
    /* MRST_COMPLETEf */
    {   CIF_LOST2_HITHRf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_LUREQFIFO */
    {   LUREQFIFOCOUNT_GTE_HITHRf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_LUREQFIFO */
    {   ADREQ1FIFO_OVERFLOWf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_ADREQ1FIFO */
    {   ADREQ1FIFO_FULLf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_ADREQ1FIFO */
    {   ADREQ0FIFO_OVERFLOWf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_ADREQ0FIFO */
    {   ADREQ0FIFO_FULLf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_ADREQ0FIFO */
    {   L2MODFIFO_OVERFLOWf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   L2MODFIFO_UNDERRUNf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   L2MODFIFO_NOTEMPTYf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   EXT_TCAM_SE_O_L_PINf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   INVALIDf} /* table terminator */
};

STATIC _soc_esm_intr_reg_info_t _soc_tr2_es01_intr_reg_info[] = {
    {   CIF_LOST2_HITHR1f, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_ADREQ1FIFO */
    {   ADREQ1FIFOCOUNT_GTE_HITHRf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_ADREQ1FIFO */
    {   CIF_LOST2_HITHR0f, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_ADREQ0FIFO */
    {   ADREQ0FIFOCOUNT_GTE_HITHRf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_ADREQ0FIFO */
    {   ADL3DST_SECf, NULL, {ES01_ADL3DST_SEC_INFOr, INVALIDr, INVALIDr}},
    {   ADL3DST_DEDf, NULL, {ES01_ADL3DST_DED_INFOr, INVALIDr, INVALIDr}},
    {   ADL3SRC_SECf, NULL, {ES01_ADL3SRC_SEC_INFOr, INVALIDr, INVALIDr}},
    {   ADL3SRC_DEDf, NULL, {ES01_ADL3SRC_DED_INFOr, INVALIDr, INVALIDr}},
    {   ADL2DST_SECf, NULL, {ES01_ADL2DST_SEC_INFOr, INVALIDr, INVALIDr}},
    {   ADL2DST_DEDf, NULL, {ES01_ADL2DST_DED_INFOr, INVALIDr, INVALIDr}},
    {   ADL2SRC_SECf, NULL, {ES01_ADL2SRC_SEC_INFOr, INVALIDr, INVALIDr}},
    {   ADL2SRC_DEDf, NULL, {ES01_ADL2SRC_DED_INFOr, INVALIDr, INVALIDr}},
    {   L2L3RSPFIFO_OVERFLOWf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_L2L3RSPFIFO */
    {   L2L3RSPFIFO_FULLf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_L2L3RSPFIFO */
    {   FP0RSPFIFO_OVERFLOWf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_FP0RSPFIFO */
    {   FP0RSPFIFO_FULLf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_FP0RSPFIFO */
    {   FP1RSPFIFO_OVERFLOWf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_FP1RSPFIFO */
    {   FP1RSPFIFO_FULLf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_FP1RSPFIFO */
    {   PKT_CNT_WRAPf, NULL, {ES01_PKT_CNT_WRAP_INFOr, INVALIDr, INVALIDr}},
    {   BYT_CNT_WRAPf, NULL, {ES01_BYT_CNT_WRAP_INFOr, INVALIDr, INVALIDr}},
    {   ADFPCNTR_SECf, NULL, {ES01_ADFPCNTR_SEC_INFOr, INVALIDr, INVALIDr}},
    {   ADFPCNTR_DEDf, NULL, {ES01_ADFPCNTR_DED_INFOr, INVALIDr, INVALIDr}},
    {   INVALIDf} /* table terminator */
};

STATIC _soc_esm_intr_reg_info_t _soc_tr2_iesmif_intr_reg_info[] = {
    {   AGE_IPFIX_ERRf, NULL, {IPFIX_AGE_CONTROLr, INVALIDr, INVALIDr}},
    {   FP_REFRESH_ERRf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   BK2BK_ESM_ELIGIBLEf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   ESU_ASF_HI_ACCUMf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_L2L3RSPFIFO, chk_FP0RSPFIFO, chk_FP1RSPFIFO */
    {   LUREQFIFO_FULLf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_LUREQFIFO */
    {   ECB_HI_ACCUMf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_ECBFIFO */
    {   ECB_FULLf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_ECBFIFO */
    {   DROPPED_CELLf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   CNP_ES_COUNT_WRAPf, NULL, {IESMIF_STATUS7r, INVALIDr, INVALIDr}},
    {   CNP_EXT_SEARCHf, NULL, {IESMIF_STATUS7r, INVALIDr, INVALIDr}},
    {   NEW_MAX_LATENCYf, NULL, {IESMIF_STATUS3r, INVALIDr, INVALIDr}},
    {   ECB_SEC_COUNT_WRAPf, NULL, {IESMIF_STATUS5r, INVALIDr, INVALIDr}},
    {   ECB_SEC_ERRf, NULL,
        {   IESMIF_STATUS5r, IESMIF_ECB_ECC_STATUS_SBEr,
            IESMIF_ECB_SBE_SYNDROME12r}},
    {   ECB_DED_COUNT_WRAPf, NULL, {IESMIF_STATUS6r, INVALIDr, INVALIDr}},
    {   ECB_DED_ERRf, NULL,
        {   IESMIF_STATUS6r, IESMIF_ECB_ECC_STATUS_DBEr, INVALIDr}},
    {   INVALIDf} /* table terminator */
};

STATIC _soc_esm_intr_reg_info_t _soc_tr2_erb_intr_reg_info[] = {
    {   EXT_LU_ERRf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   IPCF_PTR_MISMATCHf, NULL,
        {   ERB_IPCF_PTR_MISMATCH_INFOr, INVALIDr, INVALIDr}},
    {   ERB_OVERFLOWf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_ERBFIFO */
    {   ERB_FULLf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_ERBFIFO */
    {   ERB_UNDERRUNf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_ERBFIFO */
    {   INVALIDf} /* table terminator */
};

STATIC _soc_esm_intr_reg_info_t _soc_tr2_es01c_intr_reg_info[] = {
    {   EXTFP_POLICY_SECf, NULL,
        {   ES01C_EXTFP_POLICY_SEC_INFOr, INVALIDr, INVALIDr}},
    {   EXTFP_POLICY_DEDf, NULL,
        {   ES01C_EXTFP_POLICY_DED_INFOr, INVALIDr, INVALIDr}},
    {   FPCREQFIFO_BK2BK_WRf, NULL, {INVALIDr, INVALIDr, INVALIDr}},
    {   FPCREQFIFO_OVERFLOWf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /*chk_FPCREQFIFO */
    {   FPCREQFIFO_FULLf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /*chk_FPCREQFIFO */
    {   FP1RSPFIFOCOUNT_GTE_HITHRf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_FP1RSPFIFO */
    {   FP0RSPFIFOCOUNT_GTE_HITHRf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_FP0RSPFIFO */
    {   L2L3RSPFIFOCOUNT_GTE_HITHRf, NULL, {INVALIDr, INVALIDr, INVALIDr}}, /* chk_L2L3RSPFIFO */
    {   INVALIDf} /* table terminator */
};

STATIC struct {
    soc_reg_t enable_reg;
    soc_reg_t clear_reg;
    soc_reg_t status_reg;
    _soc_esm_intr_reg_info_t *reg_info;
}_soc_tr2_esm_intr_info[] = {
    {   ETU_INTR_ENABLEr, ETU_INTR_CLEARr, ETU_INTR_STATUSr,
        _soc_tr2_etu_intr_reg_info},
    {   ES01_INTR_ENABLEr, ES01_INTR_CLEARr, ES01_INTR_STATUSr,
        _soc_tr2_es01_intr_reg_info},
    {   IESMIF_INTR_ENABLEr, IESMIF_INTR_CLEARr, IESMIF_INTR_STATUSr,
        _soc_tr2_iesmif_intr_reg_info},
    {   ERB_INTR_ENABLEr, ERB_INTR_CLEARr, ERB_INTR_STATUSr,
        _soc_tr2_erb_intr_reg_info},
    {   ES01C_INTR_ENABLEr, ES01C_INTR_CLEARr, ES01C_INTR_STATUSr,
        _soc_tr2_es01c_intr_reg_info},
    {   INVALIDr, INVALIDr, INVALIDr} /* table terminator */
};

STATIC int
_soc_triumph2_esm_intr_enable(int unit, int enable)
{
    int reg_index;
    uint32 addr, rval;
    soc_reg_t reg;
    _soc_esm_intr_reg_info_t *intr_reg_info;

    if (SOC_CONTROL(unit)->tcam_info == NULL) {
        return SOC_E_NONE;
    }

    for (reg_index = 0;
            _soc_tr2_esm_intr_info[reg_index].status_reg != INVALIDf;
            reg_index++) {
        reg = _soc_tr2_esm_intr_info[reg_index].status_reg;
        rval = 0;

        for (intr_reg_info = _soc_tr2_esm_intr_info[reg_index].reg_info;
                intr_reg_info->error_field != INVALIDf; intr_reg_info++) {
            soc_reg_field_set(unit, reg, &rval, intr_reg_info->error_field,
                    enable ? 1 : 0);
        }
        reg = _soc_tr2_esm_intr_info[reg_index].enable_reg;
        addr = soc_reg_addr(unit, reg, REG_PORT_ANY, 0);
        SOC_IF_ERROR_RETURN(soc_reg32_write(unit, addr, rval));
    }

    soc_intr_enable(unit, IRQ_CHIP_FUNC_3);

    return SOC_E_NONE;
}

int
_soc_triumph2_esm_process_intr_status(int unit)
{
    int reg_index, field_index, i;
    uint32 addr, status, rval;
    soc_reg_t reg, detail_reg;
    _soc_esm_intr_reg_info_t *intr_reg_info;
    soc_reg_info_t *reg_info;
    soc_field_info_t *field_info;
    char *msg;
    char line_buf[80], field_buf[80];
    int line_len, field_len;

    for (reg_index = 0; _soc_tr2_esm_intr_info[reg_index].clear_reg != INVALIDf;
            reg_index++) {
        reg = _soc_tr2_esm_intr_info[reg_index].status_reg;

        addr = soc_reg_addr(unit, reg, REG_PORT_ANY, 0);
        SOC_IF_ERROR_RETURN(soc_reg32_read(unit, addr, &status));
        for (intr_reg_info = _soc_tr2_esm_intr_info[reg_index].reg_info;
                intr_reg_info->error_field != INVALIDf; intr_reg_info++) {
            if (!soc_reg_field_get(unit, reg, status,
                            intr_reg_info->error_field)) {
                continue;
            }
            msg = intr_reg_info->msg;
            if (msg == NULL) {
                msg = SOC_FIELD_NAME(unit, intr_reg_info->error_field);
            }
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d %s asserted\n"), unit, msg));

            for (i = 0; intr_reg_info->detail_reg[i] != INVALIDr; i++) {
                detail_reg = intr_reg_info->detail_reg[i];
                addr = soc_reg_addr(unit, detail_reg, REG_PORT_ANY, 0);
                SOC_IF_ERROR_RETURN(soc_reg32_read(unit, addr, &rval));
                sal_sprintf(line_buf, "%s=0x%08x: ",
                        SOC_REG_NAME(unit, detail_reg), rval);
                line_len = sal_strlen(line_buf);
                reg_info = &SOC_REG_INFO(unit, detail_reg);
                for (field_index = reg_info->nFields - 1; field_index >= 0;
                        field_index--) {
                    field_info = &reg_info->fields[field_index];
                    sal_sprintf(field_buf, "%s%s=0x%x",
                            field_index == reg_info->nFields - 1 ?
                            "<" : " ",
                            SOC_FIELD_NAME(unit, field_info->field),
                            soc_reg_field_get(unit, detail_reg, rval,
                                    field_info->field));
                    field_len = sal_strlen(field_buf);
                    if (line_len + field_len >= 64) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "    %s\n"), line_buf));
                        line_len = 0;
                    }
                    sal_sprintf(&line_buf[line_len], "%s", field_buf);
                    line_len += field_len;
                }
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "    %s>\n"), line_buf));
            }
        }
        reg = _soc_tr2_esm_intr_info[reg_index].clear_reg;
        addr = soc_reg_addr(unit, reg, REG_PORT_ANY, 0);
        SOC_IF_ERROR_RETURN(soc_reg32_write(unit, addr, 0xffffffff));
    }

    return SOC_E_NONE;
}

void
soc_triumph2_esm_intr_status(void *unit_vp, void *d1, void *d2,
        void *d3, void *d4)
{
    int unit = PTR_TO_INT(unit_vp);

    _soc_triumph2_esm_process_intr_status(unit);
    soc_intr_enable(unit, IRQ_CHIP_FUNC_3);
}

int
soc_triumph2_pipe_mem_clear(int unit)
{
    uint32 rval;
    int pipe_init_usec;
    soc_timeout_t to;

    /*
     * Reset the IPIPE and EPIPE block
     */
    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_1r(unit, rval));
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, VALIDf, 1);
    /* Set count to # entries in largest IPIPE table, L2_ENTRYm */
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, COUNTf, 0x8000);
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_0r(unit, rval));
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, VALIDf, 1);
    /* Set count to # entries in largest EPIPE table, EGR_L3_NEXT_HOPm */
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, COUNTf, 0x4000);
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    /* For simulation, set timeout to 10 sec.  Otherwise, timeout = 50 ms */
    if (SAL_BOOT_SIMULATION) {
        pipe_init_usec = 10000000;
    } else {
        pipe_init_usec = 50000;
    }
    soc_timeout_init(&to, pipe_init_usec, 0);

    /* Wait for IPIPE memory initialization done. */
    do {
        SOC_IF_ERROR_RETURN(READ_ING_HW_RESET_CONTROL_2r(unit, &rval));
        if (soc_reg_field_get(unit, ING_HW_RESET_CONTROL_2r, rval, DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : ING_HW_RESET timeout\n"), unit));
            break;
        }
    }while (TRUE);

    /* Wait for EPIPE memory initialization done. */
    do {
        SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1r(unit, &rval));
        if (soc_reg_field_get(unit, EGR_HW_RESET_CONTROL_1r, rval, DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : EGR_HW_RESET timeout\n"), unit));
            break;
        }
    }while (TRUE);

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    SOC_IF_ERROR_RETURN
    (soc_mem_clear(unit, SPORT_EHG_RX_TUNNEL_DATAm, COPYNO_ALL, TRUE));
    SOC_IF_ERROR_RETURN
    (soc_mem_clear(unit, SPORT_EHG_RX_TUNNEL_MASKm, COPYNO_ALL, TRUE));
    SOC_IF_ERROR_RETURN
    (soc_mem_clear(unit, SPORT_EHG_TX_TUNNEL_DATAm, COPYNO_ALL, TRUE));
    if (SOC_IS_TRIUMPH2(unit)) {
        SOC_IF_ERROR_RETURN
        (soc_mem_clear(unit, GPORT_EHG_RX_TUNNEL_DATAm, COPYNO_ALL, TRUE));
        SOC_IF_ERROR_RETURN
        (soc_mem_clear(unit, GPORT_EHG_RX_TUNNEL_MASKm, COPYNO_ALL, TRUE));
        SOC_IF_ERROR_RETURN
        (soc_mem_clear(unit, GPORT_EHG_TX_TUNNEL_DATAm, COPYNO_ALL, TRUE));
    }
    SOC_IF_ERROR_RETURN
    (soc_mem_clear(unit, XPORT_EHG_RX_TUNNEL_DATAm, COPYNO_ALL, TRUE));
    SOC_IF_ERROR_RETURN
    (soc_mem_clear(unit, XPORT_EHG_RX_TUNNEL_MASKm, COPYNO_ALL, TRUE));
    SOC_IF_ERROR_RETURN
    (soc_mem_clear(unit, XPORT_EHG_TX_TUNNEL_DATAm, COPYNO_ALL, TRUE));
    SOC_IF_ERROR_RETURN
    (soc_mem_clear(unit, XQPORT_EHG_RX_TUNNEL_DATAm, COPYNO_ALL, TRUE));
    SOC_IF_ERROR_RETURN
    (soc_mem_clear(unit, XQPORT_EHG_RX_TUNNEL_MASKm, COPYNO_ALL, TRUE));
    SOC_IF_ERROR_RETURN
    (soc_mem_clear(unit, XQPORT_EHG_TX_TUNNEL_DATAm, COPYNO_ALL, TRUE));

    SOC_IF_ERROR_RETURN(soc_mem_clear(unit, IARB_TDM_TABLEm, COPYNO_ALL, TRUE));
    SOC_IF_ERROR_RETURN(soc_mem_clear(unit, ARB_TDM_TABLEm, COPYNO_ALL, TRUE));

    /* LMEP table is not properly handled by reset control */
    SOC_IF_ERROR_RETURN(soc_mem_clear(unit, LMEPm, COPYNO_ALL, TRUE));

    return SOC_E_NONE;
}

uint32 tdmb634a[114] = {26, 2,27,14,28,30,29,26,34,27,
    3,28,15,29,26,38,27,42,28,4,
    29,26,16,27,46,28,50,29,26,5,
    27,17,28,31,29,26,35,27,6,28,
    18,29,26,39,27,43,28,7,29,26,
    19,27,47,28,51,29,1,26,8,27,
    20,28,32,29,26,36,27,9,28,21,
    29,26,40,27,44,28,10,29,26,22,
    27,48,28,52,29,26,11,27,23,28,
    33,29,26,37,27,12,28,24,29,26,
    41,27,45,28,13,29,26,25,27,49,
    28,53,29,0};

uint32 tdmb634abp[114] = {26,2,27,14,28,30,29,26,34,27,
    3,28,15,29,26,38,27,42,28,4,
    29,26,16,27,46,28,50,29,26,5,
    27,17,28,31,29,26,35,27,6,28,
    18,29,26,39,27,43,28,7,29,26,
    19,27,47,28,51,1,29,26,8,27,20,
    28,32,29,26,36,27,9,28,21,29,
    26,40,27,44,28,10,29,26,22,27,
    48,28,52,29,26,11,27,23,28,33,
    29,26,37,27,12,28,24,29,26,41,
    27,45,28,13,29,26,25,27,49,28,
    53,0,29};

uint32 eelist634afp[55] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 0};

uint32 eelist634a[55] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0};

uint32 tdmb634b[110] = {2,26,30,27,14,28,34,29,54,3,26,
    38,27,15,28,42,29,54,4,26,46,27,
    16,28,50,29,54,5,26,31,27,17,28,
    35,29,54,6,26,39,27,18,28,43,29,
    54,7,26,47,27,19,28,51,29,1,54,
    8,26,32,27,20,28,36,29,54,9,26,
    40,27,21,28,44,29,54,10,26,48,27,
    22,28,52,29,54,11,26,33,27,23,28,
    37,29,54,12,26,41,27,24,28,45,29,
    54,13,26,49,27,25,28,53,29,0,54};

uint32 tdmb634bbp[110] = {2,26,30,27,14,28,34,29,54,3,26,
    38,27,15,28,42,29,54,4,26,46,27,
    16,28,50,29,54,5,26,31,27,17,28,
    35,29,54,6,26,39,27,18,28,43,29,
    54,7,26,47,27,19,28,51,29,54,1,8,
    26,32,27,20,28,36,29,54,9,26,40,
    27,21,28,44,29,54,10,26,48,27,22,
    28,52,29,54,11,26,33,27,23,28,37,
    29,54,12,26,41,27,24,28,45,29,54,
    13,26,49,27,25,28,53,29,54,0};

uint32 eelist634bfp[55] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 0};

uint32 eelist634b[55] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0};

uint32 tdmb634c[110] = {2,26,30,27,14,26,34,27,54,3,26,38,
    27,15,26,42,27,54,4,26,46,27,16,
    26,50,27,54,5,26,31,27,17,26,35,
    27,54,6,26,39,27,18,26,43,27,54,7,
    26,47,27,19,26,51,27,1,54,8,26,32,
    27,20,26,36,27,54,9,26,40,27,21,26,
    44,27,54,10,26,48,27,22,26,52,27,54,
    11,26,33,27,23,26,37,27,54,12,26,41,
    27,24,26,45,27,54,13,26,49,27,25,26,
    53,27,0,54};

uint32 tdmb634cbp[110] = {2,26,30,27,14,26,34,27,54,3,26,38,
    27,15,26,42,27,54,4,26,46,27,16,26,
    50,27,54,5,26,31,27,17,26,35,27,54,
    6,26,39,27,18,26,43,27,54,7,26,47,
    27,19,26,51,27,54,1,8,26,32,27,20,
    26,36,27,54,9,26,40,27,21,26,44,27,
    54,10,26,48,27,22,26,52,27,54,11,26,
    33,27,23,26,37,27,54,12,26,41,27,24,
    26,45,27,54,13,26,49,27,25,26,53,27,
    54,0};

uint32 eelist634cfp[55] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 0};

uint32 eelist634c[55] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0};

uint32 tdmb636a[114] = {26,2,27,30,28,42,29,26,50,27,3,
    28,34,29,26,42,27,50,28,4,29,26,
    38,27,42,28,50,29,26,5,27,31,28,
    42,29,26,50,27,6,28,35,29,26,42,
    27,50,28,7,29,26,39,27,42,28,50,
    29,1,26,8,27,32,28,42,29,26,50,27,
    9,28,36,29,26,42,27,50,28,10,29,
    26,40,27,42,28,50,29,26,11,27,33,
    28,42,29,26,50,27,12,28,37,29,26,
    42,27,50,28,13,29,26,41,27,42,28,
    50,29,0};

uint32 tdmb636abp[114] = {26,2,27,30,28,42,29,26,50,27,3,
    28,34,29,26,42,27,50,28,4,29,26,
    38,27,42,28,50,29,26,5,27,31,28,
    42,29,26,50,27,6,28,35,29,26,42,
    27,50,28,7,29,26,39,27,42,28,50,
    1,29,26,8,27,32,28,42,29,26,50,
    27,9,28,36,29,26,42,27,50,28,10,
    29,26,40,27,42,28,50,29,26,11,27,
    33,28,42,29,26,50,27,12,28,37,29,
    26,42,27,50,28,13,29,26,41,27,42,
    28,50,0,29};

uint32 eelist636afp[55] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 0, 0, 0};

uint32 eelist636a[55] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0};

uint32 tdmb636b[110] = {2,26,42,27,30,26,50,27,54,3,26,42,
    27,34,26,50,27,54,4,26,42,27,38,
    26,50,27,54, 5,26,42,27,31,26,50,
    27,54,6,26,42,27,35,26,50,27,54,7,
    26,42,27,39,26,50,27,1,54,8,26,42,
    27,32,26,50,27,54,9,26,42,27,36,26,
    50,27,54,10,26,42,27,40,26,50,27,54,
    11,26,42,27,33,26,50,27,54,12,26,42,
    27,37,26,50,27,54,13,26,42,27,41,26,
    50,27,0,54};

uint32 tdmb636bbp[110] = {2,26,42,27,30,26,50,27,54,3,26,42,
    27,34,26,50,27,54,4,26,42,27,38,26,
    50,27,54,5,26,42,27,31,26,50,27,54,
    6,26,42,27,35,26,50,27,54,7,26,42,
    27,39,26,50,27,54,1,8,26,42,27,32,
    26,50,27,54,9,26,42,27,36,26,50,27,
    54,10,26,42,27,40,26,50,27,54,11,26,
    42,27,33,26,50,27,54,12,26,42,27,37,
    26,50,27,54,13,26,42,27,41,26,50,27,
    54,0};

uint32 eelist636bfp[55] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 0, 0, 0};

uint32 eelist636b[55] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0};

uint32 tdmb636c[110] = {2,26,42,27,30,28,50,29,54,3,26,
    42,27,34,28,50,29,54,4,26,42,27,
    38,28,50,29,54,5,26,42,27,31,28,
    50,29,54,6,26,42,27,35,28,50,29,
    54,7,26,42,27,39,28,50,29,1,54,8,
    26,42,27,32,28,50,29,54,9,26,42,
    27,36,28,50,29,54,10,26,42,27,40,
    28,50,29,54,11,26,42,27,33,28,50,
    29,54,12,26,42,27,37,28,50,29,54,
    13,26,42,27,41,28,50,29,0,54};

uint32 tdmb636cbp[110] = {2,26,42,27,30,28,50,29,54,3,26,
    42,27,34,28,50,29,54,4,26,42,27,
    38,28,50,29,54,5,26,42,27,31,28,
    50,29,54,6,26,42,27,35,28,50,29,
    54,7,26,42,27,39,28,50,29,54,1,8,
    26,42,27,32,28,50,29,54,9,26,42,
    27,36,28,50,29,54,10,26,42,27,40,
    28,50,29,54,11,26,42,27,33,28,50,
    29,54,12,26,42,27,37,28,50,29,54,
    13,26,42,27,41,28,50,29,54,0};

uint32 eelist636cfp[55] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 0, 0, 0};

uint32 eelist636c[55] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0};

uint32 tdmb638a[114] = {26,30,27,38,28,42,29,26,50,27,30,
    28,38,29,26,42,27,50,28,30,29,26,
    38,27,42,28,50,29,26,30,27,38,28,
    42,29,26,50,27,30,28,38,29,26,42,
    27,50,28,30,29,26,38,27,42,28,50,
    29,1,26,30,27,38,28,42,29,26,50,
    27,30,28,38,29,26,42,27,50,28,30,
    29,26,38,27,42,28,50,29,26,30,27,
    38,28,42,29,26,50,27,30,28,38,29,
    26,42,27,50,28,30,29,26,38,27,42,
    28,50,29,0};

uint32 tdmb638abp[114] = {26,30,27,38,28,42,29,26,50,27,30,
    28,38,29,26,42,27,50,28,30,29,26,
    38,27,42,28,50,29,26,30,27,38,28,
    42,29,26,50,27,30,28,38,29,26,42,
    27,50,28,30,29,26,38,27,42,28,50,
    1,29,26,30,27,38,28,42,29,26,50,
    27,30,28,38,29,26,42,27,50,28,30,
    29,26,38,27,42,28,50,29,26,30,27,
    38,28,42,29,26,50,27,30,28,38,29,
    26,42,27,50,28,30,29,26,38,27,42,
    28,50,0,29};

uint32 eelist638afp[55] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 0, 0, 0};

uint32 eelist638a[55] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0};

uint32 tdmb638b[110] = {30,26,38,27,42,28,50,29,54,30,26,
    38,27,42,28,50,29,54,30,26,38,27,
    42,28,50,29,54,30,26,38,27,42,28,
    50,29,54,30,26,38,27,42,28,50,29,
    54,30,26,38,27,42,28,50,29,1,54,30,
    26,38,27,42,28,50,29,54,30,26,38,
    27,42,28,50,29,54,30,26,38,27,42,
    28,50,29,54,30,26,38,27,42,28,50,
    29,54,30,26,38,27,42,28,50,29,54,
    30,26,38,27,42,28,50,29,0,54};

uint32 tdmb638bbp[110] = {30,26,38,27,42,28,50,29,54,30,26,
    38,27,42,28,50,29,54,30,26,38,27,
    42,28,50,29,54,30,26,38,27,42,28,
    50,29,54,30,26,38,27,42,28,50,29,
    54,30,26,38,27,42,28,50,29,54,1,
    30,26,38,27,42,28,50,29,54,30,26,
    38,27,42,28,50,29,54,30,26,38,27,
    42,28,50,29,54,30,26,38,27,42,28,
    50,29,54,30,26,38,27,42,28,50,29,
    54,30,26,38,27,42,28,50,29,54,0};

uint32 eelist638bfp[55] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 0, 0, 0};

uint32 eelist638b[55] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0};

uint32 tdmb638c[110] = {30,26,38,27,42,26,50,27,54,30,26,
    38,27,42,26,50,27,54,30,26,38,27,
    42,26,50,27,54,30,26,38,27,42,26,
    50,27,54,30,26,38,27,42,26,50,27,
    54,30,26,38,27,42,26,50,27,1,54,
    30,26,38,27,42,26,50,27,54,30,26,
    38,27,42,26,50,27,54,30,26,38,27,
    42,26,50,27,54,30,26,38,27,42,26,
    50,27,54,30,26,38,27,42,26,50,27,
    54,30,26,38,27,42,26,50,27,0,54};

uint32 tdmb638cbp[110] = {30,26,38,27,42,26,50,27,54,30,
    26,38,27,42,26,50,27,54,30,26,
    38,27,42,26,50,27,54,30,26,38,
    27,42,26,50,27,54,30,26,38,27,
    42,26,50,27,54,30,26,38,27,42,
    26,50,27,54,1,30,26,38,27,42,26,
    50,27,54,30,26,38,27,42,26,50,
    27,54,30,26,38,27,42,26,50,27,
    54,30,26,38,27,42,26,50,27,54,
    30,26,38,27,42,26,50,27,54,30,
    26,38,27,42,26,50,27,54,0};

uint32 eelist638cfp[55] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 0, 0, 0};

uint32 eelist638c[55] = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0};

uint32 tdmb639a[114] = {2,26,54,27,14,28,29,30,50,3,38,42,
    26,15,27,28,29,30,4,50,38,42,16,26,
    27,54,28,29,5,30,50,38,17,42,54,26,
    27,6,28,29,30,18,50,38,42,26,7,54,
    27,28,19,29,30,50,38,42,1,8,26,54,
    27,20,28,29,30,50,9,38,42,26,21,27,
    28,29,30,10,50,38,42,22,26,27,54,28,
    29,11,30,50,38,23,42,54,26,27,12,28,
    29,30,24,50,38,42,26,13,54,27,28,25,
    29,30,50,38,42,0};

uint32 tdmb639b[114] = {2,29,54,27,14,28,46,30,50,3,38,42,
    29,15,27,28,47,30,4,50,38,42,16,29,
    27,54,28,48,5,30,50,38,17,42,54,29,
    27,6,28,49,30,18,50,38,42,29,7,54,
    27,28,19,63,30,50,38,42,1,8,29,54,
    27,20,28,63,30,50,9,38,42,29,21,27,
    28,63,30,10,50,38,42,22,29,27,54,28,
    63,11,30,50,38,23,42,54,29,27,12,28,
    63,30,24,50,38,42,29,13,54,27,28,25,
    63,30,50,38,42,0};

uint32 tdmb685[228] = {30,26,34,27,38,28,42,46,29,50,26,
    31,27,35,39,28,43,29,47,26,51,32,
    27,36,28,40,29,54,44,26,48,27,52,
    28,33,37,29,41,26,45,27,49,53,28,
    30,29,34,26,38,42,27,46,28,50,29,
    54,1,31,26,35,27,39,28,43,47,29,51,
    26,32,27,36,40,28,44,29,48,26,52,
    33,27,37,28,41,29,54,45,26,49,27,
    53,28,30,34,29,38,26,42,27,46,50,
    28,31,29,35,26,39,43,27,47,28,51,
    29,54,0,32,26,36,27,40,28,44,48,29,
    52,26,33,27,37,41,28,45,29,49,26,
    53,30,27,34,28,38,29,54,42,26,46,
    27,50,28,31,35,29,39,26,43,27,47,
    51,28,32,29,36,26,40,44,27,48,28,
    52,29,54,1,33,26,37,27,41,28,45,49,
    29,53,26,30,27,34,38,28,42,29,46,
    26,50,31,27,35,28,39,29,54,43,26,
    47,27,51,28,32,36,29,40,26,44,27,
    48,52,28,33,29,37,26,41,45,27,49,
    28,53,29,54,0};

uint32 tdmb521a[114] = {2,26,54,27,14,28,29,26,27,3,28,
    29,26,15,27,28,29,26,4,27,28,29,
    16,26,27,54,28,29,5,26,27,28,17,
    29,54,26,27,6,28,29,26,18,27,28,
    29,26,7,54,27,28,19,29,26,27,28,
    29,1,8,26,54,27,20,28,29,26,27,
    9,28,29,26,21,27,28,29,26,10,27,
    28,29,22,26,27,54,28,29,11,26,27,
    28,23,29,54,26,27,12,28,29,26,24,
    27,28,29,26,13,54,27,28,25,29,26,
    27,28,29,0};

uint32 tdmb521b[110] = {2,26,27,28,14,26,27,29,54,3,26,
    27,28,15,26,27,29,54,4,26,27,28,
    16,26,27,29,54,5,26,27,28,17,26,
    27,29,54,6,26,27,28,18,26,27,29,
    54,7,26,27,28,19,26,27,29,54,1,8,
    26,27,28,20,26,27,29,54,9,26,27,
    28,21,26,27,29,54,10,26,27,28,22,
    26,27,29,54,11,26,27,28,23,26,27,
    29,54,12,26,27,28,24,26,27,29,54,
    13,26,27,28,25,26,27,29,54,0};

uint32 tdmb524a[114] = {30,26,54,27,34,28,29,26,27,38,28,
    29,26,42,27,28,29,26,46,27,28,29,
    50,26,27,54,28,29,31,26,27,28,35,
    29,54,26,27,39,28,29,26,43,27,28,
    29,26,47,54,27,28,51,29,26,27,28,
    29,1,32,26,54,27,36,28,29,26,27,
    40,28,29,26,44,27,28,29,26,48,27,
    28,29,52,26,27,54,28,29,33,26,27,
    28,37,29,54,26,27,41,28,29,26,45,
    27,28,29,26,49,54,27,28,53,29,26,
    27,28,29,0};

uint32 tdmb524b[110] = {30,26,27,28,42,26,27,29,54,34,26,
    27,28,46,26,27,29,54,38,26,27,28,
    50,26,27,29,54,31,26,27,28,43,26,
    27,29,54,35,26,27,28,47,26,27,29,
    54,39,26,27,28,51,26,27,29,54,1,
    32,26,27,28,44,26,27,29,54,36,26,
    27,28,48,26,27,29,54,40,26,27,28,
    52,26,27,29,54,33,26,27,28,45,26,
    27,29,54,37,26,27,28,49,26,27,29,
    54,41,26,27,28,53,26,27,29,54,0};

uint32 tdmb526a[110] = {2,26,27,28,14,29,46,50,38,3,26,27,
    28,15,29,46,50,54,4,26,27,28,16,29,
    46,50,54,5,26,27,28,17,29,46,50,39,
    6,26,27,28,18,29,46,50,54,7,26,27,
    28,19,29,46,50,54,1,8,26,27,28,20,
    29,46,50,40,9,26,27,28,21,29,46,50,
    54,10,26,27,28,22,29,46,50,54,11,26,
    27,28,23,29,46,50,41,12,26,27,28,24,
    29,46,50,54,13,26,27,28,25,29,46,50,54,0};

uint32 tdmb526b[114] = {26,2,27,46,28,14,29,26,50,27,3,28,
    46,29,26,15,27,50,28,4,29,26,46,27,
    16,28,50,29,26,5,27,46,28,17,29,26,
    50,27,6,28,46,29,26,18,27,50,28,7,
    29,26,46,27,19,28,50,29,1,26,8,27,
    46,28,20,29,26,50,27,9,28,46,29,26,
    21,27,50,28,10,29,26,46,27,22,28,
    50,29,26,11,27,46,28,23,29,26,50,
    27,12,28,46,29,26,24,27,50,28,13,
    29,26,46,27,25,28,50,29,0};
#if defined (SER_TR_TEST_SUPPORT)
soc_ser_test_functions_t ser_test_fun;    
#endif

int
soc_triumph2_misc_init(int unit)
{
    uint16 dev_id;
    uint8 rev_id;
    uint32 rval, prev_reg_addr;
    uint64 reg64;
    int port;
    uint32 misc_cfg;
    uint32 mode;
    uint32 *arr, *eelist = NULL;
    int i, tdm_size, has_sport = TRUE;
    int front_panel_esm = TRUE;
    int divisor, dividend;
    uint64 multipass, bm64;
    iarb_tdm_table_entry_t iarb_tdm;
    arb_tdm_table_entry_t arb_tdm;
    soc_field_t fields[3];
    uint32 values[3];

    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 0);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));

    soc_cm_get_id(unit, &dev_id, &rev_id);
    if (soc_feature(unit, soc_feature_esm_support)) {
        front_panel_esm = soc_property_get(unit, spn_FRONT_PANEL_ESM, TRUE);
    }

    /* Turn off SER protection clearing memories */
    SOC_IF_ERROR_RETURN(WRITE_CMIC_SER_PROTECT_ADDR_RANGE_VALIDr(unit, 0));

    if (!SOC_IS_RELOADING(unit) && !SOC_WARM_BOOT(unit)) {
        /* Clear IPIPE/EIPIE Memories */
        SOC_IF_ERROR_RETURN(soc_triumph2_pipe_mem_clear(unit));
    }
#if defined(SER_TR_TEST_SUPPORT)
        /*Initialize chip-specific functions for SER testing*/
        memset(&ser_test_fun, 0, sizeof(soc_ser_test_functions_t));
        ser_test_fun.inject_error_f = &soc_tr2_ser_inject_error;
        ser_test_fun.test_mem = &soc_tr2_ser_mem_test;
        ser_test_fun.test     = &soc_tr2_ser_test;
        ser_test_fun.parity_control = &_ser_test_parity_control_pci_write;
        soc_ser_test_functions_register(unit, &ser_test_fun);
#endif /*defined(SER_TR_TEST_SUPPORT*/
    switch (dev_id) {
        case BCM56634_DEVICE_ID:
        /* Fall through */
        case BCM56538_DEVICE_ID:
        if (soc_property_get(unit, spn_BCM56634_48G_4X12, 0) ||
                soc_property_get(unit, spn_BCM56538_48G_4X12, 0)) {
            /* 48x1GE + 4x12HG + 1x12G(loopback) */
            tdm_size = 110;
            if (front_panel_esm) {
                arr = tdmb634b;
                eelist = eelist634bfp;
            } else {
                arr = tdmb634bbp;
                eelist = eelist634b;
            }
        } else if (soc_property_get(unit, spn_BCM56634_48G_2X24, 0) ||
                soc_property_get(unit, spn_BCM56538_48G_2X24, 0)) {
            /* 48x1GE + 2x24HG + 1x12G(loopback) */
            tdm_size = 110;
            if (front_panel_esm) {
                arr = tdmb634c;
                eelist = eelist634cfp;
            } else {
                arr = tdmb634cbp;
                eelist = eelist634c;
            }
        } else {
            /* 48x1GE + 4x16HG */
            tdm_size = 114;
            if (front_panel_esm) {
                arr = tdmb634a;
                eelist = eelist634afp;
            } else {
                arr = tdmb634abp;
                eelist = eelist634a;
            }
        }
        break;
        case BCM56636_DEVICE_ID:
        if (soc_property_get(unit, spn_BCM56636_24G_6X12, 0)) {
            /* 24x1GE + 6x12HG + 1x12G(loopback) */
            tdm_size = 110;
            if (front_panel_esm) {
                arr = tdmb636c;
                eelist = eelist636cfp;
            } else {
                arr = tdmb636cbp;
                eelist = eelist636c;
            }
        } else if (soc_property_get(unit, spn_BCM56636_2X12_2X24, 0)) {
            /* 24x1GE + 2x12HG + 2x24G(loopback) */
            tdm_size = 110;
            if (front_panel_esm) {
                arr = tdmb636b;
                eelist = eelist636bfp;
            } else {
                arr = tdmb636bbp;
                eelist = eelist636b;
            }
        } else {
            /* 24x1GE + 2x12HG + 4x16HG */
            tdm_size = 114;
            if (front_panel_esm) {
                arr = tdmb636a;
                eelist = eelist636afp;
            } else {
                arr = tdmb636abp;
                eelist = eelist636a;
            }
        }
        SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EDATABUF_XQP_FLEXPORT_CONFIGr,
                        REG_PORT_ANY, EGR_XQP_PORT_INT_RESETf,
                        0x28));
        SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EDATABUF_XQP_FLEXPORT_CONFIGr,
                        REG_PORT_ANY, EGR_XQP_PORT_MODEf, 0x28));
        SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EDATABUF_XQP_FLEXPORT_CONFIGr,
                        REG_PORT_ANY, EGR_XQP_PORT_INT_RESETf, 0));
        soc_port_cmap_set(unit, 42, SOC_CTR_TYPE_XE);
        soc_port_cmap_set(unit, 50, SOC_CTR_TYPE_XE);
        break;
        case BCM56638_DEVICE_ID:
        if (soc_property_get(unit, spn_BCM56638_8X12, 0)) {
            /* 8x12HG + 1x12G(loopback) */
            tdm_size = 110;
            if (front_panel_esm) {
                arr = tdmb638b;
                eelist = eelist638bfp;
            } else {
                arr = tdmb638bbp;
                eelist = eelist638b;
            }
        } else if (soc_property_get(unit, spn_BCM56638_4X12_2X24, 0)) {
            /* 4x12HG + 2x24G(loopback) */
            tdm_size = 110;
            if (front_panel_esm) {
                arr = tdmb638c;
                eelist = eelist638cfp;
            } else {
                arr = tdmb638cbp;
                eelist = eelist638c;
            }
        } else {
            /* 4x12HG + 4x16HG */
            tdm_size = 114;
            if (front_panel_esm) {
                arr = tdmb638a;
                eelist = eelist638afp;
            } else {
                arr = tdmb638abp;
                eelist = eelist638a;
            }
        }
        SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EDATABUF_XQP_FLEXPORT_CONFIGr,
                        REG_PORT_ANY, EGR_XQP_PORT_INT_RESETf,
                        0x2D));
        SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EDATABUF_XQP_FLEXPORT_CONFIGr,
                        REG_PORT_ANY, EGR_XQP_PORT_MODEf, 0x2D));
        SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EDATABUF_XQP_FLEXPORT_CONFIGr,
                        REG_PORT_ANY, EGR_XQP_PORT_INT_RESETf, 0));
        soc_port_cmap_set(unit, 30, SOC_CTR_TYPE_XE);
        soc_port_cmap_set(unit, 38, SOC_CTR_TYPE_XE);
        soc_port_cmap_set(unit, 42, SOC_CTR_TYPE_XE);
        soc_port_cmap_set(unit, 50, SOC_CTR_TYPE_XE);
        break;
        case BCM56639_DEVICE_ID:
        if (!soc_property_get(unit, spn_BCM56639_28G_7X10, 0)) {
            /* 24x1GE + 8x10G + loopback */
            arr = tdmb639a;
        } else {
            /* 28x1GE + 7x10G + loopback */
            arr = tdmb639b;
        }
        tdm_size = 114;
        SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EDATABUF_XQP_FLEXPORT_CONFIGr,
                        REG_PORT_ANY, EGR_XQP_PORT_INT_RESETf,
                        0x2D));
        SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EDATABUF_XQP_FLEXPORT_CONFIGr,
                        REG_PORT_ANY, EGR_XQP_PORT_MODEf, 0x2D));
        SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EDATABUF_XQP_FLEXPORT_CONFIGr,
                        REG_PORT_ANY, EGR_XQP_PORT_INT_RESETf, 0));
        soc_port_cmap_set(unit, 30, SOC_CTR_TYPE_XE);
        soc_port_cmap_set(unit, 38, SOC_CTR_TYPE_XE);
        soc_port_cmap_set(unit, 42, SOC_CTR_TYPE_XE);
        soc_port_cmap_set(unit, 50, SOC_CTR_TYPE_XE);
        break;
        case BCM56689_DEVICE_ID:
        has_sport = FALSE;
        /* Fall through */
        case BCM56685_DEVICE_ID:
        /* 24x2.5GE + 4x12G + loopback */
        tdm_size = 228;
        arr = tdmb685;
        break;
        case BCM56520_DEVICE_ID:
        /* Fall through */
        case BCM56522_DEVICE_ID:
        if (soc_property_get(unit, spn_HIGIG_MAX_SPEED, 0) == 12000) {
            /* 48x1GE + 4x12HG + 1x12G(loopback) */
            tdm_size = 110;
            arr = tdmb634b;
        } else {
            /* 24x1GE + 4x20HG + loopback */
            tdm_size = 110;
            arr = tdmb524b;
        }
        break;
        case BCM56521_DEVICE_ID:
        has_sport = FALSE;
        if (soc_property_get(unit, spn_BCM56521_2X12_2X24, 0)) {
            /* 24x1GE + 2x12HG + 2x24HG + loopback */
            tdm_size = 110;
            arr = tdmb521b;
        } else if (soc_property_get(unit, spn_HIGIG_MAX_SPEED, 0) == 12000) {
            /* 48x1GE + 4x12HG + 1x12G(loopback) */
            tdm_size = 110;
            arr = tdmb634b;
        } else {
            /* 24x1GE + 4x20HG + loopback */
            tdm_size = 114;
            arr = tdmb521a;
        }
        break;
        case BCM56630_DEVICE_ID:
        has_sport = FALSE;
        if (soc_property_get(unit, spn_BCM56630_2X12_2X24, 0)) {
            /* 24x1GE + 2x12HG + 2x24HG + loopback */
            tdm_size = 110;
            arr = tdmb524b;
        } else if (soc_property_get(unit, spn_HIGIG_MAX_SPEED, 0) == 12000) {
            /* 48x1GE + 4x12HG + 1x12G(loopback) */
            tdm_size = 110;
            arr = tdmb634b;
        } else {
            /* 24x1GE + 4x20HG + loopback */
            tdm_size = 114;
            arr = tdmb524a;
        }
        break;
        case BCM56524_DEVICE_ID:
        /* Fall through */
        case BCM56534_DEVICE_ID:
        has_sport = FALSE;
        if (soc_property_get(unit, spn_BCM56524_2X12_2X24, 0) ||
                soc_property_get(unit, spn_BCM56534_2X12_2X24, 0)) {
            /* 24x1GE + 2x12HG + 2x24HG + loopback */
            tdm_size = 110;
            arr = tdmb524b;
        } else if (soc_property_get(unit, spn_HIGIG_MAX_SPEED, 0) == 12000) {
            /* 48x1GE + 4x12HG + 1x12G(loopback) */
            tdm_size = 110;
            arr = tdmb634b;
        } else {
            /* 24x1GE + 4x20HG + loopback */
            tdm_size = 114;
            arr = tdmb524a;
        }
        break;
        case BCM56526_DEVICE_ID:
        if (soc_property_get(unit, spn_BCM56526_2X12_4X16, 0)) {
            /* 24X1GE + 2X12HG + 4X16HG */
            tdm_size = 114;
            arr = tdmb526b;
        } else {
            /* 28x1GE + 6x12HG + loopback */
            tdm_size = 110;
            arr = tdmb526a;
        }
        SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EDATABUF_XQP_FLEXPORT_CONFIGr,
                        REG_PORT_ANY, EGR_XQP_PORT_INT_RESETf,
                        0x30));
        SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EDATABUF_XQP_FLEXPORT_CONFIGr,
                        REG_PORT_ANY, EGR_XQP_PORT_MODEf, 0x30));
        SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EDATABUF_XQP_FLEXPORT_CONFIGr,
                        REG_PORT_ANY, EGR_XQP_PORT_INT_RESETf, 0));
        soc_port_cmap_set(unit, 46, SOC_CTR_TYPE_XE);
        soc_port_cmap_set(unit, 50, SOC_CTR_TYPE_XE);
        break;
        default:
        tdm_size = 114;
        arr = tdmb634a;
        eelist = eelist634afp;
        break;
    }
    for (i = 0; i < tdm_size; i++) {
        sal_memset(&iarb_tdm, 0, sizeof(iarb_tdm_table_entry_t));
        sal_memset(&arb_tdm, 0, sizeof(arb_tdm_table_entry_t));
        soc_IARB_TDM_TABLEm_field32_set(unit, &iarb_tdm, PORT_NUMf,
                arr[i]);
        soc_ARB_TDM_TABLEm_field32_set(unit, &arb_tdm, PORT_NUMf,
                arr[i]);
        if (soc_feature(unit, soc_feature_esm_support)) {
            /*    coverity[var_deref_op]    */
            soc_IARB_TDM_TABLEm_field32_set(unit, &iarb_tdm,
                    ESM_ELIGIBLEf, eelist[arr[i]]);
        }
        /* Cache the CPU slot entry */
        if (IS_CPU_PORT(unit, arr[i])) {
            sal_memcpy(&(SOC_CONTROL(unit)->iarb_tdm), &iarb_tdm,
                    sizeof(iarb_tdm));
            SOC_CONTROL(unit)->iarb_tdm_idx = i;
        }
        if (i == tdm_size - 1) {
            soc_ARB_TDM_TABLEm_field32_set(unit, &arb_tdm, WRAP_ENf, 1);
        }
        SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_TABLEm(unit, SOC_BLOCK_ALL, i,
                        &iarb_tdm));
        SOC_IF_ERROR_RETURN(WRITE_ARB_TDM_TABLEm(unit, SOC_BLOCK_ALL, i,
                        &arb_tdm));
    }
    rval = 0;
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 0);
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, TDM_WRAP_PTRf,
            tdm_size -1);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));

    /* Enable SPORT */
    if (has_sport && SOC_PORT_VALID(unit, 1)) {
        SOC_IF_ERROR_RETURN(READ_SPORT_CTL_REGr(unit, 1, &rval));
        soc_reg_field_set(unit, SPORT_CTL_REGr, &rval, SPORT_EN_BITf, 1);
        SOC_IF_ERROR_RETURN(WRITE_SPORT_CTL_REGr(unit, 1, rval));
    }

    /* Set the mode for XE ports (XPORT blocks) */
    mode = 1;
    if (SOC_PORT_VALID(unit, 26)) {
        SOC_IF_ERROR_RETURN(READ_XPORT_MODE_REGr(unit, 26, &rval));
        soc_reg_field_set(unit, XPORT_MODE_REGr, &rval, XPORT_MODE_BITSf, mode);
        SOC_IF_ERROR_RETURN(WRITE_XPORT_MODE_REGr(unit, 26, rval));
    }
    if (SOC_PORT_VALID(unit, 27)) {
        SOC_IF_ERROR_RETURN(READ_XPORT_MODE_REGr(unit, 27, &rval));
        soc_reg_field_set(unit, XPORT_MODE_REGr, &rval, XPORT_MODE_BITSf, mode);
        SOC_IF_ERROR_RETURN(WRITE_XPORT_MODE_REGr(unit, 27, rval));
    }
    if (SOC_PORT_VALID(unit, 28)) {
        SOC_IF_ERROR_RETURN(READ_XPORT_MODE_REGr(unit, 28, &rval));
        soc_reg_field_set(unit, XPORT_MODE_REGr, &rval, XPORT_MODE_BITSf, mode);
        SOC_IF_ERROR_RETURN(WRITE_XPORT_MODE_REGr(unit, 28, rval));
    }
    if (SOC_PORT_VALID(unit, 29)) {
        SOC_IF_ERROR_RETURN(READ_XPORT_MODE_REGr(unit, 29, &rval));
        soc_reg_field_set(unit, XPORT_MODE_REGr, &rval, XPORT_MODE_BITSf, mode);
        SOC_IF_ERROR_RETURN(WRITE_XPORT_MODE_REGr(unit, 29, rval));
    }

    /* Enable GPORTs and XQPORTs */
    if (SOC_PORT_VALID(unit, 2)) {
        SOC_IF_ERROR_RETURN(READ_GPORT_MODE_REGr(unit, 2, &rval));
        soc_reg_field_set(unit, GPORT_MODE_REGr, &rval, GPORT_MODE_BITSf, mode);
        SOC_IF_ERROR_RETURN(WRITE_GPORT_MODE_REGr(unit, 2, rval));
    }
    if (SOC_PORT_VALID(unit, 14)) {
        SOC_IF_ERROR_RETURN(READ_GPORT_MODE_REGr(unit, 14, &rval));
        soc_reg_field_set(unit, GPORT_MODE_REGr, &rval, GPORT_MODE_BITSf, mode);
        SOC_IF_ERROR_RETURN(WRITE_GPORT_MODE_REGr(unit, 14, rval));
    }
    if (SOC_PORT_VALID(unit, 30)) {
        switch (dev_id) {
            case BCM56639_DEVICE_ID:
            case BCM56638_DEVICE_ID:
            mode = 2;
            break;
            default:
            mode = 1;
            break;
        }
        SOC_IF_ERROR_RETURN(READ_XQPORT_MODE_REGr(unit, 30, &rval));
        soc_reg_field_set(unit, XQPORT_MODE_REGr, &rval,
                XQPORT_MODE_BITSf, mode);
        SOC_IF_ERROR_RETURN(WRITE_XQPORT_MODE_REGr(unit, 30, rval));
    }
    if (SOC_PORT_VALID(unit, 34)) {
        SOC_IF_ERROR_RETURN(READ_XQPORT_MODE_REGr(unit, 34, &rval));
        soc_reg_field_set(unit, XQPORT_MODE_REGr, &rval,
                XQPORT_MODE_BITSf, mode);
        SOC_IF_ERROR_RETURN(WRITE_XQPORT_MODE_REGr(unit, 34, rval));
    }
    if (SOC_PORT_VALID(unit, 38)) {
        switch (dev_id) {
            case BCM56639_DEVICE_ID:
            case BCM56638_DEVICE_ID:
            mode = 2;
            break;
            default:
            mode = 1;
            break;
        }
        SOC_IF_ERROR_RETURN(READ_XQPORT_MODE_REGr(unit, 38, &rval));
        soc_reg_field_set(unit, XQPORT_MODE_REGr, &rval,
                XQPORT_MODE_BITSf, mode);
        SOC_IF_ERROR_RETURN(WRITE_XQPORT_MODE_REGr(unit, 38, rval));
    }
    if (SOC_PORT_VALID(unit, 42)) {
        switch (dev_id) {
            case BCM56639_DEVICE_ID:
            case BCM56638_DEVICE_ID:
            case BCM56636_DEVICE_ID:
            mode = 2;
            break;
            default:
            mode = 1;
            break;
        }
        SOC_IF_ERROR_RETURN(READ_XQPORT_MODE_REGr(unit, 42, &rval));
        soc_reg_field_set(unit, XQPORT_MODE_REGr, &rval,
                XQPORT_MODE_BITSf, mode);
        SOC_IF_ERROR_RETURN(WRITE_XQPORT_MODE_REGr(unit, 42, rval));
    }
    if (SOC_PORT_VALID(unit, 46)) {
        switch (dev_id) {
            case BCM56526_DEVICE_ID:
            mode = 2;
            break;
            default:
            mode = 1;
            break;
        }
        SOC_IF_ERROR_RETURN(READ_XQPORT_MODE_REGr(unit, 46, &rval));
        soc_reg_field_set(unit, XQPORT_MODE_REGr, &rval,
                XQPORT_MODE_BITSf, mode);
        SOC_IF_ERROR_RETURN(WRITE_XQPORT_MODE_REGr(unit, 46, rval));
    }
    if (SOC_PORT_VALID(unit, 50)) {
        switch (dev_id) {
            case BCM56639_DEVICE_ID:
            case BCM56638_DEVICE_ID:
            case BCM56636_DEVICE_ID:
            case BCM56526_DEVICE_ID:
            mode = 2;
            break;
            default:
            mode = 1;
            break;
        }
        SOC_IF_ERROR_RETURN(READ_XQPORT_MODE_REGr(unit, 50, &rval));
        soc_reg_field_set(unit, XQPORT_MODE_REGr, &rval,
                XQPORT_MODE_BITSf, mode);
        SOC_IF_ERROR_RETURN(WRITE_XQPORT_MODE_REGr(unit, 50, rval));
    }

    if (soc_property_get(unit, spn_PARITY_ENABLE, TRUE)) {
        _soc_triumph2_parity_enable(unit, TRUE);
        if (soc_feature(unit, soc_feature_esm_support)) {
            SOC_IF_ERROR_RETURN(_soc_triumph2_esm_intr_enable(unit, TRUE));
        }
        if (soc_feature(unit, soc_feature_ser_parity)) {
            SOC_IF_ERROR_RETURN(_soc_triumph2_ser_init(unit));
#ifdef INCLUDE_MEM_SCAN
            soc_mem_scan_ser_list_register(unit, FALSE,
                                           _soc_tr2_ser_parity_info);
#endif /* INCLUDE_MEM_SCAN */
            memset(&_tr2_ser_functions, 0, sizeof(soc_ser_functions_t));
            _tr2_ser_functions._soc_ser_stat_nack_f = &soc_triumph2_stat_nack;
            _tr2_ser_functions._soc_ser_mem_nack_f = &soc_triumph2_mem_nack;
            _tr2_ser_functions._soc_ser_fail_f = &soc_triumph2_ser_fail;
            _tr2_ser_functions._soc_ser_parity_error_intr_f =
                &soc_triumph2_parity_error;
            soc_ser_function_register(unit, &_tr2_ser_functions);
        }
    }


    /* We need the metering clock turned on regardless of parity */
    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &misc_cfg));
    soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg, METERING_CLK_ENf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, misc_cfg));

    /* Enable dual hash on L2, L3 and MPLS_ENTRY tables */
    fields[0] = ENABLEf;
    values[0] = 1;
    fields[1] = HASH_SELECTf;
    values[1] = FB_HASH_CRC32_LOWER;
    fields[2] = INSERT_LEAST_FULL_HALFf;
    values[2] = 1;
    SOC_IF_ERROR_RETURN
    (soc_reg_fields32_modify(unit, L2_AUX_HASH_CONTROLr, REG_PORT_ANY, 3,
                    fields, values));
    SOC_IF_ERROR_RETURN
    (soc_reg_fields32_modify(unit, L3_AUX_HASH_CONTROLr, REG_PORT_ANY, 3,
                    fields, values));
    SOC_IF_ERROR_RETURN
    (soc_reg_field32_modify(unit, MPLS_ENTRY_HASH_CONTROLr, REG_PORT_ANY,
                    INSERT_LEAST_FULL_HALFf, 1));

    /*
     * Egress Enable
     */
    rval = 0;
    soc_reg_field_set(unit, EGR_ENABLEr, &rval, PRT_ENABLEf, 1);
    PBMP_ALL_ITER(unit, port) {
        if ((SOC_PBMP_MEMBER(SOC_PORT_DISABLED_BITMAP(unit,all), port))) {
            continue;
        }
        SOC_IF_ERROR_RETURN(WRITE_EGR_ENABLEr(unit, port, rval));
    }

    COMPILER_64_ZERO(reg64);
    soc_reg64_field32_set(unit, EPC_LINK_BMAP_64r, &reg64, PORT_BITMAP_LOf,
            SOC_PBMP_WORD_GET(PBMP_CMIC(unit), 0));
    soc_reg64_field32_set(unit, EPC_LINK_BMAP_64r, &reg64, PORT_BITMAP_HIf,
            SOC_PBMP_WORD_GET(PBMP_CMIC(unit), 1));
    SOC_IF_ERROR_RETURN(WRITE_EPC_LINK_BMAP_64r(unit, reg64));

    /* GMAC init should be moved to mac */
    rval = 0;
    soc_reg_field_set(unit, GPORT_CONFIGr, &rval, CLR_CNTf, 1);
    prev_reg_addr = 0xffffffff;
    PBMP_GE_ITER(unit, port) {
        uint32 reg_addr;
        reg_addr = soc_reg_addr(unit, GPORT_CONFIGr, port, 0);
        if (reg_addr != prev_reg_addr) {
            SOC_IF_ERROR_RETURN(WRITE_GPORT_CONFIGr(unit, port, rval));
            prev_reg_addr = reg_addr;
        }
    }
    prev_reg_addr = 0xffffffff;
    soc_reg_field_set(unit, GPORT_CONFIGr, &rval, CLR_CNTf, 0);
    PBMP_GE_ITER(unit, port) {
        uint32 reg_addr;
        reg_addr = soc_reg_addr(unit, GPORT_CONFIGr, port, 0);
        if (reg_addr != prev_reg_addr) {
            SOC_IF_ERROR_RETURN(WRITE_GPORT_CONFIGr(unit, port, rval));
            prev_reg_addr = reg_addr;
        }
    }
    /* XMAC init should be moved to mac */
    if (SOC_PBMP_NOT_NULL(PBMP_XE_ALL(unit)) ||
            SOC_PBMP_NOT_NULL(PBMP_HG_ALL(unit))) {
        rval = 0;
        soc_reg_field_set(unit, XPORT_CONFIGr, &rval, XPORT_ENf, 1);
        soc_reg_field_set(unit, XPORT_CONFIGr, &rval, HIGIG_MODEf, 1);
        PBMP_HG_ITER(unit, port) {
            SOC_IF_ERROR_RETURN(WRITE_XPORT_CONFIGr(unit, port, rval));
        }
        soc_reg_field_set(unit, XPORT_CONFIGr, &rval, HIGIG_MODEf, 0);
        PBMP_XE_ITER(unit, port) {
            SOC_IF_ERROR_RETURN(WRITE_XPORT_CONFIGr(unit, port, rval));
        }
    }

    SOC_IF_ERROR_RETURN(READ_ING_CONFIG_64r(unit, &reg64));
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
            L3SRC_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
            L2DST_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
            APPLY_EGR_MASK_ON_L2f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
            APPLY_EGR_MASK_ON_L3f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
            ARP_RARP_TO_FPf, 0x3); /* enable both ARP & RARP */
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
            ARP_VALIDATION_ENf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
            IGNORE_HG_HDR_LAG_FAILOVERf, 1);
    SOC_IF_ERROR_RETURN(WRITE_ING_CONFIG_64r(unit, reg64));

    /* Backwards compatible mirroring by default */
    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, MISCCONFIGr, &rval,
            DRACO_1_5_MIRRORING_MODE_ENf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_ING_CONFIG_64r(unit, &reg64));
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
            DRACO1_5_MIRRORf, 1);
    SOC_IF_ERROR_RETURN(WRITE_ING_CONFIG_64r(unit, reg64));

    SOC_IF_ERROR_RETURN(READ_EGR_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, EGR_CONFIGr, &rval, DRACO1_5_MIRRORf, 1);
    SOC_IF_ERROR_RETURN(WRITE_EGR_CONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_EGR_CONFIG_1r(unit, &rval));
    soc_reg_field_set(unit, EGR_CONFIG_1r, &rval, RING_MODEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_EGR_CONFIG_1r(unit, rval));

    /*
     * Set reference clock (based on 200MHz core clock)
     * to be 200MHz * (1/40) = 5MHz
     */
    divisor = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVISOR, 40);
    dividend = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVIDEND, 1);
    rval = 0;
    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval, DIVISORf, divisor);
    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval, DIVIDENDf, dividend);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUSTr(unit, rval));

    /* Match the Internal MDC freq with above for External MDC */
    rval = 0;
    soc_reg_field_set (unit, CMIC_RATE_ADJUST_INT_MDIOr, &rval, DIVISORf, 40);
    soc_reg_field_set (unit, CMIC_RATE_ADJUST_INT_MDIOr, &rval, DIVIDENDf, 1);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUST_INT_MDIOr(unit, rval));

    /*
     * Set reference clock (based on 200MHz core clock)
     * to be 200MHz * (1/8) = 25MHz
     */
    rval = 0;
    soc_reg_field_set(unit, CMIC_RATE_ADJUST_I2Cr, &rval, DIVISORf, 8);
    soc_reg_field_set(unit, CMIC_RATE_ADJUST_I2Cr, &rval, DIVIDENDf, 1);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUST_I2Cr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_RATE_ADJUST_STDMAr, &rval, DIVISORf, 8);
    soc_reg_field_set(unit, CMIC_RATE_ADJUST_STDMAr, &rval, DIVIDENDf, 1);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUST_STDMAr(unit, rval));

    rval = 0x01; /* 125KHz I2C sampling rate based on 5Mhz reference clock */
    SOC_IF_ERROR_RETURN(WRITE_CMIC_I2C_STATr(unit, rval));

    /* GMAC init should be moved to mac */
    rval = 0;
    soc_reg_field_set(unit, GPORT_CONFIGr, &rval, CLR_CNTf, 1);
    PBMP_GE_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_GPORT_CONFIGr(unit, port, rval));
    }
    soc_reg_field_set(unit, GPORT_CONFIGr, &rval, CLR_CNTf, 0);
    PBMP_GE_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_GPORT_CONFIGr(unit, port, rval));
    }

    /* The HW defaults for EGR_VLAN_CONTROL_1.VT_MISS_UNTAG == 1, which
     * causes the outer tag to be removed from packets that don't have
     * a hit in the egress vlan tranlation table. Set to 0 to disable this.
     */
    rval = 0;
    soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, VT_MISS_UNTAGf, 0);

    /* Enable pri/cfi remarking on egress ports. */
    soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, REMARK_OUTER_DOT1Pf,
            1);
    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1r(unit, port, rval));
    }

    /* Multicast range initialization */
    SOC_IF_ERROR_RETURN
    (soc_hbx_higig2_mcast_sizes_set(unit,
                    soc_property_get(unit, spn_HIGIG2_MULTICAST_VLAN_RANGE,
                            SOC_HBX_MULTICAST_RANGE_DEFAULT),
                    soc_property_get(unit, spn_HIGIG2_MULTICAST_L2_RANGE,
                            SOC_HBX_MULTICAST_RANGE_DEFAULT),
                    soc_property_get(unit, spn_HIGIG2_MULTICAST_L3_RANGE,
                            SOC_HBX_MULTICAST_RANGE_DEFAULT)));

    /* Enable vrf based l3 lookup by default. */
    SOC_IF_ERROR_RETURN
    (soc_reg_field32_modify(unit, VRF_MASKr, REG_PORT_ANY, MASKf, 0));

    /* Setup SW2_FP_DST_ACTION_CONTROL */
    fields[0] = HGTRUNK_RES_ENf;
    fields[1] = LAG_RES_ENf;
    values[0] = values[1] = 1;
    SOC_IF_ERROR_RETURN
    (soc_reg_fields32_modify(unit, SW2_FP_DST_ACTION_CONTROLr,
                    REG_PORT_ANY, 2, fields, values));

    /* Initialize the multipass loopback bitmap to the loopback port */
    COMPILER_64_ZERO(multipass);
    COMPILER_64_ZERO(bm64);
    COMPILER_64_SET(bm64, (1 << 22), 0);
    soc_reg64_field_set(unit, MULTIPASS_LOOPBACK_BITMAP_64r, &multipass,
            BITMAPf, bm64);
    SOC_IF_ERROR_RETURN(WRITE_MULTIPASS_LOOPBACK_BITMAP_64r(unit, multipass));

    /* Use same values as the CAM BIST screen test */
    rval = 0;
    soc_reg_field_set(unit, SW2_RAM_CONTROL_4r, &rval, CPU_COS_MAP_TCAM_TMf,
            0x10);
    SOC_IF_ERROR_RETURN(WRITE_SW2_RAM_CONTROL_4r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, EFP_RAM_CONTROLr, &rval, EFP_CAM_TM_7_THRU_0f,
            0x10);
    SOC_IF_ERROR_RETURN(WRITE_EFP_RAM_CONTROLr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, FP_CAM_CONTROL_TM_7_THRU_0r, &rval,
            ALL_TCAMS_TM_7_0f, 0x10);
    soc_reg_field_set(unit, FP_CAM_CONTROL_TM_7_THRU_0r, &rval,
            ALL_GLOBAL_MASK_TCAMS_TM_7_0f, 0x10);
    SOC_IF_ERROR_RETURN(WRITE_FP_CAM_CONTROL_TM_7_THRU_0r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, L2_USER_ENTRY_CAM_DBGCTRLr, &rval, TMf, 0x10);
    SOC_IF_ERROR_RETURN(WRITE_L2_USER_ENTRY_CAM_DBGCTRLr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, L3_DEFIP_128_CAM_DBGCTRLr, &rval, CAM0_TMf, 0x10);
    soc_reg_field_set(unit, L3_DEFIP_128_CAM_DBGCTRLr, &rval, CAM1_TMf, 0x10);
    SOC_IF_ERROR_RETURN(WRITE_L3_DEFIP_128_CAM_DBGCTRLr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, L3_DEFIP_CAM_DBGCTRL0r, &rval, CAM0_TMf, 0x10);
    soc_reg_field_set(unit, L3_DEFIP_CAM_DBGCTRL0r, &rval, CAM1_TMf, 0x10);
    SOC_IF_ERROR_RETURN(WRITE_L3_DEFIP_CAM_DBGCTRL0r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, L3_DEFIP_CAM_DBGCTRL1r, &rval, CAM2_TMf, 0x10);
    soc_reg_field_set(unit, L3_DEFIP_CAM_DBGCTRL1r, &rval, CAM3_TMf, 0x10);
    SOC_IF_ERROR_RETURN(WRITE_L3_DEFIP_CAM_DBGCTRL1r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, L3_DEFIP_CAM_DBGCTRL2r, &rval, CAM4_TMf, 0x10);
    soc_reg_field_set(unit, L3_DEFIP_CAM_DBGCTRL2r, &rval, CAM5_TMf, 0x10);
    SOC_IF_ERROR_RETURN(WRITE_L3_DEFIP_CAM_DBGCTRL2r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, L3_DEFIP_CAM_DBGCTRL3r, &rval, CAM6_TMf, 0x10);
    soc_reg_field_set(unit, L3_DEFIP_CAM_DBGCTRL3r, &rval, CAM7_TMf, 0x10);
    SOC_IF_ERROR_RETURN(WRITE_L3_DEFIP_CAM_DBGCTRL3r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, MPLS_STATION_CAM_DBGCTRLr, &rval, CAM0_TMf, 0x10);
    SOC_IF_ERROR_RETURN(WRITE_MPLS_STATION_CAM_DBGCTRLr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, UDF_CAM_DBGCTRLr, &rval, TMf, 0x10);
    SOC_IF_ERROR_RETURN(WRITE_UDF_CAM_DBGCTRLr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, VFP_CAM_CONTROL_TM_7_THRU_0r, &rval, TMf, 0x10);
    SOC_IF_ERROR_RETURN(WRITE_VFP_CAM_CONTROL_TM_7_THRU_0r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, VLAN_SUBNET_CAM_DBGCTRLr, &rval, TMf, 0x10);
    SOC_IF_ERROR_RETURN(WRITE_VLAN_SUBNET_CAM_DBGCTRLr(unit, rval));

    /* Cache LMEP table */
    SOC_IF_ERROR_RETURN(soc_mem_cache_set(unit, LMEPm, MEM_BLOCK_ALL, TRUE));

    SOC_IF_ERROR_RETURN(soc_generic_ser_mem_scan_start(unit));

    soc_ser_log_init(unit, NULL, 0);

    return SOC_E_NONE;
}

#define TR2_MMU_NUM_PG   8
#define TR2_MMU_NUM_COS  8

/* Standard Ethernet MTU, 1536 bytes (1 cell = 128 bytes) */
#define TR2_MMU_ETH_FRAME_CELLS  12

/* Jumbo Frame MTU, 9216 (1 cell = 128 bytes) */
#define TR2_MMU_JUMBO_FRAME_CELLS  72

/* MAX Frame MTU, 16384 (1 cell = 128 bytes) */
#define TR2_MMU_MAX_FRAME_CELLS  128

#define TR2_MMU_IN_PORT_MIN_CELLS       72
#define TR2_MMU_IN_PORT_MIN_PKTS        1
#define TR2_MMU_PG_HDRM_LIMIT_CELLS     36
#define TR2_MMU_PG_HDRM_LIMIT_PKTS      36
#define TR2_MMU_GLOBAL_HDRM_LIMIT_CELLS 636
#define TR2_MMU_PG_RESET_OFFSET_CELLS   24
#define TR2_MMU_PG_RESET_OFFSET_PKTS    1

#define TR2_MMU_OUT_PORT_MIN_CELLS      12
#define TR2_MMU_OUT_PORT_MIN_PKTS       1
#define TR2_MMU_OUT_RESET_OFFSET_CELLS  24
#define TR2_MMU_OUT_RESET_OFFSET_PKTS   2
#define TR2_MMU_SOP_POLICY              0
#define TR2_MMU_MOP_POLICY              7

int
soc_triumph2_mmu_init(int unit)
{
    uint64 rval64;
    uint32 rval, rval0, rval1, cell_rval, pkt_rval, disc_set;
    uint16 dev_id;
    uint8 rev_id;
    int port;
    int total_cells, total_pkts;
    int in_reserved_cells, in_reserved_pkts;
    int out_reserved_cells, out_reserved_pkts;
    int out_shared_cells, out_shared_pkts;
    int idx, sum_all_ports, count;
    soc_pbmp_t pbmp_8pg, pbmp_2pg, temp;

    soc_cm_get_id(unit, &dev_id, &rev_id);
    /* Total number of cells */
    if ((SOC_IS_APOLLO(unit) || SOC_IS_VALKYRIE2(unit)) &&
            (dev_id != BCM56534_DEVICE_ID) && (dev_id != BCM56630_DEVICE_ID)) {
        total_cells = 24 * 1024; /* 24K cells */
    } else {
        total_cells = 32 * 1024; /* 32K cells */
    }

    /* Total number of packet pointers */
    total_pkts = 11 * 1024; /* 11K packet pointers */

    /* 8PG_PORTS = [26..30,34,38,42,46,50,54] */
    SOC_PBMP_CLEAR(pbmp_8pg);
    SOC_PBMP_PORT_ADD(pbmp_8pg, 26);
    SOC_PBMP_PORT_ADD(pbmp_8pg, 27);
    SOC_PBMP_PORT_ADD(pbmp_8pg, 28);
    SOC_PBMP_PORT_ADD(pbmp_8pg, 29);
    SOC_PBMP_PORT_ADD(pbmp_8pg, 30);
    SOC_PBMP_PORT_ADD(pbmp_8pg, 34);
    SOC_PBMP_PORT_ADD(pbmp_8pg, 38);
    SOC_PBMP_PORT_ADD(pbmp_8pg, 42);
    SOC_PBMP_PORT_ADD(pbmp_8pg, 46);
    SOC_PBMP_PORT_ADD(pbmp_8pg, 50);
    if (soc_feature(unit, soc_feature_internal_loopback)) {
        SOC_PBMP_PORT_ADD(pbmp_8pg, 54);
    }
    SOC_PBMP_AND(pbmp_8pg, PBMP_ALL(unit));

    /* 2PG_PORTS = [0,1..25,31..33,35..37,39..41,43..45,47..49,51..53,55,56] */
    SOC_PBMP_CLEAR(pbmp_2pg);
    SOC_PBMP_ASSIGN(pbmp_2pg, PBMP_ALL(unit));
    SOC_PBMP_PORT_REMOVE(pbmp_2pg, 26);
    SOC_PBMP_PORT_REMOVE(pbmp_2pg, 27);
    SOC_PBMP_PORT_REMOVE(pbmp_2pg, 28);
    SOC_PBMP_PORT_REMOVE(pbmp_2pg, 29);
    SOC_PBMP_PORT_REMOVE(pbmp_2pg, 30);
    SOC_PBMP_PORT_REMOVE(pbmp_2pg, 34);
    SOC_PBMP_PORT_REMOVE(pbmp_2pg, 38);
    SOC_PBMP_PORT_REMOVE(pbmp_2pg, 42);
    SOC_PBMP_PORT_REMOVE(pbmp_2pg, 46);
    SOC_PBMP_PORT_REMOVE(pbmp_2pg, 50);
    SOC_PBMP_PORT_REMOVE(pbmp_2pg, 54);
    if (soc_feature(unit, soc_feature_internal_loopback)) {
        if (soc_feature(unit, soc_feature_wlan)) {
            SOC_PBMP_PORT_ADD(pbmp_2pg, 55);
        }
        SOC_PBMP_PORT_ADD(pbmp_2pg, 56);
    }

    /*
     * Reserved space calculation:
     *   Input port:
     *     per-port minimum
     *     per-PG minimum (config to 0)
     *     per-PG headroom
     *     per-device headroom
     *     per-port minimum for SC and QM traffic (config to 0)
     *   Output port:
     *     per-port per-COS minimum space
     * Shared space calculation:
     *   Input port: total - input port reserved - output port reserved
     *   Output port: total - output port reserved
     */
    if (soc_feature(unit, soc_feature_internal_loopback)) {
        if (soc_feature(unit, soc_feature_wlan)) {
            sum_all_ports = NUM_ALL_PORT(unit) + 2; /* including 55 and 56 */
        } else {
            sum_all_ports = NUM_ALL_PORT(unit) + 1; /* including 56 only */
        }
    } else {
        sum_all_ports = NUM_ALL_PORT(unit); /* no loopback */
    }
    in_reserved_cells = sum_all_ports * TR2_MMU_IN_PORT_MIN_CELLS +
    (sum_all_ports - 1) * TR2_MMU_PG_HDRM_LIMIT_CELLS +
    TR2_MMU_GLOBAL_HDRM_LIMIT_CELLS;
    in_reserved_pkts = sum_all_ports * TR2_MMU_IN_PORT_MIN_PKTS +
    (sum_all_ports - 1) * TR2_MMU_PG_HDRM_LIMIT_PKTS;
    out_reserved_cells =
    (NUM_PORT(unit) * TR2_MMU_NUM_COS + SOC_INFO(unit).num_cpu_cosq) *
    TR2_MMU_OUT_PORT_MIN_CELLS;
    out_reserved_pkts =
    (NUM_PORT(unit) * TR2_MMU_NUM_COS + SOC_INFO(unit).num_cpu_cosq) *
    TR2_MMU_OUT_PORT_MIN_PKTS;

    /*
     * Input ports threshold
     */
    /* Reserved space: Input port per-port minimum */
    cell_rval = 0;
    soc_reg_field_set(unit, PORT_MIN_CELLr, &cell_rval, PORT_MINf,
            TR2_MMU_IN_PORT_MIN_CELLS);
    pkt_rval = 0;
    soc_reg_field_set(unit, PORT_MIN_PACKETr, &pkt_rval, PORT_MINf,
            TR2_MMU_IN_PORT_MIN_PKTS);
    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_PORT_MIN_CELLr(unit, port, cell_rval));
        SOC_IF_ERROR_RETURN(WRITE_PORT_MIN_PACKETr(unit, port, pkt_rval));
    }
    if (soc_feature(unit, soc_feature_internal_loopback)) {
        /* Redirect port */
        SOC_IF_ERROR_RETURN(WRITE_PORT_MIN_CELLr(unit, 56, cell_rval));
        SOC_IF_ERROR_RETURN(WRITE_PORT_MIN_PACKETr(unit, 56, pkt_rval));
        rval = 0;
        soc_reg_field_set(unit, RDE_PORT_SHARED_LIMIT_PACKETr, &rval,
                PORT_SHARED_LIMITf, 1024);
        SOC_IF_ERROR_RETURN(WRITE_RDE_PORT_SHARED_LIMIT_PACKETr(unit, rval));
        rval = 0;
        soc_reg_field_set(unit, PG_RDE_RESET_OFFSET_PACKETr, &rval,
                PG_RESET_OFFSETf, 4);
        SOC_IF_ERROR_RETURN(WRITE_PG_RDE_RESET_OFFSET_PACKETr(unit, 0, rval));
        SOC_IF_ERROR_RETURN(WRITE_PG_RDE_RESET_OFFSET_PACKETr(unit, 1, rval));
        rval = 0;
        soc_reg_field_set(unit, PG_RDE_THRESH_SEL2r, &rval,
                PG0_THRESH_SELf, 8);
        SOC_IF_ERROR_RETURN(WRITE_PG_RDE_THRESH_SEL2r(unit, rval));
        /* PG_RDE_MIN_PACKET = 0 : default */
        /* WLAN port */
        if (soc_feature(unit, soc_feature_wlan)) {
            SOC_IF_ERROR_RETURN(WRITE_PORT_MIN_CELLr(unit, 55, cell_rval));
            SOC_IF_ERROR_RETURN(WRITE_PORT_MIN_PACKETr(unit, 55, pkt_rval));
            rval = 0;
            soc_reg_field_set(unit, WL_PORT_SHARED_LIMIT_CELLr, &rval,
                    PORT_SHARED_LIMITf, 8192);
            SOC_IF_ERROR_RETURN(WRITE_WL_PORT_SHARED_LIMIT_CELLr(unit, rval));
            rval = 0;
            soc_reg_field_set(unit, WL_PORT_SHARED_LIMIT_PACKETr, &rval,
                    PORT_SHARED_LIMITf, 2048);
            SOC_IF_ERROR_RETURN(WRITE_WL_PORT_SHARED_LIMIT_PACKETr(unit, rval));
            rval = 0;
            soc_reg_field_set(unit, PG_WL_RESET_OFFSET_CELLr, &rval,
                    PG_RESET_OFFSETf, 4);
            SOC_IF_ERROR_RETURN(WRITE_PG_WL_RESET_OFFSET_CELLr(unit, 0, rval));
            SOC_IF_ERROR_RETURN(WRITE_PG_WL_RESET_OFFSET_CELLr(unit, 1, rval));
            rval = 0;
            soc_reg_field_set(unit, PG_WL_RESET_OFFSET_PACKETr, &rval,
                    PG_RESET_OFFSETf, 4);
            SOC_IF_ERROR_RETURN
            (WRITE_PG_WL_RESET_OFFSET_PACKETr(unit, 0, rval));
            SOC_IF_ERROR_RETURN
            (WRITE_PG_WL_RESET_OFFSET_PACKETr(unit, 1, rval));
            rval = 0;
            soc_reg_field_set(unit, WL_DROP_POLICYr, &rval,
                    DROP_PG0_1ST_FRAGMENTf, 1);
            soc_reg_field_set(unit, WL_DROP_POLICYr, &rval,
                    DROP_PG0_ANY_FRAGMENTf, 1);
            soc_reg_field_set(unit, WL_DROP_POLICYr, &rval,
                    DROP_PG0_NON_FRAGMENTf, 1);
            SOC_IF_ERROR_RETURN(WRITE_WL_DROP_POLICYr(unit, rval));
        }
    }

    /* Reserved space: Input port per-PG minimum
     * Use defalt value 0
     * With only one PG in use PORT_MIN should be sufficient */

    /* PG_WL_RESET_FLOOR_CELL, PG_WL_MIN_CELL and PG_WL_MIN_PACKET
     * are zeroes (default) */

    /* Reserved space: Input port per-PG headroom
     * Use only 1PG (highest priority PG for the port) */
    cell_rval = 0;
    soc_reg_field_set(unit, PG_HDRM_LIMIT_CELLr, &cell_rval, PG_HDRM_LIMITf,
            TR2_MMU_PG_HDRM_LIMIT_CELLS);
    soc_reg_field_set(unit, PG_HDRM_LIMIT_CELLr, &cell_rval, PG_GEf, 1);
    pkt_rval = 0;
    soc_reg_field_set(unit, PG_HDRM_LIMIT_PACKETr, &pkt_rval, PG_HDRM_LIMITf,
            TR2_MMU_PG_HDRM_LIMIT_PKTS);
    PBMP_PORT_ITER(unit, port) {
        idx = SOC_PBMP_MEMBER(pbmp_8pg, port) ? TR2_MMU_NUM_PG - 1 : 1;
        SOC_IF_ERROR_RETURN(WRITE_PG_HDRM_LIMIT_CELLr(unit, port, idx,
                        cell_rval));
        SOC_IF_ERROR_RETURN(WRITE_PG_HDRM_LIMIT_PACKETr(unit, port, idx,
                        pkt_rval));
    }
    if (soc_feature(unit, soc_feature_internal_loopback)) {
        /* Loopback ingress */
        idx = TR2_MMU_NUM_PG - 1;
        SOC_IF_ERROR_RETURN(WRITE_PG_HDRM_LIMIT_CELLr(unit, 54, idx,
                        cell_rval));
        SOC_IF_ERROR_RETURN(WRITE_PG_HDRM_LIMIT_PACKETr(unit, 54, idx,
                        pkt_rval));
        /* EP redirection */
        SOC_IF_ERROR_RETURN(WRITE_PG_HDRM_LIMIT_CELLr(unit, 56, 1,
                        cell_rval));
        SOC_IF_ERROR_RETURN(WRITE_PG_HDRM_LIMIT_PACKETr(unit, 56, 1,
                        pkt_rval));
        /* WLAN */
        if (soc_feature(unit, soc_feature_wlan)) {
            SOC_IF_ERROR_RETURN(WRITE_PG_HDRM_LIMIT_CELLr(unit, 55, 1,
                            cell_rval));
            SOC_IF_ERROR_RETURN(WRITE_PG_HDRM_LIMIT_PACKETr(unit, 55, 1,
                            pkt_rval));
        }
    }

    /* Reserved space: Input port per-device headroom */
    cell_rval = 0;
    soc_reg_field_set(unit, GLOBAL_HDRM_LIMITr, &cell_rval, GLOBAL_HDRM_LIMITf,
            TR2_MMU_GLOBAL_HDRM_LIMIT_CELLS);
    SOC_IF_ERROR_RETURN(WRITE_GLOBAL_HDRM_LIMITr(unit, cell_rval));

    /* Input port shared space - same as service pool zero */
    cell_rval = 0;
    soc_reg_field_set(unit, BUFFER_CELL_LIMIT_SPr, &cell_rval, LIMITf,
            total_cells - in_reserved_cells - out_reserved_cells);
    SOC_IF_ERROR_RETURN(WRITE_BUFFER_CELL_LIMIT_SPr(unit, 0, cell_rval));
    pkt_rval = 0;
    soc_reg_field_set(unit, BUFFER_PACKET_LIMIT_SPr, &pkt_rval, LIMITf,
            total_pkts - in_reserved_pkts - out_reserved_pkts);
    SOC_IF_ERROR_RETURN(WRITE_BUFFER_PACKET_LIMIT_SPr(unit, 0, pkt_rval));

    /* Input port per-port shared space limit - no limit */
    cell_rval = 0;
    soc_reg_field_set(unit, PORT_SHARED_LIMIT_CELLr, &cell_rval,
            PORT_SHARED_LIMITf, total_cells - 1);
    pkt_rval = 0;
    soc_reg_field_set(unit, PORT_SHARED_LIMIT_PACKETr, &pkt_rval,
            PORT_SHARED_LIMITf, total_pkts - 1);
    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_PORT_SHARED_LIMIT_CELLr(unit, port,
                        cell_rval));
        SOC_IF_ERROR_RETURN(WRITE_PORT_SHARED_LIMIT_PACKETr(unit, port,
                        pkt_rval));
    }
    if (soc_feature(unit, soc_feature_internal_loopback)) {
        /* EP redirection */
        SOC_IF_ERROR_RETURN(WRITE_PORT_SHARED_LIMIT_CELLr(unit, 56,
                        cell_rval));
        SOC_IF_ERROR_RETURN(WRITE_PORT_SHARED_LIMIT_PACKETr(unit, 56,
                        pkt_rval));
        /* WLAN */
        if (soc_feature(unit, soc_feature_wlan)) {
            SOC_IF_ERROR_RETURN(WRITE_PORT_SHARED_LIMIT_CELLr(unit, 55,
                            cell_rval));
            SOC_IF_ERROR_RETURN(WRITE_PORT_SHARED_LIMIT_PACKETr(unit, 55,
                            pkt_rval));
        }
    }

    /* Input port per-PG reset offset
     * Use only 1PG (highest priority PG for the port)
     * Use default value 0 for CPU */
    cell_rval = 0;
    soc_reg_field_set(unit, PG_RESET_OFFSET_CELLr, &cell_rval,
            PG_RESET_OFFSETf, TR2_MMU_PG_RESET_OFFSET_CELLS);
    pkt_rval = 0;
    soc_reg_field_set(unit, PG_RESET_OFFSET_PACKETr, &pkt_rval,
            PG_RESET_OFFSETf, TR2_MMU_PG_RESET_OFFSET_PKTS);
    PBMP_PORT_ITER(unit, port) {
        idx = SOC_PBMP_MEMBER(pbmp_8pg, port) ? TR2_MMU_NUM_PG - 1 : 1;
        SOC_IF_ERROR_RETURN(WRITE_PG_RESET_OFFSET_CELLr(unit, port, idx,
                        cell_rval));
        SOC_IF_ERROR_RETURN(WRITE_PG_RESET_OFFSET_PACKETr(unit, port, idx,
                        pkt_rval));
    }
    if (soc_feature(unit, soc_feature_internal_loopback)) {
        /* Loopback ingress */
        idx = TR2_MMU_NUM_PG - 1;
        SOC_IF_ERROR_RETURN(WRITE_PG_RESET_OFFSET_CELLr(unit, 54, idx,
                        cell_rval));
        SOC_IF_ERROR_RETURN(WRITE_PG_RESET_OFFSET_PACKETr(unit, 54, idx,
                        pkt_rval));
        /* EP redirection */
        SOC_IF_ERROR_RETURN(WRITE_PG_RESET_OFFSET_CELLr(unit, 56, 1,
                        cell_rval));
        SOC_IF_ERROR_RETURN(WRITE_PG_RESET_OFFSET_PACKETr(unit, 56, 1,
                        pkt_rval));
        /* WLAN */
        if (soc_feature(unit, soc_feature_wlan)) {
            SOC_IF_ERROR_RETURN(WRITE_PG_RESET_OFFSET_CELLr(unit, 55, 1,
                            cell_rval));
            SOC_IF_ERROR_RETURN(WRITE_PG_RESET_OFFSET_PACKETr(unit, 55, 1,
                            pkt_rval));
        }
    }

    /* Input port per-PG reset floor (cell). Use default value 0 */

    /* Input port priority XON disable */

    /* Input port max packet size in cells */
    rval0 = 0;
    soc_reg_field_set(unit, PORT_MAX_PKT_SIZEr, &rval0, PORT_MAX_PKT_SIZEf,
            TR2_MMU_JUMBO_FRAME_CELLS);
    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_PORT_MAX_PKT_SIZEr(unit, port, rval0));
    }
    /* WLAN */
    if (soc_feature(unit, soc_feature_wlan)) {
        SOC_IF_ERROR_RETURN(WRITE_PORT_MAX_PKT_SIZEr(unit, 55, rval0));
    }

    /* Input port per-PG threshold */
    rval0 = 0;
    soc_reg_field_set(unit, PG_THRESH_SELr, &rval0, PG0_THRESH_SELf, 0x8);
    soc_reg_field_set(unit, PG_THRESH_SELr, &rval0, PG1_THRESH_SELf, 0x8);
    soc_reg_field_set(unit, PG_THRESH_SELr, &rval0, PG2_THRESH_SELf, 0x8);
    soc_reg_field_set(unit, PG_THRESH_SELr, &rval0, PG3_THRESH_SELf, 0x8);
    soc_reg_field_set(unit, PG_THRESH_SELr, &rval0, PG4_THRESH_SELf, 0x8);
    soc_reg_field_set(unit, PG_THRESH_SELr, &rval0, PG5_THRESH_SELf, 0x8);
    soc_reg_field_set(unit, PG_THRESH_SELr, &rval0, PG6_THRESH_SELf, 0x8);
    PBMP_ITER(pbmp_8pg, port) {
        SOC_IF_ERROR_RETURN(WRITE_PG_THRESH_SELr(unit, port, rval0));
    }
    rval0 = 0;
    soc_reg_field_set(unit, PG_THRESH_SEL2r, &rval0, PG0_THRESH_SELf, 0x8);
    PBMP_ITER(pbmp_2pg, port) {
        SOC_IF_ERROR_RETURN(WRITE_PG_THRESH_SEL2r(unit, port, rval0));
    }

    idx = TR2_MMU_NUM_PG - 1;
    rval0 = 0;
    soc_reg_field_set(unit, PORT_PRI_GRP0r, &rval0, PRI0_GRPf, idx);
    soc_reg_field_set(unit, PORT_PRI_GRP0r, &rval0, PRI1_GRPf, idx);
    soc_reg_field_set(unit, PORT_PRI_GRP0r, &rval0, PRI2_GRPf, idx);
    soc_reg_field_set(unit, PORT_PRI_GRP0r, &rval0, PRI3_GRPf, idx);
    soc_reg_field_set(unit, PORT_PRI_GRP0r, &rval0, PRI4_GRPf, idx);
    soc_reg_field_set(unit, PORT_PRI_GRP0r, &rval0, PRI5_GRPf, idx);
    soc_reg_field_set(unit, PORT_PRI_GRP0r, &rval0, PRI6_GRPf, idx);
    soc_reg_field_set(unit, PORT_PRI_GRP0r, &rval0, PRI7_GRPf, idx);
    rval1 = 0;
    soc_reg_field_set(unit, PORT_PRI_GRP1r, &rval1, PRI8_GRPf, idx);
    soc_reg_field_set(unit, PORT_PRI_GRP1r, &rval1, PRI9_GRPf, idx);
    soc_reg_field_set(unit, PORT_PRI_GRP1r, &rval1, PRI10_GRPf, idx);
    soc_reg_field_set(unit, PORT_PRI_GRP1r, &rval1, PRI11_GRPf, idx);
    soc_reg_field_set(unit, PORT_PRI_GRP1r, &rval1, PRI12_GRPf, idx);
    soc_reg_field_set(unit, PORT_PRI_GRP1r, &rval1, PRI13_GRPf, idx);
    soc_reg_field_set(unit, PORT_PRI_GRP1r, &rval1, PRI14_GRPf, idx);
    soc_reg_field_set(unit, PORT_PRI_GRP1r, &rval1, PRI15_GRPf, idx);
    PBMP_ITER(pbmp_8pg, port) {
        SOC_IF_ERROR_RETURN(WRITE_PORT_PRI_GRP0r(unit, port, rval0));
        SOC_IF_ERROR_RETURN(WRITE_PORT_PRI_GRP1r(unit, port, rval1));
    }

    rval0 = 0;
    soc_reg_field_set(unit, PORT_PRI_GRP2r, &rval0, PRI_GRPf, 0xffff);
    PBMP_ITER(pbmp_2pg, port) {
        SOC_IF_ERROR_RETURN(WRITE_PORT_PRI_GRP2r(unit, port, rval0));
    }

    /* Input port pause enable */
    COMPILER_64_ZERO(rval64);
    soc_reg64_field32_set(unit, PORT_PAUSE_ENABLE_64r, &rval64,
            PORT_PAUSE_ENABLE_LOf,
            SOC_PBMP_WORD_GET(PBMP_ALL(unit), 0));
    soc_reg64_field32_set(unit, PORT_PAUSE_ENABLE_64r, &rval64,
            PORT_PAUSE_ENABLE_HIf,
            SOC_PBMP_WORD_GET(PBMP_ALL(unit), 1));
    SOC_IF_ERROR_RETURN(WRITE_PORT_PAUSE_ENABLE_64r(unit, rval64));

    /*
     * Output ports threshold
     */
    /* Reserved space: Output port per-port per-COS minimum space */
    cell_rval = 0;
    soc_reg_field_set(unit, OP_QUEUE_CONFIG_CELLr, &cell_rval, Q_MIN_CELLf,
            TR2_MMU_OUT_PORT_MIN_CELLS);
    soc_reg_field_set(unit, OP_QUEUE_CONFIG_CELLr, &cell_rval,
            Q_LIMIT_ENABLE_CELLf, 0x1);
    soc_reg_field_set(unit, OP_QUEUE_CONFIG_CELLr, &cell_rval,
            Q_LIMIT_DYNAMIC_CELLf, 0x1);
    soc_reg_field_set(unit, OP_QUEUE_CONFIG_CELLr, &cell_rval,
            Q_SHARED_LIMIT_CELLf, 2); /* alpha index 2 */
    pkt_rval = 0;
    soc_reg_field_set(unit, OP_QUEUE_CONFIG_PACKETr, &pkt_rval, Q_MIN_PACKETf,
            TR2_MMU_OUT_PORT_MIN_PKTS);
    soc_reg_field_set(unit, OP_QUEUE_CONFIG_PACKETr, &pkt_rval,
            Q_LIMIT_ENABLE_PACKETf, 0x1);
    soc_reg_field_set(unit, OP_QUEUE_CONFIG_PACKETr, &pkt_rval,
            Q_LIMIT_DYNAMIC_PACKETf, 0x1);
    soc_reg_field_set(unit, OP_QUEUE_CONFIG_PACKETr, &pkt_rval,
            Q_SHARED_LIMIT_PACKETf, 2); /* alpha index 2 */
    PBMP_ALL_ITER(unit, port) {
        count = IS_CPU_PORT(unit, port) ?
        SOC_INFO(unit).num_cpu_cosq : TR2_MMU_NUM_COS;
        for (idx = 0; idx < count; idx++) {
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_CELLr(unit, port, idx,
                            cell_rval));
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_PACKETr(unit, port, idx,
                            pkt_rval));
        }
    }
    if (soc_feature(unit, soc_feature_internal_loopback)) {
        /* EP redirection */
        pkt_rval = 0;
        soc_reg_field_set(unit, OP_QUEUE_REDIRECT_XQ_CONFIG_PACKETr, &pkt_rval,
                Q_MIN_PACKETf, TR2_MMU_OUT_PORT_MIN_PKTS);
        soc_reg_field_set(unit, OP_QUEUE_REDIRECT_XQ_CONFIG_PACKETr, &pkt_rval,
                Q_LIMIT_DYNAMIC_PACKETf, 0x1);
        soc_reg_field_set(unit, OP_QUEUE_REDIRECT_XQ_CONFIG_PACKETr, &pkt_rval,
                Q_SHARED_ALPHA_PACKETf, 2); /* alpha index 2 */
        rval = 0;
        soc_reg_field_set(unit, OP_QUEUE_REDIRECT_CONFIG_PACKETr, &rval,
                Q_MIN_PACKETf, TR2_MMU_OUT_PORT_MIN_PKTS);
        soc_reg_field_set(unit, OP_QUEUE_REDIRECT_CONFIG_PACKETr, &rval,
                Q_LIMIT_DYNAMIC_PACKETf, 0x1);
        soc_reg_field_set(unit, OP_QUEUE_REDIRECT_CONFIG_PACKETr, &rval,
                Q_SHARED_ALPHA_PACKETf, 2); /* alpha index 2 */
        cell_rval = 0;
        soc_reg_field_set(unit, OP_QUEUE_REDIRECT_CONFIG_CELLr, &cell_rval,
                Q_MIN_CELLf, TR2_MMU_OUT_PORT_MIN_CELLS);
        soc_reg_field_set(unit, OP_QUEUE_REDIRECT_CONFIG_CELLr, &cell_rval,
                Q_LIMIT_DYNAMIC_CELLf, 0x1);
        soc_reg_field_set(unit, OP_QUEUE_REDIRECT_CONFIG_CELLr, &cell_rval,
                Q_SHARED_ALPHA_CELLf, 2); /* alpha index 2 */

        for (idx = 0; idx < TR2_MMU_NUM_COS; idx++) {
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_REDIRECT_XQ_CONFIG_PACKETr
                    (unit, 54, idx, pkt_rval));
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_REDIRECT_CONFIG_PACKETr
                    (unit, 54, idx, rval));
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_REDIRECT_CONFIG_CELLr
                    (unit, 54, idx, cell_rval));
        }
        /* WLAN */
        if (soc_feature(unit, soc_feature_wlan)) {
            /* Max out (disable) first fragment shared limits */
            cell_rval = (1 << soc_reg_field_length(unit,
                            OP_QUEUE_FIRST_FRAGMENT_CONFIG_CELLr,
                            Q_SHARED_LIMIT_CELLf)) - 1;
            pkt_rval = (1 << soc_reg_field_length(unit,
                            OP_QUEUE_FIRST_FRAGMENT_CONFIG_PACKETr,
                            Q_SHARED_LIMIT_PACKETf)) - 1;
            for (idx = 0; idx < TR2_MMU_NUM_COS; idx++) {
                SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_FIRST_FRAGMENT_CONFIG_PACKETr
                        (unit, 54, idx, pkt_rval));
                SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_FIRST_FRAGMENT_CONFIG_CELLr
                        (unit, 54, idx, cell_rval));
            }
        }

        /*
         * dedicate resource for EFP copy / True egress mirror
         */
        pkt_rval = 0;

        /*
         * 1k XQ pointer, dedicated resource for ep redirect
         */
        disc_set = 1024 - (TR2_MMU_OUT_PORT_MIN_PKTS * TR2_MMU_NUM_COS);
        soc_reg_field_set(unit, OP_PORT_REDIRECT_XQ_DISC_SET_THD_PACKETr,
                &pkt_rval, DISCARD_SET_THD_PACKETf, disc_set);
        SOC_IF_ERROR_RETURN(WRITE_OP_PORT_REDIRECT_XQ_DISC_SET_THD_PACKETr
                (unit, 54, pkt_rval));

        pkt_rval = 0;
        soc_reg_field_set(unit, OP_PORT_REDIRECT_XQ_DISC_RESUME_THD_PACKETr,
                &pkt_rval, DISCARD_RESUME_THD_PACKETf, (disc_set - 50));
        SOC_IF_ERROR_RETURN(WRITE_OP_PORT_REDIRECT_XQ_DISC_RESUME_THD_PACKETr
                (unit, 54, pkt_rval));

        /*
         * 1k pointers, dedicated resource for internal loopback
         */
        pkt_rval = 0;
        soc_reg_field_set(unit, OP_PORT_REDIRECT_DISC_SET_THD_PACKETr,
                &pkt_rval, DISCARD_SET_THD_PACKETf, disc_set);
        SOC_IF_ERROR_RETURN(WRITE_OP_PORT_REDIRECT_DISC_SET_THD_PACKETr
                (unit, 54, pkt_rval));

        pkt_rval = 0;
        soc_reg_field_set(unit, OP_PORT_REDIRECT_DISC_RESUME_THD_PACKETr,
                &pkt_rval, DISCARD_RESUME_THD_PACKETf, (disc_set - 50));
        SOC_IF_ERROR_RETURN(WRITE_OP_PORT_REDIRECT_DISC_RESUME_THD_PACKETr
                (unit, 54, pkt_rval));

        pkt_rval = 0;
        disc_set = (512 * 1024) - (TR2_MMU_OUT_PORT_MIN_CELLS * TR2_MMU_NUM_COS);
        soc_reg_field_set(unit, OP_PORT_REDIRECT_DISC_SET_THD_CELLr,
                &pkt_rval, DISCARD_SET_THD_CELLf, disc_set/128);
        SOC_IF_ERROR_RETURN(WRITE_OP_PORT_REDIRECT_DISC_SET_THD_CELLr
                (unit, 54, pkt_rval));

        pkt_rval = 0;
        soc_reg_field_set(unit, OP_PORT_REDIRECT_DISC_RESUME_THD_CELLr,
                &pkt_rval, DISCARD_RESUME_THD_CELLf, (disc_set - (16 * 1024))/128);
        SOC_IF_ERROR_RETURN(WRITE_OP_PORT_REDIRECT_DISC_RESUME_THD_CELLr
                (unit, 54, pkt_rval));
    }

    /* Output port per-port per-COS reset offset */
    cell_rval = 0;
    soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_CELLr, &cell_rval,
            Q_RESET_OFFSET_CELLf, TR2_MMU_OUT_RESET_OFFSET_CELLS);
    pkt_rval = 0;
    soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_PACKETr, &pkt_rval,
            Q_RESET_OFFSET_PACKETf, TR2_MMU_OUT_RESET_OFFSET_PKTS);
    PBMP_ALL_ITER(unit, port) {
        count = IS_CPU_PORT(unit, port) ?
        SOC_INFO(unit).num_cpu_cosq : TR2_MMU_NUM_COS;
        for (idx = 0; idx < count; idx++) {
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_RESET_OFFSET_CELLr(unit, port,
                            idx,
                            cell_rval));
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_RESET_OFFSET_PACKETr(unit, port,
                            idx,
                            pkt_rval));
        }
    }

    out_shared_cells = total_cells - out_reserved_cells;
    out_shared_pkts = total_pkts - out_reserved_pkts;

    /* Output port per-device shared */
    cell_rval = 0;
    soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_CELLr, &cell_rval,
            OP_BUFFER_SHARED_LIMIT_CELLf, out_shared_cells);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_CELLr(unit, cell_rval));
    pkt_rval = 0;
    soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_PACKETr, &pkt_rval,
            OP_BUFFER_SHARED_LIMIT_PACKETf, out_shared_pkts);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_PACKETr(unit, pkt_rval));

    /* Output port per-device shared for YELLOW traffic */
    cell_rval = 0;
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_YELLOW_CELLr, &cell_rval,
            OP_BUFFER_LIMIT_YELLOW_CELLf, out_shared_cells >> 3);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_YELLOW_CELLr(unit, cell_rval));
    pkt_rval = 0;
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_YELLOW_PACKETr, &pkt_rval,
            OP_BUFFER_LIMIT_YELLOW_PACKETf, out_shared_pkts >> 3);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_YELLOW_PACKETr(unit, pkt_rval));

    /* Output port per-device shared for RED traffic */
    cell_rval = 0;
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_RED_CELLr, &cell_rval,
            OP_BUFFER_LIMIT_RED_CELLf, out_shared_cells >> 3);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RED_CELLr(unit, cell_rval));
    pkt_rval = 0;
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_RED_PACKETr, &pkt_rval,
            OP_BUFFER_LIMIT_RED_PACKETf, out_shared_pkts >> 3);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RED_PACKETr(unit, pkt_rval));

    /*
     * Output port per-port shared
     * Limit check disabled, however still keep code as reference
     * OP_SHARED_LIMIT set to 3/4 of total shared space
     * OP_SHARED_RESET_VALUE set to 1/2 of total shared space
     */
    cell_rval = 0;
    soc_reg_field_set(unit, OP_PORT_CONFIG_CELLr, &cell_rval,
            OP_SHARED_LIMIT_CELLf, out_shared_cells * 3 / 4);
    soc_reg_field_set(unit, OP_PORT_CONFIG_CELLr, &cell_rval,
            OP_SHARED_RESET_VALUE_CELLf, out_shared_cells / 2);
    soc_reg_field_set(unit, OP_PORT_CONFIG_CELLr, &cell_rval,
            PORT_LIMIT_ENABLE_CELLf, 0);
    pkt_rval = 0;
    soc_reg_field_set(unit, OP_PORT_CONFIG_PACKETr, &pkt_rval,
            OP_SHARED_LIMIT_PACKETf, out_shared_pkts * 3 / 4);
    soc_reg_field_set(unit, OP_PORT_CONFIG_PACKETr, &pkt_rval,
            OP_SHARED_RESET_VALUE_PACKETf, out_shared_pkts / 2);
    soc_reg_field_set(unit, OP_PORT_CONFIG_PACKETr, &pkt_rval,
            PORT_LIMIT_ENABLE_PACKETf, 0);
    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_OP_PORT_CONFIG_CELLr(unit, port, cell_rval));
        SOC_IF_ERROR_RETURN(WRITE_OP_PORT_CONFIG_PACKETr(unit, port,
                        pkt_rval));
    }
    if (soc_feature(unit, soc_feature_internal_loopback)) {
        /* EP redirection */
        
    }

    /* Output port per-port shared for YELLOW traffic */
    cell_rval = 0;
    soc_reg_field_set(unit, OP_PORT_LIMIT_YELLOW_CELLr, &cell_rval,
            OP_PORT_LIMIT_YELLOW_CELLf,
            (out_shared_cells * 3 / 4) >> 3);
    pkt_rval = 0;
    soc_reg_field_set(unit, OP_PORT_LIMIT_YELLOW_PACKETr, &pkt_rval,
            OP_PORT_LIMIT_YELLOW_PACKETf,
            (out_shared_pkts * 3 / 4) >> 3);
    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_OP_PORT_LIMIT_YELLOW_CELLr(unit, port,
                        cell_rval));
        SOC_IF_ERROR_RETURN(WRITE_OP_PORT_LIMIT_YELLOW_PACKETr(unit, port,
                        pkt_rval));
    }

    /* Output port per-port shared for RED traffic */
    cell_rval = 0;
    soc_reg_field_set(unit, OP_PORT_LIMIT_RED_CELLr, &cell_rval,
            OP_PORT_LIMIT_RED_CELLf,
            (out_shared_cells * 3 / 4) >> 3);
    pkt_rval = 0;
    soc_reg_field_set(unit, OP_PORT_LIMIT_RED_PACKETr, &pkt_rval,
            OP_PORT_LIMIT_RED_PACKETf,
            (out_shared_pkts * 3 / 4) >> 3);
    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_OP_PORT_LIMIT_RED_CELLr(unit, port,
                        cell_rval));
        SOC_IF_ERROR_RETURN(WRITE_OP_PORT_LIMIT_RED_PACKETr(unit, port,
                        pkt_rval));
    }

    /* Output port configuration */
    rval0 = 0;
    soc_reg_field_set(unit, OP_THR_CONFIGr, &rval0,
            MOP_POLICYf, TR2_MMU_MOP_POLICY);
    soc_reg_field_set(unit, OP_THR_CONFIGr, &rval0,
            SOP_POLICYf, TR2_MMU_SOP_POLICY);
    SOC_IF_ERROR_RETURN(WRITE_OP_THR_CONFIGr(unit, rval0));

    /* Port enable */
    COMPILER_64_ZERO(rval64);
    SOC_PBMP_CLEAR(temp);
    SOC_PBMP_ASSIGN(temp, PBMP_ALL(unit));
    soc_reg64_field32_set(unit, INPUT_PORT_RX_ENABLE_64r, &rval64,
            INPUT_PORT_RX_ENABLE_LOf,
            SOC_PBMP_WORD_GET(temp, 0));
    soc_reg64_field32_set(unit, INPUT_PORT_RX_ENABLE_64r, &rval64,
            INPUT_PORT_RX_ENABLE_HIf,
            SOC_PBMP_WORD_GET(temp, 1));
    SOC_IF_ERROR_RETURN(WRITE_OUTPUT_PORT_RX_ENABLE_64r(unit, rval64));
    SOC_PBMP_OR(temp, PBMP_MMU(unit));
    soc_reg64_field32_set(unit, INPUT_PORT_RX_ENABLE_64r, &rval64,
            INPUT_PORT_RX_ENABLE_LOf,
            SOC_PBMP_WORD_GET(temp, 0));
    soc_reg64_field32_set(unit, INPUT_PORT_RX_ENABLE_64r, &rval64,
            INPUT_PORT_RX_ENABLE_HIf,
            SOC_PBMP_WORD_GET(temp, 1));
    SOC_IF_ERROR_RETURN(WRITE_INPUT_PORT_RX_ENABLE_64r(unit, rval64));

    /* Init ESM */
    SOC_IF_ERROR_RETURN(READ_IESMIF_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, IESMIF_CONTROLr, &rval, EN_EXT_SEARCH_REQf, 0);
    SOC_IF_ERROR_RETURN(WRITE_IESMIF_CONTROLr(unit, rval));
    if (soc_feature(unit, soc_feature_esm_support)) {
        /* coverity[stack_use_callee] */
        /* coverity[stack_use_overflow] */
        SOC_IF_ERROR_RETURN(soc_triumph_esm_init(unit));
    }

    return SOC_E_NONE;
}

int
soc_triumph2_age_timer_get(int unit, int *age_seconds, int *enabled)
{
    uint32 value;

    SOC_IF_ERROR_RETURN(READ_L2_AGE_TIMERr(unit, &value));
    *enabled = soc_reg_field_get(unit, L2_AGE_TIMERr, value, AGE_ENAf);
    *age_seconds = soc_reg_field_get(unit, L2_AGE_TIMERr, value, AGE_VALf);

    return SOC_E_NONE;
}

int
soc_triumph2_age_timer_max_get(int unit, int *max_seconds)
{
    *max_seconds =
    soc_reg_field_get(unit, L2_AGE_TIMERr, 0xffffffff, AGE_VALf);

    return SOC_E_NONE;
}

int
soc_triumph2_age_timer_set(int unit, int age_seconds, int enable)
{
    uint32 rval;

    rval = 0;
    soc_reg_field_set(unit, L2_AGE_TIMERr, &rval, AGE_ENAf, enable);
    soc_reg_field_set(unit, L2_AGE_TIMERr, &rval, AGE_VALf, age_seconds);
    SOC_IF_ERROR_RETURN(WRITE_L2_AGE_TIMERr(unit, rval));

    if (soc_feature(unit, soc_feature_esm_support)) {
        soc_triumph_ext_age_timer_set(unit, age_seconds, enable);
    }

    return SOC_E_NONE;
}

void soc_triumph2_oam_handler_register(int unit, soc_triumph2_oam_handler_t handler)
{
    oam_handler[unit] = handler;
    soc_intr_enable(unit, IRQ_MEM_FAIL);
}

void
soc_triumph2_mem_config(int unit)
{
    uint16 dev_id;
    uint8 rev_id;
    soc_persist_t *sop;

    sop = SOC_PERSIST(unit);
    soc_cm_get_id(unit, &dev_id, &rev_id);

    switch (dev_id) {
        case 0xb526:
        case 0xb521:
        case 0xb520:
        case 0xb522:
        case 0xb524:
        sop->memState[VLAN_SUBNETm].index_max = 255;
        sop->memState[VLAN_SUBNET_ONLYm].index_max = 255;
        sop->memState[VLAN_SUBNET_DATA_ONLYm].index_max = 255;

        sop->memState[L2_USER_ENTRYm].index_max = 255;
        sop->memState[L2_USER_ENTRY_ONLYm].index_max = 255;
        sop->memState[L2_USER_ENTRY_DATA_ONLYm].index_max = 255;

        sop->memState[ING_IPFIX_SESSION_TABLEm].index_max = 2047;
        sop->memState[EGR_IPFIX_SESSION_TABLEm].index_max = 2047;
        sop->memState[L3_DEFIPm].index_max = 6143;
        sop->memState[L3_DEFIP_ONLYm].index_max = 6143;
        sop->memState[L3_DEFIP_DATA_ONLYm].index_max = 6143;
        sop->memState[L3_DEFIP_HIT_ONLYm].index_max = 6143;
        /* Fall through */
        case 0xb685:
        case 0xb689:
        sop->memState[MMU_CBPDATA0m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA1m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA2m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA3m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA4m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA5m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA6m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA7m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA8m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA9m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA10m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA11m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA12m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA13m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA14m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA15m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA16m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA17m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA18m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA19m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA20m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA21m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA22m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA23m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA24m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA25m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA26m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA27m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA28m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA29m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA30m].index_max = 0x5fff;
        sop->memState[MMU_CBPDATA31m].index_max = 0x5fff;
        sop->memState[FP_RANGE_CHECKm].index_max = 31;
        break;
        case 0xb534:
        case 0xb538:
        sop->memState[VLAN_SUBNETm].index_max = 255;
        sop->memState[VLAN_SUBNET_ONLYm].index_max = 255;
        sop->memState[VLAN_SUBNET_DATA_ONLYm].index_max = 255;

        sop->memState[L2_USER_ENTRYm].index_max = 255;
        sop->memState[L2_USER_ENTRY_ONLYm].index_max = 255;
        sop->memState[L2_USER_ENTRY_DATA_ONLYm].index_max = 255;

        sop->memState[ING_IPFIX_SESSION_TABLEm].index_max = 2047;
        sop->memState[EGR_IPFIX_SESSION_TABLEm].index_max = 2047;
        sop->memState[L3_DEFIPm].index_max = 6143;
        sop->memState[L3_DEFIP_ONLYm].index_max = 6143;
        sop->memState[L3_DEFIP_DATA_ONLYm].index_max = 6143;
        sop->memState[L3_DEFIP_HIT_ONLYm].index_max = 6143;
        sop->memState[FP_RANGE_CHECKm].index_max = 31;
        break;
        default:
        sop->memState[FP_RANGE_CHECKm].index_max = 31;
        break;
    }
    return;
}

static soc_reg_t ctr_reg[117] = {
    ITPOKr,
    ITXPFr,
    ITXPPr,
    ITFCSr,
    ITUCr,
    ITMCAr,
    ITBCAr,
    ITOVRr,
    ITFRGr,
    ITPKTr,
    IT64r,
    IT127r,
    IT255r,
    IT511r,
    IT1023r,
    IT1518r,
    IT2047r,
    IT4095r,
    IT9216r,
    IT16383r,
    ITMAXr,
    ITUFLr,
    ITERRr,
    ITBYTr,
    IR64r,
    IR127r,
    IR255r,
    IR511r,
    IR1023r,
    IR1518r,
    IR2047r,
    IR4095r,
    IR9216r,
    IR16383r,
    IRMAXr,
    IRPKTr,
    IRFCSr,
    IRUCr,
    IRMCAr,
    IRBCAr,
    IRXPFr,
    IRXPPr,
    IRXUOr,
    IRJBRr,
    IROVRr,
    IRXCFr,
    IRFLRr,
    IRPOKr,
    IRMEGr,
    IRMEBr,
    IRBYTr,
    IRUNDr,
    IRFRGr,
    IRERBYTr,
    IRERPKTr,
    IRJUNKr,
    MAC_RXLLFCMSGCNTr,
    GR64r,
    GR127r,
    GR255r,
    GR511r,
    GR1023r,
    GR1518r,
    GRMGVr,
    GR2047r,
    GR4095r,
    GR9216r,
    GRPKTr,
    GRBYTr,
    GRMCAr,
    GRBCAr,
    GRFCSr,
    GRXCFr,
    GRXPFr,
    GRXUOr,
    GRALNr,
    GRFLRr,
    GRCDEr,
    GRFCRr,
    GROVRr,
    GRJBRr,
    GRMTUEr,
    GRUCr,
    GRPOKr,
    RRPKTr,
    GRUNDr,
    GRFRGr,
    RRBYTr,
    GT64r,
    GT127r,
    GT255r,
    GT511r,
    GT1023r,
    GT1518r,
    GTMGVr,
    GT2047r,
    GT4095r,
    GT9216r,
    GTPKTr,
    GTMCAr,
    GTBCAr,
    GTXPFr,
    GTJBRr,
    GTFCSr,
    GTXCFr,
    GTOVRr,
    GTDFRr,
    GTEDFr,
    GTSCLr,
    GTMCLr,
    GTLCLr,
    GTXCLr,
    GTFRGr,
    GTNCLr,
    GTBYTr,
    GTUCr,
    GTPOKr
};

static soc_reg_t mac_reg[19] = {
    EHG_RX_CONTROLr,
    EHG_TPIDr,
    EHG_TX_CONTROLr,
    EHG_TX_IPV4IDr,
    MAC_RXMACSAr,
    MAC_TXMACSAr,
    PAUSE_CONTROLr,
    MAC_0r,
    MAC_1r,
    XQPORT_INTR_ENABLEr,
    XQPORT_PARITY_CONTROLr,

    MAC_RXLSSCTRLr,
    MAC_TXPSETHRr,
    MAC_TXPPPCTRLr,
    XPORT_CONFIGr,
    XP_EGR_PKT_DROP_CTLr,
    MAC_TXLLFCCTRLr,
    XQPORT_FORCE_DOUBLE_BIT_ERRORr,
    XQPORT_FORCE_SINGLE_BIT_ERRORr
};

int
soc_tr2_xqport_mode_change(int unit, soc_port_t port, soc_mac_mode_t mode)
{
    int rv = SOC_E_NONE, rv1;
    uint32 old_bits, bits, rval, val2, to_usec, max_sz, bitpos = 0;
    uint32 linkdown_tx = 0;
    uint64 rval64, max_sz64;
    soc_field_t xq_rst2 = INVALIDf;
    mac_driver_t *macd;
    int autoneg, autoneg_done, speed, duplex, enable, master;
    int pause_rx, pause_tx, dual_modid;
    int ctr;
    uint64 mac_val[19], ctr_val[117];

    soc_port_ability_t ability;

    if (!SOC_PORT_VALID(unit, port)) {
        return SOC_E_PORT;
    }

    sal_memset(&ability, 0, sizeof(soc_port_ability_t));

    SOC_IF_ERROR_RETURN(READ_XQPORT_MODE_REGr(unit, port, &rval));
    old_bits = soc_reg_field_get(unit, XQPORT_MODE_REGr, rval,
            XQPORT_MODE_BITSf);
    bits = mode == SOC_MAC_MODE_10000 ? 2 : 1;
    if (bits == old_bits) {
        return SOC_E_NONE;
    }

    to_usec = SAL_BOOT_QUICKTURN ? (250 * MILLISECOND_USEC) :
    (10 * MILLISECOND_USEC);

    /* get current MAC and PHY settings */
    SOC_IF_ERROR_RETURN(soc_phyctrl_auto_negotiate_get(unit, port, &autoneg,
                    &autoneg_done));
    SOC_IF_ERROR_RETURN(soc_phyctrl_ability_advert_get(unit, port, &ability));
    SOC_IF_ERROR_RETURN(soc_phyctrl_speed_get(unit, port, &speed));
    SOC_IF_ERROR_RETURN(soc_phyctrl_duplex_get(unit, port, &duplex));
    SOC_IF_ERROR_RETURN(soc_phyctrl_enable_get(unit, port, &enable));
    SOC_IF_ERROR_RETURN(soc_phyctrl_master_get(unit, port, &master));
    rv1 = soc_phyctrl_control_get(unit, port, SOC_PHY_CONTROL_LINKDOWN_TRANSMIT,
            &linkdown_tx);
    if (rv1 != SOC_E_NONE && rv1 != SOC_E_UNAVAIL) {
        return rv1;
    }
    SOC_IF_ERROR_RETURN(soc_mac_probe(unit, port, &macd));
    SOC_IF_ERROR_RETURN(MAC_PAUSE_GET(macd, unit, port, &pause_tx, &pause_rx));
    SOC_IF_ERROR_RETURN(READ_MAC_CNTMAXSZr(unit, port, &max_sz64));
    SOC_IF_ERROR_RETURN(READ_GPORT_CNTMAXSIZEr(unit, port, &max_sz));

    /* 1, Disable MAC TX and RX */
    SOC_IF_ERROR_RETURN(MAC_ENABLE_SET(macd, unit, port, FALSE));

    /* 5. Block linkscan and sbus access */
    soc_linkscan_pause(unit);
    COUNTER_LOCK(unit);

    /* Store the mac regs */
    for (ctr = 0; ctr < 19; ctr++) {
        SOC_COUNTER_IF_ERROR_RETURN
        (soc_reg_get(unit, mac_reg[ctr], port, 0, &mac_val[ctr]));
    }

    /* Store the counters */
    for (ctr = 0; ctr < 117; ctr++) {
        SOC_COUNTER_IF_ERROR_RETURN
        (soc_reg_get(unit, ctr_reg[ctr], port, 0, &ctr_val[ctr]));
    }

    /* Egress disable */
    rval = 0;
    soc_reg_field_set(unit, EGR_ENABLEr, &rval, PRT_ENABLEf, 0);
    SOC_COUNTER_IF_ERROR_RETURN(WRITE_EGR_ENABLEr(unit, port, rval));

    /* Hold the XQPORT hotswap reset */
    switch (port) {
        case 30:
        bitpos = 6;
        xq_rst2 = XQ0_HOTSWAP_RST_Lf;
        break;
        case 34:
        bitpos = 7;
        xq_rst2 = XQ1_HOTSWAP_RST_Lf;
        break;
        case 38:
        bitpos = 8;
        xq_rst2 = XQ2_HOTSWAP_RST_Lf;
        break;
        case 42:
        bitpos = 9;
        xq_rst2 = XQ3_HOTSWAP_RST_Lf;
        break;
        case 46:
        bitpos = 10;
        xq_rst2 = XQ4_HOTSWAP_RST_Lf;
        break;
        case 50:
        bitpos = 11;
        xq_rst2 = XQ5_HOTSWAP_RST_Lf;
        break;
        default:
        break;
    }
    SOC_COUNTER_IF_ERROR_RETURN(READ_CMIC_SOFT_RESET_REG_2r(unit, &val2));
    soc_reg_field_set(unit, CMIC_SOFT_RESET_REG_2r, &val2,
            xq_rst2, 0);
    SOC_COUNTER_IF_ERROR_RETURN(WRITE_CMIC_SOFT_RESET_REG_2r(unit, val2));
    sal_usleep(to_usec);

    /* Clear the ECRC register */
    SOC_COUNTER_IF_ERROR_RETURN(WRITE_TOQ_EP_CREDITr(unit, port, 0));

    /* Reset the EP */
    SOC_COUNTER_IF_ERROR_RETURN(READ_EDATABUF_XQP_FLEXPORT_CONFIGr(unit, &rval));
    rval |= (1 << (bitpos - 6));
    SOC_COUNTER_IF_ERROR_RETURN(WRITE_EDATABUF_XQP_FLEXPORT_CONFIGr(unit, rval));
    sal_usleep(to_usec);
    SOC_COUNTER_IF_ERROR_RETURN(READ_EDATABUF_XQP_FLEXPORT_CONFIGr(unit, &rval));
    if (mode == SOC_MAC_MODE_10000) {
        rval |= (1 << bitpos);
    } else {
        rval &= ~(1 << bitpos);
    }
    rval &= ~(1 << (bitpos - 6));
    SOC_COUNTER_IF_ERROR_RETURN(WRITE_EDATABUF_XQP_FLEXPORT_CONFIGr(unit, rval));
    sal_usleep(to_usec);

    /* Bring the XQPORT block out of reset */
    SOC_COUNTER_IF_ERROR_RETURN(READ_CMIC_SOFT_RESET_REG_2r(unit, &val2));
    soc_reg_field_set(unit, CMIC_SOFT_RESET_REG_2r, &val2,
            xq_rst2, 1);
    SOC_COUNTER_IF_ERROR_RETURN(WRITE_CMIC_SOFT_RESET_REG_2r(unit, val2));
    sal_usleep(to_usec);

    /* Bring the hyperlite out of reset */
    soc_xgxs_reset(unit, port);
    SOC_COUNTER_IF_ERROR_RETURN(soc_reg_field32_modify(unit, XQPORT_XGXS_NEWCTL_REGr,
                    port, TXD1G_FIFO_RSTBf, 0xf));

    /* Change the XQPORT block mode */
    SOC_COUNTER_IF_ERROR_RETURN(READ_XQPORT_MODE_REGr(unit, port, &rval));
    soc_reg_field_set(unit, XQPORT_MODE_REGr, &rval,
            XQPORT_MODE_BITSf, bits);
    SOC_COUNTER_IF_ERROR_RETURN(WRITE_XQPORT_MODE_REGr(unit, port, rval));

    /* Egress Enable */
    rval = 0;
    soc_reg_field_set(unit, EGR_ENABLEr, &rval, PRT_ENABLEf, 1);
    SOC_COUNTER_IF_ERROR_RETURN(WRITE_EGR_ENABLEr(unit, port, rval));

    /* Step 3: Port probe and initialization */
    SOC_COUNTER_IF_ERROR_RETURN(soc_phyctrl_detach(unit, port));
    SOC_COUNTER_IF_ERROR_RETURN(soc_phyctrl_probe(unit, port));
    SOC_COUNTER_IF_ERROR_RETURN(soc_phyctrl_init(unit, port));

    /* restore PHY setting */
    SOC_COUNTER_IF_ERROR_RETURN(soc_phyctrl_auto_negotiate_set(unit, port, autoneg));
    SOC_COUNTER_IF_ERROR_RETURN(soc_phyctrl_ability_advert_set(unit, port, &ability));
    SOC_COUNTER_IF_ERROR_RETURN(soc_phyctrl_speed_set(unit, port, speed));
    SOC_COUNTER_IF_ERROR_RETURN(soc_phyctrl_duplex_set(unit, port, duplex));
    SOC_COUNTER_IF_ERROR_RETURN(soc_phyctrl_enable_set(unit, port, enable));
    SOC_COUNTER_IF_ERROR_RETURN(soc_phyctrl_master_set(unit, port, master));
    rv1 = soc_phyctrl_control_set(unit, port, SOC_PHY_CONTROL_LINKDOWN_TRANSMIT,
            linkdown_tx);
    if (rv1 != SOC_E_NONE && rv1 != SOC_E_UNAVAIL) {
        return rv1;
    }

    /* Need to reset the Bigmac to make registers accessible */
    SOC_COUNTER_IF_ERROR_RETURN(READ_MAC_CTRLr(unit, port, &rval64));
    soc_reg64_field32_set(unit, MAC_CTRLr, &rval64, TXRESETf, 0);
    soc_reg64_field32_set(unit, MAC_CTRLr, &rval64, RXRESETf, 0);
    SOC_COUNTER_IF_ERROR_RETURN(WRITE_MAC_CTRLr(unit, port, rval64));

    SOC_COUNTER_IF_ERROR_RETURN(MAC_INIT(macd, unit, port));

    /* Restore MAC regs */
    for (ctr = 0; ctr < 19; ctr++) {
        SOC_IF_ERROR_RETURN
        (soc_reg_set(unit, mac_reg[ctr], port, 0, mac_val[ctr]));
    }

    /* Restore previous MAC settings */
    SOC_COUNTER_IF_ERROR_RETURN(MAC_ENABLE_SET(macd, unit, port, enable));
    SOC_COUNTER_IF_ERROR_RETURN(MAC_PAUSE_SET(macd, unit, port, pause_tx, pause_rx));

    /* Restore XQPORT registers that may have been reset */
    dual_modid = (NUM_MODID(unit) == 2) ? 1 : 0;
    SOC_COUNTER_IF_ERROR_RETURN(soc_reg_field32_modify(unit, XMODID_ENr, port,
                    DUAL_MODID_ENf, dual_modid));
    SOC_COUNTER_IF_ERROR_RETURN(WRITE_MAC_CNTMAXSZr(unit, port, max_sz64));
    SOC_COUNTER_IF_ERROR_RETURN(WRITE_GPORT_CNTMAXSIZEr(unit, port, max_sz));

    /* Restore the counters */
    for (ctr = 0; ctr < 117; ctr++) {
        SOC_COUNTER_IF_ERROR_RETURN
        (soc_reg_set(unit, ctr_reg[ctr], port, 0, ctr_val[ctr]));
    }

    /* 8. Resume sbus access and linkscan */
    COUNTER_UNLOCK(unit);
    soc_linkscan_continue(unit);
    return rv;
}

/*
 * Function:
 *      soc_tr2_l3_defip_index_map
 * Purpose:
 *      Map an index within L3_DEFIP to the real h/w index by jumping over
 *     unused blocks ( TCAM-3 , 3k - 4k)  to make the table appear contiguous
 * Parameters:
 *      unit       - (IN) Device Number
 *      index    - (IN) Virtual index
 *      mpls_port  - (IN/OUT) mpls port information
 * Returns:
 *      index - (OUT) Hardware index
 */

int
soc_tr2_l3_defip_index_map(int unit, int index)
{
    if (index > 0x17FF) {
        return index;
    }
    if (index > 0xBFF) {
        return (index + 0x0400);
    } else {
        return index;
    }
}


/*
 * Function:
 *      soc_tr2_ser_mem_test
 * Purpose:
 *      Performs a SER test on a single TR2 memory
 * Parameters:
 *      unit               - (IN) Device Number
 *      mem                - (IN) The memory to test
 *      test_type        - (IN) How many indices in the memory to test
 *
 */
int
soc_tr2_ser_mem_test(int unit, soc_mem_t mem, _soc_ser_test_t test_type, int cmd)
{
    int group, table, i, rv;
    _soc_parity_info_t *info;
    soc_mem_t memTable;
    soc_port_t block_port;
    soc_block_t blk;
    int testErrors = 0;
    /*Prevent compiler error for common function signature.*/
    (void) cmd;
    /*TCAM_test*/
    for (i = 0; _soc_tr2_ser_parity_info[i].mem != INVALIDm; i++) {
        if (_soc_tr2_ser_parity_info[i].mem == mem) {
            rv = ser_test_mem_pipe(unit, CMIC_SER_PROTECT_ADDR_RANGE_VALIDr, i,
            -1,_soc_tr2_ser_parity_info[i].mem, INVALIDf, test_type,
            MEM_BLOCK_ANY, REG_PORT_ANY, _SOC_ACC_TYPE_PIPE_ANY, &testErrors);
            if (rv != SOC_E_NONE) {
                LOG_CLI((BSL_META_U(unit,
                                    "Error during TCAM test.  Aborting.\n")));
                return rv;
            }
        }
    }
    /*H/W memory Test*/
    for (group = 0; _soc_tr2_parity_group_info[group].cpi_bit; group++) {
        info = _soc_tr2_parity_group_info[group].info;

        SOC_BLOCK_ITER(unit, blk,
                _soc_tr2_parity_group_info[group].blocktype) {
            if (_soc_triumph_parity_block_port(unit, blk, &block_port) < 0) {
                continue;
            }

            for (table = 0; info[table].error_field != INVALIDf; table++) {
                memTable = info[table].mem;
                if (memTable == INVALIDm) {
                    continue;
                }
                if (memTable == mem) {
                    rv = ser_test_mem_pipe(unit,info[table].control_reg, -1,
                                           info[table].enable_field, mem,
                                           INVALIDf, test_type, blk, block_port,
                                           _SOC_ACC_TYPE_PIPE_ANY, &testErrors);
                    if (rv != SOC_E_NONE) {
                        LOG_CLI((BSL_META_U(unit,
                                            "Error during H/W test.  Aborting.\n")));
                        return rv;
                    }
                }
            }
        }
    }
    if (testErrors == 0) {
        LOG_CLI((BSL_META_U(unit,
                            "SER Test passed on unit: %d for memory %s\n "),
                 unit, SOC_MEM_NAME(unit,mem)));
    }
    else {
        LOG_CLI((BSL_META_U(unit,
                            "SER Test failed on unit: %d for memory %s\n"),
                 unit, SOC_MEM_NAME(unit,mem)));
        return SOC_E_MEMORY;
    }
    return SOC_E_NONE;
}


/*
 * Function:
 *      soc_tr2_ser_test
 * Purpose:
 *      Performs a SER test on all TR2 Memories
 * Parameters:
 *      unit               - (IN) Device Number
 *      test_type        - (IN) Determines how comprehensive of a test to run
 *
 */
int
soc_tr2_ser_test(int unit, _soc_ser_test_t test_type)
{
    int i, rv;
    int numTCAMErr   = 0;
    int numNACKErr   = 0;
    /*This is a NACK test for hardware-monitored memories*/
    rv = _soc_triumph2_mem_nack_error_test(unit, test_type, &numNACKErr);
    if (rv != SOC_E_NONE) {
        LOG_CLI((BSL_META_U(unit,
                            "Error during H/W test.  Aborting.\n")));
        return rv;
    }
    /*This is a NACK test for TCAM memories*/
    /*Test each TCAM memory*/
    for(i = 0; i < COUNTOF(_soc_tr2_ser_parity_info) - 1; i++) {
        rv = ser_test_mem_pipe(unit, CMIC_SER_PROTECT_ADDR_RANGE_VALIDr, i, -1,
                _soc_tr2_ser_parity_info[i].mem, INVALIDf, test_type, MEM_BLOCK_ANY,
                REG_PORT_ANY, _SOC_ACC_TYPE_PIPE_ANY, &numTCAMErr);
                if (rv != SOC_E_NONE) {
                    LOG_CLI((BSL_META_U(unit,
                                        "Error during TCAM test.  Aborting.\n")));
                    return rv;
                }
    }
    LOG_CLI((BSL_META_U(unit,
                        "Total H/W parity errors on unit %d: %d\n"),unit, numNACKErr));
    LOG_CLI((BSL_META_U(unit,
                        "Total TCAM errors on unit %d: %d\n"), unit, numTCAMErr));
    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_tr2_ser_mem_test
 * Purpose:
 *      Performs a SER test on a single TR2 memory
 * Parameters:
 *      unit               - (IN) Device Number
 *      mem                - (IN) The memory to test
 *      test_type        - (IN) How many indices in the memory to test
 *
 */
int
soc_tr2_ser_inject_error(int unit, uint32 flags, soc_mem_t mem, int pipeTarget,
                         int block, int index)
{
    int group, table, i;
    _soc_parity_info_t *info;
    soc_mem_t memTable;
    soc_port_t block_port;
    soc_block_t blk;
    ser_test_data_t test_data;
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], fieldData[SOC_MAX_REG_FIELD_WORDS];
    test_data.index = index;
    test_data.entry_buf = tmp_entry;
    test_data.field_buf = fieldData;
    /*TCAM_test*/
    for (i = 0; _soc_tr2_ser_parity_info[i].mem != INVALIDm; i++) {
        if (_soc_tr2_ser_parity_info[i].mem == mem) {
            test_data.mem = mem;
            test_data.tcam_parity_bit = i;
            test_data.parity_enable_reg = CMIC_SER_PROTECT_ADDR_RANGE_VALIDr;
            test_data.parity_enable_field = INVALIDf;
            test_data.mem_block = MEM_BLOCK_ANY;
            test_data.port = REG_PORT_ANY;
            test_data.acc_type = _SOC_ACC_TYPE_PIPE_ANY;
            test_data.mem_info = &SOC_MEM_INFO(unit,test_data.mem);
            /*Read the memory for successful injection*/
            SOC_IF_ERROR_RETURN(ser_test_mem_read(unit, &test_data));
            /*Disable parity*/
            SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 0));
            /*Inject error*/            
            SOC_IF_ERROR_RETURN(soc_ser_test_inject_full(unit, flags, &test_data));
            /*Enable parity*/
            SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 1));
            return SOC_E_NONE;

        }
    }
    /*H/W memory Test*/
    for (group = 0; _soc_tr2_parity_group_info[group].cpi_bit; group++) {
        info = _soc_tr2_parity_group_info[group].info;

        SOC_BLOCK_ITER(unit, blk,
                _soc_tr2_parity_group_info[group].blocktype) {
            if (_soc_triumph_parity_block_port(unit, blk, &block_port) < 0) {
                continue;
            }

            for (table = 0; info[table].error_field != INVALIDf; table++) {
                memTable = info[table].mem;
                if (memTable == INVALIDm) {
                    continue;
                }
                if (memTable == mem) {
                    if((blk == block) || (block == MEM_BLOCK_ANY))
                    {
                        /*Inject error*/
                        test_data.mem = mem;
                        test_data.tcam_parity_bit = -1;
                        test_data.parity_enable_reg = info[table].control_reg;
                        test_data.parity_enable_field = info[table].enable_field;
                        test_data.mem_block = blk;
                        test_data.port = block_port;
                        test_data.acc_type = _SOC_ACC_TYPE_PIPE_ANY;
                        test_data.mem_info = &SOC_MEM_INFO(unit,test_data.mem);
                        /*Read the memory for successful injection*/
                        SOC_IF_ERROR_RETURN(ser_test_mem_read(unit, &test_data));
                        /*Disable parity*/
                        SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 0));
                        /*Inject error*/
                        SOC_IF_ERROR_RETURN(soc_ser_test_inject_error(unit, &test_data));
                        /*Enable parity*/
                        SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 1));
                    }
                }
            }
        }
    }
    return SOC_E_NONE;
}

#endif /* SOC_TRIUMPH2_SUPPORT */
