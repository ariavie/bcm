/*
 * $Id: triumph3.c,v 1.483 Broadcom SDK $
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * File:        triumph3.c
 * Purpose:
 * Requires:
 */


#include <shared/bsl.h>

#include <sal/core/boot.h>
#include <shared/bsl.h>
#include <soc/drv.h>
#include <soc/error.h>
#include <soc/debug.h>
#include <soc/mem.h>
#include <soc/mmu_config.h>
#include <soc/tcam/tcamtype1.h>
#include <soc/er_tcam.h>
#include <soc/bradley.h>
#include <soc/triumph3.h>
#include <soc/mspi.h>
#include <soc/l2x.h>
#ifdef BCM_HELIX4_SUPPORT
#include <soc/helix4.h>
#endif /* BCM_HELIX4_SUPPORT */
#include <soc/post.h>

#ifdef BCM_TRIUMPH3_SUPPORT

#define SOC_MAX_PHY_PORTS            86

#define CORE_MODE_SINGLE             0
#define CORE_MODE_DUAL               1
#define CORE_MODE_QUAD               2
#define CORE_MODE_NOTDM              3

#define PHY_MODE_SINGLE              0
#define PHY_MODE_DUAL                1
#define PHY_MODE_QUAD                2

#define MAC_MODE_INDEP               0
#define MAC_MODE_AGGR                1

#define _MAX_TR3_FLEX_PORT_PROPS     11
#define _MAX_TR3_PORT_CFG            _MAX_TR3_FLEX_PORT_PROPS
/* #define _MAX_TR3_FLEX_PORT_GROUPS    20 */ /* Total num of XC, WC -1 */
#define _MAX_TR3_TDM_SLOTS           380

#define WC40_UCMEM_DATA_ENTRY_LEN    16

#define _TR3_MMU_CELLS_RSVD_IP       100

#define _TR3_MMU_MAX_PACKET_BYTES    10240 /* bytes */
#define _TR3_MMU_PACKET_HEADER_BYTES 64    /* bytes */
#define _TR3_MMU_JUMBO_FRAME_BYTES   9216  /* bytes */
#define _TR3_MMU_DEFAULT_MTU_BYTES   1536  /* bytes */

#define _TR3_MMU_TOTAL_CELLS_24K     24576 /* 24k cells */
#define _TR3_MMU_TOTAL_CELLS_19K     19456 /* 19k cells */

int _soc_tr3_mmu_buffer_cells[SOC_MAX_NUM_DEVICES];

#define _TR3_MMU_TOTAL_CELLS(unit)  _soc_tr3_mmu_buffer_cells[(unit)]
                
#define _TR3_MMU_BYTES_PER_CELL      208   /* bytes (1664 bits) */
#define _TR3_MMU_NUM_PG              8
#define _TR3_MMU_NUM_POOL            4

/* Default ISM mem config sizes 
 * These are scaled down automatically for various SKU's 
 */
#define _ISM_MAX_MEMS                8
#define _ISM_MEM_VLAN_XLATE_SIZE     (32*1024)
#define _ISM_MEM_L2_SIZE             (64*1024)
#define _ISM_MEM_L3_SIZE             (32*1024)
#define _ISM_MEM_EP_VLAN_XLATE_SIZE  (16*1024)
#define _ISM_MEM_MPLS_SIZE           (32*1024)

#define _SOC_TR3_DEFIP_MAX_TCAMS   8
#define _SOC_TR3_DEFIP_TCAM_DEPTH  1024

#define _SOC_AP2_DEFIP_MAX_TCAMS   6
#define _SOC_AP2_DEFIP_TCAM_DEPTH  1024

void soc_tr3_oam_interrupt_process(int unit);

typedef enum {
    _SOC_PARITY_TYPE_NONE,
    _SOC_PARITY_TYPE_GENERIC,
    _SOC_PARITY_TYPE_PARITY,
    _SOC_PARITY_TYPE_ECC,
    _SOC_PARITY_TYPE_MMU_THDO,
    _SOC_PARITY_TYPE_MMU_THDI,
    _SOC_PARITY_TYPE_MMU_WRED,
    _SOC_PARITY_TYPE_MMU_QCN,
    _SOC_PARITY_TYPE_MMU_LLS,
    _SOC_PARITY_TYPE_AXP,
    _SOC_PARITY_TYPE_BST,
    _SOC_PARITY_TYPE_SER,
    _SOC_PARITY_INFO_TYPE_OAM,
    _SOC_PARITY_INFO_TYPE_NUM
} _soc_tr3_parity_info_type_t;

typedef struct _soc_tr3_parity_info_s {
    soc_reg_t                          enable_reg;
    soc_field_t                        enable_field;
} _soc_tr3_fifo_parity_info_t;

typedef struct _soc_tr3_parity_block_info_s {
    soc_block_t                        blocktype;
    soc_reg_t                          fifo_reset_reg;
    _soc_tr3_fifo_parity_info_t        *info;
} _soc_tr3_parity_block_info_t;

typedef struct _soc_tr3_parity_reg_s {
    soc_reg_t                          reg;
    char                               *mem_str;
} _soc_tr3_parity_reg_t;

typedef struct _soc_tr3_parity_mmu_bit_s {
    uint32                             bit_pos;
    soc_mem_t                          mem;
} _soc_tr3_parity_mmu_bit_t;

typedef struct _soc_tr3_parity_mmu_bit_reg_s {
    uint32                             bit_pos;
    soc_mem_t                          mem;
    soc_reg_t                          addr_reg;
} _soc_tr3_parity_mmu_bit_reg_t;

typedef struct _soc_tr3_parity_mmu_bit_fld_s {
    uint32                             bit_pos;
    soc_mem_t                          mem;
    soc_field_t                        idxf;
} _soc_tr3_parity_mmu_bit_fld_t;

typedef struct _soc_tr3_parity_mmu_bit_reg_idx_s {
    uint32                             bit_pos;
    soc_mem_t                          mem;
    soc_reg_t                          addr_reg;
    soc_field_t                        idxf;
    uint8                              uncorrectable;                                
} _soc_tr3_parity_mmu_bit_reg_fld_t;

typedef struct _soc_tr3_parity_enable_extra_info_s {
    soc_reg_t                          enable_reg;
    soc_field_t                        *enable_field_list;
} _soc_tr3_parity_enable_extra_info_t;

typedef struct _soc_tr3_legacy_parity_info_s {
    _soc_tr3_parity_info_type_t        type;
    struct _soc_tr3_legacy_parity_info_s *info;
    int                                id;
    soc_field_t                        group_reg_enable_field;
    soc_field_t                        group_reg_status_field;
    soc_mem_t                          mem;
    char                               *mem_str;
    soc_reg_t                          enable_reg;
    soc_field_t                        enable_field;
    soc_reg_t                          intr_status_reg;
    _soc_tr3_parity_enable_extra_info_t *ext_en;
    soc_reg_t                          correction_reg;
    soc_field_t                        correction_addr_field;
} _soc_tr3_parity_info_t;

typedef struct _soc_tr3_parity_route_block_s {
    uint8                              cmic_reg; /* 0: intr2, 1: intr1 */
    uint32                             cmic_bit;
    soc_block_t                        blocktype;
    soc_reg_t                          enable_reg;
    soc_reg_t                          status_reg;
    soc_field_t                        enable_field;
    _soc_tr3_parity_info_t             *info;
    uint8                              id;
} _soc_tr3_parity_route_block_t;

static
_soc_tr3_parity_info_t _soc_tr3_mmu_parity_info[] = {
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, AGING_CTR_PAR_ERR_ENf,
        AGING_CTR_PAR_ERRf, MMU_AGING_CTRm, "MMU AGING CTR",
        INVALIDr, INVALIDf, INVALIDr, NULL, PERR_PTR_CTRr, PTRf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, AGING_EXP_PAR_ERR_ENf,
        AGING_EXP_PAR_ERRf, MMU_AGING_EXPm, "MMU AGING EXP",
        INVALIDr, INVALIDf, INVALIDr, NULL, PERR_PTR_EXPr, PTRf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, CCP_PAR_ERR_ENf,
        CCP_PAR_ERRf, MMU_CCP_MEMm, "MMU CCP", INVALIDr, 
        INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, CFAP_PAR_ERR_ENf,
        CFAP_PAR_ERRf, INVALIDm, "MMU CFAP",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, CTR_UC_CNT_ENf,
        CTR_UC_CNTf, MMU_CTR_UC_DROP_MEMm, "MMU CTR UC CNT", INVALIDr, 
        INVALIDf, INVALIDr, NULL, MMU_CTR_PARITY_ERRr, ERRADDRf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, CTR_MC_CNT_ENf,
        CTR_MC_CNTf, MMU_CTR_MC_DROP_MEMm, "MMU CTR MC CNT", INVALIDr, 
        INVALIDf, INVALIDr, NULL, MMU_CTR_PARITY_ERRr, ERRADDRf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, CTR_COLOR_CNT_ERR_ENf,
        CTR_COLOR_CNT_ERRf, MMU_CTR_COLOR_DROP_MEMm, "MMU CTR COLOR CNT",
        INVALIDr, INVALIDf, INVALIDr, NULL, MMU_CTR_PARITY_ERRr, ERRADDRf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, TOQ_REPL_HEAD_TBL_PAR_ERR_ENf,
        TOQ_REPL_HEAD_TBL_PAR_ERRf, MMU_REPL_HEAD_TBLm, "MMU TOQ REPL HEAD TBL",
        INVALIDr, INVALIDf, INVALIDr, NULL, MCQ_REPLHEADERRPTRr, 
        REPLHEADERRORPOINTERf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, TOQ_MC_FIFO_PAR_ERR_ENf,
        TOQ_MC_FIFO_PAR_ERRf, INVALIDm, "MMU TOQ MCFIFO",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, TOQ_PKTLINK_PAR_ERR_ENf,
        TOQ_PKTLINK_PAR_ERRf, INVALIDm, "MMU TOQ PKTLINK",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, TOQ_CELLLINK_PAR_ERR_ENf,
        TOQ_CELLLINK_PAR_ERRf, INVALIDm, "MMU TOQ CELLLINK",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, TOQ_UC_QDB_PAR_ERR_ENf,
        TOQ_UC_QDB_PAR_ERRf, INVALIDm, "MMU TOQ UC QDB",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, TOQ_WAMULINK_PAR_ERR_ENf,
        TOQ_WAMULINK_PAR_ERRf, INVALIDm, "MMU TOQ WAMULINK",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, RDE_PAR_ERR_ENf,
        RDE_PAR_ERRf, INVALIDm, "MMU RDE PAR", INVALIDr, INVALIDf, 
        INVALIDr, NULL, RDEPARITYERRORPTRr, PARITYERRORPTRf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, WAMU_PAR_ERR_ENf,
        WAMU_PAR_ERRf, INVALIDm, "MMU WAMU PAR",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, MTRO_PAR_ERR_ENf,
        MTRO_PAR_ERRf, INVALIDm, "MMU MTRO PAR",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_MMU_WRED, NULL, 0, WRED_PAR_ERR_ENf,
        WRED_PAR_ERRf, INVALIDm, "MMU WRED",
        INVALIDr, INVALIDf, INVALIDr, NULL, WRED_PARITY_ERROR_INFOr, POINTERf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, OVQ_PAR_ERR_ENf,
        OVQ_PAR_ERRf, INVALIDm, "MMU OVQ",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, PQE_PAR_ERR_ENf,
        PQE_PAR_ERRf, INVALIDm, "MMU PQE PAR",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_MMU_QCN, NULL, 0, QCN_PAR_ERR_ENf,
        QCN_PAR_ERRf, INVALIDm, "MMU QCN PAR",
        INVALIDr, INVALIDf, INVALIDr, NULL, MMU_QCN_PARITY_ERRr, ERRADDRf },
    { _SOC_PARITY_TYPE_MMU_THDO, NULL, 0, THDO_PAR_ERR_ENf,
        THDO_PAR_ERRf, INVALIDm, "MMU THDO",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_MMU_THDI, NULL, 0, THDI_PAR_ERR_ENf,
        THDI_PAR_ERRf, INVALIDm, "MMU THDI",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_MMU_LLS, NULL, 0, LLS_PAR_ERR_ENf,
        LLS_PAR_ERRf, INVALIDm, "MMU LLS",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, RDE_DESCP_PAR_ERR_ENf,
        RDE_DESCP_PAR_ERRf, INVALIDm, "MMU RDE DESCP", INVALIDr, INVALIDf, 
        INVALIDr, NULL, DEQ_RDEDESCPERRPTRr, RDERRORPOINTERf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, E2EFC_PAR_ERR_ENf,
        E2EFC_PAR_ERRf, INVALIDm, "MMU E2EFC",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, DEQ_REPL_LIST_PAR_ERR_ENf,
        DEQ_REPL_LIST_PAR_ERRf, MMU_REPL_LIST_TBLm, "MMU REPL LIST",
        INVALIDr, INVALIDf, INVALIDr, NULL, DEQ_REPLISTERRPTRr, 
        REPLISTERRORPOINTERf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, INTFI_PAR_ERR_ENf,
        INTFI_PAR_ERRf, INVALIDm, "MMU INTFI",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, INTFO2_PAR_ERR_ENf,
        INTFO2_PAR_ERRf, INVALIDm, "MMU INTFO2",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, DEQ_SM_PAR_ERR_ENf,
        DEQ_SM_PAR_ERRf, INVALIDm, "MMU DEQ SM",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0, HSP_PAR_ERR_ENf,
        HSP_PAR_ERRf, INVALIDm, "MMU HSP",
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_BST, NULL, 0, INVALIDf,
        BST_THDI_INTf, INVALIDm, NULL,
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_BST, NULL, 0, INVALIDf,
        BST_THDO_INTf, INVALIDm, NULL,
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_BST, NULL, 0, INVALIDf,
        BST_CFAP_INTf, INVALIDm, NULL, 
        INVALIDr, INVALIDf, INVALIDr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

static
_soc_tr3_parity_info_t _soc_tr3_port_parity_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0, TXFIFO0_MEM_ERRf,
        TXFIFO0_MEM_ERRf, INVALIDm, "TX FIFO 0", PORT_ECC_CONTROLr, 
        TXFIFO_MEM_ENf, PORT_TXFIFO0_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, TXFIFO1_MEM_ERRf,
        TXFIFO1_MEM_ERRf, INVALIDm, "TX FIFO 1", PORT_ECC_CONTROLr, 
        TXFIFO_MEM_ENf, PORT_TXFIFO1_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, TXFIFO2_MEM_ERRf,
        TXFIFO2_MEM_ERRf, INVALIDm, "TX FIFO 2", PORT_ECC_CONTROLr, 
        TXFIFO_MEM_ENf, PORT_TXFIFO2_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, CDC_TXFIFO_MEM_ERRf, CDC_TXFIFO_MEM_ERRf, 
        INVALIDm, "CDC TX FIFO", PORT_ECC_CONTROLr, CDC_TXFIFO_MEM_ENf, 
        PORT_CDC_TXFIFO_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, CDC_RXFIFO_MEM_ERRf, CDC_RXFIFO_MEM_ERRf, 
        INVALIDm, "CDC RX FIFO", PORT_ECC_CONTROLr, CDC_RXFIFO_MEM_ENf, 
        PORT_CDC_RXFIFO_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0, EHG0_RX_MASK_MEM_ERRf,
        EHG0_RX_MASK_MEM_ERRf, INVALIDm, "HG 0 RX MASK MEM",
        PORT_EHG_ECC_CONTROLr, EHG_RX_MASK_MEM_ENf, 
        PORT_EHG0_RX_MASK_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, EHG1_RX_MASK_MEM_ERRf,
        EHG1_RX_MASK_MEM_ERRf, INVALIDm, "HG 1 RX MASK MEM",
        PORT_EHG_ECC_CONTROLr, EHG_RX_MASK_MEM_ENf,
        PORT_EHG1_RX_MASK_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, EHG2_RX_MASK_MEM_ERRf,
        EHG2_RX_MASK_MEM_ERRf, INVALIDm, "HG 2 RX MASK MEM",
        PORT_EHG_ECC_CONTROLr, EHG_RX_MASK_MEM_ENf,
        PORT_EHG2_RX_MASK_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, EHG0_RX_DATA_MEM_ERRf,
        EHG0_RX_DATA_MEM_ERRf, INVALIDm, "HG 0 RX DATA MEM",
        PORT_EHG_ECC_CONTROLr, EHG_RX_DATA_MEM_ENf,
        PORT_EHG0_RX_DATA_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, EHG1_RX_DATA_MEM_ERRf,
        EHG1_RX_DATA_MEM_ERRf, INVALIDm, "HG 1 RX DATA MEM",
        PORT_EHG_ECC_CONTROLr, EHG_RX_DATA_MEM_ENf,
        PORT_EHG1_RX_DATA_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, EHG2_RX_DATA_MEM_ERRf,
        EHG2_RX_DATA_MEM_ERRf, INVALIDm, "HG 2 RX DATA MEM",
        PORT_EHG_ECC_CONTROLr, EHG_RX_DATA_MEM_ENf,
        PORT_EHG2_RX_DATA_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, EHG0_TX_DATA_MEM_ERRf,
        EHG0_TX_DATA_MEM_ERRf, INVALIDm, "HG 0 TX DATA MEM",
        PORT_EHG_ECC_CONTROLr, EHG_TX_DATA_MEM_ENf,
        PORT_EHG0_TX_DATA_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, EHG1_TX_DATA_MEM_ERRf,
        EHG1_TX_DATA_MEM_ERRf, INVALIDm, "HG 1 TX DATA MEM",
        PORT_EHG_ECC_CONTROLr, EHG_TX_DATA_MEM_ENf,
        PORT_EHG1_TX_DATA_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, EHG2_TX_DATA_MEM_ERRf,
        EHG2_TX_DATA_MEM_ERRf, INVALIDm, "HG 2 TX DATA MEM",
        PORT_EHG_ECC_CONTROLr, EHG_TX_DATA_MEM_ENf,
        PORT_EHG2_TX_DATA_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, EHG0_RXFIFO_MEM_ERRf,
        EHG0_RXFIFO_MEM_ERRf, INVALIDm, "HG 0 RX FIFO MEM",
        PORT_EHG_ECC_CONTROLr, EHG_RXFIFO_MEM_ENf,
        PORT_EHG0_RXFIFO_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, EHG1_RXFIFO_MEM_ERRf,
        EHG1_RXFIFO_MEM_ERRf, INVALIDm, "HG 1 RX FIFO MEM",
        PORT_EHG_ECC_CONTROLr, EHG_RXFIFO_MEM_ENf,
        PORT_EHG1_RXFIFO_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, EHG2_RXFIFO_MEM_ERRf,
        EHG2_RXFIFO_MEM_ERRf, INVALIDm, "HG 2 RX FIFO MEM",
        PORT_EHG_ECC_CONTROLr, EHG_RXFIFO_MEM_ENf,
        PORT_EHG2_RXFIFO_ECC_STATUSr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

static
_soc_tr3_parity_info_t _soc_tr3_axp_intb_parity_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0, MASKf, STATUSf, INVALIDm, "INT BUFF 1B",
        AXP_CH_INBUF_ECC_CONTROLr, REPORT_1B_ERRf, INVALIDr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, MASKf, STATUSf, INVALIDm, "INT BUFF",
        AXP_CH_INBUF_ECC_CONTROLr, ENABLEf, AXP_CH_INBUF_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};    

static
_soc_tr3_parity_info_t _soc_tr3_axp_wrx_parity_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0, SVP_PARITY_ERR_INTR_ENf, SVP_PARITY_ERRf,
        AXP_WRX_SVP_ASSIGNMENTm, "WRX SVP", INVALIDr, INVALIDf,
        AXP_WRX_SVP_PARITY_STATUS_INTRr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, WCD_PARITY_ERR_INTR_ENf, WCD_PARITY_ERRf,
        AXP_WRX_WCDm, "WRX WCD", INVALIDr, INVALIDf, 
        AXP_WRX_WCD_PARITY_STATUS_INTRr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

static
_soc_tr3_parity_info_t _soc_tr3_axp_wtx_parity_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0, DVP_PROFILEf, DVP_PROFILEf,
        AXP_WTX_DVP_PROFILEm, "WTX DVP PROFILE",  AXP_WTX_ERR_CHK_ENr, 
        DVP_PROFILE_ECC_ENf, AXP_WTX_DVP_PROFILE_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, TUNNELf, TUNNELf,
        AXP_WTX_TUNNELm, "WTX TUNNEL", AXP_WTX_ERR_CHK_ENr, TUNNEL_ECC_ENf,
        AXP_WTX_TUNNEL_ECC_STATUS_INTRr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, FRAG_IDf, FRAG_IDf,
        AXP_WTX_FRAG_IDm, "WTX FRAG ID", AXP_WTX_ERR_CHK_ENr, FRAG_ID_PAR_ENf,
        AXP_WTX_FRAG_ID_PAR_STATUS_INTRr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, PRI_MAPf, PRI_MAPf,
        AXP_WTX_PRI_MAPm, "WTX PRI MAP", AXP_WTX_ERR_CHK_ENr, PRI_MAP_PAR_ENf,
        AXP_WTX_PRI_MAP_PAR_STATUS_INTRr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, DSCP_MAPf, DSCP_MAPf,
        AXP_WTX_DSCP_MAPm, "WTX DSCP MAP", AXP_WTX_ERR_CHK_ENr, DSCP_MAP_PAR_ENf,
        AXP_WTX_DSCP_MAP_PAR_STATUS_INTRr, NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, TRUNK_BLOCK_MASKf, TRUNK_BLOCK_MASKf, 
        AXP_WTX_TRUNK_BLOCK_MASKm, "WTX TRUNK BLOCK", AXP_WTX_ERR_CHK_ENr, 
        TRUNK_BLOCK_MASK_PAR_ENf, AXP_WTX_TRUNK_BLOCK_MASK_PAR_STATUS_INTRr, 
        NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, TRUNK_GROUP_BITMAPf, TRUNK_GROUP_BITMAPf,
        AXP_WTX_TRUNK_GROUP_BITMAPm, "WTX TRUNK GROUP", AXP_WTX_ERR_CHK_ENr, 
        TRUNK_GROUP_BITMAP_PAR_ENf, AXP_WTX_TRUNK_GROUP_BITMAP_PAR_STATUS_INTRr, 
        NULL, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

static
soc_field_t _soc_tr3_axp_sm_extended_enable_fields[] = {
    DOUBLE_BIT_ERR_INTR_ENf, 
    MULTIPLE_ERR_INTR_ENf,
    PARITY_ERR_INTR_ENf,
    INVALIDf
};

static
_soc_tr3_parity_enable_extra_info_t _soc_tr3_axp_sm_char_remap_extr_enable = {
    AXP_SM_CHAR_REMAP_ECC_INTR_ENABLE_CONTROLr,
    _soc_tr3_axp_sm_extended_enable_fields
};

static
_soc_tr3_parity_enable_extra_info_t _soc_tr3_axp_sm_pkt_buff_extr_enable = {
    AXP_SM_PACKET_BUFFER_ECC_INTR_ENABLE_CONTROLr,
    _soc_tr3_axp_sm_extended_enable_fields
};

static
_soc_tr3_parity_enable_extra_info_t _soc_tr3_axp_sm_flow_tbl_extr_enable = {
    AXP_SM_FLOW_TABLE_ECC_INTR_ENABLE_CONTROLr,
    _soc_tr3_axp_sm_extended_enable_fields
};

static
_soc_tr3_parity_enable_extra_info_t _soc_tr3_axp_sm_match_ctr_extr_enable = {
    AXP_SM_MATCH_COUNTER_ECC_INTR_ENABLE_CONTROLr,
    _soc_tr3_axp_sm_extended_enable_fields
};

static
_soc_tr3_parity_enable_extra_info_t _soc_tr3_axp_sm_match_tbl_extr_enable = {
    AXP_SM_MATCH_TABLE_ECC_INTR_ENABLE_CONTROLr,
    _soc_tr3_axp_sm_extended_enable_fields
};

static
_soc_tr3_parity_enable_extra_info_t _soc_tr3_axp_sm_state_tbl_extr_enable = {
    AXP_SM_STATE_TABLE_ECC_INTR_ENABLE_CONTROLr,
    _soc_tr3_axp_sm_extended_enable_fields
};

static
_soc_tr3_parity_info_t _soc_tr3_axp_sm_parity_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0, INVALIDf, INVALIDf, INVALIDm, 
      "CHAR REMAP", INVALIDr, INVALIDf, AXP_SM_CHAR_REMAP_ECC_INTR_STATUSr, 
      &_soc_tr3_axp_sm_char_remap_extr_enable, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, INVALIDf, INVALIDf,
      AXP_SM_PACKET_BUFFER_MEMm, "PACKET BUFFER", INVALIDr, INVALIDf,
      AXP_SM_PACKET_BUFFER_ECC_INTR_STATUSr, 
      &_soc_tr3_axp_sm_pkt_buff_extr_enable, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, INVALIDf, INVALIDf, INVALIDm, 
      "FLOW TABLE", INVALIDr, INVALIDf, AXP_SM_FLOW_TABLE_ECC_INTR_STATUSr, 
      &_soc_tr3_axp_sm_flow_tbl_extr_enable, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, INVALIDf, INVALIDf, INVALIDm, 
      "MATCH COUNTER", INVALIDr, INVALIDf, 
      AXP_SM_MATCH_COUNTER_ECC_INTR_STATUSr, 
      &_soc_tr3_axp_sm_match_ctr_extr_enable, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, INVALIDf, INVALIDf, INVALIDm, 
      "MATCH TABLE", INVALIDr, INVALIDf, AXP_SM_MATCH_TABLE_ECC_INTR_STATUSr, 
      &_soc_tr3_axp_sm_match_tbl_extr_enable, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, INVALIDf, INVALIDf, INVALIDm, 
      "STATE TABLE", INVALIDr, INVALIDf, AXP_SM_STATE_TABLE_ECC_INTR_STATUSr, 
      &_soc_tr3_axp_sm_state_tbl_extr_enable, INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

static
soc_field_t _soc_tr3_axp_sm_enable_fields[] = {
    REMAP_TABLES_ECC_GEN_ENABLEf,
    PACKET_BUFFER_ECC_GEN_ENABLEf,
    FLOW_TABLE_ECC_GEN_ENABLEf,
    MATCH_COUNTER3_ECC_GEN_ENABLEf,
    MATCH_COUNTER2_ECC_GEN_ENABLEf,
    MATCH_COUNTER1_ECC_GEN_ENABLEf,
    MATCH_COUNTER0_ECC_GEN_ENABLEf,
    MATCH_TABLE3_ECC_GEN_ENABLEf,
    MATCH_TABLE2_ECC_GEN_ENABLEf,
    MATCH_TABLE1_ECC_GEN_ENABLEf,
    MATCH_TABLE0_ECC_GEN_ENABLEf,
    STATE_TABLE7_ECC_GEN_ENABLEf,
    STATE_TABLE6_ECC_GEN_ENABLEf,
    STATE_TABLE5_ECC_GEN_ENABLEf,
    STATE_TABLE4_ECC_GEN_ENABLEf,
    STATE_TABLE3_ECC_GEN_ENABLEf,
    STATE_TABLE2_ECC_GEN_ENABLEf,
    STATE_TABLE1_ECC_GEN_ENABLEf,
    STATE_TABLE0_ECC_GEN_ENABLEf, 
    INVALIDf
};

static
_soc_tr3_parity_enable_extra_info_t _soc_tr3_axp_sm_extra_enable = {
    AXP_SM_MEM_ECC_GEN_CONTROLr,
    _soc_tr3_axp_sm_enable_fields
};

static
_soc_tr3_parity_info_t _soc_tr3_axp_parity_info[] = {
    { _SOC_PARITY_TYPE_AXP, _soc_tr3_axp_intb_parity_info, 0,
        AXP_INT_BUF_MASKf, AXP_INT_BUF_STATUSf, INVALIDm, "AXP INT BUFF",
        AXP_CH_LCL_INT_MASKr, INVALIDf, AXP_CH_LCL_INT_STATUSr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_AXP, _soc_tr3_axp_wrx_parity_info, 0,
        AXP_WRX_MASKf, AXP_WRX_STATUSf, INVALIDm, "AXP WRX",
        AXP_WRX_INTR_ENABLEr, INVALIDf, AXP_WRX_INTR_STATUSr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_AXP, _soc_tr3_axp_wtx_parity_info, 0,
        AXP_WTX_MASKf, AXP_WTX_STATUSf, INVALIDm, "AXP WTX",
        AXP_WTX_INT_MASKr, INVALIDf, AXP_WTX_INT_STATUSr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_AXP, _soc_tr3_axp_sm_parity_info, 0,
        AXP_SM_MASKf, AXP_SM_STATUSf, INVALIDm, "AXP SM", 
        INVALIDr, INVALIDf, INVALIDr, &_soc_tr3_axp_sm_extra_enable,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

static
_soc_tr3_parity_info_t _soc_tr3_ibod_parity_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0, CL1_DATA_FIFO_PERR_INTR_MASKf,
        CL1_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "CL1 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_CL1_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, CL1_CTRL_FIFO_PERR_INTR_MASKf,
        CL1_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "CL1 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_CL1_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, CL0_DATA_FIFO_PERR_INTR_MASKf,
        CL0_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "CL0 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_CL0_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, CL0_CTRL_FIFO_PERR_INTR_MASKf,
        CL0_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "CL0 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_CL0_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, XL1_DATA_FIFO_PERR_INTR_MASKf,
        XL1_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "XL1 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_XL1_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, XL1_CTRL_FIFO_PERR_INTR_MASKf,
        XL1_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "XL1 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_XL1_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, XL0_DATA_FIFO_PERR_INTR_MASKf,
        XL0_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "XL0 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_XL0_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, XL0_CTRL_FIFO_PERR_INTR_MASKf,
        XL0_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "XL0 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_XL0_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, XT3_DATA_FIFO_PERR_INTR_MASKf,
        XT3_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT3 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_XT3_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, XT3_CTRL_FIFO_PERR_INTR_MASKf,
        XT3_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT3 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_XT3_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, XT2_DATA_FIFO_PERR_INTR_MASKf,
        XT2_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT2 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_XT2_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, XT2_CTRL_FIFO_PERR_INTR_MASKf,
        XT2_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT2 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_XT2_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, XT1_DATA_FIFO_PERR_INTR_MASKf,
        XT1_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT1 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_XT1_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, XT1_CTRL_FIFO_PERR_INTR_MASKf,
        XT1_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT1 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_XT1_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, XT0_DATA_FIFO_PERR_INTR_MASKf,
        XT0_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT0 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_XT0_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, XT0_CTRL_FIFO_PERR_INTR_MASKf,
        XT0_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT0 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_XT0_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

static
_soc_tr3_parity_info_t _soc_hx4_ibod_parity_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0, CL1_DATA_FIFO_PERR_INTR_MASKf,
        CL1_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "CL1 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_CL1_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, CL1_CTRL_FIFO_PERR_INTR_MASKf,
        CL1_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "CL1 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_CL1_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, CL0_DATA_FIFO_PERR_INTR_MASKf,
        CL0_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "CL0 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_CL0_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, CL0_CTRL_FIFO_PERR_INTR_MASKf,
        CL0_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "CL0 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_CL0_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, CL2_DATA_FIFO_PERR_INTR_MASKf,
        CL2_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "CL2 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_CL2_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, CL2_CTRL_FIFO_PERR_INTR_MASKf,
        CL2_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "CL2 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_CL2_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, XL0_DATA_FIFO_PERR_INTR_MASKf,
        XL0_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "XL0 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_XL0_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, XL0_CTRL_FIFO_PERR_INTR_MASKf,
        XL0_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "XL0 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_XL0_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, XT3_DATA_FIFO_PERR_INTR_MASKf,
        XT3_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT3 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_XT3_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, XT3_CTRL_FIFO_PERR_INTR_MASKf,
        XT3_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT3 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_XT3_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, XT2_DATA_FIFO_PERR_INTR_MASKf,
        XT2_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT2 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_XT2_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, XT2_CTRL_FIFO_PERR_INTR_MASKf,
        XT2_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT2 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_XT2_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, XT1_DATA_FIFO_PERR_INTR_MASKf,
        XT1_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT1 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_XT1_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, XT1_CTRL_FIFO_PERR_INTR_MASKf,
        XT1_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT1 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_XT1_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 0, XT0_DATA_FIFO_PERR_INTR_MASKf,
        XT0_DATA_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT0 DATA FIFO",
        INVALIDr, INVALIDf, IBOD_XT0_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_ECC, NULL, 1, XT0_CTRL_FIFO_PERR_INTR_MASKf,
        XT0_CTRL_FIFO_PERR_INTR_STATUSf, INVALIDm, "XT0 CTRL FIFO",
        INVALIDr, INVALIDf, IBOD_XT0_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, INVALIDf },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

static
_soc_tr3_fifo_parity_info_t _soc_tr3_ip_parity_info[] = {
    { ISW2_SER_CONTROL_1r, IP_COUNTERS_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, RDBGC_MEM_INST0_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, HG_COUNTERS_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, RDBGC_MEM_INST2_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, ING_TRILL_RX_PKTS_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, ING_TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, ING_TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_ERROR_DROP_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_FORWARDING_DROP_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_VLAN_TAGGED_PARITY_ENf },
/*  { ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_A_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_B_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_C_PARITY_ENf },*/
    { IARB_SER_CONTROLr, LMEP_PARITY_ENf },
    { IARB_SER_CONTROLr, LMEP_DA_PARITY_ENf },
    { IARB_SER_CONTROLr, CMIC_BUF_ECC_ENf },
    { IARB_SER_CONTROLr, AXP_BUF_ECC_ENf },
    { IARB_SER_CONTROLr, CPU_BUF_ECC_ENf },
    { ICFG_SER_CONTROLr, PORT_TABLE_ECC_ENf },
    { ICFG_SER_CONTROLr, SYSTEM_CONFIG_MODVIEW_PARITY_ENf },
    { ICFG_SER_CONTROLr, SYSTEM_CONFIG_PARITY_PARITY_ENf },
    { ICFG_SER_CONTROLr, SOURCE_TRUNK_MAP_MODVIEW_PARITY_ENf },
    { IPARS_SER_CONTROLr, SRC_TRUNK_ECC_ENf },
    { IPARS_SER_CONTROLr, L3_TUNNEL_PARITY_ENf },
    { IPARS_SER_CONTROLr, FP_UDF_PARITY_ENf },
    { IPARS_SER_CONTROLr, MOD_MAP_PARITY_ENf },
    { IPARS_SER_CONTROLr, LPORT_TABLE_ECC_ENf },
    { IPARS_SER_CONTROLr, VLAN_RANGE_PARITY_ENf },
    { IPARS_SER_CONTROLr, CPU_TS_PARITY_ENf },
    { IPARS_SER_CONTROLr, SOURCE_VP_ATTRIBUTES_2_PARITY_ENf },
    { IPARS_SER_CONTROLr, PTP_LABEL_RANGE_PROFILE_TABLE_PARITY_ENf },
    
    { IVXLT_SER_CONTROLr, VLAN_PROT_PARITY_ENf },
    { IVXLT_SER_CONTROLr, VLAN_SUBNET_PARITY_ENf },
    { IVXLT_SER_CONTROLr, VFP_POLICY_PARITY_ENf },
    
    { IMPLS_SER_CONTROLr, MY_STATION_DATA_PARITY_ENf },
    { IMPLS_SER_CONTROLr, VRF_PARITY_ENf },
    { IMPLS_SER_CONTROLr, VFI_1_PARITY_ENf },
    { IMPLS_SER_CONTROLr, VFI_PARITY_ENf },
    { IMPLS_SER_CONTROLr, VLAN_MPLS_PARITY_ENf },
    { IMPLS_SER_CONTROLr, L3_IIF_PARITY_ENf },
    { IMPLS_SER_CONTROLr, SOURCE_VP_PARITY_ENf },
    
    { IVLAN_SER_CONTROLr, VLAN_PARITY_ENf },
    { IVLAN_SER_CONTROLr, VLAN_STG_PARITY_ENf },
    { IL2LU_SER_CONTROLr, L2_USER_ENTRY_DATA_PARITY_ENf },
    { ILPM_SER_CONTROLr, L3_DEFIP_DATA_PARITY_ENf },
    { ILPM_SER_CONTROLr, RTAG7_FLOW_BASED_HASH_PARITY_ENf },
    { IESMIF_PARITY_CONTROLr, L3_PROTOCOL_FN_PARITY_ENf },
    { IESMIF_PARITY_CONTROLr, KEY_ID_TO_FIELD_MAPPER_PARITY_ENf },
    { IESMIF_PARITY_CONTROLr, SEARCH_PROFILE_PARITY_ENf },
    { IESMIF_PARITY_CONTROLr, PKT_TYPE_ID_PARITY_ENf },
    
    { IRSEL1_SER_CONTROLr, INITIAL_L3_ECMP_GROUP_PARITY_ENf },
    { IRSEL1_SER_CONTROLr, INITIAL_L3_ECMP_PARITY_ENf },
    { IRSEL1_SER_CONTROLr, ING_DVP_TABLE_PARITY_ENf },
    { IRSEL1_SER_CONTROLr, INITIAL_PROT_NHI_TABLE_PARITY_ENf },
    { IRSEL1_SER_CONTROLr, INITIAL_ING_L3_NEXT_HOP_PARITY_ENf },
    { IRSEL1_SER_CONTROLr, L3_IPMC_1_PARITY_ENf },
    { IRSEL1_SER_CONTROLr, MA_INDEX_PARITY_ENf },
    { IRSEL1_SER_CONTROLr, MAID_REDUCTION_PARITY_ENf },
    { IRSEL1_SER_CONTROLr, RMEP_PARITY_ENf },
    { IRSEL1_SER_CONTROLr, MA_STATE_PARITY_ENf },
    { IRSEL1_SER_CONTROLr, PORT_CBL_TABLE_MODBASE_PARITY_ENf },
    { IRSEL1_SER_CONTROLr, PORT_CBL_TABLE_PARITY_ENf },
    { IRSEL1_SER_CONTROLr, OAM_OPCODE_CONTROL_PROFILE_PARITY_ENf },
    { IRSEL1_SER_CONTROLr, ESM_ACL_ACTION_TABLE_PARITY_ENf },
    { IRSEL1_SER_CONTROLr, ESM_ACL_PROFILE_TABLE_PARITY_ENf },
    
    { ISW1_SER_CONTROLr, DSCP_TABLE_PARITY_ENf },
    { ISW1_SER_CONTROLr, ING_PRI_CNG_MAP_PARITY_ENf },
    { ISW1_SER_CONTROLr, FP_PORT_FIELD_SEL_PARITY_ENf },
    { ISW1_SER_CONTROLr, TTL_FN_PARITY_ENf },
    { ISW1_SER_CONTROLr, TOS_FN_PARITY_ENf },
    { ISW1_SER_CONTROLr, ING_UNTAGGED_PHB_PARITY_ENf },
    
    { IFP_PARITY_CONTROLr, POLICY_PARITY_ENf },
    { IFP_PARITY_CONTROLr, METER_PARITY_ENf },
    { IFP_PARITY_CONTROLr, COUNTER_PARITY_ENf },
    { IFP_PARITY_CONTROLr, ING_DVP_2_PARITY_ENf },
    { IFP_PARITY_CONTROLr, STORM_PARITY_ENf },
    { IFP_PARITY_CONTROLr, COUNTER_MUX_DATA_STAGING_PARITY_ENf },
    { IRSEL2_SER_CONTROLr, ING_L3_NEXT_HOP_PARITY_ENf },
    { IRSEL2_SER_CONTROLr, L3_ECMP_PARITY_ENf },
    { IRSEL2_SER_CONTROLr, L3_IPMC_REMAP_PARITY_ENf },
    { IRSEL2_SER_CONTROLr, L3_IPMC_PARITY_ENf },
    { IRSEL2_SER_CONTROLr, L3_ECMP_GROUP_PARITY_ENf },
    { IRSEL2_SER_CONTROLr, IFP_REDIRECTION_PROFILE_PARITY_ENf },
    { IRSEL2_SER_CONTROLr, L2MC_PARITY_ENf },
    { IRSEL2_SER_CONTROLr, TRUNK_GROUP_PARITY_ENf },
    { IRSEL2_SER_CONTROLr, ICONTROL_OPCODE_BITMAP_PARITY_ENf },
    { IRSEL2_SER_CONTROLr, EGR_MASK_MODBASE_PARITY_ENf },
    { IRSEL2_SER_CONTROLr, TRUNK_MEMBER_PARITY_ENf },
    { IRSEL2_SER_CONTROLr, DEST_TRUNK_BITMAP_PARITY_ENf },
    
    { ING_IPFIX_SER_CONTROLr, SESSION_TBLf },
    { ING_IPFIX_SER_CONTROLr, EXPORT_FIFOf },
    { ING_IPFIX_SER_CONTROLr, EOP_TBLf },
    { ING_IPFIX_SER_CONTROLr, FLOW_TBLf },
    { DLB_ECMP_SER_CONTROLr, DLB_ECMP_FLOWSET_PARITY_ENf },
    { DLB_ECMP_SER_CONTROLr, DLB_ECMP_FLOWSET_TIMESTAMP_PAGE_PARITY_ENf },
    { DLB_LAG_SER_CONTROLr, DLB_LAG_FLOWSET_PARITY_ENf },
    { DLB_LAG_SER_CONTROLr, DLB_LAG_FLOWSET_TIMESTAMP_PAGE_PARITY_ENf },
    { FT_SER_CONTROLr, SESSION_TBLf },
    { FT_SER_CONTROLr, EXP_TBLf },
    { FT_SER_CONTROLr, EOP_TBLf },
    { FT_SER_CONTROLr, LAG_TBLf },
    { ISW2_SER_CONTROL_0r, ING_L3_NEXT_HOP_ATTRIBUTE_1_INDEX_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, EGR_MASK_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, ING_PW_TERM_SEQ_NUM_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, MODPORT_MAP_SW_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, SRC_MODID_EGRESS_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, TRUNK_BITMAP_TABLE_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, MAC_BLOCK_TABLE_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, NONUCAST_TRUNK_BLOCK_MASK_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, E2E_HOL_STATUS_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, E2E_HOL_STATUS_1_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, SRC_MODID_INGRESS_BLOCK_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, ALTERNATE_EMIRROR_BITMAP_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, PORT_LAG_FAILOVER_SET_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, VLAN_PROFILE_2_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, UNKNOWN_UCAST_BLOCK_MASK_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, UNKNOWN_MCAST_BLOCK_MASK_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, BCAST_BLOCK_MASK_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, ING_EGRMSKBMAP_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, LOCAL_SW_DISABLE_DEFAULT_PBM_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, KNOWN_MCAST_BLOCK_MASK_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, IMIRROR_BITMAP_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, UNKNOWN_HGI_BITMAP_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, ING_HIGIG_TRUNK_OVERRIDE_PROFILE_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, NUM_QCN_CNM_RECEIVED_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, OAM_LM_COUNTERS_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, AXP_WLAN_COS_MAP_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, ING_L3_NEXT_HOP_ATTRIBUTE_1_PARITY_ENf },
    { ISW2_SER_CONTROL_0r, VOQ_MOD_MAP_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL1_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL2_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL3_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, VOQ_PORT_MAP_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, SERVICE_QUEUE_MAP_PARITY_ENf },
    { ISW2_SER_CONTROL_1r, SERVICE_PORT_MAP_PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_0r, PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_1r, PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_2r, PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_3r, PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_4r, PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_5r, PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_6r, PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_7r, PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_8r, PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_9r, PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_10r, PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_11r, PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_12r, PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_13r, PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_14r, PARITY_ENf },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_15r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_0r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_1r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_2r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_3r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_4r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_5r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_6r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_7r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_8r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_9r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_10r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_11r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_12r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_13r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_14r, PARITY_ENf },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_15r, PARITY_ENf },
    { ING_SVM_MACROFLOW_INDEX_TABLE_CONTROLr, PARITY_ENf }, 
    { ING_SVM_METER_TABLE_CONTROLr, PARITY_ENf },
    { ING_SVM_OFFSET_TABLE_CONTROLr, PARITY_ENf },
    { ING_SVM_POLICY_TABLE_CONTROLr, PARITY_ENf }, 
    /* { IL2L3_BUS_SER_CONTROLr, PARITY_ENf }, */ 
    /* { FP_BUS_PARITY_CONTROLr, IFP_BUS_PARITY_ENf }, */ 
    { IESMIF_ECC_CONTROLr, AUX1_FIFO_ECC_ENf },
    { IESMIF_ECC_CONTROLr, ADM_CTRL_FIFO_ECC_ENf },
    { IESMIF_ECC_CONTROLr, ET_RSP_FIFO_ECC_ENf },    
    { IESMIF_ECC_CONTROLr, CTRL_BUS_FIFO_ECC_ENf },
    { IESMIF_ECC_CONTROLr, CTRL_BUS_FIFO_1_ECC_ENf },
    { IESMIF_ECC_CONTROLr, SER_STATUS_BUS_ECC_ENf },
    { IESMIF_PARITY_CONTROLr, AD_6X_PARITY_ENf },
    { IESMIF_PARITY_CONTROLr, AD_4X_PARITY_ENf },
    { IESMIF_PARITY_CONTROLr, AD_3X_PARITY_ENf },
    { IESMIF_PARITY_CONTROLr, AD_2X_PARITY_ENf },
    { IESMIF_PARITY_CONTROLr, AD_1X_PARITY_ENf },
    { INVALIDr }
};

static
_soc_tr3_fifo_parity_info_t _soc_tr3_ep_parity_info[] = {
    { EGR_EL3_SER_CONTROLr, EGR_L3_NEXT_HOP_PARITY_ENf },
    { EGR_EL3_SER_CONTROLr, EGR_MAC_DA_PROFILE_PARITY_ENf },
    { EGR_EL3_SER_CONTROLr, EGR_L3_INTF_PARITY_ENf },
    { EGR_EL3_SER_CONTROLr, EGR_DVP_ATTRIBUTE_PARITY_ENf },
    { EGR_EL3_SER_CONTROLr, EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PARITY_ENf },
    { EGR_EL3_SER_CONTROLr, EGR_VFI_PARITY_ENf },
    { EGR_EL3_SER_CONTROLr, EGR_IPMC_PARITY_ENf },
    { EGR_EL3_SER_CONTROLr, EGR_MAP_MH_PARITY_ENf },
    { EGR_EL3_SER_CONTROLr, EGR_IFP_MOD_FIELDS_PARITY_ENf },
    { EGR_EL3_SER_CONTROLr, EGR_MPB_ECC_ENf },
    { EGR_EVLAN_SER_CONTROLr, EGR_VLAN_PARITY_ENf },
    { EGR_EVLAN_SER_CONTROLr, EGR_VLAN_STG_PARITY_ENf },
    { EGR_EVLAN_SER_CONTROLr, EGR_PRI_CNG_MAP_PARITY_ENf },
    { EGR_EVLAN_SER_CONTROLr, EGR_IP_TUNNEL_PARITY_ENf },
    { EGR_EVLAN_SER_CONTROLr, EGR_MPLS_EXP_MAPPING_1_PARITY_ENf },
    { EGR_EVLAN_SER_CONTROLr, EGR_MPLS_EXP_MAPPING_2_PARITY_ENf },
    { EGR_EVLAN_SER_CONTROLr, EGR_MPLS_PRI_MAPPING_PARITY_ENf },
    { EGR_EVLAN_SER_CONTROLr, EGR_FRAGMENT_ID_TABLE_PARITY_ENf },
    { EGR_EVLAN_SER_CONTROLr, EGR_DSCP_TABLE_PARITY_ENf },
    { EGR_EVLAN_SER_CONTROLr, EGR_GPP_ATTRIBUTES_MODBASE_PARITY_ENf },
    { EGR_EVLAN_SER_CONTROLr, EGR_GPP_ATTRIBUTES_PARITY_ENf },
    { EGR_EVLAN_SER_CONTROLr, EGR_EHG_QOS_MAPPING_TABLE_PARITY_ENf },
    { EGR_EVLAN_SER_CONTROLr, EVLAN_BUS_PARITY_ENf },
    { EGR_EHCPM_SER_CONTROLr, MOD_MAP_PARITY_ENf },
    { EGR_EHCPM_SER_CONTROLr, EHCPM_BUS_PARITY_ENf },
    { EGR_EHCPM_SER_CONTROLr, INITBUF_ECC_ENf },
    { EGR_EFPPARS_SER_CONTROLr, EGR_1588_SA_PARITY_ENf },
    { EGR_EFPPARS_SER_CONTROLr, EFPPARS_BUS_PARITY_ENf },
    { EFP_PARITY_CONTROLr, POLICY_PARITY_ENf },
    { EFP_PARITY_CONTROLr, METER_PARITY_ENf }, /* B0 onwards only */
    { EFP_PARITY_CONTROLr, EGR_PW_INIT_COUNTER_PARITY_ENf },
    { EGR_EDATABUF_PARITY_CONTROLr, EFPCTR_PAR_ENf },
    { EGR_EDATABUF_PARITY_CONTROLr, PERQ_PAR_ENf },
    { EGR_EDATABUF_PARITY_CONTROLr, STATS_PAR_ENf },
    { EGR_EDATABUF_PARITY_CONTROLr, XTP_RESI_ECC_ENf }, /* B0 onwards only */
    { EGR_EDATABUF_PARITY_CONTROLr, CLP1_ECC_ENf },
    { EGR_EDATABUF_PARITY_CONTROLr, CLP0_ECC_ENf },
    { EGR_EDATABUF_PARITY_CONTROLr, XTP3_ECC_ENf },
    { EGR_EDATABUF_PARITY_CONTROLr, XTP2_ECC_ENf },
    { EGR_EDATABUF_PARITY_CONTROLr, XTP1_ECC_ENf },
    { EGR_EDATABUF_PARITY_CONTROLr, XTP0_ECC_ENf },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP1_ECC_ENf },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP0_ECC_ENf },
    { EGR_EDATABUF_PARITY_CONTROLr, CM_ECC_ENf },
    { EGR_IPFIX_SER_CONTROLr, SESSION_TBLf },
    { EGR_IPFIX_SER_CONTROLr, EXPORT_FIFOf },
    { EGR_IPFIX_SER_CONTROLr, EOP_TBLf },
    { EGR_IPFIX_SER_CONTROLr, FLOW_TBLf },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_0r, PARITY_ENf },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_1r, PARITY_ENf },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_2r, PARITY_ENf },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_3r, PARITY_ENf },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_4r, PARITY_ENf },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_5r, PARITY_ENf },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_6r, PARITY_ENf },
    { EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_7r, PARITY_ENf },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_0r, PARITY_ENf },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_1r, PARITY_ENf },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_2r, PARITY_ENf },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_3r, PARITY_ENf },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_4r, PARITY_ENf },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_5r, PARITY_ENf },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_6r, PARITY_ENf },
    { EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_7r, PARITY_ENf },
    { EGR_EPMOD_SER_CONTROLr, EPMOD_BUS_PARITY_ENf },
    { EFP_BUS_PARITY_CONTROLr, EFP_BUS_PARITY_ENf },
    { INVALIDr }
};

static
_soc_tr3_fifo_parity_info_t _soc_tr3_ism_parity_info[] = {
    { HASH_TABLE_PARITY_CONTROLr, TABLE0_PARITY_ENf },
    { HASH_TABLE_PARITY_CONTROLr, TABLE1_PARITY_ENf },
    { HASH_TABLE_PARITY_CONTROLr, TABLE2_PARITY_ENf },
    { HASH_TABLE_PARITY_CONTROLr, TABLE3_PARITY_ENf },
    { HASH_TABLE_PARITY_CONTROLr, TABLE4_PARITY_ENf },
    { L2_MOD_FIFO_PARITY_CONTROLr, L2_MOD_FIFO_PARITY_ENf },
  /*{ MAC_LIMIT_PARITY_CONTROLr, PORT_OR_TRUNK_MAC_COUNT_PARITY_ENf },
    { MAC_LIMIT_PARITY_CONTROLr, PORT_OR_TRUNK_MAC_LIMIT_PARITY_ENf },*/
    { MAC_LIMIT_PARITY_CONTROLr, VLAN_OR_VFI_MAC_COUNT_PARITY_ENf },
    { MAC_LIMIT_PARITY_CONTROLr, VLAN_OR_VFI_MAC_LIMIT_PARITY_ENf },
    { LEARN_FIFO_ECC_CONTROLr, ECC_ENf },
    { INVALIDr }
};

static const
_soc_tr3_parity_block_info_t _soc_tr3_parity_block_info[] = {
    { SOC_BLK_IPIPE, ING_SER_FIFO_CTRLr, _soc_tr3_ip_parity_info },
    { SOC_BLK_EPIPE, EGR_SER_FIFO_CTRLr, _soc_tr3_ep_parity_info },
    { SOC_BLK_ISM, ISM_SER_FIFO_CTRLr, _soc_tr3_ism_parity_info },
    { 0 }
};

#define _TR3_IRSEL1_TO_CMIC_OAM_INTR 0x00000010
#define _TR3_IP0_TO_CMIC_PERR_INTR   0x00000004
#define _TR3_IP5_TO_CMIC_PERR_INTR   0x00000020
#define _TR3_IP_TO_CMIC_PERR_INTR  (_TR3_IP0_TO_CMIC_PERR_INTR | _TR3_IP5_TO_CMIC_PERR_INTR)

static const
_soc_tr3_parity_route_block_t  _soc_tr3_parity_route_blocks[] = {
    { 0, 0x00000001, /* MMU_TO_CMIC_MEMFAIL_INTR */
      SOC_BLK_MMU, MEM_FAIL_INT_EN_64r, MEM_FAIL_INT_STAT_64r, INVALIDf,
      _soc_tr3_mmu_parity_info, 0 },
    { 0, 0x00000002, /* EP2_TO_CMIC_PERR_INTR */
      SOC_BLK_EPIPE, EGR_INTR_ENABLEr, INVALIDr, SER_FIFO_NON_EMPTYf,
      NULL, 0 },
    { 0, _TR3_IP0_TO_CMIC_PERR_INTR, /* IP0_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0, 0x00000008, /* IESMIF_TO_CMIC_ERR_INTR */
      SOC_BLK_IPIPE, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0, 0x00000010, /* IRSEL1_TO_CMIC_OAM_INTR */
      SOC_BLK_IPIPE, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0, _TR3_IP5_TO_CMIC_PERR_INTR, /* IP5_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0, 0x00000040, /* XTP0_TO_CMIC_PERR_INTR */
      SOC_BLK_XTPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 0 },
    { 0, 0x00000080, /* XTP1_TO_CMIC_PERR_INTR */
      SOC_BLK_XTPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 1 },
    { 0, 0x00000100, /* XTP2_TO_CMIC_PERR_INTR */
      SOC_BLK_XTPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 2 },
    { 0, 0x00000200, /* XTP3_TO_CMIC_PERR_INTR */
      SOC_BLK_XTPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 3 },
    { 0, 0x00000400, /* XLP0_TO_CMIC_PERR_INTR */
      SOC_BLK_XLPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 0  },
    { 0, 0x00000800, /* XLP1_TO_CMIC_PERR_INTR */
      SOC_BLK_XLPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 1 },
    { 0, 0x00001000, /* CLP0_TO_CMIC_PERR_INTR */
      SOC_BLK_CLPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 0 },
    { 0, 0x00002000, /* CLP0_TO_CMIC_PERR_INTR */
      SOC_BLK_CLPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 1 },
    { 0, 0x00004000, /* PCIE_REPLAY_PERR */
      SOC_BLK_CMIC, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 1, _SOC_TR3_ISM_INTR_MASK, /* ISM_TO_CMIC_INTR */
      SOC_BLK_ISM, ISM_INTR_MASKr, ISM_INTRr, SER_FIFO_NOT_EMPTYf, NULL, 0 },
    { 1, _SOC_TR3_AXP_INTR_MASK, /* AXP_TO_CMIC_INTR */
      SOC_BLK_AXP, AXP_CH_INT_MASKr, AXP_CH_INT_STATUSr, INVALIDf,
      _soc_tr3_axp_parity_info, 0 },
    { 1, _SOC_TR3_IBOD_INTR_MASK, /* BOD_TO_CMIC_INTR */
      SOC_BLK_IBOD, IBOD_INTR_MASKr, IBOD_INTR_STATUSr, INVALIDf,
      _soc_tr3_ibod_parity_info, 0 },
    { 0, 0 } /* table terminator */
};

static const
_soc_tr3_parity_route_block_t  _soc_hx4_parity_route_blocks[] = {
    { 0, 0x00000001, /* MMU_TO_CMIC_MEMFAIL_INTR */
      SOC_BLK_MMU, MEM_FAIL_INT_EN_64r, MEM_FAIL_INT_STAT_64r, INVALIDf,
      _soc_tr3_mmu_parity_info, 0 },
    { 0, 0x00000002, /* EP2_TO_CMIC_PERR_INTR */
      SOC_BLK_EPIPE, EGR_INTR_ENABLEr, INVALIDr, SER_FIFO_NON_EMPTYf,
      NULL, 0 },
    { 0, _TR3_IP0_TO_CMIC_PERR_INTR, /* IP0_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0, 0x00000010, /* IRSEL1_TO_CMIC_OAM_INTR */
      SOC_BLK_IPIPE, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0, _TR3_IP5_TO_CMIC_PERR_INTR, /* IP5_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0, 0x00000040, /* XTP0_TO_CMIC_PERR_INTR */
      SOC_BLK_XTPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 0 },
    { 0, 0x00000080, /* XTP1_TO_CMIC_PERR_INTR */
      SOC_BLK_XTPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 1 },
    { 0, 0x00000100, /* XTP2_TO_CMIC_PERR_INTR */
      SOC_BLK_XTPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 2 },
    { 0, 0x00000200, /* XTP3_TO_CMIC_PERR_INTR */
      SOC_BLK_XTPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 3 },
    { 0, 0x00000400, /* XLP0_TO_CMIC_PERR_INTR */
      SOC_BLK_XLPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 0  },
    { 0, 0x00000800, /* XWP0_TO_CMIC_PERR_INTR */
      SOC_BLK_XWPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 0 },
    { 0, 0x00001000, /* XWP1_TO_CMIC_PERR_INTR */
      SOC_BLK_XWPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 1 },
    { 0, 0x00002000, /* XWP2_TO_CMIC_PERR_INTR */
      SOC_BLK_XWPORT, PORT_INTR_ENABLEr, PORT_INTR_STATUSr, INVALIDf,
      _soc_tr3_port_parity_info, 2 },
    { 0, 0x00004000, /* PCIE_REPLAY_PERR */
      SOC_BLK_CMIC, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 1, _SOC_TR3_ISM_INTR_MASK, /* ISM_TO_CMIC_INTR */
      SOC_BLK_ISM, ISM_INTR_MASKr, ISM_INTRr, SER_FIFO_NOT_EMPTYf, NULL, 0 },
    { 1, _SOC_TR3_AXP_INTR_MASK, /* AXP_TO_CMIC_INTR */
      SOC_BLK_AXP, AXP_CH_INT_MASKr, AXP_CH_INT_STATUSr, INVALIDf,
      _soc_tr3_axp_parity_info, 0 },
    { 1, _SOC_TR3_IBOD_INTR_MASK, /* BOD_TO_CMIC_INTR */
      SOC_BLK_IBOD, IBOD_INTR_MASKr, IBOD_INTR_STATUSr, INVALIDf,
      _soc_hx4_ibod_parity_info, 0 },
    { 0, 0 } /* table terminator */
};

static soc_ser_functions_t _tr3_ser_functions;

static soc_tr3_oam_handler_t tr3_oam_handler[SOC_MAX_NUM_DEVICES] = {NULL};
static soc_tr3_oam_ser_handler_t tr3_oam_ser_handler[SOC_MAX_NUM_DEVICES] = {NULL};

STATIC int
_soc_tr3_parity_enable_info(int unit, int port, soc_reg_t group_reg, uint64 *group_rval,
                            const _soc_tr3_parity_info_t *info_list,
                            soc_mem_t mem, int enable)
{
    const _soc_tr3_parity_info_t *info;
    int info_index;
    soc_reg_t reg;
    uint32 rval;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }

        if (mem != INVALIDm && info->mem != mem) {
            continue;
        }

        if (group_reg != INVALIDr && group_rval && 
            info->group_reg_enable_field != INVALIDf) {
            /* Enable the info entry in the group register */
            if (SOC_REG_IS_64(unit, group_reg)) {
                soc_reg64_field32_set(unit, group_reg, group_rval,
                                      info->group_reg_enable_field, enable ? 1 : 0);
            } else {
                rval = COMPILER_64_LO(*group_rval);
                soc_reg_field_set(unit, group_reg, &rval,
                                  info->group_reg_enable_field, enable ? 1 : 0);
                COMPILER_64_SET(*group_rval, 0, rval);
            }
        }
        /* Handle different parity error enabling style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_PARITY:
        case _SOC_PARITY_TYPE_ECC:
        case _SOC_PARITY_TYPE_AXP:
            reg = info->enable_reg;
            if (reg != INVALIDr && info->enable_field != INVALIDf) {
                SOC_IF_ERROR_RETURN
                    (soc_reg32_get(unit, reg, port, 0, &rval));
                soc_reg_field_set(unit, reg, &rval, info->enable_field,
                                      enable ? 1 : 0);
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, port, 0, rval));
            }
            if (info->ext_en != NULL) {
                reg = info->ext_en->enable_reg;
                if (reg != INVALIDr) {
                    uint8 fidx = 0;
                    
                    SOC_IF_ERROR_RETURN
                        (soc_reg32_get(unit, reg, port, 0, &rval));
                    while (info->ext_en->enable_field_list[fidx] != INVALIDf) {
                        soc_reg_field_set(unit, reg, &rval,
                                          info->ext_en->enable_field_list[fidx],
                                          enable ? 1 : 0);
                        fidx++;
                    }
                    SOC_IF_ERROR_RETURN
                        (soc_reg32_set(unit, reg, port, 0, rval));
                }
            }
            if (info->info != NULL) {
                if (info->enable_reg != INVALIDr) {
                    uint64 rval64;
                    SOC_IF_ERROR_RETURN
                        (soc_reg32_get(unit, info->enable_reg, port, 0, &rval));
                    COMPILER_64_SET(rval64, 0, rval);
                    SOC_IF_ERROR_RETURN
                        (_soc_tr3_parity_enable_info(unit, port, info->enable_reg,
                                                     &rval64, info->info, 
                                                     INVALIDm, enable));
                    
                    rval = COMPILER_64_LO(rval64);
                    SOC_IF_ERROR_RETURN
                        (soc_reg32_set(unit, info->enable_reg, port, 0, rval));
                } else {
                    SOC_IF_ERROR_RETURN
                        (_soc_tr3_parity_enable_info(unit, port, INVALIDr,
                                                     NULL, info->info, 
                                                     INVALIDm, enable));
                }
            }
            break;
        case _SOC_PARITY_TYPE_GENERIC:
        case _SOC_PARITY_TYPE_MMU_THDO:
        case _SOC_PARITY_TYPE_MMU_THDI:
        case _SOC_PARITY_TYPE_MMU_WRED:
        case _SOC_PARITY_TYPE_MMU_QCN:
        case _SOC_PARITY_TYPE_MMU_LLS:
        case _SOC_PARITY_TYPE_BST:
        default:
            break;
        } /* Handle different parity error enabling style */
        if (mem != INVALIDm) {
            break;
        }
    } /* Loop through each info entry in the route block */
    return SOC_E_NONE;
}

STATIC int
_soc_tr3_parity_enable_all(int unit, int enable)
{
    int         rv, blk_inf_idx, port = REG_PORT_ANY;
    uint8       rbi, bcount;
    uint16      pcount;
    uint32      cmic_bit, cmic_rval1 = 0, cmic_rval2 = 0;
    uint32      rval;
    uint64      rval64;
    soc_reg_t   reg;
    soc_field_t field;
    const       _soc_tr3_parity_route_block_t *rb;
    uint16      dev_id;
    uint8       rev_id;
    
    soc_cm_get_id(unit, &dev_id, &rev_id);

    for (bcount = 0; _soc_tr3_parity_block_info[bcount].blocktype; bcount++) {
        for (pcount = 0;
             _soc_tr3_parity_block_info[bcount].info[pcount].enable_reg != INVALIDr;
             pcount++) {
            reg = _soc_tr3_parity_block_info[bcount].info[pcount].enable_reg;
            field = _soc_tr3_parity_block_info[bcount].info[pcount].enable_field;
            if (!SOC_REG_IS_VALID(unit, reg) ||
                !soc_reg_field_valid(unit, reg, field)) {
                continue;
            }
            if (!(soc_feature(unit, soc_feature_esm_support) || SOC_CONTROL(unit)->tcam_info) &&
                SOC_BLOCK_IS(SOC_REG_INFO(unit,reg).block, SOC_BLK_IPIPE) && 
                SOC_REG_STAGE(unit, reg) == 0x9) { /* IESMIF */
                continue;
            }
            if ((rev_id & 0xF0) && /* These work on B0 onwards only */
                ((reg == EFP_PARITY_CONTROLr && field == METER_PARITY_ENf) || 
                 (reg == EGR_EDATABUF_PARITY_CONTROLr && field == XTP_RESI_ECC_ENf))) {
                 if (field == XTP_RESI_ECC_ENf) {
                     /*  disable the parity on the egress residual buffer */
                     rv = soc_reg_field32_modify(unit, reg, REG_PORT_ANY, field,
                                                 0);
                     if (SOC_FAILURE(rv)) {
                         return rv;
                     }
                 }
                continue;
            }
            rv = soc_reg_field32_modify(unit, reg, REG_PORT_ANY, field,
                                        (enable ? 1 : 0));
            if (SOC_FAILURE(rv)) {
                return rv;
            }
        }
        /* Loop through each place-and-route block entry */
        for (rbi = 0; ; rbi++) {
            rb = SOC_IS_HELIX4(unit) ? &_soc_hx4_parity_route_blocks[rbi]: 
                                       &_soc_tr3_parity_route_blocks[rbi];
            cmic_bit = rb->cmic_bit;
            if (cmic_bit == 0) {
                /* End of table */
                break;
            }
            if (rb->blocktype == _soc_tr3_parity_block_info[bcount].blocktype) {
                /* New SER mechanism */
                if (enable) {
                    if (rb->cmic_reg == 0) {
                        cmic_rval1 |= cmic_bit;
                    } else {
                        cmic_rval2 |= cmic_bit;
                    }
                }
                if (rb->enable_reg != INVALIDr) {
                    SOC_IF_ERROR_RETURN
                        (soc_reg_field32_modify(unit, rb->enable_reg,
                            REG_PORT_ANY, rb->enable_field, enable ? 1 : 0));
                }
            }
        }
        /* reset (toggle) fifo if applicable */
        if (_soc_tr3_parity_block_info[bcount].fifo_reset_reg != INVALIDr) {
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     _soc_tr3_parity_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 1));
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     _soc_tr3_parity_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 0));
        }
    }
    /* Loop through each place-and-route block entry */
    for (rbi = 0; ; rbi++) {
            rb = SOC_IS_HELIX4(unit) ? &_soc_hx4_parity_route_blocks[rbi]: 
                                       &_soc_tr3_parity_route_blocks[rbi];
        cmic_bit = rb->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        if (rb->info == NULL) {
            continue;
        }
        if (enable) {
            if (rb->cmic_reg == 0) {
                cmic_rval1 |= cmic_bit;
            } else {
                cmic_rval2 |= cmic_bit;
            }
        }
        /* Legacy style SER enabling */
        SOC_BLOCK_ITER(unit, blk_inf_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, blk_inf_idx).number == rb->id) {
                port = SOC_BLOCK_PORT(unit, blk_inf_idx);
                break;
            }
        }
        if (SOC_BLOCK_IN_LIST(SOC_REG_INFO(unit, rb->enable_reg).block, 
            SOC_BLK_PORT) && (port == REG_PORT_ANY)) {
                /* This port block is not configured */
                continue;
        } 
        if (rb->enable_reg != INVALIDr) {
            if (SOC_REG_IS_64(unit, rb->enable_reg)) {
                SOC_IF_ERROR_RETURN(soc_reg_get(unit, rb->enable_reg,
                                                port, 0, &rval64));
            } else {
                SOC_IF_ERROR_RETURN(soc_reg32_get(unit, rb->enable_reg,
                                                  port, 0, &rval));
            
                COMPILER_64_SET(rval64, 0, rval);
            }
        }
        rv = _soc_tr3_parity_enable_info(unit, port, rb->enable_reg,
                                         &rval64, rb->info,
                                         INVALIDm, enable);
        if (rv == SOC_E_NOT_FOUND) {
            continue;
        } else if (SOC_FAILURE(rv)) {
            return rv;
        }
        /* Write per route block parity enable register */
        if (SOC_REG_IS_64(unit, rb->enable_reg)) {
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, rb->enable_reg, port, 0, rval64));
        } else {
            rval =  COMPILER_64_LO(rval64);
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, rb->enable_reg, port, 0, rval));
        }
    }

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_STAT_CLEARf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
    if (enable) {
        /* MMU enables */
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_CHK_ENf, 1);
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_GEN_ENf, 1);
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_STAT_CLEARf, 0);
        soc_reg_field_set(unit, MISCCONFIGr, &rval, METERING_CLK_ENf, 1);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        /* Write CMIC enable register */
        (void)soc_cmicm_intr2_enable(unit, cmic_rval1);
        (void)soc_cmicm_intr1_enable(unit, cmic_rval2);
    } else {
        /* MMU disables */
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_CHK_ENf, 0);
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_GEN_ENf, 0);
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_STAT_CLEARf, 0);
        soc_reg_field_set(unit, MISCCONFIGr, &rval, METERING_CLK_ENf, 0);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        /* Write CMIC disable register */
        (void)soc_cmicm_intr2_disable(unit, cmic_rval1);
        (void)soc_cmicm_intr1_disable(unit, cmic_rval2);
    }

    return SOC_E_NONE;
}

static char *_soc_tr3_ser_hwmem_base_info[] = {
    "CMIC PKT BUFFER - In Iarb",
    "CPU PKT BUFFER - In Iarb",
    "AXP PACKET BUFFER - In Iarb",
    "IFP COUNTER MUX DATA STAGING - In Ifp",
    "INGRESS PACKET BUFFER - In Ipars",
    "ESM AUX1 FIFO - In Iesmif",
    "ESM CTRL BUS FIFO - In Iesmif",
    "ESM ADM CTRL FIFO - In Iesmif",
    "ESM ET RSP FIFO - In Iesmif",
    "ESM CTRL BUS FIFO 1 - In Iesmif",
    "ESM SER STATUS BUS FIFO - In Iesmif",
    "ISW2 EOP BUFFER A - In Iesmif",
    "ISW2 EOP BUFFER B - In Iesmif",
    "ISW2 EOP BUFFER C - In Iesmif",
    "Invalid value",
    "Invalid value",
    "EP MPB DATA - In El3",
    "EP INITBUF - In Ehcpm",
    "CM DATA BUFFER - In Edatabuf",
    "XLP0 DATA BUFFER - In Edatabuf",
    "XLP1 DATA BUFFER - In Edatabuf",
    "XTP0 DATA BUFFER - In Edatabuf",
    "XTP1 DATA BUFFER - In Edatabuf",
    "XTP2 DATA BUFFER - In Edatabuf",
    "XTP3 DATA BUFFER - In Edatabuf",
    "CLP0 DATA BUFFER - In Edatabuf",
    "CLP1 DATA BUFFER - In Edatabuf",
    "XTP RESI DATA BUFFER - In Edatabuf",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "IPARS - PassThrought bus parity check",
    "IVXLT - PassThrought bus parity check",
    "IMPLS - PassThrought bus parity check",
    "IL2L3 - PassThrought bus parity check",
    "IESMIF - PassThrought bus parity check",
    "IFP - PassThrought bus parity check",
    "IRSEL1 - PassThrought bus parity check",
    "ISW1 - PassThrought bus parity check",
    "IRSEL2 - PassThrought bus parity check",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "EGR VLAN - PassThrought bus parity check",
    "EGR HCPM - PassThrought bus parity check",
    "EGR PMOD - PassThrought bus parity check",
    "EGR FPPARS - PassThrought bus parity check",
    "EFP - PassThrought bus parity check",
};

STATIC void
_soc_tr3_print_parity_fifo_details(int unit, uint8 regmem, soc_block_t blk, uint32 sblk, 
                                   uint32 address, uint32 stage, uint32 base, 
                                   uint32 index, uint32 hwmbase, uint32 hwmbase_ism,
                                   uint32 type, uint8 drop)
{
    if (bsl_check(bslLayerSoc, bslSourceCommon, bslSeverityError, unit)) {
        switch (type) {
        case 0:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: SOP cell.\n")));
            break;
        case 1:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: MOP cell.\n")));
            break;
        case 2:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: EOP cell.\n")));
            break;
        case 3:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: SBUS transaction.\n")));
            break;
        case 4:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Error in: miscellaneous transaction.\n")));
            break;
        default:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Invalid error reported !!\n")));
            break;
        }
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Blk: %d, Address: 0x%08x, base: 0x%x, stage: %d, index: %d\n"), 
                              sblk, address, base, stage, index));
        if (!regmem) {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "Mem hwbase: 0x%02x [%s], ISM hwbase: 0x%x\n"), hwmbase,
                                    (hwmbase < 0x35) ? 
                         (SOC_IS_HELIX4(unit) ? _soc_hx4_ser_hwmem_base_info[hwmbase] :
                         _soc_tr3_ser_hwmem_base_info[hwmbase]) : "--", 
                         (blk == SOC_BLK_ISM) ? hwmbase_ism : 0));
        }
        if (drop) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "SER caused packet drop.\n")));
        }
    }
}

STATIC int
_soc_tr3_process_parity_fifo(int unit, soc_block_t blk, char *prefix_str)
{
    uint32 reg_val, mask, entry[SOC_MAX_MEM_WORDS];
    soc_reg_t reg = INVALIDr;
    soc_mem_t mem;
    uint32 sblk = 0, regmem, sbus, drop, ecc_parity, address;
    uint32 stage, addrbase, index, hwmbase, hwmbase_ism, type;
    uint8 bidx;
    char blk_str[10];
    _soc_ser_correct_info_t spci;

    switch (blk) {
    case SOC_BLK_IPIPE:
        mem = ING_SER_FIFOm;
        mask = _TR3_IP_TO_CMIC_PERR_INTR;
        sal_sprintf(blk_str, "IPIPE");
        break;
    case SOC_BLK_EPIPE:
        mem = EGR_SER_FIFOm;
        mask = 0x00000001; /* SER_FIFO_NON_EMPTYf */
        reg = EGR_INTR_STATUSr;
        sal_sprintf(blk_str, "EPIPE");
        break;
    case SOC_BLK_ISM:
        mem = ISM_SER_FIFOm;
        mask = 0x00000002; /* SER_FIFO_NOT_EMPTYf */
        reg = ISM_INTRr;
        sal_sprintf(blk_str, "ISM");
        break;
    default: return SOC_E_PARAM;
    }

    do {
        SOC_IF_ERROR_RETURN
            (soc_mem_pop(unit, mem, MEM_BLOCK_ANY, entry));
        /* process entry */
        if (soc_mem_field32_get(unit, mem, entry, VALIDf)) {
            ecc_parity = soc_mem_field32_get(unit, mem, entry, ECC_PARITYf);
            regmem = soc_mem_field32_get(unit, mem, entry, MEM_TYPEf);
            address = soc_mem_field32_get(unit, mem, entry, ADDRESSf);
            stage = soc_mem_field32_get(unit, mem, entry, PIPE_STAGEf);
            type = soc_mem_field32_get(unit, mem, entry, INSTRUCTION_TYPEf);
            drop = soc_mem_field32_get(unit, mem, entry, DROPf);
            SOC_BLOCK_ITER(unit, bidx, blk) {
                sblk = SOC_BLOCK2SCH(unit, bidx);
                break;
            }
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s\n"), prefix_str));
            if (soc_mem_field32_get(unit, mem, entry, MULTIPLEf)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Multiple: ")));
            }
            if (regmem) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Reg: ")));
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Mem: ")));
            }
            sal_memset(&spci, 0, sizeof(spci));
            spci.double_bit = 0;
            switch (ecc_parity) {
            case 0:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Parity error..\n"))); 
                break;
            case 1:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Corrected single bit ECC error..\n"))); 
                break;
            case 2:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Double or Multiple bit ECC error..\n"))); 
                spci.double_bit = 1;
                break;
            default:
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Invalid SER issue !!\n")));
                return SOC_E_INTERNAL;
            }
            if (regmem == 0) {
                /* process mem */
                sbus = soc_mem_field32_get(unit, mem, entry, NON_SBUSf);
                addrbase = soc_mem_field32_get(unit, mem, entry, MEMBASEf);
                index = soc_mem_field32_get(unit, mem, entry, MEMINDEXf);
                hwmbase = soc_mem_field32_get(unit, mem, entry, HWMEMBASEf);
                if (sbus == 0) {
                    hwmbase_ism = soc_mem_field32_get(unit, mem, entry, HWMEMBASE_ISMf);
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                       ecc_parity == 0 ? 
                                       SOC_SWITCH_EVENT_DATA_ERROR_PARITY :
                                       SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                                       sblk | SOC_SER_ERROR_DATA_BLK_ADDR_SET, address);
                    _soc_tr3_print_parity_fifo_details(unit, 0, blk, sblk,
                                                       address, stage, addrbase,
                                                       index, hwmbase, hwmbase_ism,
                                                       type, drop);
                    spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_UNKNOWN;
                    spci.reg = INVALIDr;
                    spci.mem = INVALIDm;
                    spci.blk_type = blk;
                    spci.sblk = sblk;
                    spci.addr = address - index;
                    spci.index = index;
                    (void)soc_ser_correction(unit, &spci);
                } else {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "%s SER mem address un-accessable !!\n"), blk_str));
                    _soc_tr3_print_parity_fifo_details(unit, 0, blk, sblk,
                                                       address, stage, addrbase,
                                                       index, hwmbase, 0,
                                                       type, drop);
                }
            } else {
                /* process reg */
                sbus = soc_mem_field32_get(unit, mem, entry, NON_SBUSf);
                addrbase = soc_mem_field32_get(unit, mem, entry, REGBASEf);
                index = soc_mem_field32_get(unit, mem, entry, REGINDEXf);
                if (sbus == 0) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                       ecc_parity == 0 ? 
                                       SOC_SWITCH_EVENT_DATA_ERROR_PARITY :
                                       SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                                       sblk | SOC_SER_ERROR_DATA_BLK_ADDR_SET, address);
                    _soc_tr3_print_parity_fifo_details(unit, 1, blk, sblk,
                                                       address, stage, addrbase,
                                                       index, 0, 0, type, drop);
                    spci.flags = SOC_SER_SRC_REG | SOC_SER_REG_MEM_UNKNOWN;
                    spci.reg = INVALIDr;
                    spci.mem = INVALIDm;
                    spci.blk_type = blk;
                    spci.sblk = sblk;
                    spci.addr = address;
                    spci.index = index;
                    (void)soc_ser_correction(unit, &spci);
                } else {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "%s SER reg address un-accessable !!\n"), blk_str));
                    _soc_tr3_print_parity_fifo_details(unit, 1, blk, sblk,
                                                       address, stage, addrbase,
                                                       index, 0, 0, type, drop);
                }
            }
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Got invalid mem pop from %s !!\n"),
                                  SOC_MEM_NAME(unit, mem)));
        }
        /* check if any more pending */
        if (reg == INVALIDr) {
            SOC_IF_ERROR_RETURN
                (READ_CMIC_CMC0_IRQ_STAT2r(unit, &reg_val));
        } else {
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &reg_val));
        }
    } while (reg_val & mask);
    return SOC_E_NONE;
}

STATIC int
_soc_tr3_parity_process_ecc(int unit, soc_mem_t mem, uint8 force_check, int port,
                            const _soc_tr3_parity_info_t *info,
                            char *prefix_str, char *mem_str)
{
    _soc_tr3_parity_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    uint8 has_error;
    uint32 rval;
    uint32 multiple, double_bit, entry_idx, idx;
    char *mem_str_ptr;
    _soc_ser_correct_info_t spci;
    soc_field_t ecc_fields[][5] = {
        { ECC_ERRf, DOUBLE_BIT_ERRf, MULTIPLE_ERRf, ENTRY_IDXf, TABLE_IDXf },
        { PARITY_ERRf, DOUBLE_BIT_ERRf, MULTIPLE_ERRf, ENTRY_IDXf, TABLE_IDXf },
        { CTRL_FIFO_ECC_ERRf, CTRL_FIFO_DOUBLE_BIT_ERRf, CTRL_FIFO_MULTIPLE_ERRf, 
          CTRL_FIFO_ENTRY_IDXf, TABLE_IDXf },
        { DATA_FIFO_ECC_ERRf, DATA_FIFO_DOUBLE_BIT_ERRf, DATA_FIFO_MULTIPLE_ERRf,
          DATA_FIFO_ENTRY_IDXf, TABLE_IDXf }
    };

    if (info->intr_status_reg != INVALIDr) {
        reg_entry[0].reg = info->intr_status_reg;
        reg_entry[0].mem_str = NULL;
        reg_entry[1].reg = INVALIDr;
        reg_ptr = reg_entry;
    } else {
        return SOC_E_NONE;
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        uint8 combo = 0;
        soc_field_t *fields = ecc_fields[0];
        reg = reg_ptr[idx].reg;
        mem_str_ptr = reg_ptr[idx].mem_str != NULL ?
            reg_ptr[idx].mem_str : mem_str;
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, port, 0, &rval));
        if (!SOC_REG_FIELD_VALID(unit, reg, fields[0])) {
            fields = ecc_fields[1];
        }
        if (!SOC_REG_FIELD_VALID(unit, reg, fields[0])) {
            fields = ecc_fields[2];
            if (info->id) {
                fields = ecc_fields[3];
            }
            combo = 1;
        }
        if (soc_reg_field_get(unit, reg, rval, fields[0])) {
            uint8 mt = FALSE, ti = 0;
            has_error = TRUE;
            double_bit = soc_reg_field_get(unit, reg, rval, fields[1]);
            multiple = soc_reg_field_get(unit, reg, rval, fields[2]);
            entry_idx = soc_reg_field_get(unit, reg, rval, fields[3]);
            if (SOC_REG_FIELD_VALID(unit, reg, fields[4])) {
                mt = TRUE;
                ti = soc_reg_field_get(unit, reg, rval, fields[4]);
            }
            if (double_bit) {
                if (!mt) {
                    spci.double_bit = 1;
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "%s %s entry %d double-bit ECC error\n"),
                               prefix_str, mem_str_ptr, entry_idx));
                } else {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "%s %s table %d entry %d double-bit ECC error\n"),
                               prefix_str, mem_str_ptr, ti, entry_idx));
                }
            } else {
                spci.double_bit = 0;
            }
            if (!mt && mem != INVALIDm) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s entry %d ECC error\n"),
                           prefix_str, mem_str_ptr, entry_idx));
                sal_memset(&spci, 0, sizeof(spci));
                spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
                spci.reg = INVALIDr;
                spci.mem = mem;
                spci.blk_type = -1;
                spci.index = entry_idx;
                (void)soc_ser_correction(unit, &spci);
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s table %d entry %d ECC error\n"),
                           prefix_str, mem_str_ptr, ti, entry_idx));
            }
            if (mem != INVALIDm) {
                soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                   SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                                   mem | SOC_SER_ERROR_DATA_ID_OFFSET_SET, entry_idx);
            } else {
                soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                   SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                                   info->enable_field |
                                   SOC_SER_ERROR_DATA_FIELD_ID_OFFSET, entry_idx);
            }
            if (multiple) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s has multiple ECC errors\n"),
                           prefix_str, mem_str_ptr));
            }
        }
        /* Clear parity status */
        if (!combo) {
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, port, 0, 0));
        } else {
            soc_reg_field_set(unit, reg, &rval, fields[0], 0);
            soc_reg_field_set(unit, reg, &rval, fields[1], 0);
            soc_reg_field_set(unit, reg, &rval, fields[2], 0);
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, port, 0, rval));
        }
    }
    if (!has_error && !force_check) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s ECC hardware inconsistency\n"),
                   prefix_str, mem_str));
    }
    return SOC_E_NONE;
}

STATIC int
_soc_tr3_parity_process_mmu_thdo(int unit, soc_block_t blocktype, 
                                 char *prefix_str)
{
    uint64 rval64;
    uint32 entry_idx, rval_hi, rval_lo;
    int i;
    _soc_ser_correct_info_t spci;
    static const _soc_tr3_parity_mmu_bit_reg_t thdo[] = {
        { 0, MMU_THDO_Q_TO_QGRP_MAPm, THDO_Q_TO_QGRP_MAP_ECC_ERROR_ADDRESSr },
        { 1, MMU_THDO_CONFIG_QUEUEm, THDO_CONFIG_QUEUE_ECC_ERROR_ADDRESSr },
        { 2, MMU_THDO_OFFSET_QUEUEm, THDO_OFFSET_QUEUE_ECC_ERROR_ADDRESSr },
        { 3, MMU_THDO_CONFIG_QGROUPm, THDO_CONFIG_QGROUP_ECC_ERROR_ADDRESSr },
        { 4, MMU_THDO_OFFSET_QGROUPm, THDO_OFFSET_QGROUP_ECC_ERROR_ADDRESSr },
        { 5, MMU_THDO_COUNTER_QUEUEm, THDO_COUNTER_QUEUE_ECC_ERROR_ADDRESSr },
        { 6, MMU_THDO_COUNTER_QGROUPm, THDO_COUNTER_QGROUP_ECC_ERROR_ADDRESSr },
        { 7, MMU_THDO_COUNTER_PORTm, THDO_COUNTER_PORT_ECC_ERROR_ADDRESSr },
        { 8, MMU_THDO_BST_QUEUEm, THDO_BST_QUEUE_ECC_ERROR_ADDRESSr },
        { 9, MMU_THDO_BST_QGROUPm, THDO_BST_QGROUP_ECC_ERROR_ADDRESSr },
        { 10, MMU_THDO_BST_PORTm, THDO_BST_PORT_ECC_ERROR_ADDRESSr },
        { 11, MMU_THDO_RESUME_QUEUEm, THDO_RESUME_QUEUE_ECC_ERROR_ADDRESSr },
        { 12, MMU_THDO_RESUME_QGROUPm, THDO_RESUME_QGROUP_ECC_ERROR_ADDRESSr },
        { 13, MMU_THDO_CONFIG_PORTm, THDO_CONFIG_PORT_ECC_ERROR_ADDRESSr },
        { 14, MMU_THDO_Q_TO_QGRP_MAPm, THDO_Q_TO_QGRP_MAP_ECC_ERROR_ADDRESSr },
        { 15, MMU_THDO_CONFIG_QUEUEm, THDO_CONFIG_QUEUE_ECC_ERROR_ADDRESSr },
        { 16, MMU_THDO_OFFSET_QUEUEm, THDO_OFFSET_QUEUE_ECC_ERROR_ADDRESSr },
        { 17, MMU_THDO_CONFIG_QGROUPm, THDO_CONFIG_QGROUP_ECC_ERROR_ADDRESSr },
        { 18, MMU_THDO_OFFSET_QGROUPm, THDO_OFFSET_QGROUP_ECC_ERROR_ADDRESSr },
        { 19, MMU_THDO_COUNTER_QUEUEm, THDO_COUNTER_QUEUE_ECC_ERROR_ADDRESSr },
        { 20, MMU_THDO_COUNTER_QGROUPm, THDO_COUNTER_QGROUP_ECC_ERROR_ADDRESSr },
        { 21, MMU_THDO_COUNTER_PORTm, THDO_COUNTER_PORT_ECC_ERROR_ADDRESSr },
        { 22, MMU_THDO_BST_QUEUEm, THDO_BST_QUEUE_ECC_ERROR_ADDRESSr },
        { 23, MMU_THDO_BST_QGROUPm, THDO_BST_QGROUP_ECC_ERROR_ADDRESSr },
        { 24, MMU_THDO_BST_PORTm, THDO_BST_PORT_ECC_ERROR_ADDRESSr },
        { 25, MMU_THDO_RESUME_QUEUEm, THDO_RESUME_QUEUE_ECC_ERROR_ADDRESSr },
        { 26, MMU_THDO_RESUME_QGROUPm, THDO_RESUME_QGROUP_ECC_ERROR_ADDRESSr },
        { 27, MMU_THDO_CONFIG_PORTm, THDO_CONFIG_PORT_ECC_ERROR_ADDRESSr }
    };

    SOC_IF_ERROR_RETURN(READ_THDO_PARITY_ERROR_STATUS_64r(unit, &rval64));
    rval_hi = COMPILER_64_HI(rval64);
    rval_lo = COMPILER_64_LO(rval64);
    for (i = 0; i < COUNTOF(thdo); i++) {
        if (thdo[i].bit_pos < 32) {
            if (!(rval_lo & (1 << thdo[i].bit_pos))) {
                continue;
            }
        } else {
            if (!(rval_hi & (1 << (thdo[i].bit_pos - 32)))) {
                continue;
            }
        }
        entry_idx = soc_reg_field_get(unit, thdo[i].addr_reg, 
                                      (thdo[i].bit_pos < 32) ? rval_lo : rval_hi, 
                                      ADDRESSf);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                           SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                           thdo[i].mem | SOC_SER_ERROR_DATA_ID_OFFSET_SET, entry_idx);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s %s ECC error, entry: %d\n"), prefix_str,
                              SOC_MEM_NAME(unit, thdo[i].mem), i < 14 ? "2B" : "1B",
                   entry_idx));
        if (i >= 14) {
            sal_memset(&spci, 0, sizeof(spci));
            spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
            spci.reg = INVALIDr;
            spci.mem = thdo[i].mem;
            spci.blk_type = blocktype;
            spci.index = entry_idx;
            (void)soc_ser_correction(unit, &spci);
        }
    }
    /* Clear parity status */
    COMPILER_64_ZERO(rval64);
    SOC_IF_ERROR_RETURN(WRITE_THDO_PARITY_ERROR_STATUS_64r(unit, rval64));

    return SOC_E_NONE;
}

STATIC int
_soc_tr3_parity_process_mmu_thdi(int unit, soc_block_t blocktype, 
                                 char *prefix_str)
{
    uint64 rval64;
    uint32 entry_idx, rval_hi, rval_lo;
    int i;
    _soc_ser_correct_info_t spci;
    static const _soc_tr3_parity_mmu_bit_fld_t thdi0[] = {
        { 63, THDI_PORT_PG_CNTRSm, PORT_PG_CNTR_ADDRf },
        { 62, THDI_PORT_SP_CNTRSm, PORT_SP_CNTR_ADDRf },
        { 61, THDI_PORT_PG_CONFIGm, PORT_PG_CFG_ADDRf },
        { 60, THDI_PORT_SP_CONFIGm, PORT_SP_CFG_ADDRf },
        { 59, THDI_PORT_PG_CNTRSm, PORT_PG_CNTR_ADDRf },
        { 58, THDI_PORT_SP_CNTRSm, PORT_SP_CNTR_ADDRf },
        { 57, THDI_PORT_PG_CONFIGm, PORT_PG_CFG_ADDRf },
        { 56, THDI_PORT_SP_CONFIGm, PORT_SP_CFG_ADDRf }
    };
    static const _soc_tr3_parity_mmu_bit_fld_t thdi1[] = {
        { 25, THDI_PORT_PG_BSTm, PORT_PG_BST_ADDRf },
        { 24, THDI_PORT_SP_BSTm, PORT_SP_BST_ADDRf }
    };

    SOC_IF_ERROR_RETURN(READ_PARITY_ERROR_STATUS_0_64r(unit, &rval64));
    rval_hi = COMPILER_64_HI(rval64);
    rval_lo = COMPILER_64_LO(rval64);
    for (i = 0; i < COUNTOF(thdi0); i++) {
        if (thdi0[i].bit_pos < 32) {
            if (!(rval_lo & (1 << thdi0[i].bit_pos))) {
                continue;
            }
        } else {
            if (!(rval_hi & (1 << (thdi0[i].bit_pos - 32)))) {
                continue;
            }
        }
        entry_idx = soc_reg64_field32_get(unit, PARITY_ERROR_STATUS_0r, rval64,
                                          thdi0[i].idxf);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                           SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                           thdi0[i].mem | SOC_SER_ERROR_DATA_ID_OFFSET_SET, entry_idx);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s %s ECC error, entry: %d\n"), prefix_str,
                              SOC_MEM_NAME(unit, thdi0[i].mem), i > 59 ? "2B" : "1B", 
                   entry_idx));
        if (i <= 59) {
            sal_memset(&spci, 0, sizeof(spci));
            spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
            spci.reg = INVALIDr;
            spci.mem = thdi0[i].mem;
            spci.blk_type = blocktype;
            spci.index = entry_idx;
            (void)soc_ser_correction(unit, &spci);
        }
    }
    /* Clear parity status */
    COMPILER_64_ZERO(rval64);
    SOC_IF_ERROR_RETURN(WRITE_PARITY_ERROR_STATUS_0r(unit, rval64));

    SOC_IF_ERROR_RETURN(READ_PARITY_ERROR_STATUS_1r(unit, &rval64));
    rval_hi = COMPILER_64_HI(rval64);
    rval_lo = COMPILER_64_LO(rval64);
    for (i = 0; i < COUNTOF(thdi1); i++) {
        if (thdi1[i].bit_pos < 32) {
            if (!(rval_lo & (1 << thdi1[i].bit_pos))) {
                continue;
            }
        } else {
            if (!(rval_hi & (1 << (thdi1[i].bit_pos - 32)))) {
                continue;
            }
        }
        entry_idx = soc_reg64_field32_get(unit, PARITY_ERROR_STATUS_1r, rval64,
                                          thdi1[i].idxf);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                           SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                           thdi1[i].mem | SOC_SER_ERROR_DATA_ID_OFFSET_SET, entry_idx);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s 1B %s ECC error, entry: %d\n"), prefix_str,
                              SOC_MEM_NAME(unit, thdi1[i].mem), entry_idx));
        sal_memset(&spci, 0, sizeof(spci));
        spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
        spci.reg = INVALIDr;
        spci.mem = thdi1[i].mem;
        spci.blk_type = blocktype;
        spci.index = entry_idx;
        (void)soc_ser_correction(unit, &spci);
    }
    /* Clear parity status */
    COMPILER_64_ZERO(rval64);
    SOC_IF_ERROR_RETURN(WRITE_PARITY_ERROR_STATUS_1r(unit, rval64));

    return SOC_E_NONE;
}

STATIC int
_soc_tr3_parity_process_mmu_wred(int unit, soc_block_t blocktype, 
                                 soc_reg_t addr_reg, soc_field_t addr_field,
                                 char *prefix_str)
{
    uint32 entry_idx, rval;
    int i;
    _soc_ser_correct_info_t spci;
    static const _soc_tr3_parity_mmu_bit_t wred[] = {
        { 14, MMU_WRED_PORT_SP_SHARED_COUNTm },
        { 13, MMU_WRED_QGROUP_SHARED_COUNTm },
        { 12, MMU_WRED_UC_QUEUE_TOTAL_COUNTm },
        { 11, MMU_WRED_PORT_SP_DROP_THDm },
        { 10, MMU_WRED_QGROUP_DROP_THDm },
        { 9, MMU_WRED_UC_QUEUE_DROP_THD_DEQm },
        { 8, MMU_WRED_UC_QUEUE_DROP_THD_ENQm },
        { 7, MMU_WRED_DROP_CURVE_PROFILE_5m },
        { 6, MMU_WRED_DROP_CURVE_PROFILE_4m },
        { 5, MMU_WRED_DROP_CURVE_PROFILE_3m },
        { 4, MMU_WRED_DROP_CURVE_PROFILE_2m },
        { 3, MMU_WRED_DROP_CURVE_PROFILE_1m },
        { 2, MMU_WRED_DROP_CURVE_PROFILE_0m },
        { 1, MMU_WRED_AVG_QSIZEm },
        { 0, MMU_WRED_CONFIGm }
    };
    
    SOC_IF_ERROR_RETURN(READ_WRED_PARITY_ERROR_BITMAPr(unit, &rval));
    for (i = 0; i < COUNTOF(wred); i++) {
        if (!(rval & (1 << wred[i].bit_pos))) {
            continue;
        }
        entry_idx = soc_reg_field_get(unit, addr_reg, rval, addr_field);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                           SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                           wred[i].mem | SOC_SER_ERROR_DATA_ID_OFFSET_SET, entry_idx);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s ECC error, entry: %d\n"), prefix_str,
                              SOC_MEM_NAME(unit, wred[i].mem),
                   entry_idx));
        sal_memset(&spci, 0, sizeof(spci));
        spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
        spci.reg = INVALIDr;
        spci.mem = wred[i].mem;
        spci.blk_type = blocktype;
        spci.index = entry_idx;
        (void)soc_ser_correction(unit, &spci);
    }
    SOC_IF_ERROR_RETURN(WRITE_WRED_PARITY_ERROR_BITMAPr(unit, 0));
    return SOC_E_NONE;
}

STATIC int
_soc_tr3_parity_process_mmu_qcn(int unit, soc_block_t blocktype, 
                                soc_reg_t info_addr_reg, soc_field_t addr_field,
                                char *prefix_str)
{
    uint32 entry_idx, rval;
    int i;
    _soc_ser_correct_info_t spci;
    static const _soc_tr3_parity_mmu_bit_t qcn[] = {
        { 16, MMU_QCN_QLEN_SHADOWm },
        { 15, MMU_QCN_QFBTBm },
        { 14, MMU_QCN_CPQST_TSSLSm },
        { 13, MMU_QCN_CPQST_QLENm },
        { 12, MMU_QCN_ENABLEm },
        { 11, MMU_QCN_CNM_QUEUEm },
        { 10, MMU_QCN_CNM_COUNTERm }
    };

    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, info_addr_reg, REG_PORT_ANY, 0, 
                                      &rval));
    for (i = 0; i < COUNTOF(qcn); i++) {
        if (!(rval & (1 << qcn[i].bit_pos))) {
            continue;
        }
        entry_idx = soc_reg_field_get(unit, info_addr_reg, rval, addr_field);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                           SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                           qcn[i].mem | SOC_SER_ERROR_DATA_ID_OFFSET_SET, entry_idx);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s ECC error, entry: %d\n"), prefix_str,
                              SOC_MEM_NAME(unit, qcn[i].mem),
                   entry_idx));
        sal_memset(&spci, 0, sizeof(spci));
        spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
        spci.reg = INVALIDr;
        spci.mem = qcn[i].mem;
        spci.blk_type = blocktype;
        spci.index = entry_idx;
        (void)soc_ser_correction(unit, &spci);
    }
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, info_addr_reg, REG_PORT_ANY, 0, 0));

    return SOC_E_NONE;
}

STATIC int
_soc_tr3_parity_process_mmu_lls(int unit, soc_block_t blocktype, 
                                char *prefix_str)
{
    uint32 entry_idx, rval, rval1;
    int i;
    _soc_ser_correct_info_t spci;
    static const _soc_tr3_parity_mmu_bit_reg_fld_t lls[] = {
        { 3, LLS_PORT_TDMm, LLS_PORT_TDM_ECC_STATUSr, 
          DB_PORT_TDM_ECC_ERROR_ADDRESSf, 0 },
        { 2, LLS_PORT_TDMm, LLS_PORT_TDM_ECC_STATUSr, 
          DB_PORT_TDM_ECC_ERROR_ADDRESSf, 1 },
        { 1, LLS_PORT_WERR_MAX_SCm, LLS_PORT_WERR_MAX_SC_ECC_STATUSr, 
          DB_PORT_WERR_MAX_SC_ECC_ERROR_ADDRESSf, 0 },
        { 0, LLS_PORT_WERR_MAX_SCm, LLS_PORT_WERR_MAX_SC_ECC_STATUSr, 
          DB_PORT_WERR_MAX_SC_ECC_ERROR_ADDRESSf, 1 }
    };
    static const _soc_tr3_parity_mmu_bit_reg_fld_t lls_l0[] = {
        { 23, LLS_L0_CHILD_WEIGHT_WORKINGm, 
          LLS_L0_CHILD_WEIGHT_WORKING_ECC_STATUSr,
          DB_L0_CHILD_WEIGHT_WORKING_ECC_ERROR_ADDRESSf, 0 },
        { 22, LLS_L0_CHILD_WEIGHT_WORKINGm, 
          LLS_L0_CHILD_WEIGHT_WORKING_ECC_STATUSr,
          DB_L0_CHILD_WEIGHT_WORKING_ECC_ERROR_ADDRESSf, 1 },
        { 21, LLS_L0_MIN_NEXTm, LLS_L0_MIN_NEXT_ECC_STATUSr,
          DB_L0_MIN_NEXT_ECC_ERROR_ADDRESSf, 0 },
        { 20, LLS_L0_MIN_NEXTm, LLS_L0_MIN_NEXT_ECC_STATUSr,
          DB_L0_MIN_NEXT_ECC_ERROR_ADDRESSf, 1 },
        { 19, LLS_L0_PARENTm, LLS_L0_PARENT_ECC_STATUSr,
          DB_L0_PARENT_ECC_ERROR_ADDRESSf, 0 },
        { 18, LLS_L0_PARENTm, LLS_L0_PARENT_ECC_STATUSr,
          DB_L0_PARENT_ECC_ERROR_ADDRESSf, 1 },
        { 17, LLS_L0_CONFIGm, 
          LLS_L0_CONFIG_ECC_STATUSr,
          DB_L0_CONFIG_ECC_ERROR_ADDRESSf, 0 },
        { 16, LLS_L0_CONFIGm, 
          LLS_L0_CONFIG_ECC_STATUSr,
          DB_L0_CONFIG_ECC_ERROR_ADDRESSf, 1 },
        { 15, LLS_L0_PARENT_STATEm, 
          LLS_L0_PARENT_STATE_ECC_STATUSr,
          DB_L0_PARENT_STATE_ECC_ERROR_ADDRESSf, 0 },
        { 14, LLS_L0_PARENT_STATEm,
          LLS_L0_PARENT_STATE_ECC_STATUSr,
          DB_L0_PARENT_STATE_ECC_ERROR_ADDRESSf, 1 },
        { 13, LLS_L0_HEADS_TAILSm, 
          LLS_L0_HEADS_TAILS_ECC_STATUSr,
          DB_L0_HEADS_TAILS_ECC_ERROR_ADDRESSf, 0 },
        { 12, LLS_L0_HEADS_TAILSm,
          LLS_L0_HEADS_TAILS_ECC_STATUSr,
          DB_L0_HEADS_TAILS_ECC_ERROR_ADDRESSf, 1 },
        { 11, LLS_L0_WERR_MAX_SCm, 
          LLS_L0_WERR_MAX_SC_ECC_STATUSr,
          DB_L0_WERR_MAX_SC_ECC_ERROR_ADDRESSf, 0 },
        { 10, LLS_L0_WERR_MAX_SCm, 
          LLS_L0_WERR_MAX_SC_ECC_STATUSr,
          DB_L0_WERR_MAX_SC_ECC_ERROR_ADDRESSf, 1 },
        { 9, LLS_L0_CHILD_STATE1m, 
          LLS_L0_CHILD_STATE1_ECC_STATUSr,
          DB_L0_CHILD_STATE1_ECC_ERROR_ADDRESSf, 0 },
        { 8, LLS_L0_CHILD_STATE1m, 
          LLS_L0_CHILD_STATE1_ECC_STATUSr,
          DB_L0_CHILD_STATE1_ECC_ERROR_ADDRESSf, 1 },
        { 7, LLS_L0_CHILD_WEIGHT_CFGm, 
          LLS_L0_CHILD_WEIGHT_CFG_ECC_STATUSr,
          DB_L0_CHILD_WEIGHT_CFG_ECC_ERROR_ADDRESSf, 0 },
        { 6, LLS_L0_CHILD_WEIGHT_CFGm, 
          LLS_L0_CHILD_WEIGHT_CFG_ECC_STATUSr,
          DB_L0_CHILD_WEIGHT_CFG_ECC_ERROR_ADDRESSf, 1 },
        { 5, LLS_L0_WERR_NEXTm, 
          LLS_L0_WERR_NEXT_ECC_STATUSr,
          DB_L0_WERR_NEXT_ECC_ERROR_ADDRESSf, 0 },
        { 4, LLS_L0_WERR_NEXTm, 
          LLS_L0_WERR_NEXT_ECC_STATUSr,
          DB_L0_WERR_NEXT_ECC_ERROR_ADDRESSf, 1 },
        { 3, LLS_L0_EF_NEXTm, 
          LLS_L0_EF_NEXT_ECC_STATUSr,
          DB_L0_EF_NEXT_ECC_ERROR_ADDRESSf, 0 },
        { 2, LLS_L0_EF_NEXTm,
          LLS_L0_EF_NEXT_ECC_STATUSr,
          DB_L0_EF_NEXT_ECC_ERROR_ADDRESSf, 1 },
        { 1, LLS_L0_ERRORm,
          LLS_L0_ERROR_ECC_STATUSr, 
          DB_L0_ERROR_ECC_ERROR_ADDRESSf, 0 },
        { 0, LLS_L0_ERRORm, 
          LLS_L0_ERROR_ECC_STATUSr, 
          DB_L0_ERROR_ECC_ERROR_ADDRESSf, 1 }
    };
    static const _soc_tr3_parity_mmu_bit_reg_fld_t lls_l1[] = {
        { 23, LLS_L1_CHILD_WEIGHT_WORKINGm, 
          LLS_L1_CHILD_WEIGHT_WORKING_ECC_STATUSr,
          DB_L1_CHILD_WEIGHT_WORKING_ECC_ERROR_ADDRESSf, 0 },
        { 22, LLS_L1_CHILD_WEIGHT_WORKINGm, 
          LLS_L1_CHILD_WEIGHT_WORKING_ECC_STATUSr,
          DB_L1_CHILD_WEIGHT_WORKING_ECC_ERROR_ADDRESSf, 1 },
        { 21, LLS_L1_MIN_NEXTm, LLS_L1_MIN_NEXT_ECC_STATUSr,
          DB_L1_MIN_NEXT_ECC_ERROR_ADDRESSf, 0 },
        { 20, LLS_L1_MIN_NEXTm, LLS_L1_MIN_NEXT_ECC_STATUSr,
          DB_L1_MIN_NEXT_ECC_ERROR_ADDRESSf, 1 },
        { 19, LLS_L1_PARENTm, LLS_L1_PARENT_ECC_STATUSr,
          DB_L1_PARENT_ECC_ERROR_ADDRESSf, 0 },
        { 18, LLS_L1_PARENTm, LLS_L1_PARENT_ECC_STATUSr,
          DB_L1_PARENT_ECC_ERROR_ADDRESSf, 1 },
        { 17, LLS_L1_CONFIGm, 
          LLS_L1_CONFIG_ECC_STATUSr,
          DB_L1_CONFIG_ECC_ERROR_ADDRESSf, 0 },
        { 16, LLS_L1_CONFIGm, 
          LLS_L1_CONFIG_ECC_STATUSr,
          DB_L1_CONFIG_ECC_ERROR_ADDRESSf, 1 },
        { 15, LLS_L1_PARENT_STATEm, 
          LLS_L1_PARENT_STATE_ECC_STATUSr,
          DB_L1_PARENT_STATE_ECC_ERROR_ADDRESSf, 0 },
        { 14, LLS_L1_PARENT_STATEm,
          LLS_L1_PARENT_STATE_ECC_STATUSr,
          DB_L1_PARENT_STATE_ECC_ERROR_ADDRESSf, 1 },
        { 13, LLS_L1_HEADS_TAILSm, 
          LLS_L1_HEADS_TAILS_ECC_STATUSr,
          DB_L1_HEADS_TAILS_ECC_ERROR_ADDRESSf, 0 },
        { 12, LLS_L1_HEADS_TAILSm,
          LLS_L1_HEADS_TAILS_ECC_STATUSr,
          DB_L1_HEADS_TAILS_ECC_ERROR_ADDRESSf, 1 },
        { 11, LLS_L1_WERR_MAX_SCm, 
          LLS_L1_WERR_MAX_SC_ECC_STATUSr,
          DB_L1_WERR_MAX_SC_ECC_ERROR_ADDRESSf, 0 },
        { 10, LLS_L1_WERR_MAX_SCm, 
          LLS_L1_WERR_MAX_SC_ECC_STATUSr,
          DB_L1_WERR_MAX_SC_ECC_ERROR_ADDRESSf, 1 },
        { 9, LLS_L1_CHILD_STATE1m, 
          LLS_L1_CHILD_STATE1_ECC_STATUSr,
          DB_L1_CHILD_STATE1_ECC_ERROR_ADDRESSf, 0 },
        { 8, LLS_L1_CHILD_STATE1m, 
          LLS_L1_CHILD_STATE1_ECC_STATUSr,
          DB_L1_CHILD_STATE1_ECC_ERROR_ADDRESSf, 1 },
        { 7, LLS_L1_CHILD_WEIGHT_CFGm, 
          LLS_L1_CHILD_WEIGHT_CFG_ECC_STATUSr,
          DB_L1_CHILD_WEIGHT_CFG_ECC_ERROR_ADDRESSf, 0 },
        { 6, LLS_L1_CHILD_WEIGHT_CFGm, 
          LLS_L1_CHILD_WEIGHT_CFG_ECC_STATUSr,
          DB_L1_CHILD_WEIGHT_CFG_ECC_ERROR_ADDRESSf, 1 },
        { 5, LLS_L1_WERR_NEXTm, 
          LLS_L1_WERR_NEXT_ECC_STATUSr,
          DB_L1_WERR_NEXT_ECC_ERROR_ADDRESSf, 0 },
        { 4, LLS_L1_WERR_NEXTm, 
          LLS_L1_WERR_NEXT_ECC_STATUSr,
          DB_L1_WERR_NEXT_ECC_ERROR_ADDRESSf, 1 },
        { 3, LLS_L1_EF_NEXTm, 
          LLS_L1_EF_NEXT_ECC_STATUSr,
          DB_L1_EF_NEXT_ECC_ERROR_ADDRESSf, 0 },
        { 2, LLS_L1_EF_NEXTm,
          LLS_L1_EF_NEXT_ECC_STATUSr,
          DB_L1_EF_NEXT_ECC_ERROR_ADDRESSf, 1 },
        { 1, LLS_L1_ERRORm,
          LLS_L1_ERROR_ECC_STATUSr, 
          DB_L1_ERROR_ECC_ERROR_ADDRESSf, 0 },
        { 0, LLS_L1_ERRORm, 
          LLS_L1_ERROR_ECC_STATUSr, 
          DB_L1_ERROR_ECC_ERROR_ADDRESSf, 1 }
    };
    static const _soc_tr3_parity_mmu_bit_reg_fld_t lls_l2[] = {
        { 13, LLS_L2_CHILD_WEIGHT_WORKINGm, 
          LLS_L2_CHILD_WEIGHT_WORKING_ECC_STATUSr,
          DB_L2_CHILD_WEIGHT_WORKING_ECC_ERROR_ADDRESSf, 0 },
        { 12, LLS_L2_CHILD_WEIGHT_WORKINGm, 
          LLS_L2_CHILD_WEIGHT_WORKING_ECC_STATUSr,
          DB_L2_CHILD_WEIGHT_WORKING_ECC_ERROR_ADDRESSf, 1 },
        { 11, LLS_L2_CHILD_STATE1m, 
          LLS_L2_CHILD_STATE1_ECC_STATUSr,
          DB_L2_CHILD_STATE1_ECC_ERROR_ADDRESSf, 0 },
        { 10, LLS_L2_CHILD_STATE1m, 
          LLS_L2_CHILD_STATE1_ECC_STATUSr,
          DB_L2_CHILD_STATE1_ECC_ERROR_ADDRESSf, 1 },
        { 9, LLS_L2_PARENTm, LLS_L2_PARENT_ECC_STATUSr,
          DB_L2_PARENT_ECC_ERROR_ADDRESSf, 0 },
        { 8, LLS_L2_PARENTm, LLS_L2_PARENT_ECC_STATUSr,
          DB_L2_PARENT_ECC_ERROR_ADDRESSf, 1 },
        { 7, LLS_L2_CHILD_WEIGHT_CFGm, 
          LLS_L2_CHILD_WEIGHT_CFG_ECC_STATUSr,
          DB_L2_CHILD_WEIGHT_CFG_ECC_ERROR_ADDRESSf, 0 },
        { 6, LLS_L2_CHILD_WEIGHT_CFGm, 
          LLS_L2_CHILD_WEIGHT_CFG_ECC_STATUSr,
          DB_L2_CHILD_WEIGHT_CFG_ECC_ERROR_ADDRESSf, 1 },
        { 5, LLS_L2_WERR_NEXTm, 
          LLS_L2_WERR_NEXT_ECC_STATUSr,
          DB_L2_WERR_NEXT_ECC_ERROR_ADDRESSf, 0 },
        { 4, LLS_L2_WERR_NEXTm, 
          LLS_L2_WERR_NEXT_ECC_STATUSr,
          DB_L2_WERR_NEXT_ECC_ERROR_ADDRESSf, 1 },
        { 3, LLS_L2_MIN_NEXTm, 
          LLS_L2_MIN_NEXT_ECC_STATUSr,
          DB_L2_MIN_NEXT_ECC_ERROR_ADDRESSf, 0 },
        { 2, LLS_L2_MIN_NEXTm,
          LLS_L2_MIN_NEXT_ECC_STATUSr,
          DB_L2_MIN_NEXT_ECC_ERROR_ADDRESSf, 1 },
        { 1, LLS_L2_ERRORm,
          LLS_L2_ERROR_ECC_STATUSr, 
          DB_L2_ERROR_ECC_ERROR_ADDRESSf, 0 },
        { 0, LLS_L2_ERRORm, 
          LLS_L2_ERROR_ECC_STATUSr, 
          DB_L2_ERROR_ECC_ERROR_ADDRESSf, 1 }
    };
    SOC_IF_ERROR_RETURN(READ_LLS_PORT_ECC_ERRORr(unit, &rval));
    for (i = 0; i < COUNTOF(lls); i++) {
        if (!(rval & (1 << lls[i].bit_pos))) {
            continue;
        }
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, lls[i].addr_reg, REG_PORT_ANY, 0,
                                          &rval1));
        entry_idx = soc_reg_field_get(unit, lls[i].addr_reg, rval1, lls[i].idxf);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                           SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                           lls[i].mem | SOC_SER_ERROR_DATA_ID_OFFSET_SET, entry_idx);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s %s ECC error, entry: %d\n"), prefix_str,
                              SOC_MEM_NAME(unit, lls[i].mem),
                   lls[i].uncorrectable ? "Uncorrectable" : "Correctable",
                   entry_idx));
        if (!lls[i].uncorrectable) {
            sal_memset(&spci, 0, sizeof(spci));
            spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
            spci.reg = INVALIDr;
            spci.mem = lls[i].mem;
            spci.blk_type = blocktype;
            spci.index = entry_idx;
            (void)soc_ser_correction(unit, &spci);
        }
    }
    SOC_IF_ERROR_RETURN(WRITE_LLS_PORT_ECC_ERRORr(unit, 0));
    
    SOC_IF_ERROR_RETURN(READ_LLS_L0_ECC_ERROR1r(unit, &rval));
    for (i = 0; i < COUNTOF(lls_l0); i++) {
        if (!(rval & (1 << lls_l0[i].bit_pos))) {
            continue;
        }
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, lls_l0[i].addr_reg, REG_PORT_ANY, 0,
                                          &rval1));
        entry_idx = soc_reg_field_get(unit, lls_l0[i].addr_reg, rval1, 
                                      lls_l0[i].idxf);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                           SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                           lls_l0[i].mem | SOC_SER_ERROR_DATA_ID_OFFSET_SET, entry_idx);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s %s ECC error, entry: %d\n"), prefix_str,
                              SOC_MEM_NAME(unit, lls_l0[i].mem),
                   lls_l0[i].uncorrectable ? "Uncorrectable" : "Correctable",
                   entry_idx));
        if (!lls_l0[i].uncorrectable) {
            sal_memset(&spci, 0, sizeof(spci));
            spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
            spci.reg = INVALIDr;
            spci.mem = lls_l0[i].mem;
            spci.blk_type = blocktype;
            spci.index = entry_idx;
            (void)soc_ser_correction(unit, &spci);
        }
    }
    
    SOC_IF_ERROR_RETURN(WRITE_LLS_L0_ECC_ERROR1r(unit, 0));
    
    SOC_IF_ERROR_RETURN(READ_LLS_L1_ECC_ERROR1r(unit, &rval));
    for (i = 0; i < COUNTOF(lls_l1); i++) {
        if (!(rval & (1 << lls_l1[i].bit_pos))) {
            continue;
        }
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, lls_l1[i].addr_reg, REG_PORT_ANY, 0,
                                          &rval1));
        entry_idx = soc_reg_field_get(unit, lls_l1[i].addr_reg, rval1, 
                                      lls_l1[i].idxf);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                           SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                           lls_l1[i].mem | SOC_SER_ERROR_DATA_ID_OFFSET_SET, entry_idx);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s %s ECC error, entry: %d\n"), prefix_str,
                              SOC_MEM_NAME(unit, lls_l1[i].mem),
                   lls_l1[i].uncorrectable ? "Uncorrectable" : "Correctable",
                   entry_idx));
        if (!lls_l1[i].uncorrectable) {
            sal_memset(&spci, 0, sizeof(spci));
            spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
            spci.reg = INVALIDr;
            spci.mem = lls_l1[i].mem;
            spci.blk_type = blocktype;
            spci.index = entry_idx;
            (void)soc_ser_correction(unit, &spci);
        }
    }
    SOC_IF_ERROR_RETURN(WRITE_LLS_L1_ECC_ERROR1r(unit, 0));
    
    SOC_IF_ERROR_RETURN(READ_LLS_L2_ECC_ERROR1r(unit, &rval));
    for (i = 0; i < COUNTOF(lls_l2); i++) {
        if (!(rval & (1 << lls_l2[i].bit_pos))) {
            continue;
        }
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, lls_l2[i].addr_reg, REG_PORT_ANY, 0,
                                          &rval1));
        entry_idx = soc_reg_field_get(unit, lls_l2[i].addr_reg, rval1, 
                                      lls_l2[i].idxf);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                           SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                           lls_l2[i].mem | SOC_SER_ERROR_DATA_ID_OFFSET_SET, entry_idx);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s %s ECC error, entry: %d\n"), prefix_str,
                              SOC_MEM_NAME(unit, lls_l2[i].mem),
                   lls_l2[i].uncorrectable ? "Uncorrectable" : "Correctable",
                   entry_idx));
        if (!lls_l2[i].uncorrectable) {
            sal_memset(&spci, 0, sizeof(spci));
            spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
            spci.reg = INVALIDr;
            spci.mem = lls_l2[i].mem;
            spci.blk_type = blocktype;
            spci.index = entry_idx;
            (void)soc_ser_correction(unit, &spci);
        }
    }
    SOC_IF_ERROR_RETURN(WRITE_LLS_L2_ECC_ERROR1r(unit, 0));
    return SOC_E_NONE;
}

static _soc_tr3_bst_hw_cb bst_cb;

STATIC int
_soc_tr3_process_mmu_bst(int unit)
{
    if (bst_cb) {
        bst_cb(unit);
    }
    return SOC_E_NONE;
}

int soc_tr3_set_bst_callback(int unit, _soc_tr3_bst_hw_cb cb)
{
    bst_cb = cb;
    return SOC_E_NONE;
}

static int
_soc_tr3_process_parity(int unit, soc_block_t blocktype,
                        uint8 blk_id, soc_reg_t reg,
                        _soc_tr3_parity_info_t *info_list,
                        char *prefix_str)
{
    int port = REG_PORT_ANY, blk_inf_idx;
    int info_index, blk;
    uint32 rval;
    uint64 rval64;
    char *mem_str = "";
    _soc_tr3_parity_info_t *info;
    char new_prefix_str[80];
    uint8 no_top = 0;

    SOC_BLOCK_ITER(unit, blk_inf_idx, blocktype) {
        if (SOC_BLOCK_INFO(unit, blk_inf_idx).number == blk_id) {
            port = SOC_BLOCK_PORT(unit, blk_inf_idx);
            break;
        }
    }
    if (reg != INVALIDr) {
        if (SOC_REG_IS_64(unit, reg)) {
            SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, port, 0, &rval64));
        } else {
            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));
        }        
    } else {
        no_top = 1; /* No top level status reg, so check all */
    }
    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }
        if (!no_top) {
            if (SOC_REG_IS_64(unit, reg)) {
                if (!soc_reg64_field32_get(unit, reg, rval64,
                                        info->group_reg_status_field)) {
                    continue;
                }
            } else if (!soc_reg_field_get(unit, reg, rval,
                                   info->group_reg_status_field)) {
                continue;
            }
        }
        if (info->mem_str) {
            mem_str = info->mem_str;
        }
        sal_sprintf(new_prefix_str, "%s %s\n", prefix_str, mem_str);

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_GENERIC:
             blk = SOC_BLOCK_INFO(unit, blk_inf_idx).cmic;
             LOG_ERROR(BSL_LS_SOC_COMMON,
                       (BSL_META_U(unit,
                                   "%s Blk: %d %s generic parity error.\n"),
                                   prefix_str, blk, mem_str));
             if (info->mem != INVALIDm) {
                 uint32 entry_idx = 0;
                 _soc_ser_correct_info_t spci;
                 
                 if (info->correction_reg != INVALIDr) {                     
                     SOC_IF_ERROR_RETURN
                         (soc_reg32_get(unit, info->correction_reg, REG_PORT_ANY, 0, 
                                        &rval));
                     entry_idx = soc_reg_field_get(unit, info->correction_reg, 
                                                   rval, info->correction_addr_field);
                 }
                 soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                    SOC_SWITCH_EVENT_DATA_ERROR_PARITY, 
                                    info->mem | SOC_SER_ERROR_DATA_ID_OFFSET_SET, entry_idx);
                 sal_memset(&spci, 0, sizeof(spci));
                 spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
                 spci.reg = INVALIDr;
                 spci.mem = info->mem;
                 spci.blk_type = blocktype;
                 spci.index = entry_idx;
                 (void)soc_ser_correction(unit, &spci);
             }
             break;
        case _SOC_PARITY_TYPE_ECC:
            /* ECC_ERRf, MULTIPLE_ERRf, DOUBLE_BIT_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_tr3_parity_process_ecc(unit, info->mem, no_top ? 1 : 0, 
                                             port, info, prefix_str, 
                                             mem_str));
            break;
        case _SOC_PARITY_TYPE_AXP:
            /* nested parity info */
            SOC_IF_ERROR_RETURN
                (_soc_tr3_process_parity(unit, blocktype, blk_id, 
                                         info->intr_status_reg, info->info,
                                         new_prefix_str));
            break;
        case _SOC_PARITY_TYPE_MMU_THDO:
            SOC_IF_ERROR_RETURN
                (_soc_tr3_parity_process_mmu_thdo(unit, blocktype, new_prefix_str));
            break;
        case _SOC_PARITY_TYPE_MMU_THDI:
            SOC_IF_ERROR_RETURN
                (_soc_tr3_parity_process_mmu_thdi(unit, blocktype, new_prefix_str));
            break;
        case _SOC_PARITY_TYPE_MMU_WRED:
            SOC_IF_ERROR_RETURN
                (_soc_tr3_parity_process_mmu_wred(unit, blocktype, 
                                                  info->correction_reg,
                                                  info->correction_addr_field,
                                                  new_prefix_str));
            break;
        case _SOC_PARITY_TYPE_MMU_QCN:
            SOC_IF_ERROR_RETURN
                (_soc_tr3_parity_process_mmu_qcn(unit, blocktype, 
                                                 info->correction_reg,
                                                 info->correction_addr_field,
                                                 new_prefix_str));
            break;
        case _SOC_PARITY_TYPE_MMU_LLS:
            SOC_IF_ERROR_RETURN
                (_soc_tr3_parity_process_mmu_lls(unit, blocktype, new_prefix_str));
            break;
        case _SOC_PARITY_TYPE_BST:
            SOC_IF_ERROR_RETURN(_soc_tr3_process_mmu_bst(unit));
            break;
        default:
            break;
        }
    }
    return SOC_E_NONE;
}

STATIC int
_soc_tr3_parity_process_all(int unit)
{
    uint8 none = 0, rbi;
    uint32 rval, cmic_rval1, cmic_rval2, cmic_bit;
    const _soc_tr3_parity_route_block_t *rb;
    char prefix_str[10];
    soc_stat_t *stat = SOC_STAT(unit);

    sal_sprintf(prefix_str, "Unit: %d \n", unit);

    /* Read CMIC parity status register */
    SOC_IF_ERROR_RETURN
        (READ_CMIC_CMC0_IRQ_STAT2r(unit, &cmic_rval2));
    if (cmic_rval2 == 0) {
        none = 1;
    }
    /* Read ISM/AXP parity status register */
    SOC_IF_ERROR_RETURN
        (READ_CMIC_CMC0_IRQ_STAT1r(unit, &cmic_rval1));
    if (((cmic_rval1 & _SOC_TR3_FUNC_PARITY_INTR_MASK) == 0) && (none)) {
        return SOC_E_NONE;
    }
    /* Loop through each place-and-route block entry */
    for (rbi = 0; ; rbi++) {
            rb = SOC_IS_HELIX4(unit) ? &_soc_hx4_parity_route_blocks[rbi]: 
                                       &_soc_tr3_parity_route_blocks[rbi];
        cmic_bit = rb->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        /* Check status for the route block in the CMIC register */
        if (rb->cmic_reg == 0) {
            if (!(cmic_rval2 & cmic_bit)) {
                /* No interrupt bit asserted for the route block */
                continue;
            }
        }
        if (rb->cmic_reg == 1) {
            if (!(cmic_rval1 & cmic_bit)) {
                /* No interrupt bit asserted for the route block */
                continue;
            }
        }
        if (rb->blocktype == SOC_BLK_IPIPE || rb->blocktype == SOC_BLK_EPIPE ||
            rb->blocktype == SOC_BLK_ISM) {
            if (rb->blocktype == SOC_BLK_IPIPE) {
                if (READ_IP2_INTR_STATUS_2r(unit, &rval)) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "unit %d: Error reading %s reg !!\n"),
                                          unit, SOC_REG_NAME(unit, IP2_INTR_STATUS_2r)));
                    return SOC_E_INTERNAL;
                }
                if (rval) {
                    /* Call OAM interrupt handler */
                    soc_tr3_oam_interrupt_process(unit);                    
                }
            }
            /* New fifo style processing */
            (void)_soc_tr3_process_parity_fifo(unit, rb->blocktype, prefix_str);
            stat->ser_err_fifo++;
        } else {
            /* Legacy processing */
            (void)_soc_tr3_process_parity(unit, rb->blocktype, rb->id,
                                          rb->status_reg, rb->info,
                                          prefix_str);
            stat->ser_err_int++;
        }
    }
    return SOC_E_NONE;
}

void
soc_tr3_process_func_intr(void *unit_vp, void *d1, void *d2, void *d3, void *d4)
{
    int unit = PTR_TO_INT(unit_vp);
    uint32 rval;

    if (soc_feature(unit, soc_feature_l2_overflow)) {
        if (READ_ISM_INTRr(unit, &rval)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d: Error reading %s reg !!\n"),
                                  unit, SOC_REG_NAME(unit, ISM_INTRr)));
            return;
        }
        if (soc_reg_field_get(unit, ISM_INTRr, rval, L2_LEARN_INSERT_FAILUREf)) {
            soc_tr3_l2_overflow_interrupt_handler(unit);
        } else {
            (void)_soc_tr3_parity_process_all(unit);
        }
    } else {
        (void)_soc_tr3_parity_process_all(unit);
    }
    sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Don't reenable too soon */
    if (d1 != NULL) {
        (void)soc_cmicm_intr1_enable(unit, PTR_TO_INT(d1));
    } else if (d2 != NULL) {
        (void)soc_cmicm_intr2_enable(unit, PTR_TO_INT(d2));
    }
}

int
_soc_triumph3_mem_parity_control(int unit, soc_mem_t mem,
                                 int copyno, int enable)
{
    uint32 parity_enable, intfo_dis = 0, llsfc_cfg, aac2, mscfg;
    uint16 dev_id;
    uint8  rev_id;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    

    /* Do the following toggles even if the memory is invalid,
     * so the register tests can use this routine. */
    SOC_IF_ERROR_RETURN(READ_AUX_ARB_CONTROL_2r(unit, &aac2));
    
    if (!enable) {
        /* Disable HW updates */
        soc_reg_field_set(unit, INTFO_HW_UPDATE_DISr, &intfo_dis,
                          EG_SPf, 1);
        soc_reg_field_set(unit, INTFO_HW_UPDATE_DISr, &intfo_dis,
                          ING_SPf, 1);
        soc_reg_field_set(unit, INTFO_HW_UPDATE_DISr, &intfo_dis,
                          CONGST_STf, 1);
        SOC_IF_ERROR_RETURN(WRITE_INTFO_HW_UPDATE_DISr(unit, intfo_dis));

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_CFGr, REG_PORT_ANY,
                                    PFC_ST_TBL_DISABLEf, 1));

        SOC_IF_ERROR_RETURN(READ_LLS_FC_CONFIGr(unit, &llsfc_cfg));
        soc_reg_field_set(unit, LLS_FC_CONFIGr, &llsfc_cfg,
                          FC_CFG_DISABLE_XOFFf, 1);
        soc_reg_field_set(unit, LLS_FC_CONFIGr, &llsfc_cfg,
                          FC_CFG_DISABLE_ALL_XOFFf, 1);
        soc_reg_field_set(unit, LLS_FC_CONFIGr, &llsfc_cfg,
                          FC_CFG_DISABLE_L2_COSMASK_XOFFf, 1);
        SOC_IF_ERROR_RETURN(WRITE_LLS_FC_CONFIGr(unit, llsfc_cfg));

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit,
                                    IFP_METER_WRITE_LAST_REFRESH_NUMBERr,
                                    REG_PORT_ANY, WRITE_ENf, 1));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit,
                                    ING_SVM_CONTROLr, REG_PORT_ANY,
                         DISABLE_CPU_WRITE_TO_LAST_REFRESH_NUMBERf, 0));

        /* Refresh disables */
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          DLB_1US_TICK_ENABLEf, 0);
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          STORM_CONTROL_REFRESH_ENABLEf, 0);
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          SVC_MTR_REFRESH_ENABLEf, 0);
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          OAM_REFRESH_ENABLEf, 0);
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          DLB_REFRESH_ENABLEf, 0);
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          FT_REFRESH_ENABLEf, 0);
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          IPFIX_REFRESH_ENABLEf, 0);
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          FP_REFRESH_ENABLEf, 0);
        SOC_IF_ERROR_RETURN(WRITE_AUX_ARB_CONTROL_2r(unit, aac2));
    }

    parity_enable = soc_property_get(unit, spn_PARITY_ENABLE, TRUE);
    if (parity_enable) {
        (void)_soc_tr3_parity_enable_all(unit, enable);
    } else {
        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &mscfg));
        soc_reg_field_set(unit, MISCCONFIGr, &mscfg, PARITY_STAT_CLEARf, 1);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, mscfg));
        if (enable) {
            /* MMU enables */
            /* coverity[dead_error_line] */
            soc_reg_field_set(unit, MISCCONFIGr, &mscfg, PARITY_CHK_ENf, 1);
            /* coverity[dead_error_line] */
            soc_reg_field_set(unit, MISCCONFIGr, &mscfg, PARITY_GEN_ENf, 1);
            soc_reg_field_set(unit, MISCCONFIGr, &mscfg, PARITY_STAT_CLEARf, 0);
            soc_reg_field_set(unit, MISCCONFIGr, &mscfg, METERING_CLK_ENf, 1);
            SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, mscfg));
        } else {
            /* MMU disables */
            soc_reg_field_set(unit, MISCCONFIGr, &mscfg, PARITY_CHK_ENf, 0);
            soc_reg_field_set(unit, MISCCONFIGr, &mscfg, PARITY_GEN_ENf, 0);
            soc_reg_field_set(unit, MISCCONFIGr, &mscfg, PARITY_STAT_CLEARf, 0);
            soc_reg_field_set(unit, MISCCONFIGr, &mscfg, METERING_CLK_ENf, 0);
            SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, mscfg));
        }
    }

    if (enable) {
        /* Re-enable HW updates */
        SOC_IF_ERROR_RETURN(WRITE_INTFO_HW_UPDATE_DISr(unit, intfo_dis));

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, INTFI_CFGr, REG_PORT_ANY,
                                    PFC_ST_TBL_DISABLEf, 0));

        SOC_IF_ERROR_RETURN(READ_LLS_FC_CONFIGr(unit, &llsfc_cfg));
        soc_reg_field_set(unit, LLS_FC_CONFIGr, &llsfc_cfg,
                          FC_CFG_DISABLE_XOFFf, 0);
        soc_reg_field_set(unit, LLS_FC_CONFIGr, &llsfc_cfg,
                          FC_CFG_DISABLE_ALL_XOFFf, 0);
        soc_reg_field_set(unit, LLS_FC_CONFIGr, &llsfc_cfg,
                          FC_CFG_DISABLE_L2_COSMASK_XOFFf, 0);
        SOC_IF_ERROR_RETURN(WRITE_LLS_FC_CONFIGr(unit, llsfc_cfg));

        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit,
                                    IFP_METER_WRITE_LAST_REFRESH_NUMBERr,
                                    REG_PORT_ANY, WRITE_ENf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit,
                                    ING_SVM_CONTROLr, REG_PORT_ANY,
                         DISABLE_CPU_WRITE_TO_LAST_REFRESH_NUMBERf, 1));

        /* Refresh enables */
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          DLB_1US_TICK_ENABLEf, 1);
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          STORM_CONTROL_REFRESH_ENABLEf, 1);
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          SVC_MTR_REFRESH_ENABLEf, 1);
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          OAM_REFRESH_ENABLEf, 1);
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          DLB_REFRESH_ENABLEf, 1);
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          FT_REFRESH_ENABLEf, 1);
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          IPFIX_REFRESH_ENABLEf, 1);
        soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &aac2,
                          FP_REFRESH_ENABLEf, 1);
        SOC_IF_ERROR_RETURN(WRITE_AUX_ARB_CONTROL_2r(unit, aac2));
    } 
    sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Allow things to stabalize */
    return SOC_E_NONE;
}

/* SER processing for TCAMs */
static _soc_ser_parity_info_t _soc_tr3_ser_parity_info_template[] = {
    /* EP */
    { EFP_TCAMm, _SOC_SER_PARITY_MODE_4BITS,
      CMIC_SER1_START_ADDR_0r, CMIC_SER1_END_ADDR_0r,
      CMIC_SER1_MEM_ADDR_0r, CMIC_SER1_PARITY_MODE_SEL_15_0r,
      RANGE_0_PARITY_BITSf, 470, CMIC_SER1_RANGE0_DATAENTRY_LENr, 1, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    /* IP */
    { FP_TCAMm, _SOC_SER_PARITY_MODE_4BITS,
      CMIC_SER0_START_ADDR_1r, CMIC_SER0_END_ADDR_1r,
      CMIC_SER0_MEM_ADDR_1r, CMIC_SER0_PARITY_MODE_SEL_15_0r,
      RANGE_1_PARITY_BITSf, 470, CMIC_SER0_RANGE1_DATAENTRY_LENr, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { VFP_TCAMm, _SOC_SER_PARITY_MODE_4BITS,
      CMIC_SER0_START_ADDR_2r, CMIC_SER0_END_ADDR_2r,
      CMIC_SER0_MEM_ADDR_2r, CMIC_SER0_PARITY_MODE_SEL_15_0r,
      RANGE_2_PARITY_BITSf, 470, CMIC_SER0_RANGE2_DATAENTRY_LENr, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { FP_UDF_TCAMm, _SOC_SER_PARITY_MODE_2BITS,
      CMIC_SER0_START_ADDR_3r, CMIC_SER0_END_ADDR_3r,
      CMIC_SER0_MEM_ADDR_3r, CMIC_SER0_PARITY_MODE_SEL_15_0r,
      RANGE_3_PARITY_BITSf, 161, CMIC_SER0_RANGE3_DATAENTRY_LENr, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { L3_TUNNELm, _SOC_SER_PARITY_MODE_4BITS,
      CMIC_SER0_START_ADDR_4r, CMIC_SER0_END_ADDR_4r,
      CMIC_SER0_MEM_ADDR_4r, CMIC_SER0_PARITY_MODE_SEL_15_0r,
      RANGE_4_PARITY_BITSf, 213, CMIC_SER0_RANGE4_DATAENTRY_LENr, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { VLAN_SUBNETm, _SOC_SER_PARITY_MODE_2BITS,
      CMIC_SER0_START_ADDR_5r, CMIC_SER0_END_ADDR_5r,
      CMIC_SER0_MEM_ADDR_5r, CMIC_SER0_PARITY_MODE_SEL_15_0r,
      RANGE_5_PARITY_BITSf, 129, CMIC_SER0_RANGE5_DATAENTRY_LENr, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { MY_STATION_TCAMm, _SOC_SER_PARITY_MODE_8BITS,
      CMIC_SER0_START_ADDR_6r, CMIC_SER0_END_ADDR_6r,
      CMIC_SER0_MEM_ADDR_6r, CMIC_SER0_PARITY_MODE_SEL_15_0r,
      RANGE_6_PARITY_BITSf, 153, CMIC_SER0_RANGE6_DATAENTRY_LENr, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { L2_USER_ENTRYm, _SOC_SER_PARITY_MODE_4BITS,
      CMIC_SER0_START_ADDR_7r, CMIC_SER0_END_ADDR_7r,
      CMIC_SER0_MEM_ADDR_7r, CMIC_SER0_PARITY_MODE_SEL_15_0r,
      RANGE_7_PARITY_BITSf, 127, CMIC_SER0_RANGE7_DATAENTRY_LENr, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { FP_GLOBAL_MASK_TCAMm, _SOC_SER_PARITY_MODE_2BITS,
      CMIC_SER0_START_ADDR_8r, CMIC_SER0_END_ADDR_8r,
      CMIC_SER0_MEM_ADDR_8r, CMIC_SER0_PARITY_MODE_SEL_15_0r,
      RANGE_8_PARITY_BITSf, 177, CMIC_SER0_RANGE8_DATAENTRY_LENr, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { CPU_COS_MAPm, _SOC_SER_PARITY_MODE_2BITS,
      CMIC_SER0_START_ADDR_9r, CMIC_SER0_END_ADDR_9r,
      CMIC_SER0_MEM_ADDR_9r, CMIC_SER0_PARITY_MODE_SEL_15_0r,
      RANGE_9_PARITY_BITSf, 231, CMIC_SER0_RANGE9_DATAENTRY_LENr, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { ESM_PKT_TYPE_IDm, _SOC_SER_PARITY_MODE_2BITS,
      CMIC_SER0_START_ADDR_10r, CMIC_SER0_END_ADDR_10r,
      CMIC_SER0_MEM_ADDR_10r, CMIC_SER0_PARITY_MODE_SEL_15_0r,
      RANGE_10_PARITY_BITSf, 129, CMIC_SER0_RANGE10_DATAENTRY_LENr, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { L3_DEFIPm, _SOC_SER_PARITY_MODE_2BITS,
      CMIC_SER0_START_ADDR_11r, CMIC_SER0_END_ADDR_11r,
      CMIC_SER0_MEM_ADDR_11r, CMIC_SER0_PARITY_MODE_SEL_15_0r,
      RANGE_11_PARITY_BITSf, 190, CMIC_SER0_RANGE11_DATAENTRY_LENr, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_SIZE_VERIFY | 
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ},
    { L3_DEFIP_PAIR_128m, _SOC_SER_PARITY_MODE_2BITS,
      CMIC_SER0_START_ADDR_12r, CMIC_SER0_END_ADDR_12r,
      CMIC_SER0_MEM_ADDR_12r, CMIC_SER0_PARITY_MODE_SEL_15_0r,
      RANGE_12_PARITY_BITSf, 380, CMIC_SER0_RANGE12_DATAENTRY_LENr, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_SIZE_VERIFY |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ},
    { INVALIDm, _SOC_SER_PARITY_MODE_NUM},
};

static _soc_ser_parity_info_t *_soc_tr3_ser_parity_info[SOC_MAX_NUM_DEVICES];

#define SOC_TR3_SER_MEM_AVAILABLE (4096 * 32)  /* bits */

STATIC void
_soc_tr3_ser_info_flag_update(_soc_ser_parity_info_t *ser_info,
                              soc_mem_t mem, uint32 flag, int enable)
{
    int ser_idx = 0;

    while (INVALIDm != ser_info[ser_idx].mem) {
        if (ser_info[ser_idx].mem == mem) {
            if (enable) {
                ser_info[ser_idx].ser_flags |= flag;
            } else {
                ser_info[ser_idx].ser_flags &= ~flag;
            }
        }
        ser_idx++;
    }
}

STATIC int
_soc_tr3_ser_init(int unit)
{
    _soc_ser_parity_info_t *ser_info;
    int alloc_size, ser_idx = 0;
    soc_tcam_info_t *tcam_info;
    soc_tcam_partition_t *ipv4_defip_partition;

    /* First, make per-unit copy of the master TCAM list */
    alloc_size = sizeof(_soc_tr3_ser_parity_info_template);
    if (NULL == _soc_tr3_ser_parity_info[unit]) {
        if ((_soc_tr3_ser_parity_info[unit] =
             sal_alloc(alloc_size, "tr3 tcam list")) == NULL) {
            return SOC_E_MEMORY;
        }
    }
    /* Make a fresh copy of the TCAM template info */
    sal_memcpy(_soc_tr3_ser_parity_info[unit],
               &(_soc_tr3_ser_parity_info_template),
               alloc_size);

    /* Now make per-unit modifications */
    ser_info = _soc_tr3_ser_parity_info[unit];
    tcam_info = SOC_CONTROL(unit)->tcam_info;
    if (NULL != tcam_info) {
        ipv4_defip_partition = &(tcam_info->partitions[
                                              TCAM_PARTITION_FWD_IP4]);
        if (0 != ipv4_defip_partition->num_entries) {
            /* No internal DEFIP tables, truncate the TCAM list */
            while (INVALIDm != ser_info[ser_idx].mem) {
                if (ser_info[ser_idx].mem == L3_DEFIPm) {
                    ser_info[ser_idx].mem = INVALIDm;
                    break;
                }
                ser_idx++;
            }
        }
    }

    if (soc_feature(unit, soc_feature_field_stage_half_slice) ||
        soc_feature(unit, soc_feature_field_stage_ingress_256_half_slice) ||
        soc_feature(unit, soc_feature_field_slice_size128) ||
        soc_feature(unit, soc_feature_field_stage_quarter_slice)) {
        _soc_tr3_ser_info_flag_update(ser_info, FP_GLOBAL_MASK_TCAMm,
                                      _SOC_SER_FLAG_NO_DMA, TRUE);
        _soc_tr3_ser_info_flag_update(ser_info, FP_TCAMm,
                                      _SOC_SER_FLAG_NO_DMA, TRUE);
    }

    if (soc_feature(unit, soc_feature_field_stage_half_slice) ||
        soc_feature(unit, soc_feature_field_stage_egress_256_half_slice) ||
        soc_feature(unit, soc_feature_field_stage_quarter_slice)) {
        _soc_tr3_ser_info_flag_update(ser_info, EFP_TCAMm,
                                      _SOC_SER_FLAG_NO_DMA, TRUE);
    }

    if (soc_feature(unit, soc_feature_field_stage_lookup_512_half_slice) ||
        soc_feature(unit, soc_feature_field_stage_quarter_slice)) {
        _soc_tr3_ser_info_flag_update(ser_info, VFP_TCAMm,
                                      _SOC_SER_FLAG_NO_DMA, TRUE);
    }

    return soc_ser_init(unit, ser_info, SOC_TR3_SER_MEM_AVAILABLE);
}

int
soc_tr3_ser_mem_clear(int unit, soc_mem_t mem)
{
    return soc_cmicm_ser_mem_clear(unit,
                                   _soc_tr3_ser_parity_info[unit], mem);
}

STATIC void
soc_tr3_ser_fail(int unit)
{
#ifdef BCM_HELIX4_SUPPORT
    if (SOC_IS_HELIX4(unit)) {
        soc_hx4_ser_fail(unit);
        return;
    }
#endif /* BCM_HELIX4_SUPPORT */    
    soc_process_cmicm_ser_parity_error(unit, _soc_tr3_ser_parity_info[unit],
                                       _SOC_PARITY_TYPE_SER);
    return;
}

/* FCOE standard FC header configurations */
static _soc_fcoe_header_info_t _soc_tr3_fcoe_header_info[] = {
    { SOC_FCOE_HDR_TYPE_STD ,   0,     7 },
    { SOC_FCOE_HDR_TYPE_STD ,   33,   35 },
    { SOC_FCOE_HDR_TYPE_STD ,   50,   51 },
    { SOC_FCOE_HDR_TYPE_STD ,   64,   71 },
    { SOC_FCOE_HDR_TYPE_VFT ,   80,   80 },
    { SOC_FCOE_HDR_TYPE_IFR ,   81,   81 },
    { SOC_FCOE_HDR_TYPE_ENCAP,  82,   82 },
    { SOC_FCOE_HDR_TYPE_STD,   128,  134 },
    { SOC_FCOE_HDR_TYPE_STD,   192,  201 },
};

STATIC int
_soc_tr3_fcoe_config_init(int unit)
{
    int index, rctl, count = COUNTOF(_soc_tr3_fcoe_header_info);

    for (index = 0; index < count; index++) {
        /* Configure FCOE header for routing control indexes */
        for (rctl = _soc_tr3_fcoe_header_info[index].r_ctl_min; 
             rctl <= _soc_tr3_fcoe_header_info[index].r_ctl_max; rctl++) {
            SOC_IF_ERROR_RETURN(
                soc_mem_field32_modify(unit, FC_HEADER_TYPEm, rctl, 
                 FC_HDR_ENCODEf, _soc_tr3_fcoe_header_info[index].fc_hdr_type));
        }
    }
    return SOC_E_NONE;
}

STATIC int
soc_tr3_mem_clear(int unit)
{
    uint32              rval, index;
    int                 pipe_init_usec;
    soc_timeout_t       to;
    int                 tcam_protect_write;

    static const soc_mem_t cam[] = {
        L3_TUNNELm,
        FP_UDF_TCAMm,
        VLAN_SUBNETm,
        VFP_TCAMm,
        MY_STATION_TCAMm,
        L2_USER_ENTRYm,
        L3_DEFIPm,
        L3_DEFIP_PAIR_128m,
        ESM_PKT_TYPE_IDm,
        FP_TCAMm,
        FP_GLOBAL_MASK_TCAMm,
        CPU_COS_MAPm,
        EFP_TCAMm
    };

    static const soc_mem_t axp[] = {
        AXP_WTX_TUNNELm,
        AXP_WRX_WCDm,
        AXP_WRX_SVP_ASSIGNMENTm,
        AXP_WTX_DVP_PROFILEm,
        AXP_WTX_PRI_MAPm,
        AXP_WTX_FRAG_IDm
    };

    /*
     * Reset the IPIPE and EPIPE block
     */
    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_1r(unit, rval));
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, VALIDf, 1);
    /* Set count to # entries in largest IPIPE table */
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, COUNTf, 65536);
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_0r(unit, rval));
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, VALIDf, 1);
    /* Set count to # entries in largest EPIPE table */
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, COUNTf, 65536);
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ISM_HW_RESET_CONTROL_0r(unit, rval));
    soc_reg_field_set(unit, ISM_HW_RESET_CONTROL_1r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, ISM_HW_RESET_CONTROL_1r, &rval, VALIDf, 1);
    /* Set count to # entries in largest ISM table */
    soc_reg_field_set(unit, ISM_HW_RESET_CONTROL_1r, &rval, COUNTf, 131072);
    SOC_IF_ERROR_RETURN(WRITE_ISM_HW_RESET_CONTROL_1r(unit, rval));
    
    /* Clear AXP block mems */
    rval = 0;
    soc_reg_field_set(unit, AXP_WRX_MEMORY_BULK_RESETr, &rval, START_RESETf, 1);
    SOC_IF_ERROR_RETURN(WRITE_AXP_WRX_MEMORY_BULK_RESETr(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_AXP_WTX_MEMORY_BULK_RESETr(unit, rval));
    if (soc_feature(unit, soc_feature_regex)) {
        SOC_IF_ERROR_RETURN(WRITE_AXP_SM_MEMORY_BULK_RESETr(unit, rval));
    }

    /* For simulation, set timeout to 10 sec.  Otherwise, timeout = 50 ms */
    if (SAL_BOOT_SIMULATION) {
        pipe_init_usec = 10000000;
    } else {
        pipe_init_usec = 50000;
    }
    soc_timeout_init(&to, pipe_init_usec, 0);
    /* Wait for IPIPE memory initialization done. */
    do {
        SOC_IF_ERROR_RETURN(READ_ING_HW_RESET_CONTROL_2r(unit, &rval));
        if (soc_reg_field_get(unit, ING_HW_RESET_CONTROL_2r, rval, DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : ING_HW_RESET timeout\n"), unit));
            break;
        }
    } while (TRUE);
    soc_timeout_init(&to, pipe_init_usec, 0);
    /* Wait for EPIPE memory initialization done. */
    do {
        SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1r(unit, &rval));
        if (soc_reg_field_get(unit, EGR_HW_RESET_CONTROL_1r, rval, DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : EGR_HW_RESET timeout\n"), unit));
            break;
        }
    } while (TRUE);
    soc_timeout_init(&to, pipe_init_usec, 0);
    /* Wait for ISM memory initialization done. */
    do {
        SOC_IF_ERROR_RETURN(READ_ISM_HW_RESET_CONTROL_1r(unit, &rval));
        if (soc_reg_field_get(unit, ISM_HW_RESET_CONTROL_1r, rval, DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : ISM_HW_RESET timeout\n"), unit));
            break;
        }
    } while (TRUE);
    soc_timeout_init(&to, pipe_init_usec, 0);
    /* Wait for AXP WLAN RX memory initialization done. */
    do {
        SOC_IF_ERROR_RETURN(READ_AXP_WRX_MEMORY_BULK_RESETr(unit, &rval));
        if (soc_reg_field_get(unit, AXP_WRX_MEMORY_BULK_RESETr, rval, RESET_DONEf) ||
            SAL_BOOT_PLISIM) {
            break;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : AXP_WRX_MEMORY timeout\n"), unit));
            break;
        }
    } while (TRUE);
    soc_timeout_init(&to, pipe_init_usec, 0);
    /* Wait for AXP WLAN TX memory initialization done. */
    do {
        SOC_IF_ERROR_RETURN(READ_AXP_WTX_MEMORY_BULK_RESETr(unit, &rval));
        if (soc_reg_field_get(unit, AXP_WTX_MEMORY_BULK_RESETr, rval, RESET_DONEf) ||
            SAL_BOOT_PLISIM) {
            break;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : AXP_WTX_MEMORY timeout\n"), unit));
            break;
        }
    } while (TRUE);
    if (soc_feature(unit, soc_feature_regex)) {
        soc_timeout_init(&to, pipe_init_usec, 0);
        /* Wait for AXP SM memory initialization done. */
        do {
            SOC_IF_ERROR_RETURN(READ_AXP_SM_MEMORY_BULK_RESETr(unit, &rval));
            if (soc_reg_field_get(unit, AXP_SM_MEMORY_BULK_RESETr, rval, RESET_DONEf) ||
                SAL_BOOT_PLISIM) {
                break;
            }
            if (soc_timeout_check(&to)) {
                LOG_WARN(BSL_LS_SOC_COMMON,
                         (BSL_META_U(unit,
                                     "unit %d : AXP_SM_MEMORY timeout\n"), unit));
                break;
            }
        } while (TRUE);
    }
    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_ISM_HW_RESET_CONTROL_1r(unit, rval));
    rval = 0;
    soc_reg_field_set(unit, AXP_WRX_MEMORY_BULK_RESETr, &rval, START_RESETf, 0);
    SOC_IF_ERROR_RETURN(WRITE_AXP_WRX_MEMORY_BULK_RESETr(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_AXP_WTX_MEMORY_BULK_RESETr(unit, rval));
    if (soc_feature(unit, soc_feature_regex)) {
        SOC_IF_ERROR_RETURN(WRITE_AXP_SM_MEMORY_BULK_RESETr(unit, rval));
    }

    if (!SAL_BOOT_SIMULATION || SAL_BOOT_BCMSIM) {
        /* TCAM tables are not handled by hardware reset control */
        tcam_protect_write = SOC_CONTROL(unit)->tcam_protect_write;
        SOC_CONTROL(unit)->tcam_protect_write = FALSE;
        for (index = 0; index < sizeof(cam) / sizeof(soc_mem_t); index++) {
            if (SOC_MEM_IS_VALID(unit, cam[index])) {
                if (SAL_BOOT_BCMSIM &&
                    !((cam[index] == VLAN_SUBNET_ONLYm) ||
                     (cam[index] == VFP_TCAMm) ||
                     (cam[index] == L2_USER_ENTRY_ONLYm))) {
                    continue;
                }
                SOC_IF_ERROR_RETURN(soc_mem_clear(unit, cam[index],
                                                  COPYNO_ALL, TRUE));
            }
        }
        SOC_CONTROL(unit)->tcam_protect_write = tcam_protect_write;
    }
    if (!SAL_BOOT_SIMULATION) {
        for (index = 0; index < sizeof(axp) / sizeof(soc_mem_t); index++) {
            SOC_IF_ERROR_RETURN(soc_mem_clear(unit, axp[index], COPYNO_ALL, TRUE));
        }
        SOC_IF_ERROR_RETURN
            (soc_mem_clear(unit, EGR_MPLS_VC_AND_SWAP_LABEL_TABLEm, COPYNO_ALL, 
                           TRUE));
        SOC_IF_ERROR_RETURN
            (soc_mem_clear(unit, ING_DVP_2_TABLEm, COPYNO_ALL, TRUE));
    }
    return SOC_E_NONE;
}

int
soc_tr3_init_port_mapping(int unit)
{
    soc_info_t *si;
    soc_mem_t mem;
    uint32 rval;
    ing_physical_to_logical_port_number_mapping_table_entry_t entry;
    int port, phy_port, mmu_port;
    int num_port, num_phy_port, num_mmu_port;

    si = &SOC_INFO(unit);

    /* Ingress physical to logical port mapping */
    mem = ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm;
    num_phy_port = soc_mem_index_count(unit, mem);
    sal_memset(&entry, 0, sizeof(entry));
    for (phy_port = 0; phy_port < num_phy_port; phy_port++) {
        port = si->port_p2l_mapping[phy_port];
        soc_mem_field32_set(unit, mem, &entry, LOGICAL_PORT_NUMBERf,
                            port == -1 ? 0x7f : port);
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem, MEM_BLOCK_ALL, phy_port, &entry));
    }
    num_port = soc_mem_index_count(unit, PORT_TABm);
    /* Egress logical to physical port mapping */
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_l2p_mapping[port];
        rval = 0;
        soc_reg_field_set(unit, EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr,
                          &rval, PHYSICAL_PORT_NUMBERf,
                          phy_port == -1 ? 0x7f : phy_port);
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr(unit, port,
                                                                rval));
    }

    /* MMU to physical port mapping and MMU to logical port mapping */
    num_mmu_port = SOC_REG_NUMELS(unit, MMU_TO_PHY_PORT_MAPPINGr);
    for (mmu_port = 0; mmu_port < num_mmu_port; mmu_port++) {
        phy_port = si->port_m2p_mapping[mmu_port];
        port = phy_port == -1 ? -1 : si->port_p2l_mapping[phy_port];

        rval = 0;
        soc_reg_field_set(unit, MMU_TO_PHY_PORT_MAPPINGr, &rval, PHY_PORTf,
                          phy_port == -1 ? 0x7f : phy_port);
        SOC_IF_ERROR_RETURN
            (WRITE_MMU_TO_PHY_PORT_MAPPINGr(unit, mmu_port, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_TO_LOGIC_PORT_MAPPINGr, &rval, LOGIC_PORTf,
                          port == -1 ? 0x3f : port);
        SOC_IF_ERROR_RETURN
            (WRITE_MMU_TO_LOGIC_PORT_MAPPINGr(unit, mmu_port, rval));
    }

    return SOC_E_NONE;
}

int
soc_triumph3_init_num_cosq(int unit)
{
    soc_info_t *si;
    int port;
    int mc_numq, mc_base;
    int uc_numq, uc_base;

    si = &SOC_INFO(unit);

    SOC_PBMP_CLEAR(si->eq_pbm);
    PBMP_ALL_ITER(unit, port) {
        if (IS_HG_PORT(unit, port)) {
            SOC_PBMP_PORT_ADD(si->eq_pbm, port);
        }
    }

    PBMP_ALL_ITER(unit, port) {
        soc_tr3_get_def_qbase(unit, port, _SOC_TR3_INDEX_STYLE_UCAST_QUEUE,
                                &uc_base, &uc_numq);
        soc_tr3_get_def_qbase(unit, port, _SOC_TR3_INDEX_STYLE_MCAST_QUEUE,
                                &mc_base, &mc_numq);
        si->port_num_cosq[port] = mc_numq;
        si->port_cosq_base[port] = mc_base;
        si->port_num_uc_cosq[port] = uc_numq;
        si->port_uc_cosq_base[port] = uc_base;
        si->port_group[port] = -1;
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "Port-%d : UC: %d:%d, MC: %d:%d\n"),
                                port, uc_base, uc_numq, mc_base, mc_numq));
    }

    return SOC_E_NONE;
}

/* TR3 Port Configs:
   ================

F.HG[127] = Boot Config between HG[127]/3xF.HG[42]
F.HG[42]  = Hot Swap between HG[42]/2xHGd[21]/2xRXAUI/4xHGs[11]/4xXFI/4x1GE/4x2.5GE
F.XAUI    = Hot Swap between XAUI/4x1GE/4x2.5GE
F.HG[21]  = Hot Swap between HG[21]/XAUI/4x1GE/4x2.5G
F.40GE    = Hot Swap between XE40/2xRXAUI/4xXFI/4x1GE/4x2.5GE

------------------------------------------------------------------------------------------------------------------------------------------
    dev-id         | cfg-id |           configuration                                               |    property             |  Hot swap
------------------------------------------------------------------------------------------------------------------------------------------
BCM56640           | 37     |                3xF.HG[42] + 1xHG[127] + 1GE                           | none                    |     yes
BCM56640           | 35     | TR3_100GE_260: 1x100GE + 1xHG[127] + 1GE                              | bcm56640_1x100_1x127    |     no
BCM56640           | 36     |                1x100GE + 4xHG[32] + 1GE                               | bcm56640_1x100_4x32     |     no
BCM56640           | 81     |                1x100GE + 8xHGd[16] + 1GE                              | bcm56640_1x100_8x16     |     no
BCM56640           | 38     |                1x100GE + 3xF.HG[42] + 1GE                             | bcm56640_1x100_3x42     |     yes
BCM56640           | 82     |                3xF.HG[42] + 4xHG[32] + 1GE                            | bcm56640_3x42_4x32      |     yes
BCM56640           | 83     |                3xF.HG[42] + 8xHGd[16] + 1GE                           | bcm56640_3x42_8x16      |     yes
BCM56640           | 71     |                3xF.40GE + 3xF.HG[42] + 1GE                            | bcm56640_3x40_3x42      |     yes
BCM56640           | 72     |                3xF.HG[42] + 3xF.40GE + 1GE                            | bcm56640_3x42_3x40      |     yes
                   |        |                                                                       |                         |     
BCM56643           | 95     | TR3_1G_280: 48xGE + 4xXFI + 4xHG[42] + 1GE                            | none                    |     no
BCM56643           | 195    | TR3_1G_280: 48xGE + 1x40GE + 4xHG[42] + 1GE                           | bcm56640_1x40_4x42      |     no
BCM56643           | 295    | TR3_1G_280: 48xGE + 4xXFI + 1xHG[127] + 1GE                           | bcm56640_4x10_1x127     |     no
BCM56643           | 100    | TR3_1G_280_FX: 36xGE + 4xXFI + 2xHG[42] + 2xF.HG[42] + 1GE            | bcm56640_4x10_4x42      |     yes
BCM56643           | 102    | TR3_1G_280_FX: 36xGE + 4xXFI + 2xF.HG[42] + 2xHG[42] + 1GE            | bcm56643_4x10_4x42      |     Yes
                   |        |                                                                       |                         |     
BCM56644           | 90     | FB3_1G_200_HG25: 48xGE + 2xHG[25] + 2xHG[25] + 1GE                    | none                    |     no
BCM56644           | 190    | FB3_1G_200_HG25: 24xGE (line rate encap) + 2xXAUI + 2xHG[25] + 1GE    | bcm56644_24g            |     no
                   |        |                                                                       |                         |     
BCM56540/BCM56545  | 10     | FB3_1G_200: 48xGE + 2xHG[42] + 2xHG[21] + 1GE                         | none                    |     no
BCM56540/BCM56545  | 12     | FB4_1G_200: 48xGE + 4xXFI + 2xHG[42] + 1GE                            | bcm56540_4x10_2x42      |     no
BCM56540/BCM56545  | 96     | FB3_1G_200_XFI: 48xGE + 8xXFI + 1GE                                   | bcm56540_8x10           |     no
BCM56545           | 99     | 24xGE + 4xXAUI + 2xXFI + 2xHG[12] + 1GE                               | bcm56545_24g            |     no
                   |        |                                                                       |                         |     
BCM56648           | 95     | TR3_1G_280: 48xGE + 4xXFI + 4xHG[42] + 1GE                            | none                    |     no
BCM56648           | 195    | TR3_1G_280: 48xGE + 1x40GE + 4xHG[42] + 1GE                           | bcm56640_1x40_4x42      |     no
BCM56648           | 100    | TR3_1G_280_FX: 36xGE + 4xXFI + 2xHG[42] + 2xF.HG[42] + 1GE            | bcm56640_4x10_4x42      |     yes
                   |        |                                                                       |                         |     
BCM56544           | 91     | FB4_XAUI_200_C: 10xF.XAUI + 4xHG[21] + 1GE                            | none                    |     yes
BCM56544           | 97     |                 10xF.XAUI + 4xXFI + 1GE                               | bcm56544_10x10_4x10     |     yes 
BCM56544           | 98     |                 10xF.XAUI + 2xHG[42]                                  | bcm56544_10x10_2x42     |     yes 
BCM56544           | 94     | FB4_XAUI_200_F: 4xXAUI + 12xXFI + 1GE                                 | bcm56544_4x10_12x10     |     no
                   |        |                                                                       |                         |     
BCM56541           | 110    | 28xGE + 2xHG[42] + 2xHG[21] + 1GE                                     | none                    |     no
BCM56541           | 112    | 28xGE + 4xXFI + 2xHG[42] + 1GE                                        | bcm56540_4x10_2x42      |     no
BCM56541           | 196    | 28xGE + 8xXFI + 1GE                                                   | bcm56540_8x10           |     no
                   |        |                                                                       |                         |     
BCM56542           | 40     | AP2_1G_200_A: 28xGE + 2xF.XAUI/2x10GE + 2xF.HG[42] + 2xF.HG[21] + 1GE | bcm56542_2x10_2x42_2x21 |     yes
BCM56542           | 41     | AP2_1G_200_B: 28xGE + 8xGE/8x2.5GE    + 2xHG[42]   + 2xHG[21] + 1GE   | none                    |     no
                   |        |                                                                       |                         |     
BCM56546           | 110    | 28xGE + 2xHG[42] + 2xHG[21] + 1GE                                     | none                    |     no
BCM56546           | 112    | 28xGE + 4xXFI + 2xHG[42] + 1GE                                        | bcm56540_4x10_2x42      |     no
BCM56546           | 196    | 28xGE + 8xXFI + 1GE                                                   | bcm56540_8x10           |     no
                   |        |                                                                       |                         |     
BCM56649           | 395    | 28xGE + 4xXFI + 4xHG[42] + 1GE                                        | none                    |     no
BCM56649           | 495    | 28xGE + 1x40GE + 4xHG[42] + 1GE                                       | bcm56640_1x40_4x42      |     no
BCM56649           | 101    | 28xGE + 4xXFI + 2xHG[42] + 2xF.HG[42] + 1GE                           | bcm56640_4x10_4x42      |     yes
                   |        |                                                                       |                         |     
BCM56044           | 38     | 1x100GE + 3xF.HG[42] + 1GE                                            | none                    |     yes
                   |        |                                                                       |                         |     
BCM56045           | 55     | RNGR_XAUI_260: 12xXAUI + 3xF.HG[42] + 1GE                             | none                    |     yes
BCM56045           | 71     | 3xF.40GE + 3xF.HG[42] + 1GE                                           | bcm56640_3x40_3x42      |     yes
BCM56045           | 72     | 3xF.HG[42] + 3xF.40GE + 1GE                                           | bcm56640_3x42_3x40      |     yes
                   |        |                                                                       |                         |     
BCM56046           | 155    | 12xXAUI + 2xF.HG[42] + 1GE                                            | none                    |     yes
BCM56046           | 171    | 3xF.40GE + 2xF.HG[42] + 1GE                                           | bcm56640_3x40_2x42      |     yes
BCM56046           | 172    | 3xF.HG[42] + 2xF.40GE + 1GE                                           | bcm56640_3x42_2x40      |     yes
------------------------------------------------------------------------------------------------------------------------------------------
*/

typedef struct {
    uint16 dev_id;
    uint8 opp_spacing;
    int def_cfg;
    int cfg[_MAX_TR3_PORT_CFG];
} _soc_tr3_port_cfg_t;

typedef struct {
    uint16 dev_id;
    char *props[_MAX_TR3_FLEX_PORT_PROPS];
} _soc_tr3_flex_port_cfg_t;

static _soc_tr3_flex_port_cfg_t tr3_flex_props[] = {
    { BCM56640_DEVICE_ID, { spn_BCM56640_3X40_3X42, spn_BCM56640_3X42_3X40,
                            spn_BCM56640_1X100_1X127, spn_BCM56640_1X100_4X32, 
                            spn_BCM56640_1X100_8X16, spn_BCM56640_1X100_3X42,
                            spn_BCM56640_3X42_4X32, spn_BCM56640_3X42_8X16,
                            /* NOTE: Following 2 are test only configs */
                            "REGRESSION", "EMULATION", NULL } },
    { BCM56643_DEVICE_ID, { spn_BCM56640_1X40_4X42, spn_BCM56640_4X10_1X127,
                            spn_BCM56640_4X10_4X42, spn_BCM56643_4X10_4X42,
                           NULL} },

    { BCM56644_DEVICE_ID, { spn_BCM56644_24G, NULL } },
    { BCM56540_DEVICE_ID, { spn_BCM56540_4X10_2X42, spn_BCM56540_8X10, NULL } },
    { BCM56541_DEVICE_ID, { spn_BCM56540_4X10_2X42, spn_BCM56540_8X10, NULL } },
    { BCM56542_DEVICE_ID, { spn_BCM56542_2X10_2X42_2X21, NULL } },
    { BCM56544_DEVICE_ID, { spn_BCM56544_10X10_4X10, spn_BCM56544_10X10_2X42, 
                            spn_BCM56544_4X10_12X10, NULL } },
    { BCM56545_DEVICE_ID, { spn_BCM56540_4X10_2X42, spn_BCM56540_8X10, 
                            spn_BCM56545_24G, NULL } },
    { BCM56546_DEVICE_ID, { spn_BCM56540_4X10_2X42, spn_BCM56540_8X10, NULL } },
    { BCM56648_DEVICE_ID, { spn_BCM56640_1X40_4X42, spn_BCM56640_4X10_4X42, NULL } },
    { BCM56649_DEVICE_ID, { spn_BCM56640_1X40_4X42, spn_BCM56640_4X10_4X42, NULL } },
    { BCM56044_DEVICE_ID, { NULL } },
    { BCM56045_DEVICE_ID, { spn_BCM56640_3X40_3X42, spn_BCM56640_3X42_3X40, NULL } },
    { BCM56046_DEVICE_ID, { spn_BCM56640_3X40_2X42, spn_BCM56640_3X42_2X40, NULL } }
};

int16 _tr3_wc_flex_port_speeds_1[] = { 42, 21, 10, 11, 10, 3, 1, -1 };
int16 _tr3_wc_flex_port_lanes_1[]  = {  4,  2,  2,  1,  1, 1, 1, -1 };
int16 _tr3_wc_def_flex_port_speeds_1[] = { 42, 21, 11 };
int16 _tr3_wc_flex_port_speeds_2[] = { 21, 10, 3, 1, -1 };
int16 _tr3_wc_flex_port_lanes_2[]  = {  4,  4, 1, 1, -1 };
int16 _tr3_wc_def_flex_port_speeds_2[] = { 21, 0, 3 };
int16 _tr3_wc_flex_port_speeds_3[] = { 40, 10, 10, 3, 1, -1 };
int16 _tr3_wc_flex_port_lanes_3[]  = {  4,  2,  1, 1, 1, -1 };
int16 _tr3_wc_def_flex_port_speeds_3[] = { 40, 10, 10 };
int16 _tr3_xc_flex_port_speeds[] = { 10,  3,  1, -1 };
int16 _tr3_xc_flex_port_lanes[]  = {  4,  1,  1, -1 };
int16 _tr3_xc_def_flex_port_speeds[] = { 10, 0, 3 };
_soc_tr3_flex_port_inf_t _tr3_flex_port_inf[SOC_MAX_NUM_DEVICES];
int _tr3_port_config_id[SOC_MAX_NUM_DEVICES] = {-1};
int _tr3_tdm_opp_spacing[SOC_MAX_NUM_DEVICES] = {0};
_soc_tr3_flex_port_data_t _tr3_flex_port_data[SOC_MAX_NUM_DEVICES] = {{0}};

STATIC void
_soc_tr3_resolve_port_config(int unit, int dev_id) {
    static _soc_tr3_port_cfg_t tr3_port_cfg[] = {
        { BCM56640_DEVICE_ID, 3, 37,  {  71,  72,  35, 36, 81, 38, 82, 83, 
                                         /* NOTE: Following 2 are test only configs */
                                         11,  50,  -1 } },
        { BCM56643_DEVICE_ID, 3, 95,  { 195, 295, 100, 102, -1 } },
        { BCM56644_DEVICE_ID, 3, 90,  { 190,  -1 } },
        { BCM56540_DEVICE_ID, 3, 10,  {  12,  96,  -1 } },
        { BCM56541_DEVICE_ID, 3, 110, { 112, 196,  -1 } },
        { BCM56542_DEVICE_ID, 3, 41,  {  40,  -1 } },
        { BCM56544_DEVICE_ID, 3, 91,  {  97,  98,  94, -1 } },
        { BCM56545_DEVICE_ID, 3, 10,  {  12,  96,  99, -1 } },
        { BCM56546_DEVICE_ID, 3, 110, { 112, 196, -1 } },
        { BCM56648_DEVICE_ID, 3, 95,  { 195, 100, -1 } },
        { BCM56649_DEVICE_ID, 3, 395, { 495, 101, -1 } },
        { BCM56044_DEVICE_ID, 3, 38,  {  -1 } },
        { BCM56045_DEVICE_ID, 3, 55,  {  71,  72, -1 } },
        { BCM56046_DEVICE_ID, 3, 155, { 171, 172, -1 } }
    };
    int i, c, config, cfg_id = 0;
    uint8 entries;
    
    entries = COUNTOF(tr3_flex_props);
    for (i = 0; i < entries; i++) {
        if (dev_id == tr3_flex_props[i].dev_id) {
            _tr3_tdm_opp_spacing[unit] = tr3_port_cfg[i].opp_spacing;
            cfg_id = tr3_port_cfg[i].def_cfg;
            for (c = 0; tr3_flex_props[i].props[c] != NULL ;c++) {
                config = soc_property_get(unit, tr3_flex_props[i].props[c], 0);
                if (config) {
                    cfg_id = tr3_port_cfg[i].cfg[c];
                    break;
                }
            }
        }
    }
    _tr3_port_config_id[unit] = cfg_id;
    _tr3_flex_port_data[unit].dev_id = dev_id;
}

int _soc_tr3_port_speed_max[SOC_MAX_PHY_PORTS]; /* max phy port speed */
/*
 * Tr3 port mapping
 * cpu port number is fixed: physical 0, logical 0, mmu 0
 * loopback port numbers are fixed
 */
int
soc_triumph3_get_port_mapping(int unit, uint16 dev_id)
{
    /* COVERITY: Intentional: static array of mappings */
    /* coverity[stack_use_callee_max : FALSE] */
    /* FB3_1G_200: 48xGE + 2xHG[42] + 2xHG[21] + 1GE */
    static const int p2l_mapping_10[] = {
          0,
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
         37, -1, -1, -1,
         38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
         -1, -1, -1, -1, 50, -1, -1, -1, 51, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 52, -1, -1, -1, 53, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_10[] = {
         59,
          0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,
         12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
         24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
         60, -1, -1, -1,
         36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
         -1, -1, -1, -1, 48, -1, -1, -1, 49, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 50, -1, -1, -1, 51, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_10[] = {
         -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
         -1, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 21, -1, -1, -1, 21, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* 56541/56546: 28xGE + 2xHG[42] + 2xHG[21] + 1GE */
    static const int p2l_mapping_110[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  2,  3,  4,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
         37, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 50, -1, -1, -1, 51, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 52, -1, -1, -1, 53, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_110[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1,  0,  1,  2,  3,
          4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
         16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 48, -1, -1, -1, 49, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 50, -1, -1, -1, 51, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_110[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 21, -1, -1, -1, 21, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* TR3_1G_200: 48xGE + 4xXFI + 4xHG[25] + 1GE */
    static const int p2l_mapping_11[] = {
          0,
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
         37, -1, -1, -1,
         38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
         -1, -1, -1, -1, 50, 51, 52, 53, -1, -1, -1, -1,
         54, -1, -1, -1,
         55, -1, -1, -1, 56, -1, -1, -1, 57, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_11[] = {
         59,
          0, 1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11,
         12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
         24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
         60, -1, -1, -1,
         36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
         -1, -1, -1, -1, 48, 49, 50, 51, -1, -1, -1, -1,
         52, -1, -1, -1,
         53, -1, -1, -1, 54, -1, -1, -1, 55, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_11[] = {
         -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
         -1, -1, -1, -1, 10, 10, 10, 10, -1, -1, -1, -1,
         25, -1, -1, -1,
         25, -1, -1, -1, 25, -1, -1, -1, 25, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* FB4_1G_200: 48xGE + 4xXFI + 2xHG[42] + 1GE */
    static const int p2l_mapping_12[] = {
          0,
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
         37, -1, -1, -1,
         38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
         -1, -1, -1, -1, 50, 51, 52, 53, -1, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 54, -1, -1, -1, 55, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_12[] = {
         59,
          0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,
         12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
         24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
         60, -1, -1, -1,
         36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
         -1, -1, -1, -1, 48, 49, 50, 51, -1, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 52, -1, -1, -1, 53, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_12[] = {
         -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
         -1, -1, -1, -1, 10, 10, 10, 10, -1, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* 56541/56546: 28xGE + 4xXFI + 2xHG[42] + 1GE */
    static const int p2l_mapping_112[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  2,  3,  4,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
         37, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 50, 51, 52, 53, -1, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 54, -1, -1, -1, 55, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_112[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1,  0,  1,  2,  3,
          4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
         16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 48, 49, 50, 51, -1, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 52, -1, -1, -1, 53, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_112[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 10, 10, 10, 10, -1, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* TR3_100GE_260: 1x100GE + 1xHG[127] */
    static const int p2l_mapping_35[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1,
         21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_35[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1,
         52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_35[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        100, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1,
        127, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* 1x100GE + 4xHG[32] */
    static const int p2l_mapping_36[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         17, -1, -1, -1,
         21, -1, -1, -1, 25, -1, -1, -1, 29, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_36[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         53, -1, -1, -1,
         52, -1, -1, -1, 54, -1, -1, -1, 55, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_36[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        100, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         30, -1, -1, -1,
         30, -1, -1, -1, 30, -1, -1, -1, 30, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* 3xF.HG[42] + 1xHG[127] */
    static const int p2l_mapping_37[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         -1, -1, -1, -1,
         21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_37[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5, -1, -1, -1,  9, -1, -1, -1, 13, -1, -1, -1,
         -1, -1, -1, -1,
         21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_37[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         48, 40, 41, 42, 49, 43, 44, 45, 50, 46, 47, 51,
         -1, -1, -1, -1,
         52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_37[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1,
        127, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    static _soc_tr3_flex_port_inf_t flex_port_inf_37 = {
        1,
        { 13, 14, 15, -1 },
        { _tr3_wc_flex_port_speeds_1, _tr3_wc_flex_port_speeds_1,
          _tr3_wc_flex_port_speeds_1, NULL },
        { _tr3_wc_def_flex_port_speeds_1, _tr3_wc_def_flex_port_speeds_1,
          _tr3_wc_def_flex_port_speeds_1, NULL },
        { _tr3_wc_flex_port_lanes_1, _tr3_wc_flex_port_lanes_1,
          _tr3_wc_flex_port_lanes_1, NULL }
    };    
    /* 1x100GE + 3xF.HG[42] */
    static const int p2l_mapping_38[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1,
         21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_38[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1,
         21, -1, -1, -1, 25, -1, -1, -1, 29, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_38[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1,
         48, 40, 41, 42, 49, 43, 44, 45, 50, 46, 47, 51,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_38[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        100, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    static _soc_tr3_flex_port_inf_t flex_port_inf_38 = {
        1,
        { 17, 18, 19, -1 },
        { _tr3_wc_flex_port_speeds_1, _tr3_wc_flex_port_speeds_1,
          _tr3_wc_flex_port_speeds_1, NULL },
        { _tr3_wc_def_flex_port_speeds_1, _tr3_wc_def_flex_port_speeds_1,
          _tr3_wc_def_flex_port_speeds_1, NULL },
        { _tr3_wc_flex_port_lanes_1, _tr3_wc_flex_port_lanes_1,
          _tr3_wc_flex_port_lanes_1, NULL }
    };    
    /* AP2_1G_200_A: 28xGE + 2xF.XAUI/2x10GE + 2xF.HG[42] + 2xF.HG[21] + 1GE */
    static const int p2l_mapping_40[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  2,  3,  4,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         17, 18, 19, 20, -1, -1, -1, -1, 21, 22, 23, 24,
         25, -1, -1, -1,
         26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37,
         -1, -1, -1, -1, 38, 39, 40, 41, 42, 43, 44, 45,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 46, 47, 48, 49, 50, 51, 52, 53,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_40[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  2,  3,  4,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         17, 18, 19, 20, -1, -1, -1, -1, 21, 22, 23, 24,
         25, -1, -1, -1,
         26, 27, 28, 29, 30, -1, -1, -1, 34, -1, -1, -1,
         -1, -1, -1, -1, 38, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 46, -1, -1, -1, 50, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_40[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1,  0,  1,  2,  3,
          4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
         16, 17, 18, 19, -1, -1, -1, -1, 20, 21, 22, 23,
         60, -1, -1, -1,
         24, 25, 26, 27, 32, 28, 29, 30, 33, 31, 36, 37,
         -1, -1, -1, -1, 48, 49, 50, 51, 52, 53, 54, 55,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 44, 38, 39, 40, 47, 41, 42, 43,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_40[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1, -1, -1, -1, -1,  1,  1,  1,  1,
          1, -1, -1, -1,
          1,  1,  1,  1, 10, -1, -1, -1, 10, -1, -1, -1,
         -1, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 21, -1, -1, -1, 21, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    static _soc_tr3_flex_port_inf_t flex_port_inf_40 = {
        1,
        { 11, 12, 14, 15, 18, 19, -1 },
        { _tr3_xc_flex_port_speeds, _tr3_xc_flex_port_speeds,
          _tr3_wc_flex_port_speeds_1, _tr3_wc_flex_port_speeds_1,
          _tr3_wc_flex_port_speeds_2, _tr3_wc_flex_port_speeds_2, NULL },
        { _tr3_xc_def_flex_port_speeds, _tr3_xc_def_flex_port_speeds,
          _tr3_wc_def_flex_port_speeds_1, _tr3_wc_def_flex_port_speeds_1,
          _tr3_wc_def_flex_port_speeds_2, _tr3_wc_def_flex_port_speeds_2, NULL },
        { _tr3_xc_flex_port_lanes, _tr3_xc_flex_port_lanes,
          _tr3_wc_flex_port_lanes_1, _tr3_wc_flex_port_lanes_1,
          _tr3_wc_flex_port_lanes_2, _tr3_wc_flex_port_lanes_2, NULL }
    };
    /* AP2_1G_200_B: 28xGE + 8xGE/8x2.5GE + 2xHG[42] + 2xHG[21] + 1GE */
    static const int p2l_mapping_41[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  2,  3,  4,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         17, 18, 19, 20, -1, -1, -1, -1, 21, 22, 23, 24,
         25, -1, -1, -1,
         26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37,
         -1, -1, -1, -1, 38, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 46, -1, -1, -1, 50, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_41[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1,  0,  1,  2,  3,
          4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
         16, 17, 18, 19, -1, -1, -1, -1, 20, 21, 22, 23,
         60, -1, -1, -1,
         24, 25, 26, 27, 32, 28, 29, 30, 33, 31, 36, 37,
         -1, -1, -1, -1, 48, -1, -1, -1, 52, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 44, -1, -1, -1, 47, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_41[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1, -1, -1, -1, -1,  1,  1,  1,  1,
          1, -1, -1, -1,
          1,  1,  1,  1,  3,  3,  3,  3,  3,  3,  3,  3,
         -1, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 21, -1, -1, -1, 21, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* FB4_1G_260_EMU: 48xGE + 4xXFI + 2xHG[42] + 1GE */
    static const int p2l_mapping_50[] = {
          0,
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
         37, -1, -1, -1,
         38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
         -1, -1, -1, -1, 50, 51, 52, 53, -1, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 54, -1, -1, -1, 55, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_50[] = {
         59,
          0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,
         12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
         24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
         60, -1, -1, -1,
         36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
         -1, -1, -1, -1, 48, 49, 50, 51, -1, -1, -1, -1,
         -1, -1, -1, -1, 
         -1, -1, -1, -1, 52, -1, -1, -1, 53, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_50[] = {
         -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
         -1, -1, -1, -1, 10, 10, 10, 10, -1, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* RNGR_XAUI_260: 12xXAUI + 3xF.HG[42] + 1GE */
    static const int p2l_mapping_55[] = {
          0,
          1, -1, -1, -1,  2, -1, -1, -1,  3, -1, -1, -1,
          4, -1, -1, -1,  5, -1, -1, -1,  6, -1, -1, -1,
          7, -1, -1, -1,  8, -1, -1, -1,  9, -1, -1, -1,
         37, -1, -1, -1,
         10, -1, -1, -1, 11, -1, -1, -1, 12, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1,
         21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_55[] = {
          0,
          1, -1, -1, -1,  2, -1, -1, -1,  3, -1, -1, -1,
          4, -1, -1, -1,  5, -1, -1, -1,  6, -1, -1, -1,
          7, -1, -1, -1,  8, -1, -1, -1,  9, -1, -1, -1,
         37, -1, -1, -1,
         10, -1, -1, -1, 11, -1, -1, -1, 12, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1,
         21, -1, -1, -1, 25, -1, -1, -1, 29, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_55[] = {
         59,
         48, -1, -1, -1, 36, -1, -1, -1, 32, -1, -1, -1,
         37, -1, -1, -1, 49, -1, -1, -1, 38, -1, -1, -1,
         33, -1, -1, -1, 39, -1, -1, -1, 50, -1, -1, -1,
         60, -1, -1, -1,
         40, -1, -1, -1, 51, -1, -1, -1, 41, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 
         52, 42, 34, 43, 53, 44, 35, 45, 54, 46, 55, 47,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_55[] = {
         -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
          1, -1, -1, -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    static _soc_tr3_flex_port_inf_t flex_port_inf_55 = {
        1,
        { 17, 18, 19, -1 },
        { _tr3_wc_flex_port_speeds_1, _tr3_wc_flex_port_speeds_1, 
          _tr3_wc_flex_port_speeds_1, NULL },
        { _tr3_wc_def_flex_port_speeds_1, _tr3_wc_def_flex_port_speeds_1, 
          _tr3_wc_def_flex_port_speeds_1, NULL },
        { _tr3_wc_flex_port_lanes_1, _tr3_wc_flex_port_lanes_1, 
          _tr3_wc_flex_port_lanes_1, NULL }
    };
    /* 12xXAUI + 2xF.HG[42] + 1GE */
    static const int p2l_mapping_155[] = {
          0,
          1, -1, -1, -1,  2, -1, -1, -1,  3, -1, -1, -1,
          4, -1, -1, -1,  5, -1, -1, -1,  6, -1, -1, -1,
          7, -1, -1, -1,  8, -1, -1, -1,  9, -1, -1, -1,
         37, -1, -1, -1,
         10, -1, -1, -1, 11, -1, -1, -1, 12, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1,
         21, 22, 23, 24, 25, 26, 27, 28, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_155[] = {
          0,
          1, -1, -1, -1,  2, -1, -1, -1,  3, -1, -1, -1,
          4, -1, -1, -1,  5, -1, -1, -1,  6, -1, -1, -1,
          7, -1, -1, -1,  8, -1, -1, -1,  9, -1, -1, -1,
         37, -1, -1, -1,
         10, -1, -1, -1, 11, -1, -1, -1, 12, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1,
         21, -1, -1, -1, 25, -1, -1, -1, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_155[] = {
         59,
         48, -1, -1, -1, 36, -1, -1, -1, 32, -1, -1, -1,
         37, -1, -1, -1, 49, -1, -1, -1, 38, -1, -1, -1,
         33, -1, -1, -1, 39, -1, -1, -1, 50, -1, -1, -1,
         60, -1, -1, -1,
         40, -1, -1, -1, 51, -1, -1, -1, 41, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 
         52, 42, 34, 43, 53, 44, 35, 45, -1, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_155[] = {
         -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
          1, -1, -1, -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    static _soc_tr3_flex_port_inf_t flex_port_inf_155 = {
        1,
        { 17, 18, -1 },
        { _tr3_wc_flex_port_speeds_1, _tr3_wc_flex_port_speeds_1, NULL },
        { _tr3_wc_def_flex_port_speeds_1, _tr3_wc_def_flex_port_speeds_1, NULL },
        { _tr3_wc_flex_port_lanes_1, _tr3_wc_flex_port_lanes_1, NULL }
    };
    /* 3xF.40GE + 3xF.HG[42] */
    static const int p2l_mapping_71[] = {
          0, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         -1, -1, -1, -1,
         21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_71[] = {
          0, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5, -1, -1, -1,  9, -1, -1, -1, 13, -1, -1, -1,
         -1, -1, -1, -1,
         21, -1, -1, -1, 25, -1, -1, -1, 29, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_71[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         60, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         48, 32, 33, 34, 49, 35, 36, 37, 50, 38, 51, 39,
         -1, -1, -1, -1,
         52, 40, 41, 42, 53, 43, 44, 45, 54, 46, 55, 47,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_71[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         40, -1, -1, -1, 40, -1, -1, -1, 40, -1, -1, -1,
         -1, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    static _soc_tr3_flex_port_inf_t flex_port_inf_71 = {
        1,
        { 13, 14, 15, 17, 18, 19, -1 },
        { _tr3_wc_flex_port_speeds_3, _tr3_wc_flex_port_speeds_3,
          _tr3_wc_flex_port_speeds_3, _tr3_wc_flex_port_speeds_1, 
          _tr3_wc_flex_port_speeds_1, _tr3_wc_flex_port_speeds_1, NULL },
        { _tr3_wc_def_flex_port_speeds_3, _tr3_wc_def_flex_port_speeds_3,
          _tr3_wc_def_flex_port_speeds_3, _tr3_wc_def_flex_port_speeds_1,
          _tr3_wc_def_flex_port_speeds_1, _tr3_wc_def_flex_port_speeds_1, NULL },
        { _tr3_wc_flex_port_lanes_3, _tr3_wc_flex_port_lanes_3,
          _tr3_wc_flex_port_lanes_3, _tr3_wc_flex_port_lanes_1,
          _tr3_wc_flex_port_lanes_1, _tr3_wc_flex_port_lanes_1, NULL }
    };
    /* 3xF.HG[42] + 3xF.40GE */
    static const int p2l_mapping_72[] = {
          0, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         -1, -1, -1, -1,
         21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_72[] = {
          0, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5, -1, -1, -1,  9, -1, -1, -1, 13, -1, -1, -1,
         -1, -1, -1, -1,
         21, -1, -1, -1, 25, -1, -1, -1, 29, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_72[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         60, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         52, 40, 41, 42, 53, 43, 44, 45, 54, 46, 55, 47,
         -1, -1, -1, -1,
         48, 32, 33, 34, 49, 35, 36, 37, 50, 38, 51, 39,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_72[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1,
         40, -1, -1, -1, 40, -1, -1, -1, 40, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    static _soc_tr3_flex_port_inf_t flex_port_inf_72 = {
        1,
        { 13, 14, 15, 17, 18, 19, -1 },
        { _tr3_wc_flex_port_speeds_1, _tr3_wc_flex_port_speeds_1,
          _tr3_wc_flex_port_speeds_1, _tr3_wc_flex_port_speeds_3, 
          _tr3_wc_flex_port_speeds_3, _tr3_wc_flex_port_speeds_3, NULL },
        { _tr3_wc_def_flex_port_speeds_1, _tr3_wc_def_flex_port_speeds_1,
          _tr3_wc_def_flex_port_speeds_1, _tr3_wc_def_flex_port_speeds_3,
          _tr3_wc_def_flex_port_speeds_3, _tr3_wc_def_flex_port_speeds_3, NULL },
        { _tr3_wc_flex_port_lanes_1, _tr3_wc_flex_port_lanes_1,
          _tr3_wc_flex_port_lanes_1, _tr3_wc_flex_port_lanes_3,
          _tr3_wc_flex_port_lanes_3, _tr3_wc_flex_port_lanes_3, NULL }
    };
    /* 3xF.40GE + 2xF.HG[42] */
    static const int p2l_mapping_171[] = {
          0, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         -1, -1, -1, -1,
         21, 22, 23, 24, 25, 26, 27, 28, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_171[] = {
          0, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5, -1, -1, -1,  9, -1, -1, -1, 13, -1, -1, -1,
         -1, -1, -1, -1,
         21, -1, -1, -1, 25, -1, -1, -1, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_171[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         60, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         48, 32, 33, 34, 49, 35, 36, 37, 50, 38, 51, 39,
         -1, -1, -1, -1,
         52, 40, 41, 42, 53, 43, 44, 45, -1, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_171[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         40, -1, -1, -1, 40, -1, -1, -1, 40, -1, -1, -1,
         -1, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    static _soc_tr3_flex_port_inf_t flex_port_inf_171 = {
        1,
        { 13, 14, 15, 17, 18, -1 },
        { _tr3_wc_flex_port_speeds_3, _tr3_wc_flex_port_speeds_3,
          _tr3_wc_flex_port_speeds_3, _tr3_wc_flex_port_speeds_1, 
          _tr3_wc_flex_port_speeds_1, NULL },
        { _tr3_wc_def_flex_port_speeds_3, _tr3_wc_def_flex_port_speeds_3,
          _tr3_wc_def_flex_port_speeds_3, _tr3_wc_def_flex_port_speeds_1,
          _tr3_wc_def_flex_port_speeds_1, NULL },
        { _tr3_wc_flex_port_lanes_3, _tr3_wc_flex_port_lanes_3,
          _tr3_wc_flex_port_lanes_3, _tr3_wc_flex_port_lanes_1,
          _tr3_wc_flex_port_lanes_1, NULL }
    };
    /* 3xF.HG[42] + 2xF.40GE */
    static const int p2l_mapping_172[] = {
          0, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         -1, -1, -1, -1,
         21, 22, 23, 24, 25, 26, 27, 28, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_172[] = {
          0, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5, -1, -1, -1,  9, -1, -1, -1, 13, -1, -1, -1,
         -1, -1, -1, -1,
         21, -1, -1, -1, 25, -1, -1, -1, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_172[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         60, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         52, 40, 41, 42, 53, 43, 44, 45, 54, 46, 55, 47,
         -1, -1, -1, -1,
         48, 32, 33, 34, 49, 35, 36, 37, -1, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_172[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1,
         40, -1, -1, -1, 40, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    static _soc_tr3_flex_port_inf_t flex_port_inf_172 = {
        1,
        { 13, 14, 15, 17, 18, 19, -1 },
        { _tr3_wc_flex_port_speeds_1, _tr3_wc_flex_port_speeds_1,
          _tr3_wc_flex_port_speeds_1, _tr3_wc_flex_port_speeds_3, 
          _tr3_wc_flex_port_speeds_3, NULL },
        { _tr3_wc_def_flex_port_speeds_1, _tr3_wc_def_flex_port_speeds_1,
          _tr3_wc_def_flex_port_speeds_1, _tr3_wc_def_flex_port_speeds_3,
          _tr3_wc_def_flex_port_speeds_3, NULL },
        { _tr3_wc_flex_port_lanes_1, _tr3_wc_flex_port_lanes_1,
          _tr3_wc_flex_port_lanes_1, _tr3_wc_flex_port_lanes_3,
          _tr3_wc_flex_port_lanes_3, NULL }
    };
    /* 1x100GE + 8xHGd[16] */
    static const int p2l_mapping_81[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         17, -1, 19, -1,
         21, -1, 23, -1, 25, -1, 27, -1, 29, -1, 31, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_81[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         53, -1, 33, -1,
         52, -1, 32, -1, 54, -1, 34, -1, 55, -1, 35, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_81[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        100, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         16, -1, 16, -1,
         16, -1, 16, -1, 16, -1, 16, -1, 16, -1, 16, -1,
         -1, -1, -1, -1, -1
    };
    /* 3xF.HG[42] + 4xHG[32] */
    static const int p2l_mapping_82[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         17, -1, -1, -1,
         21, -1, -1, -1, 25, -1, -1, -1, 29, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_82[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5, -1, -1, -1,  9, -1, -1, -1, 13, -1, -1, -1,
         17, -1, -1, -1,
         21, -1, -1, -1, 25, -1, -1, -1, 29, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_82[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         48, 40, 41, 42, 49, 43, 44, 45, 50, 46, 47, 51,
         53, -1, -1, -1,
         52, -1, -1, -1, 54, -1, -1, -1, 55, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_82[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         30, -1, -1, -1,
         30, -1, -1, -1, 30, -1, -1, -1, 30, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* 3xF.HG[42] + 8xHGd[16] */
    static const int p2l_mapping_83[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         17, -1, 19, -1,
         21, -1, 23, -1, 25, -1, 27, -1, 29, -1, 31, -1,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_83[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          5, -1, -1, -1,  9, -1, -1, -1, 13, -1, -1, -1,
         17, -1, 19, -1,
         21, -1, 23, -1, 25, -1, 27, -1, 29, -1, 31, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_83[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         48, 40, 41, 42, 49, 43, 44, 45, 50, 46, 47, 51,
         53, -1, 33, -1,
         52, -1, 32, -1, 54, -1, 34, -1, 55, -1, 35, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_83[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         16, -1, 16, -1,
         16, -1, 16, -1, 16, -1, 16, -1, 16, -1, 16, -1,
         -1, -1, -1, -1, -1
    };
    /* FB3_1G_200_HG25: 48xGE + 2xHG[21] + 2xHG[21] + 1GE */
    static const int p2l_mapping_90[] = {
          0,  
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
         37, -1, -1, -1,
         38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 
         -1, -1, -1, -1, 50, -1, -1, -1, 51, -1, -1, -1, 
         -1, -1, -1, -1, 
         -1, -1, -1, -1, 52, -1, -1, -1, 53, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_90[] = {
         59,  
          0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 
         12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
         24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
         60, -1, -1, -1, 
         36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 
         -1, -1, -1, -1, 48, -1, -1, -1, 49, -1, -1, -1, 
         -1, -1, -1, -1, 
         -1, -1, -1, -1, 50, -1, -1, -1, 51, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_90[] = {
         -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
         -1, -1, -1, -1, 25, -1, -1, -1, 25, -1, -1, -1, 
         -1, -1, -1, -1, 
         -1, -1, -1, -1, 25, -1, -1, -1, 25, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* 56644: 24xGE-LR + 2xXAUI + 2xHG[21] + 1GE */
    static const int p2l_mapping_190[] = {
          0,  
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         37, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
         -1, -1, -1, -1, 50, -1, -1, -1, 51, -1, -1, -1, 
         -1, -1, -1, -1, 
         -1, -1, -1, -1, 52, -1, -1, -1, 53, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_190[] = {
         59,  
          0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 
         12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         60, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
         -1, -1, -1, -1, 48, -1, -1, -1, 49, -1, -1, -1, 
         -1, -1, -1, -1, 
         -1, -1, -1, -1, 50, -1, -1, -1, 51, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_190[] = {
         -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1, 
         -1, -1, -1, -1, 
         -1, -1, -1, -1, 25, -1, -1, -1, 25, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* FB4_XAUI_200_C: 10xF.XAUI + 4xHG[21] + 1GE */
    static const int p2l_mapping_91[] = {
          0,
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
         37, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 38, 39, 40, 41,
         -1, -1, -1, -1, 42, -1, -1, -1, 46, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 50, -1, -1, -1, 51, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_91[] = {
          0,
          1, -1, -1, -1,  5, -1, -1, -1,  9, -1, -1, -1,
         13, -1, -1, -1, 17, -1, -1, -1, 21, -1, -1, -1,
         25, -1, -1, -1, 29, -1, -1, -1, 33, -1, -1, -1,
         37, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, -1, -1,
         -1, -1, -1, -1, 42, -1, -1, -1, 46, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 50, -1, -1, -1, 51, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_91[] = {
         59,
         32,  0,  1,  2, 33,  3,  4,  5, 34,  6,  7,  8,
         35,  9, 10, 11, 45, 12, 13, 14, 46, 15, 16, 17,
         48, 18, 19, 20, 49, 21, 22, 23, 50, 24, 25, 26,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 51, 27, 28, 29,
         -1, -1, -1, -1, 52, -1, -1, -1, 53, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 54, -1, -1, -1, 55, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_91[] = {
         -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1,
         -1, -1, -1, -1, 21, -1, -1, -1, 21, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 21, -1, -1, -1, 21, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    static _soc_tr3_flex_port_inf_t flex_port_inf_91 = {
        1,
        { 0, 1, 2, 3, 4, 5, 6, 7, 8, 12, -1 },
        { _tr3_xc_flex_port_speeds, _tr3_xc_flex_port_speeds,
          _tr3_xc_flex_port_speeds, _tr3_xc_flex_port_speeds,
          _tr3_xc_flex_port_speeds, _tr3_xc_flex_port_speeds, 
          _tr3_xc_flex_port_speeds, _tr3_xc_flex_port_speeds,
          _tr3_xc_flex_port_speeds, _tr3_xc_flex_port_speeds, NULL },
        { _tr3_xc_def_flex_port_speeds, _tr3_xc_def_flex_port_speeds,
          _tr3_xc_def_flex_port_speeds, _tr3_xc_def_flex_port_speeds,
          _tr3_xc_def_flex_port_speeds, _tr3_xc_def_flex_port_speeds, 
          _tr3_xc_def_flex_port_speeds, _tr3_xc_def_flex_port_speeds,
          _tr3_xc_def_flex_port_speeds, _tr3_xc_def_flex_port_speeds, NULL },
        { _tr3_xc_flex_port_lanes, _tr3_xc_flex_port_lanes,
          _tr3_xc_flex_port_lanes, _tr3_xc_flex_port_lanes,
          _tr3_xc_flex_port_lanes, _tr3_xc_flex_port_lanes,
          _tr3_xc_flex_port_lanes, _tr3_xc_flex_port_lanes,
          _tr3_xc_flex_port_lanes, _tr3_xc_flex_port_lanes, NULL }
    };
    /* FB4_XAUI_200_F: 4xXAUI + 12xXFI + 1GE */
    static const int p2l_mapping_94[] = {
          0,
          1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 17, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 29, -1, -1, -1, -1, -1, -1, -1,
         37, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, -1, -1,
         -1, -1, -1, -1, 42, 43, 44, 45, -1, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 46, 47, 48, 49, 50, 51, 52, 53,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_94[] = {
         59,
         40, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 41, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 42, -1, -1, -1, -1, -1, -1, -1,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 43, -1, -1, -1,
         -1, -1, -1, -1, 48, 32, 33, 34, -1, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 49, 35, 50, 51, 52, 53, 54, 55,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_94[] = {
         -1,
         10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1,
         -1, -1, -1, -1, 10, 10, 10, 10, -1, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, 10, 10, 10, 10, 10, 10, 10, 10,
         -1, -1, -1, -1, -1
    };
    /* TR3_1G_280: 48xGE + 4xXFI + 4xHG[42] + 1GE */
    static const int p2l_mapping_95[] = {
          0,
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
         37, -1, -1, -1,
         38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
         -1, -1, -1, -1, 50, 51, 52, 53, -1, -1, -1, -1,
         54, -1, -1, -1,
         55, -1, -1, -1, 56, -1, -1, -1, 57, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_95[] = {
         59,
          0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,
         12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
         24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
         60, -1, -1, -1,
         36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
         -1, -1, -1, -1, 48, 49, 50, 51, -1, -1, -1, -1,
         52, -1, -1, -1,
         53, -1, -1, -1, 54, -1, -1, -1, 55, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_95[] = {
         -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
         -1, -1, -1, -1, 10, 10, 10, 10, -1, -1, -1, -1,
         42, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* 48xGE + 1x40GE + 4xHG[42] + 1GE */
    static const int p2l_mapping_195[] = {
          0,
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
         37, -1, -1, -1,
         38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
         -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1,
         54, -1, -1, -1,
         55, -1, -1, -1, 56, -1, -1, -1, 57, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_195[] = {
         59,
          0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,
         12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
         24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
         60, -1, -1, -1,
         36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
         -1, -1, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1,
         52, -1, -1, -1,
         53, -1, -1, -1, 54, -1, -1, -1, 55, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_195[] = {
         -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
         -1, -1, -1, -1, 40, -1, -1, -1, -1, -1, -1, -1,
         42, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* TR3_1G_280: 48xGE + 4xXFI + 1xHG[127] + 1GE */
    static const int p2l_mapping_295[] = {
          0,
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
         37, -1, -1, -1,
         38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
         -1, -1, -1, -1, 50, 51, 52, 53, -1, -1, -1, -1,
         -1, -1, -1, -1,
         55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_295[] = {
         59,
          0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,
         12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
         24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
         60, -1, -1, -1,
         36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
         -1, -1, -1, -1, 48, 49, 50, 51, -1, -1, -1, -1,
         -1, -1, -1, -1,
         52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_295[] = {
         -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
         -1, -1, -1, -1, 10, 10, 10, 10, -1, -1, -1, -1,
         -1, -1, -1, -1,
        127, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* 28xGE + 4xXFI + 4xHG[42] + 1GE */
    static const int p2l_mapping_395[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  2,  3,  4,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
         29, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 50, 51, 52, 53, -1, -1, -1, -1,
         54, -1, -1, -1,
         55, -1, -1, -1, 56, -1, -1, -1, 57, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_395[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1,  0,  1,  2,  3,
          4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
         16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 48, 49, 50, 51, -1, -1, -1, -1,
         52, -1, -1, -1,
         53, -1, -1, -1, 54, -1, -1, -1, 55, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_395[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 10, 10, 10, 10, -1, -1, -1, -1,
         42, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* 28xGE + 1x40GE + 4xHG[42] + 1GE */
    static const int p2l_mapping_495[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  2,  3,  4,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
         29, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1,
         54, -1, -1, -1,
         55, -1, -1, -1, 56, -1, -1, -1, 57, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_495[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1,  0,  1,  2,  3,
          4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
         16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1,
         52, -1, -1, -1,
         53, -1, -1, -1, 54, -1, -1, -1, 55, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_495[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 40, -1, -1, -1, -1, -1, -1, -1,
         42, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* FB3_1G_200_XFI: 48xGE + 8xXFI + 1GE */
    static const int p2l_mapping_96[] = {
          0,
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
         37, -1, -1, -1,
         38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
         -1, -1, -1, -1, 50, 51, 52, 53, 54, 55, 56, 57,
         -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_96[] = {
         59,
          0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,
         12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
         24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
         60, -1, -1, -1,
         36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
         -1, -1, -1, -1, 48, 49, 50, 51, 52, 53, 54, 55,
         -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_96[] = {
         -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
         -1, -1, -1, -1, 10, 10, 10, 10, 10, 10, 10, 10,
         -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* 56541/56546: 28xGE + 8xXFI + 1GE */
    static const int p2l_mapping_196[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  2,  3,  4,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
         37, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 50, 51, 52, 53, 54, 55, 56, 57,
         -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_196[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1,  0,  1,  2,  3,
          4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
         16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 48, 49, 50, 51, 52, 53, 54, 55,
         -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_196[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 10, 10, 10, 10, 10, 10, 10, 10,
         -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* 10xF.XAUI + 4xXFI */
    static const int p2l_mapping_97[] = {
          0,
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
         37, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 38, 39, 40, 41,
         -1, -1, -1, -1, 42, 43, 44, 45, -1, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_97[] = {
          0,
          1, -1, -1, -1,  5, -1, -1, -1,  9, -1, -1, -1,
         13, -1, -1, -1, 17, -1, -1, -1, 21, -1, -1, -1,
         25, -1, -1, -1, 29, -1, -1, -1, 33, -1, -1, -1,
         37, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, -1, -1,
         -1, -1, -1, -1, 42, 43, 44, 45, -1, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_97[] = {
         59,
         32,  0,  1,  2, 33,  3,  4,  5, 34,  6,  7,  8,
         35,  9, 10, 11, 45, 12, 13, 14, 46, 15, 16, 17,
         48, 18, 19, 20, 49, 21, 22, 23, 50, 24, 25, 26,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 51, 27, 28, 29,
         -1, -1, -1, -1, 52, 53, 54, 55, -1, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_97[] = {
         -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1,
         -1, -1, -1, -1, 10, 10, 10, 10, -1, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* 10xF.XAUI + 2xHG[42] */
    static const int p2l_mapping_98[] = {
          0,
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
         37, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 38, 39, 40, 41,
         -1, -1, -1, -1, 42, -1, -1, -1, 46, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_98[] = {
          0,
          1, -1, -1, -1,  5, -1, -1, -1,  9, -1, -1, -1,
         13, -1, -1, -1, 17, -1, -1, -1, 21, -1, -1, -1,
         25, -1, -1, -1, 29, -1, -1, -1, 33, -1, -1, -1,
         37, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, -1, -1,
         -1, -1, -1, -1, 42, -1, -1, -1, 46, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_98[] = {
         59,
         32,  0,  1,  2, 33,  3,  4,  5, 34,  6,  7,  8,
         35,  9, 10, 11, 45, 12, 13, 14, 46, 15, 16, 17,
         48, 18, 19, 20, 49, 21, 22, 23, 50, 24, 25, 26,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 51, 27, 28, 29,
         -1, -1, -1, -1, 52, -1, -1, -1, 53, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_98[] = {
        -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1,
         -1, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* 56546: 24xGE + 4xXAUI + 2xXFI + 2xHG[12] + 1GE */
    static const int p2l_mapping_99[] = {
          0,  
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         25, -1, -1, -1, 26, -1, -1, -1, 27, -1, -1, -1,
         28, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 29, -1, -1, -1, 
         -1, -1, -1, -1, 30, 31, -1, -1, -1, -1, -1, -1, 
         -1, -1, -1, -1, 
         -1, -1, -1, -1, 32, -1, -1, -1, 33, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_99[] = {
         59,  
          0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 
         12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
         49, -1, -1, -1, 50, -1, -1, -1, 51, -1, -1, -1,
         60, -1, -1, -1, 
         -1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, 
         -1, -1, -1, -1, 54, 55, -1, -1, -1, -1, -1, -1, 
         -1, -1, -1, -1, 
         -1, -1, -1, -1, 48, -1, -1, -1, 52, -1, -1, -1,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_99[] = {
         -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
         10, -1, -1, -1, 10, -1, -1, -1, 10, -1, -1, -1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1,
         -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, -1, -1, 
         -1, -1, -1, -1, 
         -1, -1, -1, -1, 12, -1, -1, -1, 12, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* TR3_1G_280_FX: 36xGE + 4xXFI + 2xF.HG[42] + 2xHG[42] + 1GE */
    static const int p2l_mapping_100[] = {
          0,
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
         37, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 42, 43, 44, 45, -1, -1, -1, -1,
         46, -1, -1, -1,
         47, -1, -1, -1, 48, 49, 50, 51, 52, 53, 54, 55,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_100[] = {
          0,
          1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
         13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
         25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
         37, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 42, 43, 44, 45, -1, -1, -1, -1,
         46, -1, -1, -1,
         47, -1, -1, -1, 48, -1, -1, -1, 52, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_100[] = {
         59,
          0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,
         12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
         24, 25, 26, 27, 28, 29, 30, 31, 36, 37, 38, 39,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 32, 33, 34, 35, -1, -1, -1, -1,
         48, -1, -1, -1,
         49, -1, -1, -1, 54, 46, 50, 47, 55, 52, 51, 53,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_100[] = {
         -1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 10, 10, 10, 10, -1, -1, -1, -1,
         42, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    static _soc_tr3_flex_port_inf_t flex_port_inf_100 = {
        1,
        { 18, 19, -1 },
        { _tr3_wc_flex_port_speeds_1, _tr3_wc_flex_port_speeds_1, NULL },
        { _tr3_wc_def_flex_port_speeds_1, _tr3_wc_def_flex_port_speeds_1, NULL },
        { _tr3_wc_flex_port_lanes_1, _tr3_wc_flex_port_lanes_1, NULL }
    };    
    /* 28xGE + 4xXFI + 2xF.HG[42] + 2xHG[42] + 1GE */
    static const int p2l_mapping_101[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  2,  3,  4,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
         37, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 42, 43, 44, 45, -1, -1, -1, -1,
         46, -1, -1, -1,
         47, -1, -1, -1, 48, 49, 50, 51, 52, 53, 54, 55,
         61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_101[] = {
          0,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  2,  3,  4,
          5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
         17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
         37, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 42, 43, 44, 45, -1, -1, -1, -1,
         46, -1, -1, -1,
         47, -1, -1, -1, 48, -1, -1, -1, 52, -1, -1, -1,
         61, 59, 58, 60, 62
    };
    static const int p2m_mapping_101[] = {
         59,
         -1, -1, -1, -1, -1, -1, -1, -1,  0,  1,  2,  3,
          4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
         16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
         60, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 32, 33, 34, 35, -1, -1, -1, -1,
         48, -1, -1, -1,
         49, -1, -1, -1, 54, 46, 50, 47, 55, 52, 51, 53,
         58, 62, 56, 61, 57
    };
    static const int port_speed_max_101[] = {
         -1,
         -1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
          1, -1, -1, -1,
         -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
         -1, -1, -1, -1, 10, 10, 10, 10, -1, -1, -1, -1,
         42, -1, -1, -1,
         42, -1, -1, -1, 42, -1, -1, -1, 42, -1, -1, -1,
         -1, -1, -1, -1, -1
    };
    /* TR3_1G_280_FX: 36xGE + 4xXFI + 2xHG[42] + 2xF.HG[42] + 1GE */
    static const int p2l_mapping_102[] = {
         0,
         1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
        13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
        37, -1, -1, -1,
         1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 42, 43, 44, 45, -1, -1, -1, -1,
        46, 47, 48, 49,
        50, 51, 52, 53, 54, -1, -1, -1, 55, -1, -1, -1,
        61, 59, 58, 60, 62
    };
    static const int flex_p2l_mapping_102[] = {
         0,
         1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,
        13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
        37, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 42, 43, 44, 45, -1, -1, -1, -1,
        46, -1, -1, -1,
        50, -1, -1, -1,  54, -1, -1, -1, 55, -1, -1, -1,
        61, 59, 58, 60, 62
    };
    static const int p2m_mapping_102[] = {
        59,
        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,
        12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
        24, 25, 26, 27, 28, 29, 30, 31, 36, 37, 38, 39,
        60, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 32, 33, 34, 35, -1, -1, -1, -1,
        48, 46, 50, 47,
        49, 52, 51, 53, 54, -1, -1, -1, 55, -1, -1, -1,
        58, 62, 56, 61, 57
    };
    static _soc_tr3_flex_port_inf_t flex_port_inf_102 = {
        1,
        { 16, 17, -1 },
        { _tr3_wc_flex_port_speeds_1, _tr3_wc_flex_port_speeds_1, NULL },
        { _tr3_wc_def_flex_port_speeds_1, _tr3_wc_def_flex_port_speeds_1, NULL },
        { _tr3_wc_flex_port_lanes_1, _tr3_wc_flex_port_lanes_1, NULL }
    };

    soc_info_t *si;
    int rv = SOC_E_NONE;
    int phy_port;
    soc_pbmp_t pbmp_xport_xe;
    soc_pbmp_t pbmp_xport_ge;
    const int *p2l_mapping, *p2l_flex_mapping = NULL, *p2m_mapping, *speed_max;
    int flex_p2l_mapping[SOC_MAX_PHY_PORTS] = {-1}, 
        flex_speed_max[SOC_MAX_PHY_PORTS] = {0};
    
    sal_memset(&_tr3_flex_port_inf[unit], 0, sizeof(_soc_tr3_flex_port_inf_t));
    _soc_tr3_resolve_port_config(unit, dev_id);
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "Port config id: %d\n"), _tr3_port_config_id[unit]));

    switch (_tr3_port_config_id[unit]) {
    case 10:
        p2l_mapping = p2l_mapping_10;
        p2m_mapping = p2m_mapping_10;
        speed_max = port_speed_max_10;
        break;
    case 110:
        p2l_mapping = p2l_mapping_110;
        p2m_mapping = p2m_mapping_110;
        speed_max = port_speed_max_110;
        break;
    case 11:
        p2l_mapping = p2l_mapping_11;
        p2m_mapping = p2m_mapping_11;
        speed_max = port_speed_max_11;
        break;
    case 12:
        p2l_mapping = p2l_mapping_12;
        p2m_mapping = p2m_mapping_12;
        speed_max = port_speed_max_12;
        break;
    case 112:
        p2l_mapping = p2l_mapping_112;
        p2m_mapping = p2m_mapping_112;
        speed_max = port_speed_max_112;
        break;
    case 35:
        p2l_mapping = p2l_mapping_35;
        p2m_mapping = p2m_mapping_35;
        speed_max = port_speed_max_35;
        break;
    case 36:
        p2l_mapping = p2l_mapping_36;
        p2m_mapping = p2m_mapping_36;
        speed_max = port_speed_max_36;
        break;
    case 37:
        p2l_mapping = p2l_mapping_37;
        p2m_mapping = p2m_mapping_37;
        speed_max = port_speed_max_37;
        p2l_flex_mapping = flex_p2l_mapping_37;
        _tr3_flex_port_inf[unit] = flex_port_inf_37;
        break;
    case 38:
        p2l_mapping = p2l_mapping_38;
        p2m_mapping = p2m_mapping_38;
        speed_max = port_speed_max_38;
        p2l_flex_mapping = flex_p2l_mapping_38;
        _tr3_flex_port_inf[unit] = flex_port_inf_38;
        break;
    case 40:
        p2l_mapping = p2l_mapping_40;
        p2m_mapping = p2m_mapping_40;
        speed_max = port_speed_max_40;
        p2l_flex_mapping = flex_p2l_mapping_40;
        _tr3_flex_port_inf[unit] = flex_port_inf_40;
        break;
    case 41:
        p2l_mapping = p2l_mapping_41;
        p2m_mapping = p2m_mapping_41;
        speed_max = port_speed_max_41;
        break;
    case 50:
        p2l_mapping = p2l_mapping_50;
        p2m_mapping = p2m_mapping_50;
        speed_max = port_speed_max_50;
        break;
    case 55:
        p2l_mapping = p2l_mapping_55;
        p2m_mapping = p2m_mapping_55;
        speed_max = port_speed_max_55;
        p2l_flex_mapping = flex_p2l_mapping_55;
        _tr3_flex_port_inf[unit] = flex_port_inf_55;
        break;
    case 155:
        p2l_mapping = p2l_mapping_155;
        p2m_mapping = p2m_mapping_155;
        speed_max = port_speed_max_155;
        p2l_flex_mapping = flex_p2l_mapping_155;
        _tr3_flex_port_inf[unit] = flex_port_inf_155;
        break;
    case 71:
        p2l_mapping = p2l_mapping_71;
        p2m_mapping = p2m_mapping_71;
        speed_max = port_speed_max_71;
        p2l_flex_mapping = flex_p2l_mapping_71;
        _tr3_flex_port_inf[unit] = flex_port_inf_71;
        break;
    case 72:
        p2l_mapping = p2l_mapping_72;
        p2m_mapping = p2m_mapping_72;
        speed_max = port_speed_max_72;
        p2l_flex_mapping = flex_p2l_mapping_72;
        _tr3_flex_port_inf[unit] = flex_port_inf_72;
        break;
    case 171:
        p2l_mapping = p2l_mapping_171;
        p2m_mapping = p2m_mapping_171;
        speed_max = port_speed_max_171;
        p2l_flex_mapping = flex_p2l_mapping_171;
        _tr3_flex_port_inf[unit] = flex_port_inf_171;
        break;
    case 172:
        p2l_mapping = p2l_mapping_172;
        p2m_mapping = p2m_mapping_172;
        speed_max = port_speed_max_172;
        p2l_flex_mapping = flex_p2l_mapping_172;
        _tr3_flex_port_inf[unit] = flex_port_inf_172;
        break;
    case 81:
        p2l_mapping = p2l_mapping_81;
        p2m_mapping = p2m_mapping_81;
        speed_max = port_speed_max_81;
        break;
    case 82:
        p2l_mapping = p2l_mapping_82;
        p2m_mapping = p2m_mapping_82;
        speed_max = port_speed_max_82;
        p2l_flex_mapping = flex_p2l_mapping_82;
        _tr3_flex_port_inf[unit] = flex_port_inf_37;
        break;
    case 83:
        p2l_mapping = p2l_mapping_83;
        p2m_mapping = p2m_mapping_83;
        speed_max = port_speed_max_83;
        p2l_flex_mapping = flex_p2l_mapping_83;
        _tr3_flex_port_inf[unit] = flex_port_inf_37;
        break;
    case 90:
        p2l_mapping = p2l_mapping_90;
        p2m_mapping = p2m_mapping_90;
        speed_max = port_speed_max_90;
        break;
    case 190:
        p2l_mapping = p2l_mapping_190;
        p2m_mapping = p2m_mapping_190;
        speed_max = port_speed_max_190;
        break;
    case 91:
        p2l_mapping = p2l_mapping_91;
        p2m_mapping = p2m_mapping_91;
        speed_max = port_speed_max_91;
        p2l_flex_mapping = flex_p2l_mapping_91;
        _tr3_flex_port_inf[unit] = flex_port_inf_91;
        break;
    case 94:
        p2l_mapping = p2l_mapping_94;
        p2m_mapping = p2m_mapping_94;
        speed_max = port_speed_max_94;
        break;
    case 95:
        p2l_mapping = p2l_mapping_95;
        p2m_mapping = p2m_mapping_95;
        speed_max = port_speed_max_95;
        break;
    case 195:
        p2l_mapping = p2l_mapping_195;
        p2m_mapping = p2m_mapping_195;
        speed_max = port_speed_max_195;
        break;
    case 295:
        p2l_mapping = p2l_mapping_295;
        p2m_mapping = p2m_mapping_295;
        speed_max = port_speed_max_295;
        break;
    case 395:
        p2l_mapping = p2l_mapping_395;
        p2m_mapping = p2m_mapping_395;
        speed_max = port_speed_max_395;
        break;
    case 495:
        p2l_mapping = p2l_mapping_495;
        p2m_mapping = p2m_mapping_495;
        speed_max = port_speed_max_495;
        break;
    case 96:
        p2l_mapping = p2l_mapping_96;
        p2m_mapping = p2m_mapping_96;
        speed_max = port_speed_max_96;
        break;    
    case 196:
        p2l_mapping = p2l_mapping_196;
        p2m_mapping = p2m_mapping_196;
        speed_max = port_speed_max_196;
        break;
    case 97:
        p2l_mapping = p2l_mapping_97;
        p2m_mapping = p2m_mapping_97;
        speed_max = port_speed_max_97;
        p2l_flex_mapping = flex_p2l_mapping_97;
        _tr3_flex_port_inf[unit] = flex_port_inf_91;
        break;
    case 98:
        p2l_mapping = p2l_mapping_98;
        p2m_mapping = p2m_mapping_98;
        speed_max = port_speed_max_98;
        p2l_flex_mapping = flex_p2l_mapping_98;
        _tr3_flex_port_inf[unit] = flex_port_inf_91;
        break;
    case 99:
        p2l_mapping = p2l_mapping_99;
        p2m_mapping = p2m_mapping_99;
        speed_max = port_speed_max_99;
        break;
    case 100:
        p2l_mapping = p2l_mapping_100;
        p2m_mapping = p2m_mapping_100;
        speed_max = port_speed_max_100;
        p2l_flex_mapping = flex_p2l_mapping_100;
        _tr3_flex_port_inf[unit] = flex_port_inf_100;
        break;
    case 101:
        p2l_mapping = p2l_mapping_101;
        p2m_mapping = p2m_mapping_101;
        speed_max = port_speed_max_101;
        p2l_flex_mapping = flex_p2l_mapping_101;
        _tr3_flex_port_inf[unit] = flex_port_inf_100;
        break;
    case 102:
        p2l_mapping = p2l_mapping_102;
        p2m_mapping = p2m_mapping_102;
        speed_max = port_speed_max_100;
        p2l_flex_mapping = flex_p2l_mapping_102;
        _tr3_flex_port_inf[unit] = flex_port_inf_102;
        break;
    default:
        return SOC_E_PARAM;
    }

    /* Handle any init time flex port configs */
    if (_tr3_flex_port_inf[unit].valid) {
        uint8 idx, i, j, port_groups = 0;
        char *config_str, *sub_str, *sub_str_end;
        int num_lanes, port_bw;
        
        if (p2l_flex_mapping) {
            sal_memcpy(flex_p2l_mapping, p2l_flex_mapping, 
                       sizeof(int) * SOC_MAX_PHY_PORTS);
        }
        sal_memcpy(flex_speed_max, speed_max, sizeof(int) * SOC_MAX_PHY_PORTS);
        for (i = 0; ; i++) {
            if (_tr3_flex_port_inf[unit].flex_port_groups[i] == -1) {
                break;
            }
        }
        port_groups = i;
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "Flex port groups: %d\n"), port_groups));
        _tr3_flex_port_data[unit].port_groups = port_groups;
        for (i = 0; i < port_groups; i++) {
            config_str = soc_property_port_get_str(unit, i, spn_PORTGROUP);
            if (config_str == NULL) {
                continue;
            }
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "Flex group cfg: %d=%s\n"), i, config_str));
            /*
             * portgroup_<port group>=<num of lanes>
             */
            sub_str = config_str;
            num_lanes = sal_ctoi(sub_str, &sub_str_end);
            if (sub_str == sub_str_end) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Port group %d: Missing number of lanes information \"%s\"\n"),
                                      i, config_str));
                rv = SOC_E_FAIL;
                continue;
            }
            if (num_lanes == 0) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Port group %d: Missing number of lanes information \"%s\"\n"),
                                      i, config_str));
                rv = SOC_E_FAIL;
                continue;
            }
            SOC_PBMP_CLEAR(pbmp_xport_xe);
            SOC_PBMP_CLEAR(pbmp_xport_ge);
            idx = _tr3_flex_port_inf[unit].flex_port_groups[i]*4 + 1;
            switch (num_lanes) {
            case 1:
                _tr3_flex_port_data[unit].ports[i] = 4;
                /* Determine bandwidth */
                port_bw = _tr3_flex_port_inf[unit].def_flex_port_speeds[i][2];
                /* Check for properties */
                pbmp_xport_ge = soc_property_get_pbmp_default(unit, spn_PBMP_XPORT_GE,
                                                              pbmp_xport_ge);
                /* Force 10 -> 1 */
                if (SOC_PBMP_MEMBER(pbmp_xport_ge, p2l_mapping[idx])) {
                    if (port_bw == 10) {
                        for (j = 0; _tr3_flex_port_inf[unit].flex_port_speeds[i][j] != -1;j++) {
                            if (_tr3_flex_port_inf[unit].flex_port_speeds[i][j] == 1 && 
                                _tr3_flex_port_inf[unit].flex_port_lanes[i][j] == num_lanes) {
                                port_bw = 1;
                                break;
                            }
                        }
                    }
                }
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                                        "Flex group: %d, lanes: %d, ports: %d, speed: %d gbps\n"), i, 
                                        num_lanes, _tr3_flex_port_data[unit].ports[i], port_bw));
                flex_p2l_mapping[idx+1] = flex_p2l_mapping[idx]+1;
                flex_p2l_mapping[idx+2] = flex_p2l_mapping[idx]+2;
                flex_p2l_mapping[idx+3] = flex_p2l_mapping[idx]+3;
                flex_speed_max[idx] = port_bw;
                flex_speed_max[idx+1] = port_bw;
                flex_speed_max[idx+2] = port_bw;
                flex_speed_max[idx+3] = port_bw;
                break;
            case 2:
                _tr3_flex_port_data[unit].ports[i] = 2;
                /* Determine bandwidth */
                port_bw = _tr3_flex_port_inf[unit].def_flex_port_speeds[i][1];
                /* Check for properties */
                pbmp_xport_xe = soc_property_get_pbmp_default(unit, spn_PBMP_XPORT_XE,
                                                              pbmp_xport_xe);
                /* Force 21 -> 10 */
                if (SOC_PBMP_MEMBER(pbmp_xport_xe, flex_p2l_mapping[idx])) {
                    if (port_bw == 21) {
                        for (j = 0; _tr3_flex_port_inf[unit].flex_port_speeds[i][j] != -1;j++) {
                            if (_tr3_flex_port_inf[unit].flex_port_speeds[i][j] == 10 && 
                                _tr3_flex_port_inf[unit].flex_port_lanes[i][j] == num_lanes) {
                                port_bw = 10;
                                break;
                            }
                        }
                    }
                }
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                                        "Flex group: %d, lanes: %d, ports: %d, speed: %d gbps\n"), i, 
                                        num_lanes, _tr3_flex_port_data[unit].ports[i], port_bw));
                flex_p2l_mapping[idx+1] = -1;
                flex_p2l_mapping[idx+2] = flex_p2l_mapping[idx]+2;
                flex_p2l_mapping[idx+3] = -1;
                flex_speed_max[idx] = port_bw;
                flex_speed_max[idx+1] = -1;
                flex_speed_max[idx+2] = port_bw;
                flex_speed_max[idx+3] = -1;
                break;
            case 4:
                _tr3_flex_port_data[unit].ports[i] = 1;
                /* Determine bandwidth */
                port_bw = _tr3_flex_port_inf[unit].def_flex_port_speeds[i][0];
                /* Check for properties */
                pbmp_xport_xe = soc_property_get_pbmp_default(unit, spn_PBMP_XPORT_XE,
                                                              pbmp_xport_xe);
                /* Force 21 -> 10 */
                if (SOC_PBMP_MEMBER(pbmp_xport_xe, flex_p2l_mapping[idx])) {
                    if (port_bw == 21) {
                        for (j = 0; _tr3_flex_port_inf[unit].flex_port_speeds[i][j] != -1;j++) {
                            if (_tr3_flex_port_inf[unit].flex_port_speeds[i][j] == 10 && 
                                _tr3_flex_port_inf[unit].flex_port_lanes[i][j] == num_lanes) {
                                port_bw = 10;
                                break;
                            }
                        }
                    }
                }
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                                        "Flex group: %d, lanes: %d, ports: %d, speed: %d gbps\n"), i, 
                                        num_lanes, _tr3_flex_port_data[unit].ports[i], port_bw));
                flex_p2l_mapping[idx+1] = -1;
                flex_p2l_mapping[idx+2] = -1;
                flex_p2l_mapping[idx+3] = -1;
                flex_speed_max[idx] = port_bw;
                flex_speed_max[idx+1] = -1;
                flex_speed_max[idx+2] = -1;
                flex_speed_max[idx+3] = -1;
                break;
            default: break;
            }
        }
    }

    si = &SOC_INFO(unit);
    if ((_tr3_port_config_id[unit] >= 10 && _tr3_port_config_id[unit] <= 14) ||
        (_tr3_port_config_id[unit] >= 20 && _tr3_port_config_id[unit] <= 23) ||
        (_tr3_port_config_id[unit] >= 40 && _tr3_port_config_id[unit] <= 41) ||
        (_tr3_port_config_id[unit] >= 60 && _tr3_port_config_id[unit] <= 61)) {
        si->bandwidth = 200000;
    } else if ((_tr3_port_config_id[unit] >= 30 && _tr3_port_config_id[unit] <= 35) ||
               (_tr3_port_config_id[unit] == 50) || (_tr3_port_config_id[unit] == 62)) {
        si->bandwidth = 260000;
    }
    for (phy_port = 0; phy_port < SOC_MAX_PHY_PORTS; phy_port++) {
        si->port_p2l_mapping[phy_port] = p2l_mapping[phy_port];
        si->flex_port_p2l_mapping[phy_port] = _tr3_flex_port_inf[unit].valid ? flex_p2l_mapping[phy_port] : 
                                                  p2l_mapping[phy_port]; /* for disabling unavailable ports */
        si->port_p2m_mapping[phy_port] = p2m_mapping[phy_port];
        _soc_tr3_port_speed_max[phy_port] = 0;
        if (_tr3_flex_port_inf[unit].valid) {
            if (flex_speed_max[phy_port] != -1) {
                si->port_speed_max[si->port_p2l_mapping[phy_port]] =
                    flex_speed_max[phy_port] * 1000;
                _soc_tr3_port_speed_max[phy_port] = flex_speed_max[phy_port] * 1000;
            }
        } else {
            if (speed_max[phy_port] != -1) {
                si->port_speed_max[si->port_p2l_mapping[phy_port]] = 
                    speed_max[phy_port] * 1000;
                _soc_tr3_port_speed_max[phy_port] = speed_max[phy_port] * 1000;
            }
        }
    }
    return rv;
}

int
soc_tr3_port_is_flex_port(int unit, soc_port_t port)
{
    uint8 i, port_groups = 0;
    uint16 idx;
    int p;
    soc_info_t *si = &SOC_INFO(unit);

    if (!_tr3_flex_port_inf[unit].valid) {
        return FALSE;
    }
    if (IS_CL_PORT(unit, port) && (IS_CE_PORT(unit, port) || 
        si->port_speed_max[port] >= 100000)) {
        return FALSE;
    }
    for (i = 0; ; i++) {
        if (_tr3_flex_port_inf[unit].flex_port_groups[i] == -1) {
            break;
        }
    }
    port_groups = i;
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "Flex port groups: %d\n"), port_groups));
    for (i = 0; i < port_groups; i++) {
        idx = _tr3_flex_port_inf[unit].flex_port_groups[i]*4 + 1;
        p = si->port_p2l_mapping[idx];
        /* Only the first port in a group is the controlling/deciding port */
        if (port == p) {
            return TRUE;
        } 
     }
    return FALSE;
}

/* Map of block to first physical port in the block */
int _soc_tr3_b2pp[SOC_MAX_NUM_BLKS];

/*
 * TR3 port mapping
 */
int
soc_tr3_port_config_init(int unit, uint16 dev_id)
{
    int b, p;
    for (b=0; SOC_BLOCK_TYPE(unit, b) != -1; b++) {
        _soc_tr3_b2pp[b] = -1;
        for (p=0; SOC_PORT_BLOCK(unit, p)!= -1; p++) {
            if (b == SOC_PORT_BLOCK(unit, p)) {
                _soc_tr3_b2pp[b] = p;
                break;
            }
        }
    }
    SOC_INFO(unit).blk_fpp = _soc_tr3_b2pp;
#ifdef BCM_HELIX4_SUPPORT
    if (SOC_IS_HELIX4(unit)) {
        return soc_hx4_get_port_mapping(unit, dev_id);
    } else
#endif /* BCM_HELIX4_SUPPORT */
    {
        return soc_triumph3_get_port_mapping(unit, dev_id);
    }
}

#ifdef BCM_ISM_SUPPORT
/* Default mem config size */
static soc_ism_mem_size_config_t _ism_alloc_size[_ISM_MAX_MEMS] = {
    { SOC_ISM_MEM_VLAN_XLATE, _ISM_MEM_VLAN_XLATE_SIZE },
    { SOC_ISM_MEM_L2_ENTRY, _ISM_MEM_L2_SIZE },
    { SOC_ISM_MEM_L3_ENTRY, _ISM_MEM_L3_SIZE },
    { SOC_ISM_MEM_EP_VLAN_XLATE, _ISM_MEM_EP_VLAN_XLATE_SIZE },
    { SOC_ISM_MEM_MPLS, _ISM_MEM_MPLS_SIZE },
    { SOC_ISM_MEM_ESM_L2, 0 },
    { SOC_ISM_MEM_ESM_L3, 0 },
    { SOC_ISM_MEM_ESM_ACL, 0 }
};
#endif

/* Return the TR3 devid core clock speed in MHz */
int
soc_tr3_core_clock_speed(int unit)
{
    uint16      dev_id;
    uint8       rev_id;
    
    soc_cm_get_id(unit, &dev_id, &rev_id);

    switch (dev_id) {
    case BCM56643_DEVICE_ID:
        return SOC_TR3_CORE_CLOCK_450;
    case BCM56640_DEVICE_ID:
    case BCM56644_DEVICE_ID:
    case BCM56648_DEVICE_ID:
    case BCM56649_DEVICE_ID:
        return SOC_TR3_CORE_CLOCK_415;
    case BCM56540_DEVICE_ID:
    case BCM56541_DEVICE_ID: 
    case BCM56542_DEVICE_ID:
    case BCM56543_DEVICE_ID:
    case BCM56544_DEVICE_ID:
    case BCM56545_DEVICE_ID:
    case BCM56546_DEVICE_ID:
        return SOC_TR3_CORE_CLOCK_315;
    default: 
        return SOC_TR3_CORE_CLOCK_UNKNOWN;
    }
}

int
soc_tr3_mem_config(int unit, int dev_id, int rev_id)
{
    int rv = SOC_E_NONE;
    uint16 scale = 1;
    int num_ipv6_128b_entries = 0;
    int config_v6_entries = 0;   
    int defip_config = 0;
    
    soc_persist_t *sop = SOC_PERSIST(unit);
    
    switch (dev_id) {
    case BCM56540_DEVICE_ID:
    case BCM56541_DEVICE_ID:
    case BCM56542_DEVICE_ID:
    case BCM56543_DEVICE_ID:
    case BCM56544_DEVICE_ID:
    case BCM56545_DEVICE_ID:
    case BCM56546_DEVICE_ID:
        /* ISM Raw and ESM */
        sop->memState[EXT_L2_ENTRY_1m].index_max = -1;
        sop->memState[EXT_L2_ENTRY_2m].index_max = -1;
        /* L3 Next hop */
        sop->memState[INITIAL_ING_L3_NEXT_HOPm].index_max = 32767;
        sop->memState[ING_L3_NEXT_HOPm].index_max = 32767;
        sop->memState[EGR_L3_NEXT_HOPm].index_max = 32767;
        sop->memState[INITIAL_PROT_NHI_TABLEm].index_max = 32767;
        sop->memState[ING_L3_NEXT_HOP_ATTRIBUTE_1_INDEXm].index_max = 24575;
        /* L3 LPM */
        SOC_CONTROL(unit)->l3_defip_max_tcams = _SOC_AP2_DEFIP_MAX_TCAMS;
        SOC_CONTROL(unit)->l3_defip_tcam_size = _SOC_AP2_DEFIP_TCAM_DEPTH;
        sop->memState[L3_DEFIPm].index_max = 6143;
        sop->memState[L3_DEFIP_ONLYm].index_max = 6143;
        sop->memState[L3_DEFIP_DATA_ONLYm].index_max = 6143;
        sop->memState[L3_DEFIP_HIT_ONLYm].index_max = 6143;
        /* L3 IPMC groups */
        sop->memState[L3_IPMCm].index_max = 8191;
        sop->memState[L3_IPMC_1m].index_max = 8191;
        sop->memState[L3_IPMC_REMAPm].index_max = 8191;
        sop->memState[EGR_IPMCm].index_max = 8191;
        sop->memState[MMU_REPL_GROUPm].index_max = 8191;
        /* L2 VFI */
        sop->memState[VFIm].index_max = 4095;
        sop->memState[VFI_1m].index_max = 4095;
        sop->memState[EGR_VFIm].index_max = 4095;
        /* L3 Tunnels */
        sop->memState[EGR_IP_TUNNELm].index_max = 1023;
        sop->memState[EGR_IP_TUNNEL_IPV6m].index_max = 511;
        sop->memState[EGR_IP_TUNNEL_MPLSm].index_max = 1023;
        sop->memState[EGR_FRAGMENT_ID_TABLEm].index_max = 1023;
        /* Virtual ports */
        sop->memState[SOURCE_VP_ATTRIBUTES_2m].index_max = 16383;
        sop->memState[SOURCE_VPm].index_max = 16383;
        sop->memState[ING_DVP_TABLEm].index_max = 16383;
        sop->memState[ING_DVP_2_TABLEm].index_max = 16383;
        sop->memState[EGR_DVP_ATTRIBUTEm].index_max = 16383;
        sop->memState[EGR_DVP_ATTRIBUTE_1m].index_max = 16383;
        /* Counters */
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_0m].index_max = 2047;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_1m].index_max = 2047;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_2m].index_max = 2047;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_3m].index_max = 2047;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_4m].index_max = 2047;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_5m].index_max = 2047;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_6m].index_max = 2047;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_7m].index_max = 2047;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_8m].index_max = -1;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_9m].index_max = -1;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_10m].index_max = -1;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_11m].index_max = -1;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_12m].index_max = -1;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_13m].index_max = -1;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_14m].index_max = -1;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_15m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_8m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_9m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_10m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_11m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_12m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_13m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_14m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_15m].index_max = -1;
        sop->memState[VLAN_OR_VFI_MAC_COUNTm].index_max = 8191;
        sop->memState[VLAN_OR_VFI_MAC_LIMITm].index_max = 8191;
        sop->memState[OAM_LM_COUNTERSm].index_max = 8191;
        /* LMEP */
        sop->memState[LMEPm].index_max = 1023;
        sop->memState[LMEP_DAm].index_max = 1023;
        /* RMEP */
        sop->memState[RMEPm].index_max = 4095;
        sop->memState[MAID_REDUCTIONm].index_max = 1023;
        sop->memState[MA_STATEm].index_max = 1023;
        sop->memState[ESM_ACL_ACTION_CONTROLm].index_max = -1;
        sop->memState[ESM_ACL_PROFILEm].index_max = -1;
        /* Others */
        sop->memState[L3_IIFm].index_max = 8191;
        sop->memState[VLAN_PROFILE_TABm].index_max = 63;
        sop->memState[VLAN_PROFILE_2m].index_max = 63;
        /* L3_DEFIP sizing */
        if (soc_property_get(unit, "l3_defip_sizing", TRUE)) {
            defip_config = soc_property_get(unit, spn_IPV6_LPM_128B_ENABLE, 1);

            num_ipv6_128b_entries = soc_property_get(unit,
                                        spn_NUM_IPV6_LPM_128B_ENTRIES,
                                        (defip_config ? 2048 : 0));
            num_ipv6_128b_entries = num_ipv6_128b_entries +
                                    (num_ipv6_128b_entries % 2);
            config_v6_entries = num_ipv6_128b_entries;
            if (soc_property_get(unit, spn_LPM_SCALING_ENABLE, 0)) {
                num_ipv6_128b_entries = 0;
                if (!soc_property_get(unit, spn_LPM_IPV6_128B_RESERVED, 1)) {
                    config_v6_entries = ((config_v6_entries /
                                        SOC_CONTROL(unit)->l3_defip_tcam_size) +
                                        ((config_v6_entries %
                                         SOC_CONTROL(unit)->l3_defip_tcam_size)
                                        ? 1 : 0)) * SOC_CONTROL(unit)->l3_defip_tcam_size;
                }

            }

            sop->memState[L3_DEFIP_PAIR_128m].index_max =
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_ONLYm].index_max =
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_DATA_ONLYm].index_max =
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_HIT_ONLYm].index_max =
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIPm].index_max =
                                     (SOC_CONTROL(unit)->l3_defip_max_tcams *
                                     SOC_CONTROL(unit)->l3_defip_tcam_size) -
                                     (num_ipv6_128b_entries * 2) - 1;
            sop->memState[L3_DEFIP_ONLYm].index_max =
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_DATA_ONLYm].index_max =
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_HIT_ONLYm].index_max =
                                          sop->memState[L3_DEFIPm].index_max;
            SOC_CONTROL(unit)->l3_defip_index_remap = num_ipv6_128b_entries;
            soc_l3_defip_indexes_init(unit, config_v6_entries);
        }
        break;
  
    case BCM56044_DEVICE_ID:
    case BCM56045_DEVICE_ID:
    case BCM56046_DEVICE_ID:
        /* ISM Raw and ESM */
        sop->memState[EXT_L2_ENTRY_1m].index_max = -1;
        sop->memState[EXT_L2_ENTRY_2m].index_max = -1;
        /* L3 Next hop */
        sop->memState[INITIAL_ING_L3_NEXT_HOPm].index_max = 1023;
        sop->memState[ING_L3_NEXT_HOPm].index_max = 1023;
        sop->memState[EGR_L3_NEXT_HOPm].index_max = 1023;
        sop->memState[INITIAL_PROT_NHI_TABLEm].index_max = 1023;
        
        sop->memState[ING_L3_NEXT_HOP_ATTRIBUTE_1_INDEXm].index_max = 24575;
        /* L3 LPM */
        sop->memState[L3_DEFIPm].index_max = 128;
        sop->memState[L3_DEFIP_ONLYm].index_max = 128;
        sop->memState[L3_DEFIP_DATA_ONLYm].index_max = 128;
        sop->memState[L3_DEFIP_HIT_ONLYm].index_max = 128;
        /* L3 IPMC */
        sop->memState[L3_IPMCm].index_max = 256;
        sop->memState[L3_IPMC_1m].index_max = 256;
        sop->memState[L3_IPMC_REMAPm].index_max = 256;
        sop->memState[MMU_REPL_GROUPm].index_max = 256;
        sop->memState[ING_UNTAGGED_PHBm].index_max = 62; 
        sop->memState[EGR_IPMCm].index_max = 256;
        sop->memState[EGR_L3_INTFm].index_max = 512;
        
        /* Counters */
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_0m].index_max = 255;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_1m].index_max = 255;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_2m].index_max = 255;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_3m].index_max = 255;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_4m].index_max = 255;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_5m].index_max = 255;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_6m].index_max = 255;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_7m].index_max = 255;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_8m].index_max = -1;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_9m].index_max = -1;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_10m].index_max = -1;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_11m].index_max = -1;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_12m].index_max = -1;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_13m].index_max = -1;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_14m].index_max = -1;
        sop->memState[ING_FLEX_CTR_COUNTER_TABLE_15m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_8m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_9m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_10m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_11m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_12m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_13m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_14m].index_max = -1;
        sop->memState[ING_FLEX_CTR_OFFSET_TABLE_15m].index_max = -1;
        sop->memState[VLAN_OR_VFI_MAC_COUNTm].index_max = 8191;
        sop->memState[VLAN_OR_VFI_MAC_LIMITm].index_max = 8191;
        sop->memState[OAM_LM_COUNTERSm].index_max = 8191;
        sop->memState[EGR_FLEX_CTR_COUNTER_TABLE_0m].index_max = 63;
        sop->memState[EGR_FLEX_CTR_COUNTER_TABLE_1m].index_max = 63;
        sop->memState[EGR_FLEX_CTR_COUNTER_TABLE_2m].index_max = 63;
        sop->memState[EGR_FLEX_CTR_COUNTER_TABLE_3m].index_max = 63;
        sop->memState[EGR_FLEX_CTR_COUNTER_TABLE_4m].index_max = 63;
        sop->memState[EGR_FLEX_CTR_COUNTER_TABLE_5m].index_max = 63;
        sop->memState[EGR_FLEX_CTR_COUNTER_TABLE_6m].index_max = 63;
        sop->memState[EGR_FLEX_CTR_COUNTER_TABLE_7m].index_max = 63;

        /* LMEP */
        sop->memState[LMEPm].index_max = -1;
        sop->memState[LMEP_DAm].index_max = -1;
        /* RMEP */
        sop->memState[RMEPm].index_max = -1;
        sop->memState[MAID_REDUCTIONm].index_max = -1;
        sop->memState[MA_STATEm].index_max = -1;
        sop->memState[ESM_ACL_ACTION_CONTROLm].index_max = -1;
        sop->memState[ESM_ACL_PROFILEm].index_max = -1;
        /* L3_DEFIP sizing */
        if (soc_property_get(unit, "l3_defip_sizing", TRUE)) {
            if (soc_property_get(unit, spn_IPV6_LPM_128B_ENABLE, 1)) {
                sop->memState[L3_DEFIP_PAIR_128m].index_max = 128;
                sop->memState[L3_DEFIP_PAIR_128_ONLYm].index_max = 128;
                sop->memState[L3_DEFIP_PAIR_128_DATA_ONLYm].index_max = 128;
                sop->memState[L3_DEFIP_PAIR_128_HIT_ONLYm].index_max = 128;
                sop->memState[L3_DEFIPm].index_max = 128;
                sop->memState[L3_DEFIP_ONLYm].index_max = 128;
                sop->memState[L3_DEFIP_DATA_ONLYm].index_max = 128;
                sop->memState[L3_DEFIP_HIT_ONLYm].index_max = 128;
                SOC_CONTROL(unit)->l3_defip_index_remap = 128;
            } else {
                sop->memState[L3_DEFIP_PAIR_128m].index_max = -1;
                sop->memState[L3_DEFIP_PAIR_128_ONLYm].index_max = -1;
                sop->memState[L3_DEFIP_PAIR_128_DATA_ONLYm].index_max = -1;
                sop->memState[L3_DEFIP_PAIR_128_HIT_ONLYm].index_max = -1;
            }
        }
        /* These memories are not present in Ranger+ */
        sop->memState[AXP_SM_CHAR_REMAP0m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP1m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP2m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP3m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP4m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP5m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP6m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP7m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP8m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP9m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP10m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP11m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP12m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP13m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP14m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP15m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP16m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP17m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP18m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP19m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP20m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP21m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP22m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP23m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP24m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP25m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP26m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP27m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP28m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP29m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP30m].index_max = -1;
        sop->memState[AXP_SM_CHAR_REMAP31m].index_max = -1;
        sop->memState[AXP_SM_FLOW_TABLE_BULK_MATCH_DATAm].index_max = -1;
        sop->memState[AXP_SM_FLOW_TABLE_BULK_MATCH_MASKm].index_max = -1;
        sop->memState[AXP_SM_FLOW_TABLE_BULK_REPLACE_DATAm].index_max = -1;
        sop->memState[AXP_SM_FLOW_TABLE_BULK_REPLACE_MASKm].index_max = -1;
        sop->memState[AXP_SM_FLOW_TABLE_MEMm].index_max = -1;
        sop->memState[AXP_SM_MATCH_COUNTERS_MEM0m].index_max = -1;
        sop->memState[AXP_SM_MATCH_COUNTERS_MEM1m].index_max = -1;
        sop->memState[AXP_SM_MATCH_COUNTERS_MEM2m].index_max = -1;
        sop->memState[AXP_SM_MATCH_COUNTERS_MEM3m].index_max = -1;
        sop->memState[AXP_SM_MATCH_TABLE_BULK_MATCH_DATAm].index_max = -1;
        sop->memState[AXP_SM_MATCH_TABLE_BULK_MATCH_MASKm].index_max = -1;
        sop->memState[AXP_SM_MATCH_TABLE_BULK_REPLACE_DATAm].index_max = -1;
        sop->memState[AXP_SM_MATCH_TABLE_BULK_REPLACE_MASKm].index_max = -1;
        sop->memState[AXP_SM_MATCH_TABLE_MEM0m].index_max = -1;
        sop->memState[AXP_SM_MATCH_TABLE_MEM1m].index_max = -1;
        sop->memState[AXP_SM_MATCH_TABLE_MEM2m].index_max = -1;
        sop->memState[AXP_SM_MATCH_TABLE_MEM3m].index_max = -1;
        sop->memState[AXP_SM_PACKET_BUFFER_MEMm].index_max = -1;
        sop->memState[AXP_SM_STATE_TABLE_BULK_MATCH_DATAm].index_max = -1;
        sop->memState[AXP_SM_STATE_TABLE_BULK_MATCH_MASKm].index_max = -1;
        sop->memState[AXP_SM_STATE_TABLE_BULK_REPLACE_DATAm].index_max = -1;
        sop->memState[AXP_SM_STATE_TABLE_BULK_REPLACE_MASKm].index_max = -1;
        sop->memState[AXP_SM_STATE_TABLE_MEM0m].index_max = -1;
        sop->memState[AXP_SM_STATE_TABLE_MEM1m].index_max = -1;
        sop->memState[AXP_SM_STATE_TABLE_MEM2m].index_max = -1;
        sop->memState[AXP_SM_STATE_TABLE_MEM3m].index_max = -1;
        sop->memState[AXP_SM_STATE_TABLE_MEM4m].index_max = -1;
        sop->memState[AXP_SM_STATE_TABLE_MEM5m].index_max = -1;
        sop->memState[AXP_SM_STATE_TABLE_MEM6m].index_max = -1;
        sop->memState[AXP_SM_STATE_TABLE_MEM7m].index_max = -1;

        sop->memState[AXP_WLAN_COS_MAPm].index_max = -1;
        sop->memState[AXP_WRX_SVP_ASSIGNMENTm].index_max = -1;
        sop->memState[AXP_WRX_WCDm].index_max = -1;
        sop->memState[AXP_WRX_SVP_ASSIGNMENTm].index_max = -1;
        sop->memState[AXP_WRX_WCDm].index_max = -1;
        sop->memState[AXP_WTX_DSCP_MAPm].index_max = -1;
        sop->memState[AXP_WTX_DVP_PROFILEm].index_max = -1;
        sop->memState[AXP_WTX_FRAG_IDm].index_max = -1;
        sop->memState[AXP_WTX_PRI_MAPm].index_max = -1;
        sop->memState[AXP_WTX_TRUNK_BLOCK_MASKm].index_max = -1;
        sop->memState[AXP_WTX_TRUNK_GROUP_BITMAPm].index_max = -1;
        sop->memState[AXP_WTX_TUNNELm].index_max = -1;
        sop->memState[VRFm].index_max = -1;
        sop->memState[SVM_METER_TABLEm].index_max = -1;
        sop->memState[SVM_OFFSET_TABLEm].index_max = -1;
        sop->memState[SVM_POLICY_TABLEm].index_max = -1;
        break;

    case BCM56648_DEVICE_ID:
    case BCM56649_DEVICE_ID:
        /* L3 IPMC */
        sop->memState[L3_IPMCm].index_max = 8191;
        sop->memState[L3_IPMC_1m].index_max = 8191;
        sop->memState[L3_IPMC_REMAPm].index_max = 8191;
        sop->memState[MMU_REPL_GROUPm].index_max = 8191;
        sop->memState[ING_UNTAGGED_PHBm].index_max = 62;
        if (rev_id & 0xF0) { /* B0 onwards size changed */
            sop->memState[EGR_IPMCm].index_max = 8191;
        }

        /* Fall through for L3_DEFIP config */
    default:
        /* L3_DEFIP sizing */
        SOC_CONTROL(unit)->l3_defip_max_tcams = _SOC_TR3_DEFIP_MAX_TCAMS;
        SOC_CONTROL(unit)->l3_defip_tcam_size = _SOC_TR3_DEFIP_TCAM_DEPTH;
        if (soc_property_get(unit, "l3_defip_sizing", TRUE)) {
            defip_config = soc_property_get(unit, spn_IPV6_LPM_128B_ENABLE, 1);

            num_ipv6_128b_entries = soc_property_get(unit,
                                        spn_NUM_IPV6_LPM_128B_ENTRIES,
                                        (defip_config ? 2048 : 0));
            num_ipv6_128b_entries = num_ipv6_128b_entries +
                                    (num_ipv6_128b_entries % 2);
            config_v6_entries = num_ipv6_128b_entries;
            if (soc_property_get(unit, spn_LPM_SCALING_ENABLE, 0)) {
               num_ipv6_128b_entries = 0;
                if (!soc_property_get(unit, spn_LPM_IPV6_128B_RESERVED, 1)) {
                    config_v6_entries = ((config_v6_entries /
                                        SOC_CONTROL(unit)->l3_defip_tcam_size) +
                                        ((config_v6_entries %
                                         SOC_CONTROL(unit)->l3_defip_tcam_size)
                                        ? 1 : 0)) * SOC_CONTROL(unit)->l3_defip_tcam_size;
                }

            }

            sop->memState[L3_DEFIP_PAIR_128m].index_max =
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_ONLYm].index_max =
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_DATA_ONLYm].index_max =
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_HIT_ONLYm].index_max =
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIPm].index_max =
                                     (SOC_CONTROL(unit)->l3_defip_max_tcams *
                                     SOC_CONTROL(unit)->l3_defip_tcam_size) -
                                     (num_ipv6_128b_entries * 2) - 1;
            sop->memState[L3_DEFIP_ONLYm].index_max =
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_DATA_ONLYm].index_max =
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_HIT_ONLYm].index_max =
                                          sop->memState[L3_DEFIPm].index_max;
            SOC_CONTROL(unit)->l3_defip_index_remap = num_ipv6_128b_entries;
            soc_l3_defip_indexes_init(unit, config_v6_entries);
        }
        break;
    }
    sop->memState[ING_UNTAGGED_PHBm].index_max = 62;
    if (!(rev_id & 0xF0)) { /* This mem is only available B0 onwards */
        sop->memState[L2_LEARN_INSERT_FAILUREm].index_max = -1;
    }
    
    /* MMU buffer size config */
    switch (dev_id) {
    case BCM56640_DEVICE_ID:
    case BCM56643_DEVICE_ID: 
    case BCM56644_DEVICE_ID:
    case BCM56648_DEVICE_ID:
    case BCM56649_DEVICE_ID:
    case BCM56044_DEVICE_ID:
        _soc_tr3_mmu_buffer_cells[unit] = _TR3_MMU_TOTAL_CELLS_24K; 
        break;
    case BCM56540_DEVICE_ID:
    case BCM56541_DEVICE_ID: 
    case BCM56542_DEVICE_ID:
    case BCM56543_DEVICE_ID:
    case BCM56544_DEVICE_ID:
    case BCM56545_DEVICE_ID:
    case BCM56546_DEVICE_ID:
    case BCM56045_DEVICE_ID:
    case BCM56046_DEVICE_ID:
        _soc_tr3_mmu_buffer_cells[unit] = _TR3_MMU_TOTAL_CELLS_19K; 
        break;
    default: 
        _soc_tr3_mmu_buffer_cells[unit] = _TR3_MMU_TOTAL_CELLS_19K; 
        break;
    }
    
#ifdef BCM_ISM_SUPPORT
    switch (dev_id) {
    case BCM56648_DEVICE_ID:
    case BCM56649_DEVICE_ID:
    case BCM56540_DEVICE_ID:
    case BCM56541_DEVICE_ID:
    case BCM56542_DEVICE_ID:
    case BCM56543_DEVICE_ID:
    case BCM56544_DEVICE_ID:
    case BCM56545_DEVICE_ID:
    case BCM56546_DEVICE_ID: scale = 3; 
        break;
    case BCM56044_DEVICE_ID:
    case BCM56045_DEVICE_ID:
    case BCM56046_DEVICE_ID: scale = 8; 
        break;
    default: break;
    }

    if (soc_feature(unit, soc_feature_ism_memory)) {
        soc_ism_mem_size_config_t ism_alloc_size[_ISM_MAX_MEMS];
        sal_memcpy(ism_alloc_size, _ism_alloc_size, sizeof(ism_alloc_size));
        ism_alloc_size[0].size =
            soc_property_get(unit, spn_VLAN_XLATE_MEM_ENTRIES,
                             ism_alloc_size[0].size/scale);
        ism_alloc_size[1].size =
            soc_property_get(unit, spn_L2_MEM_ENTRIES,
                             ism_alloc_size[1].size/scale);
        ism_alloc_size[2].size =
            soc_property_get(unit, spn_L3_MEM_ENTRIES,
                             ism_alloc_size[2].size/scale);
        ism_alloc_size[3].size =
            soc_property_get(unit, spn_EGR_VLAN_XLATE_MEM_ENTRIES,
                             ism_alloc_size[3].size/scale);
        ism_alloc_size[4].size =
            soc_property_get(unit, spn_MPLS_MEM_ENTRIES,
                             ism_alloc_size[4].size/scale);
        if (soc_feature(unit, soc_feature_esm_support)) {
            rv = soc_tr3_esm_init_read_config(unit);
            (void)soc_tr3_esm_get_ism_mem_size(unit, SOC_ISM_MEM_ESM_L2,
                                               &ism_alloc_size[5].size);
            (void)soc_tr3_esm_get_ism_mem_size(unit, SOC_ISM_MEM_ESM_L3,
                                               &ism_alloc_size[6].size);
            (void)soc_tr3_esm_get_ism_mem_size(unit, SOC_ISM_MEM_ESM_ACL,
                                               &ism_alloc_size[7].size);
            if (NULL == SOC_CONTROL(unit)->tcam_info) {
                sop->memState[ESM_PKT_TYPE_IDm].index_max = -1;
                sop->memState[ESM_PKT_TYPE_ID_ONLYm].index_max = -1;
                sop->memState[ESM_PKT_TYPE_ID_DATA_ONLYm].index_max = -1;
                sop->memState[ESM_SEARCH_PROFILEm].index_max = -1;
                sop->memState[ESM_KEY_ID_TO_FIELD_MAPPERm].index_max = -1;
                sop->memState[ESM_RANGE_CHECKm].index_max = -1;
                sop->memState[ESM_L3_PROTOCOL_FNm].index_max = -1;
                sop->memState[ESM_HWTL_OBSERVED_ET_RSPm].index_max = -1;
                sop->memState[ESM_ACL_ACTION_CONTROLm].index_max = -1;
                sop->memState[ESM_ACL_PROFILEm].index_max = -1;
            }
        }
        if (ism_alloc_size[1].size <= 0 && ism_alloc_size[5].size <= 0) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "No L2 memory configured !!\n")));
            return SOC_E_RESOURCE;
        }
        rv = soc_ism_mem_config(unit, ism_alloc_size, COUNTOF(ism_alloc_size));
        if (SOC_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Invalid or unsupported ISM memory config !!\n")));
            return rv;
        }
    }
#endif
    return rv;
}

#define _TR3_INDEX_1K_ENTRIES  1023
#define _TR3_INDEX_2K_ENTRIES  2047
#define _TR3_OFFSET_2K_ENTRIES 2048
#define _TR3_OFFSET_3K_ENTRIES 3072
#define _TR3_INDEX_4K_ENTRIES  4095
#define _TR3_INDEX_6K_ENTRIES  6143
#define _TR3_OFFSET_6K_ENTRIES 6144

/* Map logical (always starts from 0 and contiguous) index to physical index 
   which can have a starting offset and/or holes.
   Input  : logical index
   Returns: physical index */
int
soc_tr3_l3_defip_index_map(int unit, soc_mem_t mem, int index)
{
    int wide = 0;
    
    if (SOC_CONTROL(unit)->l3_defip_index_remap == 0) {
        return index;
    }

    if (mem == L3_DEFIP_PAIR_128m ||
        mem == L3_DEFIP_PAIR_128_ONLYm ||
        mem == L3_DEFIP_PAIR_128_DATA_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLYm) {
        wide = 1;
    }

    if (SOC_CONTROL(unit)->l3_defip_urpf) {
        if (soc_feature(unit, soc_feature_l3_reduced_defip_table)) { 
            return soc_l3_defip_urpf_index_map(unit, wide, index);
        } else if (!(soc_feature(unit, soc_feature_esm_support) &&
                     SOC_MEM_IS_ENABLED(unit, EXT_IPV4_DEFIPm) &&
                     soc_mem_index_count(unit, EXT_IPV4_DEFIPm) &&
                     SOC_MEM_IS_ENABLED(unit, EXT_IPV6_64_DEFIPm) &&
                     soc_mem_index_count(unit, EXT_IPV6_64_DEFIPm))) {
            /* TR3 no ESM */
            if (!soc_feature(unit, soc_feature_l3_expanded_defip_table)) { 
                return soc_l3_defip_urpf_index_map(unit, wide, index);
            }

            if (wide == 0) {
                if (index > _TR3_INDEX_2K_ENTRIES) {
                    return index + SOC_CONTROL(unit)->l3_defip_index_remap;
                }
                return index + SOC_CONTROL(unit)->l3_defip_index_remap / 2;
            } else {
               if (index > _TR3_INDEX_1K_ENTRIES) {
                    return index + SOC_CONTROL(unit)->l3_defip_index_remap / 4;
               }
               return index;
            }
        }
    } else { /* urpf not enabled */
        if (!(soc_feature(unit, soc_feature_esm_support) &&
              SOC_MEM_IS_ENABLED(unit, EXT_IPV4_DEFIPm) &&
              soc_mem_index_count(unit, EXT_IPV4_DEFIPm) &&
              SOC_MEM_IS_ENABLED(unit, EXT_IPV6_64_DEFIPm) &&
              soc_mem_index_count(unit, EXT_IPV6_64_DEFIPm))) {
            /* TR3 no ESM */
            if (!soc_feature(unit, soc_feature_l3_expanded_defip_table) &&
                !soc_feature(unit, soc_feature_l3_reduced_defip_table) && 
                !soc_feature(unit, soc_feature_l3_256_defip_table)) {
                return soc_l3_defip_index_map(unit, wide, index);
            }
        }

        if (soc_feature(unit, soc_feature_l3_reduced_defip_table)) { 
            /* AP2, FB4 */
            return soc_l3_defip_index_map(unit, wide, index);
        } 
    }
   
    /* Ranger, Ranger+ dont support uRPF */
    return (wide) ? index : index + SOC_CONTROL(unit)->l3_defip_index_remap;
}

/* Reverse map physical index to logical index.
   Input  : physical index
   Returns: logical index */
int
soc_tr3_l3_defip_index_remap(int unit, soc_mem_t mem, int index)
{
    int wide = 0;
    
    if (SOC_CONTROL(unit)->l3_defip_index_remap == 0) {
        return index;
    }

    if (mem == L3_DEFIP_PAIR_128m ||
        mem == L3_DEFIP_PAIR_128_ONLYm ||
        mem == L3_DEFIP_PAIR_128_DATA_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLYm) {
        wide = 1;
    }

    if (SOC_CONTROL(unit)->l3_defip_urpf) {
        if (soc_feature(unit, soc_feature_l3_reduced_defip_table)) { 
            /* AP2, FB4 */
            if (wide == 0) {
                return index - (SOC_CONTROL(unit)->l3_defip_index_remap);
            } else if (wide == 1 && index > _TR3_INDEX_1K_ENTRIES) {
                return index - (SOC_CONTROL(unit)->l3_defip_index_remap / 2);
            }
            return index;
        } else if (!(soc_feature(unit, soc_feature_esm_support) &&
                   SOC_MEM_IS_ENABLED(unit, EXT_IPV4_DEFIPm) &&
                   soc_mem_index_count(unit, EXT_IPV4_DEFIPm))) { 
            /* TR3 no ESM */
            if (!soc_feature(unit, soc_feature_l3_expanded_defip_table)) { 
                return soc_l3_defip_urpf_index_remap(unit, wide, index);
            }

            if (wide == 0) {
                if (index > _TR3_INDEX_6K_ENTRIES) {
                    return index - SOC_CONTROL(unit)->l3_defip_index_remap;
                }
                return index - SOC_CONTROL(unit)->l3_defip_index_remap / 2;
            } else {
               if (index > _TR3_INDEX_1K_ENTRIES) {
                    return index - SOC_CONTROL(unit)->l3_defip_index_remap / 4;
               }
               return index;
            }
        }
    } else { /* urpf not enabled */
        if (!(soc_feature(unit, soc_feature_esm_support) &&
            SOC_MEM_IS_ENABLED(unit, EXT_IPV4_DEFIPm) &&
            soc_mem_index_count(unit, EXT_IPV4_DEFIPm))) { 
            /* TR3 no ESM */

            if (!soc_feature(unit, soc_feature_l3_expanded_defip_table) &&
                !soc_feature(unit, soc_feature_l3_reduced_defip_table) &&
                !soc_feature(unit, soc_feature_l3_256_defip_table)) { 
                return soc_l3_defip_index_remap(unit, wide, index);
            }
        }

        if (soc_feature(unit, soc_feature_l3_reduced_defip_table)) { 
            /* AP2, FB4 */
            return (wide) ? index : index - 
                   (SOC_CONTROL(unit)->l3_defip_index_remap * 2);
        }
    }

    /* Ranger, Ranger+ dont support uRPF */ 
    return (wide) ? index : index - SOC_CONTROL(unit)->l3_defip_index_remap;
}

/* Given a physical index (always in terms of the narrow entry) 
   return the logical index and memory type */
int
soc_tr3_l3_defip_mem_index_get(int unit, int pindex, soc_mem_t *mem)
{
    int cam_size = 1024;

    *mem = L3_DEFIPm;
    
    if (!(soc_feature(unit, soc_feature_esm_support) &&
        SOC_MEM_IS_ENABLED(unit, EXT_IPV4_DEFIPm) &&
        soc_mem_index_count(unit, EXT_IPV4_DEFIPm))) { 
        /* TR3 no ESM */

        if (!soc_feature(unit, soc_feature_l3_expanded_defip_table) &&
            !soc_feature(unit, soc_feature_l3_reduced_defip_table) &&
            !soc_feature(unit, soc_feature_l3_256_defip_table)) {
            return soc_l3_defip_index_mem_map(unit, pindex, mem);
        }
    }

    if (SOC_CONTROL(unit)->l3_defip_urpf) {
        if (soc_feature(unit, soc_feature_l3_reduced_defip_table)) { 
            /* AP2, FB4 */
            if (SOC_CONTROL(unit)->l3_defip_index_remap == 0) {
                *mem = L3_DEFIPm;
                return pindex;  
            }      
            if (pindex < _TR3_OFFSET_2K_ENTRIES || pindex > _TR3_INDEX_4K_ENTRIES) {
                *mem = L3_DEFIP_PAIR_128m;
                pindex = ((pindex / (cam_size * 2)) * cam_size) +
                           (pindex % cam_size);
            }
        } else if (!(soc_feature(unit, soc_feature_esm_support) &&
                   SOC_MEM_IS_ENABLED(unit, EXT_IPV4_DEFIPm) &&
                   soc_mem_index_count(unit, EXT_IPV4_DEFIPm))) { 
            /* TR3 no ESM */
            if (pindex < _TR3_OFFSET_2K_ENTRIES || 
                ((pindex > _TR3_INDEX_4K_ENTRIES) &&
                 (pindex < _TR3_OFFSET_6K_ENTRIES))) {
                *mem = L3_DEFIP_PAIR_128m;
                pindex = pindex/2;
            }
        }
    } else {
        if (soc_feature(unit, soc_feature_l3_reduced_defip_table)) { /* AP2 */
            if (SOC_CONTROL(unit)->l3_defip_index_remap == 0) {
                *mem = L3_DEFIPm;
                return pindex;  
            }      
            if (pindex < (SOC_CONTROL(unit)->l3_defip_index_remap * 2)) {
                *mem = L3_DEFIP_PAIR_128m;  
                pindex = ((pindex / (cam_size * 2)) * cam_size) +
                           (pindex % cam_size);
            }
        } else if (pindex < SOC_CONTROL(unit)->l3_defip_index_remap) {
            *mem = L3_DEFIP_PAIR_128m;
            pindex = pindex/2;
        }
    }
    return soc_tr3_l3_defip_index_remap(unit, *mem, pindex);
}

int
_soc_tr3_port_mem_blk_enabled(int unit, int blk)
{
    int block_has_ports = FALSE, port, phy, lane, high_speed_port;
    soc_info_t *si = &SOC_INFO(unit);

    switch (SOC_BLOCK_TYPE(unit, blk)) {
    case SOC_BLK_XLPORT:
#ifdef BCM_HELIX4_SUPPORT
    case SOC_BLK_XWPORT:
#endif
        /* Only one PHY per XLPORT/XWPORT */
        for (lane = 0; lane < _SOC_TR3_LANES_PER_PHY; lane++) {
            port = si->port_p2l_mapping[si->blk_fpp[blk] + lane];
            if (SOC_PORT_VALID(unit, port)) {
                block_has_ports = TRUE;
                break;
            }
        }
        if (block_has_ports) {
            return TRUE;
        }
        break;
    case SOC_BLK_XTPORT:
        for (phy = 0; phy < _SOC_TR3_PHY_PER_PORT_BLOCK; phy++) {
            for (lane = 0; lane < _SOC_TR3_LANES_PER_PHY; lane++) {
                port = si->port_p2l_mapping[si->blk_fpp[blk] +
                           ((phy * _SOC_TR3_LANES_PER_PHY) + lane)];
                if (SOC_PORT_VALID(unit, port)) {
                    block_has_ports |= 1 << phy;
                    break; /* Only need to reset PHY once */
                }
            }
        }
        if (block_has_ports) {
            return TRUE;
        }
        break;
    case SOC_BLK_CLPORT:
        high_speed_port = -1;
        for (phy = 0; phy < _SOC_TR3_PHY_PER_PORT_BLOCK; phy++) {
            for (lane = 0; lane < _SOC_TR3_LANES_PER_PHY; lane++) {
                port = si->port_p2l_mapping[si->blk_fpp[blk] +
                           ((phy * _SOC_TR3_LANES_PER_PHY) + lane)];
                if (SOC_PORT_VALID(unit, port) &&
                    si->port_speed_max[port] >= 100000) {
                    high_speed_port = port;
                } else if (high_speed_port >= 0) {
                    port = high_speed_port;
                }
                if (SOC_PORT_VALID(unit, port)) {
                    block_has_ports |= 1 << phy;
                }
            }
        }
        if (block_has_ports) {
            return TRUE;
        }
        break;
    default: break;
    }
    return FALSE;
}

uint32 _soc_tr3_tdm_arr[_MAX_TR3_TDM_SLOTS] = {-1};
int _soc_tr3_tdm_size = 0;
_soc_tr3_flex_tdm_inf_t _soc_tr3_flex_tdm = {0};

STATIC int
_soc_tr3_mmu_tdm_init(int unit)
{
    static uint32 tr3_tdm_10[] = { /* FB3_1G_200 */
        57, 73, 61,  1, 13, 57, 77, 61, 25, 41, 57, 73, 61, 81, 57, 77,  5, 61, 81,
        57, 73, 61,  9, 17, 57, 77, 61, 29, 45, 57, 73, 61, 81, 57, 77, 21, 61,  0,
        57, 73, 61,  2, 14, 57, 77, 61, 33, 49, 57, 73, 61, 81, 57, 77, 26, 61, 81,
        57, 73, 61,  6, 18, 57, 77, 61, 30, 42, 57, 73, 61, 81, 57, 77, 46, 61,  0,
        57, 73, 61, 10, 22, 57, 77, 61, 34, 50, 57, 73, 61, 81, 57, 77, 37, 61, -1,
        57, 73, 61,  3, 15, 57, 77, 61, 27, 43, 57, 73, 61, 81, 57, 77,  7, 61, 81,
        57, 73, 61, 11, 19, 57, 77, 61, 31, 47, 57, 73, 61, 81, 57, 77, 23, 61,  0,
        57, 73, 61,  4, 16, 57, 77, 61, 35, 51, 57, 73, 61, 81, 57, 77, 28, 61, 81,
        57, 73, 61,  8, 20, 57, 77, 61, 32, 44, 57, 73, 61, 81, 57, 77, 48, 61,  0,
        57, 73, 61, 12, 24, 57, 77, 61, 36, 52, 57, 73, 61, 81, 57, 77, 37, 61, -1
    };
    static uint32 tr3_tdm_110[] = { /* 28xGE + 2xHG[42] + 2xHG[21] + 1GE */
        57, 73, 61, -1, 13, 57, 77, 61, 25, -1, 57, 73, 61, 81, 57, 77, -1, 61, 81,
        57, 73, 61,  9, 17, 57, 77, 61, 29, -1, 57, 73, 61, 81, 57, 77, 21, 61,  0,
        57, 73, 61, -1, 14, 57, 77, 61, 33, -1, 57, 73, 61, 81, 57, 77, 26, 61, 81,
        57, 73, 61, -1, 18, 57, 77, 61, 30, -1, 57, 73, 61, 81, 57, 77, -1, 61,  0,
        57, 73, 61, 10, 22, 57, 77, 61, 34, -1, 57, 73, 61, 81, 57, 77, 37, 61, -1,
        57, 73, 61, -1, 15, 57, 77, 61, 27, -1, 57, 73, 61, 81, 57, 77, -1, 61, 81,
        57, 73, 61, 11, 19, 57, 77, 61, 31, -1, 57, 73, 61, 81, 57, 77, 23, 61,  0,
        57, 73, 61, -1, 16, 57, 77, 61, 35, -1, 57, 73, 61, 81, 57, 77, 28, 61, 81,
        57, 73, 61, -1, 20, 57, 77, 61, 32, -1, 57, 73, 61, 81, 57, 77, -1, 61,  0,
        57, 73, 61, 12, 24, 57, 77, 61, 36, -1, 57, 73, 61, 81, 57, 77, 37, 61, -1
    };
    static uint32 tr3_tdm_11[] = { /* TR3_1G_200 */
        69, 57, 73,  1, 13, 77, 58, 69, 25, 41, 73, 59, 65, 77, 60, 69,  5, 73, 65,
        77, 57, 69,  9, 17, 65, 58, 73, 29, 45, 77, 59, 65, 69, 60, 73, 21,  0, 65,
        77, 57, 69,  2, 14, 73, 58, 77, 33, 49, 69, 59, 65, 73, 60, 77, 26, 69, 65,
        73, 57, 77,  6, 18, 65, 58, 69, 30, 42, 73, 59, 65, 77, 60, 69, 46, 81, 65,
        73, 57, 77, 10, 22, 69, 58, 73, 34, 50, 77, 59, 65, 69, 60, 73, 37, 77, 65,
        69, 57, 73,  3, 15, 77, 58, 69, 27, 43, 73, 59, 65, 77, 60, 69,  7, 73, 65,
        77, 57, 69, 11, 19, 65, 58, 73, 31, 47, 77, 59, 65, 69, 60, 73, 23,  0, 65,
        77, 57, 69,  4, 16, 73, 58, 77, 35, 51, 69, 59, 65, 73, 60, 77, 28, 69, 65,
        73, 57, 77,  8, 20, 65, 58, 69, 32, 44, 73, 59, 65, 77, 60, 69, 48, -1, 65,
        73, 57, 77, 12, 24, 69, 58, 73, 36, 52, 77, 59, 65, 69, 60, 73, 37, 77, 65
    };
    static uint32 tr3_tdm_12[] = { /* FB4_1G_200 */
        73, 57, 77,  1, 13, 73, 58, 77, 25, 41, 73, 59, 77, 81, 73, 60,  5, 77, 81,
        73, 57, 77,  9, 17, 73, 58, 77, 29, 45, 73, 59, 77, 81, 73, 60, 21, 77,  0,
        73, 57, 77,  2, 14, 73, 58, 77, 33, 49, 73, 59, 77, 81, 73, 60, 26, 77, 81,
        73, 57, 77,  6, 18, 73, 58, 77, 30, 42, 73, 59, 77, 81, 73, 60, 46, 77,  0,
        73, 57, 77, 10, 22, 73, 58, 77, 34, 50, 73, 59, 77, 81, 73, 60, 37, 77, -1,
        73, 57, 77,  3, 15, 73, 58, 77, 27, 43, 73, 59, 77, 81, 73, 60,  7, 77, 81,
        73, 57, 77, 11, 19, 73, 58, 77, 31, 47, 73, 59, 77, 81, 73, 60, 23, 77,  0,
        73, 57, 77,  4, 16, 73, 58, 77, 35, 51, 73, 59, 77, 81, 73, 60, 28, 77, 81,
        73, 57, 77,  8, 20, 73, 58, 77, 32, 44, 73, 59, 77, 81, 73, 60, 48, 77,  0,
        73, 57, 77, 12, 24, 73, 58, 77, 36, 52, 73, 59, 77, 81, 73, 60, 37, 77, -1
    };
    static uint32 tr3_tdm_112[] = { /* 28xGE + 4xXFI + 2xHG[42] + 1GE */
        73, 57, 77, -1, 13, 73, 58, 77, 25, -1, 73, 59, 77, 81, 73, 60, -1, 77, 81,
        73, 57, 77,  9, 17, 73, 58, 77, 29, -1, 73, 59, 77, 81, 73, 60, 21, 77,  0,
        73, 57, 77, -1, 14, 73, 58, 77, 33, -1, 73, 59, 77, 81, 73, 60, 26, 77, 81,
        73, 57, 77, -1, 18, 73, 58, 77, 30, -1, 73, 59, 77, 81, 73, 60, -1, 77,  0,
        73, 57, 77, 10, 22, 73, 58, 77, 34, -1, 73, 59, 77, 81, 73, 60, 37, 77, -1,
        73, 57, 77, -1, 15, 73, 58, 77, 27, -1, 73, 59, 77, 81, 73, 60, -1, 77, 81,
        73, 57, 77, 11, 19, 73, 58, 77, 31, -1, 73, 59, 77, 81, 73, 60, 23, 77,  0,
        73, 57, 77, -1, 16, 73, 58, 77, 35, -1, 73, 59, 77, 81, 73, 60, 28, 77, 81,
        73, 57, 77, -1, 20, 73, 58, 77, 32, -1, 73, 59, 77, 81, 73, 60, -1, 77,  0,
        73, 57, 77, 12, 24, 73, 58, 77, 36, -1, 73, 59, 77, 81, 73, 60, 37, 77, -1
    };
    static uint32 tr3_tdm_35[] = { /* TR3_100GE_260 */
        53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69,  0,
        53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 81,
        53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69,  0,
        53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 37,
        53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 81,
        53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69,  0,
        53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 81,
        53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, -1,
        53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69,  0,
        53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 53, 69, 81
    };
    static uint32 tr3_tdm_36[] = { /* 1x100GE + 4xHG[32] */
        53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77,  0,
        53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, 81,
        53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77,  0,
        53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, 37,
        53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, 81,
        53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77,  0,
        53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, 81,
        53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, -1,
        53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77,  0,
        53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, 53, 69, 53, 65, 53, 73, 53, 77, 81
    };
    static uint32 tr3_tdm_37[] = { /* 3xF.HG[42] + 1xHG[127] */
        53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69,  0,
        53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 81,
        53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69,  0,
        53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 37,
        53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 81,
        53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69,  0,
        53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 81,
        53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, -1,
        53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69,  0,
        53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 53, 69, 57, 69, 61, 69, 81
    };
    static _soc_tr3_flex_tdm_inf_t flex_tr3_tdm_37 = {
        1, 
        { 25, 25, 25 },
        {  0,  2,  4 },
        {  6,  6,  6 }
    };
    static uint32 tr3_tdm_38[] = { /* 1x100GE + 3xF.HG[42] */
        69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53,  0,
        69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 81,
        69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53,  0,
        69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 37,
        69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 81,
        69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53,  0,
        69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 81,
        69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, -1,
        69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53,  0,
        69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 69, 53, 73, 53, 77, 53, 81
    };
    static _soc_tr3_flex_tdm_inf_t flex_tr3_tdm_38 = {
        1, 
        { 25, 25, 25 },
        {  0,  2,  4 },
        {  6,  6,  6 }
    };
    static uint32 tr3_tdm_40[] = { /* AP2_1G_200_A */
        57, 73, 61, 41, 81, 57, 77, 61, 25, 45, 57, 73, 61, 13, 57, 77, 49, 61,  0,
        57, 73, 61, 42, 21, 57, 77, 61,  9, 45, 57, 73, 61, 17, 57, 77, 49, 61, 81,
        57, 73, 61, 43, 81, 57, 77, 61, 33, 45, 57, 73, 61, 14, 57, 77, 49, 61,  0,
        57, 73, 61, 44, 26, 57, 77, 61, 10, 45, 57, 73, 61, 18, 57, 77, 49, 61, 81,
        57, 73, 61, 41, -1, 57, 77, 61, 34, 45, 57, 73, 61, 22, 57, 77, 49, 61, 37,
        57, 73, 61, 42, 81, 57, 77, 61, 27, 45, 57, 73, 61, 15, 57, 77, 49, 61,  0,
        57, 73, 61, 43, 23, 57, 77, 61, 11, 45, 57, 73, 61, 19, 57, 77, 49, 61, 81,
        57, 73, 61, 44, 81, 57, 77, 61, 35, 45, 57, 73, 61, 16, 57, 77, 49, 61,  0,
        57, 73, 61, 41, 28, 57, 77, 61, 12, 45, 57, 73, 61, 20, 57, 77, 49, 61, 81,
        57, 73, 61, 42, -1, 57, 77, 61, 36, 45, 57, 73, 61, 24, 57, 77, 49, 61, 37,
        57, 73, 61, 43, 81, 57, 77, 61, 25, 45, 57, 73, 61, 13, 57, 77, 49, 61,  0,
        57, 73, 61, 44, 21, 57, 77, 61,  9, 45, 57, 73, 61, 17, 57, 77, 49, 61, 81,
        57, 73, 61, 41, 81, 57, 77, 61, 33, 45, 57, 73, 61, 14, 57, 77, 49, 61,  0,
        57, 73, 61, 42, 26, 57, 77, 61, 10, 45, 57, 73, 61, 18, 57, 77, 49, 61, 81,
        57, 73, 61, 43, -1, 57, 77, 61, 34, 45, 57, 73, 61, 22, 57, 77, 49, 61, 37,
        57, 73, 61, 44, 81, 57, 77, 61, 27, 45, 57, 73, 61, 15, 57, 77, 49, 61,  0,
        57, 73, 61, 41, 23, 57, 77, 61, 11, 45, 57, 73, 61, 19, 57, 77, 49, 61, 81,
        57, 73, 61, 42, 81, 57, 77, 61, 35, 45, 57, 73, 61, 16, 57, 77, 49, 61,  0,
        57, 73, 61, 43, 28, 57, 77, 61, 12, 45, 57, 73, 61, 20, 57, 77, 49, 61, 81,
        57, 73, 61, 44, -1, 57, 77, 61, 36, 45, 57, 73, 61, 24, 57, 77, 49, 61, 37
    };
    static _soc_tr3_flex_tdm_inf_t flex_tr3_tdm_40 = {
        1, 
        { 76, 76, 19, 19, 38, 38 },
        {  9, 16,  0,  2,  1,  6 },
        { 19, 19,  5,  5, 10,  9 }
    };
    static uint32 tr3_tdm_41[] = { /* AP2_1G_200_B */
        57, 73, 61, 41, 81, 57, 77, 61, 25, 45, 57, 73, 61, 13, 57, 77, 49, 61,  0,
        57, 73, 61, 42, 21, 57, 77, 61,  9, 46, 57, 73, 61, 17, 57, 77, 50, 61, 81,
        57, 73, 61, 43, 81, 57, 77, 61, 33, 47, 57, 73, 61, 14, 57, 77, 51, 61,  0,
        57, 73, 61, 44, 26, 57, 77, 61, 10, 48, 57, 73, 61, 18, 57, 77, 52, 61, 81,
        57, 73, 61, 41, -1, 57, 77, 61, 34, 45, 57, 73, 61, 22, 57, 77, 49, 61, 37,
        57, 73, 61, 42, 81, 57, 77, 61, 27, 46, 57, 73, 61, 15, 57, 77, 50, 61,  0,
        57, 73, 61, 43, 23, 57, 77, 61, 11, 47, 57, 73, 61, 19, 57, 77, 51, 61, 81,
        57, 73, 61, 44, 81, 57, 77, 61, 35, 48, 57, 73, 61, 16, 57, 77, 52, 61,  0,
        57, 73, 61, 41, 28, 57, 77, 61, 12, 45, 57, 73, 61, 20, 57, 77, 49, 61, 81,
        57, 73, 61, 42, -1, 57, 77, 61, 36, 46, 57, 73, 61, 24, 57, 77, 50, 61, 37,
        57, 73, 61, 43, 81, 57, 77, 61, 25, 47, 57, 73, 61, 13, 57, 77, 51, 61,  0,
        57, 73, 61, 44, 21, 57, 77, 61,  9, 48, 57, 73, 61, 17, 57, 77, 52, 61, 81,
        57, 73, 61, 41, 81, 57, 77, 61, 33, 45, 57, 73, 61, 14, 57, 77, 49, 61,  0,
        57, 73, 61, 42, 26, 57, 77, 61, 10, 46, 57, 73, 61, 18, 57, 77, 50, 61, 81,
        57, 73, 61, 43, -1, 57, 77, 61, 34, 47, 57, 73, 61, 22, 57, 77, 51, 61, 37,
        57, 73, 61, 44, 81, 57, 77, 61, 27, 48, 57, 73, 61, 15, 57, 77, 52, 61,  0,
        57, 73, 61, 41, 23, 57, 77, 61, 11, 45, 57, 73, 61, 19, 57, 77, 49, 61, 81,
        57, 73, 61, 42, 81, 57, 77, 61, 35, 46, 57, 73, 61, 16, 57, 77, 50, 61,  0,
        57, 73, 61, 43, 28, 57, 77, 61, 12, 47, 57, 73, 61, 20, 57, 77, 51, 61, 81,
        57, 73, 61, 44, -1, 57, 77, 61, 36, 48, 57, 73, 61, 24, 57, 77, 52, 61, 37
    };
    static const uint32 tr3_tdm_50[] = { /* FB4_1G_260_EMU */
        73, -1, 57, 77,  1, 13, 73, 81, 58, 77, 25, 41, 73, -1, 59, 77, -1, 81, 73, 5,  60, 77, -1, -1,  0,
        73, -1, 57, 77,  9, 17, 73, 81, 58, 77, 29, 45, 73, -1, 59, 77, -1, 81, 73, 21, 60, 77, -1, -1, 81,
        73, -1, 57, 77,  2, 14, 73, 81, 58, 77, 33, 49, 73, -1, 59, 77, -1, 81, 73, 26, 60, 77, -1, -1,  0,
        73, -1, 57, 77,  6, 18, 73, 81, 58, 77, 30, 42, 73, -1, 59, 77, -1, 81, 73, 46, 60, 77, -1, -1, -1,
        73, -1, 57, 77, 10, 22, 73, 81, 58, 77, 34, 50, 73, -1, 59, 77, -1, 81, 73, 37, 60, 77, -1, -1, 81,
        73, -1, 57, 77,  3, 15, 73, 81, 58, 77, 27, 43, 73, -1, 59, 77, -1, 81, 73, 7,  60, 77, -1, -1,  0,
        73, -1, 57, 77, 11, 19, 73, 81, 58, 77, 31, 47, 73, -1, 59, 77, -1, 81, 73, 23, 60, 77, -1, -1, 81,
        73, -1, 57, 77,  4, 16, 73, 81, 58, 77, 35, 51, 73, -1, 59, 77, -1, 81, 73, 28, 60, 77, -1, -1, -1,
        73, -1, 57, 77,  8, 20, 73, 81, 58, 77, 32, 44, 73, -1, 59, 77, -1, 81, 73, 48, 60, 77, -1, -1,  0,
        73, -1, 57, 77, 12, 24, 73, 81, 58, 77, 36, 52, 73, -1, 59, 77, -1, 81, 73, 37, 60, 77, -1, -1, 81
    };
    static const uint32 tr3_tdm_55[] = { /* RNGR_XAUI_260: 12xXAUI + 3xF.HG[42] + 1GE */
         1, 69, 13, 73, 25, 77, 41, 69,  5, 73, 17, 77, 29, 69, 45, 73,  9, 77, 21, 69, 33, 73, 49, 77,  0,
         1, 69, 13, 73, 25, 77, 41, 69,  5, 73, 17, 77, 29, 69, 45, 73,  9, 77, 21, 69, 33, 73, 49, 77, 81,
         1, 69, 13, 73, 25, 77, 41, 69,  5, 73, 17, 77, 29, 69, 45, 73,  9, 77, 21, 69, 33, 73, 49, 77,  0,
         1, 69, 13, 73, 25, 77, 41, 69,  5, 73, 17, 77, 29, 69, 45, 73,  9, 77, 21, 69, 33, 73, 49, 77, 37,
         1, 69, 13, 73, 25, 77, 41, 69,  5, 73, 17, 77, 29, 69, 45, 73,  9, 77, 21, 69, 33, 73, 49, 77, 81,
         1, 69, 13, 73, 25, 77, 41, 69,  5, 73, 17, 77, 29, 69, 45, 73,  9, 77, 21, 69, 33, 73, 49, 77,  0,
         1, 69, 13, 73, 25, 77, 41, 69,  5, 73, 17, 77, 29, 69, 45, 73,  9, 77, 21, 69, 33, 73, 49, 77, 81,
         1, 69, 13, 73, 25, 77, 41, 69,  5, 73, 17, 77, 29, 69, 45, 73,  9, 77, 21, 69, 33, 73, 49, 77, -1,
         1, 69, 13, 73, 25, 77, 41, 69,  5, 73, 17, 77, 29, 69, 45, 73,  9, 77, 21, 69, 33, 73, 49, 77,  0,
         1, 69, 13, 73, 25, 77, 41, 69,  5, 73, 17, 77, 29, 69, 45, 73,  9, 77, 21, 69, 33, 73, 49, 77, 81
    };
    static _soc_tr3_flex_tdm_inf_t flex_tr3_tdm_55 = {
        1, 
        { 25, 25, 25 },
        {  1,  3,  5 },
        {  6,  6,  6 }
    };
    static const uint32 tr3_tdm_155[] = { /* 12xXAUI + 2xF.HG[42] + 1GE */
         1, 69, 13, 73, 25, -1, 41, 69,  5, 73, 17, -1, 29, 69, 45, 73,  9, -1, 21, 69, 33, 73, 49, -1,  0,
         1, 69, 13, 73, 25, -1, 41, 69,  5, 73, 17, -1, 29, 69, 45, 73,  9, -1, 21, 69, 33, 73, 49, -1, 81,
         1, 69, 13, 73, 25, -1, 41, 69,  5, 73, 17, -1, 29, 69, 45, 73,  9, -1, 21, 69, 33, 73, 49, -1,  0,
         1, 69, 13, 73, 25, -1, 41, 69,  5, 73, 17, -1, 29, 69, 45, 73,  9, -1, 21, 69, 33, 73, 49, -1, 37,
         1, 69, 13, 73, 25, -1, 41, 69,  5, 73, 17, -1, 29, 69, 45, 73,  9, -1, 21, 69, 33, 73, 49, -1, 81,
         1, 69, 13, 73, 25, -1, 41, 69,  5, 73, 17, -1, 29, 69, 45, 73,  9, -1, 21, 69, 33, 73, 49, -1,  0,
         1, 69, 13, 73, 25, -1, 41, 69,  5, 73, 17, -1, 29, 69, 45, 73,  9, -1, 21, 69, 33, 73, 49, -1, 81,
         1, 69, 13, 73, 25, -1, 41, 69,  5, 73, 17, -1, 29, 69, 45, 73,  9, -1, 21, 69, 33, 73, 49, -1, -1,
         1, 69, 13, 73, 25, -1, 41, 69,  5, 73, 17, -1, 29, 69, 45, 73,  9, -1, 21, 69, 33, 73, 49, -1,  0,
         1, 69, 13, 73, 25, -1, 41, 69,  5, 73, 17, -1, 29, 69, 45, 73,  9, -1, 21, 69, 33, 73, 49, -1, 81
    };
    static _soc_tr3_flex_tdm_inf_t flex_tr3_tdm_155 = {
        1, 
        { 25, 25 },
        {  1,  3 },
        {  6,  6 }
    };
    static const uint32 tr3_tdm_71[] = { /* 3xF.40GE + 3xF.HG[42], 3xF.HG[42] + 3xF.40GE */
        53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77,  0,
        53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 81,
        53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77,  0,
        53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 37,
        53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 81,
        53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77,  0,
        53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 81,
        53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, -1,
        53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77,  0,
        53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 53, 69, 57, 73, 61, 77, 81
    };
    static _soc_tr3_flex_tdm_inf_t flex_tr3_tdm_71 = {
        1, 
        { 25, 25, 25, 25, 25, 25 },
        {  0,  2,  4,  1,  3,  5 },
        {  6,  6,  6,  6,  6,  6 }
    };
    static const uint32 tr3_tdm_171[] = { /* 3xF.40GE + 2xF.HG[42], 3xF.HG[42] + 2xF.40GE */
        53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1,  0,
        53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 81,
        53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1,  0,
        53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 37,
        53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 81,
        53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1,  0,
        53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 81,
        53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, -1,
        53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1,  0,
        53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 53, 69, 57, 73, 61, -1, 81
    };
    static _soc_tr3_flex_tdm_inf_t flex_tr3_tdm_171 = {
        1, 
        { 25, 25, 25, 25, 25 },
        {  0,  2,  4,  1,  3 },
        {  6,  6,  6,  6,  6 }
    };
    static uint32 tr3_tdm_81[] = { /* 1x100GE + 8xHGd[16] */
        53, 69, 53, 73, 53, 65, 53, 77, 53, 71, 53, 67, 53, 75, 53, 79, 53, 65, 69, 53, 73, 53, 77, 53,  0,
        53, 71, 53, 75, 53, 67, 53, 79, 53, 69, 53, 65, 53, 73, 53, 77, 53, 67, 71, 53, 75, 53, 79, 53, 81,
        53, 69, 53, 73, 53, 65, 53, 77, 53, 71, 53, 67, 53, 75, 53, 79, 53, 65, 69, 53, 73, 53, 77, 53,  0,
        53, 71, 53, 75, 53, 67, 53, 79, 53, 69, 53, 65, 53, 73, 53, 77, 53, 67, 71, 53, 75, 53, 79, 53, 37,
        53, 69, 53, 73, 53, 65, 53, 77, 53, 71, 53, 67, 53, 75, 53, 79, 53, 65, 69, 53, 73, 53, 77, 53, 81,
        53, 71, 53, 75, 53, 67, 53, 79, 53, 69, 53, 65, 53, 73, 53, 77, 53, 67, 71, 53, 75, 53, 79, 53,  0,
        53, 69, 53, 73, 53, 65, 53, 77, 53, 71, 53, 67, 53, 75, 53, 79, 53, 65, 69, 53, 73, 53, 77, 53, 81,
        53, 71, 53, 75, 53, 67, 53, 79, 53, 69, 53, 65, 53, 73, 53, 77, 53, 67, 71, 53, 75, 53, 79, 53, -1,
        53, 69, 53, 73, 53, 65, 53, 77, 53, 71, 53, 67, 53, 75, 53, 79, 53, 65, 69, 53, 73, 53, 77, 53,  0,
        53, 71, 53, 75, 53, 67, 53, 79, 53, 69, 53, 65, 53, 73, 53, 77, 53, 67, 71, 53, 75, 53, 79, 53, 81
    };
    static uint32 tr3_tdm_82[] = { /* 3xF.HG[42] + 4xHG[32] */
        53, 69, 57, 65, 61, 73, 53, 77, 57, 69, 61, 65, 53, 73, 57, 77, 61, 69, 53, 65, 57, 73, 61, 77,  0,
        53, 69, 57, 65, 61, 73, 53, 77, 57, 69, 61, 65, 53, 73, 57, 77, 61, 69, 53, 65, 57, 73, 61, 77, 81,
        53, 69, 57, 65, 61, 73, 53, 77, 57, 69, 61, 65, 53, 73, 57, 77, 61, 69, 53, 65, 57, 73, 61, 77,  0,
        53, 69, 57, 65, 61, 73, 53, 77, 57, 69, 61, 65, 53, 73, 57, 77, 61, 69, 53, 65, 57, 73, 61, 77, 37,
        53, 69, 57, 65, 61, 73, 53, 77, 57, 69, 61, 65, 53, 73, 57, 77, 61, 69, 53, 65, 57, 73, 61, 77, 81,
        53, 69, 57, 65, 61, 73, 53, 77, 57, 69, 61, 65, 53, 73, 57, 77, 61, 69, 53, 65, 57, 73, 61, 77,  0,
        53, 69, 57, 65, 61, 73, 53, 77, 57, 69, 61, 65, 53, 73, 57, 77, 61, 69, 53, 65, 57, 73, 61, 77, 81,
        53, 69, 57, 65, 61, 73, 53, 77, 57, 69, 61, 65, 53, 73, 57, 77, 61, 69, 53, 65, 57, 73, 61, 77, -1,
        53, 69, 57, 65, 61, 73, 53, 77, 57, 69, 61, 65, 53, 73, 57, 77, 61, 69, 53, 65, 57, 73, 61, 77,  0,
        53, 69, 57, 65, 61, 73, 53, 77, 57, 69, 61, 65, 53, 73, 57, 77, 61, 69, 53, 65, 57, 73, 61, 77, 81
    };
    static uint32 tr3_tdm_83[] = { /* 3xF.HG[42] + 8xHGd[16] */
        53, 69, 57, 73, 61, 65, 53, 77, 57, 71, 61, 67, 53, 75, 57, 79, 61, 65, 69, 53, 73, 57, 77, 61,  0,
        53, 71, 57, 75, 61, 67, 53, 79, 57, 69, 61, 65, 53, 73, 57, 77, 61, 67, 71, 53, 75, 57, 79, 61, 81,
        53, 69, 57, 73, 61, 65, 53, 77, 57, 71, 61, 67, 53, 75, 57, 79, 61, 65, 69, 53, 73, 57, 77, 61,  0,
        53, 71, 57, 75, 61, 67, 53, 79, 57, 69, 61, 65, 53, 73, 57, 77, 61, 67, 71, 53, 75, 57, 79, 61, 37,
        53, 69, 57, 73, 61, 65, 53, 77, 57, 71, 61, 67, 53, 75, 57, 79, 61, 65, 69, 53, 73, 57, 77, 61, 81,
        53, 71, 57, 75, 61, 67, 53, 79, 57, 69, 61, 65, 53, 73, 57, 77, 61, 67, 71, 53, 75, 57, 79, 61,  0,
        53, 69, 57, 73, 61, 65, 53, 77, 57, 71, 61, 67, 53, 75, 57, 79, 61, 65, 69, 53, 73, 57, 77, 61, 81,
        53, 71, 57, 75, 61, 67, 53, 79, 57, 69, 61, 65, 53, 73, 57, 77, 61, 67, 71, 53, 75, 57, 79, 61, -1,
        53, 69, 57, 73, 61, 65, 53, 77, 57, 71, 61, 67, 53, 75, 57, 79, 61, 65, 69, 53, 73, 57, 77, 61,  0,
        53, 71, 57, 75, 61, 67, 53, 79, 57, 69, 61, 65, 53, 73, 57, 77, 61, 67, 71, 53, 75, 57, 79, 61, 81
    };
    static const uint32 tr3_tdm_90[] = { /* FB3_1G_200_HG25 */
        57, 73,  1, 13, 61, 77, 25, 41, 57, 73, 81, 61, 77,  5, 57, 73,  0, 61, 77,
        57, 73,  9, 17, 61, 77, 29, 45, 57, 73, 81, 61, 77, 21, 57, 73, -1, 61, 77,
        57, 73,  2, 14, 61, 77, 33, 49, 57, 73, 81, 61, 77, 26, 57, 73,  0, 61, 77,
        57, 73,  6, 18, 61, 77, 30, 42, 57, 73, 81, 61, 77, 46, 57, 73, -1, 61, 77,
        57, 73, 10, 22, 61, 77, 34, 50, 57, 73, 81, 61, 77, 37, 57, 73,  0, 61, 77,
        57, 73,  3, 15, 61, 77, 27, 43, 57, 73, 81, 61, 77,  7, 57, 73,  0, 61, 77,
        57, 73, 11, 19, 61, 77, 31, 47, 57, 73, 81, 61, 77, 23, 57, 73, -1, 61, 77,
        57, 73,  4, 16, 61, 77, 35, 51, 57, 73, 81, 61, 77, 28, 57, 73,  0, 61, 77,
        57, 73,  8, 20, 61, 77, 32, 44, 57, 73, 81, 61, 77, 48, 57, 73, -1, 61, 77,
        57, 73, 12, 24, 61, 77, 36, 52, 57, 73, 81, 61, 77, 37, 57, 73,  0, 61, 77
    };
    static const uint32 tr3_tdm_190[] = { /* 24xGE-LR + 2xXAUI + 2xHG[21] + 1GE */
        73, 57,  1, 13, 77, 61, 81, 73,  5, 17, 57, 77, 61,  0, 73,  9, 57, 77, 61,
        73, 57,  2, 21, 77, 61, 81, 73,  6, 14, 57, 77, 61, -1, 73, 18, 57, 77, 61,
        73, 57, 10, 22, 77, 61, 81, 73,  3, 15, 57, 77, 61,  0, 73,  7, 57, 77, 61,
        73, 57, 11, 19, 77, 61, 81, 73,  4, 23, 57, 77, 61, -1, 73, 16, 57, 77, 61,
        73, 57,  8, 20, 77, 61, 81, 73, 12, 24, 57, 77, 61,  0, 73, 37, 57, 77, 61
    };
    static uint32 tr3_tdm_91[] = { /* FB4_XAUI_200_C -> 10xF.XAUI + 4xHG[21] + 1GE */
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33, 81,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33,  0,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33, 37,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33,  0,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33, -1,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33, 81,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33,  0,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33, 37,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33,  0,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33, -1,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33, 81,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33,  0,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33, 37,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33,  0,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33, -1,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33, 81,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33,  0,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33, 37,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33,  0,
        57,  1, 73, 13, 61, 25, 77,  5, 57, 17, 73, 29, 49, 61,  9, 77, 21, 33, -1
    };
    static _soc_tr3_flex_tdm_inf_t flex_tr3_tdm_91 = {
        1, 
        { 76, 76, 76, 76, 76, 76, 76, 76, 76, 76 },
        {  1,  7, 14,  3,  9, 16,  5, 11, 17, 12 },
        { 19, 19, 19, 19, 19, 19, 19, 19, 19, 19 } 
    };
    static uint32 tr3_tdm_94[] = { /* FB4_XAUI_200_F */
        57, 73,  1, 77, 81, 58, 74, 17, 78, -1, 59, 75, 29, 79, 81, 60, 76, 49, 80,
        57, 73,  1, 77, 81, 58, 74, 17, 78,  0, 59, 75, 29, 79, 81, 60, 76, 49, 80,
        57, 73,  1, 77, 81, 58, 74, 17, 78, 37, 59, 75, 29, 79, 81, 60, 76, 49, 80,
        57, 73,  1, 77, 81, 58, 74, 17, 78,  0, 59, 75, 29, 79, 81, 60, 76, 49, 80,
        57, 73,  1, 77, 81, 58, 74, 17, 78, -1, 59, 75, 29, 79, 81, 60, 76, 49, 80
    };
    static uint32 tr3_tdm_95[] = { /* TR3_1G_280 */
    	 1, 69, 57, 73, 65, 77, 13, 69, 58, 73, 65, 77,  5, 69, 59, 73, 65, 77, 25, 69, 60, 73, 65, 77, 41,  0,
    	 9, 69, 57, 73, 65, 77, 17, 69, 58, 73, 65, 77, 21, 69, 59, 73, 65, 77, 29, 69, 60, 73, 65, 77, 45, 81,
    	 2, 69, 57, 73, 65, 77, 14, 69, 58, 73, 65, 77, 33, 69, 59, 73, 65, 77, 26, 69, 60, 73, 65, 77, 49,  0,
    	 6, 69, 57, 73, 65, 77, 18, 69, 58, 73, 65, 77, 42, 69, 59, 73, 65, 77, 30, 69, 60, 73, 65, 77, 46, 81,
    	10, 69, 57, 73, 65, 77, 22, 69, 58, 73, 65, 77, 37, 69, 59, 73, 65, 77, 34, 69, 60, 73, 65, 77, 50,  0,
    	 3, 69, 57, 73, 65, 77, 15, 69, 58, 73, 65, 77,  7, 69, 59, 73, 65, 77, 27, 69, 60, 73, 65, 77, 43, 81,
    	11, 69, 57, 73, 65, 77, 19, 69, 58, 73, 65, 77, 23, 69, 59, 73, 65, 77, 31, 69, 60, 73, 65, 77, 47,  0,
    	 4, 69, 57, 73, 65, 77, 16, 69, 58, 73, 65, 77, 35, 69, 59, 73, 65, 77, 28, 69, 60, 73, 65, 77, 51, 81,
    	 8, 69, 57, 73, 65, 77, 20, 69, 58, 73, 65, 77, 44, 69, 59, 73, 65, 77, 32, 69, 60, 73, 65, 77, 48, -1,
    	12, 69, 57, 73, 65, 77, 24, 69, 58, 73, 65, 77, 37, 69, 59, 73, 65, 77, 36, 69, 60, 73, 65, 77, 52, 81
    };
    static uint32 tr3_tdm_195[] = { /* 48xGE + 1x40GE + 4xHG[42] */
    	 1, 69, 57, 73, 65, 77, 13, 69, 57, 73, 65, 77,  5, 69, 57, 73, 65, 77, 25, 69, 57, 73, 65, 77, 41,  0,
    	 9, 69, 57, 73, 65, 77, 17, 69, 57, 73, 65, 77, 21, 69, 57, 73, 65, 77, 29, 69, 57, 73, 65, 77, 45, 81,
    	 2, 69, 57, 73, 65, 77, 14, 69, 57, 73, 65, 77, 33, 69, 57, 73, 65, 77, 26, 69, 57, 73, 65, 77, 49,  0,
    	 6, 69, 57, 73, 65, 77, 18, 69, 57, 73, 65, 77, 42, 69, 57, 73, 65, 77, 30, 69, 57, 73, 65, 77, 46, 81,
    	10, 69, 57, 73, 65, 77, 22, 69, 57, 73, 65, 77, 37, 69, 57, 73, 65, 77, 34, 69, 57, 73, 65, 77, 50,  0,
    	 3, 69, 57, 73, 65, 77, 15, 69, 57, 73, 65, 77,  7, 69, 57, 73, 65, 77, 27, 69, 57, 73, 65, 77, 43, 81,
    	11, 69, 57, 73, 65, 77, 19, 69, 57, 73, 65, 77, 23, 69, 57, 73, 65, 77, 31, 69, 57, 73, 65, 77, 47,  0,
    	 4, 69, 57, 73, 65, 77, 16, 69, 57, 73, 65, 77, 35, 69, 57, 73, 65, 77, 28, 69, 57, 73, 65, 77, 51, 81,
    	 8, 69, 57, 73, 65, 77, 20, 69, 57, 73, 65, 77, 44, 69, 57, 73, 65, 77, 32, 69, 57, 73, 65, 77, 48, -1,
    	12, 69, 57, 73, 65, 77, 24, 69, 57, 73, 65, 77, 37, 69, 57, 73, 65, 77, 36, 69, 57, 73, 65, 77, 52, 81
    };
    static uint32 tr3_tdm_295[] = { /* 48xGE + 4xXFI + 1xHG[127] */
    	 1, 69, 57, 69, -1, 69, 13, 69, 58, 69, -1, 69,  5, 69, 59, 69, -1, 69, 25, 69, 60, 69, -1, 69, 41,  0,
    	 9, 69, 57, 69, -1, 69, 17, 69, 58, 69, -1, 69, 21, 69, 59, 69, -1, 69, 29, 69, 60, 69, -1, 69, 45, 81,
    	 2, 69, 57, 69, -1, 69, 14, 69, 58, 69, -1, 69, 33, 69, 59, 69, -1, 69, 26, 69, 60, 69, -1, 69, 49,  0,
    	 6, 69, 57, 69, -1, 69, 18, 69, 58, 69, -1, 69, 42, 69, 59, 69, -1, 69, 30, 69, 60, 69, -1, 69, 46, 81,
    	10, 69, 57, 69, -1, 69, 22, 69, 58, 69, -1, 69, 37, 69, 59, 69, -1, 69, 34, 69, 60, 69, -1, 69, 50,  0,
    	 3, 69, 57, 69, -1, 69, 15, 69, 58, 69, -1, 69,  7, 69, 59, 69, -1, 69, 27, 69, 60, 69, -1, 69, 43, 81,
    	11, 69, 57, 69, -1, 69, 19, 69, 58, 69, -1, 69, 23, 69, 59, 69, -1, 69, 31, 69, 60, 69, -1, 69, 47,  0,
    	 4, 69, 57, 69, -1, 69, 16, 69, 58, 69, -1, 69, 35, 69, 59, 69, -1, 69, 28, 69, 60, 69, -1, 69, 51, 81,
    	 8, 69, 57, 69, -1, 69, 20, 69, 58, 69, -1, 69, 44, 69, 59, 69, -1, 69, 32, 69, 60, 69, -1, 69, 48, -1,
    	12, 69, 57, 69, -1, 69, 24, 69, 58, 69, -1, 69, 37, 69, 59, 69, -1, 69, 36, 69, 60, 69, -1, 69, 52, 81
    };
    static uint32 tr3_tdm_395[] = { /* 28xGE + 4xXFI + 4xHG[42] */
    	-1, 69, 57, 73, 65, 77, 13, 69, 58, 73, 65, 77, -1, 69, 59, 73, 65, 77, 25, 69, 60, 73, 65, 77, -1,  0,
    	 9, 69, 57, 73, 65, 77, 17, 69, 58, 73, 65, 77, 21, 69, 59, 73, 65, 77, 29, 69, 60, 73, 65, 77, -1, 81,
    	-1, 69, 57, 73, 65, 77, 14, 69, 58, 73, 65, 77, 33, 69, 59, 73, 65, 77, 26, 69, 60, 73, 65, 77, -1,  0,
    	-1, 69, 57, 73, 65, 77, 18, 69, 58, 73, 65, 77, -1, 69, 59, 73, 65, 77, 30, 69, 60, 73, 65, 77, -1, 81,
    	10, 69, 57, 73, 65, 77, 22, 69, 58, 73, 65, 77, 37, 69, 59, 73, 65, 77, 34, 69, 60, 73, 65, 77, -1,  0,
    	-1, 69, 57, 73, 65, 77, 15, 69, 58, 73, 65, 77, -1, 69, 59, 73, 65, 77, 27, 69, 60, 73, 65, 77, -1, 81,
    	11, 69, 57, 73, 65, 77, 19, 69, 58, 73, 65, 77, 23, 69, 59, 73, 65, 77, 31, 69, 60, 73, 65, 77, -1,  0,
    	-1, 69, 57, 73, 65, 77, 16, 69, 58, 73, 65, 77, 35, 69, 59, 73, 65, 77, 28, 69, 60, 73, 65, 77, -1, 81,
    	-1, 69, 57, 73, 65, 77, 20, 69, 58, 73, 65, 77, -1, 69, 59, 73, 65, 77, 32, 69, 60, 73, 65, 77, -1, -1,
    	12, 69, 57, 73, 65, 77, 24, 69, 58, 73, 65, 77, 37, 69, 59, 73, 65, 77, 36, 69, 60, 73, 65, 77, -1, 81
    };
    static uint32 tr3_tdm_495[] = { /* 28xGE + 1x40GE + 4xHG[42] */
    	-1, 69, 57, 73, 65, 77, 13, 69, 57, 73, 65, 77, -1, 69, 57, 73, 65, 77, 25, 69, 57, 73, 65, 77, -1,  0,
    	 9, 69, 57, 73, 65, 77, 17, 69, 57, 73, 65, 77, 21, 69, 57, 73, 65, 77, 29, 69, 57, 73, 65, 77, -1, 81,
    	-1, 69, 57, 73, 65, 77, 14, 69, 57, 73, 65, 77, 33, 69, 57, 73, 65, 77, 26, 69, 57, 73, 65, 77, -1,  0,
    	-1, 69, 57, 73, 65, 77, 18, 69, 57, 73, 65, 77, -1, 69, 57, 73, 65, 77, 30, 69, 57, 73, 65, 77, -1, 81,
    	10, 69, 57, 73, 65, 77, 22, 69, 57, 73, 65, 77, 37, 69, 57, 73, 65, 77, 34, 69, 57, 73, 65, 77, -1,  0,
    	-1, 69, 57, 73, 65, 77, 15, 69, 57, 73, 65, 77, -1, 69, 57, 73, 65, 77, 27, 69, 57, 73, 65, 77, -1, 81,
    	11, 69, 57, 73, 65, 77, 19, 69, 57, 73, 65, 77, 23, 69, 57, 73, 65, 77, 31, 69, 57, 73, 65, 77, -1,  0,
    	-1, 69, 57, 73, 65, 77, 16, 69, 57, 73, 65, 77, 35, 69, 57, 73, 65, 77, 28, 69, 57, 73, 65, 77, -1, 81,
    	-1, 69, 57, 73, 65, 77, 20, 69, 57, 73, 65, 77, -1, 69, 57, 73, 65, 77, 32, 69, 57, 73, 65, 77, -1, -1,
    	12, 69, 57, 73, 65, 77, 24, 69, 57, 73, 65, 77, 37, 69, 57, 73, 65, 77, 36, 69, 57, 73, 65, 77, -1, 81
    };
    static uint32 tr3_tdm_96[] = { /* FB3_1G_200_XFI */
        57, 81, 61,  1, 13, 58, 81, 62, 25, 41, 59, 81, 63,  0, 60, 81,  5, 64, -1,
        57, 81, 61,  9, 17, 58, 81, 62, 29, 45, 59, 81, 63,  0, 60, 81, 21, 64, -1,
        57, 81, 61,  2, 14, 58, 81, 62, 33, 49, 59, 81, 63,  0, 60, 81, 26, 64, -1,
        57, 81, 61,  6, 18, 58, 81, 62, 30, 42, 59, 81, 63,  0, 60, 81, 46, 64, -1,
        57, 81, 61, 10, 22, 58, 81, 62, 34, 50, 59, 81, 63,  0, 60, 81, 37, 64, -1,
        57, 81, 61,  3, 15, 58, 81, 62, 27, 43, 59, 81, 63,  0, 60, 81,  7, 64, -1,
        57, 81, 61, 11, 19, 58, 81, 62, 31, 47, 59, 81, 63,  0, 60, 81, 23, 64, -1,
        57, 81, 61,  4, 16, 58, 81, 62, 35, 51, 59, 81, 63,  0, 60, 81, 28, 64, -1,
        57, 81, 61,  8, 20, 58, 81, 62, 32, 44, 59, 81, 63,  0, 60, 81, 48, 64, -1,
        57, 81, 61, 12, 24, 58, 81, 62, 36, 52, 59, 81, 63,  0, 60, 81, 37, 64, -1
    };
    static uint32 tr3_tdm_196[] = { /* 28xGE + 8xXFI + 1GE */
        57, 81, 61, -1, 13, 58, 81, 62, 25, -1, 59, 81, 63,  0, 60, 81, -1, 64, -1,
        57, 81, 61,  9, 17, 58, 81, 62, 29, -1, 59, 81, 63,  0, 60, 81, 21, 64, -1,
        57, 81, 61, -1, 14, 58, 81, 62, 33, -1, 59, 81, 63,  0, 60, 81, 26, 64, -1,
        57, 81, 61, -1, 18, 58, 81, 62, 30, -1, 59, 81, 63,  0, 60, 81, -1, 64, -1,
        57, 81, 61, 10, 22, 58, 81, 62, 34, -1, 59, 81, 63,  0, 60, 81, 37, 64, -1,
        57, 81, 61, -1, 15, 58, 81, 62, 27, -1, 59, 81, 63,  0, 60, 81, -1, 64, -1,
        57, 81, 61, 11, 19, 58, 81, 62, 31, -1, 59, 81, 63,  0, 60, 81, 23, 64, -1,
        57, 81, 61, -1, 16, 58, 81, 62, 35, -1, 59, 81, 63,  0, 60, 81, 28, 64, -1,
        57, 81, 61, -1, 20, 58, 81, 62, 32, -1, 59, 81, 63,  0, 60, 81, -1, 64, -1,
        57, 81, 61, 12, 24, 58, 81, 62, 36, -1, 59, 81, 63,  0, 60, 81, 37, 64, -1
    };
    static uint32 tr3_tdm_97[] = { /* 10xF.XAUI + 4xXFI */
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33, 81,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33,  0,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33, 37,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33,  0,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33, -1,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33, 81,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33,  0,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33, 37,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33,  0,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33, -1,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33, 81,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33,  0,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33, 37,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33,  0,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33, -1,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33, 81,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33,  0,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33, 37,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33,  0,
    	57,  1, -1, 13, 58, 25, 81,  5, 59, 17, 81, 29, 49, 60,  9, -1, 21, 33, -1
    };
    static _soc_tr3_flex_tdm_inf_t flex_tr3_tdm_97 = {
        1, 
        { 76, 76, 76, 76, 76, 76, 76, 76, 76, 76 },
        {  1,  7, 14,  3,  9, 16,  5, 11, 17, 12 },
        { 19, 19, 19, 19, 19, 19, 19, 19, 19, 19 } 
    };
    static uint32 tr3_tdm_98[] = { /* 10xF.XAUI + 2xHG[42] */
        57, 81,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57,  0,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57, 37,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57,  0,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57, -1,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57, 81,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57,  0,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57, 37,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57,  0,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57, -1,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57, 81,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57,  0,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57, 37,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57,  0,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57, -1,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57, 81,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57,  0,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57, 37,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57,  0,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33,
        57, -1,  1, 61, 13, 57, 25, 61,  5, 57, 17, 61, 29, 49, 57,  9, 61, 21, 33
    };
    static _soc_tr3_flex_tdm_inf_t flex_tr3_tdm_98 = {
        1, 
        { 76, 76, 76, 76, 76, 76, 76, 76, 76, 76 },
        {  2,  8, 15,  4, 10, 17,  6, 12, 18, 13 },
        { 19, 19, 19, 19, 19, 19, 19, 19, 19, 19 } 
    };
    static uint32 tr3_tdm_99[] = { /* 24xGE + 4xXAUI + 2xXFI + 2xHG[12] + 1GE */
    	57,  1, 73, 13, 81, 25, 77,  5, 58, 17, 73, 29, 49,  0,  9, 77, 21, 33, -1,
    	57,  2, 73, 14, 81, 25, 77,  6, 58, 18, 73, 29, 49,  0, 10, 77, 22, 33, -1,
    	57,  3, 73, 15, 81, 25, 77,  7, 58, 19, 73, 29, 49,  0, 11, 77, 23, 33, -1,
    	57,  4, 73, 16, 81, 25, 77,  8, 58, 20, 73, 29, 49,  0, 12, 77, 24, 33, -1,
    	57,  1, 73, 13, 81, 25, 77,  5, 58, 17, 73, 29, 49, 37,  9, 77, 21, 33, -1,
    	57,  2, 73, 14, 81, 25, 77,  6, 58, 18, 73, 29, 49,  0, 10, 77, 22, 33, -1,
    	57,  3, 73, 15, 81, 25, 77,  7, 58, 19, 73, 29, 49,  0, 11, 77, 23, 33, -1,
    	57,  4, 73, 16, 81, 25, 77,  8, 58, 20, 73, 29, 49,  0, 12, 77, 24, 33, -1,
    	57,  1, 73, 13, 81, 25, 77,  5, 58, 17, 73, 29, 49,  0,  9, 77, 21, 33, -1,
    	57,  2, 73, 14, 81, 25, 77,  6, 58, 18, 73, 29, 49, 37, 10, 77, 22, 33, -1,
    	57,  3, 73, 15, 81, 25, 77,  7, 58, 19, 73, 29, 49,  0, 11, 77, 23, 33, -1,
    	57,  4, 73, 16, 81, 25, 77,  8, 58, 20, 73, 29, 49,  0, 12, 77, 24, 33, -1,
    	57,  1, 73, 13, 81, 25, 77,  5, 58, 17, 73, 29, 49,  0,  9, 77, 21, 33, -1,
    	57,  2, 73, 14, 81, 25, 77,  6, 58, 18, 73, 29, 49,  0, 10, 77, 22, 33, -1,
    	57,  3, 73, 15, 81, 25, 77,  7, 58, 19, 73, 29, 49, 37, 11, 77, 23, 33, -1,
    	57,  4, 73, 16, 81, 25, 77,  8, 58, 20, 73, 29, 49,  0, 12, 77, 24, 33, -1,
    	57,  1, 73, 13, 81, 25, 77,  5, 58, 17, 73, 29, 49,  0,  9, 77, 21, 33, -1,
    	57,  2, 73, 14, 81, 25, 77,  6, 58, 18, 73, 29, 49,  0, 10, 77, 22, 33, -1,
    	57,  3, 73, 15, 81, 25, 77,  7, 58, 19, 73, 29, 49,  0, 11, 77, 23, 33, -1,
    	57,  4, 73, 16, 81, 25, 77,  8, 58, 20, 73, 29, 49, 37, 12, 77, 24, 33, -1
    };
    static uint32 tr3_tdm_100[] = { /* TR3_1G_280_FX */
    	 1, 69, 57, 73, 65, 77, 13, 69, 58, 73, 65, 77,  5, 69, 59, 73, 65, 77, 25, 69, 60, 73, 65, 77, -1,  0,
    	 9, 69, 57, 73, 65, 77, 17, 69, 58, 73, 65, 77, 21, 69, 59, 73, 65, 77, 29, 69, 60, 73, 65, 77, -1, 81,
    	 2, 69, 57, 73, 65, 77, 14, 69, 58, 73, 65, 77, 33, 69, 59, 73, 65, 77, 26, 69, 60, 73, 65, 77, -1,  0,
    	 6, 69, 57, 73, 65, 77, 18, 69, 58, 73, 65, 77, -1, 69, 59, 73, 65, 77, 30, 69, 60, 73, 65, 77, -1, 81,
    	10, 69, 57, 73, 65, 77, 22, 69, 58, 73, 65, 77, 37, 69, 59, 73, 65, 77, 34, 69, 60, 73, 65, 77, -1,  0,
    	 3, 69, 57, 73, 65, 77, 15, 69, 58, 73, 65, 77,  7, 69, 59, 73, 65, 77, 27, 69, 60, 73, 65, 77, -1, 81,
    	11, 69, 57, 73, 65, 77, 19, 69, 58, 73, 65, 77, 23, 69, 59, 73, 65, 77, 31, 69, 60, 73, 65, 77, -1,  0,
    	 4, 69, 57, 73, 65, 77, 16, 69, 58, 73, 65, 77, 35, 69, 59, 73, 65, 77, 28, 69, 60, 73, 65, 77, -1, 81,
    	 8, 69, 57, 73, 65, 77, 20, 69, 58, 73, 65, 77, -1, 69, 59, 73, 65, 77, 32, 69, 60, 73, 65, 77, -1, -1,
    	12, 69, 57, 73, 65, 77, 24, 69, 58, 73, 65, 77, 37, 69, 59, 73, 65, 77, 36, 69, 60, 73, 65, 77, -1, 81
    };
    static _soc_tr3_flex_tdm_inf_t flex_tr3_tdm_100 = {
        1, 
        { 26, 26 },
        {  3,  5 },
        {  6,  6 }
    };
    static uint32 tr3_tdm_101[] = { /* 28xGE + 4xXFI + 2xF.HG[42] + 2xHG[42] + 1GE */
    	-1, 69, 57, 73, 65, 77, 13, 69, 58, 73, 65, 77, -1, 69, 59, 73, 65, 77, 25, 69, 60, 73, 65, 77, -1,  0,
    	 9, 69, 57, 73, 65, 77, 17, 69, 58, 73, 65, 77, 21, 69, 59, 73, 65, 77, 29, 69, 60, 73, 65, 77, -1, 81,
    	-1, 69, 57, 73, 65, 77, 14, 69, 58, 73, 65, 77, 33, 69, 59, 73, 65, 77, 26, 69, 60, 73, 65, 77, -1,  0,
    	-1, 69, 57, 73, 65, 77, 18, 69, 58, 73, 65, 77, -1, 69, 59, 73, 65, 77, 30, 69, 60, 73, 65, 77, -1, 81,
    	10, 69, 57, 73, 65, 77, 22, 69, 58, 73, 65, 77, 37, 69, 59, 73, 65, 77, 34, 69, 60, 73, 65, 77, -1,  0,
    	-1, 69, 57, 73, 65, 77, 15, 69, 58, 73, 65, 77, -1, 69, 59, 73, 65, 77, 27, 69, 60, 73, 65, 77, -1, 81,
    	11, 69, 57, 73, 65, 77, 19, 69, 58, 73, 65, 77, 23, 69, 59, 73, 65, 77, 31, 69, 60, 73, 65, 77, -1,  0,
    	-1, 69, 57, 73, 65, 77, 16, 69, 58, 73, 65, 77, 35, 69, 59, 73, 65, 77, 28, 69, 60, 73, 65, 77, -1, 81,
    	-1, 69, 57, 73, 65, 77, 20, 69, 58, 73, 65, 77, -1, 69, 59, 73, 65, 77, 32, 69, 60, 73, 65, 77, -1, -1,
    	12, 69, 57, 73, 65, 77, 24, 69, 58, 73, 65, 77, 37, 69, 59, 73, 65, 77, 36, 69, 60, 73, 65, 77, -1, 81
    };
    static _soc_tr3_flex_tdm_inf_t flex_tr3_tdm_102 = {
        1,
        { 26, 26 },
        {  4,  1 },
        {  6,  6 }
    };

    
    soc_info_t *si;
    int i;
    iarb_tdm_table_entry_t iarb_tdm;
    lls_port_tdm_entry_t lls_tdm;
    uint32 rval;
    
    _soc_tr3_flex_tdm.valid = 0;
#ifdef BCM_HELIX4_SUPPORT
    if (SOC_IS_HELIX4(unit)) {
        _soc_hx4_mmu_tdm_array_init(unit);
    } else
#endif
    {
        switch (_tr3_port_config_id[unit]) {
        case 10:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_10);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_10, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 110:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_110);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_110, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 11:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_11);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_11, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 12:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_12);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_12, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 112:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_112);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_112, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 35:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_35);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_35, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 36:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_36);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_36, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 37:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_37);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_37, sizeof(uint32) * _soc_tr3_tdm_size);
            _soc_tr3_flex_tdm = flex_tr3_tdm_37;
            break;
        case 38:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_38);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_38, sizeof(uint32) * _soc_tr3_tdm_size);
            _soc_tr3_flex_tdm = flex_tr3_tdm_38;
            break;
        case 40:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_40);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_40, sizeof(uint32) * _soc_tr3_tdm_size);
            _soc_tr3_flex_tdm = flex_tr3_tdm_40;
            break;
        case 41:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_41);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_41, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 50:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_50);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_50, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 55:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_55);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_55, sizeof(uint32) * _soc_tr3_tdm_size);
            _soc_tr3_flex_tdm = flex_tr3_tdm_55;
            break;
        case 155:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_155);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_155, sizeof(uint32) * _soc_tr3_tdm_size);
            _soc_tr3_flex_tdm = flex_tr3_tdm_155;
            break;
        case 71:
        case 72:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_71);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_71, sizeof(uint32) * _soc_tr3_tdm_size);
            _soc_tr3_flex_tdm = flex_tr3_tdm_71;
            break;
        case 171:
        case 172:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_171);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_171, sizeof(uint32) * _soc_tr3_tdm_size);
            _soc_tr3_flex_tdm = flex_tr3_tdm_171;
            break;
        case 81:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_81);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_81, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 82:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_82);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_82, sizeof(uint32) * _soc_tr3_tdm_size);
            _soc_tr3_flex_tdm = flex_tr3_tdm_37;
            break;
        case 83:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_83);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_83, sizeof(uint32) * _soc_tr3_tdm_size);
            _soc_tr3_flex_tdm = flex_tr3_tdm_37;
            break;
        case 90:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_90);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_90, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 190:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_190);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_190, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 91:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_91);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_91, sizeof(uint32) * _soc_tr3_tdm_size);
            _soc_tr3_flex_tdm = flex_tr3_tdm_91;
            break;
        case 94:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_94);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_94, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 95:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_95);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_95, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 195:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_195);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_195, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 295:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_295);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_295, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 395:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_395);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_395, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 495:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_495);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_495, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 96:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_96);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_96, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 196:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_196);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_196, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 97:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_97);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_97, sizeof(uint32) * _soc_tr3_tdm_size);
            _soc_tr3_flex_tdm = flex_tr3_tdm_97;
            break;
        case 98:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_98);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_98, sizeof(uint32) * _soc_tr3_tdm_size);
            _soc_tr3_flex_tdm = flex_tr3_tdm_98;
            break;
        case 99:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_99);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_99, sizeof(uint32) * _soc_tr3_tdm_size);
            break;
        case 100:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_100);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_100, sizeof(uint32) * _soc_tr3_tdm_size);
            _soc_tr3_flex_tdm = flex_tr3_tdm_100;
            break;
        case 101:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_101);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_101, sizeof(uint32) * _soc_tr3_tdm_size);
            _soc_tr3_flex_tdm = flex_tr3_tdm_100;
            break;
        case 102:
            _soc_tr3_tdm_size = COUNTOF(tr3_tdm_100);
            sal_memcpy(&_soc_tr3_tdm_arr, &tr3_tdm_100, sizeof(uint32) * _soc_tr3_tdm_size);
            _soc_tr3_flex_tdm = flex_tr3_tdm_102;
            break;
        default:
            return SOC_E_PARAM;
        }
    }

    si = &SOC_INFO(unit);
    assert(_soc_tr3_tdm_size);
    /* Disable IARB TDM before programming... */
    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 1);
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, TDM_WRAP_PTRf,
                      _soc_tr3_tdm_size -1);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));

    if (_soc_tr3_flex_tdm.valid) {
        uint16 j, k, c;
        for (j = 0; j < _tr3_flex_port_data[unit].port_groups; j++) {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "base slot[port]: %d[%d]\n"), _soc_tr3_flex_tdm.base_slot[j],
                                    _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]]));
            if (!_soc_tr3_flex_tdm.cells_per_row[j]) {
                if (_tr3_flex_port_data[unit].ports[j] == 1) {
                    for (i=_soc_tr3_flex_tdm.base_slot[j]+1; i < _soc_tr3_tdm_size; i+=1) {
                        int port_group_range = 
                            _soc_tr3_tdm_arr[i] - _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]];
                        if (port_group_range > 0 && port_group_range <= 3) {
                            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                        (BSL_META_U(unit,
                                                    "arr[%d]: %d->%d\n"), i, _soc_tr3_tdm_arr[i],
                                                    _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]]));
                            _soc_tr3_tdm_arr[i] = _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]];
                        }
                    }
                }
                continue;
            }
            for (i = 0; i < _soc_tr3_tdm_size; i+=_soc_tr3_flex_tdm.cells_per_row[j]) {
                for (k = _soc_tr3_flex_tdm.base_slot[j]; 
                     k < _soc_tr3_flex_tdm.cells_per_row[j]+_soc_tr3_flex_tdm.cell_offset[j];
                     k+=_soc_tr3_flex_tdm.cell_offset[j]) {
                    c = k;
                    /* Some exceptions to deal with slots not aligned on fixed multiples */
                    if (!SOC_IS_HELIX4(unit)) {
                        /* TR3 only */
                        if ((_soc_tr3_flex_tdm.cells_per_row[j] == 25) && (k >= 24)) {
                            continue;
                        }
                        if ((_soc_tr3_flex_tdm.cells_per_row[j] == 26) && (k >= 25)) {
                            continue;
                        }
                        if (_tr3_port_config_id[unit] == 83) {
                            if ((k / _soc_tr3_flex_tdm.cell_offset[j]) == 3) {
                                c++;
                            }
                        } else if (_tr3_port_config_id[unit] == 40) {
                            if ((j == 2) && ((k / _soc_tr3_flex_tdm.cell_offset[j]) == 3)) {
                                 c-=1;
                            }
                            if ((j == 4) && ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 2)) {
                                 c-=1;
                            }
                            if ((j == 5) && ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 2)) {
                                 c+=1;
                            }
                        }
                    } else {
                        /* Helix4 specific */
                        if (_tr3_port_config_id[unit] == 490 || _tr3_port_config_id[unit] == 500 ||
                            _tr3_port_config_id[unit] == 495 || _tr3_port_config_id[unit] == 491 ||
                            _tr3_port_config_id[unit] == 514 || _tr3_port_config_id[unit] == 497 ||
                            _tr3_port_config_id[unit] == 510) {
                            if ((k / _soc_tr3_flex_tdm.cell_offset[j]) == 5) {
                                c--;
                            }
                            if ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 6) {
                                c-=2;
                            }
                        } else if (_tr3_port_config_id[unit] == 460) {
                            if ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 1) {
                                c++;
                            }
                        } else if (_tr3_port_config_id[unit] == 410 || _tr3_port_config_id[unit] == 420) {
                            if ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 7) {
                                c-=3;
                            } else if ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 5) {
                                c-=2;
                            } else if ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 2) {
                                c--;
                            }
                        } else if (_tr3_port_config_id[unit] == 450) {
                            if ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 6) {
                                c-=2;
                            } else if ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 2) {
                                c--;
                            }
                        } else if (_tr3_port_config_id[unit] == 610) {
                            if ((k / _soc_tr3_flex_tdm.cell_offset[j]) > 1 &&
                                (k / _soc_tr3_flex_tdm.cell_offset[j]) < 5) {
                                c--;
                            } else if ((k / _soc_tr3_flex_tdm.cell_offset[j]) == 7) {
                                c-=3;
                            } else if ((k / _soc_tr3_flex_tdm.cell_offset[j]) > 4) {
                                c-=2;
                            }
                        }
                    }
                    if (c >= _soc_tr3_flex_tdm.cells_per_row[j]) {
                        break;
                    }
                    switch (_tr3_flex_port_data[unit].ports[j]) {
                    case 1:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                    (BSL_META_U(unit,
                                                "arr[%d]: %d->%d\n"), i+c, _soc_tr3_tdm_arr[i+c], 
                                                _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]]));
                        _soc_tr3_tdm_arr[i+c] = _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]];
                        break;
                    case 2:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                    (BSL_META_U(unit,
                                                "arr[%d]: %d->%d\n"), i+c, _soc_tr3_tdm_arr[i+c], 
                                                ((k / _soc_tr3_flex_tdm.cell_offset[j]) % 2) ?
                                     (_soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]] + 2) : 
                                     _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]]));
                        _soc_tr3_tdm_arr[i+c] = ((k / _soc_tr3_flex_tdm.cell_offset[j]) % 2) ?
                                   (_soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]] + 2) : 
                                   _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]];
                        break;
                    case 4:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                    (BSL_META_U(unit,
                                                "arr[%d]: %d->%d\n"), i+c, _soc_tr3_tdm_arr[i+c], 
                                                _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]] + 
                                     ((k / _soc_tr3_flex_tdm.cell_offset[j])) % 4));
                        _soc_tr3_tdm_arr[i+c] = _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]] + 
                                                ((k / _soc_tr3_flex_tdm.cell_offset[j]) % 4);
                        break;                        
                    default:
                        break;
                    }
                }
            }
        }
    }
    for (i = 0; i < _soc_tr3_tdm_size; i++) {
        sal_memset(&iarb_tdm, 0, sizeof(iarb_tdm_table_entry_t));
        if (_soc_tr3_tdm_arr[i] == -1) {
            soc_IARB_TDM_TABLEm_field32_set(unit, &iarb_tdm, PORT_NUMf,
                                            127);
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "TDM slot: %d, NOP\n"), i));
        } else {
            soc_IARB_TDM_TABLEm_field32_set(unit, &iarb_tdm, PORT_NUMf,
                                            _soc_tr3_tdm_arr[i]);
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "TDM slot: %d, phy port: %d\n"),
                                    i, _soc_tr3_tdm_arr[i]));
        }
        SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_TABLEm(unit, SOC_BLOCK_ALL, i,
                                                  &iarb_tdm));
        if (0 == (i%2)) {
            /* Two entries per mem entry */
            sal_memset(&lls_tdm, 0, sizeof(lls_port_tdm_entry_t));
            soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm, PORT_ID_0f,
                                          (_soc_tr3_tdm_arr[i] != -1) ?
                                          si->port_p2m_mapping[_soc_tr3_tdm_arr[i]] : 63);
            soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm, PORT_ID_0_ENABLEf, 1);
        } else {
            soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm, PORT_ID_1f,
                                          (_soc_tr3_tdm_arr[i] != -1) ?
                                          si->port_p2m_mapping[_soc_tr3_tdm_arr[i]] : 63);
            soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm, PORT_ID_1_ENABLEf, 1);
            SOC_IF_ERROR_RETURN(WRITE_LLS_PORT_TDMm(unit, SOC_BLOCK_ALL, (i/2),
                                                    &lls_tdm));
            SOC_IF_ERROR_RETURN(WRITE_LLS_PORT_TDMm(unit, SOC_BLOCK_ALL, 512+(i/2),
                                                    &lls_tdm));
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "LLS TDM: %d, [%d],[%d]\n"), i/2,
                                    soc_LLS_PORT_TDMm_field32_get(unit, &lls_tdm, PORT_ID_0f),
                         soc_LLS_PORT_TDMm_field32_get(unit, &lls_tdm, PORT_ID_1f)));
        }
        if ((_soc_tr3_tdm_size%2) && (i == (_soc_tr3_tdm_size-1))) { /* Handle last single odd entry */
            SOC_IF_ERROR_RETURN
                (WRITE_LLS_PORT_TDMm(unit, SOC_BLOCK_ALL, (i/2), &lls_tdm));
            SOC_IF_ERROR_RETURN
                (WRITE_LLS_PORT_TDMm(unit, SOC_BLOCK_ALL, 512+(i/2), &lls_tdm));
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "LLS TDM: %d, [%d],[%d]\n"), i/2,
                                    soc_LLS_PORT_TDMm_field32_get(unit, &lls_tdm, PORT_ID_0f),
                         soc_LLS_PORT_TDMm_field32_get(unit, &lls_tdm, PORT_ID_1f)));
        }
    }

    /*
     * bcmsim: C model cannot support cell based flow
     */
    if (SAL_BOOT_BCMSIM) {
        soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 1);
    } else {
        soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 0);
    }
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, AUX_CMICM_SLOT_ENf, 1); 
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, AUX_AXP_SLOT_ENf, 1);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_LLS_TDM_CAL_CFGr(unit, &rval));
    soc_reg_field_set(unit, LLS_TDM_CAL_CFGr, &rval, END_Af, (_soc_tr3_tdm_size) -1);
    soc_reg_field_set(unit, LLS_TDM_CAL_CFGr, &rval, END_Bf, (_soc_tr3_tdm_size) -1);
    soc_reg_field_set(unit, LLS_TDM_CAL_CFGr, &rval, DEFAULT_PORTf, 58); /* AXP MMU port num */
    soc_reg_field_set(unit, LLS_TDM_CAL_CFGr, &rval, ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_LLS_TDM_CAL_CFGr(unit, rval));
    
    SOC_IF_ERROR_RETURN
        (WRITE_LLS_TDM_OPPORTUNISTIC_SPACINGr(unit, _tr3_tdm_opp_spacing[unit]));
    if (SAL_BOOT_QUICKTURN) {
        SOC_IF_ERROR_RETURN(READ_PASSTHRU_NLF_MTU_CHECKr(unit, &rval));
        soc_reg_field_set(unit, PASSTHRU_NLF_MTU_CHECKr, &rval, MTU_IN_BYTESf,
                          0x3fff);
        SOC_IF_ERROR_RETURN(WRITE_PASSTHRU_NLF_MTU_CHECKr(unit, rval));
    }
    
    return SOC_E_NONE;
}

STATIC int
_soc_tr3_tdm_update(int unit, soc_port_t port, int lanes, int update_hw)
{
    /* update the table values */
    uint8 new_cal;
    uint16 i, j, k, c, p, delta = 0;
    uint32 rval;
    int iter = 0, phy;
    iarb_tdm_table_entry_t iarb_tdm;
    lls_port_tdm_entry_t lls_tdm;
    soc_info_t *si = &SOC_INFO(unit);

    phy = si->port_l2p_mapping[port];
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "Phy port: %d\n"), phy));
    for (j = 0; j < _tr3_flex_port_data[unit].port_groups; j++) {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "base slot[port]: %d[%d]\n"), _soc_tr3_flex_tdm.base_slot[j],
                                _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]]));
        if (!_soc_tr3_flex_tdm.cells_per_row[j]) {
            continue;
        }
        for (i = 0; i < _soc_tr3_tdm_size; i+=_soc_tr3_flex_tdm.cells_per_row[j]) {
            for (k = _soc_tr3_flex_tdm.base_slot[j]; 
                 k < _soc_tr3_flex_tdm.cells_per_row[j]+_soc_tr3_flex_tdm.cell_offset[j];
                 k+=_soc_tr3_flex_tdm.cell_offset[j]) {
                c = k;
                /* Some exceptions - TR3 only */
                if (!SOC_IS_HELIX4(unit)) {
                    if ((_soc_tr3_flex_tdm.cells_per_row[j] == 25) && (k >= 24)) {
                        continue;
                    }
                    if ((_soc_tr3_flex_tdm.cells_per_row[j] == 26) && (k >= 25)) {
                        continue;
                    }
                    if (_tr3_port_config_id[unit] == 83) {
                        if ((k / _soc_tr3_flex_tdm.cell_offset[j]) == 3) {
                            c++;
                        }
                    }
                    if (_tr3_port_config_id[unit] == 40) {
                        if ((j == 2) && ((k / _soc_tr3_flex_tdm.cell_offset[j]) == 3)) {
                             c-=1;
                        }
                        if ((j == 4) && ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 2)) {
                             c-=1;
                        }
                        if ((j == 5) && ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 2)) {
                             c+=1;
                        }
                    }
                } else {
                    /* Helix4 specific */
                    if (_tr3_port_config_id[unit] == 490 || _tr3_port_config_id[unit] == 500 ||
                        _tr3_port_config_id[unit] == 495 || _tr3_port_config_id[unit] == 491 ||
                        _tr3_port_config_id[unit] == 514 || _tr3_port_config_id[unit] == 497 ||
                        _tr3_port_config_id[unit] == 510) {
                        if ((k / _soc_tr3_flex_tdm.cell_offset[j]) == 5) {
                            c--;
                        }
                        if ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 6) {
                            c-=2;
                        }
                    } else if (_tr3_port_config_id[unit] == 460) {
                        if ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 1) {
                            c++;
                        }
                    } else if (_tr3_port_config_id[unit] == 410 || _tr3_port_config_id[unit] == 420) {
                        if ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 7) {
                            c-=3;
                        } else if ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 5) {
                            c-=2;
                        } else if ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 2) {
                            c--;
                        }
                    } else if (_tr3_port_config_id[unit] == 450) {
                        if ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 6) {
                            c-=2;
                        } else if ((k / _soc_tr3_flex_tdm.cell_offset[j]) >= 2) {
                            c--;
                        }
                    } else if (_tr3_port_config_id[unit] == 610) {
                        if ((k / _soc_tr3_flex_tdm.cell_offset[j]) > 1 &&
                            (k / _soc_tr3_flex_tdm.cell_offset[j]) < 5) {
                            c--;
                        } else if ((k / _soc_tr3_flex_tdm.cell_offset[j]) == 7) {
                            c-=3;
                        } else if ((k / _soc_tr3_flex_tdm.cell_offset[j]) > 4) {
                            c-=2;
                        }
                    }
                }
                if (c >= _soc_tr3_flex_tdm.cells_per_row[j]) {
                    break;
                }
                if (k == _soc_tr3_flex_tdm.base_slot[j] &&  _soc_tr3_tdm_arr[i+c] != phy) {
                    break;
                }
                switch(lanes) { /* Note: The meaning of lanes here is how many lanes/slot does a port use */
                    case 4: /* This is a single high speed port */
                        if (_soc_tr3_tdm_arr[i+c] != _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]]) {
                            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                        (BSL_META_U(unit,
                                                    "arr[%d]: %d->%d\n"), i+c, _soc_tr3_tdm_arr[i+c], 
                                                    _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]]));
                            _soc_tr3_tdm_arr[i+c] = _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]];
                            delta++;
                        }
                        break;
                    case 2: /* This is a set of 2 dual lane ports */
                        p = ((k / _soc_tr3_flex_tdm.cell_offset[j]) % 2) ?
                                (_soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]] + 2) : 
                                _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]];
                        if (_soc_tr3_tdm_arr[i+c] != p) {
                            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                        (BSL_META_U(unit,
                                                    "arr[%d]: %d->%d\n"), i+c, _soc_tr3_tdm_arr[i+c], 
                                                    ((k / _soc_tr3_flex_tdm.cell_offset[j]) % 2) ?
                                         (_soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]] + 2) : 
                                         _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]]));
                            _soc_tr3_tdm_arr[i+c] = ((k / _soc_tr3_flex_tdm.cell_offset[j]) % 2) ?
                                       (_soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]] + 2) : 
                                       _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]];
                            delta++;
                        }
                        break;
                    case 1: /* This is a single lane port group of 4 ports */
                        if (_soc_tr3_tdm_arr[i+c] != _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]] + 
                                               ((k / _soc_tr3_flex_tdm.cell_offset[j]) % 4)) {
                            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                        (BSL_META_U(unit,
                                                    "arr[%d]: %d->%d\n"), i+c, _soc_tr3_tdm_arr[i+c], 
                                                    _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]] + 
                                         ((k / _soc_tr3_flex_tdm.cell_offset[j])) % 4));
                            _soc_tr3_tdm_arr[i+c] = _soc_tr3_tdm_arr[_soc_tr3_flex_tdm.base_slot[j]] + 
                                                   ((k / _soc_tr3_flex_tdm.cell_offset[j]) % 4);
                            delta++;
                        }
                        break;                        
                    default:
                        break;
                }
            }
        }
    }
    if (!delta) {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "No LLs TDM change needed..\n")));
        return SOC_E_NONE;
    }
    if (!update_hw) {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "No LLs TDM h/w change requested..\n")));
        return SOC_E_NONE;
    }
    /* Determine current calendar */
    SOC_IF_ERROR_RETURN(READ_LLS_TDM_STATUSr(unit, &rval));
    new_cal = ~(soc_reg_field_get(unit, LLS_TDM_STATUSr, rval, CURRENT_CALENDARf)) & 1;
    j = new_cal * 512;

    /* Check and update h/w with deltas only */
    for (i = 0; i < _soc_tr3_tdm_size; i++) {
        SOC_IF_ERROR_RETURN(READ_IARB_TDM_TABLEm(unit, SOC_BLOCK_ALL, i,
                                                 &iarb_tdm));
        if (_soc_tr3_tdm_arr[i] != -1) {
             if (_soc_tr3_tdm_arr[i] != 
                 soc_IARB_TDM_TABLEm_field32_get(unit, &iarb_tdm, PORT_NUMf)) {
                 soc_IARB_TDM_TABLEm_field32_set(unit, &iarb_tdm, PORT_NUMf,
                                                 _soc_tr3_tdm_arr[i]);
                 LOG_VERBOSE(BSL_LS_SOC_COMMON,
                             (BSL_META_U(unit,
                                         "TDM slot: %d, phy port: %d\n"),
                                         i, _soc_tr3_tdm_arr[i]));
                 SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_TABLEm(unit, SOC_BLOCK_ALL, i,
                                                           &iarb_tdm));
             }
        }
        if (0 == (i%2)) {
            delta = 0;
            SOC_IF_ERROR_RETURN(READ_LLS_PORT_TDMm(unit, SOC_BLOCK_ALL, j+(i/2),
                                                   &lls_tdm));
            if (_soc_tr3_tdm_arr[i] != -1) {
                if (si->port_p2m_mapping[_soc_tr3_tdm_arr[i]] !=
                    soc_LLS_PORT_TDMm_field32_get(unit, &lls_tdm, PORT_ID_0f)) {
                    soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm, PORT_ID_0f,
                                                  si->port_p2m_mapping[_soc_tr3_tdm_arr[i]]);
                    delta = 1;
                    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                (BSL_META_U(unit,
                                            "i_0 %d: %d\n"), i, si->port_p2m_mapping[_soc_tr3_tdm_arr[i]]));
                }
            }
        } else {
            if (_soc_tr3_tdm_arr[i] != -1) {
                if (si->port_p2m_mapping[_soc_tr3_tdm_arr[i]] !=
                    soc_LLS_PORT_TDMm_field32_get(unit, &lls_tdm, PORT_ID_1f)) {
                    soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm, PORT_ID_1f,
                                                  si->port_p2m_mapping[_soc_tr3_tdm_arr[i]]);
                    delta = 1;
                    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                (BSL_META_U(unit,
                                            "i_1 %d: %d\n"), i, si->port_p2m_mapping[_soc_tr3_tdm_arr[i]]));
                }
            }
            if (delta) {
                SOC_IF_ERROR_RETURN(WRITE_LLS_PORT_TDMm(unit, SOC_BLOCK_ALL, j+(i/2),
                                                        &lls_tdm));
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                                        "LLS TDM: %d, [%d],[%d]\n"), j+(i/2),
                                        soc_LLS_PORT_TDMm_field32_get(unit, &lls_tdm, PORT_ID_0f),
                             soc_LLS_PORT_TDMm_field32_get(unit, &lls_tdm, PORT_ID_1f)));
                delta = 0;
            }
        }
        /* Handle last single odd entry */
        if ((_soc_tr3_tdm_size%2) && (i == (_soc_tr3_tdm_size-1)) && delta) {
            SOC_IF_ERROR_RETURN(WRITE_LLS_PORT_TDMm(unit, SOC_BLOCK_ALL, j+(i/2),
                                                    &lls_tdm));
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "LLS TDM: %d, [%d],[%d]\n"), j+(i/2),
                                    soc_LLS_PORT_TDMm_field32_get(unit, &lls_tdm, PORT_ID_0f),
                         soc_LLS_PORT_TDMm_field32_get(unit, &lls_tdm, PORT_ID_1f)));
        }
    }
    /* Switch LLS calendar */
    SOC_IF_ERROR_RETURN(WRITE_LLS_TDM_CAL_CFG_SWITCHr(unit, 1));
    do {
        SOC_IF_ERROR_RETURN(READ_LLS_TDM_STATUSr(unit, &rval));
        sal_udelay(100);
    } while ((iter++ < 100000) && 
             (soc_reg_field_get(unit, LLS_TDM_STATUSr, rval, 
                               CURRENT_CALENDARf) != new_cal) &&
             !(SAL_BOOT_BCMSIM || SAL_BOOT_PLISIM));
    if (iter >= 100000) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "LLS Calendar switch failed !!\n")));
        return SOC_E_INTERNAL;
    }
    SOC_IF_ERROR_RETURN(WRITE_LLS_TDM_CAL_CFG_SWITCHr(unit, 0));
    return SOC_E_NONE;
}

STATIC int
_soc_tr3_ledup_init(int unit)
{
    int ix;
    uint32 rval = 0;
    struct led_remap {
       uint32 reg_addr0;
       uint32 reg_addr1;
       uint32 port0;
       uint32 port1;
       uint32 port2;
       uint32 port3;
    } led_remap[] = {
        { CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r, CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r,
            REMAP_PORT_0f,REMAP_PORT_1f,REMAP_PORT_2f,REMAP_PORT_3f },
        { CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r, CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r,
            REMAP_PORT_4f,REMAP_PORT_5f,REMAP_PORT_6f,REMAP_PORT_7f },
        { CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r, CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r,
            REMAP_PORT_8f,REMAP_PORT_9f,REMAP_PORT_10f,REMAP_PORT_11f },
        { CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r, CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r,
            REMAP_PORT_12f,REMAP_PORT_13f,REMAP_PORT_14f,REMAP_PORT_15f },
        { CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r, CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r,
            REMAP_PORT_16f,REMAP_PORT_17f,REMAP_PORT_18f,REMAP_PORT_19f },
        { CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r, CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r,
            REMAP_PORT_20f,REMAP_PORT_21f,REMAP_PORT_22f,REMAP_PORT_23f },
        { CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r, CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r,
            REMAP_PORT_24f,REMAP_PORT_25f,REMAP_PORT_26f,REMAP_PORT_27f },
        { CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r, CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r,
            REMAP_PORT_28f,REMAP_PORT_29f,REMAP_PORT_30f,REMAP_PORT_31f },
        { CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r, CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r,
            REMAP_PORT_32f,REMAP_PORT_33f,REMAP_PORT_34f,REMAP_PORT_35f },
        { CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r, CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r,
            REMAP_PORT_36f,REMAP_PORT_37f,REMAP_PORT_38f,REMAP_PORT_39f },
        { CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r, CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r,
            REMAP_PORT_40f,REMAP_PORT_41f,REMAP_PORT_42f,REMAP_PORT_43f },
        { CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r, CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r,
            REMAP_PORT_44f,REMAP_PORT_45f,REMAP_PORT_46f,REMAP_PORT_47f },
        { CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r, CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r,
            REMAP_PORT_48f,REMAP_PORT_49f,REMAP_PORT_50f,REMAP_PORT_51f }/*,
        { CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r, CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r,
            REMAP_PORT_52f,REMAP_PORT_53f,REMAP_PORT_54f,REMAP_PORT_55f },
        { CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r, CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r,
            REMAP_PORT_56f,REMAP_PORT_57f,REMAP_PORT_58f,REMAP_PORT_59f },
        { CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r, CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r,
            REMAP_PORT_60f,REMAP_PORT_61f,REMAP_PORT_62f,REMAP_PORT_63f }*/
    };


    /* initialize the led remap register settings */   
    for (ix = 0; ix < COUNTOF(led_remap); ix++) {
        rval = 0;
        soc_reg_field_set(unit, led_remap[ix].reg_addr0, &rval, 
                         led_remap[ix].port0, ix * 4 + 1);
        soc_reg_field_set(unit, led_remap[ix].reg_addr0, &rval, 
                         led_remap[ix].port1, ix * 4 + 2);
        soc_reg_field_set(unit, led_remap[ix].reg_addr0, &rval, 
                         led_remap[ix].port2, ix * 4 + 3);
        soc_reg_field_set(unit, led_remap[ix].reg_addr0, &rval, 
                         led_remap[ix].port3, ix * 4 + 4);
        
        SOC_IF_ERROR_RETURN
            (soc_pci_write(unit, 
                soc_reg_addr(unit, led_remap[ix].reg_addr0, REG_PORT_ANY, 0), 
                rval));
        if (ix < 7) {
            SOC_IF_ERROR_RETURN
                (soc_pci_write(unit, 
                    soc_reg_addr(unit, led_remap[ix].reg_addr1, REG_PORT_ANY, 0), 
                    rval));
        }
    }

    /* configure the LED scan delay cycles */
    SOC_IF_ERROR_RETURN(READ_CMIC_LEDUP0_CTRLr(unit, &rval));
    soc_reg_field_set(unit, CMIC_LEDUP0_CTRLr, &rval, LEDUP_SCAN_START_DELAYf, 11);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_CTRLr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_CMIC_LEDUP1_CTRLr(unit, &rval));
    soc_reg_field_set(unit, CMIC_LEDUP1_CTRLr, &rval, LEDUP_SCAN_START_DELAYf, 4);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_CTRLr(unit, rval));

    rval =0;


    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_0f, 48);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_1f, 47);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_2f, 46);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_3f, 45);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_4f, 44);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_5f, 43);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_6f, 42);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_7f, 41);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_8f, 40);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_9f, 39);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_10f, 38);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_11f, 37);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r(unit, rval));

    /* m CMIC_LEDUP0_PORT_ORDER_REMAP_12_15 REMAP_PORT_15=49 */
    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_15f, 49);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r(unit, rval));


    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_16f, 36);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_17f, 35);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_18f, 34);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_19f, 33);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_20f, 32);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_21f, 31);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_22f, 30);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_23f, 29);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_24f, 28);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_25f, 27);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_26f, 26);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_27f, 25);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_28f, 24);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_29f, 23);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_30f, 22);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_31f, 21);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_32f, 20);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_33f, 19);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_34f, 18);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_35f, 17);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_36f, 16);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_37f, 15);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_38f, 14);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_39f, 13);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_40f, 12);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_41f, 11);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_42f, 10);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_43f, 9);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_44f, 8);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_45f, 7);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_46f, 6);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_47f, 5);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_48f, 4);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_49f, 3);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_50f, 2);
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_51f, 1);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r(unit, rval));


    rval = 0;

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r(unit, rval));


    /*  c1 WC-C0/13/0             CMIC_LEDUP1_PORT_ORDER_REMAP_24_27.REMAP_PORT_27 */
    /*  c1 WC-C0/13/1             CMIC_LEDUP1_PORT_ORDER_REMAP_24_27.REMAP_PORT_26 */
    /*  c1 WC-C0/13/2             CMIC_LEDUP1_PORT_ORDER_REMAP_24_27.REMAP_PORT_25 */

    /*  c1 WC-C0/13/3, WC-C0/16/4 CMIC_LEDUP1_PORT_ORDER_REMAP_24_27.REMAP_PORT_24 */

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_27f, 5);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_26f, 6);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_25f, 7);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_24f, 8);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r(unit, rval));


    /*  c5 WC-C0/14/0             CMIC_LEDUP1_PORT_ORDER_REMAP_20_23.REMAP_PORT_23 */
    /*  c5 WC-C0/14/1             CMIC_LEDUP1_PORT_ORDER_REMAP_20_23.REMAP_PORT_22 */
    /*  c5 WC-C0/14/2             CMIC_LEDUP1_PORT_ORDER_REMAP_20_23.REMAP_PORT_21 */
    /*  c5 WC-C0/14/3             CMIC_LEDUP1_PORT_ORDER_REMAP_20_23.REMAP_PORT_20 */

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_23f, 9);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_22f, 10);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_21f, 11);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_20f, 12);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r(unit, rval));


    /*  c9 WC-C0/15/0             CMIC_LEDUP1_PORT_ORDER_REMAP_16_19.REMAP_PORT_19 */
    /*  c9 WC-C0/15/1             CMIC_LEDUP1_PORT_ORDER_REMAP_16_19.REMAP_PORT_18 */
    /*  c9 WC-C0/15/2             CMIC_LEDUP1_PORT_ORDER_REMAP_16_19.REMAP_PORT_17 */
    /*  c9 WC-C0/15/3, WC-C0/16/4 CMIC_LEDUP1_PORT_ORDER_REMAP_16_19.REMAP_PORT_16 */

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_19f, 13);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_18f, 14);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_17f, 15);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_16f, 16);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r(unit, rval));


    /*  cd WC-C0/16/0             CMIC_LEDUP1_PORT_ORDER_REMAP_12_15.REMAP_PORT_15 */
    /*  cd WC-C0/16/1             CMIC_LEDUP1_PORT_ORDER_REMAP_12_15.REMAP_PORT_14 */
    /*  cd WC-C0/16/2             CMIC_LEDUP1_PORT_ORDER_REMAP_12_15.REMAP_PORT_13 */
    /*  cd WC-C0/16/3, WC-C0/16/4 CMIC_LEDUP1_PORT_ORDER_REMAP_12_15.REMAP_PORT_12 */

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_15f, 17);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_14f, 18);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_13f, 19);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_12f, 20);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r(unit, rval));


    /*  d1 WC-C0/17/0             CMIC_LEDUP1_PORT_ORDER_REMAP_8_11.REMAP_PORT_11 */
    /*  d1 WC-C0/17/1             CMIC_LEDUP1_PORT_ORDER_REMAP_8_11.REMAP_PORT_10 */
    /*  d1 WC-C0/17/2             CMIC_LEDUP1_PORT_ORDER_REMAP_8_11.REMAP_PORT_9 */
    /*  d1 WC-C0/17/3, WC-C0/16/4 CMIC_LEDUP1_PORT_ORDER_REMAP_8_11.REMAP_PORT_8 */

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_11f, 21);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_10f, 22);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_9f, 23);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_8f, 24);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r(unit, rval));


    /*  d5 WC-C0/18/0             CMIC_LEDUP1_PORT_ORDER_REMAP_4_7.REMAP_PORT_7 */
    /*  d5 WC-C0/18/1             CMIC_LEDUP1_PORT_ORDER_REMAP_4_7.REMAP_PORT_6 */
    /*  d5 WC-C0/18/2             CMIC_LEDUP1_PORT_ORDER_REMAP_4_7.REMAP_PORT_5 */
    /*  d5 WC-C0/18/3, WC-C0/16/4 CMIC_LEDUP1_PORT_ORDER_REMAP_4_7.REMAP_PORT_4 */

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_7f, 25);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_6f, 26);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_5f, 27);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_4f, 28);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r(unit, rval));


    /*  d9 WC-C0/19/0             CMIC_LEDUP1_PORT_ORDER_REMAP_0_3.REMAP_PORT_3 */
    /*  d9 WC-C0/19/1             CMIC_LEDUP1_PORT_ORDER_REMAP_0_3.REMAP_PORT_2 */
    /*  d9 WC-C0/19/2             CMIC_LEDUP1_PORT_ORDER_REMAP_0_3.REMAP_PORT_1 */
    /*  d9 WC-C0/19/3, WC-C0/16/4 CMIC_LEDUP1_PORT_ORDER_REMAP_0_3.REMAP_PORT_0 */

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_3f, 29);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_2f, 30);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_1f, 31);
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_0f, 32);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r(unit, rval));


    /*
    Raw SCHAN ops due to missing blocks in certain SKUs
    PORT_LED_CHAIN_CONFIGr
    set rcerror=0
    schan 0x34d00200 0x02029700 0x00000002
    schan 0x34f00200 0x02029700 0x00000002
    schan 0x34e00200 0x02029700 0x00000002
    set rcerror=1
    */

    {
        _soc_reg32_set(unit, 0x8,0, (0x02029700), (0x00000002));
        _soc_reg32_set(unit, 0x9,0, (0x02029700), (0x00000002));
        _soc_reg32_set(unit, 0xa,0, (0x02029700), (0x00000002));
        _soc_reg32_set(unit, 0xb,0, (0x02029700), (0x00000002));
        _soc_reg32_set(unit, 0xc,0, (0x02029700), (0x00000002));
        _soc_reg32_set(unit, 0xd,0, (0x02029700), (0x00000002));
        _soc_reg32_set(unit, 0xe,0, (0x02029700), (0x00000002));
        _soc_reg32_set(unit, 0xf,0, (0x02029700), (0x00000002));
    }

    /* initialize the UP0, UP1 data ram */
    rval = 0;
    for (ix = 0; ix < 256; ix++) {
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_DATA_RAMr(unit,ix, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_DATA_RAMr(unit,ix, rval));
    }
    return SOC_E_NONE;  
}

/* extern int (*_phy_wc40_firmware_set_helper)(int, int, uint8 *,int); */
extern int (*_phy_wcmod_firmware_set_helper[SOC_MAX_NUM_DEVICES])(int, int, uint8 *,int);

STATIC int
tr3_wc_firmware_set(int unit, int port, uint8 *array, int datalen)
{
    int blk, phy_port, wc_inst;

    phy_port = SOC_INFO(unit).port_l2p_mapping[port];
    blk = SOC_PORT_BLOCK(unit, phy_port);

    /* Which WC in this port block?
     * Find port offset, then divide by 4 (lanes per WC)
     */
    if ((phy_port < _soc_tr3_b2pp[blk]) ||
        (phy_port >= (_soc_tr3_b2pp[blk] + 12))) {
        return SOC_E_INTERNAL;
    }
    wc_inst = (phy_port - _soc_tr3_b2pp[blk]) / 4;


    return soc_warpcore_firmware_set(unit, port, array, datalen, wc_inst,
                                     PORT_WC_UCMEM_DATAm,
                                     PORT_WC_UCMEM_CTRLr);
}

int
soc_tr3_port_lanes_gen(int unit, soc_port_t port, int *lanes, soc_block_type_t *pbt)
{
    uint8 match = 0;
    int i, blk, blk_num, p, rv = SOC_E_PORT;
    soc_info_t *si = &SOC_INFO(unit);
    int phy = si->port_l2p_mapping[port];

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "Get lane, port: %d\n"), port));
    *lanes = -1;
    if (pbt) {
        *pbt = SOC_BLK_NONE;
    }
    if (IS_CL_PORT(unit, port) && (IS_CE_PORT(unit, port) || 
        (si->port_speed_max[port] > 106000))) {
        *lanes = 12;
        if (si->port_speed_max[port] <= 106000) {
            *lanes = 10;
        }
        rv = SOC_E_NONE;
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "CE\n")));
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                ": %d\n"), *lanes));
        return rv;
    }
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        blk_num = SOC_BLOCK_INFO(unit, blk).number;
        for (i = 0; i < 4; i++) {
            p = si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk]+i];
            if (p < 0) {
                continue;
            }
            if (p == port) {
                match = 1;
                break;
            }
        } 
        if (!match) {
            continue;
        }
        if (si->port_speed_max[port] == -1) {
            break;
        } 
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "XL\n")));
        if (pbt) {
            *pbt = SOC_BLK_XLPORT;
        }
        rv = SOC_E_NONE;
        if (blk_num == 0) {
            *lanes = 1;
        } else {
            *lanes = 1;
            if (si->port_speed_max[port] > 11000) {
                *lanes = 2;
            }
            if (si->port_speed_max[port] > 21000) {
                *lanes = 4;
            }
        }
        break;
    }
    if (!match) {
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XTPORT) {
            for (i = 0; i < 12; i++) {
                p = si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk]+i];
                if (p < 0) {
                    continue;
                }
                if (p == port) {
                    match = 1;
                    break;
                }
            } 
            if (!match) {
                continue;
            }
            if (si->port_speed_max[port] == -1) {
                break;
            }
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "XT\n")));
            if (pbt) {
                *pbt = SOC_BLK_XTPORT;
            }
            rv = SOC_E_NONE;
            *lanes = 1;
            if (SOC_IS_HELIX4(unit)) {
                if (si->port_speed_max[port] > 1000) {
                    *lanes = 4;
                }
            } else {
                if (si->port_speed_max[port] > 3000) {
                    *lanes = 4;
                }
            }
            break;
        }    
    }
    if (!match) {
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XWPORT) {
            uint8 d_0 = 0, d_1 = 0;
            for (i = 0; i < 4; i++) {
                p = si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk]+i];
                if (p < 0) {
                    continue;
                }
                if (p == port) {
                    match = 1;
                    if (i == 0) {
                        d_0 =  1;
                    } else if (i == 2) {
                        d_1 = 1;
                    }
                    break;
                }
            }
            if (!match) {
                continue;
            }
            if (si->port_speed_max[port] == -1) {
                break;
            }
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "XW\n")));
            if (pbt) {
                *pbt = SOC_BLK_XWPORT;
            }
            rv = SOC_E_NONE;
            *lanes = 1;
            if (si->port_speed_max[port] >= 10000 && si->port_speed_max[port] <= 12000) {
                switch (i) {
                    case 0:
                        *lanes = 4;
                        if (((si->flex_port_p2l_mapping[phy + 1] >= 0) &&
                            (si->flex_port_p2l_mapping[phy + 2] >= 0) &&
                            (si->flex_port_p2l_mapping[phy + 3] >= 0)) || 
                            ((si->flex_port_p2l_mapping[phy + 1] >= 0) && 
                            (si->flex_port_p2l_mapping[phy + 2] < 0) &&
                            (si->flex_port_p2l_mapping[phy + 3] < 0))) {
                            *lanes = 1;
                        } else if ((si->flex_port_p2l_mapping[phy + 1] < 0) &&
                                (si->flex_port_p2l_mapping[phy + 2] >= 0) &&
                                (si->flex_port_p2l_mapping[phy + 3] < 0)) {
                                *lanes = 2;
                        }
                        break;
                    case 1:
                        *lanes = 4;
                        if (((si->flex_port_p2l_mapping[phy - 1] >= 0) &&
                            (si->flex_port_p2l_mapping[phy + 1] >= 0) &&
                            (si->flex_port_p2l_mapping[phy + 2] >= 0)) ||
                            ((si->flex_port_p2l_mapping[phy - 1] >= 0) &&
                            (si->flex_port_p2l_mapping[phy + 1] < 0) &&
                            (si->flex_port_p2l_mapping[phy + 2] < 0))) {
                            *lanes = 1;
                        }
                        break;
                    case 2:
                        *lanes = 4;
                        if ((si->flex_port_p2l_mapping[phy - 2] >= 0) &&
                            (si->flex_port_p2l_mapping[phy - 1] >= 0) &&
                            (si->flex_port_p2l_mapping[phy + 1] >= 0)) {
                            *lanes = 1;
                        } else if ((si->flex_port_p2l_mapping[phy - 2] >= 0) &&
                                (si->flex_port_p2l_mapping[phy - 1] < 0) &&
                                (si->flex_port_p2l_mapping[phy + 1] < 0)) {
                            *lanes = 2;
                        }
                        break;
                    case 3:
                        *lanes = 4;
                        if ((si->flex_port_p2l_mapping[phy - 3] >= 0) &&
                            (si->flex_port_p2l_mapping[phy - 2] >= 0) &&
                            (si->flex_port_p2l_mapping[phy - 1] >= 0)) {
                            *lanes = 1;
                        }
                        break;
                }
            } else if (si->port_speed_max[port] > 12000) {
                *lanes = 4;

                if ((d_0 || d_1) && (si->port_speed_max[port] <= 25000)) {
                    int dual_pair;
                    if (d_0) {
                        dual_pair = si->flex_port_p2l_mapping[phy + 2];
                        if (dual_pair >= 0) {
                            if (si->port_speed_max[dual_pair] > 0) { /* HGd */
                                *lanes = 2;
                            }
                        }
                    } else if (d_1) {
                        dual_pair = si->flex_port_p2l_mapping[phy - 2];
                        if (dual_pair >= 0) {
                            if (si->port_speed_max[dual_pair] > 0) { /* HGd */
                                *lanes = 2;
                            }
                        }
                    }
                }
            }
            break;
        }
    }
    if (!match) {
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_CLPORT) {
            uint8 d_0 = 0, d_1 = 0;
            for (i = 0; i < 12; i++) {
                p = si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk]+i];
                if (p < 0) {
                    continue;
                }
                if (p == port) {
                    match = 1;
                    if (i == 0 || i == 4 || i == 8) {
                        d_0 = 1;
                    } else if (i == 2 || i == 6 || i == 10) {
                        d_1 = 1;
                    }
                    break;
                }
            } 
            if (!match) {
                continue;
            }
            if (si->port_speed_max[port] == -1) {
                break;
            }
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "CL\n")));
            if (pbt) {
                *pbt = SOC_BLK_CLPORT;
            }
            rv = SOC_E_NONE;
            *lanes = 1;
            
            if (si->port_speed_max[port] >= 10000 && si->port_speed_max[port] <= 12000) {
                switch (i%4) {
                case 0:
                    *lanes = 4;
                    if ((si->flex_port_p2l_mapping[phy + 1] >= 0) &&
                        (si->flex_port_p2l_mapping[phy + 2] >= 0) &&
                        (si->flex_port_p2l_mapping[phy + 3] >= 0)) {
                        *lanes = 1;
                    } else if ((si->flex_port_p2l_mapping[phy + 1] < 0) &&
                        (si->flex_port_p2l_mapping[phy + 2] >= 0) &&
                        (si->flex_port_p2l_mapping[phy + 3] < 0)) {
                        *lanes = 2;
                    } else if (_tr3_port_config_id[unit] == 99) { /* 2xXFI case */
                        if ((si->flex_port_p2l_mapping[phy + 1] >= 0) &&
                            (si->flex_port_p2l_mapping[phy + 2] < 0) &&
                            (si->flex_port_p2l_mapping[phy + 3] < 0)) {
                            *lanes = 1;
                        }
                    }
                    break;
                case 1:
                    *lanes = 4;
                    if ((si->flex_port_p2l_mapping[phy - 1] >= 0) &&
                        (si->flex_port_p2l_mapping[phy + 1] >= 0) &&
                        (si->flex_port_p2l_mapping[phy + 2] >= 0)) {
                        *lanes = 1;
                    } else if (_tr3_port_config_id[unit] == 99) { /* 2xXFI case */
                        if ((si->flex_port_p2l_mapping[phy - 1] >= 0) &&
                            (si->flex_port_p2l_mapping[phy + 1] < 0) &&
                            (si->flex_port_p2l_mapping[phy + 2] < 0)) {
                            *lanes = 1;
                        }
                    }
                    break;
                case 2:
                    *lanes = 4;
                    if ((si->flex_port_p2l_mapping[phy - 2] >= 0) &&
                        (si->flex_port_p2l_mapping[phy - 1] >= 0) &&
                        (si->flex_port_p2l_mapping[phy + 1] >= 0)) {
                        *lanes = 1;
                    } else if ((si->flex_port_p2l_mapping[phy - 2] >= 0) &&
                        (si->flex_port_p2l_mapping[phy - 1] < 0) &&
                        (si->flex_port_p2l_mapping[phy + 1] < 0)) {
                        *lanes = 2;
                    }
                    break;
                case 3:
                    *lanes = 4;
                    if ((si->flex_port_p2l_mapping[phy - 3] >= 0) &&
                        (si->flex_port_p2l_mapping[phy - 2] >= 0) &&
                        (si->flex_port_p2l_mapping[phy - 1] >= 0)) {
                        *lanes = 1;
                    }
                    break;
                }
            } else if (si->port_speed_max[port] > 12000) {
                *lanes = 4;
                if ((d_0 || d_1) && (si->port_speed_max[port] <= 25000)) {
                    int dual_pair;
                    if (d_0) {
                        dual_pair = si->flex_port_p2l_mapping[phy + 2];
                        if (dual_pair >= 0) {
                            if (si->port_speed_max[dual_pair] > 0) { /* HGd */
                                *lanes = 2;
                            }
                        }
                    } else if (d_1) {
                        dual_pair = si->flex_port_p2l_mapping[phy - 2];
                        if (dual_pair >= 0) {
                            if (si->port_speed_max[dual_pair] > 0) { /* HGd */
                                *lanes = 2;
                            }
                        }
                    }
                }
            }
            break;
        }
    }
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            ": %d\n"), *lanes));
    return rv;
}

int
soc_tr3_port_lanes_get(int unit, soc_port_t port, int *lanes)
{
    if (!SOC_PORT_VALID(unit, port)) {
        return SOC_E_PORT;
    }
    *lanes = SOC_INFO(unit).port_num_lanes[port];
    return SOC_E_NONE;
}

#define _SOC_TR3_LCPLL0    0
#define _SOC_TR3_LCPLL1    1
#define _SOC_TR3_STOP_CLK  1
#define _SOC_TR3_START_CLK 0

STATIC int
_soc_tr3_hx4_clock_sync(int unit, int pll, int port, int stop_clk) {
    uint32 rval;

    if (SOC_IS_HELIX4(unit)) {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "%s called with port %d (stop_clk = %d)\n"),
                     FUNCTION_NAME(), port, stop_clk));
        sal_usleep(10000);
        switch (pll) {
        case _SOC_TR3_LCPLL0:
            SOC_IF_ERROR_RETURN(READ_TOP_XG_PLL0_CTRL_1r(unit, &rval));
            soc_reg_field_set(unit, TOP_XG_PLL0_CTRL_1r, &rval, HOLD_CHf, stop_clk ? 0x10 : 0);
            SOC_IF_ERROR_RETURN(WRITE_TOP_XG_PLL0_CTRL_1r(unit, rval));
            break;
        case _SOC_TR3_LCPLL1:
            SOC_IF_ERROR_RETURN(READ_TOP_XG_PLL1_CTRL_1r(unit, &rval));
            soc_reg_field_set(unit, TOP_XG_PLL1_CTRL_1r, &rval, HOLD_CHf, stop_clk ? 0x10 : 0);
            SOC_IF_ERROR_RETURN(WRITE_TOP_XG_PLL1_CTRL_1r(unit, rval));
            break;
        default:
            break;
        }
        sal_usleep(10000);
    }
    return SOC_E_NONE;
}

STATIC int
_soc_tr3_set_defip_table_size(int unit, soc_mem_t mem, int size)
{
    soc_persist_t *sop = SOC_PERSIST(unit);
    
    if (mem == L3_DEFIPm) {
        sop->memState[L3_DEFIPm].index_max = size;
        sop->memState[L3_DEFIP_ONLYm].index_max = size;
        sop->memState[L3_DEFIP_DATA_ONLYm].index_max = size;
        sop->memState[L3_DEFIP_HIT_ONLYm].index_max = size;
    } else if (mem == L3_DEFIP_PAIR_128m) {
        sop->memState[L3_DEFIP_PAIR_128m].index_max = size;
        sop->memState[L3_DEFIP_PAIR_128_ONLYm].index_max = size;
        sop->memState[L3_DEFIP_PAIR_128_DATA_ONLYm].index_max = size;
        sop->memState[L3_DEFIP_PAIR_128_HIT_ONLYm].index_max = size;
    } else {
        return SOC_E_PARAM;
    }

    return SOC_E_NONE;
}

int
_soc_tr3_misc_init(int unit)
{
    static const soc_field_t port_field[] = {
        PORT0f, PORT1f, PORT2f, PORT3f,
        PORT4f, PORT5f, PORT6f, PORT7f,
        PORT8f, PORT9f, PORT10f, PORT11f
    };
    static const soc_field_t core_mode_field[] = {
        XPORT0_CORE_PORT_MODEf,
        XPORT1_CORE_PORT_MODEf,
        XPORT2_CORE_PORT_MODEf
    };
    static const soc_field_t phy_mode_field[] = {
        XPORT0_PHY_PORT_MODEf,
        XPORT1_PHY_PORT_MODEf,
        XPORT2_PHY_PORT_MODEf
    };
    static const soc_field_t xpc_gmii_enable_field[] = {
        XPC0_GMII_MII_ENABLEf,
        XPC1_GMII_MII_ENABLEf,
        XPC2_GMII_MII_ENABLEf
    };
    static const soc_field_t vfp_tcam_blksel_field[] = {
        SLICE_3_Uf, SLICE_3_Lf, SLICE_2_Uf, SLICE_2_Lf,
        SLICE_1_Uf, SLICE_1_Lf, SLICE_0_Uf, SLICE_0_Lf
    };
    static const soc_field_t efp_tcam_blksel_field[] = {
        SLICE_3f, SLICE_2f,
        SLICE_1f, SLICE_0f
    };   
    soc_info_t *si;
    uint64 val64;
    uint32 rval, entry[SOC_MAX_MEM_WORDS], tmpval;
    soc_pbmp_t pbmp;
    int speed, divisor, dividend, delay;
    int i, axp, lpt, port, phy_port, blk, blk_num, bindex;
    int parity_enable, phy, lane, port_attr, maxsp = 8;
    uint32 mac_mode = MAC_MODE_INDEP, core_mode[3], phy_mode[3];
    uint16 cl_port_valid[2], xt_port_valid[4], xl_port_valid[2], xw_port_valid[3];
#ifdef BCM_ISM_SUPPORT
    int total, rv = SOC_E_NONE;
    uint8 banks[_SOC_ISM_MAX_BANKS], count;
    uint32 bank_size[_SOC_ISM_MAX_BANKS];
#endif
    uint16      dev_id;
    uint8       rev_id;
    soc_field_t fields[2];
    uint32      values[2];
    uint32      hash_control;
    static int rtag7_field_width[] = { 16, 16, 4, 16, 8, 8, 16, 16 };
    int index, index_count, sub_sel, offset;
    int ism_defip_max_index = 0;
    int ism_defip_pair_128_size = soc_mem_index_count(unit, L3_DEFIP_PAIR_128m);
    int ism_defip_size = soc_mem_index_count(unit, L3_DEFIPm);
    int max_tcams = SOC_L3_DEFIP_MAX_TCAMS_GET(unit);
    int tcam_depth = SOC_L3_DEFIP_TCAM_DEPTH_GET(unit);

    si = &SOC_INFO(unit);
    soc_cm_get_id(unit, &dev_id, &rev_id);

    if (SAL_BOOT_QUICKTURN) {
        sop_memstate_t *memState;

        memState = SOC_PERSIST(unit)->memState;
        memState[L2_USER_ENTRYm].index_max  = 7;
        memState[MY_STATION_TCAMm].index_max  = 7;
    }

    /* Stop the mem scan task before all of the parity init takes place */
    SOC_IF_ERROR_RETURN(soc_generic_ser_mem_scan_stop(unit));

    parity_enable = soc_property_get(unit, spn_PARITY_ENABLE, TRUE);

    if (parity_enable) {
#ifdef BCM_HELIX4_SUPPORT
        if (SOC_IS_HELIX4(unit)) {
            (void)_soc_hx4_tcam_ser_init(unit);
            /* SER list registration moved into HX4 init because
             * SER TCAM info structure isn't in this file's scope. */
        } else
#endif /* BCM_HELIX4_SUPPORT */
        {
            (void)_soc_tr3_ser_init(unit);
#ifdef INCLUDE_MEM_SCAN
            soc_mem_scan_ser_list_register(unit, FALSE,
                                           _soc_tr3_ser_parity_info[unit]);
#endif /* INCLUDE_MEM_SCAN */
        }
        SOC_SER_SUPPORT(unit) = 1;
        memset(&_tr3_ser_functions, 0, sizeof(soc_ser_functions_t));
        _tr3_ser_functions._soc_ser_fail_f = &soc_tr3_ser_fail;
        _tr3_ser_functions._soc_ser_parity_error_cmicm_intr_f =
            &soc_tr3_process_func_intr;
        soc_ser_function_register(unit, &_tr3_ser_functions);
    }
    
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit,
                                IFP_METER_WRITE_LAST_REFRESH_NUMBERr,
                                REG_PORT_ANY, WRITE_ENf, 1));
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, ING_SVM_CONTROLr, REG_PORT_ANY,
                                DISABLE_CPU_WRITE_TO_LAST_REFRESH_NUMBERf, 0));

    if (!SOC_IS_RELOADING(unit) && !SOC_WARM_BOOT(unit)) {
        uint32 data[SOC_MAX_MEM_WORDS];
        
        SOC_IF_ERROR_RETURN(soc_tr3_mem_clear(unit));
        
        if (!SOC_IS_HELIX4(unit)) {
            
            if (soc_feature(unit, soc_feature_global_meter)) { 
                SOC_IF_ERROR_RETURN
                    (soc_mem_read(unit, SVM_POLICY_TABLEm, MEM_BLOCK_ANY, 0, data));
            }
            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, SVM_MACROFLOW_INDEX_TABLEm, MEM_BLOCK_ANY, 0, data));
            
            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_0m, MEM_BLOCK_ANY, 0, data));
            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_1m, MEM_BLOCK_ANY, 0, data));
            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_2m, MEM_BLOCK_ANY, 0, data));
            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_3m, MEM_BLOCK_ANY, 0, data));
            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_4m, MEM_BLOCK_ANY, 0, data));
            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_5m, MEM_BLOCK_ANY, 0, data));
            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_6m, MEM_BLOCK_ANY, 0, data));
            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_7m, MEM_BLOCK_ANY, 0, data));
            switch (dev_id) {
            case BCM56640_DEVICE_ID:
            case BCM56643_DEVICE_ID: 
            case BCM56644_DEVICE_ID:
            case BCM56648_DEVICE_ID:
            case BCM56649_DEVICE_ID:
                SOC_IF_ERROR_RETURN
                    (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_8m, MEM_BLOCK_ANY, 0, data));
                SOC_IF_ERROR_RETURN
                    (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_9m, MEM_BLOCK_ANY, 0, data));
                SOC_IF_ERROR_RETURN
                    (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_10m, MEM_BLOCK_ANY, 0, data));
                SOC_IF_ERROR_RETURN
                    (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_11m, MEM_BLOCK_ANY, 0, data));
                SOC_IF_ERROR_RETURN
                    (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_12m, MEM_BLOCK_ANY, 0, data));
                SOC_IF_ERROR_RETURN
                    (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_13m, MEM_BLOCK_ANY, 0, data));
                SOC_IF_ERROR_RETURN
                    (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_14m, MEM_BLOCK_ANY, 0, data));
                SOC_IF_ERROR_RETURN
                    (soc_mem_read(unit, ING_FLEX_CTR_OFFSET_TABLE_15m, MEM_BLOCK_ANY, 0, data));
                break;
            default:
                break;
            }
        }
    }
    
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, IFP_METER_WRITE_LAST_REFRESH_NUMBERr,
                                REG_PORT_ANY, WRITE_ENf, 0));
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, ING_SVM_CONTROLr, REG_PORT_ANY,
                                DISABLE_CPU_WRITE_TO_LAST_REFRESH_NUMBERf, 1));

    /* Read ESM config now as it effects ser init */
    if (soc_feature(unit, soc_feature_esm_support)) {
        SOC_IF_ERROR_RETURN(soc_tr3_esm_init_read_config(unit));
    }

    /* Disable IBOD FIFO full interrupts */
    SOC_IF_ERROR_RETURN(WRITE_IBOD_INTR_MASKr(unit, 0));

    (void)_soc_tr3_parity_enable_all(unit, parity_enable);
    if (!parity_enable) {
        /* Clear AXP SER calculations if parity isn't enabled */
        SOC_IF_ERROR_RETURN(WRITE_AXP_SM_MEM_ECC_GEN_CONTROLr(unit, 0));
    }

    /* Disable unused flex counter pools */
    switch (dev_id) {
    case BCM56540_DEVICE_ID:
    case BCM56541_DEVICE_ID: 
    case BCM56542_DEVICE_ID:
    case BCM56543_DEVICE_ID:
    case BCM56544_DEVICE_ID:
    case BCM56545_DEVICE_ID:
    case BCM56546_DEVICE_ID:
    case BCM56044_DEVICE_ID:
    case BCM56045_DEVICE_ID:
    case BCM56046_DEVICE_ID:
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, ING_FLEX_CTR_COUNTER_UPDATE_CONTROL_8r, 
                                    REG_PORT_ANY, COUNTER_POOL_ENABLEf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, ING_FLEX_CTR_COUNTER_UPDATE_CONTROL_9r, 
                                    REG_PORT_ANY, COUNTER_POOL_ENABLEf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, ING_FLEX_CTR_COUNTER_UPDATE_CONTROL_10r, 
                                    REG_PORT_ANY, COUNTER_POOL_ENABLEf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, ING_FLEX_CTR_COUNTER_UPDATE_CONTROL_11r, 
                                    REG_PORT_ANY, COUNTER_POOL_ENABLEf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, ING_FLEX_CTR_COUNTER_UPDATE_CONTROL_12r, 
                                    REG_PORT_ANY, COUNTER_POOL_ENABLEf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, ING_FLEX_CTR_COUNTER_UPDATE_CONTROL_13r, 
                                    REG_PORT_ANY, COUNTER_POOL_ENABLEf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, ING_FLEX_CTR_COUNTER_UPDATE_CONTROL_14r, 
                                    REG_PORT_ANY, COUNTER_POOL_ENABLEf, 0));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, ING_FLEX_CTR_COUNTER_UPDATE_CONTROL_15r, 
                                    REG_PORT_ANY, COUNTER_POOL_ENABLEf, 0));
        break;
    default:
        break;
    }
    
    /* Enable Green mode power savings for Ranger+ */
    switch (dev_id) {
    case BCM56044_DEVICE_ID:
    case BCM56045_DEVICE_ID:
    case BCM56046_DEVICE_ID:
        /* Disable unused ING_L3_NEXT_HOP table */
        COMPILER_64_SET(val64, 0xffffffff, 0xffffff00);
        SOC_IF_ERROR_RETURN(WRITE_IRSEL2_NEXT_HOP_PDA_CONTROLr(unit, val64));
        /* Disable unused EGR_L3_NEXT_HOP table */
        SOC_IF_ERROR_RETURN(WRITE_EGR_L3_NEXT_HOP_PDA_CTRL0r(unit, 0xffff0000));
        SOC_IF_ERROR_RETURN(WRITE_EGR_L3_NEXT_HOP_PDA_CTRL1r(unit, 0xffffffff));
        SOC_IF_ERROR_RETURN(WRITE_EGR_L3_NEXT_HOP_PDA_CTRL2r(unit, 0xffffffff));
        SOC_IF_ERROR_RETURN(WRITE_EGR_L3_NEXT_HOP_PDA_CTRL3r(unit, 0xffffffff));
        /* Disable unused L3_IPMC table */
        SOC_IF_ERROR_RETURN(WRITE_IRSEL2_IPMC_PDA_CONTROLr(unit, 0xfff0));
        /* Disable unused LPM TCAM mems */
        SOC_IF_ERROR_RETURN(WRITE_L3_DEFIP_CAM_DBGCTRL5r(unit, 0));
        /* Disable comparison opeartions on unused VFP TCAM entries */
        rval = 0;
        for (i = 0; i < 8; i++) {
            /*           
               In VFP_TCAM_BLKSEL register 2 bits are allocated for each tcam 
               in each slice.Setting lower bit enables comparison operation
               on upper half of the TCAM and setting upper bit enables 
               comparison  operation on lower half of the TCAM.In Ranger+ VFP,
               only 1/4th of total entries in a slice are used i.e In each slice
               lower half of upper TCAM and lower TCAM are unused.
               Since VFP has 4 slices and each slice has two tcams int it, this 
               is looping 8 times. 
             */ 
             soc_reg_field_set(unit, VFP_TCAM_BLKSELr, &rval,
                               vfp_tcam_blksel_field[i], 0x1);
        }
        SOC_IF_ERROR_RETURN(WRITE_VFP_TCAM_BLKSELr(unit, rval));

        /* Disable comparison opeartions on unused EFP TCAM entries */
        rval = 0;
        for (i = 0; i < 4; i++) {
            /*
               In EFP_TCAM_BLKSEL register 2 bits are allocated for each tcam 
               in each slice.Setting lower bit enables comparison operation
               on upper half of the TCAM and setting upper bit enables 
               comparison  operation on lower half of the TCAM.In Ranger+ EFP,
               only half of total entries in a slice are used i.e In each slice
               lower half of the single TCAM available is  unused.Since EFP has
               4 slices ahd each slice has only single TCAM in it, this is 
               looping 4 times. 
             */  
             soc_reg_field_set(unit, EFP_TCAM_BLKSELr, &rval,
                               efp_tcam_blksel_field[i], 0x1);
        }
        SOC_IF_ERROR_RETURN(WRITE_EFP_TCAM_BLKSELr(unit, rval));
        break;
    default:
        break;
    }

#ifdef BCM_ISM_SUPPORT
    /* Main ISM h/w config */
    rv = soc_ism_hw_config(unit);
    if (SOC_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Error configuring ISM h/w !!\n")));
        return rv;
    }
    /* Misc ISM h/w configs */
    rv = soc_ism_table_hash_config(unit, SOC_ISM_MEM_VLAN_XLATE, 1);
    rv |= soc_ism_table_hash_config(unit, SOC_ISM_MEM_L2_ENTRY, 1);
    rv |= soc_ism_table_hash_config(unit, SOC_ISM_MEM_L3_ENTRY, 1);
    rv |= soc_ism_table_hash_config(unit, SOC_ISM_MEM_EP_VLAN_XLATE, 1);
    rv |= soc_ism_table_hash_config(unit, SOC_ISM_MEM_MPLS, 1);
    if (SOC_FAILURE(rv)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Error configuring ISM hash zero_lsb !!\n")));
        return SOC_E_INTERNAL;
    }
    SOC_IF_ERROR_RETURN(soc_ism_get_total_banks(unit, &total));
    SOC_IF_ERROR_RETURN(soc_ism_hash_max_offset_get(unit, &offset));
    offset = offset/total;
    
    rv = soc_ism_get_banks(unit, SOC_ISM_MEM_VLAN_XLATE, banks, bank_size, 
                           &count);
    if (rv  < 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "ISM VLAN_XLATE bank enumeration retrieval failed\n")));
        return rv;
    }
    for (i = 0; i < count; i++) {
        /* Offset 0 is CRC32 low */
        rv = soc_ism_hash_offset_config(unit, banks[i], i*offset);
        if (rv  < 0) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "ISM VLAN_XLATE bank %d hash offset set failure\n"),
                                  banks[i]));
            return rv;
        }
    }
    rv = soc_ism_get_banks(unit, SOC_ISM_MEM_L2_ENTRY, banks, bank_size, 
                           &count);
    if (rv  < 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "ISM L2 bank enumeration retrieval failed\n")));
        return rv;
    }
    for (i = 0; i < count; i++) {
        /* Offset 0 is CRC32 low */
        rv = soc_ism_hash_offset_config(unit, banks[i], i*offset);
        if (rv  < 0) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "ISM L2 bank %d hash offset set failure\n"), banks[i]));
            return rv;
        }
    }
    rv = soc_ism_get_banks(unit, SOC_ISM_MEM_L3_ENTRY,
                                   banks, bank_size, &count);
    if (rv  < 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "ISM L3 bank enumeration retrieval failed\n")));
        return rv;
    }
    for (i = 0; i < count; i++) {
        /* Offset 0 is CRC32 low */
        rv = soc_ism_hash_offset_config(unit, banks[i], i*offset);
        if (rv  < 0) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "ISM L3 bank %d hash offset set failure\n"), banks[i]));
            return rv;
        }
    }
    rv = soc_ism_get_banks(unit, SOC_ISM_MEM_EP_VLAN_XLATE,
                                   banks, bank_size, &count);
    if (rv  < 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "ISM EP_VLAN_XLATE bank enumeration retrieval failed\n")));
        return rv;
    }
    for (i = 0; i < count; i++) {
        /* Offset 0 is CRC32 low */
        rv = soc_ism_hash_offset_config(unit, banks[i], i*offset);
        if (rv  < 0) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "ISM EP_VLAN_XLATE bank %d hash offset set failure\n"),
                                  banks[i]));
            return rv;
        }
    }
    rv = soc_ism_get_banks(unit, SOC_ISM_MEM_MPLS,
                                   banks, bank_size, &count);
    if (rv  < 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "ISM MPLS bank enumeration retrieval failed\n")));
        return rv;
    }
    for (i = 0; i < count; i++) {
        /* Offset 0 is CRC32 low */
        rv = soc_ism_hash_offset_config(unit, banks[i], i*offset);
        if (rv  < 0) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "ISM MPLS bank %d hash offset set failure\n"),
                                  banks[i]));
            return rv;
        }
    }
#endif

    SOC_IF_ERROR_RETURN(soc_tr3_init_port_mapping(unit));

    sal_memset(entry, 0, sizeof(cpu_pbm_entry_t));
    soc_mem_pbmp_field_set(unit, CPU_PBMm, entry, BITMAPf, &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, CPU_PBMm, MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(cpu_pbm_2_entry_t));
    soc_mem_pbmp_field_set(unit, CPU_PBM_2m, entry, BITMAPf, &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, CPU_PBM_2m, MEM_BLOCK_ALL, 0, entry));

    SOC_PBMP_CLEAR(pbmp);
    PBMP_ALL_ITER(unit, port) {
        if (IS_LB_PORT(unit, port) ||
            (si->port_group[port] >= 2 && si->port_group[port] <= 3)) {
            SOC_PBMP_PORT_ADD(pbmp, port);
        }
    }

    sal_memset(cl_port_valid, 0, sizeof(cl_port_valid));
    sal_memset(xt_port_valid, 0, sizeof(xt_port_valid));
    sal_memset(xl_port_valid, 0, sizeof(xl_port_valid));
    sal_memset(xw_port_valid, 0, sizeof(xw_port_valid));

    for (phy_port = 1; phy_port < SOC_MAX_PHY_PORTS; phy_port++) {
        /* Only enable the required subports */
        port = si->flex_port_p2l_mapping[phy_port];
        if (port < 0) {
            continue;
        }
        blk = SOC_PORT_BLOCK(unit, phy_port);
        bindex = SOC_PORT_BINDEX(unit, phy_port);
        blk_num = SOC_BLOCK_INFO(unit, blk).number;
        if (!SOC_PORT_VALID(unit, port)) {
            continue;
        }
        if (IS_CL_PORT(unit, port)) {
            cl_port_valid[blk_num] |= 1 << bindex;
        } else if (IS_XT_PORT(unit, port)) {
            xt_port_valid[blk_num] |= 1 << bindex;
        } else if (IS_XL_PORT(unit, port)) {
            xl_port_valid[blk_num] |= 1 << bindex;
        } else if (IS_XW_PORT(unit, port)) {
            xw_port_valid[blk_num] |= 1 << bindex;
        }
    }

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_CLPORT) {
        blk_num = SOC_BLOCK_INFO(unit, blk).number;
        if (_soc_tr3_port_speed_max[_soc_tr3_b2pp[blk]] >= 100000) {
            mac_mode = MAC_MODE_AGGR;
            port = si->port_p2l_mapping[_soc_tr3_b2pp[blk]];
            /* Put in reset */
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, PORT_MAC_CONTROLr, port,
                                        CMAC_RESETf, 1));
            sal_udelay(10);
            rval = 0;
            soc_reg_field_set(unit, PORT_MODE_REGr, &rval, MAC_MODEf,
                              mac_mode);
            SOC_IF_ERROR_RETURN(WRITE_PORT_MODE_REGr(unit, port, rval));
            /* Release from reset */
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, PORT_MAC_CONTROLr, port,
                                        CMAC_RESETf, 0));
        } else {
            port = -1;
            for (phy = 0; phy < _SOC_TR3_PHY_PER_PORT_BLOCK; phy++) {
                int base_lane = (phy * _SOC_TR3_LANES_PER_PHY);
                core_mode[phy] = CORE_MODE_NOTDM;
                phy_mode[phy] = PHY_MODE_SINGLE;
                speed = _soc_tr3_port_speed_max[_soc_tr3_b2pp[blk] + base_lane];
                if (speed > 0) {
                    core_mode[phy] = CORE_MODE_QUAD;
                    phy_mode[phy] = PHY_MODE_QUAD;
                }
                if ((speed >= 10000) && (speed <= 12000)) {
                    core_mode[phy] = CORE_MODE_SINGLE; /* XAUI */
                    if (si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] + base_lane] >= 0) {
                        if ((((si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] +
                              base_lane + 1]) >= 0) && 
                             ((si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] +
                               base_lane + 2]) >= 0) &&
                             ((si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] +
                               base_lane + 3]) >= 0)) || ((_tr3_port_config_id[unit] == 99) &&
                             (((si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] +
                              base_lane + 1]) >= 0) && 
                             ((si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] +
                               base_lane + 2]) < 0) &&
                             ((si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] +
                               base_lane + 3]) < 0)))) {
                            core_mode[phy] = CORE_MODE_QUAD; /* XFI */
                        } else if (((si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] +
                                     base_lane + 1]) < 0) && 
                                   ((si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] +
                                     base_lane + 2]) >= 0) &&
                                   ((si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] +
                                     base_lane + 3]) < 0)) {
                            core_mode[phy] = CORE_MODE_DUAL; /* RXAUI */
                        }
                    }
                } else if (speed > 12000) {
                    core_mode[phy] = CORE_MODE_SINGLE;
                    phy_mode[phy] = PHY_MODE_SINGLE;
                    if (si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] + base_lane] >= 0) {
                        if (((si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] +
                              base_lane + 1]) < 0) &&
                            ((si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] +
                              base_lane + 2]) >= 0) &&
                            ((si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] +
                              base_lane + 3]) < 0)) { /* HIGIG-Duo */
                            core_mode[phy] = CORE_MODE_DUAL;
                            phy_mode[phy] = PHY_MODE_DUAL;
                        }
                    }
                }
                for (lane = 0; lane < _SOC_TR3_LANES_PER_PHY; lane++) {
                    if (port < 0) {
                        port = si->port_p2l_mapping[_soc_tr3_b2pp[blk] +
                               base_lane + lane];
                        if (SOC_PORT_VALID(unit, port)) {
                            break;
                        } else {
                            port = -1;
                        }
                    }
                }
            }
            if (port < 0) { /* Block not in use */
                continue;
            }

            /* Put in reset */
            rval = 0;
            soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                              XMAC0_RESETf, 1);
            soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                              XMAC1_RESETf, 1);
            soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                              XMAC2_RESETf, 1);
            SOC_IF_ERROR_RETURN(WRITE_PORT_MAC_CONTROLr(unit, port, rval));
            /* Configure core and phy modes */
            rval = 0;
            for (phy = 0; phy < _SOC_TR3_PHY_PER_PORT_BLOCK; phy++) {
                soc_reg_field_set(unit, PORT_MODE_REGr, &rval,
                                  core_mode_field[phy], core_mode[phy]);
                soc_reg_field_set(unit, PORT_MODE_REGr, &rval,
                                  phy_mode_field[phy], phy_mode[phy]);
            }
            SOC_IF_ERROR_RETURN(WRITE_PORT_MODE_REGr(unit, port, rval));
            /* Release from reset */
            rval = 0;
            soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                              XMAC0_RESETf, 0);
            soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                              XMAC1_RESETf, 0);
            soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                              XMAC2_RESETf, 0);
            SOC_IF_ERROR_RETURN(WRITE_PORT_MAC_CONTROLr(unit, port, rval));
        }
        /* Reset MIB counter */
        if (cl_port_valid[blk_num]) {
            rval = 0;
            soc_reg_field_set(unit, PORT_MIB_RESETr, &rval, CLR_CNTf,
                              cl_port_valid[blk_num]);
            SOC_IF_ERROR_RETURN(WRITE_PORT_MIB_RESETr(unit, port, rval));
            SOC_IF_ERROR_RETURN(WRITE_PORT_MIB_RESETr(unit, port, 0));
        }
        /* Enable subports */
        rval = 0;
        for (bindex = 0; bindex < 12; bindex++) {
            if (cl_port_valid[blk_num] & (1 << bindex)) {
                soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval,
                                  port_field[bindex], 1);
            }
        }
        SOC_IF_ERROR_RETURN(WRITE_PORT_ENABLE_REGr(unit, port, rval));
        /* Configure the LED intra port delay */
        rval = 2;
        SOC_IF_ERROR_RETURN(WRITE_PORT_LED_CHAIN_CONFIGr(unit, port, rval));

        /* Clear per block PORT_EHG memories */
        SOC_IF_ERROR_RETURN
            (soc_mem_clear(unit, PORT_EHG_RX_TUNNEL_DATAm, blk, TRUE));
        SOC_IF_ERROR_RETURN
            (soc_mem_clear(unit, PORT_EHG_RX_TUNNEL_MASKm, blk, TRUE));
        SOC_IF_ERROR_RETURN
            (soc_mem_clear(unit, PORT_EHG_TX_TUNNEL_DATAm, blk, TRUE));
    }

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XTPORT) {
        blk_num = SOC_BLOCK_INFO(unit, blk).number;
        port = -1;
        for (phy = 0; phy < _SOC_TR3_PHY_PER_PORT_BLOCK; phy++) {
            int base_lane = (phy * _SOC_TR3_LANES_PER_PHY);
            core_mode[phy] = CORE_MODE_QUAD;
            phy_mode[phy] = PHY_MODE_SINGLE;
            speed = _soc_tr3_port_speed_max[_soc_tr3_b2pp[blk] + base_lane];
            if (speed > 3000) {
                core_mode[phy] = CORE_MODE_SINGLE;
                phy_mode[phy] = PHY_MODE_DUAL;
            } else if (speed > 0) {
                core_mode[phy] = CORE_MODE_QUAD;
                phy_mode[phy] = PHY_MODE_QUAD;
            }
            for (lane = 0; lane < _SOC_TR3_LANES_PER_PHY; lane++) {
                if (port < 0) {
                    port = si->port_p2l_mapping[_soc_tr3_b2pp[blk] + base_lane + lane];
                    if (SOC_PORT_VALID(unit, port)) {
                        break;
                    } else {
                        port = -1;
                    }
                }
            }
        }
        if (port < 0) { /* Block not in use */
            continue;
        }

        rval = 0;
        /* Put in reset */
        soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                          XMAC0_RESETf, 1);
        soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                          XMAC1_RESETf, 1);
        soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                          XMAC2_RESETf, 1);
        SOC_IF_ERROR_RETURN(WRITE_PORT_MAC_CONTROLr(unit, port, rval));
        /* Configure core and phy modes */
        rval = 0;
        for (phy = 0; phy < _SOC_TR3_PHY_PER_PORT_BLOCK; phy++) {
            soc_reg_field_set(unit, PORT_MODE_REGr, &rval,
                              core_mode_field[phy], core_mode[phy]);
            soc_reg_field_set(unit, PORT_MODE_REGr, &rval,
                              phy_mode_field[phy], phy_mode[phy]);
            soc_reg_field_set(unit, PORT_MODE_REGr, &rval, 
                              xpc_gmii_enable_field[phy],
                              ((core_mode[phy] == CORE_MODE_QUAD) && 
                               (!SOC_IS_HELIX4(unit)) ) ? 1 : 0);
        }
        SOC_IF_ERROR_RETURN(WRITE_PORT_MODE_REGr(unit, port, rval));
        /* Release from reset */
        rval = 0;
        soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                          XMAC0_RESETf, 0);
        soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                          XMAC1_RESETf, 0);
        soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                          XMAC2_RESETf, 0);
        SOC_IF_ERROR_RETURN(WRITE_PORT_MAC_CONTROLr(unit, port, rval));

        /* Reset MIB counter */
        if (xt_port_valid[blk_num]) {
            rval = 0;
            soc_reg_field_set(unit, PORT_MIB_RESETr, &rval, CLR_CNTf,
                              xt_port_valid[blk_num]);
            SOC_IF_ERROR_RETURN(WRITE_PORT_MIB_RESETr(unit, port, rval));
            SOC_IF_ERROR_RETURN(WRITE_PORT_MIB_RESETr(unit, port, 0));
        }
        /* Enable subports */
        rval = 0;
        for (bindex = 0; bindex < 12; bindex++) {
            if (xt_port_valid[blk_num] & (1 << bindex)) {
                soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval,
                                  port_field[bindex], 1);
            }
        }
        SOC_IF_ERROR_RETURN(_soc_tr3_hx4_clock_sync(unit, _SOC_TR3_LCPLL0, port,
                                                    _SOC_TR3_STOP_CLK));
        SOC_IF_ERROR_RETURN(WRITE_PORT_ENABLE_REGr(unit, port, rval));
        SOC_IF_ERROR_RETURN(_soc_tr3_hx4_clock_sync(unit, _SOC_TR3_LCPLL0, port,
                            _SOC_TR3_START_CLK));
        
        /* Configure the LED intra port delay */
        rval = 2;
        SOC_IF_ERROR_RETURN(WRITE_PORT_LED_CHAIN_CONFIGr(unit, port, rval));

        /* Clear per block PORT_EHG memories */
        SOC_IF_ERROR_RETURN
            (soc_mem_clear(unit, PORT_EHG_RX_TUNNEL_DATAm, blk, TRUE));
        SOC_IF_ERROR_RETURN
            (soc_mem_clear(unit, PORT_EHG_RX_TUNNEL_MASKm, blk, TRUE));
        SOC_IF_ERROR_RETURN
            (soc_mem_clear(unit, PORT_EHG_TX_TUNNEL_DATAm, blk, TRUE));
    }

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        blk_num = SOC_BLOCK_INFO(unit, blk).number;
        port = SOC_BLOCK_PORT(unit, blk);
        if (port < 0) {
            continue;
        }
        core_mode[0] = CORE_MODE_QUAD;
        phy_mode[0] = PHY_MODE_QUAD;
        /* XL0 only operates in Quad (single 1G) mode */
        if (blk_num != 0) {
            maxsp = 4;
            if (si->port_speed_max[port] > 11000) {
                core_mode[0] = CORE_MODE_DUAL;
                phy_mode[0] = PHY_MODE_DUAL;
            }
            if (si->port_speed_max[port] > 21000) {
                core_mode[0] = CORE_MODE_SINGLE;
                phy_mode[0] = PHY_MODE_SINGLE;
            }
        } else {
            maxsp = 1;
            si->management_port = port; /* XL0 */
        }
        /* Put in reset */
        rval = 0;
        soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                          XMAC0_RESETf, 1);
        SOC_IF_ERROR_RETURN(WRITE_PORT_MAC_CONTROLr(unit, port, rval));
        /* Configure core and phy modes */
        rval = 0;
        soc_reg_field_set(unit, PORT_MODE_REGr, &rval, core_mode_field[0],
                          core_mode[0]);
        soc_reg_field_set(unit, PORT_MODE_REGr, &rval, phy_mode_field[0],
                          phy_mode[0]);
        /* Only set XPC on XL0 */
        soc_reg_field_set(unit, PORT_MODE_REGr, &rval, 
                          xpc_gmii_enable_field[0],
                          ((maxsp == 1) && (!SOC_IS_HELIX4(unit)) &&
                           (phy_mode[0] == PHY_MODE_QUAD)) ? 1 : 0);
        SOC_IF_ERROR_RETURN(WRITE_PORT_MODE_REGr(unit, port, rval));
        /* Release from reset */
        rval = 0;
        soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                          XMAC0_RESETf, 0);
        SOC_IF_ERROR_RETURN(WRITE_PORT_MAC_CONTROLr(unit, port, rval));
        /* Enable subports */
        rval = 0;
        for (bindex = 0; bindex < maxsp; bindex++) {
            if (xl_port_valid[blk_num] & (1 << bindex)) {
                soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval,
                                  port_field[bindex], 1);
            }
        }
        SOC_IF_ERROR_RETURN(WRITE_PORT_ENABLE_REGr(unit, port, rval));
        /* Configure the LED intra port delay */
        rval = 2;
        SOC_IF_ERROR_RETURN(WRITE_PORT_LED_CHAIN_CONFIGr(unit, port, rval));

        /* Clear per block PORT_EHG memories */
        sal_memset(entry, 0, sizeof(entry));
        for (i = 0; i < 16; i++) {
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, PORT_EHG_RX_TUNNEL_DATAm, blk, i, entry));
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, PORT_EHG_RX_TUNNEL_MASKm, blk, i, entry));
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, PORT_EHG_TX_TUNNEL_DATAm, blk, i, entry));
        }
    }

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XWPORT) {
        blk_num = SOC_BLOCK_INFO(unit, blk).number;
        port = SOC_BLOCK_PORT(unit, blk);
        if (port < 0) {
            continue;
        }
        core_mode[1] = core_mode[2] = CORE_MODE_NOTDM;
        phy_mode[1] = phy_mode[2] = 0;
        rval = 0;
        /* XW0/1/2 operates in:
        *      - Quad (single 1G and single XFI)
        *      - Dual (two HGd and two XFI (XFI ports are contiguous))
        *      - Single (HGd, HG, 40G)
        */
        if (_soc_tr3_port_speed_max[_soc_tr3_b2pp[blk]] < 10000) {
            core_mode[0] = CORE_MODE_QUAD;
            phy_mode[0] = PHY_MODE_QUAD;
            maxsp = 4;
            soc_reg_field_set(unit, PORT_MODE_REGr, &rval,
                              xpc_gmii_enable_field[0], 
                              (!SOC_IS_HELIX4(unit)) ? 1 : 0);
        } else if (_soc_tr3_port_speed_max[_soc_tr3_b2pp[blk]] >= 10000 &&
                   _soc_tr3_port_speed_max[_soc_tr3_b2pp[blk]] < 21000) {
            if (((si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] + 1]) < 0) &&
                ((si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] + 2]) >= 0) &&
                ((si->flex_port_p2l_mapping[_soc_tr3_b2pp[blk] + 3]) < 0)) {
                /* RXAUI */
                core_mode[0] = CORE_MODE_DUAL;
                phy_mode[0] = PHY_MODE_DUAL;
                maxsp = 3;
            } else {
                core_mode[0] = CORE_MODE_QUAD;
                phy_mode[0] = PHY_MODE_QUAD;
                maxsp = 4; /* 2 */
            }
        } else if (_soc_tr3_port_speed_max[_soc_tr3_b2pp[blk]] >= 21000 &&
                   _soc_tr3_port_speed_max[_soc_tr3_b2pp[blk]] < 40000) {
            /* Differentiate between HG and HGd */
            if (xw_port_valid[blk_num] & (1 << 2)) {
                /* If port2 in the Port block is valid this is HGd */
                core_mode[0] = CORE_MODE_DUAL;
                phy_mode[0] = PHY_MODE_DUAL;
                maxsp = 3;
            } else {
                core_mode[0] = CORE_MODE_SINGLE;
                phy_mode[0] = PHY_MODE_SINGLE;
                maxsp = 1;
            }
        } else if (_soc_tr3_port_speed_max[_soc_tr3_b2pp[blk]] >= 40000) {
            core_mode[0] = CORE_MODE_SINGLE;
            phy_mode[0] = PHY_MODE_SINGLE;
            maxsp = 1;
        }
        /* Put in reset */
        {
            uint32 rval1 = 0;
            soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval1,
                              XMAC0_RESETf, 1);
            SOC_IF_ERROR_RETURN(WRITE_PORT_MAC_CONTROLr(unit, port, rval1));
        }
        /* Configure core and phy modes */        
        soc_reg_field_set(unit, PORT_MODE_REGr, &rval, core_mode_field[0],
                          core_mode[0]);
        soc_reg_field_set(unit, PORT_MODE_REGr, &rval, phy_mode_field[0],
                          phy_mode[0]);
        SOC_IF_ERROR_RETURN(WRITE_PORT_MODE_REGr(unit, port, rval));
        /* Release from reset */
        rval = 0;
        soc_reg_field_set(unit, PORT_MAC_CONTROLr, &rval,
                          XMAC0_RESETf, 0);
        SOC_IF_ERROR_RETURN(WRITE_PORT_MAC_CONTROLr(unit, port, rval));
        /* Enable subports */
        rval = 0;
        for (bindex = 0; bindex < maxsp; bindex++) {
            if (xw_port_valid[blk_num] & (1 << bindex)) {
                soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval,
                                  port_field[bindex], 1);
            }
        }
        SOC_IF_ERROR_RETURN(_soc_tr3_hx4_clock_sync(unit, _SOC_TR3_LCPLL0, port,
                                                    _SOC_TR3_STOP_CLK));
        SOC_IF_ERROR_RETURN(WRITE_PORT_ENABLE_REGr(unit, port, rval));
        SOC_IF_ERROR_RETURN(_soc_tr3_hx4_clock_sync(unit, _SOC_TR3_LCPLL0, port,
                            _SOC_TR3_START_CLK));
        /* Configure the LED intra port delay */
        rval = 2;
        SOC_IF_ERROR_RETURN(WRITE_PORT_LED_CHAIN_CONFIGr(unit, port, rval));

        /* Clear per block PORT_EHG memories */
        for (i = 0; i < 16; i++) {
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, PORT_EHG_RX_TUNNEL_DATAm, blk, i, entry));
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, PORT_EHG_RX_TUNNEL_MASKm, blk, i, entry));
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, PORT_EHG_TX_TUNNEL_DATAm, blk, i, entry));
        }
    }

    sal_memset(entry, 0, sizeof(egr_ing_port_entry_t));
    soc_mem_field32_set(unit, EGR_ING_PORTm, entry, PORT_TYPEf, 1);
    PBMP_HG_ITER(unit, port) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, PORT_CONFIGr, port, HIGIG_MODEf, 1));
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, EGR_ING_PORTm, MEM_BLOCK_ALL, port, entry));
    }
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, EGR_ING_PORTm, MEM_BLOCK_ALL, si->cpu_hg_index,
                       entry));

	/* Enable pri/cfi remarking on egress ports. */
	rval = 0;
	soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, REMARK_OUTER_DOT1Pf,
			1);
	PBMP_ALL_ITER(unit, port) {
		SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1r(unit, port, rval));
	}
    
    PBMP_ALL_ITER(unit, port) {
        if (IS_CPU_PORT(unit, port)) {
            continue;
        }
        /* Set loopback port type */
        if (IS_LB_PORT(unit, port)) {
            soc_mem_field32_set(unit, EGR_ING_PORTm, entry, PORT_TYPEf, 2);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, EGR_ING_PORTm, MEM_BLOCK_ALL, port, entry));
            continue;
        }
        /* Set max packet size that is used in statistic counter update */
        
        SOC_IF_ERROR_RETURN(WRITE_PORT_CNTMAXSIZEr(unit, port, 16383));
    }

    /* Enable 1588 indication in Higig extension header */
    if (SOC_PBMP_NOT_NULL(PBMP_HG_ALL(unit))) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, HG_EH_CONTROLr, REG_PORT_ANY,
                                    EH_1588_INDICATION_ENABLEf, 1));

        COMPILER_64_ZERO(val64);
        SOC_IF_ERROR_RETURN(READ_EGR_HG_EH_CONTROL_64r(unit, &val64));
        soc_reg64_field32_set(unit, EGR_HG_EH_CONTROL_64r, &val64,
                                 EH_1588_INDICATION_ENABLEf, 1);
        SOC_IF_ERROR_RETURN(WRITE_EGR_HG_EH_CONTROL_64r(unit, val64));
    }

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, MISCCONFIGr, &rval, METERING_CLK_ENf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, AUX_ARB_CONTROL_2r, REG_PORT_ANY,
                                STORM_CONTROL_REFRESH_ENABLEf, 1));

    /* Adjust storm control refresh rate to 8000/sec (1 token per 125 us) */
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, REFRESH_COUNT_CONTROLr, REG_PORT_ANY,
                                STORM_CONTROL_REFRESH_MAXf, 0xf));

    /* AXP configuration */
    if (soc_feature(unit, soc_feature_axp)) {
        for (axp = 0; axp < SOC_AXP_NLF_NUM; axp++) {
            SOC_IF_ERROR_RETURN
                (READ_AXP_CH_NLF_PORT_MAPPINGr(unit, axp, &rval));
            soc_reg_field_set(unit, AXP_CH_NLF_PORT_MAPPINGr, &rval,
                          NLF_PORT_NUMf, AXP_PORT(unit, axp));
            SOC_IF_ERROR_RETURN
                (WRITE_AXP_CH_NLF_PORT_MAPPINGr(unit, axp, rval));
        }
        for (lpt = 0; lpt < SOC_AXP_LPT_NUM; lpt++) {
            port_attr = SOC_AXP_EPP_USE_SGLP;
            switch (lpt) {
            case SOC_AXP_LPT_WLAN_ENCAP:
                port = AXP_PORT(unit, SOC_AXP_NLF_WLAN_ENCAP);
                break;
            case SOC_AXP_LPT_WLAN_DECAP:
                port = AXP_PORT(unit, SOC_AXP_NLF_WLAN_DECAP);
                port_attr = SOC_AXP_EPP_USE_SVP;
                break;
            case SOC_AXP_LPT_DPI_SM:
                port = AXP_PORT(unit, SOC_AXP_NLF_SM);
                break;
            default:
                port = AXP_PORT(unit, SOC_AXP_NLF_PASSTHRU);
            }
            SOC_IF_ERROR_RETURN
                (soc_mem_field32_modify(unit, ING_NLF_PORT_MAPm, lpt,
                                        PORT_NUMf, port));

            /* USE_SVP for WLAN_DECAP, otherwise USE_SGLP in SOURCE_TRUNK_MAP 
             * TABLE to get LPORT index. 
             */
            SOC_IF_ERROR_RETURN
                (soc_mem_field32_modify(unit, EGR_AXP_PORT_PROPERTYm, lpt,
                                        SELf, port_attr)); 
        }

        rval = 0;
        soc_reg_field_set(unit, IP_TO_AXP_CREDIT_TRANSFERr, 
                          &rval, NUM_OF_CREDITSf, 0x10);
        soc_reg_field_set(unit, IP_TO_AXP_CREDIT_TRANSFERr,
                          &rval, TRANSFER_ENABLEf, 1);
        SOC_IF_ERROR_RETURN(WRITE_IP_TO_AXP_CREDIT_TRANSFERr(unit, rval));

        SOC_IF_ERROR_RETURN(READ_AXP_WRX_MASTER_CTRLr(unit, &rval));
        soc_reg_field_set(unit, AXP_WRX_MASTER_CTRLr, &rval, CREDIT_TO_AXP_ENABLEf, 1);
        SOC_IF_ERROR_RETURN(WRITE_AXP_WRX_MASTER_CTRLr(unit, rval));

        rval = 0;
        soc_reg_field_set(unit, AXP_WTX_ICREDIT_CTLr, &rval, CREDIT_ENf, 1);
        SOC_IF_ERROR_RETURN(WRITE_AXP_WTX_ICREDIT_CTLr(unit, rval));

        for (axp = 0; axp < 4; axp++) {
            SOC_IF_ERROR_RETURN(READ_AXP_CH_NLFIB_PTRr(unit, axp, &rval));
            soc_reg_field_set(unit, AXP_CH_NLFIB_PTRr, &rval, START_PTRf, axp*160);
            tmpval = (axp + 1)*160 - 1;
            if (tmpval >= 512) {
                tmpval = 511;
            }
            soc_reg_field_set(unit, AXP_CH_NLFIB_PTRr, &rval, END_PTRf, tmpval);
            SOC_IF_ERROR_RETURN(WRITE_AXP_CH_NLFIB_PTRr(unit, axp, rval));

            SOC_IF_ERROR_RETURN(READ_AXP_CH_NLFOB_CTRLr(unit, axp, &rval));
            soc_reg_field_set(unit, AXP_CH_NLFOB_CTRLr, &rval, CREDIT_ENf, 1);
            SOC_IF_ERROR_RETURN(WRITE_AXP_CH_NLFOB_CTRLr(unit, axp, rval));

            rval = 0;
            soc_reg_field_set(unit, AXP_CH_MAX_MMU_REQr, &rval, REQ_MAXf, 0x18);
            SOC_IF_ERROR_RETURN(WRITE_AXP_CH_MAX_MMU_REQr(unit, axp, rval));
        }

        rval = 0;
        soc_reg_field_set(unit, UCQ_CONFIGr, &rval, WAMU_QUEUE_BASEf, 
             si->port_uc_cosq_base[AXP_PORT(unit, SOC_AXP_NLF_WLAN_DECAP)]);
        SOC_IF_ERROR_RETURN(WRITE_UCQ_CONFIGr(unit, rval));

        rval = 0;
        soc_reg_field_set(unit, AXP_CH_MMU_REQ_ENr, &rval, ENABLEf, 0xf);
        SOC_IF_ERROR_RETURN(WRITE_AXP_CH_MMU_REQ_ENr(unit, rval));

        /* initializing default hashing scheme */
        SOC_IF_ERROR_RETURN
            (soc_reg_read_any_block(unit, AXP_WRX_SVP_HASH_CTRLr, &hash_control));
        soc_reg_field_set(unit, AXP_WRX_SVP_HASH_CTRLr, &hash_control, SELECT_Af,
            FB_HASH_CRC32_UPPER);
        soc_reg_field_set(unit, AXP_WRX_SVP_HASH_CTRLr, &hash_control, SELECT_Bf,
            FB_HASH_CRC32_LOWER);

        SOC_IF_ERROR_RETURN
            (soc_reg_write_all_blocks(unit, AXP_WRX_SVP_HASH_CTRLr, hash_control));
    }

    /*
     * Egress Enable
     */
    sal_memset(entry, 0, sizeof(egr_enable_entry_t));
    soc_mem_field32_set(unit, EGR_ENABLEm, entry, PRT_ENABLEf, 1);
    PBMP_ALL_ITER(unit, port) {
        if (IS_AXP_PORT(unit, port)) {
            /* Physical port table index doesn't exist for AXP ports */
            continue;
        }
        phy_port = si->port_l2p_mapping[port];
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, phy_port, entry));
        /* cache num of port lanes */
        (void)soc_tr3_port_lanes_gen(unit, port, &si->port_num_lanes[port], NULL);
    }

    sal_memset(entry, 0, sizeof(epc_link_bmap_entry_t));
    soc_mem_pbmp_field_set(unit, EPC_LINK_BMAPm, entry, PORT_BITMAPf,
                           &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN(WRITE_EPC_LINK_BMAPm(unit, MEM_BLOCK_ALL, 0, entry));

    SOC_IF_ERROR_RETURN(READ_ING_CONFIG_64r(unit, &val64));
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &val64,
                          APPLY_EGR_MASK_ON_L2f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &val64,
                          APPLY_EGR_MASK_ON_L3f, 1);
    SOC_IF_ERROR_RETURN(WRITE_ING_CONFIG_64r(unit, val64));

    /* set to allow Mirror bit in Module Header */
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EGR_CONFIG_1r, REG_PORT_ANY, 
                                RING_MODEf, 1));

    /* Multicast range initialization */
    SOC_IF_ERROR_RETURN
        (soc_hbx_higig2_mcast_sizes_set(unit,
             soc_property_get(unit, spn_HIGIG2_MULTICAST_VLAN_RANGE,
                              SOC_HBX_MULTICAST_RANGE_DEFAULT),
             soc_property_get(unit, spn_HIGIG2_MULTICAST_L2_RANGE,
                              SOC_HBX_MULTICAST_RANGE_DEFAULT),
             soc_property_get(unit, spn_HIGIG2_MULTICAST_L3_RANGE,
                              SOC_HBX_MULTICAST_RANGE_DEFAULT)));

    /* Initialize FCOE standard Headers */
    SOC_IF_ERROR_RETURN(_soc_tr3_fcoe_config_init(unit)); 

    /*
     * Set external MDIO freq to
     * 9.38MHz (450MHz), 8.65MHz (415MHz), or 6.56MHz (315 MHz)
     * target_freq = core_clock_freq * DIVIDEND / DIVISOR / 2
     */
    divisor = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVISOR, 24);
    dividend = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVIDEND, 1);
    rval = 0;
    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval,
                      DIVISORf, divisor);
    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval,
                      DIVIDENDf, dividend);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUSTr(unit, rval));

    /*
     * Set internal MDIO freq to
     * 37.5MHz (450MHz), 34.58MHz (415MHz), or 26.25MHz (315 MHz)
     * Valid range is from 2.5MHz to 40MHz
     * target_freq = core_clock_freq * DIVIDEND / DIVISOR / 2
     */
    divisor = soc_property_get(unit, spn_RATE_INT_MDIO_DIVISOR, 18);
    dividend = soc_property_get(unit, spn_RATE_INT_MDIO_DIVIDEND, 1);
    rval = 0;
    soc_reg_field_set(unit, CMIC_RATE_ADJUST_INT_MDIOr, &rval,
                      DIVISORf, divisor);
    soc_reg_field_set(unit, CMIC_RATE_ADJUST_INT_MDIOr, &rval,
                      DIVIDENDf, dividend);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUST_INT_MDIOr(unit, rval));

    delay = soc_property_get(unit, spn_MDIO_OUTPUT_DELAY, -1);
    if (delay >= 1  && delay <= 15) {
        SOC_IF_ERROR_RETURN(READ_CMIC_MIIM_CONFIGr(unit, &rval));
        soc_reg_field_set(unit, CMIC_MIIM_CONFIGr, &rval, MDIO_OUT_DELAYf,
                          delay);
        SOC_IF_ERROR_RETURN(WRITE_CMIC_MIIM_CONFIGr(unit, rval));
    }

    /* Enable IPFIX : default register value disable IPFIX. */
    if (soc_feature(unit, soc_feature_ipfix)) {
        SOC_IF_ERROR_RETURN(READ_ING_IPFIX_CONFIGr(unit, &rval));
        soc_reg_field_set(unit, ING_IPFIX_CONFIGr, &rval, DISABLE_ALLf, 0);
        SOC_IF_ERROR_RETURN(WRITE_ING_IPFIX_CONFIGr(unit, rval));
        
        SOC_IF_ERROR_RETURN(READ_EGR_IPFIX_CONFIGr(unit, &rval));
        soc_reg_field_set(unit, EGR_IPFIX_CONFIGr, &rval, DISABLE_ALLf, 0);
        SOC_IF_ERROR_RETURN(WRITE_EGR_IPFIX_CONFIGr(unit, rval));
    }

    if ((!SOC_IS_HELIX4(unit)) && (rev_id & 0xF0)) {
        SOC_IF_ERROR_RETURN(READ_EGR_Q_BEGINr(unit, &rval));
        soc_reg_field_set(unit, EGR_Q_BEGINr, &rval,
                          L2_TUNNEL_DSCP_REMARK_SELf, 1);
        SOC_IF_ERROR_RETURN(WRITE_EGR_Q_BEGINr(unit, rval));
    }

    /* Setup SW2_FP_DST_ACTION_CONTROL */
    fields[0] = HGTRUNK_RES_ENf;
    values[0] = 1;
    fields[1] = LAG_RES_ENf;
    values[1] = 1;
    SOC_IF_ERROR_RETURN(soc_reg_fields32_modify(unit,
                SW2_FP_DST_ACTION_CONTROLr, REG_PORT_ANY, 2, fields, values));

#ifdef BCM_HELIX4_SUPPORT
    /* initialize LED UP0 */
    if (SOC_IS_HELIX4(unit)) {
        SOC_IF_ERROR_RETURN(_soc_hx4_ledup_init(unit));
    } else
#endif /* BCM_HELIX4_SUPPORT */
    {
        SOC_IF_ERROR_RETURN(_soc_tr3_ledup_init(unit));
    }

    if (soc_mspi_init(unit) != SOC_E_NONE) {
        LOG_WARN(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                             "unit %d : MSPI Init Failed\n"), unit));
    }

    /*    _phy_wc40_firmware_set_helper = tr3_wc_firmware_set; */
    _phy_wcmod_firmware_set_helper[unit] = tr3_wc_firmware_set;

    /* Initialize external TCAM */
    if (soc_feature(unit, soc_feature_esm_support) && 
        SOC_CONTROL(unit)->tcam_info) {
        /* initialize the ESMIF too */
        rv = soc_tr3_esmif_init(unit);
        if (rv < 0) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "ESM if initialization failed\n")));
            return rv;
        }
        /* Check if we need to set the size of L3_DEFIP and L3_DEFIP_PAIR_128 
         * to 0
         */
        if (SOC_MEM_IS_ENABLED(unit, EXT_IPV6_128_DEFIPm) &&
            soc_mem_index_count(unit, EXT_IPV6_128_DEFIPm)) {
            /* set size L3_DEFIP_PAIR_128m to 0 */
            ism_defip_pair_128_size = 0;
        }

        if (SOC_MEM_IS_ENABLED(unit, EXT_IPV4_DEFIPm) &&
            soc_mem_index_count(unit, EXT_IPV4_DEFIPm) &&
            SOC_MEM_IS_ENABLED(unit, EXT_IPV6_64_DEFIPm) &&
            soc_mem_index_count(unit, EXT_IPV6_64_DEFIPm)) {
            /* set size of L3_DEFIPm to 0 */
            ism_defip_size = 0;
        }

        if (ism_defip_size == 0) {
            SOC_IF_ERROR_RETURN(_soc_tr3_set_defip_table_size(unit,
                                                              L3_DEFIPm, -1));
        } else {
            if (ism_defip_pair_128_size == 0) {
                ism_defip_max_index = (max_tcams * tcam_depth) - 1;
                SOC_IF_ERROR_RETURN(_soc_tr3_set_defip_table_size(unit,
                                             L3_DEFIPm, ism_defip_max_index));
                soc_l3_defip_indexes_init(unit, 0);
            }
        }

        if (ism_defip_pair_128_size == 0) {
            SOC_IF_ERROR_RETURN(_soc_tr3_set_defip_table_size(unit,
                                                       L3_DEFIP_PAIR_128m, -1));
        } else {
            if (ism_defip_size == 0) {
                ism_defip_max_index = ((max_tcams * tcam_depth) >> 1) - 1;
                SOC_IF_ERROR_RETURN(_soc_tr3_set_defip_table_size(unit,
                                      L3_DEFIP_PAIR_128m, ism_defip_max_index));
                soc_l3_defip_indexes_init(unit, ism_defip_max_index + 1);
            }
        }
        if (ism_defip_size == 0 && ism_defip_pair_128_size == 0) {
            soc_l3_defip_indexes_init(unit, 0);
        }

    } else if (!SOC_IS_HELIX4(unit)) {
        /* put ESMIF in bypass */
        rv = READ_ESMIF_INIT_CONFIGr(unit, &rval);
        if (rv < 0) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Reading ESMIF_INIT_CONFIG failed !!\n")));
            return rv;
        }
        soc_reg_field_set(unit, ESMIF_INIT_CONFIGr, &rval, 
                        IESMIF_BYPASS_ENABLEf, 1);
        rv = WRITE_ESMIF_INIT_CONFIGr(unit, rval);
        if (rv < 0) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Writing ESMIF_INIT_CONFIG failed !!\n")));
            return rv;
        }
        /* power down IESMIF memories */
        rv = WRITE_IESMIF_MEMORY_CONTROLr(unit, 3);
        if (rv < 0) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Writing IESMIF_MEMORY_CONTROL failed !!\n")));
            return rv;
        }
    }
    if (soc_feature(unit, soc_feature_esm_correction)) {
        rv = soc_tr3_esm_recovery_start(unit);  
        if (rv < 0) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Creating ESM recovery thread failed\n")));
            return rv;
        }
    }
    /* Populate and enable RTAG7 Macro flow offset table */
    if (soc_mem_is_valid(unit, RTAG7_FLOW_BASED_HASHm)) {
        index_count = soc_mem_index_count(unit, RTAG7_FLOW_BASED_HASHm);
        sal_memset(entry, 0, sizeof(rtag7_flow_based_hash_entry_t));
        for (index = 0; index < index_count; ) {
            for (sub_sel = 0; sub_sel < 8 && index < index_count; sub_sel++) {
                for (offset = 0;
                     offset < rtag7_field_width[sub_sel] && index < index_count;
                     offset++) {
                    soc_mem_field32_set(unit, RTAG7_FLOW_BASED_HASHm, &entry,
                                        SUB_SEL_ECMPf, sub_sel);
                    soc_mem_field32_set(unit, RTAG7_FLOW_BASED_HASHm, &entry,
                                        OFFSET_ECMPf, offset);
                    SOC_IF_ERROR_RETURN
                        (soc_mem_write(unit, RTAG7_FLOW_BASED_HASHm,
                                       MEM_BLOCK_ANY, index, &entry));
                    index++;
                }
            }
        }
        rval = 0;
        soc_reg_field_set(unit, RTAG7_HASH_SELr, &rval, USE_FLOW_SEL_ECMPf, 1);
        soc_reg_field_set(unit, RTAG7_HASH_SELr, &rval,
                                                USE_FLOW_SEL_TRILL_ECMPf, 1);
        SOC_IF_ERROR_RETURN(WRITE_RTAG7_HASH_SELr(unit, rval));
    }
    if (parity_enable) {
        SOC_IF_ERROR_RETURN(soc_generic_ser_mem_scan_start(unit));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_tr3_port_control(int unit, soc_port_t port, soc_block_type_t pbt, 
                      uint8 enable)
{
    int blk, phy;
    soc_info_t *si = &SOC_INFO(unit);

    phy = si->port_l2p_mapping[port];
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "%s port: log %d, phy %d\n"), FUNCTION_NAME(), port, phy));

    switch (pbt) {
    case SOC_BLK_XLPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MAC_CONTROLr, port,
                                            XMAC0_RESETf, enable ? 0 : 1));
                return SOC_E_NONE;
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Invalid port !!\n")));
            }        
        }
        break;
    case SOC_BLK_XWPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XWPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MAC_CONTROLr, port,
                                            XMAC0_RESETf, enable ? 0 : 1));
                return SOC_E_NONE;
            }
        }
        break;
    case SOC_BLK_XTPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XTPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MAC_CONTROLr, port,
                                            XMAC0_RESETf, enable ? 0 : 1));
                return SOC_E_NONE;
            } else if (phy >= _soc_tr3_b2pp[blk]+4 && phy <= _soc_tr3_b2pp[blk]+7) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MAC_CONTROLr, port,
                                            XMAC1_RESETf, enable ? 0 : 1));
                return SOC_E_NONE;
            } else if (phy <= _soc_tr3_b2pp[blk]+11) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MAC_CONTROLr, port,
                                            XMAC2_RESETf, enable ? 0 : 1));
                return SOC_E_NONE;
            }
        }
        break;
    case SOC_BLK_CLPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_CLPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MAC_CONTROLr, port,
                                            XMAC0_RESETf, enable ? 0 : 1));
                return SOC_E_NONE;
            } else if (phy >= _soc_tr3_b2pp[blk]+4 && phy <= _soc_tr3_b2pp[blk]+7) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MAC_CONTROLr, port,
                                            XMAC1_RESETf, enable ? 0 : 1));
                return SOC_E_NONE;
            } else if (phy <= _soc_tr3_b2pp[blk]+11) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MAC_CONTROLr, port,
                                            XMAC2_RESETf, enable ? 0 : 1));
                return SOC_E_NONE;
            }
        }
        break;
    default:
        return SOC_E_PORT;
    }
    return SOC_E_PORT;
}

STATIC int
_soc_tr3_egress_buffer_reset(int unit, soc_port_t port, soc_block_type_t pbt,
                             uint8 reset)
{
    int f=0, blk, phy;
    soc_info_t *si = &SOC_INFO(unit);
    soc_field_t field_xl[] = {XLP0_RESETf, XLP1_RESETf};
    soc_field_t field_xw[] = {XWP0_RESETf, XWP1_RESETf, XWP2_RESETf};
    soc_field_t field_xt[] = {XTP0_RESETf, XTP1_RESETf, XTP2_RESETf, XTP3_RESETf};
    soc_field_t field_cl[] = {CLP0_RESETf, CLP1_RESETf};

    phy = si->port_l2p_mapping[port];
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "%s port: log %d, phy %d\n"), FUNCTION_NAME(), port, phy));

    switch (pbt) {
    case SOC_BLK_XLPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, EGR_PORT_BUFFER_SFT_RESETr, port,
                                            field_xl[f], reset ? 0x1 : 0));
                return SOC_E_NONE;
            }
            f++;
        }
        break;
    case SOC_BLK_XWPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XWPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, EGR_PORT_BUFFER_SFT_RESETr, port,
                                            field_xw[f], reset ? 0x1 : 0));
                return SOC_E_NONE;
            }
            f++;
        }
        break;
    case SOC_BLK_XTPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XTPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, EGR_PORT_BUFFER_SFT_RESETr, port,
                                            field_xt[f], reset ? 0x1 : 0));
                return SOC_E_NONE;
            } else if (phy >= _soc_tr3_b2pp[blk]+4 && phy <= _soc_tr3_b2pp[blk]+7) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, EGR_PORT_BUFFER_SFT_RESETr, port,
                                            field_xt[f], reset ? 0x2 : 0));
                return SOC_E_NONE;
            } else if (phy <= _soc_tr3_b2pp[blk]+11) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, EGR_PORT_BUFFER_SFT_RESETr, port,
                                            field_xt[f], reset ? 0x4 : 0));
                return SOC_E_NONE;
            }
            f++;
        }
        break;
    case SOC_BLK_CLPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_CLPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, EGR_PORT_BUFFER_SFT_RESETr, port,
                                            field_cl[f], reset ? 0x1 : 0));
                return SOC_E_NONE;
            } else if (phy >= _soc_tr3_b2pp[blk]+4 && phy <= _soc_tr3_b2pp[blk]+7) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, EGR_PORT_BUFFER_SFT_RESETr, port,
                                            field_cl[f], reset ? 0x2 : 0));
                return SOC_E_NONE;
            } else if (phy <= _soc_tr3_b2pp[blk]+11) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, EGR_PORT_BUFFER_SFT_RESETr, port,
                                            field_cl[f], reset ? 0x4 : 0));
                return SOC_E_NONE;
            }
            f++;
        }
        break;
    default:
        return SOC_E_PORT;
    }
    return SOC_E_PORT;
}

STATIC int
_soc_tr3_port_soft_reset(int unit, soc_port_t port, soc_block_type_t pbt,
                         uint8 reset)
{
    int blk, phy;
    soc_info_t *si = &SOC_INFO(unit);

    phy = si->port_l2p_mapping[port];
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "%s port: log %d, phy %d\n"), FUNCTION_NAME(), port, phy));

    switch (pbt) {
    case SOC_BLK_XLPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_SOFT_RESETr, port,
                                            XPORT_CORE0f, reset ? 1 : 0));
                return SOC_E_NONE;
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Invalid port !!\n")));
            }        
        }
        break;
    case SOC_BLK_XWPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XWPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_SOFT_RESETr, port,
                                            XPORT_CORE0f, reset ? 1 : 0));
                return SOC_E_NONE;
            }        
        }
        break;
    case SOC_BLK_XTPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XTPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_SOFT_RESETr, port,
                                            XPORT_CORE0f, reset ? 1 : 0));
                return SOC_E_NONE;
            } else if (phy >= _soc_tr3_b2pp[blk]+4 && phy <= _soc_tr3_b2pp[blk]+7) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_SOFT_RESETr, port,
                                            XPORT_CORE1f, reset ? 1 : 0));
                return SOC_E_NONE;
            } else if (phy <= _soc_tr3_b2pp[blk]+11) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_SOFT_RESETr, port,
                                            XPORT_CORE2f, reset ? 1 : 0));
                return SOC_E_NONE;
            }
        }
        break;
    case SOC_BLK_CLPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_CLPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_SOFT_RESETr, port,
                                            XPORT_CORE0f, reset ? 1 : 0));
                return SOC_E_NONE;
            } else if (phy >= _soc_tr3_b2pp[blk]+4 && phy <= _soc_tr3_b2pp[blk]+7) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_SOFT_RESETr, port,
                                            XPORT_CORE1f, reset ? 1 : 0));
                return SOC_E_NONE;
            } else if (phy <= _soc_tr3_b2pp[blk]+11) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_SOFT_RESETr, port,
                                            XPORT_CORE2f, reset ? 1 : 0));
                return SOC_E_NONE;
            }
        }
        break;
    default:
        return SOC_E_PORT;
    }
    return SOC_E_PORT;
}

STATIC int
_soc_tr3_subport_disable(int unit, soc_port_t port, soc_block_type_t pbt, 
                         int count, uint8 disable)
{
    static const soc_field_t port_field[] = {
        PORT0f, PORT1f, PORT2f, PORT3f,
        PORT4f, PORT5f, PORT6f, PORT7f,
        PORT8f, PORT9f, PORT10f, PORT11f
    };
    
    int bindex, blk, phy, incr = 1;
    soc_info_t *si = &SOC_INFO(unit);
    uint32 rval = 0;
    
    if (count==2) {
        count++;
        incr = 2;
    }

    phy = si->port_l2p_mapping[port];
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "%s port: log %d, phy %d\n"), FUNCTION_NAME(), port, phy));

    switch (pbt) {
    case SOC_BLK_XLPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN(READ_PORT_ENABLE_REGr(unit, port, &rval));
                for (bindex = 0; bindex < count; bindex+=incr) {
                    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval,
                                      port_field[bindex], disable ? 0 : 1);
                }
                SOC_IF_ERROR_RETURN(WRITE_PORT_ENABLE_REGr(unit, port, rval));
                return SOC_E_NONE;
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Invalid port !!\n")));
            }        
        }
        break;
    case SOC_BLK_XWPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XWPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN(READ_PORT_ENABLE_REGr(unit, port, &rval));
                for (bindex = 0; bindex < count; bindex+=incr) {
                    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval,
                                      port_field[bindex], disable ? 0 : 1);
                }
                SOC_IF_ERROR_RETURN(WRITE_PORT_ENABLE_REGr(unit, port, rval));
                return SOC_E_NONE;
            }        
        }
        break;
    case SOC_BLK_XTPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XTPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN(READ_PORT_ENABLE_REGr(unit, port, &rval));
                for (bindex = 0; bindex < count; bindex+=incr) {
                    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval,
                                      port_field[bindex], disable ? 0 : 1);
                }
                SOC_IF_ERROR_RETURN(WRITE_PORT_ENABLE_REGr(unit, port, rval));
                return SOC_E_NONE;
            } else if (phy >= _soc_tr3_b2pp[blk]+4 && phy <= _soc_tr3_b2pp[blk]+7) {
                SOC_IF_ERROR_RETURN(READ_PORT_ENABLE_REGr(unit, port, &rval));
                for (bindex = 4; bindex < 4+count; bindex+=incr) {
                    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval,
                                      port_field[bindex], disable ? 0 : 1);
                }
                SOC_IF_ERROR_RETURN(WRITE_PORT_ENABLE_REGr(unit, port, rval));
                return SOC_E_NONE;
            } else if (phy <= _soc_tr3_b2pp[blk]+11) {
                SOC_IF_ERROR_RETURN(READ_PORT_ENABLE_REGr(unit, port, &rval));
                for (bindex = 8; bindex < 8+count; bindex+=incr) {
                    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval,
                                      port_field[bindex], disable ? 0 : 1);
                }
                SOC_IF_ERROR_RETURN(WRITE_PORT_ENABLE_REGr(unit, port, rval));
                return SOC_E_NONE;
            }
        }
        break;
    case SOC_BLK_CLPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_CLPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN(READ_PORT_ENABLE_REGr(unit, port, &rval));
                for (bindex = 0; bindex < count; bindex+=incr) {
                    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval,
                                      port_field[bindex], disable ? 0 : 1);
                }
                SOC_IF_ERROR_RETURN(WRITE_PORT_ENABLE_REGr(unit, port, rval));
                return SOC_E_NONE;
            } else if (phy >= _soc_tr3_b2pp[blk]+4 && phy <= _soc_tr3_b2pp[blk]+7) {
                SOC_IF_ERROR_RETURN(READ_PORT_ENABLE_REGr(unit, port, &rval));
                for (bindex = 4; bindex < 4+count; bindex+=incr) {
                    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval,
                                      port_field[bindex], disable ? 0 : 1);
                }
                SOC_IF_ERROR_RETURN(WRITE_PORT_ENABLE_REGr(unit, port, rval));
                return SOC_E_NONE;
            } else if (phy <= _soc_tr3_b2pp[blk]+11) {
                SOC_IF_ERROR_RETURN(READ_PORT_ENABLE_REGr(unit, port, &rval));
                for (bindex = 8; bindex < 8+count; bindex+=incr) {
                    soc_reg_field_set(unit, PORT_ENABLE_REGr, &rval,
                                      port_field[bindex], disable ? 0 : 1);
                }
                SOC_IF_ERROR_RETURN(WRITE_PORT_ENABLE_REGr(unit, port, rval));
                return SOC_E_NONE;
            }
        }
        break;
    default:
        return SOC_E_PORT;
    }
    return SOC_E_PORT;
}

STATIC int
_soc_tr3_port_mode_set(int unit, soc_port_t port, soc_block_type_t pbt,
                       int lanes)
{
    int blk, phy;
    uint32 core_mode, phy_mode;
    soc_info_t *si = &SOC_INFO(unit);

    phy = si->port_l2p_mapping[port];
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "%s port: log %d, phy %d\n"), FUNCTION_NAME(), port, phy));
    
    /* Note: lanes => means how many physical lanes/slot does a port use */
    switch (lanes) {
    case 4: core_mode = CORE_MODE_SINGLE; 
        phy_mode = (pbt == SOC_BLK_XTPORT) ? PHY_MODE_DUAL : 
                   ((si->port_speed_max[port] >= 10000) &&
                    (si->port_speed_max[port] <= 12000)) ? PHY_MODE_QUAD : 
                    PHY_MODE_SINGLE; 
        break;
    case 2: core_mode = CORE_MODE_DUAL; 
        phy_mode = (si->port_speed_max[port] == 10000) ? PHY_MODE_QUAD :
                    PHY_MODE_DUAL; 
        break;
    case 1: core_mode = CORE_MODE_QUAD; phy_mode = PHY_MODE_QUAD; 
        break;
    default:
        return SOC_E_PARAM;
    }

    switch (pbt) {
    case SOC_BLK_XLPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT0_CORE_PORT_MODEf, core_mode));
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT0_PHY_PORT_MODEf, phy_mode));
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPC0_GMII_MII_ENABLEf,
                                            (core_mode == CORE_MODE_QUAD) ? 1 : 0));
                return SOC_E_NONE;
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Invalid port !!\n")));
            }        
        }
        break;
    case SOC_BLK_XWPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XWPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT0_CORE_PORT_MODEf, core_mode));
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT0_PHY_PORT_MODEf, phy_mode));
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPC0_GMII_MII_ENABLEf,
                                            (core_mode == CORE_MODE_QUAD) ? 1 : 0));
                return SOC_E_NONE;
            }        
        }
        break;
    case SOC_BLK_XTPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XTPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT0_CORE_PORT_MODEf, core_mode));
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT0_PHY_PORT_MODEf, phy_mode));
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPC0_GMII_MII_ENABLEf, 
                                            (core_mode == CORE_MODE_QUAD) ? 1 : 0));
                return SOC_E_NONE;
            } else if (phy >= _soc_tr3_b2pp[blk]+4 && phy <= _soc_tr3_b2pp[blk]+7) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT1_CORE_PORT_MODEf, core_mode));
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT1_PHY_PORT_MODEf, phy_mode));
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPC1_GMII_MII_ENABLEf,
                                            (core_mode == CORE_MODE_QUAD) ? 1 : 0));
                return SOC_E_NONE;
            } else if (phy <= _soc_tr3_b2pp[blk]+11) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT2_CORE_PORT_MODEf, core_mode));
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT2_PHY_PORT_MODEf, phy_mode));
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPC2_GMII_MII_ENABLEf,
                                            (core_mode == CORE_MODE_QUAD) ? 1 : 0));
                return SOC_E_NONE;
            }
        }
        break;
    case SOC_BLK_CLPORT:
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_CLPORT) {
            if (phy >= _soc_tr3_b2pp[blk] && phy <= _soc_tr3_b2pp[blk]+3) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT0_CORE_PORT_MODEf, core_mode));
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT0_PHY_PORT_MODEf, phy_mode));
                return SOC_E_NONE;
            } else if (phy >= _soc_tr3_b2pp[blk]+4 && phy <= _soc_tr3_b2pp[blk]+7) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT1_CORE_PORT_MODEf, core_mode));
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT1_PHY_PORT_MODEf, phy_mode));
                return SOC_E_NONE;
            } else if (phy <= _soc_tr3_b2pp[blk]+11) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT2_CORE_PORT_MODEf, core_mode));
                SOC_IF_ERROR_RETURN
                    (soc_reg_field32_modify(unit, PORT_MODE_REGr, port,
                                            XPORT2_PHY_PORT_MODEf, phy_mode));
                return SOC_E_NONE;
            }
        }
        break;
    default:
        return SOC_E_PORT;
    }
    return SOC_E_PORT;
}

STATIC int
_soc_tr3_port_type_set(int unit, soc_port_t port, int type)
{
    port_tab_entry_t ptab;
    egr_port_entry_t eport;
    icontrol_opcode_bitmap_entry_t entry;
    soc_pbmp_t pbmp;
    
    SOC_IF_ERROR_RETURN(READ_PORT_TABm(unit, MEM_BLOCK_ANY, port, &ptab));
    soc_PORT_TABm_field32_set(unit, &ptab, PORT_TYPEf, type);
    SOC_IF_ERROR_RETURN(WRITE_PORT_TABm(unit, MEM_BLOCK_ANY, port, &ptab));
    
    SOC_IF_ERROR_RETURN(READ_EGR_PORTm(unit, MEM_BLOCK_ANY, port, &eport));
    soc_EGR_PORTm_field32_set(unit, &eport, PORT_TYPEf, type);
    SOC_IF_ERROR_RETURN(WRITE_EGR_PORTm(unit, MEM_BLOCK_ANY, port, &eport));

    SOC_IF_ERROR_RETURN(READ_EGR_ING_PORTm(unit, MEM_BLOCK_ANY, port, &eport));
    soc_EGR_ING_PORTm_field32_set(unit, &eport, PORT_TYPEf, type);
    SOC_IF_ERROR_RETURN(WRITE_EGR_ING_PORTm(unit, MEM_BLOCK_ANY, port, &eport));

    SOC_IF_ERROR_RETURN
        (READ_ICONTROL_OPCODE_BITMAPm(unit, MEM_BLOCK_ANY, port, &entry));
    SOC_PBMP_CLEAR(pbmp);
    if (type == SOC_ENCAP_HIGIG) {
        SOC_PBMP_PORT_SET(pbmp, CMIC_PORT(unit));
    }
    soc_mem_pbmp_field_set(unit, ICONTROL_OPCODE_BITMAPm, &entry,
                           BITMAPf, &pbmp);
    SOC_IF_ERROR_RETURN
        (WRITE_ICONTROL_OPCODE_BITMAPm(unit, MEM_BLOCK_ANY, port, &entry));
    return SOC_E_NONE;
}

STATIC int
_soc_tr3_current_port_speeds(int unit, int *m2s)
{
    int mmu_port, port, phy_port;
    soc_info_t *si;

    si = &SOC_INFO(unit);

    for (mmu_port = 0; mmu_port < SOC_MAX_PHY_PORTS; mmu_port++) {
        m2s[mmu_port] = -1;
    }

    PBMP_PORT_ITER(unit, port) {
        if (IS_CPU_PORT(unit, port) || IS_AXP_PORT(unit, port) ||
            IS_LB_PORT(unit, port)) {
            continue;
        }
        phy_port = si->port_l2p_mapping[port];
        mmu_port = si->port_p2m_mapping[phy_port];
        m2s[mmu_port] = si->port_speed_max[port];
    }

    return 0;
}

STATIC uint32
_soc_tr3_get_mcfifo_config_val(int unit)
{
    int i, j, l;
    int cm2s[SOC_MAX_PHY_PORTS];
    uint32 mcfval = 0;
    
    _soc_tr3_current_port_speeds(unit, cm2s);

    for (i = 32; i < 48; i++) {
        if (cm2s[i] <= 0) {
            continue;
        } else if (cm2s[i] >= 10000) {
            mcfval |= 1 << (i - 32);
        }
    }

    for (i = 47; i >= 36; i-= 1) {
        if (cm2s[i] <= 0) {
            continue;
        } else if (mcfval & (1 << (i - 32))) {
            l = (i - 36)*4;
            for (j = l; j < l + 4; j++) {
                if (i == j) {
                    continue;
                }
            
                if (cm2s[j] > 0) {
                    mcfval |= 1 << (j - 32);
                }
            }
        }
    }

    for (i = 32; i < 36; i++) {
        if (cm2s[i] <= 0) {
            mcfval &= ~(1 << (i - 32));
        } else {
            l = (i/4) + 4;
            if (mcfval & (1 << l)) {
                mcfval |= 1 << (i - 32);
            }
        }
    }

    return mcfval;
}

#if 0
STATIC int
_soc_tr3_get_numq_and_fifo_size(int unit, int port, int *pcredits, int *pnumq)
{
    int credits = 0, numq = 8, phy_port, mmu_port, speed;
    soc_info_t *si;
    uint32 mcfval = 0;

    *pcredits = 0;
    *pnumq = 0;

    si = &SOC_INFO(unit);

    phy_port = si->port_l2p_mapping[port];
    mmu_port = si->port_p2m_mapping[phy_port];

    if (mmu_port == 59) {
        *pnumq = 48;
        *pcredits = (12 * 1024)/48 & ~3;
        return 0;
    } else if (mmu_port == 56) {
        *pnumq = 8;
        *pcredits = (2 * 1024)/8 & ~3;
        return 0;
    } else if (mmu_port == 58) {
        *pnumq = 8;
        *pcredits = (4 * 1024)/8 & ~3;
        return 0;
    } else if (mmu_port == 60) {
#if 0 
        *pnumq = 8;
        *pcredits = (256)/numq;
#else
            return 0;
#endif
    } else if (mmu_port == 61) {
        *pnumq = 1;
        *pcredits = (256)/1 & ~3;
        return 0;
    }
   
    speed = si->port_speed_max[port];

    if (speed <= 0) {
        return 0;
    }
   
    numq = (((mmu_port >= 40) && (mmu_port <= 55)) && (IS_HG_PORT(unit,port))) ? 10 : 8;

    if (mmu_port < 48) {
        if (mmu_port < 32) {
            if ((speed >= 1000) && (speed < 10000)) {
                credits = (256/numq) & ~3;
            } else if (speed >= 10000) {
                credits = (1024/numq) & ~3;
            }
        } else {
            mcfval = _soc_tr3_get_mcfifo_config_val(unit);
            if ((mmu_port >= 32) && (mmu_port <= 35)) {
                if (mcfval & (1 << 12)) {
                    credits = 2048/numq & ~3;
                } else if (mcfval & (1 << (mmu_port - 32))) {
                    credits = 2048/numq & ~3;
                } else {
                    credits = 256/numq & ~3;
                }
            } else {
                if (mcfval & (1 << (mmu_port - 32))) {
                    credits = 1024/numq & ~3;
                } else {
                    credits = 256/numq & ~3;
                }
            }
        }
    } else {
        if (speed >= 100000) {
            credits = (10 * 2 * 2048)/numq & ~3;
        } else {
            credits = (2 * 2048)/numq & ~3;
        }
    }

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "MMU port=%d numq=%d credits=%d\n"), mmu_port, numq, credits));

    *pcredits = credits;
    *pnumq = numq;
    return 0;
}
#else
STATIC int
_soc_tr3_get_numq_and_fifo_size(int unit, int port, int *pcredits, int *pnumq)
{
    int credits = 0, numq = 8, phy_port, mmu_port, speed;
    soc_info_t *si;

    *pcredits = 0;
    *pnumq = 0;

    si = &SOC_INFO(unit);

    phy_port = si->port_l2p_mapping[port];
    mmu_port = si->port_p2m_mapping[phy_port];

    if (mmu_port == 59) {
        *pnumq = 48;
        *pcredits = (12 * 1024)/48 & ~3;
        return 0;
    } else if (mmu_port == 56) {
        *pnumq = 8;
        *pcredits = (2 * 1024)/8 & ~3;
        return 0;
    } else if (mmu_port == 58) {
        *pnumq = 8;
        *pcredits = (4 * 1024)/8 & ~3;
        return 0;
    } else if (mmu_port == 60) {
        *pnumq = 8;
        *pcredits = 256/8 & ~3;
        return 0;
    } else if (mmu_port == 61) {
        *pnumq = 1;
        *pcredits = (256)/1 & ~3;
        return 0;
    }
   
    speed = si->port_speed_max[port];

    if (speed <= 0) {
        return 0;
    }
   
     numq = ((mmu_port >= 40) && (mmu_port <= 55)) ? 10 : 8;
    
    if ((speed >= 1000) && (speed < 10000)) {
        credits = (256/numq) & ~3;
    } else if ((speed >= 10000) && (speed < 20000)) {
        credits = (1024/numq) & ~3;
    } else if ((speed >= 20000) && (speed < 40000)) {
        if (mmu_port < 48) {
            credits = ((1 * 1024)/numq) & ~3;
        } else {
            credits = ((2 * 1024)/numq) & ~3;
        }
    } else if ((speed >= 40000) && (speed <= 42000)) {
        credits = ((2 * 2 * 1024)/numq) & ~3;
    } else if (speed > 42000) {
        numq = 10;
        credits = 2048;
    }
        
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "%s MMU port=%d numq=%d credits=%d\n"),
                            SOC_PORT_NAME(unit, port), mmu_port, numq, credits));

    *pcredits = credits;
    *pnumq = numq;
    return 0;
}
#endif

STATIC int
_soc_tr3_set_mcfifo_config(int unit)
{
    uint32 fval, mcfval = 0, rval;
    
    mcfval = _soc_tr3_get_mcfifo_config_val(unit);

    SOC_IF_ERROR_RETURN(READ_MCFIFO_CONFIGr(unit, &rval));
    fval = soc_reg_field_get(unit, MCFIFO_CONFIGr, rval, MODE_COMBINEf);
    if (fval != mcfval) {
        soc_reg_field_set(unit, MCFIFO_CONFIGr, &rval, MODE_COMBINEf, mcfval);
    
        SOC_IF_ERROR_RETURN(WRITE_MCFIFO_CONFIGr(unit, rval));
    }

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "MCFIFO_CONFIG=0x%08x\n"), mcfval));
    return 0;
}

STATIC int
_soc_tr3_update_mcq_fifo(int unit, int *pm2s)
{
    int cm2s[SOC_MAX_PHY_PORTS], mmu_port, port, phy_port, i, total_queues;
    soc_info_t *si;
    int credits = 0, numq;
    soc_reg_t reg;

    si = &SOC_INFO(unit);

    _soc_tr3_current_port_speeds(unit, cm2s);

    PBMP_PORT_ITER(unit, port) {
        if (IS_CPU_PORT(unit, port) || IS_AXP_PORT(unit, port) ||
            IS_LB_PORT(unit, port)) {
            continue;
        }
        phy_port = si->port_l2p_mapping[port];
        mmu_port = si->port_p2m_mapping[phy_port];

        if (pm2s[mmu_port] == cm2s[mmu_port]) {
            continue;
        }

        if (cm2s[mmu_port] <= 0) {
            continue;
        }

        total_queues = ((mmu_port >= 40) && (mmu_port <= 55)) ? 10 : 8;

        _soc_tr3_get_numq_and_fifo_size(unit, port, &credits, &numq);
        
        
        if ((mmu_port >= 40) && (mmu_port <= 47)) {
            reg = MCQ_FIFO_BASE_REGr;
        } else if ((mmu_port >= 48) && (mmu_port <= 55)) {
            reg = MCQ_FIFO_BASE_REG_48_55r;
        } else if ((mmu_port >= 36) && (mmu_port <= 39)) {
            reg = MCQ_FIFO_BASE_REG_36_39r;
        } else if ((mmu_port >= 32) && (mmu_port <= 35)) {
            reg = MCQ_FIFO_BASE_REG_32_35r;
        } else if (mmu_port == 56) {
            reg = MCQ_FIFO_BASE_REG_56r;
        } else if (mmu_port == 58) {
            reg = MCQ_FIFO_BASE_REG_PASSTHRUr;
        } else {
            reg = INVALIDr;
        }

        for (i = 0; i < numq; i++) {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "Updating OVQ credits for port: %s(%d) = %d\n"), 
                                    SOC_PORT_NAME(unit, port),i, credits));
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "Updating MCQ base for port: %s(%d) = %d\n"), 
                                    SOC_PORT_NAME(unit, port), i, i*credits));
            if (reg != INVALIDr) {
                if (credits < 2048) {
                    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, i, i*credits));
                } else {
                    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, i, 0));
                }
            }
            SOC_IF_ERROR_RETURN(WRITE_OVQ_MCQ_CREDITSr(unit, port, i, credits));
        }

        for (i = numq; i < total_queues; i++) {
            if (reg != INVALIDr) {
                if (credits < 2048) {
                    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, i, i*credits));
                } else {
                    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, i, 0));
                }
            }
            SOC_IF_ERROR_RETURN(WRITE_OVQ_MCQ_CREDITSr(unit, port, i, 0));
        }
    }

    _soc_tr3_set_mcfifo_config(unit);

    return 0;
}

/*
 * NOTE: number of lanes and number of ports mapping:
 *       lanes: 1 => ports 4
 *       lanes: 2 => ports 2
 *       lanes: 4 => ports 1
 */
int 
soc_tr3_port_lanes_set(int unit, soc_port_t port, int lanes, 
                       int *old_lanes, int *mode_change)
{
    static const soc_reg_t lls_port_credit_reg[] = {
        LLS_PORT_0_CREDITr, LLS_PORT_1_CREDITr, LLS_PORT_2_CREDITr,
        LLS_PORT_3_CREDITr, LLS_PORT_4_CREDITr, LLS_PORT_5_CREDITr,
        LLS_PORT_6_CREDITr, LLS_PORT_7_CREDITr, LLS_PORT_8_CREDITr,
        LLS_PORT_9_CREDITr, LLS_PORT_10_CREDITr, LLS_PORT_11_CREDITr,
        LLS_PORT_12_CREDITr, LLS_PORT_13_CREDITr, LLS_PORT_14_CREDITr,
        LLS_PORT_15_CREDITr, LLS_PORT_16_CREDITr, LLS_PORT_17_CREDITr,
        LLS_PORT_18_CREDITr, LLS_PORT_19_CREDITr, LLS_PORT_20_CREDITr,
        LLS_PORT_21_CREDITr, LLS_PORT_22_CREDITr, LLS_PORT_23_CREDITr,
        LLS_PORT_24_CREDITr, LLS_PORT_25_CREDITr, LLS_PORT_26_CREDITr,
        LLS_PORT_27_CREDITr, LLS_PORT_28_CREDITr, LLS_PORT_29_CREDITr,
        LLS_PORT_30_CREDITr, LLS_PORT_31_CREDITr, LLS_PORT_32_CREDITr,
        LLS_PORT_33_CREDITr, LLS_PORT_34_CREDITr, LLS_PORT_35_CREDITr,
        LLS_PORT_36_CREDITr, LLS_PORT_37_CREDITr, LLS_PORT_38_CREDITr,
        LLS_PORT_39_CREDITr, LLS_PORT_40_CREDITr, LLS_PORT_41_CREDITr,
        LLS_PORT_42_CREDITr, LLS_PORT_43_CREDITr, LLS_PORT_44_CREDITr,
        LLS_PORT_45_CREDITr, LLS_PORT_46_CREDITr, LLS_PORT_47_CREDITr,
        LLS_PORT_48_CREDITr, LLS_PORT_49_CREDITr, LLS_PORT_50_CREDITr,
        LLS_PORT_51_CREDITr, LLS_PORT_52_CREDITr, LLS_PORT_53_CREDITr,
        LLS_PORT_54_CREDITr, LLS_PORT_55_CREDITr, LLS_PORT_56_CREDITr,
        LLS_PORT_57_CREDITr, LLS_PORT_58_CREDITr, LLS_PORT_59_CREDITr,
        LLS_PORT_60_CREDITr, LLS_PORT_61_CREDITr, LLS_PORT_62_CREDITr
    }; 
    
    int hp, hgc = 0;
    int prev_port_speeds[SOC_MAX_PHY_PORTS];
    soc_block_type_t pbt;
    int i, phy, old_value, count = 0;
    soc_port_t it_port;
    egr_enable_entry_t egr_en;
    soc_info_t *si = &SOC_INFO(unit);

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "Set lane, port: %d : %d\n"), port, lanes));
    if (!(lanes == 1 || lanes == 2 || lanes == 4)) {
        return SOC_E_PARAM;
    }
    if (!soc_tr3_port_is_flex_port(unit, port)) {
        return SOC_E_PORT;
    }
    SOC_IF_ERROR_RETURN(soc_tr3_port_lanes_gen(unit, port, &old_value, &pbt));
    *old_lanes = old_value;
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "Old value: %d, pbt: %d\n"), old_value, pbt));
    if (old_value == lanes) {
        return SOC_E_EXISTS;
    }
    if (IS_XT_PORT(unit, port) && lanes == 2) {
        return SOC_E_PARAM;
    }
#define RECONFIGURE_PORT_TYPE_INFO(ptype) \
    si->ptype.num = 0; \
    si->ptype.min = si->ptype.max = -1; \
    PBMP_ITER(si->ptype.bitmap, it_port) { \
        si->ptype.port[si->ptype.num++] = it_port; \
        if (si->ptype.min < 0) { \
            si->ptype.min = it_port; \
        } \
        if (it_port > si->ptype.max) { \
            si->ptype.max = it_port; \
        } \
    }
    SOC_CONTROL_LOCK(unit);

    if (!SOC_WARM_BOOT(unit)) {
        _soc_tr3_current_port_speeds(unit, prev_port_speeds);
    }
    
    /* update various speeds, bitmaps and port types */
    /* NOTE: For 1 to n and 2 to n, do not assume that all ports in a group are the same */
    if (old_value == 1 && lanes == 2) { /* 4xHGs[11] -> 2xHGd[21], 4xXFI/4x1GE -> 2xRXAUI */
        if (IS_XE_PORT(unit, port) || IS_GE_PORT(unit, port)) {
            si->port_speed_max[port] = 11000;
            if (IS_GE_PORT(unit, port)) {
                SOC_PBMP_PORT_REMOVE(si->ge.bitmap, port);
            } else {
                SOC_PBMP_PORT_ADD(si->xe.bitmap, port);
            }
            for (i = port + 1; i < port + 4; i++) {
                if (i == port+2) {
                    if (IS_HG_PORT(unit, i)) {
                        SOC_PBMP_PORT_REMOVE(si->st.bitmap, i);
                        SOC_PBMP_PORT_REMOVE(si->hg.bitmap, i);
                        _soc_tr3_port_type_set(unit, i, SOC_ENCAP_IEEE);
                        *mode_change = SOC_ENCAP_IEEE;
                    } else if (IS_GE_PORT(unit, i)) {
                        SOC_PBMP_PORT_REMOVE(si->ge.bitmap, i);
                    }
                    si->port_speed_max[i] = 11000;
                    SOC_PBMP_PORT_ADD(si->xe.bitmap, i);
                    SOC_PBMP_PORT_ADD(si->ether.bitmap, i);
                } else {
                    if (IS_HG_PORT(unit, i)) {
                        SOC_PBMP_PORT_ADD(si->st.disabled_bitmap, i);
                        SOC_PBMP_PORT_ADD(si->hg.disabled_bitmap, i);
                        _soc_tr3_port_type_set(unit, i, SOC_ENCAP_IEEE);
                        *mode_change = SOC_ENCAP_IEEE;
                    } else if (IS_GE_PORT(unit, i)) {
                        SOC_PBMP_PORT_ADD(si->ge.disabled_bitmap, i);
                    } else if (IS_XE_PORT(unit, i)) {
                        SOC_PBMP_PORT_ADD(si->xe.disabled_bitmap, i);
                    }
                    SOC_PBMP_PORT_ADD(si->port.disabled_bitmap, i);
                    SOC_PBMP_PORT_ADD(si->all.disabled_bitmap, i);
                    si->port_speed_max[i] = 0;
                }
            }
        } else if (IS_HG_PORT(unit, port)) {
            si->port_speed_max[port] = 21000;
            for (i = port + 1; i < port + 4; i++) {
                if (i == port+2) {
                    si->port_speed_max[i] = 21000;
                    if (IS_XE_PORT(unit, i)) {
                        SOC_PBMP_PORT_REMOVE(si->xe.bitmap, i);
                        SOC_PBMP_PORT_REMOVE(si->ether.bitmap, i);
                        _soc_tr3_port_type_set(unit, i, SOC_ENCAP_HIGIG);
                        *mode_change = SOC_ENCAP_HIGIG;
                    } else if (IS_GE_PORT(unit, port)) {
                        SOC_PBMP_PORT_REMOVE(si->ge.bitmap, i);
                        SOC_PBMP_PORT_REMOVE(si->ether.bitmap, i);
                        _soc_tr3_port_type_set(unit, i, SOC_ENCAP_HIGIG);
                        *mode_change = SOC_ENCAP_HIGIG;
                    }            
                    SOC_PBMP_PORT_ADD(si->hg.bitmap, i);
                    SOC_PBMP_PORT_ADD(si->st.bitmap, i);
                } else {
                    if (IS_HG_PORT(unit, i)) {
                        SOC_PBMP_PORT_ADD(si->st.disabled_bitmap, i);
                        SOC_PBMP_PORT_ADD(si->hg.disabled_bitmap, i);
                    } else if (IS_GE_PORT(unit, i)) {
                        SOC_PBMP_PORT_ADD(si->ge.disabled_bitmap, i);
                    } else if (IS_XE_PORT(unit, i)) {
                        SOC_PBMP_PORT_ADD(si->xe.disabled_bitmap, i);
                    }
                    SOC_PBMP_PORT_ADD(si->port.disabled_bitmap, i);
                    SOC_PBMP_PORT_ADD(si->all.disabled_bitmap, i);
                    si->port_speed_max[i] = 0;
                }
            }
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Invalid port config for hotswap !!\n")));
            SOC_CONTROL_UNLOCK(unit);
            return SOC_E_PARAM;
        }
        RECONFIGURE_PORT_TYPE_INFO(ether);
        RECONFIGURE_PORT_TYPE_INFO(st);
        RECONFIGURE_PORT_TYPE_INFO(hg);
        RECONFIGURE_PORT_TYPE_INFO(xe);
        RECONFIGURE_PORT_TYPE_INFO(ge);
    } else if (old_value == 1 && lanes == 4) {
        /* 4xHGs[11]/4xXFI/4x1GE/4x2.5GE -> HG[42]/40GE, 4x1GE/4x2.5GE -> XAUI */
        if (IS_XT_PORT(unit, port)) { /* No HG allowed in XT so all ports are the same */
            SOC_PBMP_PORT_REMOVE(si->ge.bitmap, port);
            SOC_PBMP_PORT_ADD(si->xe.bitmap, port);
            si->port_speed_max[port] = 11000;
            for (i = port + 1; i < port + 4; i++) {
                SOC_PBMP_PORT_ADD(si->ge.disabled_bitmap, i);
                SOC_PBMP_PORT_ADD(si->ether.disabled_bitmap, i);
                SOC_PBMP_PORT_ADD(si->port.disabled_bitmap, i);
                SOC_PBMP_PORT_ADD(si->all.disabled_bitmap, i);
                si->port_speed_max[i] = 0;
            }
            RECONFIGURE_PORT_TYPE_INFO(xe);
            RECONFIGURE_PORT_TYPE_INFO(ge);
        } else if (IS_XE_PORT(unit, port) || IS_GE_PORT(unit, port)) {
            uint8 to_xe = 0, to_40ge = 0;
            /* convert to XE for ports in CL1 block as per SKU/config */
            if ((si->port_l2p_mapping[port] == 73 || si->port_l2p_mapping[port] == 77) &&
                (_tr3_port_config_id[unit] == 40)) {
                to_xe = 1;
            }
            if (((si->port_l2p_mapping[port] == 53 || si->port_l2p_mapping[port] == 57 ||
                si->port_l2p_mapping[port] == 61) && (_tr3_port_config_id[unit] == 71)) || 
                ((si->port_l2p_mapping[port] == 53 || si->port_l2p_mapping[port] == 57 ||
                si->port_l2p_mapping[port] == 61) && (_tr3_port_config_id[unit] == 72))) {
                to_40ge = 1;
            }
            if (IS_XE_PORT(unit, port)) {
                if (!(to_xe || to_40ge)) {
                    SOC_PBMP_PORT_REMOVE(si->xe.bitmap, port);
                }
                SOC_PBMP_PORT_REMOVE(si->xl.bitmap, port);
            } else if (IS_GE_PORT(unit, port)) {
                SOC_PBMP_PORT_REMOVE(si->ge.bitmap, port);
            }            
            if (!(to_xe || to_40ge)) {
                /* Validate new HG count */
                PBMP_HG_ITER(unit, hp) {
                    if (!SOC_PBMP_MEMBER(SOC_PORT_DISABLED_BITMAP(unit, port), hp)) {
                        hgc++;
                    }
                }
                if (hgc+1 > _SOC_TR3_MAX_HG_PORT_COUNT) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "Port config error (Higig port count[%d] exceeded) !!\n"),
                                          hgc));
                    return SOC_E_PARAM;
                }
                SOC_PBMP_PORT_REMOVE(si->ether.bitmap, port);
                SOC_PBMP_PORT_ADD(si->hg.bitmap, port);
                SOC_PBMP_PORT_ADD(si->st.bitmap, port);
                _soc_tr3_port_type_set(unit, port, SOC_ENCAP_HIGIG);
                *mode_change = SOC_ENCAP_HIGIG;
            }
            si->port_speed_max[port] = (to_xe) ? ((to_40ge) ? 40000 : 11000) : 42000;
            for (i = port + 1; i < port + 4; i++) {
                if (IS_XE_PORT(unit, i) || IS_GE_PORT(unit, i)) {
                    if (IS_XE_PORT(unit, i)) {
                        SOC_PBMP_PORT_ADD(si->xe.disabled_bitmap, i);
                    } else if (IS_GE_PORT(unit, i)) {
                        SOC_PBMP_PORT_ADD(si->ge.disabled_bitmap, i);
                    }
                    SOC_PBMP_PORT_ADD(si->ether.disabled_bitmap, i);
                } else if (IS_HG_PORT(unit, i)) {
                    SOC_PBMP_PORT_ADD(si->st.disabled_bitmap, i);
                    SOC_PBMP_PORT_ADD(si->hg.disabled_bitmap, i);
                }
                SOC_PBMP_PORT_ADD(si->port.disabled_bitmap, i);
                SOC_PBMP_PORT_ADD(si->all.disabled_bitmap, i);
                si->port_speed_max[i] = 0;
            }
            RECONFIGURE_PORT_TYPE_INFO(ether);
            RECONFIGURE_PORT_TYPE_INFO(st);
            RECONFIGURE_PORT_TYPE_INFO(hg);
            RECONFIGURE_PORT_TYPE_INFO(xe);
            RECONFIGURE_PORT_TYPE_INFO(ge);
        } else if (IS_HG_PORT(unit, port)) {
            si->port_speed_max[port] = 42000;
            for (i = port + 1; i < port + 4; i++) {
                if (IS_HG_PORT(unit, i)) {
                    SOC_PBMP_PORT_ADD(si->hg.disabled_bitmap, i);
                    SOC_PBMP_PORT_ADD(si->st.disabled_bitmap, i);
                } else if (IS_XE_PORT(unit, i) || IS_GE_PORT(unit, i)) {
                    if (IS_XE_PORT(unit, i)) {
                        SOC_PBMP_PORT_ADD(si->xe.disabled_bitmap, i);
                    } else if (IS_GE_PORT(unit, i)) {
                        SOC_PBMP_PORT_ADD(si->ge.disabled_bitmap, i);
                    }
                    SOC_PBMP_PORT_ADD(si->ether.disabled_bitmap, i);
                }
                SOC_PBMP_PORT_ADD(si->port.disabled_bitmap, i);
                SOC_PBMP_PORT_ADD(si->all.disabled_bitmap, i);
                si->port_speed_max[i] = 0;
            }
            RECONFIGURE_PORT_TYPE_INFO(ether);
            RECONFIGURE_PORT_TYPE_INFO(st);
            RECONFIGURE_PORT_TYPE_INFO(hg);
            RECONFIGURE_PORT_TYPE_INFO(xe);
            RECONFIGURE_PORT_TYPE_INFO(ge);
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Invalid port config for hotswap !!\n")));
            SOC_CONTROL_UNLOCK(unit);
            return SOC_E_PARAM;
        }
    } else if (old_value == 2 && lanes == 1) {
        if (IS_HG_PORT(unit, port)) { /* 2HGd[21] -> 4xHGs[11] */
            /* Validate new HG count */
            PBMP_HG_ITER(unit, hp) {
                if (!SOC_PBMP_MEMBER(SOC_PORT_DISABLED_BITMAP(unit, port), hp)) {
                    hgc++;
                }
            }
            if (hgc+3 > _SOC_TR3_MAX_HG_PORT_COUNT) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Port config error (Higig port count[%d] exceeded) !!\n"),
                                      hgc));
                return SOC_E_PARAM;
            }
            si->port_speed_max[port] = 11000;
            for (i = port + 1; i < port + 4; i++) {
                si->port_speed_max[i] = 11000;
                SOC_PBMP_PORT_ADD(si->hg.bitmap, i);
                SOC_PBMP_PORT_ADD(si->st.bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->xe.bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->ge.bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->ether.bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->st.disabled_bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->hg.disabled_bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->port.disabled_bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->all.disabled_bitmap, i);
            }
        } else if (IS_XE_PORT(unit, port)) { /* 2xRXAUI -> 4xXFI */
            si->port_speed_max[port] = 11000;
            for (i = port + 1; i < port + 4; i++) {
                si->port_speed_max[i] = 11000;
                SOC_PBMP_PORT_ADD(si->xe.bitmap, i);
                SOC_PBMP_PORT_ADD(si->ether.bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->st.bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->hg.bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->xe.disabled_bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->ether.disabled_bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->port.disabled_bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->all.disabled_bitmap, i);
            }
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Invalid port config for hotswap !!\n")));
            SOC_CONTROL_UNLOCK(unit);
            return SOC_E_PARAM;
        }
        RECONFIGURE_PORT_TYPE_INFO(ether);
        RECONFIGURE_PORT_TYPE_INFO(st);
        RECONFIGURE_PORT_TYPE_INFO(hg);
        RECONFIGURE_PORT_TYPE_INFO(xe);
        RECONFIGURE_PORT_TYPE_INFO(ge);
    } else if (old_value == 2 && lanes == 4) { /* 2HGd[21]/2xRXAUI -> HG[42]/40GE */
        if (IS_HG_PORT(unit, port)) {
            si->port_speed_max[port] = 42000;
            SOC_PBMP_PORT_ADD(si->st.disabled_bitmap, port+2);
            SOC_PBMP_PORT_ADD(si->hg.disabled_bitmap, port+2);
            SOC_PBMP_PORT_ADD(si->port.disabled_bitmap, port+2);
            SOC_PBMP_PORT_ADD(si->all.disabled_bitmap, port+2);
            si->port_speed_max[port+2] = 0;
        } else if (IS_XE_PORT(unit, port)) {
            if (((si->port_l2p_mapping[port] == 53 || si->port_l2p_mapping[port] == 57 ||
                si->port_l2p_mapping[port] == 61) && (_tr3_port_config_id[unit] == 71)) || 
                ((si->port_l2p_mapping[port] == 53 || si->port_l2p_mapping[port] == 57 ||
                si->port_l2p_mapping[port] == 61) && (_tr3_port_config_id[unit] == 72))) {
                si->port_speed_max[port] = 40000;
                SOC_PBMP_PORT_ADD(si->xe.disabled_bitmap, port+2);
                SOC_PBMP_PORT_ADD(si->port.disabled_bitmap, port+2);
                SOC_PBMP_PORT_ADD(si->all.disabled_bitmap, port+2);
                si->port_speed_max[port+2] = 0;
            } else {
                /* Validate new HG count */
                PBMP_HG_ITER(unit, hp) {
                    if (!SOC_PBMP_MEMBER(SOC_PORT_DISABLED_BITMAP(unit, port), hp)) {
                        hgc++;
                    }
                }
                if (hgc+1 > _SOC_TR3_MAX_HG_PORT_COUNT) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "Port config error (Higig port count[%d] exceeded) !!\n"),
                                          hgc));
                    return SOC_E_PARAM;
                }
                si->port_speed_max[port] = 42000;
                SOC_PBMP_PORT_REMOVE(si->xe.bitmap, port);
                SOC_PBMP_PORT_REMOVE(si->ether.bitmap, port);
                SOC_PBMP_PORT_ADD(si->hg.bitmap, port);
                SOC_PBMP_PORT_ADD(si->st.bitmap, port);
                _soc_tr3_port_type_set(unit, port, SOC_ENCAP_HIGIG);
                *mode_change = SOC_ENCAP_HIGIG;
                SOC_PBMP_PORT_ADD(si->xe.disabled_bitmap, port+2);
                SOC_PBMP_PORT_ADD(si->ether.disabled_bitmap, port+2);
                SOC_PBMP_PORT_ADD(si->port.disabled_bitmap, port+2);
                SOC_PBMP_PORT_ADD(si->all.disabled_bitmap, port+2);
                si->port_speed_max[port+2] = 0;
                RECONFIGURE_PORT_TYPE_INFO(ether);
                RECONFIGURE_PORT_TYPE_INFO(st);
                RECONFIGURE_PORT_TYPE_INFO(hg);
                RECONFIGURE_PORT_TYPE_INFO(xe);
            }
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Invalid port config for hotswap !!\n")));
            SOC_CONTROL_UNLOCK(unit);
            return SOC_E_PARAM;
        }
    } else if (old_value == 4 && lanes == 1) {
        /* HG[42] -> 4xHGs[11], HG[21]/XAUI -> 4x1GE, 40GE -> 4x10GE */
        if (IS_HG_PORT(unit, port)) {
            /* Handle F.HG[21] HG[21] case */
            if (si->port_speed_max[port] == 21000 && 
                si->port_l2p_mapping[port] > 72) {
                SOC_PBMP_PORT_REMOVE(si->hg.bitmap, port);
                SOC_PBMP_PORT_REMOVE(si->st.bitmap, port);
                SOC_PBMP_PORT_ADD(si->ge.bitmap, port);
                si->port_speed_max[port] = 1000;
                _soc_tr3_port_type_set(unit, port, SOC_ENCAP_IEEE);
                *mode_change = SOC_ENCAP_IEEE;
                for (i = port + 1; i < port + 4; i++) {
                    si->port_speed_max[i] = 1000;
                    SOC_PBMP_PORT_ADD(si->ge.bitmap, i);
                    SOC_PBMP_PORT_ADD(si->ether.bitmap, i);
                    if (IS_XE_PORT(unit, i)) {
                        SOC_PBMP_PORT_REMOVE(si->xe.bitmap, i);
                    } else {
                        SOC_PBMP_PORT_REMOVE(si->hg.bitmap, i);
                        SOC_PBMP_PORT_REMOVE(si->st.bitmap, i);
                        _soc_tr3_port_type_set(unit, i, SOC_ENCAP_IEEE);
                        *mode_change = SOC_ENCAP_IEEE;
                    }
                    SOC_PBMP_PORT_REMOVE(si->ge.disabled_bitmap, i);
                    SOC_PBMP_PORT_REMOVE(si->ether.disabled_bitmap, i);
                    SOC_PBMP_PORT_REMOVE(si->port.disabled_bitmap, i);
                    SOC_PBMP_PORT_REMOVE(si->all.disabled_bitmap, i);
                }
            } else {
                /* Validate new HG count */
                PBMP_HG_ITER(unit, hp) {
                    if (!SOC_PBMP_MEMBER(SOC_PORT_DISABLED_BITMAP(unit, port), hp)) {
                        hgc++;
                    }
                }
                if (hgc+3 > _SOC_TR3_MAX_HG_PORT_COUNT) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "Port config error (Higig port count[%d] exceeded) !!\n"),
                                          hgc));
                    return SOC_E_PARAM;
                }
                si->port_speed_max[port] = 11000;
                for (i = port + 1; i < port + 4; i++) {
                    si->port_speed_max[i] = 11000;
                    SOC_PBMP_PORT_ADD(si->hg.bitmap, i);
                    SOC_PBMP_PORT_ADD(si->st.bitmap, i);
                    SOC_PBMP_PORT_REMOVE(si->xe.bitmap, i);
                    SOC_PBMP_PORT_REMOVE(si->ether.bitmap, i);
                    SOC_PBMP_PORT_REMOVE(si->port.disabled_bitmap, i);
                    SOC_PBMP_PORT_REMOVE(si->all.disabled_bitmap, i);
                    _soc_tr3_port_type_set(unit, i, SOC_ENCAP_HIGIG);
                    *mode_change = SOC_ENCAP_HIGIG;
                }
            }
            RECONFIGURE_PORT_TYPE_INFO(ether);
            RECONFIGURE_PORT_TYPE_INFO(st);
            RECONFIGURE_PORT_TYPE_INFO(hg);
            RECONFIGURE_PORT_TYPE_INFO(xe);
            RECONFIGURE_PORT_TYPE_INFO(ge);
        } else if (IS_XT_PORT(unit, port)) {
            SOC_PBMP_PORT_REMOVE(si->xe.bitmap, port);
            SOC_PBMP_PORT_ADD(si->ge.bitmap, port);
            si->port_speed_max[port] = 1000;
            for (i = port + 1; i < port + 4; i++) {
                si->port_speed_max[i] = 1000;
                SOC_PBMP_PORT_REMOVE(si->ge.disabled_bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->ether.disabled_bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->port.disabled_bitmap, i);
                SOC_PBMP_PORT_REMOVE(si->all.disabled_bitmap, i);
            }
            RECONFIGURE_PORT_TYPE_INFO(xe);
            RECONFIGURE_PORT_TYPE_INFO(ge);
        } else if (IS_XE_PORT(unit, port)) { /* CL block as XE */
            if (si->port_speed_max[port] > 10000) { /* 1x40G -> 4xXFI*/
                si->port_speed_max[port] = 11000;
                for (i = port + 1; i < port + 4; i++) {
                    si->port_speed_max[i] = 11000;
                    SOC_PBMP_PORT_ADD(si->xe.bitmap, i);
                    SOC_PBMP_PORT_ADD(si->ether.bitmap, i);
                    SOC_PBMP_PORT_REMOVE(si->xe.disabled_bitmap, i);
                    SOC_PBMP_PORT_REMOVE(si->ether.disabled_bitmap, i);
                    SOC_PBMP_PORT_REMOVE(si->port.disabled_bitmap, i);
                    SOC_PBMP_PORT_REMOVE(si->all.disabled_bitmap, i);
                    if (IS_HG_PORT(unit, i)) {
                        SOC_PBMP_PORT_REMOVE(si->hg.bitmap, i);
                        SOC_PBMP_PORT_REMOVE(si->st.bitmap, i);
                        _soc_tr3_port_type_set(unit, i, SOC_ENCAP_IEEE);
                        *mode_change = SOC_ENCAP_IEEE;
                    }
                }
                RECONFIGURE_PORT_TYPE_INFO(st);
                RECONFIGURE_PORT_TYPE_INFO(hg);
                RECONFIGURE_PORT_TYPE_INFO(ether);
                RECONFIGURE_PORT_TYPE_INFO(xe);
            } else if (si->port_speed_max[port+1] == 0) {
                /* XAUI -> 4x1G */
                SOC_PBMP_PORT_REMOVE(si->xe.bitmap, port);
                SOC_PBMP_PORT_ADD(si->ge.bitmap, port);
                si->port_speed_max[port] = 1000;
                for (i = port + 1; i < port + 4; i++) {
                    si->port_speed_max[i] = 1000;
                    SOC_PBMP_PORT_REMOVE(si->ge.disabled_bitmap, i);
                    SOC_PBMP_PORT_REMOVE(si->ether.disabled_bitmap, i);
                    SOC_PBMP_PORT_REMOVE(si->port.disabled_bitmap, i);
                    SOC_PBMP_PORT_REMOVE(si->all.disabled_bitmap, i);
                }
                RECONFIGURE_PORT_TYPE_INFO(ether);
                RECONFIGURE_PORT_TYPE_INFO(xe);
                RECONFIGURE_PORT_TYPE_INFO(ge);
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Invalid port config for hotswap !!\n")));
                SOC_CONTROL_UNLOCK(unit);
                return SOC_E_PARAM;
            }
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Invalid port config for hotswap !!\n")));
            SOC_CONTROL_UNLOCK(unit);
            return SOC_E_PARAM;
        }
    } else if (old_value == 4 && lanes == 2) { /* HG[42] -> 2xHGd[21] */
        if (IS_HG_PORT(unit, port)) {
            /* Validate new HG count */
            PBMP_HG_ITER(unit, hp) {
                if (!SOC_PBMP_MEMBER(SOC_PORT_DISABLED_BITMAP(unit, port), hp)) {
                    hgc++;
                }
            }
            if (hgc+1 > _SOC_TR3_MAX_HG_PORT_COUNT) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Port config error (Higig port count[%d] exceeded) !!\n"),
                                      hgc));
                return SOC_E_PARAM;
            }
            si->port_speed_max[port] = 21000;
            si->port_speed_max[port+2] = 21000;
            if (IS_XE_PORT(unit, port+2)) {
                SOC_PBMP_PORT_REMOVE(si->xe.bitmap, port+2);
                SOC_PBMP_PORT_REMOVE(si->ether.bitmap, port+2);
                _soc_tr3_port_type_set(unit, port+2, SOC_ENCAP_HIGIG);
                *mode_change = SOC_ENCAP_HIGIG;
            } else if (IS_GE_PORT(unit, port+2)) {
                SOC_PBMP_PORT_REMOVE(si->ge.bitmap, port+2);
                SOC_PBMP_PORT_REMOVE(si->ether.bitmap, port+2);
                _soc_tr3_port_type_set(unit, port+2, SOC_ENCAP_HIGIG);
                *mode_change = SOC_ENCAP_HIGIG;
            }
            SOC_PBMP_PORT_ADD(si->hg.bitmap, port+2);
            SOC_PBMP_PORT_ADD(si->st.bitmap, port+2);
            SOC_PBMP_PORT_REMOVE(si->st.disabled_bitmap, port+2);
            SOC_PBMP_PORT_REMOVE(si->hg.disabled_bitmap, port+2);
            SOC_PBMP_PORT_REMOVE(si->port.disabled_bitmap, port+2);
            SOC_PBMP_PORT_REMOVE(si->all.disabled_bitmap, port+2);
            if (IS_XE_PORT(unit, port+2)) {
                RECONFIGURE_PORT_TYPE_INFO(ether);
                RECONFIGURE_PORT_TYPE_INFO(xe);
            } else if (IS_GE_PORT(unit, port+2)) {
                RECONFIGURE_PORT_TYPE_INFO(ether);
                RECONFIGURE_PORT_TYPE_INFO(ge);
            }
            RECONFIGURE_PORT_TYPE_INFO(st);
            RECONFIGURE_PORT_TYPE_INFO(hg);
        } else { /* 40GE -> 2xRXAUI */
            si->port_speed_max[port] = 11000;
            si->port_speed_max[port+2] = 11000;
            if (IS_HG_PORT(unit, port+2)) {
                SOC_PBMP_PORT_REMOVE(si->hg.bitmap, port+2);
                SOC_PBMP_PORT_REMOVE(si->st.bitmap, port+2);
                _soc_tr3_port_type_set(unit, port+2, SOC_ENCAP_IEEE);
                *mode_change = SOC_ENCAP_IEEE;
            }
            SOC_PBMP_PORT_ADD(si->xe.bitmap, port+2);
            SOC_PBMP_PORT_ADD(si->ether.bitmap, port+2);
            SOC_PBMP_PORT_REMOVE(si->xe.disabled_bitmap, port+2);
            SOC_PBMP_PORT_REMOVE(si->ether.disabled_bitmap, port+2);
            SOC_PBMP_PORT_REMOVE(si->port.disabled_bitmap, port+2);
            SOC_PBMP_PORT_REMOVE(si->all.disabled_bitmap, port+2);
            RECONFIGURE_PORT_TYPE_INFO(hg);
            RECONFIGURE_PORT_TYPE_INFO(xe);
        } 
    }
#undef RECONFIGURE_PORT_TYPE_INFO
    soc_dport_map_update(unit);
    SOC_CONTROL_UNLOCK(unit);
    /* 
     * NOTE: using 'old_value' for new port count loops and
     *       'lanes' for old port count loops.
     */ 

    /* reset port h/w (assume port en=f by now, pkts drained and link is down in 
       EPC_LINK_BMAP) */
#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        /* update tdm s/w array */
        (void)_soc_tr3_tdm_update(unit, port, lanes, FALSE);
        goto _skip_flex_hw_reconfig;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */
    SOC_IF_ERROR_RETURN(_soc_tr3_port_control(unit, port, pbt, FALSE));

    switch (old_value) {
    case 1: count = 4; break;
    case 2: count = 2; break;
    case 4: count = 1; break;
    default: break;
    }
    /* Disable egress cell request generation */
    sal_memset(&egr_en, 0, sizeof(egr_enable_entry_t));
    for (i = 0; i < count; i++) {
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_ENABLEm(unit, SOC_BLOCK_ANY, si->port_l2p_mapping[port + i], 
                               &egr_en));
    }
    /* reset egress buffers */
    SOC_IF_ERROR_RETURN(_soc_tr3_egress_buffer_reset(unit, port, pbt, TRUE));
    /* do port reset */
    SOC_IF_ERROR_RETURN(_soc_tr3_port_soft_reset(unit, port, pbt, TRUE));
    /* disable old subports */
    SOC_IF_ERROR_RETURN(_soc_tr3_subport_disable(unit, port, pbt, count, TRUE));
    /* clear ports mmu link list credit */
    for (i = 0; i < 4; i++) {
        phy = si->port_l2p_mapping[port + i];
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, lls_port_credit_reg[si->port_p2m_mapping[phy]],
                           REG_PORT_ANY, 0, 0));
    }

    /* Done with most of the stuff for the old ports, now work on the new ports */
    /* update port mode */
    SOC_IF_ERROR_RETURN(_soc_tr3_port_mode_set(unit, port, pbt, lanes));
    /* update tdm's */
    SOC_IF_ERROR_RETURN(_soc_tr3_tdm_update(unit, port, lanes, TRUE));

    SOC_IF_ERROR_RETURN(_soc_tr3_update_mcq_fifo(unit, prev_port_speeds));

    /* port reinit */
    SOC_IF_ERROR_RETURN(_soc_tr3_port_control(unit, port, pbt, TRUE));
    /* Set higig modes */
    PBMP_HG_ITER(unit, it_port) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, PORT_CONFIGr, it_port, HIGIG_MODEf, 1));
    }
    /* Clear non-higig mode */
    PBMP_XE_ITER(unit, it_port) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, PORT_CONFIGr, it_port, HIGIG_MODEf, 0));
    }
    PBMP_GE_ITER(unit, it_port) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, PORT_CONFIGr, it_port, HIGIG_MODEf, 0));
    }
    /* release port reset */
    SOC_IF_ERROR_RETURN(_soc_tr3_port_soft_reset(unit, port, pbt, FALSE));
    /* release egress buffer reset */
    SOC_IF_ERROR_RETURN(_soc_tr3_egress_buffer_reset(unit, port, pbt, FALSE));
    switch (lanes) {
    case 1: count = 4; break;
    case 2: count = 2; break;
    case 4: count = 1; break;
    default: break;
    }
    /* Enable new subports */
    SOC_IF_ERROR_RETURN(_soc_tr3_subport_disable(unit, port, pbt, count, FALSE));
    /* Enable egress cell request generation */
    soc_EGR_ENABLEm_field32_set(unit, &egr_en, PRT_ENABLEf, 1);
#ifdef BCM_WARM_BOOT_SUPPORT
_skip_flex_hw_reconfig:
#endif /* BCM_WARM_BOOT_SUPPORT */
    /* update num lanes, flex p2l maps */
    phy = si->port_l2p_mapping[port];
    SOC_CONTROL_LOCK(unit);
    switch (lanes) {
    case 1:
        if (!SOC_WARM_BOOT(unit)) {
            for (i = 0; i < count; i++) {
                SOC_IF_ERROR_RETURN
                    (WRITE_EGR_ENABLEm(unit, SOC_BLOCK_ANY, 
                                       si->port_l2p_mapping[port + i], &egr_en));
            }
        }
        si->port_num_lanes[port] = lanes;
        si->port_num_lanes[port+1] = lanes;
        si->port_num_lanes[port+2] = lanes;
        si->port_num_lanes[port+3] = lanes;
        si->flex_port_p2l_mapping[phy+1] = port+1;
        si->flex_port_p2l_mapping[phy+2] = port+2;
        si->flex_port_p2l_mapping[phy+3] = port+3;
        break;
    case 2:
        if (!SOC_WARM_BOOT(unit)) {
            SOC_IF_ERROR_RETURN
                (WRITE_EGR_ENABLEm(unit, SOC_BLOCK_ANY, si->port_l2p_mapping[port], 
                                   &egr_en)); 
            SOC_IF_ERROR_RETURN
                (WRITE_EGR_ENABLEm(unit, SOC_BLOCK_ANY, si->port_l2p_mapping[port + 2], 
                                   &egr_en)); 
        }
        si->port_num_lanes[port] = lanes;
        si->port_num_lanes[port+1] = 0;
        si->port_num_lanes[port+2] = lanes;
        si->port_num_lanes[port+3] = 0;
        si->flex_port_p2l_mapping[phy+1] = -1;
        si->flex_port_p2l_mapping[phy+2] = port+2;
        si->flex_port_p2l_mapping[phy+3] = -1;
        break;
    case 4:
        if (!SOC_WARM_BOOT(unit)) {
            SOC_IF_ERROR_RETURN
                (WRITE_EGR_ENABLEm(unit, SOC_BLOCK_ANY, si->port_l2p_mapping[port], 
                                   &egr_en)); 
        }
        si->port_num_lanes[port] = lanes;
        si->port_num_lanes[port+1] = 0;
        si->port_num_lanes[port+2] = 0;
        si->port_num_lanes[port+3] = 0;
        si->flex_port_p2l_mapping[phy+1] = -1;
        si->flex_port_p2l_mapping[phy+2] = -1;
        si->flex_port_p2l_mapping[phy+3] = -1;
        break;
    default: break;
    }
    SOC_CONTROL_UNLOCK(unit);
    /* assume port en=t follows and link will be up in EPC_LINK_BMAP */

    return SOC_E_NONE;
}

int
soc_tr3_phy_addr_get(int unit, soc_port_t port, uint16 *int_addr)
{
    /* NOTE: this is copied from phyident.c and should be kept in sync */
    static const uint16 _soc_triumph3_int_phy_addr[] = {
        0x80, /* Port   0 (cmic) N/A */
        0x81, /* Port   1 (XC0) IntBus=0 Addr=0x01 */
        0x82, /* Port   2 (XC0) IntBus=0 Addr=0x02 */
        0x83, /* Port   3 (XC0) IntBus=0 Addr=0x03 */
        0x84, /* Port   4 (XC0) IntBus=0 Addr=0x04 */
        0x85, /* Port   5 (XC1) IntBus=0 Addr=0x05 */
        0x86, /* Port   6 (XC1) IntBus=0 Addr=0x06 */
        0x87, /* Port   7 (XC1) IntBus=0 Addr=0x07 */
        0x88, /* Port   8 (XC1) IntBus=0 Addr=0x08 */
        0x89, /* Port   9 (XC2) IntBus=0 Addr=0x09 */
        0x8A, /* Port  10 (XC2) IntBus=0 Addr=0x0A */
        0x8B, /* Port  11 (XC2) IntBus=0 Addr=0x0B */
        0x8C, /* Port  12 (XC2) IntBus=0 Addr=0x0C */
        0x8D, /* Port  13 (XC3) IntBus=0 Addr=0x0D */
        0x8E, /* Port  14 (XC3) IntBus=0 Addr=0x0E */
        0x8F, /* Port  15 (XC3) IntBus=0 Addr=0x0F */
        0x90, /* Port  16 (XC3) IntBus=0 Addr=0x10 */
        0x91, /* Port  17 (XC4) IntBus=0 Addr=0x11 */
        0x92, /* Port  18 (XC4) IntBus=0 Addr=0x12 */
        0x93, /* Port  19 (XC4) IntBus=0 Addr=0x13 */
        0x94, /* Port  20 (XC4) IntBus=0 Addr=0x14 */
        0x95, /* Port  21 (XC5) IntBus=0 Addr=0x15 */
        0x96, /* Port  22 (XC5) IntBus=0 Addr=0x16 */
        0x97, /* Port  23 (XC5) IntBus=0 Addr=0x17 */
        0x98, /* Port  24 (XC5) IntBus=0 Addr=0x18 */
        0x99, /* Port  25 (XC6) IntBus=0 Addr=0x19 */
        0x9A, /* Port  26 (XC6) IntBus=0 Addr=0x1A */
        0x9B, /* Port  27 (XC6) IntBus=0 Addr=0x1B */
        0x9C, /* Port  28 (XC6) IntBus=0 Addr=0x1C */

        0xA1, /* Port  29 (XC7) IntBus=1 Addr=0x01 */
        0xA2, /* Port  30 (XC7) IntBus=1 Addr=0x02 */
        0xA3, /* Port  31 (XC7) IntBus=1 Addr=0x03 */
        0xA4, /* Port  32 (XC7) IntBus=1 Addr=0x04 */
        0xA5, /* Port  33 (XC8) IntBus=1 Addr=0x05 */
        0xA6, /* Port  34 (XC8) IntBus=1 Addr=0x06 */
        0xA7, /* Port  35 (XC8) IntBus=1 Addr=0x07 */
        0xA8, /* Port  36 (XC8) IntBus=1 Addr=0x08 */
        0xA9, /* Port  37 (XC9) IntBus=1 Addr=0x09 */
        0,    /* Port  38 (---) IntBus=1 Addr=0 */
        0,    /* Port  39 (---) IntBus=1 Addr=0 */
        0,    /* Port  40 (---) IntBus=1 Addr=0 */
        0xAD, /* Port  41 (XC10) IntBus=1 Addr=0x0D */
        0xAE, /* Port  42 (XC10) IntBus=1 Addr=0x0E */
        0xAF, /* Port  43 (XC10) IntBus=1 Addr=0x0F */
        0xB0, /* Port  44 (XC10) IntBus=1 Addr=0x10 */
        0xB1, /* Port  45 (XC11) IntBus=1 Addr=0x11 */
        0xB2, /* Port  46 (XC11) IntBus=1 Addr=0x12 */
        0xB3, /* Port  47 (XC11) IntBus=1 Addr=0x13 */
        0xB4, /* Port  48 (XC11) IntBus=1 Addr=0x14 */
        0xB5, /* Port  49 (XC12) IntBus=1 Addr=0x15 */
        0xB6, /* Port  50 (XC12) IntBus=1 Addr=0x16 */
        0xB7, /* Port  51 (XC12) IntBus=1 Addr=0x17 */
        0xB8, /* Port  52 (XC12) IntBus=1 Addr=0x18 */

#ifdef TR3_WCMOD_MULTIPORT_SUPPORT
        
        0xC1, /* Port  53 (WC0) IntBus=2 Addr=0x01 */
        0xC2, /* Port  54 (WC0) IntBus=2 Addr=0x02 */
        0xC3, /* Port  55 (WC0) IntBus=2 Addr=0x03 */
        0xC4, /* Port  56 (WC0) IntBus=2 Addr=0x04 */
        0xC5, /* Port  57 (WC1) IntBus=2 Addr=0x05 */
        0xC6, /* Port  58 (WC1) IntBus=2 Addr=0x06 */
        0xC7, /* Port  59 (WC1) IntBus=2 Addr=0x07 */
        0xC8, /* Port  60 (WC1) IntBus=2 Addr=0x08 */
        0xC9, /* Port  61 (WC2) IntBus=2 Addr=0x09 */
        0xCA, /* Port  62 (WC2) IntBus=2 Addr=0x0A */
        0xCB, /* Port  63 (WC2) IntBus=2 Addr=0x0B */
        0xCC, /* Port  64 (WC2) IntBus=2 Addr=0x0C */
        0xCD, /* Port  65 (WC3) IntBus=2 Addr=0x0D */
        0xCE, /* Port  66 (WC3) IntBus=2 Addr=0x0E */
        0xCF, /* Port  67 (WC3) IntBus=2 Addr=0x0F */
        0xD0, /* Port  68 (WC3) IntBus=2 Addr=0x10 */
        0xD1, /* Port  69 (WC4) IntBus=2 Addr=0x11 */
        0xD2, /* Port  70 (WC4) IntBus=2 Addr=0x12 */
        0xD3, /* Port  71 (WC4) IntBus=2 Addr=0x13 */
        0xD4, /* Port  72 (WC4) IntBus=2 Addr=0x14 */
        0xD5, /* Port  73 (WC5) IntBus=2 Addr=0x15 */
        0xD6, /* Port  74 (WC5) IntBus=2 Addr=0x16 */
        0xD7, /* Port  75 (WC5) IntBus=2 Addr=0x17 */
        0xD8, /* Port  76 (WC5) IntBus=2 Addr=0x18 */
        0xD9, /* Port  77 (WC6) IntBus=2 Addr=0x19 */
        0xDA, /* Port  78 (WC6) IntBus=2 Addr=0x1A */
        0xDB, /* Port  79 (WC6) IntBus=2 Addr=0x1B */
        0xDC, /* Port  80 (WC6) IntBus=2 Addr=0x1C */
#else
        0xC1, /* Port  53 (WC0) IntBus=2 Addr=0x01 */
        0xC1, /* Port  54 (WC0) IntBus=2 Addr=0x02 */
        0xC1, /* Port  55 (WC0) IntBus=2 Addr=0x03 */
        0xC1, /* Port  56 (WC0) IntBus=2 Addr=0x04 */
        0xC5, /* Port  57 (WC1) IntBus=2 Addr=0x05 */
        0xC5, /* Port  58 (WC1) IntBus=2 Addr=0x06 */
        0xC5, /* Port  59 (WC1) IntBus=2 Addr=0x07 */
        0xC5, /* Port  60 (WC1) IntBus=2 Addr=0x08 */
        0xC9, /* Port  61 (WC2) IntBus=2 Addr=0x09 */
        0xC9, /* Port  62 (WC2) IntBus=2 Addr=0x0A */
        0xC9, /* Port  63 (WC2) IntBus=2 Addr=0x0B */
        0xC9, /* Port  64 (WC2) IntBus=2 Addr=0x0C */
        0xCD, /* Port  65 (WC3) IntBus=2 Addr=0x0D */
        0xCD, /* Port  66 (WC3) IntBus=2 Addr=0x0E */
        0xCD, /* Port  67 (WC3) IntBus=2 Addr=0x0F */
        0xCD, /* Port  68 (WC3) IntBus=2 Addr=0x10 */
        0xD1, /* Port  69 (WC4) IntBus=2 Addr=0x11 */
        0xD1, /* Port  70 (WC4) IntBus=2 Addr=0x12 */
        0xD1, /* Port  71 (WC4) IntBus=2 Addr=0x13 */
        0xD1, /* Port  72 (WC4) IntBus=2 Addr=0x14 */
        0xD5, /* Port  73 (WC5) IntBus=2 Addr=0x15 */
        0xD5, /* Port  74 (WC5) IntBus=2 Addr=0x16 */
        0xD5, /* Port  75 (WC5) IntBus=2 Addr=0x17 */
        0xD5, /* Port  76 (WC5) IntBus=2 Addr=0x18 */
        0xD9, /* Port  77 (WC6) IntBus=2 Addr=0x19 */
        0xD9, /* Port  78 (WC6) IntBus=2 Addr=0x1A */
        0xD9, /* Port  79 (WC6) IntBus=2 Addr=0x1B */
        0xD9, /* Port  80 (WC6) IntBus=2 Addr=0x1C */
#endif /* TR3_WCMOD_MULTIPORT_SUPPORT */
    };
    *int_addr = _soc_triumph3_int_phy_addr[SOC_INFO(unit).port_l2p_mapping[port]];
    return SOC_E_NONE;
}

#define _TR3_MMU_BYTES_TO_CELLS(_byte_)  \
    (((_byte_) + _TR3_MMU_BYTES_PER_CELL - 1) / _TR3_MMU_BYTES_PER_CELL)
    
STATIC void
_soc_tr3_mmu_init_dev_config(int unit, _soc_mmu_device_info_t *devcfg)
{
    sal_memset(devcfg, 0, sizeof(_soc_mmu_device_info_t));

    devcfg->max_pkt_byte = _TR3_MMU_MAX_PACKET_BYTES;
    devcfg->mmu_hdr_byte = _TR3_MMU_PACKET_HEADER_BYTES;
    devcfg->jumbo_pkt_size = _TR3_MMU_JUMBO_FRAME_BYTES;
    devcfg->default_mtu_size = _TR3_MMU_DEFAULT_MTU_BYTES;
    devcfg->mmu_cell_size = _TR3_MMU_BYTES_PER_CELL;
    devcfg->mmu_total_cell = _TR3_MMU_TOTAL_CELLS(unit) - _TR3_MMU_CELLS_RSVD_IP; /* cells for IP */
    devcfg->num_pg = _TR3_MMU_NUM_PG;
    devcfg->num_service_pool = _TR3_MMU_NUM_POOL;
}

STATIC int
_soc_tr3_default_pg_headroom(int unit, soc_port_t port, int lossless)
{
    int speed = 1000, hdrm = 0;

    if ((!lossless) || (IS_CPU_PORT(unit, port)) || (IS_AXP_PORT(unit, port))) {
        return 0;
    }

    speed = SOC_INFO(unit).port_speed_max[port];
    
    if ((speed >= 1000) && (speed < 10000)) {
        hdrm = 162;
    } else if ((speed >= 10000) && (speed < 20000)) {
        hdrm = 242;
    } else if ((speed >= 20000) && (speed <= 42000)) {
        hdrm = 344;
    } else if (speed >= 100000) {
        hdrm = 768;
    } else {
        hdrm = 162;
    }
    return hdrm;
}

STATIC void
_soc_tr3_mmu_config_buf_default(int unit, _soc_mmu_cfg_buf_t *buf)
{
    soc_info_t *si;
    _soc_mmu_cfg_buf_pool_t *buf_pool;
    _soc_mmu_cfg_buf_port_t *buf_port;
    _soc_mmu_cfg_buf_port_pool_t *buf_port_pool;
    _soc_mmu_cfg_buf_prigroup_t *buf_prigroup;
    _soc_mmu_cfg_buf_queue_t *buf_queue;
    int max_packet_cells, jumbo_frame_cells, default_mtu_cells;
    int port, idx, per_q_guarentee;
    int total_pool_size = 0, egr_shared_total = 0, lossless = 1;
    int q_reserved = 0, numq, tmp, in_reserved = 0;
    _soc_mmu_cfg_buf_qgroup_t *queue_grp;

    si = &SOC_INFO(unit);

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "Initializing default MMU config (u=%d)\n"), unit));
    max_packet_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(_TR3_MMU_MAX_PACKET_BYTES +
                                              _TR3_MMU_PACKET_HEADER_BYTES,
                                              _TR3_MMU_BYTES_PER_CELL);
    jumbo_frame_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(_TR3_MMU_JUMBO_FRAME_BYTES +
                                               _TR3_MMU_PACKET_HEADER_BYTES,
                                               _TR3_MMU_BYTES_PER_CELL);
    default_mtu_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(_TR3_MMU_DEFAULT_MTU_BYTES +
                                               _TR3_MMU_PACKET_HEADER_BYTES,
                                               _TR3_MMU_BYTES_PER_CELL);

    total_pool_size = _TR3_MMU_TOTAL_CELLS(unit) - _TR3_MMU_CELLS_RSVD_IP;
    
    lossless = soc_property_get(unit, spn_MMU_LOSSLESS, 1);

    buf->headroom = 2 * jumbo_frame_cells;

    in_reserved += buf->headroom;

    per_q_guarentee = (lossless) ? 0 : default_mtu_cells;
    PBMP_ALL_ITER(unit, port) {
        numq = 0;
        soc_tr3_get_def_qbase(unit, port, _SOC_TR3_INDEX_STYLE_UCAST_QUEUE, 
                       NULL, &tmp);
        numq += tmp;
        soc_tr3_get_def_qbase(unit, port, _SOC_TR3_INDEX_STYLE_MCAST_QUEUE, 
                       NULL, &tmp);
        numq += tmp;
        q_reserved += per_q_guarentee * numq;
    }
    
    egr_shared_total = total_pool_size - q_reserved;

    for (idx = 0; idx < _TR3_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];

        if (idx == 0) {  /* 100% scale up by 100 */
            buf_pool->size = 10000 | _MMU_CFG_BUF_PERCENT_FLAG;
            buf_pool->yellow_size = 10000 | _MMU_CFG_BUF_PERCENT_FLAG;
            buf_pool->red_size = 10000 | _MMU_CFG_BUF_PERCENT_FLAG;
        } else {
            buf_pool->size = 0;
            buf_pool->yellow_size = 0;
            buf_pool->red_size = 0;
        }
    }

    for (idx = 0; idx < SOC_MMU_CFG_QGROUP_MAX; idx++) {
        queue_grp = &buf->qgroups[idx];
        queue_grp->guarantee = 0;
        queue_grp->pool_limit = total_pool_size;
        queue_grp->discard_enable = (lossless) ? 0 : 1;
        queue_grp->pool_scale = -1;
        queue_grp->pool_resume = default_mtu_cells * 2;
        queue_grp->red_limit = 7 | _MMU_CFG_BUF_DYNAMIC_FLAG;
        queue_grp->yellow_limit = 7 | _MMU_CFG_BUF_DYNAMIC_FLAG;
        queue_grp->yellow_resume = default_mtu_cells * 2;
        queue_grp->red_resume = default_mtu_cells * 2;
    }

    PBMP_ALL_ITER(unit, port) {
        buf_port = &buf->ports[port];

        /* internal priority to priority group mapping */
        for (idx = 0; idx < 16; idx++) {
            buf_port->pri_to_prigroup[idx] = 7;
        }

        /* priority group to pool mapping */
        for (idx = 0; idx < _TR3_MMU_NUM_PG; idx++) {
            buf_port->prigroups[idx].pool_idx = 0;
        }

        for (idx = 0; idx < _TR3_MMU_NUM_POOL; idx++) {
            buf_port_pool = &buf_port->pools[idx];
            buf_port_pool->guarantee = 0;
            buf_port_pool->pool_limit = 0;
            buf_port_pool->pool_resume = 0;
            if (idx == 0) {
                buf_port_pool->pool_limit = total_pool_size;
                buf_port_pool->pool_resume = 
                            total_pool_size - (default_mtu_cells * 2);
            }
            in_reserved += buf_port_pool->guarantee;
        }

        buf_port->pkt_size = max_packet_cells;
        
        /* priority group */
        for (idx = 0; idx < _TR3_MMU_NUM_PG; idx++) {
            buf_prigroup = &buf_port->prigroups[idx];
            buf_prigroup->guarantee = 0;
            buf_prigroup->user_delay = -1;
            buf_prigroup->switch_delay = -1;
            buf_prigroup->pkt_size = max_packet_cells;
            buf_prigroup->device_headroom_enable = 0;
            buf_prigroup->pool_limit = 0;
            buf_prigroup->pool_floor = 0;
            buf_prigroup->pool_scale = -1;
            buf_prigroup->headroom = 0;
            buf_prigroup->pool_resume = 0;
            buf_prigroup->flow_control_enable = 0;
            if (idx == 7) {
                buf_prigroup->device_headroom_enable = 1;
                buf_prigroup->guarantee = jumbo_frame_cells;
                buf_prigroup->flow_control_enable = lossless;
                if (lossless) {
                    buf_prigroup->headroom = 
                        _soc_tr3_default_pg_headroom(unit, port, lossless);
                    buf_prigroup->pool_scale = 7;
                }
            }

            in_reserved += buf_prigroup->guarantee + buf_prigroup->headroom;
        }

        /* multicast queue */
        for (idx = 0; idx < si->port_num_cosq[port]; idx++) {
            buf_queue = &buf_port->queues[idx];
            buf_queue->qgroup_id = -1;
            if (lossless) {
                buf_queue->guarantee = 0;
                buf_queue->discard_enable = 0;
                buf_queue->pool_scale = -1;
                buf_queue->pool_limit = egr_shared_total;
                buf_queue->red_limit = egr_shared_total;
                buf_queue->color_discard_enable = 0;
                buf_queue->pool_resume = 16;
            } else {
                buf_queue->guarantee = default_mtu_cells;
                buf_queue->discard_enable = 1;
                buf_queue->pool_scale = 7;
                buf_queue->pool_limit = 0;
                buf_queue->red_limit = 7 | _MMU_CFG_BUF_DYNAMIC_FLAG;
                buf_queue->color_discard_enable = 1;
                buf_queue->pool_resume = 16;
            }
        }

        /* unicast queue */
        for (idx = 0; idx < si->port_num_uc_cosq[port]; idx++) {
            buf_queue = &buf_port->queues[si->port_num_cosq[port] + idx];
            buf_queue->qgroup_id = -1;
            if (lossless) {
                buf_queue->guarantee = 0;
                buf_queue->discard_enable = 0;
                buf_queue->pool_scale = -1;
                buf_queue->pool_limit = egr_shared_total;
                buf_queue->red_limit = egr_shared_total;
                buf_queue->yellow_limit = egr_shared_total;
                buf_queue->color_discard_enable = 0;
                buf_queue->pool_resume = default_mtu_cells * 2;
                buf_queue->yellow_resume = default_mtu_cells * 2;
                buf_queue->red_resume = default_mtu_cells * 2;
            } else {
                buf_queue->guarantee = default_mtu_cells;
                buf_queue->discard_enable = 1;
                buf_queue->pool_scale = 7;
                buf_queue->pool_limit = 0;
                buf_queue->red_limit = 7 | _MMU_CFG_BUF_DYNAMIC_FLAG;
                buf_queue->yellow_limit = 7 | _MMU_CFG_BUF_DYNAMIC_FLAG;
                buf_queue->color_discard_enable = 1;
                buf_queue->pool_resume = default_mtu_cells * 2;
                buf_queue->yellow_resume = default_mtu_cells * 2;
                buf_queue->red_resume = default_mtu_cells * 2;
            }
        }

        /* queue to pool mapping */
        for (idx = 0; 
             idx < si->port_num_cosq[port] + si->port_num_uc_cosq[port]; idx++) {
            buf_port->queues[idx].pool_idx = 0;
        }
    }

    PBMP_ALL_ITER(unit, port) {
        buf_port = &buf->ports[port];
        buf_prigroup = &buf_port->prigroups[7];
        if (!lossless) {
            buf_prigroup->pool_limit = total_pool_size - in_reserved;
        }
    }

    /* extended queue profiles */
    for (idx = 0; idx < SOC_MMU_CFG_EQUEUE_MAX; idx++) {
        buf_queue = &buf->equeues[idx];
        buf_queue->numq = 0;
        buf_queue->guarantee = 0;
        buf_queue->pool_limit = 0;
        buf_queue->discard_enable = 1;
        buf_queue->pool_scale = -1;
        buf_queue->pool_resume = default_mtu_cells * 2;
        buf_queue->red_limit = 7 | _MMU_CFG_BUF_DYNAMIC_FLAG;
        buf_queue->yellow_limit = 7 | _MMU_CFG_BUF_DYNAMIC_FLAG;
        buf_queue->yellow_resume = default_mtu_cells * 2;
        buf_queue->red_resume = default_mtu_cells * 2;
    }

}

STATIC int
_soc_tr3_pool_scale_to_limit(int size, int scale)
{
    int factor = 1000;

    switch (scale) {
        case 7: factor = 875; break;
        case 6: factor = 750; break;
        case 5: factor = 625; break;
        case 4: factor = 500; break;
        case 3: factor = 375; break;
        case 2: factor = 250; break;
        case 1: factor = 125; break;
        case 0:
        default:
            factor = 1000; break;
    }
    return (size * factor)/1000;
}

STATIC int
_soc_tr3_mmu_config_buf_set_hw(int unit, _soc_mmu_cfg_buf_t *buf)
{
    soc_info_t *si;
    _soc_mmu_cfg_buf_pool_t *buf_pool;
    _soc_mmu_cfg_buf_port_t *buf_port;
    _soc_mmu_cfg_buf_prigroup_t *buf_prigroup;
    _soc_mmu_cfg_buf_queue_t *buf_queue;
    _soc_mmu_cfg_buf_port_pool_t *buf_port_pool;
    soc_reg_t reg = INVALIDr;
    uint32 rval, fval;
    uint32 entry0[SOC_MAX_MEM_WORDS], entry1[SOC_MAX_MEM_WORDS];
    thdi_port_pg_config_entry_t pg_config_mem;
    thdi_port_sp_config_entry_t thdi_sp_config;
    mmu_thdo_config_qgroup_entry_t cfg_qgrp;
    int default_mtu_cells, limit, midx, pri, pool;
    int port, phy_port, mmu_port, base, numq, idx;
    int jumbo_frame_cells, pval;
    _soc_mmu_cfg_buf_qgroup_t *queue_grp;
    static const soc_field_t prigroup_reg[] = {
        PORT_PRI_GRP0r, PORT_PRI_GRP1r
    };
    static const soc_field_t prigroup_field[] = {
        PRI0_GRPf, PRI1_GRPf, PRI2_GRPf, PRI3_GRPf,
        PRI4_GRPf, PRI5_GRPf, PRI6_GRPf, PRI7_GRPf,
        PRI8_GRPf, PRI9_GRPf, PRI10_GRPf, PRI11_GRPf,
        PRI12_GRPf, PRI13_GRPf, PRI14_GRPf, PRI15_GRPf
    };
    static const soc_field_t prigroup_spid_field[] = {
        PG0_SPIDf, PG1_SPIDf, PG2_SPIDf, PG3_SPIDf,
        PG4_SPIDf, PG5_SPIDf, PG6_SPIDf, PG7_SPIDf
    };

    si = &SOC_INFO(unit);

    default_mtu_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(_TR3_MMU_DEFAULT_MTU_BYTES +
                                               _TR3_MMU_PACKET_HEADER_BYTES,
                                               _TR3_MMU_BYTES_PER_CELL);

    jumbo_frame_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(_TR3_MMU_JUMBO_FRAME_BYTES +
                                               _TR3_MMU_PACKET_HEADER_BYTES,
                                               _TR3_MMU_BYTES_PER_CELL);

    rval = 0;
    fval = _TR3_MMU_TOTAL_CELLS(unit) - _TR3_MMU_CELLS_RSVD_IP;
    soc_reg_field_set(unit, CFAPFULLTHRESHOLDr, &rval, CFAPFULLSETPOINTf, fval);
    soc_reg_field_set(unit, CFAPFULLTHRESHOLDr, &rval, CFAPFULLRESETPOINTf,
                        fval - 2*jumbo_frame_cells);
    SOC_IF_ERROR_RETURN(WRITE_CFAPFULLTHRESHOLDr(unit, rval));

    /* internal priority to priority group mapping */
    PBMP_ALL_ITER(unit, port) {
        buf_port = &buf->ports[port];

        for (idx = 0; idx < 16; idx++) {
            if (idx % 8 == 0) { /* 8 fields per register */
                reg = prigroup_reg[idx / 8];
                rval = 0;
            }
            soc_reg_field_set(unit, reg, &rval, prigroup_field[idx],
                              buf_port->pri_to_prigroup[idx]);
            if (idx % 8 == 7) { /* 8 fields per register */
                SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
            }
        }
    }

    /* Input port device settings */
    rval = 0;
    soc_reg_field_set(unit, GLOBAL_HDRM_LIMITr, &rval, GLOBAL_HDRM_LIMITf,
                      buf->headroom);
    SOC_IF_ERROR_RETURN(WRITE_GLOBAL_HDRM_LIMITr(unit, rval));
    
    fval = 0;
    for (idx = 0; idx < _TR3_MMU_NUM_POOL; idx++) {
        if ((buf->pools[idx].size & ~_MMU_CFG_BUF_PERCENT_FLAG) != 0) {
            fval |= 1 << idx;
        }
    }
    rval = 0;
    soc_reg_field_set(unit, USE_SP_SHAREDr, &rval, ENABLEf, fval);
    SOC_IF_ERROR_RETURN(WRITE_USE_SP_SHAREDr(unit, rval));

    fval = 0;
    for (idx = 0; idx < _TR3_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];
        if ((buf_pool->size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 0) {
            continue;
        }

        if (buf_pool->yellow_size & _MMU_CFG_BUF_PERCENT_FLAG) {
            if ((buf_pool->yellow_size & ~_MMU_CFG_BUF_PERCENT_FLAG) < 10000) {
                fval |= 1 << idx;
            }
        } else {
            if (buf->pools[idx].size != buf->pools[idx].yellow_size) {
                fval |= 1 << idx;
            }
        }
    }
    rval = 0;
    soc_reg_field_set(unit, COLOR_AWAREr, &rval, ENABLEf, fval);
    SOC_IF_ERROR_RETURN(WRITE_COLOR_AWAREr(unit, rval));

    /* configure Q-groups */
    for (idx = 0; idx < SOC_MMU_CFG_QGROUP_MAX; idx++) {
        queue_grp = &buf->qgroups[idx];
    
        sal_memset(&cfg_qgrp, 0, sizeof(cfg_qgrp));

        soc_mem_field32_set(unit, MMU_THDO_CONFIG_QGROUPm, &cfg_qgrp, 
                Q_MIN_LIMIT_CELLf, queue_grp->guarantee);
        if (queue_grp->pool_scale != -1) {
            soc_mem_field32_set(unit, MMU_THDO_CONFIG_QGROUPm, &cfg_qgrp, 
                               Q_SHARED_ALPHA_CELLf, queue_grp->pool_scale);
            soc_mem_field32_set(unit, MMU_THDO_CONFIG_QGROUPm, &cfg_qgrp, 
                                    Q_LIMIT_DYNAMIC_CELLf, 1);
        } else {
            soc_mem_field32_set(unit, MMU_THDO_CONFIG_QGROUPm, &cfg_qgrp, 
                                Q_SHARED_LIMIT_CELLf, queue_grp->pool_limit);
        }
        
        if ((queue_grp->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
            (queue_grp->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
            soc_mem_field32_set(unit, MMU_THDO_CONFIG_QGROUPm, &cfg_qgrp, 
                                    Q_COLOR_LIMIT_DYNAMIC_CELLf, 1);
        }

        if (queue_grp->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) {
            pval = _soc_tr3_pool_scale_to_limit(queue_grp->pool_limit,
                          queue_grp->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG);
            soc_mem_field32_set(unit, MMU_THDO_CONFIG_QGROUPm, &cfg_qgrp, 
                                    LIMIT_RED_CELLf, pval/8);

        } else {
            soc_mem_field32_set(unit, MMU_THDO_CONFIG_QGROUPm, &cfg_qgrp, 
                                    LIMIT_RED_CELLf, queue_grp->red_limit);
        }

        if (queue_grp->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) {
            pval = _soc_tr3_pool_scale_to_limit(queue_grp->pool_limit,
                          queue_grp->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG);
            soc_mem_field32_set(unit, MMU_THDO_CONFIG_QGROUPm, &cfg_qgrp, 
                                    LIMIT_YELLOW_CELLf, pval/8);

        } else {
            soc_mem_field32_set(unit, MMU_THDO_CONFIG_QGROUPm, &cfg_qgrp, 
                                    LIMIT_YELLOW_CELLf, queue_grp->yellow_limit);
        }

        if (queue_grp->discard_enable) {
            soc_mem_field32_set(unit, MMU_THDO_CONFIG_QGROUPm, &cfg_qgrp, 
                                    Q_LIMIT_ENABLE_CELLf, 1);
        }

        SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, MMU_THDO_CONFIG_QGROUPm, MEM_BLOCK_ALL,
                               idx, &cfg_qgrp));
    }

    /* per service pool settings */
    for (idx = 0; idx < _TR3_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];
        if ((buf_pool->size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 0) {
            continue;
        }

        limit = buf_pool->total - (buf_pool->prigroup_headroom +
                                   buf_pool->prigroup_guarantee + 
                                   buf->headroom);

        rval = 0;
        soc_reg_field_set(unit, BUFFER_CELL_LIMIT_SPr, &rval, LIMITf, limit);
        SOC_IF_ERROR_RETURN(WRITE_BUFFER_CELL_LIMIT_SPr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, CELL_RESET_LIMIT_OFFSET_SPr, &rval, OFFSETf,
                          NUM_PORT(unit) * default_mtu_cells / 2);
        SOC_IF_ERROR_RETURN(WRITE_CELL_RESET_LIMIT_OFFSET_SPr(unit, idx, rval));

        if (buf_pool->yellow_size & _MMU_CFG_BUF_PERCENT_FLAG) {
            if ((buf_pool->yellow_size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 10000) {
                continue;
            }
        } else {
            if (buf_pool->size == buf_pool->yellow_size) {
                continue;
            }
        }

        if (buf_pool->yellow_size & _MMU_CFG_BUF_PERCENT_FLAG) {
            fval = (buf_pool->yellow_size & ~_MMU_CFG_BUF_PERCENT_FLAG) * limit /
                10000;
        } else {
            fval = buf_pool->yellow_size;
        }
        rval = 0;
        soc_reg_field_set(unit, CELL_SPAP_YELLOW_OFFSET_SPr, &rval, OFFSETf, 
                          limit - fval);
        SOC_IF_ERROR_RETURN
            (WRITE_CELL_SPAP_YELLOW_OFFSET_SPr(unit, idx, rval));

        if (buf_pool->red_size & _MMU_CFG_BUF_PERCENT_FLAG) {
            fval = (buf_pool->red_size & ~_MMU_CFG_BUF_PERCENT_FLAG) * limit /
                10000;
        } else {
            fval = buf_pool->red_size;
        }
        rval = 0;
        soc_reg_field_set(unit, CELL_SPAP_RED_OFFSET_SPr, &rval, OFFSETf,
                          limit - fval);
        SOC_IF_ERROR_RETURN(WRITE_CELL_SPAP_RED_OFFSET_SPr(unit, idx, rval));
    }

    /* Input port per port settings */
    PBMP_ALL_ITER(unit, port) {
        phy_port = si->port_l2p_mapping[port];
        mmu_port = si->port_p2m_mapping[phy_port];
        buf_port = &buf->ports[port];

        rval = 0;
        for (idx = 0; idx < _TR3_MMU_NUM_PG; idx++) {
            soc_reg_field_set(unit, PORT_PG_SPIDr, &rval,
                              prigroup_spid_field[idx],
                              buf_port->prigroups[idx].pool_idx);
        }
        SOC_IF_ERROR_RETURN(WRITE_PORT_PG_SPIDr(unit, port, rval));

        /* Per port per pool settings */
        for (idx = 0; idx < _TR3_MMU_NUM_POOL; idx++) {
            buf_port_pool = &buf_port->pools[idx];
            midx = (mmu_port * 4) + idx;
            sal_memset(&thdi_sp_config, 0, sizeof(thdi_sp_config));
            soc_mem_field32_set(unit, THDI_PORT_SP_CONFIGm, &thdi_sp_config, 
                                PORT_SP_MIN_LIMITf, buf_port_pool->guarantee);
            soc_mem_field32_set(unit, THDI_PORT_SP_CONFIGm, &thdi_sp_config, 
                           PORT_SP_RESUME_LIMITf, buf_port_pool->pool_resume);
            soc_mem_field32_set(unit, THDI_PORT_SP_CONFIGm, &thdi_sp_config, 
                               PORT_SP_MAX_LIMITf, buf_port_pool->pool_limit);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, THDI_PORT_SP_CONFIGm, MEM_BLOCK_ALL,
                               midx, &thdi_sp_config));
        }

        fval = 0;
        for (idx = 0; idx < _TR3_MMU_NUM_PG; idx++) {
            if (buf_port->prigroups[idx].flow_control_enable != 0) {
                for (pri=0; pri < 16; pri++) {
                    if (buf_port->pri_to_prigroup[pri] == idx) {
                        fval |= 1 << pri;
                    }
                }
            }
        }

        rval = 0;
        soc_reg_field_set(unit, PORT_PRI_XON_ENABLEr, &rval,
                          PORT_PRI_XON_ENABLEf, fval);
        SOC_IF_ERROR_RETURN(WRITE_PORT_PRI_XON_ENABLEr(unit, port, rval));

        rval = 0;
        soc_reg_field_set(unit, PORT_MAX_PKT_SIZEr, &rval, PORT_MAX_PKT_SIZEf,
                          buf_port->pkt_size);
        SOC_IF_ERROR_RETURN(WRITE_PORT_MAX_PKT_SIZEr(unit, port, rval));

        /* Input port per port per priority group settings */
        for (idx = 0; idx < _TR3_MMU_NUM_PG; idx++) {
            buf_prigroup = &buf->ports[port].prigroups[idx];

            midx = (mmu_port * 8) + idx;
            sal_memset(&pg_config_mem, 0, sizeof(pg_config_mem));
            soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, &pg_config_mem, PG_MIN_LIMITf, 
                                buf_prigroup->guarantee > 1 ? buf_prigroup->guarantee : 1);

            if (buf_prigroup->pool_scale != -1) {
                soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, &pg_config_mem, 
                                           PG_SHARED_DYNAMICf, 1);
                soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, &pg_config_mem, 
                                    PG_SHARED_LIMITf, buf_prigroup->pool_scale);
            } else {
                soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, &pg_config_mem, 
                                   PG_SHARED_LIMITf, buf_prigroup->pool_limit);
            }

            soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, &pg_config_mem, 
                         PG_GBL_HDRM_ENf, buf_prigroup->device_headroom_enable);
            soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, &pg_config_mem, 
                                       PG_HDRM_LIMITf, buf_prigroup->headroom);

            soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, &pg_config_mem, 
                                 PG_RESET_OFFSETf, buf_prigroup->pool_resume);

            soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, &pg_config_mem, 
                                  PG_RESET_FLOORf, buf_prigroup->pool_floor);
                                        
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, THDI_PORT_PG_CONFIGm, 
                                           MEM_BLOCK_ALL, midx, &pg_config_mem));
        }
    }

    /***********************************
     * THDO 
     ***********************************/

    /* Output port per port per queue setting for multicast queue */
    PBMP_ALL_ITER(unit, port) {
        for (idx = 0; idx < si->port_num_cosq[port]; idx++) {
            buf_queue = &buf->ports[port].queues[idx];
            pool = buf_queue->pool_idx;
            buf_pool = &buf->pools[pool];
            limit = buf_pool->total - buf_pool->queue_guarantee;
            if (limit < 0) {
                limit = 0;
            }
            rval = 0;
            soc_reg_field_set(unit, OP_QUEUE_CONFIG_CELLr, &rval, Q_MIN_CELLf,
                              buf_queue->guarantee);
            if (buf_queue->pool_scale != -1) {
                soc_reg_field_set(unit, OP_QUEUE_CONFIG_CELLr, &rval,
                               Q_SHARED_ALPHA_CELLf, buf_queue->pool_scale);
            } else {
                soc_reg_field_set(unit, OP_QUEUE_CONFIG_CELLr, &rval,
                                Q_SHARED_LIMIT_CELLf, limit);
            }
            SOC_IF_ERROR_RETURN
                (WRITE_OP_QUEUE_CONFIG_CELLr(unit, port, idx, rval));

            rval = 0;
            if (buf_queue->discard_enable) {
                soc_reg_field_set(unit, OP_QUEUE_CONFIG1_CELLr, &rval,
                                  Q_LIMIT_ENABLE_CELLf, 1);
            }
            if (buf_queue->pool_scale != -1) {
                soc_reg_field_set(unit, OP_QUEUE_CONFIG1_CELLr, &rval,
                                  Q_LIMIT_DYNAMIC_CELLf, 1);
            }
            if (buf_queue->color_discard_enable) {
                soc_reg_field_set(unit, OP_QUEUE_CONFIG1_CELLr, &rval,
                                  Q_COLOR_ENABLE_CELLf, 1);
            }
            if (buf_queue->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) {
                soc_reg_field_set(unit, OP_QUEUE_CONFIG1_CELLr, &rval,
                                  Q_COLOR_LIMIT_DYNAMIC_CELLf, 1);
            }
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_CELLr, &rval,
                              Q_SPIDf, buf_queue->pool_idx);
            SOC_IF_ERROR_RETURN
                (WRITE_OP_QUEUE_CONFIG1_CELLr(unit, port, idx, rval));

            rval = 0;
            if (buf_queue->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) {
                soc_reg_field_set(unit, OP_QUEUE_LIMIT_COLOR_CELLr, &rval, REDf,
                        (buf_queue->red_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG));
            } else {
                soc_reg_field_set(unit, OP_QUEUE_LIMIT_COLOR_CELLr, &rval, REDf,
                                                        buf_queue->red_limit/8);
            }   
            SOC_IF_ERROR_RETURN
                (WRITE_OP_QUEUE_LIMIT_COLOR_CELLr(unit, port, idx, rval));

            rval = 0;
            soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_CELLr, &rval,
                              Q_RESET_OFFSET_CELLf,
                              buf_queue->pool_resume / 8);
            SOC_IF_ERROR_RETURN
                (WRITE_OP_QUEUE_RESET_OFFSET_CELLr(unit, port, idx, rval));
        }
    }

    /* Output port per port per queue setting for regular unicast queue */
    PBMP_ALL_ITER(unit, port) {
        if (IS_CPU_PORT(unit, port)) {
            continue;
        }

        /* per port regular unicast queue */
        soc_tr3_get_def_qbase(unit, port, _SOC_TR3_INDEX_STYLE_UCAST_QUEUE,
                                &base, &numq);
        for (idx = 0; idx < numq; idx++) {
            buf_queue = &buf->ports[port].queues[si->port_num_cosq[port] + idx];

            sal_memset(entry0, 0, sizeof(mmu_thdo_config_queue_entry_t));
            sal_memset(entry1, 0, sizeof(mmu_thdo_offset_0_entry_t));

            soc_mem_field32_set(unit, MMU_THDO_CONFIG_QUEUEm, entry0, 
                                Q_MIN_LIMIT_CELLf, buf_queue->guarantee);
            if (buf_queue->discard_enable) {
                soc_mem_field32_set(unit, MMU_THDO_CONFIG_QUEUEm, entry0,
                                    Q_LIMIT_ENABLE_CELLf, 1);
            }
            if (buf_queue->pool_scale != -1) {
                soc_mem_field32_set(unit, MMU_THDO_CONFIG_QUEUEm, entry0,
                                    Q_LIMIT_DYNAMIC_CELLf, 1);
                soc_mem_field32_set(unit, MMU_THDO_CONFIG_QUEUEm, entry0,
                           Q_SHARED_ALPHA_CELLf, buf_queue->pool_scale);
            } else {
                /* Q_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, MMU_THDO_CONFIG_QUEUEm, entry0,
                               Q_SHARED_LIMIT_CELLf, buf_queue->pool_limit);
            }
            soc_mem_field32_set(unit, MMU_THDO_OFFSET_QUEUEm, 
                entry1, RESET_OFFSET_CELLf, buf_queue->pool_resume / 8);
            if (buf_queue->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) {
                soc_mem_field32_set(unit, MMU_THDO_CONFIG_QUEUEm, entry0,
                                    Q_COLOR_LIMIT_DYNAMIC_CELLf, 1);
                soc_mem_field32_set
                    (unit, MMU_THDO_CONFIG_QUEUEm, entry0, LIMIT_YELLOW_CELLf,
                     buf_queue->yellow_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
                soc_mem_field32_set
                    (unit, MMU_THDO_CONFIG_QUEUEm, entry0, LIMIT_RED_CELLf,
                     buf_queue->red_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
            } else {
                /* Q_COLOR_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set
                    (unit, MMU_THDO_CONFIG_QUEUEm, entry0, LIMIT_YELLOW_CELLf,
                     buf_queue->yellow_limit / 8);
                soc_mem_field32_set
                    (unit, MMU_THDO_CONFIG_QUEUEm, entry0, LIMIT_RED_CELLf,
                     buf_queue->red_limit / 8);
            }
            soc_mem_field32_set
                (unit, MMU_THDO_OFFSET_QUEUEm, entry1, RESET_OFFSET_YELLOW_CELLf,
                 buf_queue->yellow_resume / 8);
            soc_mem_field32_set
                (unit, MMU_THDO_OFFSET_QUEUEm, entry1, RESET_OFFSET_RED_CELLf,
                 buf_queue->red_resume / 8);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, MMU_THDO_CONFIG_QUEUEm, MEM_BLOCK_ALL,
                               base + idx, entry0));
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, MMU_THDO_OFFSET_QUEUEm, MEM_BLOCK_ALL,
                               base + idx, entry1));

            sal_memset(entry0, 0, sizeof(mmu_thdo_q_to_qgrp_map_entry_t));
            soc_mem_field32_set(unit, MMU_THDO_Q_TO_QGRP_MAPm, 
                                entry0, Q_SPIDf, buf_queue->pool_idx);
            if (buf_queue->color_discard_enable) {
                soc_mem_field32_set(unit, MMU_THDO_Q_TO_QGRP_MAPm, entry0,
                                    Q_COLOR_ENABLE_CELLf, 1);
            }

            if (buf_queue->qgroup_id != -1) {
                soc_mem_field32_set(unit, MMU_THDO_Q_TO_QGRP_MAPm, entry0,
                                    QGROUP_VALIDf, 1);
                soc_mem_field32_set(unit, MMU_THDO_Q_TO_QGRP_MAPm, entry0,
                                    QGROUPf, buf_queue->qgroup_id);
                if (buf_queue->qgroup_min_enable) {
                    soc_mem_field32_set(unit, MMU_THDO_Q_TO_QGRP_MAPm, entry0,
                                    USE_QGROUP_MINf, 1);
                }
            }
            
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, MMU_THDO_Q_TO_QGRP_MAPm, 
                                              MEM_BLOCK_ALL, base + idx, entry0));
        }
    }


    /* Output port per pool settings */
    for (idx = 0; idx < _TR3_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];
        if ((buf_pool->size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 0) {
            continue;
        }

        limit = buf_pool->total - buf_pool->queue_guarantee;

        rval = 0;
        soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_CELLr, &rval,
                          OP_BUFFER_SHARED_LIMIT_CELLf, limit);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, OP_BUFFER_SHARED_LIMIT_CELLr, REG_PORT_ANY,
                           idx, rval));

        rval = 0;
        soc_reg_field_set(unit, OP_BUFFER_LIMIT_YELLOW_CELLr, &rval,
                          OP_BUFFER_LIMIT_YELLOW_CELLf, limit / 8);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, OP_BUFFER_LIMIT_YELLOW_CELLr, REG_PORT_ANY,
                           idx, rval));

        rval = 0;
        soc_reg_field_set(unit, OP_BUFFER_LIMIT_RED_CELLr, &rval,
                          OP_BUFFER_LIMIT_RED_CELLf, limit / 8);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, OP_BUFFER_LIMIT_RED_CELLr, REG_PORT_ANY,
                           idx, rval));

        rval = 0;
        soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_RESUME_CELLr, &rval,
                          OP_BUFFER_SHARED_LIMIT_RESUME_CELLf, limit);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, OP_BUFFER_SHARED_LIMIT_RESUME_CELLr,
                           REG_PORT_ANY, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_YELLOW_CELLr, &rval,
                          OP_BUFFER_LIMIT_RESUME_YELLOW_CELLf, limit / 8);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, OP_BUFFER_LIMIT_RESUME_YELLOW_CELLr,
                           REG_PORT_ANY, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_RED_CELLr, &rval,
                          OP_BUFFER_LIMIT_RESUME_RED_CELLf, limit / 8);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, OP_BUFFER_LIMIT_RESUME_RED_CELLr,
                           REG_PORT_ANY, idx, rval));

        /* Output port per port per pool setting */
        PBMP_PORT_ITER(unit, port) {
            phy_port = si->port_l2p_mapping[port];
            mmu_port = si->port_p2m_mapping[phy_port];

            sal_memset(entry0, 0, sizeof(mmu_thdo_config_port_entry_t));
            soc_mem_field32_set(unit, MMU_THDO_CONFIG_PORTm, entry0,
                                                      SHARED_LIMITf, limit);
            soc_mem_field32_set(unit, MMU_THDO_CONFIG_PORTm, entry0,
                              SHARED_RESUMEf, limit - (default_mtu_cells * 2));

            soc_mem_field32_set(unit, MMU_THDO_CONFIG_PORTm, entry0,
                                                      YELLOW_LIMITf, limit/8);
            soc_mem_field32_set(unit, MMU_THDO_CONFIG_PORTm, entry0,
                            YELLOW_RESUMEf, (limit - (default_mtu_cells*2))/8);

            soc_mem_field32_set(unit, MMU_THDO_CONFIG_PORTm, entry0,
                                                      RED_LIMITf, limit/8);
            soc_mem_field32_set(unit, MMU_THDO_CONFIG_PORTm, entry0,
                              RED_RESUMEf, (limit - (default_mtu_cells * 2))/8);

            SOC_IF_ERROR_RETURN
                (WRITE_MMU_THDO_CONFIG_PORTm(unit, MEM_BLOCK_ANY, 
                                             (mmu_port*4) + idx, &entry0));
        }

        /* Output port per port per pool setting for multicast queues */
        PBMP_PORT_ITER(unit, port) {
            rval = 0;
            soc_reg_field_set(unit, OP_PORT_CONFIG_CELLr, &rval,
                              OP_SHARED_LIMIT_CELLf, limit);
            soc_reg_field_set(unit, OP_PORT_CONFIG_CELLr, &rval,
                              OP_SHARED_RESET_VALUE_CELLf,
                              limit - (2 * default_mtu_cells));
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, OP_PORT_CONFIG_CELLr, port, idx, rval));

            rval = 0;
            soc_reg_field_set(unit, OP_PORT_LIMIT_COLOR_CELLr, &rval, REDf,
                              limit / 8);
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, OP_PORT_LIMIT_COLOR_CELLr, port, idx,
                               rval));

            rval = 0;
            soc_reg_field_set
                (unit, OP_PORT_LIMIT_RESUME_COLOR_CELLr, &rval, REDf,
                              (limit - (2*default_mtu_cells)) / 8);
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, OP_PORT_LIMIT_RESUME_COLOR_CELLr, port,
                               idx, rval));
        }
    }

    /* setup WAMU */
    rval = 0;
    soc_reg_field_set(unit, WAMUTOTALSHRLMTINGr, &rval, SHRPKT_LMTf, 0xfff);
    soc_reg_field_set(unit, WAMUTOTALSHRLMTINGr, &rval, SHRCELL_LMTf, 0x7fff);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, WAMUTOTALSHRLMTINGr, REG_PORT_ANY, 0, rval));
    
    rval = 0;
    soc_reg_field_set(unit, WAMUTOTALSHRLMTPKTEGRr, &rval, SHR_LMTf, 0xfff);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, WAMUTOTALSHRLMTPKTEGRr, REG_PORT_ANY, 0, rval));
    
    rval = 0;
    soc_reg_field_set(unit, CNTX_AGING_LIMITr, &rval, AGING_LIMITf, 0x1fff);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, CNTX_AGING_LIMITr, REG_PORT_ANY, 0, rval));
    
    rval = 0;
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, WAMUTHDBYPASSr, REG_PORT_ANY, 0, rval));

    rval = 0;
    soc_reg_field_set(unit, WAMU_PG_MIN_CELLr, &rval, PG_MIN_ENf, 1);
    soc_reg_field_set(unit, WAMU_PG_MIN_CELLr, &rval, PG_MINf, 
                                                jumbo_frame_cells);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, WAMU_PG_MIN_CELLr, REG_PORT_ANY, 0, rval));

    rval = 0;
    soc_reg_field_set(unit, WAMU_PG_SHARED_LIMIT_CELLr, &rval, 
                        PG_SHARED_LIMITf, 6);
    soc_reg_field_set(unit, WAMU_PG_SHARED_LIMIT_CELLr, &rval, 
                        PG_SHARED_DYNAMICf, 1);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, WAMU_PG_SHARED_LIMIT_CELLr, REG_PORT_ANY, 0, rval));

    rval = 0;
    soc_reg_field_set(unit, WAMU_PG_RESET_OFFSET_CELLr, &rval, 
                        WAMU_PG_RESET_OFFSETf, 1);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, WAMU_PG_RESET_OFFSET_CELLr, REG_PORT_ANY, 0, rval));

    rval = 0;
    soc_reg_field_set(unit, WAMUMINLMTPGr, &rval, PKTLMTf, 2);
    soc_reg_field_set(unit, WAMUMINLMTPGr, &rval, CELLLMTf, default_mtu_cells);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, WAMUMINLMTPGr, REG_PORT_ANY, 0, rval));

    rval = 0;
    soc_reg_field_set(unit, WAMUSHRLMTCELLPGr, &rval, SHRLMTf, 6);
    soc_reg_field_set(unit, WAMUSHRLMTCELLPGr, &rval, DYNMf, 1);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, WAMUSHRLMTCELLPGr, REG_PORT_ANY, 0, rval));

    for (idx = 0; idx < 8; idx++) {
        rval = 0;
        soc_reg_field_set(unit, WAMUSHRLMTPKTQr, &rval, SHRLMTPKTf, 0xfff);
        soc_reg_field_set(unit, WAMUSHRLMTPKTQr, &rval, DYNMf, 1);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, WAMUSHRLMTPKTQr, REG_PORT_ANY, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, WAMUMINLMTPKTQr, &rval, MINLMTPKTf, 2);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, WAMUMINLMTPKTQr, REG_PORT_ANY, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, WAMURSTOFFSETPKTQr, &rval, RSTOFFSETf, 2);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, WAMURSTOFFSETPKTQr, REG_PORT_ANY, idx, rval));
    }

    return SOC_E_NONE;
}

int
soc_tr3_mmu_config_init(int unit, int test_only)
{
    int rv;
    _soc_mmu_cfg_buf_t *buf;
    _soc_mmu_device_info_t devcfg;

    buf = soc_mmu_cfg_alloc(unit);
    if (!buf) {
        return SOC_E_MEMORY;
    }
    
    _soc_tr3_mmu_init_dev_config(unit, &devcfg);
    _soc_tr3_mmu_config_buf_default(unit, buf);
    _soc_mmu_cfg_buf_read(unit, buf, &devcfg);
    rv = _soc_mmu_cfg_buf_check(unit, buf, &devcfg);
    if (!test_only) {
        if (SOC_FAILURE(rv)) {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "MMU config: Use default setting\n")));
            _soc_tr3_mmu_config_buf_default(unit, buf);
            _soc_mmu_cfg_buf_calculate(unit, buf, &devcfg);
        }
        rv = _soc_tr3_mmu_config_buf_set_hw(unit, buf);
    }

    soc_mmu_cfg_free(unit, buf);

    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "MMU THDI/THDO init done\n")));
    return rv;
}

int
_soc_tr3_mmu_init(int unit)
{
    uint32        rval;
    uint64        r64val;
    int           port, mmu_init_usec, i, numq = 0, credits = 0, total_queues;
    soc_timeout_t to;
    egr_edb_xmit_ctrl_entry_t e;
    soc_reg_t    reg;
    int phy_port, mmu_port;
    soc_info_t *si;

    si = &SOC_INFO(unit);

    /* Init Link List Scheduler */
    rval = 0;
    soc_reg_field_set(unit, LLS_SOFT_RESETr, &rval, SOFT_RESETf, 0);
    SOC_IF_ERROR_RETURN(WRITE_LLS_SOFT_RESETr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, LLS_INITr, &rval, INITf, 1);
    SOC_IF_ERROR_RETURN(WRITE_LLS_INITr(unit, rval));

    /* Wait for LLS init done. */
    if (SAL_BOOT_SIMULATION) {
        mmu_init_usec = 10000000; /* Simulation  .. 10sec */
    } else {
        mmu_init_usec = 50000;
    }
    soc_timeout_init(&to, mmu_init_usec, 0);
    do {
        SOC_IF_ERROR_RETURN(READ_LLS_INITr(unit, &rval));
        if (soc_reg_field_get(unit, LLS_INITr, rval, INIT_DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : LLS INIT timeout\n"), unit));
            break;
        }
    } while (TRUE);

    /* Setup TDM for MMU Arb & LLS */
    SOC_IF_ERROR_RETURN(_soc_tr3_mmu_tdm_init(unit));

    SOC_IF_ERROR_RETURN(soc_tr3_mmu_config_init(unit, FALSE));

    /* Enable LLS */
    rval = 0;
    soc_reg_field_set(unit, LLS_CONFIG0r, &rval, DEQUEUE_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_CONFIG0r, &rval, ENQUEUE_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_CONFIG0r, &rval, PORT_SCHEDULER_ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_LLS_CONFIG0r(unit, rval));

    /* LLS default init */
    SOC_IF_ERROR_RETURN(soc_tr3_lls_init(unit));
    
    /* Enable IP to CMICM credit transfer */
    rval = 0;
    soc_reg_field_set(unit, IP_TO_CMICM_CREDIT_TRANSFERr, &rval, TRANSFER_ENABLEf, 1);
    soc_reg_field_set(unit, IP_TO_CMICM_CREDIT_TRANSFERr, &rval, NUM_OF_CREDITSf, 32);
    SOC_IF_ERROR_RETURN(WRITE_IP_TO_CMICM_CREDIT_TRANSFERr(unit, rval));

    PBMP_ALL_ITER(unit, port) {
        phy_port = si->port_l2p_mapping[port];
        mmu_port = si->port_p2m_mapping[phy_port];

        total_queues = ((mmu_port >= 40) && (mmu_port <= 55)) ? 10 : 8;

        _soc_tr3_get_numq_and_fifo_size(unit, port, &credits, &numq);
        if (numq == 0) {
            continue;
        }
        
        if ((mmu_port >= 40) && (mmu_port <= 47)) {
            reg = MCQ_FIFO_BASE_REGr;
        } else if ((mmu_port >= 48) && (mmu_port <= 55)) {
            reg = MCQ_FIFO_BASE_REG_48_55r;
        } else if ((mmu_port >= 36) && (mmu_port <= 39)) {
            reg = MCQ_FIFO_BASE_REG_36_39r;
        } else if ((mmu_port >= 32) && (mmu_port <= 35)) {
            reg = MCQ_FIFO_BASE_REG_32_35r;
        } else if (mmu_port == 56) {
            reg = MCQ_FIFO_BASE_REG_56r;
        } else if (mmu_port == 58) {
            reg = MCQ_FIFO_BASE_REG_PASSTHRUr;
        } else if (mmu_port == 59) {
            reg = MCQ_FIFO_BASE_REG_CPUr;
        } else {
            reg = INVALIDr;
        }

        for (i = 0; i < numq; i++) {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "seting OVQ credits for port: %s(%d) = %d\n"), 
                                    SOC_PORT_NAME(unit, port),i, credits));
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "setting MCQ base for port: %s(%d) = %d\n"), 
                                    SOC_PORT_NAME(unit, port), i, i*credits));
            if (reg != INVALIDr) {
                if (credits < 2048) {
                    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, i, i*credits));
                } else {
                    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, i, 0));
                }
            }
            SOC_IF_ERROR_RETURN(WRITE_OVQ_MCQ_CREDITSr(unit, port, i, credits));
        }

        for (i = numq; i < total_queues; i++) {
            if (reg != INVALIDr) {
                if (credits < 2048) {
                    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, i, i*credits));
                } else {
                    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, i, 0));
                }
            }
            SOC_IF_ERROR_RETURN(WRITE_OVQ_MCQ_CREDITSr(unit, port, i, 0));
        }

        COMPILER_64_ZERO(r64val);
        soc_reg64_field32_set(unit, MMU_INTFO_CONGST_STr, &r64val, ENf, 1);
        SOC_IF_ERROR_RETURN(WRITE_MMU_INTFO_CONGST_STr(unit, port, r64val));
    }
    
    SOC_IF_ERROR_RETURN(WRITE_OVQ_MCQ_CREDITSr(unit, 
                                    AXP_PORT(unit, SOC_AXP_NLF_SM), 0, 32));

    _soc_tr3_set_mcfifo_config(unit);

    sal_memset(&e, 0, sizeof(egr_edb_xmit_ctrl_entry_t));
    for (i=0; i<80; i++) {
        soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, &e, START_CNTf,
                            (i < 53) ? 7 : 2);
        /* XL ports should have WAIT_FOR_MOP field set. */
        if ((i > 64) && (i < 69)) {
            soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, &e, WAIT_FOR_MOPf, 1);
        }
        SOC_IF_ERROR_RETURN(WRITE_EGR_EDB_XMIT_CTRLm(unit, MEM_BLOCK_ALL, i, &e));
    }

    /* OVQ settings */
    rval = 0;
    soc_reg_field_set(unit, OVQ_DROP_THRESHOLD0r, &rval,
                      OVQ_DROP_THRESHOLD0f, 0x17cf);
    SOC_IF_ERROR_RETURN(WRITE_OVQ_DROP_THRESHOLD0r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, OVQ_DROP_THRESHOLD_RESET_LIMITr, &rval,
             OVQ_DROP_THRESHOLD_RESET_LIMITf, 0x1700);
    SOC_IF_ERROR_RETURN(WRITE_OVQ_DROP_THRESHOLD_RESET_LIMITr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, OP_THR_CONFIGr, &rval, MOP_POLICYf, 7);
    soc_reg_field_set(unit, OP_THR_CONFIGr, &rval, YELLOW_CELL_DS_SELECTf, 1);
    SOC_IF_ERROR_RETURN(WRITE_OP_THR_CONFIGr(unit, rval));

#if 0
    rval = 0;
    soc_reg_field_set(unit, OVQ_FLOWCONTROL_THRESHOLDr, &rval, 
                                                OVQ_FC_ENABLEf, 1);
    soc_reg_field_set(unit, OVQ_FLOWCONTROL_THRESHOLDr, &rval,
                      OVQ_FC_THRESHOLDf, 11250);
    soc_reg_field_set(unit, OVQ_FLOWCONTROL_THRESHOLDr, &rval,
                      OVQ_FC_THRESHOLD_RESET_LIMITf, 11249);
    SOC_IF_ERROR_RETURN(WRITE_OVQ_FLOWCONTROL_THRESHOLDr(unit, rval));
#endif

    /* Enable all ports */
    COMPILER_64_ZERO(r64val);
    COMPILER_64_SET(r64val, 0x7fffffff, 0xffffffff);
    SOC_IF_ERROR_RETURN(WRITE_INPUT_PORT_RX_ENABLE_64r(unit, r64val));
    COMPILER_64_ZERO(r64val);
    COMPILER_64_SET(r64val, 0x7fffffff, 0xffffffff);
    SOC_IF_ERROR_RETURN(WRITE_OUTPUT_PORT_RX_ENABLE0_64r(unit, r64val));

    /* init dual modid */
    if ((NUM_MODID(unit) == 2) && 
        (SOC_REG_IS_VALID(unit, E2EFC_CONFIGr)) ) {
        SOC_IF_ERROR_RETURN(READ_E2EFC_CONFIGr(unit, &rval));
        soc_reg_field_set(unit, E2EFC_CONFIGr, &rval, DUAL_MODID_ENf, 1);
        SOC_IF_ERROR_RETURN(WRITE_E2EFC_CONFIGr(unit, rval));
    }

    PBMP_ALL_ITER(unit, port) {
        if (SOC_INFO(unit).port_num_uc_cosq[port] > 0) {
            COMPILER_64_ZERO(r64val);
            soc_reg64_field32_set(unit, ING_COS_MODEr, &r64val, 
                BASE_QUEUE_NUM_0f, SOC_INFO(unit).port_uc_cosq_base[port]);

            soc_reg64_field32_set(unit, ING_COS_MODEr, &r64val,
                BASE_QUEUE_NUM_1f, SOC_INFO(unit).port_uc_cosq_base[port]);

            SOC_IF_ERROR_RETURN(WRITE_ING_COS_MODEr(unit, port, 
                                  COMPILER_64_LO(r64val)));
        }
    }

    rval = 0;
    soc_reg_field_set(unit, PRIORITY_CONTROLr, &rval, USE_SC_FOR_MH_PRIf, 1);
    soc_reg_field_set(unit, PRIORITY_CONTROLr, &rval, USE_QM_FOR_MH_PRIf, 1);
    SOC_IF_ERROR_RETURN(WRITE_PRIORITY_CONTROLr(unit, rval));

    /* Input port pause enable */
    COMPILER_64_ZERO(r64val);
    if (soc_property_get(unit, spn_MMU_LOSSLESS, 1)) {
        COMPILER_64_SET(r64val, 0x7fffffff, 0xffffffff);
    }
    SOC_IF_ERROR_RETURN(WRITE_PORT_PAUSE_ENABLE_64r(unit, r64val));

    SOC_IF_ERROR_RETURN(WRITE_THDI_BYPASSr(unit, 0));
    SOC_IF_ERROR_RETURN(WRITE_THDO_BYPASSr(unit, 0));

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit) && soc_feature(unit, soc_feature_esm_support)) {
        SOC_IF_ERROR_RETURN(soc_tr3_esm_init_read_config(unit));
        if (SOC_CONTROL(unit)->tcam_info) {
            SOC_IF_ERROR_RETURN(_soc_triumph3_esm_init_adjust_mem_size(unit));
        }
    }
#endif

    if (soc_feature(unit, soc_feature_post)) {
        SOC_IF_ERROR_RETURN(soc_mmu_post_init(unit));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_tr3_age_timer_get(int unit, int *age_seconds, int *enabled)
{
    soc_control_t *soc = SOC_CONTROL(unit);
    *age_seconds = soc->l2x_age_interval ? (soc->l2x_age_interval) : 0;
    *enabled = soc->l2x_age_pid != SAL_THREAD_ERROR ? 1 : 0;
    return SOC_E_NONE; 
}

STATIC int
_soc_tr3_age_timer_max_get(int unit, int *max_seconds)
{
    *max_seconds = 0xffffffff;
    return SOC_E_NONE;
}

STATIC int
_soc_tr3_age_timer_set(int unit, int age_seconds, int enable)
{
    soc_control_t *soc = SOC_CONTROL(unit);

    /* SW aging thread running */
    if (soc->l2x_age_interval) {
        if (!enable) {
            SOC_IF_ERROR_RETURN(soc_tr3_l2_bulk_age_stop(unit));
        } else {
            if (age_seconds) {
                SOC_CONTROL_LOCK(unit);
                soc->l2x_age_interval = age_seconds;
                soc->l2x_prev_age_timeout = age_seconds;
                SOC_CONTROL_UNLOCK(unit);
            }
            /* Wake up thread to update the new age timer */
            sal_sem_give(soc->l2x_age_notify);
        }       
    } else {  
        /* SW aging not runninig, start the thread */
        if (enable) {
            if (age_seconds) {
                SOC_CONTROL_LOCK(unit);
                soc->l2x_prev_age_timeout = age_seconds;
                SOC_CONTROL_UNLOCK(unit);
            }
            SOC_IF_ERROR_RETURN
                (soc_tr3_l2_bulk_age_start(unit, age_seconds));
        }
    }
    return SOC_E_NONE;
}

static
soc_field_t _soc_tr3_oam_interrupt_fields[] = {
    SOME_RDI_DEFECT_INTRf,
    SOME_RMEP_CCM_DEFECT_INTRf,
    ERROR_CCM_DEFECT_INTRf,
    ANY_RMEP_TLV_PORT_DOWN_INTRf,
    ANY_RMEP_TLV_PORT_UP_INTRf,
    ANY_RMEP_TLV_INTERFACE_DOWN_INTRf,
    ANY_RMEP_TLV_INTERFACE_UP_INTRf,
    XCON_CCM_DEFECT_INTRf,
    INVALIDf
};

void
soc_tr3_oam_handler_register(int unit, soc_tr3_oam_handler_t handler)
{
    uint32 rval;
    int rv, fidx = 0;

    tr3_oam_handler[unit] = handler;
    
    rv = READ_IP2_INTR_ENABLE_2r(unit, &rval);
    if (rv) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d: Error reading %s reg !!\n"),
                              unit, SOC_REG_NAME(unit, IP2_INTR_ENABLE_2r)));
    }
    while (_soc_tr3_oam_interrupt_fields[fidx] != INVALIDf) {
        soc_reg_field_set(unit, IP2_INTR_ENABLE_2r, &rval,
                          _soc_tr3_oam_interrupt_fields[fidx], 1);
        fidx++;
    }
    rv = WRITE_IP2_INTR_ENABLE_2r(unit, rval);
    if (rv) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d: Error writing %s reg !!\n"),
                              unit, SOC_REG_NAME(unit, IP2_INTR_ENABLE_2r)));
    }                   
    /* Enable Interrupt */
    (void)soc_cmicm_intr2_enable(unit, _TR3_IRSEL1_TO_CMIC_OAM_INTR);
}

void
soc_tr3_oam_interrupt_process(int unit)
{
    soc_tr3_oam_handler_t oam_handler_snapshot = tr3_oam_handler[unit];
            
    if (oam_handler_snapshot != NULL) {
        /* We don't need to specify the OAM interrupt to OAM handler as 
           OAM Handler it checks for all OAM interrupts */
        (void)(oam_handler_snapshot(unit, 0));
    }
}

void
soc_tr3_oam_ser_handler_register(int unit, soc_tr3_oam_ser_handler_t handler) 
{
    tr3_oam_ser_handler[unit] = handler;
}

int
soc_tr3_oam_ser_process(int unit, soc_mem_t mem, int index) 
{
    if (tr3_oam_ser_handler[unit]) {
        return tr3_oam_ser_handler[unit](unit, mem, index);
    } else {
        return SOC_E_UNAVAIL;
    }
}

static const soc_reg_t thermal_reg[] = {
    TOP_PVTMON_RESULT_0r, TOP_PVTMON_RESULT_1r,
    TOP_PVTMON_RESULT_2r, TOP_PVTMON_RESULT_3r,
    TOP_PVTMON_RESULT_4r
};

int
soc_tr3_temperature_monitor_get(int unit,
          int temperature_max,
          soc_switch_temperature_monitor_t *temperature_array,
          int *temperature_count)
{
    uint32 rval;
    soc_reg_t reg;
    int index;
    int fval, cur, peak;
    int num_entries_out;

    *temperature_count = 0;
    if (COUNTOF(thermal_reg) > temperature_max) {
        num_entries_out = temperature_max;
    } else {
        num_entries_out = COUNTOF(thermal_reg);
    }
#ifdef BCM_HELIX4_SUPPORT
    if (SOC_IS_HELIX4(unit)) {
        num_entries_out -= 2;
    }
#endif
    reg = TOP_PVTMON_CTRL_0r;
    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_0r(unit, &rval));
    soc_reg_field_set(unit, reg, &rval, FUNC_MODE_SELf, 0);
    soc_reg_field_set(unit, reg, &rval, MEASUREMENT_CALLIBRATIONf, 5);
    soc_reg_field_set(unit, reg, &rval, BG_ADJf, 2);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_0r(unit, rval));

    sal_usleep(1000);

    for (index = 0; index < num_entries_out; index++) {
        reg = thermal_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        fval = soc_reg_field_get(unit, reg, rval, TEMP_DATAf);
        cur = (4180000 - (5556 * fval)) / 1000;
        fval = soc_reg_field_get(unit, reg, rval, PEAK_TEMP_DATAf);
        peak = (4180000 - (5556 * fval)) / 1000;
        (temperature_array + index)->curr = cur;
        (temperature_array + index)->peak = peak;
    }
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TEMP_MON_PEAK_RST_Lf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TEMP_MON_PEAK_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    *temperature_count=num_entries_out;
    
    return SOC_E_NONE;
}

soc_blk_ctr_reg_desc_t _soc_tr3_blk_ctr_reg_desc[] = {
    {
        SOC_BLK_AXP,
        {
            {AXP_SM_PACKETS_RECEIVED_COUNTERr, 1, 1, 0},
            {AXP_SM_PACKETS_SENT_COUNTERr, 1, 1, 0},
            {AXP_SM_PACKETS_DROPPED_COUNTERr, 1, 1, 0},
            {AXP_SM_BYTES_MATCHED_COUNTERr, 1, 1, 0},
            {AXP_SM_MATCHED_FLOWS_COUNTERr, 1, 1, 0},
            {AXP_SM_UNMATCHED_FLOWS_COUNTERr, 1, 1, 0},
            {AXP_SM_TOTAL_MATCH_COUNTERr, 1, 1, 0},
            {AXP_SM_TOTAL_CROSS_SIG_FLAGS_COUNTERr, 1, 1, 0},
            {AXP_SM_FRAGMENTS_RECEIVED_COUNTERr, 1, 1, 0},
            {AXP_SM_IN_PACKET_ERROR_COUNTERr, 1, 1, 0},
            {AXP_SM_FLOW_TRACKER_ERROR_COUNTERr, 1, 1, 0},
            {AXP_SM_PACKET_LENGTH_ERROR_COUNTERr, 1, 1, 0},
            {AXP_SM_L4_CHECKSUM_ERROR_COUNTERr, 1, 1, 0},
            {AXP_SM_FLOW_DONE_PACKET_DROP_COUNTERr, 1, 1, 0},
            {AXP_SM_FLOW_TIMESTAMP_ERROR_COUNTERr, 1, 1, 0},
            {AXP_SM_FLOW_PACKET_NUM_ERROR_COUNTERr, 1, 1, 0},
            {AXP_SM_ECC_ERROR_COUNTERr, 1, 1, 0},
            {INVALIDr, 0, 0}
        }
    },
    {
        SOC_BLK_ETU,
        {
            {ILAMAC_RX_PACKETS_COUNTr, 2, 1, 0},
            {ILAMAC_RX_BYTES_COUNTr, 2, 1, 0},
            {ILAMAC_TX_PACKETS_COUNTr, 2, 1, 0},
            {ILAMAC_TX_BYTES_COUNTr, 2, 1, 0},
            {ILAMAC_RX_WORD_SYNC_ERRORS_COUNTr, 1, 12, 8},
            {ILAMAC_RX_FRAMING_ERRORS_COUNTr, 1, 12, 8},
            {ILAMAC_RX_BAD_TYPE_ERRORS_COUNTr, 1, 12, 8},
            {ILAMAC_RX_DESCRAM_ERRORS_COUNTr, 1, 12, 8},
            {ILAMAC_RX_ALIGNMENT_ERRORS_COUNTr, 1, 1, 0},
            {ILAMAC_RX_ALIGNMENT_FAILURES_ERRORS_COUNTr, 1, 1, 0},
            {ILAMAC_RX_CRC_ERRORS_COUNTr, 1, 1, 0},
            {ILAMAC_RX_BURSTMAX_ERRORS_COUNTr, 1, 1, 0},
            {ILAMAC_RX_LANE_CRC_ERRORS_COUNTr, 1, 12, 8},
            {ILAMAC_RX_BAD_PACKETS_COUNTr, 1, 1, 0},
            {WCL_RX_LOST_LOCK_COUNTr, 1, 12, 8},
            {INVALIDr, 0, 0}
        }
    }
};

void
soc_tr3_blk_counter_config(int unit)
{
    soc_control_t *soc = SOC_CONTROL(unit);
    soc->blk_ctr_desc_count = COUNTOF(_soc_tr3_blk_ctr_reg_desc);
    soc->blk_ctr_desc = _soc_tr3_blk_ctr_reg_desc;
}

int _soc_tr3_ur_port_reset(int unit, int num_ports, soc_port_t port,
                           soc_block_type_t pbt)
{
    static const soc_reg_t lls_port_credit_reg[] = {
        LLS_PORT_0_CREDITr, LLS_PORT_1_CREDITr, LLS_PORT_2_CREDITr,
        LLS_PORT_3_CREDITr, LLS_PORT_4_CREDITr, LLS_PORT_5_CREDITr,
        LLS_PORT_6_CREDITr, LLS_PORT_7_CREDITr, LLS_PORT_8_CREDITr,
        LLS_PORT_9_CREDITr, LLS_PORT_10_CREDITr, LLS_PORT_11_CREDITr,
        LLS_PORT_12_CREDITr, LLS_PORT_13_CREDITr, LLS_PORT_14_CREDITr,
        LLS_PORT_15_CREDITr, LLS_PORT_16_CREDITr, LLS_PORT_17_CREDITr,
        LLS_PORT_18_CREDITr, LLS_PORT_19_CREDITr, LLS_PORT_20_CREDITr,
        LLS_PORT_21_CREDITr, LLS_PORT_22_CREDITr, LLS_PORT_23_CREDITr,
        LLS_PORT_24_CREDITr, LLS_PORT_25_CREDITr, LLS_PORT_26_CREDITr,
        LLS_PORT_27_CREDITr, LLS_PORT_28_CREDITr, LLS_PORT_29_CREDITr,
        LLS_PORT_30_CREDITr, LLS_PORT_31_CREDITr, LLS_PORT_32_CREDITr,
        LLS_PORT_33_CREDITr, LLS_PORT_34_CREDITr, LLS_PORT_35_CREDITr,
        LLS_PORT_36_CREDITr, LLS_PORT_37_CREDITr, LLS_PORT_38_CREDITr,
        LLS_PORT_39_CREDITr, LLS_PORT_40_CREDITr, LLS_PORT_41_CREDITr,
        LLS_PORT_42_CREDITr, LLS_PORT_43_CREDITr, LLS_PORT_44_CREDITr,
        LLS_PORT_45_CREDITr, LLS_PORT_46_CREDITr, LLS_PORT_47_CREDITr,
        LLS_PORT_48_CREDITr, LLS_PORT_49_CREDITr, LLS_PORT_50_CREDITr,
        LLS_PORT_51_CREDITr, LLS_PORT_52_CREDITr, LLS_PORT_53_CREDITr,
        LLS_PORT_54_CREDITr, LLS_PORT_55_CREDITr, LLS_PORT_56_CREDITr,
        LLS_PORT_57_CREDITr, LLS_PORT_58_CREDITr, LLS_PORT_59_CREDITr,
        LLS_PORT_60_CREDITr, LLS_PORT_61_CREDITr, LLS_PORT_62_CREDITr
    }; 
    
    int prev_port_speeds[_SOC_HX4_FIFO_CHK_MAX_PORTS];
    int lanes, rv = SOC_E_NONE;
    egr_enable_entry_t egr_en;
    soc_info_t *si = &SOC_INFO(unit);

    switch (num_ports) {
    case 1: lanes = 4; break;
    case 2: lanes = 2; break;
    case 4: lanes = 1; break;
    default: lanes = 1;
    }

    if (!SOC_WARM_BOOT(unit)) {
        _soc_tr3_current_port_speeds(unit, prev_port_speeds);
    }

    /* put the port in reset */
    SOC_IF_ERROR_RETURN
        (_soc_tr3_port_control(unit, port, pbt, FALSE));
    /* reset egress buffers */
    SOC_IF_ERROR_RETURN
        (_soc_tr3_egress_buffer_reset(unit, port, pbt, TRUE));
    /* do port soft reset */
    SOC_IF_ERROR_RETURN
        (_soc_tr3_port_soft_reset(unit, port, pbt, TRUE));
    /* disable port */
    SOC_IF_ERROR_RETURN
        (_soc_tr3_subport_disable(unit, port, pbt, num_ports, TRUE));
    /* clear ports mmu link list credit */
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, 
          lls_port_credit_reg[si->port_p2m_mapping[si->port_l2p_mapping[port]]],
          REG_PORT_ANY, 0, 0));
    /* setup the port modes */
    SOC_IF_ERROR_RETURN
        (_soc_tr3_port_mode_set(unit, port, pbt, lanes));

    SOC_IF_ERROR_RETURN(_soc_tr3_update_mcq_fifo(unit, prev_port_speeds));

    /* port reinit */
    SOC_IF_ERROR_RETURN
        (_soc_tr3_port_control(unit, port, pbt, TRUE));
    /* release port reset */
    SOC_IF_ERROR_RETURN
        (_soc_tr3_port_soft_reset(unit, port, pbt, FALSE));
    /* release egress buffer reset */
    SOC_IF_ERROR_RETURN
        (_soc_tr3_egress_buffer_reset(unit, port, pbt, FALSE));
    /* Enable new subports */
    SOC_IF_ERROR_RETURN
        (_soc_tr3_subport_disable(unit, port, pbt, num_ports, FALSE));

    /* Enable egress cell request generation */
    SOC_IF_ERROR_RETURN
        (READ_EGR_ENABLEm(unit, SOC_BLOCK_ANY, si->port_l2p_mapping[port], 
                           &egr_en));   
    soc_EGR_ENABLEm_field32_set(unit, &egr_en, PRT_ENABLEf, 1);
    SOC_IF_ERROR_RETURN
        (WRITE_EGR_ENABLEm(unit, SOC_BLOCK_ANY, si->port_l2p_mapping[port], 
                           &egr_en));

    return rv;
}

int _soc_hx4_xmac_cclk_config(int unit)
{
    int rv = SOC_E_NONE;
    uint32 rval;
    uint32 ndiv = 111, mdiv = 11;


    /* TOP_CORE_PLL_CTRL0 -> FAST_LOCK */
    if (SOC_E_NONE != (rv = READ_TOP_CORE_PLL_CTRL0r(unit, &rval))) {
        return rv;
    }
    soc_reg_field_set(unit, TOP_CORE_PLL_CTRL0r, &rval, FAST_LOCKf, 1);
    if (SOC_E_NONE != (rv = WRITE_TOP_CORE_PLL_CTRL0r(unit, rval))) {
        return rv;
    }
    /* TOP_CORE_PLL_CTRL3 -> MSTR_NDIV_INTf */
    if (SOC_E_NONE != (rv = READ_TOP_CORE_PLL_CTRL3r(unit, &rval))) {
        return rv;
    }
    soc_reg_field_set(unit, TOP_CORE_PLL_CTRL3r, &rval, MSTR_NDIV_INTf, ndiv);
    if (SOC_E_NONE != (rv = WRITE_TOP_CORE_PLL_CTRL3r(unit, rval))) {
        return rv;
    }
    /* TOP_CORE_PLL_CTRL4 -> MSTR_CH0_MDIVf */
    if (SOC_E_NONE != (rv = READ_TOP_CORE_PLL_CTRL4r(unit, &rval))) {
        return rv;
    }
    soc_reg_field_set(unit, TOP_CORE_PLL_CTRL4r, &rval, MSTR_CH0_MDIVf, mdiv);
    if (SOC_E_NONE != (rv = WRITE_TOP_CORE_PLL_CTRL4r(unit, rval))) {
        return rv;
    }
    /* TOP_MISC_CONTROL -> CMIC_TO_CORE_PLL_LOAD */
    if (SOC_E_NONE != (rv = READ_TOP_MISC_CONTROL_1r(unit, &rval))) {
        return rv;
    }
    soc_reg_field_set(unit, TOP_MISC_CONTROL_1r, &rval, 
                      CMIC_TO_CORE_PLL_LOADf, 1);
    if (SOC_E_NONE != (rv = WRITE_TOP_MISC_CONTROL_1r(unit, rval))) {
        return rv;
    }
    /* TOP_CORE_PLL_CTRL2 -> LOAD_EN_CH0 */        
    if (SOC_E_NONE != (rv = READ_TOP_CORE_PLL_CTRL2r(unit, &rval))) {
        return rv;
    }
    soc_reg_field_set(unit, TOP_CORE_PLL_CTRL2r, &rval, LOAD_EN_CH0f, 1);
    if (SOC_E_NONE != (rv = WRITE_TOP_CORE_PLL_CTRL2r(unit, rval))) {
        return rv;
    }

    return rv;
}


/*
 * Tr3 chip driver functions.
 */
soc_functions_t soc_triumph3_drv_funs = {
    _soc_tr3_misc_init,
    _soc_tr3_mmu_init,
    _soc_tr3_age_timer_get,
    _soc_tr3_age_timer_max_get,
    _soc_tr3_age_timer_set,
};

#endif /* BCM_TRIUMPH3_SUPPORT */
