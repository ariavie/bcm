/*
 * $Id: 26d293a9ee0fa39af6a21f4104d0f5c98ddb0099 $
 * 
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#include <bcm_int/control.h>
#include <bcm_int/api_xlate_port.h>
#include <bcm_int/common/switch.h>
#include <bcm/error.h>
#include <bcm/debug.h>
#include <bcm/auth.h>
#include <bcm/ces.h>
#include <bcm/cosq.h>
#include <bcm/custom.h>
#include <bcm/eav.h>
#include <bcm/ecn.h>
#include <bcm/fabric.h>
#include <bcm/failover.h>
#include <bcm/fcoe.h>
#include <bcm/field.h>
#include <bcm/init.h>
#include <bcm/ipfix.h>
#include <bcm/knet.h>
#include <bcm/l2.h>
#include <bcm/link.h>
#include <bcm/mcast.h>
#include <bcm/mirror.h>
#include <bcm/mpls.h>
#include <bcm/multicast.h>
#include <bcm/oam.h>
#include <bcm/policer.h>
#include <bcm/port.h>
#include <bcm/qos.h>
#include <bcm/rate.h>
#include <bcm/rx.h>
#include <bcm/sat.h>
#include <bcm/stack.h>
#include <bcm/stat.h>
#include <bcm/stg.h>
#include <bcm/subport.h>
#include <bcm/switch.h>
#include <bcm/time.h>
#include <bcm/topo.h>
#include <bcm/trunk.h>
#include <bcm/tx.h>
#include <bcm/txbeacon.h>
#include <bcm/udf.h>
#include <bcm/vlan.h>
#include <bcm/vswitch.h>
#if defined(INCLUDE_BFD)
#include <bcm/bfd.h>
#endif
#if defined(INCLUDE_FCMAP)
#include <bcm/fcmap.h>
#endif
#if defined(INCLUDE_I2C)
#include <bcm/bcmi2c.h>
#endif
#if defined(INCLUDE_L3)
#include <bcm/extender.h>
#include <bcm/ipmc.h>
#include <bcm/l2gre.h>
#include <bcm/l3.h>
#include <bcm/mim.h>
#include <bcm/nat.h>
#include <bcm/niv.h>
#include <bcm/proxy.h>
#include <bcm/trill.h>
#include <bcm/tunnel.h>
#include <bcm/vxlan.h>
#include <bcm/wlan.h>
#endif
#if defined(INCLUDE_MACSEC)
#include <bcm/macsec.h>
#endif
#if defined(INCLUDE_PTP)
#include <bcm/ptp.h>
#endif
#if defined(INCLUDE_REGEX)
#include <bcm/bregex.h>
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_auth_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_auth_detach,
static int (*_auth_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_auth_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _auth_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_auth_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_auth_egress_get( \
    int unit, int port, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_auth_egress_get,
static int (*_auth_egress_get_dispatch[])(
    int unit, 
    int port, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_auth_egress_get(
    int unit, 
    int port, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _auth_egress_get_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_auth_egress_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_auth_egress_set( \
    int unit, int port, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_auth_egress_set,
static int (*_auth_egress_set_dispatch[])(
    int unit, 
    int port, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_auth_egress_set(
    int unit, 
    int port, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _auth_egress_set_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_auth_egress_set", 3, 3, unit, port, enable, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_auth_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_auth_init,
static int (*_auth_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_auth_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _auth_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_auth_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_auth_mac_add( \
    int unit, int port, bcm_mac_t mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_auth_mac_add,
static int (*_auth_mac_add_dispatch[])(
    int unit, 
    int port, 
    bcm_mac_t mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_auth_mac_add(
    int unit, 
    int port, 
    bcm_mac_t mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _auth_mac_add_dispatch[dtype](unit, port, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_auth_mac_add", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_auth_mac_control_get( \
    int unit, bcm_auth_mac_control_t type, uint32 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_auth_mac_control_get,
static int (*_auth_mac_control_get_dispatch[])(
    int unit, 
    bcm_auth_mac_control_t type, 
    uint32 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_auth_mac_control_get(
    int unit, 
    bcm_auth_mac_control_t type, 
    uint32 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _auth_mac_control_get_dispatch[dtype](unit, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_auth_mac_control_get", 3, 2, unit, type, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_auth_mac_control_set( \
    int unit, bcm_auth_mac_control_t type, uint32 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_auth_mac_control_set,
static int (*_auth_mac_control_set_dispatch[])(
    int unit, 
    bcm_auth_mac_control_t type, 
    uint32 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_auth_mac_control_set(
    int unit, 
    bcm_auth_mac_control_t type, 
    uint32 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _auth_mac_control_set_dispatch[dtype](unit, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_auth_mac_control_set", 3, 3, unit, type, value, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_auth_mac_delete( \
    int unit, int port, bcm_mac_t mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_auth_mac_delete,
static int (*_auth_mac_delete_dispatch[])(
    int unit, 
    int port, 
    bcm_mac_t mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_auth_mac_delete(
    int unit, 
    int port, 
    bcm_mac_t mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _auth_mac_delete_dispatch[dtype](unit, port, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_auth_mac_delete", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_auth_mac_delete_all( \
    int unit, int port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_auth_mac_delete_all,
static int (*_auth_mac_delete_all_dispatch[])(
    int unit, 
    int port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_auth_mac_delete_all(
    int unit, 
    int port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _auth_mac_delete_all_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_auth_mac_delete_all", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_auth_mode_get( \
    int unit, int port, uint32 *modep);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_auth_mode_get,
static int (*_auth_mode_get_dispatch[])(
    int unit, 
    int port, 
    uint32 *modep) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_auth_mode_get(
    int unit, 
    int port, 
    uint32 *modep)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _auth_mode_get_dispatch[dtype](unit, port, modep);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_auth_mode_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_auth_mode_set( \
    int unit, int port, uint32 mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_auth_mode_set,
static int (*_auth_mode_set_dispatch[])(
    int unit, 
    int port, 
    uint32 mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_auth_mode_set(
    int unit, 
    int port, 
    uint32 mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _auth_mode_set_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_auth_mode_set", 3, 3, unit, port, mode, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_auth_unauth_callback( \
    int unit, bcm_auth_cb_t func, void *cookie);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_auth_unauth_callback,
static int (*_auth_unauth_callback_dispatch[])(
    int unit, 
    bcm_auth_cb_t func, 
    void *cookie) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_auth_unauth_callback(
    int unit, 
    bcm_auth_cb_t func, 
    void *cookie)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _auth_unauth_callback_dispatch[dtype](unit, func, cookie);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_auth_unauth_callback", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

#if defined(INCLUDE_BFD)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_bfd_auth_sha1_get( \
    int unit, int index, bcm_bfd_auth_sha1_t *sha1);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_bfd_auth_sha1_get,
static int (*_bfd_auth_sha1_get_dispatch[])(
    int unit, 
    int index, 
    bcm_bfd_auth_sha1_t *sha1) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_bfd_auth_sha1_get(
    int unit, 
    int index, 
    bcm_bfd_auth_sha1_t *sha1)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _bfd_auth_sha1_get_dispatch[dtype](unit, index, sha1);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_bfd_auth_sha1_get", 3, 2, unit, index, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_BFD)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_bfd_auth_sha1_set( \
    int unit, int index, bcm_bfd_auth_sha1_t *sha1);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_bfd_auth_sha1_set,
static int (*_bfd_auth_sha1_set_dispatch[])(
    int unit, 
    int index, 
    bcm_bfd_auth_sha1_t *sha1) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_bfd_auth_sha1_set(
    int unit, 
    int index, 
    bcm_bfd_auth_sha1_t *sha1)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _bfd_auth_sha1_set_dispatch[dtype](unit, index, sha1);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_bfd_auth_sha1_set", 3, 2, unit, index, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_BFD)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_bfd_auth_simple_password_get( \
    int unit, int index, bcm_bfd_auth_simple_password_t *sp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_bfd_auth_simple_password_get,
static int (*_bfd_auth_simple_password_get_dispatch[])(
    int unit, 
    int index, 
    bcm_bfd_auth_simple_password_t *sp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_bfd_auth_simple_password_get(
    int unit, 
    int index, 
    bcm_bfd_auth_simple_password_t *sp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _bfd_auth_simple_password_get_dispatch[dtype](unit, index, sp);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_bfd_auth_simple_password_get", 3, 2, unit, index, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_BFD)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_bfd_auth_simple_password_set( \
    int unit, int index, bcm_bfd_auth_simple_password_t *sp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_bfd_auth_simple_password_set,
static int (*_bfd_auth_simple_password_set_dispatch[])(
    int unit, 
    int index, 
    bcm_bfd_auth_simple_password_t *sp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_bfd_auth_simple_password_set(
    int unit, 
    int index, 
    bcm_bfd_auth_simple_password_t *sp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _bfd_auth_simple_password_set_dispatch[dtype](unit, index, sp);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_bfd_auth_simple_password_set", 3, 2, unit, index, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_BFD)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_bfd_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_bfd_detach,
static int (*_bfd_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_bfd_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _bfd_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_bfd_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_BFD)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_bfd_endpoint_create( \
    int unit, bcm_bfd_endpoint_info_t *endpoint_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_bfd_endpoint_create,
static int (*_bfd_endpoint_create_dispatch[])(
    int unit, 
    bcm_bfd_endpoint_info_t *endpoint_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_bfd_endpoint_create(
    int unit, 
    bcm_bfd_endpoint_info_t *endpoint_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_A2P(unit,&endpoint_info->gport);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_A2P(unit,&endpoint_info->remote_gport);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_A2P(unit,&endpoint_info->tx_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _bfd_endpoint_create_dispatch[dtype](unit, endpoint_info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->gport);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->remote_gport);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->tx_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_bfd_endpoint_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_BFD)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_bfd_endpoint_destroy( \
    int unit, bcm_bfd_endpoint_t endpoint);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_bfd_endpoint_destroy,
static int (*_bfd_endpoint_destroy_dispatch[])(
    int unit, 
    bcm_bfd_endpoint_t endpoint) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_bfd_endpoint_destroy(
    int unit, 
    bcm_bfd_endpoint_t endpoint)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _bfd_endpoint_destroy_dispatch[dtype](unit, endpoint);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_bfd_endpoint_destroy", 2, 2, unit, endpoint, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_BFD)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_bfd_endpoint_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_bfd_endpoint_destroy_all,
static int (*_bfd_endpoint_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_bfd_endpoint_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _bfd_endpoint_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_bfd_endpoint_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_BFD)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_bfd_endpoint_get( \
    int unit, bcm_bfd_endpoint_t endpoint, bcm_bfd_endpoint_info_t *endpoint_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_bfd_endpoint_get,
static int (*_bfd_endpoint_get_dispatch[])(
    int unit, 
    bcm_bfd_endpoint_t endpoint, 
    bcm_bfd_endpoint_info_t *endpoint_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_bfd_endpoint_get(
    int unit, 
    bcm_bfd_endpoint_t endpoint, 
    bcm_bfd_endpoint_info_t *endpoint_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _bfd_endpoint_get_dispatch[dtype](unit, endpoint, endpoint_info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->gport);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->remote_gport);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->tx_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_bfd_endpoint_get", 3, 2, unit, endpoint, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_BFD)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_bfd_endpoint_poll( \
    int unit, bcm_bfd_endpoint_t endpoint);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_bfd_endpoint_poll,
static int (*_bfd_endpoint_poll_dispatch[])(
    int unit, 
    bcm_bfd_endpoint_t endpoint) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_bfd_endpoint_poll(
    int unit, 
    bcm_bfd_endpoint_t endpoint)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _bfd_endpoint_poll_dispatch[dtype](unit, endpoint);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_bfd_endpoint_poll", 2, 2, unit, endpoint, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_BFD)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_bfd_endpoint_stat_get( \
    int unit, bcm_bfd_endpoint_t endpoint, bcm_bfd_endpoint_stat_t *ctr_info, uint8 clear);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_bfd_endpoint_stat_get,
static int (*_bfd_endpoint_stat_get_dispatch[])(
    int unit, 
    bcm_bfd_endpoint_t endpoint, 
    bcm_bfd_endpoint_stat_t *ctr_info, 
    uint8 clear) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_bfd_endpoint_stat_get(
    int unit, 
    bcm_bfd_endpoint_t endpoint, 
    bcm_bfd_endpoint_stat_t *ctr_info, 
    uint8 clear)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _bfd_endpoint_stat_get_dispatch[dtype](unit, endpoint, ctr_info, clear);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_bfd_endpoint_stat_get", 4, 2, unit, endpoint, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_BFD)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_bfd_event_register( \
    int unit, bcm_bfd_event_types_t event_types, bcm_bfd_event_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_bfd_event_register,
static int (*_bfd_event_register_dispatch[])(
    int unit, 
    bcm_bfd_event_types_t event_types, 
    bcm_bfd_event_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_bfd_event_register(
    int unit, 
    bcm_bfd_event_types_t event_types, 
    bcm_bfd_event_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _bfd_event_register_dispatch[dtype](unit, event_types, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_bfd_event_register", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_BFD)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_bfd_event_unregister( \
    int unit, bcm_bfd_event_types_t event_types, bcm_bfd_event_cb cb);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_bfd_event_unregister,
static int (*_bfd_event_unregister_dispatch[])(
    int unit, 
    bcm_bfd_event_types_t event_types, 
    bcm_bfd_event_cb cb) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_bfd_event_unregister(
    int unit, 
    bcm_bfd_event_types_t event_types, 
    bcm_bfd_event_cb cb)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _bfd_event_unregister_dispatch[dtype](unit, event_types, cb);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_bfd_event_unregister", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_BFD)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_bfd_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_bfd_init,
static int (*_bfd_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_bfd_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _bfd_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_bfd_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_attach_ethernet( \
    int unit, int port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_attach_ethernet,
static int (*_ces_attach_ethernet_dispatch[])(
    int unit, 
    int port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_attach_ethernet(
    int unit, 
    int port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_attach_ethernet_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_attach_ethernet", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_cb_register( \
    int unit, bcm_ces_event_types_t events, bcm_ces_event_cb callback, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_cb_register,
static int (*_ces_cb_register_dispatch[])(
    int unit, 
    bcm_ces_event_types_t events, 
    bcm_ces_event_cb callback, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_cb_register(
    int unit, 
    bcm_ces_event_types_t events, 
    bcm_ces_event_cb callback, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_cb_register_dispatch[dtype](unit, events, callback, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_cb_register", 4, 2, unit, events, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_cb_unregister( \
    int unit, bcm_ces_event_types_t events, bcm_ces_event_cb callback);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_cb_unregister,
static int (*_ces_cb_unregister_dispatch[])(
    int unit, 
    bcm_ces_event_types_t events, 
    bcm_ces_event_cb callback) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_cb_unregister(
    int unit, 
    bcm_ces_event_types_t events, 
    bcm_ces_event_cb callback)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_cb_unregister_dispatch[dtype](unit, events, callback);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_cb_unregister", 3, 2, unit, events, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_detach,
static int (*_ces_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_egress_status_get( \
    int unit, bcm_ces_service_t ces_service, bcm_ces_service_egress_status_t *status);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_egress_status_get,
static int (*_ces_egress_status_get_dispatch[])(
    int unit, 
    bcm_ces_service_t ces_service, 
    bcm_ces_service_egress_status_t *status) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_egress_status_get(
    int unit, 
    bcm_ces_service_t ces_service, 
    bcm_ces_service_egress_status_t *status)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_egress_status_get_dispatch[dtype](unit, ces_service, status);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_egress_status_get", 3, 2, unit, ces_service, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_ethernet_config_get( \
    int unit, int port, bcm_ces_mac_cmd_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_ethernet_config_get,
static int (*_ces_ethernet_config_get_dispatch[])(
    int unit, 
    int port, 
    bcm_ces_mac_cmd_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_ethernet_config_get(
    int unit, 
    int port, 
    bcm_ces_mac_cmd_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_ethernet_config_get_dispatch[dtype](unit, port, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_ethernet_config_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_ethernet_config_set( \
    int unit, int port, bcm_ces_mac_cmd_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_ethernet_config_set,
static int (*_ces_ethernet_config_set_dispatch[])(
    int unit, 
    int port, 
    bcm_ces_mac_cmd_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_ethernet_config_set(
    int unit, 
    int port, 
    bcm_ces_mac_cmd_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_ethernet_config_set_dispatch[dtype](unit, port, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_ethernet_config_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_init,
static int (*_ces_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_service_cas_packet_enable( \
    int unit, bcm_ces_service_t ces_service, bcm_ces_cas_packet_control_t *cas_packet);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_service_cas_packet_enable,
static int (*_ces_service_cas_packet_enable_dispatch[])(
    int unit, 
    bcm_ces_service_t ces_service, 
    bcm_ces_cas_packet_control_t *cas_packet) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_service_cas_packet_enable(
    int unit, 
    bcm_ces_service_t ces_service, 
    bcm_ces_cas_packet_control_t *cas_packet)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_service_cas_packet_enable_dispatch[dtype](unit, ces_service, cas_packet);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_service_cas_packet_enable", 3, 2, unit, ces_service, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_service_config_get( \
    int unit, bcm_ces_service_t ces_service, bcm_ces_service_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_service_config_get,
static int (*_ces_service_config_get_dispatch[])(
    int unit, 
    bcm_ces_service_t ces_service, 
    bcm_ces_service_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_service_config_get(
    int unit, 
    bcm_ces_service_t ces_service, 
    bcm_ces_service_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_service_config_get_dispatch[dtype](unit, ces_service, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_service_config_get", 3, 2, unit, ces_service, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_service_control_word_get( \
    int unit, bcm_ces_service_t ces_service, uint16 *tx_control_word_mask, uint16 *tx_control_word, uint16 *rx_control_word);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_service_control_word_get,
static int (*_ces_service_control_word_get_dispatch[])(
    int unit, 
    bcm_ces_service_t ces_service, 
    uint16 *tx_control_word_mask, 
    uint16 *tx_control_word, 
    uint16 *rx_control_word) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_service_control_word_get(
    int unit, 
    bcm_ces_service_t ces_service, 
    uint16 *tx_control_word_mask, 
    uint16 *tx_control_word, 
    uint16 *rx_control_word)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_service_control_word_get_dispatch[dtype](unit, ces_service, tx_control_word_mask, tx_control_word, rx_control_word);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_service_control_word_get", 5, 2, unit, ces_service, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_service_control_word_set( \
    int unit, bcm_ces_service_t ces_service, uint16 tx_control_word_mask, uint16 tx_control_word);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_service_control_word_set,
static int (*_ces_service_control_word_set_dispatch[])(
    int unit, 
    bcm_ces_service_t ces_service, 
    uint16 tx_control_word_mask, 
    uint16 tx_control_word) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_service_control_word_set(
    int unit, 
    bcm_ces_service_t ces_service, 
    uint16 tx_control_word_mask, 
    uint16 tx_control_word)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_service_control_word_set_dispatch[dtype](unit, ces_service, tx_control_word_mask, tx_control_word);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_service_control_word_set", 4, 3, unit, ces_service, tx_control_word_mask, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_service_create( \
    int unit, int flags, bcm_ces_service_config_t *config, bcm_ces_service_t *ces_service);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_service_create,
static int (*_ces_service_create_dispatch[])(
    int unit, 
    int flags, 
    bcm_ces_service_config_t *config, 
    bcm_ces_service_t *ces_service) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_service_create(
    int unit, 
    int flags, 
    bcm_ces_service_config_t *config, 
    bcm_ces_service_t *ces_service)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_service_create_dispatch[dtype](unit, flags, config, ces_service);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_service_create", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_service_destroy( \
    int unit, bcm_ces_service_t ces_service);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_service_destroy,
static int (*_ces_service_destroy_dispatch[])(
    int unit, 
    bcm_ces_service_t ces_service) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_service_destroy(
    int unit, 
    bcm_ces_service_t ces_service)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_service_destroy_dispatch[dtype](unit, ces_service);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_service_destroy", 2, 2, unit, ces_service, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_service_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_service_destroy_all,
static int (*_ces_service_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_service_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_service_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_service_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_service_enable_get( \
    int unit, bcm_ces_service_t ces_service, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_service_enable_get,
static int (*_ces_service_enable_get_dispatch[])(
    int unit, 
    bcm_ces_service_t ces_service, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_service_enable_get(
    int unit, 
    bcm_ces_service_t ces_service, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_service_enable_get_dispatch[dtype](unit, ces_service, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_service_enable_get", 3, 2, unit, ces_service, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_service_enable_set( \
    int unit, bcm_ces_service_t ces_service, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_service_enable_set,
static int (*_ces_service_enable_set_dispatch[])(
    int unit, 
    bcm_ces_service_t ces_service, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_service_enable_set(
    int unit, 
    bcm_ces_service_t ces_service, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_service_enable_set_dispatch[dtype](unit, ces_service, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_service_enable_set", 3, 3, unit, ces_service, enable, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_service_ingress_cas_enable_get( \
    int unit, bcm_ces_service_t ces_service, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_service_ingress_cas_enable_get,
static int (*_ces_service_ingress_cas_enable_get_dispatch[])(
    int unit, 
    bcm_ces_service_t ces_service, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_service_ingress_cas_enable_get(
    int unit, 
    bcm_ces_service_t ces_service, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_service_ingress_cas_enable_get_dispatch[dtype](unit, ces_service, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_service_ingress_cas_enable_get", 3, 2, unit, ces_service, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_service_ingress_cas_enable_set( \
    int unit, bcm_ces_service_t ces_service, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_service_ingress_cas_enable_set,
static int (*_ces_service_ingress_cas_enable_set_dispatch[])(
    int unit, 
    bcm_ces_service_t ces_service, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_service_ingress_cas_enable_set(
    int unit, 
    bcm_ces_service_t ces_service, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_service_ingress_cas_enable_set_dispatch[dtype](unit, ces_service, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_service_ingress_cas_enable_set", 3, 3, unit, ces_service, enable, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_service_pm_clear( \
    int unit, bcm_ces_service_t ces_service);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_service_pm_clear,
static int (*_ces_service_pm_clear_dispatch[])(
    int unit, 
    bcm_ces_service_t ces_service) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_service_pm_clear(
    int unit, 
    bcm_ces_service_t ces_service)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_service_pm_clear_dispatch[dtype](unit, ces_service);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_service_pm_clear", 2, 2, unit, ces_service, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_service_pm_get( \
    int unit, bcm_ces_service_t ces_service, bcm_ces_service_pm_stats_t *stats);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_service_pm_get,
static int (*_ces_service_pm_get_dispatch[])(
    int unit, 
    bcm_ces_service_t ces_service, 
    bcm_ces_service_pm_stats_t *stats) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_service_pm_get(
    int unit, 
    bcm_ces_service_t ces_service, 
    bcm_ces_service_pm_stats_t *stats)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_service_pm_get_dispatch[dtype](unit, ces_service, stats);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_service_pm_get", 3, 2, unit, ces_service, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_service_rclock_config_get( \
    int unit, bcm_ces_service_t ces_service, bcm_ces_rclock_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_service_rclock_config_get,
static int (*_ces_service_rclock_config_get_dispatch[])(
    int unit, 
    bcm_ces_service_t ces_service, 
    bcm_ces_rclock_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_service_rclock_config_get(
    int unit, 
    bcm_ces_service_t ces_service, 
    bcm_ces_rclock_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_service_rclock_config_get_dispatch[dtype](unit, ces_service, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_service_rclock_config_get", 3, 2, unit, ces_service, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_service_rclock_config_set( \
    int unit, bcm_ces_service_t ces_service, bcm_ces_rclock_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_service_rclock_config_set,
static int (*_ces_service_rclock_config_set_dispatch[])(
    int unit, 
    bcm_ces_service_t ces_service, 
    bcm_ces_rclock_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_service_rclock_config_set(
    int unit, 
    bcm_ces_service_t ces_service, 
    bcm_ces_rclock_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_service_rclock_config_set_dispatch[dtype](unit, ces_service, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_service_rclock_config_set", 3, 2, unit, ces_service, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_services_cclk_config_get( \
    int unit, bcm_ces_cclk_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_services_cclk_config_get,
static int (*_ces_services_cclk_config_get_dispatch[])(
    int unit, 
    bcm_ces_cclk_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_services_cclk_config_get(
    int unit, 
    bcm_ces_cclk_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_services_cclk_config_get_dispatch[dtype](unit, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_services_cclk_config_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_services_cclk_config_set( \
    int unit, bcm_ces_cclk_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_services_cclk_config_set,
static int (*_ces_services_cclk_config_set_dispatch[])(
    int unit, 
    bcm_ces_cclk_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_services_cclk_config_set(
    int unit, 
    bcm_ces_cclk_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_services_cclk_config_set_dispatch[dtype](unit, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_services_cclk_config_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_services_clear( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_services_clear,
static int (*_ces_services_clear_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_services_clear(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_services_clear_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_services_clear", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_services_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_services_init,
static int (*_ces_services_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_services_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_services_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_services_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ces_services_traverse( \
    int unit, uint32 flags, bcm_ces_service_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ces_services_traverse,
static int (*_ces_services_traverse_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_ces_service_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ces_services_traverse(
    int unit, 
    uint32 flags, 
    bcm_ces_service_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ces_services_traverse_dispatch[dtype](unit, flags, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ces_services_traverse", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_clear( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_clear,
static int (*_clear_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_clear(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _clear_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_clear", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_bst_profile_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_bst_stat_id_t bid, bcm_cosq_bst_profile_t *profile);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_bst_profile_get,
static int (*_cosq_bst_profile_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_bst_stat_id_t bid, 
    bcm_cosq_bst_profile_t *profile) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_bst_profile_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_bst_stat_id_t bid, 
    bcm_cosq_bst_profile_t *profile)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_bst_profile_get_dispatch[dtype](unit, gport, cosq, bid, profile);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_bst_profile_get", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_bst_profile_set( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_bst_stat_id_t bid, bcm_cosq_bst_profile_t *profile);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_bst_profile_set,
static int (*_cosq_bst_profile_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_bst_stat_id_t bid, 
    bcm_cosq_bst_profile_t *profile) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_bst_profile_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_bst_stat_id_t bid, 
    bcm_cosq_bst_profile_t *profile)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_bst_profile_set_dispatch[dtype](unit, gport, cosq, bid, profile);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_bst_profile_set", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_bst_stat_clear( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_bst_stat_id_t bid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_bst_stat_clear,
static int (*_cosq_bst_stat_clear_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_bst_stat_id_t bid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_bst_stat_clear(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_bst_stat_id_t bid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_bst_stat_clear_dispatch[dtype](unit, gport, cosq, bid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_bst_stat_clear", 4, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_bst_stat_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_bst_stat_id_t bid, uint32 options, uint64 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_bst_stat_get,
static int (*_cosq_bst_stat_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_bst_stat_id_t bid, 
    uint32 options, 
    uint64 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_bst_stat_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_bst_stat_id_t bid, 
    uint32 options, 
    uint64 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_bst_stat_get_dispatch[dtype](unit, gport, cosq, bid, options, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_bst_stat_get", 6, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_bst_stat_get32( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_bst_stat_id_t bid, uint32 options, uint32 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_bst_stat_get32,
static int (*_cosq_bst_stat_get32_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_bst_stat_id_t bid, 
    uint32 options, 
    uint32 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_bst_stat_get32(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_bst_stat_id_t bid, 
    uint32 options, 
    uint32 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_bst_stat_get32_dispatch[dtype](unit, gport, cosq, bid, options, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_bst_stat_get32", 6, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_bst_stat_multi_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, uint32 options, int max_values, bcm_bst_stat_id_t *id_list, uint64 *values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_bst_stat_multi_get,
static int (*_cosq_bst_stat_multi_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 options, 
    int max_values, 
    bcm_bst_stat_id_t *id_list, 
    uint64 *values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_bst_stat_multi_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 options, 
    int max_values, 
    bcm_bst_stat_id_t *id_list, 
    uint64 *values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_bst_stat_multi_get_dispatch[dtype](unit, gport, cosq, options, max_values, id_list, values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_bst_stat_multi_get", 7, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_bst_stat_multi_get32( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, uint32 options, int max_values, bcm_bst_stat_id_t *id_list, uint32 *values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_bst_stat_multi_get32,
static int (*_cosq_bst_stat_multi_get32_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 options, 
    int max_values, 
    bcm_bst_stat_id_t *id_list, 
    uint32 *values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_bst_stat_multi_get32(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 options, 
    int max_values, 
    bcm_bst_stat_id_t *id_list, 
    uint32 *values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_bst_stat_multi_get32_dispatch[dtype](unit, gport, cosq, options, max_values, id_list, values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_bst_stat_multi_get32", 7, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_bst_stat_sync( \
    int unit, bcm_bst_stat_id_t bid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_bst_stat_sync,
static int (*_cosq_bst_stat_sync_dispatch[])(
    int unit, 
    bcm_bst_stat_id_t bid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_bst_stat_sync(
    int unit, 
    bcm_bst_stat_id_t bid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_bst_stat_sync_dispatch[dtype](unit, bid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_bst_stat_sync", 2, 2, unit, bid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_classifier_create( \
    int unit, bcm_cosq_classifier_t *classifier, int *classifier_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_classifier_create,
static int (*_cosq_classifier_create_dispatch[])(
    int unit, 
    bcm_cosq_classifier_t *classifier, 
    int *classifier_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_classifier_create(
    int unit, 
    bcm_cosq_classifier_t *classifier, 
    int *classifier_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(classifier_gport);
		BCM_API_XLATE_PORT_COND(classifier) BCM_API_XLATE_PORT_SAVE(classifier_gport,classifier->gport);
		BCM_API_XLATE_PORT_COND(classifier) BCM_API_XLATE_PORT_A2P(unit,&classifier->gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_classifier_create_dispatch[dtype](unit, classifier, classifier_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(classifier) BCM_API_XLATE_PORT_RESTORE(classifier->gport,classifier_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_classifier_create", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_classifier_destroy( \
    int unit, int classifier_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_classifier_destroy,
static int (*_cosq_classifier_destroy_dispatch[])(
    int unit, 
    int classifier_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_classifier_destroy(
    int unit, 
    int classifier_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_classifier_destroy_dispatch[dtype](unit, classifier_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_classifier_destroy", 2, 2, unit, classifier_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_classifier_get( \
    int unit, int classifier_id, bcm_cosq_classifier_t *classifier);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_classifier_get,
static int (*_cosq_classifier_get_dispatch[])(
    int unit, 
    int classifier_id, 
    bcm_cosq_classifier_t *classifier) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_classifier_get(
    int unit, 
    int classifier_id, 
    bcm_cosq_classifier_t *classifier)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_classifier_get_dispatch[dtype](unit, classifier_id, classifier);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(classifier) BCM_API_XLATE_PORT_P2A(unit,&classifier->gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_classifier_get", 3, 2, unit, classifier_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_classifier_mapping_clear( \
    int unit, bcm_gport_t port, int classifier_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_classifier_mapping_clear,
static int (*_cosq_classifier_mapping_clear_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int classifier_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_classifier_mapping_clear(
    int unit, 
    bcm_gport_t port, 
    int classifier_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_classifier_mapping_clear_dispatch[dtype](unit, port, classifier_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_classifier_mapping_clear", 3, 3, unit, port, classifier_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_classifier_mapping_get( \
    int unit, bcm_gport_t port, int classifier_id, bcm_gport_t *queue_group, bcm_cos_t priority, bcm_cos_queue_t *cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_classifier_mapping_get,
static int (*_cosq_classifier_mapping_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int classifier_id, 
    bcm_gport_t *queue_group, 
    bcm_cos_t priority, 
    bcm_cos_queue_t *cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_classifier_mapping_get(
    int unit, 
    bcm_gport_t port, 
    int classifier_id, 
    bcm_gport_t *queue_group, 
    bcm_cos_t priority, 
    bcm_cos_queue_t *cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_classifier_mapping_get_dispatch[dtype](unit, port, classifier_id, queue_group, priority, cosq);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,queue_group);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_classifier_mapping_get", 6, 3, unit, port, classifier_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_classifier_mapping_multi_get( \
    int unit, bcm_gport_t port, int classifier_id, bcm_gport_t *queue_group, int array_max, bcm_cos_t *priority_array, bcm_cos_queue_t *cosq_array, int *array_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_classifier_mapping_multi_get,
static int (*_cosq_classifier_mapping_multi_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int classifier_id, 
    bcm_gport_t *queue_group, 
    int array_max, 
    bcm_cos_t *priority_array, 
    bcm_cos_queue_t *cosq_array, 
    int *array_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_classifier_mapping_multi_get(
    int unit, 
    bcm_gport_t port, 
    int classifier_id, 
    bcm_gport_t *queue_group, 
    int array_max, 
    bcm_cos_t *priority_array, 
    bcm_cos_queue_t *cosq_array, 
    int *array_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_classifier_mapping_multi_get_dispatch[dtype](unit, port, classifier_id, queue_group, array_max, priority_array, cosq_array, array_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,queue_group);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_classifier_mapping_multi_get", 8, 3, unit, port, classifier_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_classifier_mapping_multi_set( \
    int unit, bcm_gport_t port, int classifier_id, bcm_gport_t queue_group, int array_count, bcm_cos_t *priority_array, bcm_cos_queue_t *cosq_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_classifier_mapping_multi_set,
static int (*_cosq_classifier_mapping_multi_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int classifier_id, 
    bcm_gport_t queue_group, 
    int array_count, 
    bcm_cos_t *priority_array, 
    bcm_cos_queue_t *cosq_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_classifier_mapping_multi_set(
    int unit, 
    bcm_gport_t port, 
    int classifier_id, 
    bcm_gport_t queue_group, 
    int array_count, 
    bcm_cos_t *priority_array, 
    bcm_cos_queue_t *cosq_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&queue_group);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_classifier_mapping_multi_set_dispatch[dtype](unit, port, classifier_id, queue_group, array_count, priority_array, cosq_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_classifier_mapping_multi_set", 7, 3, unit, port, classifier_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_classifier_mapping_set( \
    int unit, bcm_gport_t port, int classifier_id, bcm_gport_t queue_group, bcm_cos_t priority, bcm_cos_queue_t cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_classifier_mapping_set,
static int (*_cosq_classifier_mapping_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int classifier_id, 
    bcm_gport_t queue_group, 
    bcm_cos_t priority, 
    bcm_cos_queue_t cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_classifier_mapping_set(
    int unit, 
    bcm_gport_t port, 
    int classifier_id, 
    bcm_gport_t queue_group, 
    bcm_cos_t priority, 
    bcm_cos_queue_t cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&queue_group);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_classifier_mapping_set_dispatch[dtype](unit, port, classifier_id, queue_group, priority, cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_classifier_mapping_set", 6, 3, unit, port, classifier_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_config_get( \
    int unit, int *numq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_config_get,
static int (*_cosq_config_get_dispatch[])(
    int unit, 
    int *numq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_config_get(
    int unit, 
    int *numq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_config_get_dispatch[dtype](unit, numq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_config_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_config_set( \
    int unit, int numq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_config_set,
static int (*_cosq_config_set_dispatch[])(
    int unit, 
    int numq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_config_set(
    int unit, 
    int numq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_config_set_dispatch[dtype](unit, numq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_config_set", 2, 2, unit, numq, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_control_get( \
    int unit, bcm_gport_t port, bcm_cos_queue_t cosq, bcm_cosq_control_t type, int *arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_control_get,
static int (*_cosq_control_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_control_t type, 
    int *arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_control_get(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_control_t type, 
    int *arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_control_get_dispatch[dtype](unit, port, cosq, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_control_get", 5, 3, unit, port, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_control_set( \
    int unit, bcm_gport_t port, bcm_cos_queue_t cosq, bcm_cosq_control_t type, int arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_control_set,
static int (*_cosq_control_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_control_t type, 
    int arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_control_set(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_control_t type, 
    int arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_control_set_dispatch[dtype](unit, port, cosq, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_control_set", 5, 3, unit, port, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_cpu_cosq_enable_get( \
    int unit, bcm_cos_queue_t cosq, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_cpu_cosq_enable_get,
static int (*_cosq_cpu_cosq_enable_get_dispatch[])(
    int unit, 
    bcm_cos_queue_t cosq, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_cpu_cosq_enable_get(
    int unit, 
    bcm_cos_queue_t cosq, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_cpu_cosq_enable_get_dispatch[dtype](unit, cosq, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_cpu_cosq_enable_get", 3, 2, unit, cosq, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_cpu_cosq_enable_set( \
    int unit, bcm_cos_queue_t cosq, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_cpu_cosq_enable_set,
static int (*_cosq_cpu_cosq_enable_set_dispatch[])(
    int unit, 
    bcm_cos_queue_t cosq, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_cpu_cosq_enable_set(
    int unit, 
    bcm_cos_queue_t cosq, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_cpu_cosq_enable_set_dispatch[dtype](unit, cosq, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_cpu_cosq_enable_set", 3, 3, unit, cosq, enable, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_delay_tolerance_level_get( \
    int unit, int delay_tolerance_level, bcm_cosq_delay_tolerance_t *delay_tolerance);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_delay_tolerance_level_get,
static int (*_cosq_delay_tolerance_level_get_dispatch[])(
    int unit, 
    int delay_tolerance_level, 
    bcm_cosq_delay_tolerance_t *delay_tolerance) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_delay_tolerance_level_get(
    int unit, 
    int delay_tolerance_level, 
    bcm_cosq_delay_tolerance_t *delay_tolerance)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_delay_tolerance_level_get_dispatch[dtype](unit, delay_tolerance_level, delay_tolerance);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_delay_tolerance_level_get", 3, 2, unit, delay_tolerance_level, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_delay_tolerance_level_set( \
    int unit, int delay_tolerance_level, bcm_cosq_delay_tolerance_t *delay_tolerance);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_delay_tolerance_level_set,
static int (*_cosq_delay_tolerance_level_set_dispatch[])(
    int unit, 
    int delay_tolerance_level, 
    bcm_cosq_delay_tolerance_t *delay_tolerance) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_delay_tolerance_level_set(
    int unit, 
    int delay_tolerance_level, 
    bcm_cosq_delay_tolerance_t *delay_tolerance)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_delay_tolerance_level_set_dispatch[dtype](unit, delay_tolerance_level, delay_tolerance);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_delay_tolerance_level_set", 3, 2, unit, delay_tolerance_level, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_dest_credit_size_get( \
    int unit, bcm_module_t dest_modid, uint32 *credit_size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_dest_credit_size_get,
static int (*_cosq_dest_credit_size_get_dispatch[])(
    int unit, 
    bcm_module_t dest_modid, 
    uint32 *credit_size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_dest_credit_size_get(
    int unit, 
    bcm_module_t dest_modid, 
    uint32 *credit_size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_dest_credit_size_get_dispatch[dtype](unit, dest_modid, credit_size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_dest_credit_size_get", 3, 2, unit, dest_modid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_dest_credit_size_set( \
    int unit, bcm_module_t dest_modid, uint32 credit_size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_dest_credit_size_set,
static int (*_cosq_dest_credit_size_set_dispatch[])(
    int unit, 
    bcm_module_t dest_modid, 
    uint32 credit_size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_dest_credit_size_set(
    int unit, 
    bcm_module_t dest_modid, 
    uint32 credit_size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_dest_credit_size_set_dispatch[dtype](unit, dest_modid, credit_size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_dest_credit_size_set", 3, 3, unit, dest_modid, credit_size, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_detach,
static int (*_cosq_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_discard_get( \
    int unit, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_discard_get,
static int (*_cosq_discard_get_dispatch[])(
    int unit, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_discard_get(
    int unit, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_discard_get_dispatch[dtype](unit, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_discard_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_discard_port_get( \
    int unit, bcm_port_t port, bcm_cos_queue_t cosq, uint32 color, int *drop_start, int *drop_slope, int *average_time);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_discard_port_get,
static int (*_cosq_discard_port_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_cos_queue_t cosq, 
    uint32 color, 
    int *drop_start, 
    int *drop_slope, 
    int *average_time) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_discard_port_get(
    int unit, 
    bcm_port_t port, 
    bcm_cos_queue_t cosq, 
    uint32 color, 
    int *drop_start, 
    int *drop_slope, 
    int *average_time)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_discard_port_get_dispatch[dtype](unit, port, cosq, color, drop_start, drop_slope, average_time);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_discard_port_get", 7, 3, unit, port, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_discard_port_set( \
    int unit, bcm_port_t port, bcm_cos_queue_t cosq, uint32 color, int drop_start, int drop_slope, int average_time);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_discard_port_set,
static int (*_cosq_discard_port_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_cos_queue_t cosq, 
    uint32 color, 
    int drop_start, 
    int drop_slope, 
    int average_time) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_discard_port_set(
    int unit, 
    bcm_port_t port, 
    bcm_cos_queue_t cosq, 
    uint32 color, 
    int drop_start, 
    int drop_slope, 
    int average_time)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_discard_port_set_dispatch[dtype](unit, port, cosq, color, drop_start, drop_slope, average_time);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_discard_port_set", 7, 3, unit, port, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_discard_set( \
    int unit, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_discard_set,
static int (*_cosq_discard_set_dispatch[])(
    int unit, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_discard_set(
    int unit, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_discard_set_dispatch[dtype](unit, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_discard_set", 2, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_fabric_distribution_add( \
    int unit, bcm_fabric_distribution_t ds_id, int num_cos_levels, uint32 flags, bcm_gport_t *req_gport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_fabric_distribution_add,
static int (*_cosq_fabric_distribution_add_dispatch[])(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    int num_cos_levels, 
    uint32 flags, 
    bcm_gport_t *req_gport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_fabric_distribution_add(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    int num_cos_levels, 
    uint32 flags, 
    bcm_gport_t *req_gport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,req_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_fabric_distribution_add_dispatch[dtype](unit, ds_id, num_cos_levels, flags, req_gport);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,req_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_fabric_distribution_add", 5, 3, unit, ds_id, num_cos_levels, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_fabric_distribution_get( \
    int unit, bcm_fabric_distribution_t ds_id, int *num_cos_levels, bcm_gport_t *req_gport, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_fabric_distribution_get,
static int (*_cosq_fabric_distribution_get_dispatch[])(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    int *num_cos_levels, 
    bcm_gport_t *req_gport, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_fabric_distribution_get(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    int *num_cos_levels, 
    bcm_gport_t *req_gport, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_fabric_distribution_get_dispatch[dtype](unit, ds_id, num_cos_levels, req_gport, flags);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,req_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_fabric_distribution_get", 5, 2, unit, ds_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_fc_path_add( \
    int unit, bcm_cosq_fc_direction_type_t fc_direction, bcm_cosq_fc_endpoint_t *source, bcm_cosq_fc_endpoint_t *target);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_fc_path_add,
static int (*_cosq_fc_path_add_dispatch[])(
    int unit, 
    bcm_cosq_fc_direction_type_t fc_direction, 
    bcm_cosq_fc_endpoint_t *source, 
    bcm_cosq_fc_endpoint_t *target) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_fc_path_add(
    int unit, 
    bcm_cosq_fc_direction_type_t fc_direction, 
    bcm_cosq_fc_endpoint_t *source, 
    bcm_cosq_fc_endpoint_t *target)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(source_port);
		BCM_API_XLATE_PORT_DECL(target_port);
		BCM_API_XLATE_PORT_COND(source) BCM_API_XLATE_PORT_SAVE(source_port,source->port);
		BCM_API_XLATE_PORT_COND(source) BCM_API_XLATE_PORT_A2P(unit,&source->port);
		BCM_API_XLATE_PORT_COND(target) BCM_API_XLATE_PORT_SAVE(target_port,target->port);
		BCM_API_XLATE_PORT_COND(target) BCM_API_XLATE_PORT_A2P(unit,&target->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_fc_path_add_dispatch[dtype](unit, fc_direction, source, target);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(source) BCM_API_XLATE_PORT_RESTORE(source->port,source_port);
		BCM_API_XLATE_PORT_COND(target) BCM_API_XLATE_PORT_RESTORE(target->port,target_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_fc_path_add", 4, 2, unit, fc_direction, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_fc_path_delete( \
    int unit, bcm_cosq_fc_direction_type_t fc_direction, bcm_cosq_fc_endpoint_t *source, bcm_cosq_fc_endpoint_t *target);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_fc_path_delete,
static int (*_cosq_fc_path_delete_dispatch[])(
    int unit, 
    bcm_cosq_fc_direction_type_t fc_direction, 
    bcm_cosq_fc_endpoint_t *source, 
    bcm_cosq_fc_endpoint_t *target) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_fc_path_delete(
    int unit, 
    bcm_cosq_fc_direction_type_t fc_direction, 
    bcm_cosq_fc_endpoint_t *source, 
    bcm_cosq_fc_endpoint_t *target)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(source_port);
		BCM_API_XLATE_PORT_DECL(target_port);
		BCM_API_XLATE_PORT_COND(source) BCM_API_XLATE_PORT_SAVE(source_port,source->port);
		BCM_API_XLATE_PORT_COND(source) BCM_API_XLATE_PORT_A2P(unit,&source->port);
		BCM_API_XLATE_PORT_COND(target) BCM_API_XLATE_PORT_SAVE(target_port,target->port);
		BCM_API_XLATE_PORT_COND(target) BCM_API_XLATE_PORT_A2P(unit,&target->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_fc_path_delete_dispatch[dtype](unit, fc_direction, source, target);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(source) BCM_API_XLATE_PORT_RESTORE(source->port,source_port);
		BCM_API_XLATE_PORT_COND(target) BCM_API_XLATE_PORT_RESTORE(target->port,target_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_fc_path_delete", 4, 2, unit, fc_direction, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_fc_path_get( \
    int unit, bcm_cosq_fc_direction_type_t fc_direction, bcm_cosq_fc_endpoint_t *source, int target_max, bcm_cosq_fc_endpoint_t *target, int *target_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_fc_path_get,
static int (*_cosq_fc_path_get_dispatch[])(
    int unit, 
    bcm_cosq_fc_direction_type_t fc_direction, 
    bcm_cosq_fc_endpoint_t *source, 
    int target_max, 
    bcm_cosq_fc_endpoint_t *target, 
    int *target_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_fc_path_get(
    int unit, 
    bcm_cosq_fc_direction_type_t fc_direction, 
    bcm_cosq_fc_endpoint_t *source, 
    int target_max, 
    bcm_cosq_fc_endpoint_t *target, 
    int *target_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(source_port);
		BCM_API_XLATE_PORT_COND(source) BCM_API_XLATE_PORT_SAVE(source_port,source->port);
		BCM_API_XLATE_PORT_COND(source) BCM_API_XLATE_PORT_A2P(unit,&source->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_fc_path_get_dispatch[dtype](unit, fc_direction, source, target_max, target, target_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(source) BCM_API_XLATE_PORT_RESTORE(source->port,source_port);
		BCM_API_XLATE_PORT_COND(target) BCM_API_XLATE_PORT_P2A(unit,&target->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_fc_path_get", 6, 2, unit, fc_direction, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_add( \
    int unit, bcm_gport_t port, int numq, uint32 flags, bcm_gport_t *gport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_add,
static int (*_cosq_gport_add_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int numq, 
    uint32 flags, 
    bcm_gport_t *gport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_add(
    int unit, 
    bcm_gport_t port, 
    int numq, 
    uint32 flags, 
    bcm_gport_t *gport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_add_dispatch[dtype](unit, port, numq, flags, gport);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_add", 5, 3, unit, port, numq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_attach( \
    int unit, bcm_gport_t sched_port, bcm_gport_t input_port, bcm_cos_queue_t cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_attach,
static int (*_cosq_gport_attach_dispatch[])(
    int unit, 
    bcm_gport_t sched_port, 
    bcm_gport_t input_port, 
    bcm_cos_queue_t cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_attach(
    int unit, 
    bcm_gport_t sched_port, 
    bcm_gport_t input_port, 
    bcm_cos_queue_t cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&sched_port);
		BCM_API_XLATE_PORT_A2P(unit,&input_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_attach_dispatch[dtype](unit, sched_port, input_port, cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_attach", 4, 3, unit, sched_port, input_port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_attach_get( \
    int unit, bcm_gport_t sched_port, bcm_gport_t *input_port, bcm_cos_queue_t *cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_attach_get,
static int (*_cosq_gport_attach_get_dispatch[])(
    int unit, 
    bcm_gport_t sched_port, 
    bcm_gport_t *input_port, 
    bcm_cos_queue_t *cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_attach_get(
    int unit, 
    bcm_gport_t sched_port, 
    bcm_gport_t *input_port, 
    bcm_cos_queue_t *cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&sched_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_attach_get_dispatch[dtype](unit, sched_port, input_port, cosq);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,input_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_attach_get", 4, 2, unit, sched_port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_bandwidth_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, uint32 *kbits_sec_min, uint32 *kbits_sec_max, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_bandwidth_get,
static int (*_cosq_gport_bandwidth_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 *kbits_sec_min, 
    uint32 *kbits_sec_max, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_bandwidth_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 *kbits_sec_min, 
    uint32 *kbits_sec_max, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_bandwidth_get_dispatch[dtype](unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_bandwidth_get", 6, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_bandwidth_set( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, uint32 kbits_sec_min, uint32 kbits_sec_max, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_bandwidth_set,
static int (*_cosq_gport_bandwidth_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 kbits_sec_min, 
    uint32 kbits_sec_max, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_bandwidth_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 kbits_sec_min, 
    uint32 kbits_sec_max, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_bandwidth_set_dispatch[dtype](unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_bandwidth_set", 6, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_child_get( \
    int unit, bcm_gport_t in_gport, bcm_cos_queue_t cosq, bcm_gport_t *out_gport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_child_get,
static int (*_cosq_gport_child_get_dispatch[])(
    int unit, 
    bcm_gport_t in_gport, 
    bcm_cos_queue_t cosq, 
    bcm_gport_t *out_gport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_child_get(
    int unit, 
    bcm_gport_t in_gport, 
    bcm_cos_queue_t cosq, 
    bcm_gport_t *out_gport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&in_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_child_get_dispatch[dtype](unit, in_gport, cosq, out_gport);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,out_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_child_get", 4, 3, unit, in_gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_color_size_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_color_t color, uint32 flags, bcm_cosq_gport_size_t *gport_size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_color_size_get,
static int (*_cosq_gport_color_size_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_color_t color, 
    uint32 flags, 
    bcm_cosq_gport_size_t *gport_size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_color_size_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_color_t color, 
    uint32 flags, 
    bcm_cosq_gport_size_t *gport_size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_color_size_get_dispatch[dtype](unit, gport, cosq, color, flags, gport_size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_color_size_get", 6, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_color_size_set( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_color_t color, uint32 flags, bcm_cosq_gport_size_t *gport_size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_color_size_set,
static int (*_cosq_gport_color_size_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_color_t color, 
    uint32 flags, 
    bcm_cosq_gport_size_t *gport_size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_color_size_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_color_t color, 
    uint32 flags, 
    bcm_cosq_gport_size_t *gport_size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_color_size_set_dispatch[dtype](unit, gport, cosq, color, flags, gport_size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_color_size_set", 6, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_congestion_config_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_congestion_info_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_congestion_config_get,
static int (*_cosq_gport_congestion_config_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_congestion_info_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_congestion_config_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_congestion_info_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_congestion_config_get_dispatch[dtype](unit, gport, cosq, config);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_P2A(unit,&config->dest_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_P2A(unit,&config->fabric_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_congestion_config_get", 4, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_congestion_config_set( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_congestion_info_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_congestion_config_set,
static int (*_cosq_gport_congestion_config_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_congestion_info_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_congestion_config_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_congestion_info_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(config_dest_port);
		BCM_API_XLATE_PORT_DECL(config_fabric_port);
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_SAVE(config_dest_port,config->dest_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_A2P(unit,&config->dest_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_SAVE(config_fabric_port,config->fabric_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_A2P(unit,&config->fabric_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_congestion_config_set_dispatch[dtype](unit, gport, cosq, config);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_RESTORE(config->dest_port,config_dest_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_RESTORE(config->fabric_port,config_fabric_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_congestion_config_set", 4, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_connection_get( \
    int unit, bcm_cosq_gport_connection_t *gport_connect);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_connection_get,
static int (*_cosq_gport_connection_get_dispatch[])(
    int unit, 
    bcm_cosq_gport_connection_t *gport_connect) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_connection_get(
    int unit, 
    bcm_cosq_gport_connection_t *gport_connect)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(gport_connect) BCM_API_XLATE_PORT_A2P(unit,&gport_connect->voq);
		BCM_API_XLATE_PORT_COND(gport_connect) BCM_API_XLATE_PORT_A2P(unit,&gport_connect->voq_connector);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_connection_get_dispatch[dtype](unit, gport_connect);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(gport_connect) BCM_API_XLATE_PORT_P2A(unit,&gport_connect->voq);
		BCM_API_XLATE_PORT_COND(gport_connect) BCM_API_XLATE_PORT_P2A(unit,&gport_connect->voq_connector);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_connection_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_connection_set( \
    int unit, bcm_cosq_gport_connection_t *gport_connect);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_connection_set,
static int (*_cosq_gport_connection_set_dispatch[])(
    int unit, 
    bcm_cosq_gport_connection_t *gport_connect) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_connection_set(
    int unit, 
    bcm_cosq_gport_connection_t *gport_connect)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(gport_connect_voq);
		BCM_API_XLATE_PORT_DECL(gport_connect_voq_connector);
		BCM_API_XLATE_PORT_COND(gport_connect) BCM_API_XLATE_PORT_SAVE(gport_connect_voq,gport_connect->voq);
		BCM_API_XLATE_PORT_COND(gport_connect) BCM_API_XLATE_PORT_A2P(unit,&gport_connect->voq);
		BCM_API_XLATE_PORT_COND(gport_connect) BCM_API_XLATE_PORT_SAVE(gport_connect_voq_connector,gport_connect->voq_connector);
		BCM_API_XLATE_PORT_COND(gport_connect) BCM_API_XLATE_PORT_A2P(unit,&gport_connect->voq_connector);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_connection_set_dispatch[dtype](unit, gport_connect);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(gport_connect) BCM_API_XLATE_PORT_RESTORE(gport_connect->voq,gport_connect_voq);
		BCM_API_XLATE_PORT_COND(gport_connect) BCM_API_XLATE_PORT_RESTORE(gport_connect->voq_connector,gport_connect_voq_connector);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_connection_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_delete( \
    int unit, bcm_gport_t gport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_delete,
static int (*_cosq_gport_delete_dispatch[])(
    int unit, 
    bcm_gport_t gport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_delete(
    int unit, 
    bcm_gport_t gport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_delete_dispatch[dtype](unit, gport);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_delete", 2, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_destmod_attach( \
    int unit, bcm_gport_t gport, bcm_port_t ingress_port, bcm_module_t dest_modid, int fabric_egress_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_destmod_attach,
static int (*_cosq_gport_destmod_attach_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_port_t ingress_port, 
    bcm_module_t dest_modid, 
    int fabric_egress_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_destmod_attach(
    int unit, 
    bcm_gport_t gport, 
    bcm_port_t ingress_port, 
    bcm_module_t dest_modid, 
    int fabric_egress_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		BCM_API_XLATE_PORT_A2P(unit,&ingress_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_destmod_attach_dispatch[dtype](unit, gport, ingress_port, dest_modid, fabric_egress_port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_destmod_attach", 5, 3, unit, gport, ingress_port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_destmod_detach( \
    int unit, bcm_gport_t gport, bcm_port_t ingress_port, bcm_module_t dest_modid, int fabric_egress_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_destmod_detach,
static int (*_cosq_gport_destmod_detach_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_port_t ingress_port, 
    bcm_module_t dest_modid, 
    int fabric_egress_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_destmod_detach(
    int unit, 
    bcm_gport_t gport, 
    bcm_port_t ingress_port, 
    bcm_module_t dest_modid, 
    int fabric_egress_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		BCM_API_XLATE_PORT_A2P(unit,&ingress_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_destmod_detach_dispatch[dtype](unit, gport, ingress_port, dest_modid, fabric_egress_port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_destmod_detach", 5, 3, unit, gport, ingress_port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_detach( \
    int unit, bcm_gport_t sched_port, bcm_gport_t input_port, bcm_cos_queue_t cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_detach,
static int (*_cosq_gport_detach_dispatch[])(
    int unit, 
    bcm_gport_t sched_port, 
    bcm_gport_t input_port, 
    bcm_cos_queue_t cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_detach(
    int unit, 
    bcm_gport_t sched_port, 
    bcm_gport_t input_port, 
    bcm_cos_queue_t cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&sched_port);
		BCM_API_XLATE_PORT_A2P(unit,&input_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_detach_dispatch[dtype](unit, sched_port, input_port, cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_detach", 4, 3, unit, sched_port, input_port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_discard_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_gport_discard_t *discard);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_discard_get,
static int (*_cosq_gport_discard_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_gport_discard_t *discard) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_discard_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_gport_discard_t *discard)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_discard_get_dispatch[dtype](unit, gport, cosq, discard);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_discard_get", 4, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_discard_set( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_gport_discard_t *discard);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_discard_set,
static int (*_cosq_gport_discard_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_gport_discard_t *discard) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_discard_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_gport_discard_t *discard)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_discard_set_dispatch[dtype](unit, gport, cosq, discard);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_discard_set", 4, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_dynamic_sched_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_dynamic_state_t state, int *weight);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_dynamic_sched_get,
static int (*_cosq_gport_dynamic_sched_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_dynamic_state_t state, 
    int *weight) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_dynamic_sched_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_dynamic_state_t state, 
    int *weight)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_dynamic_sched_get_dispatch[dtype](unit, gport, cosq, state, weight);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_dynamic_sched_get", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_dynamic_sched_set( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_dynamic_state_t state, int weight);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_dynamic_sched_set,
static int (*_cosq_gport_dynamic_sched_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_dynamic_state_t state, 
    int weight) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_dynamic_sched_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_dynamic_state_t state, 
    int weight)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_dynamic_sched_set_dispatch[dtype](unit, gport, cosq, state, weight);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_dynamic_sched_set", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_egress_map_get( \
    int unit, bcm_gport_t gport, bcm_cos_t ingress_pri, bcm_color_t ingress_dp, bcm_cos_queue_t *offset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_egress_map_get,
static int (*_cosq_gport_egress_map_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_t ingress_pri, 
    bcm_color_t ingress_dp, 
    bcm_cos_queue_t *offset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_egress_map_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_t ingress_pri, 
    bcm_color_t ingress_dp, 
    bcm_cos_queue_t *offset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_egress_map_get_dispatch[dtype](unit, gport, ingress_pri, ingress_dp, offset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_egress_map_get", 5, 3, unit, gport, ingress_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_egress_map_set( \
    int unit, bcm_gport_t gport, bcm_cos_t ingress_pri, bcm_color_t ingress_dp, bcm_cos_queue_t offset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_egress_map_set,
static int (*_cosq_gport_egress_map_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_t ingress_pri, 
    bcm_color_t ingress_dp, 
    bcm_cos_queue_t offset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_egress_map_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_t ingress_pri, 
    bcm_color_t ingress_dp, 
    bcm_cos_queue_t offset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_egress_map_set_dispatch[dtype](unit, gport, ingress_pri, ingress_dp, offset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_egress_map_set", 5, 3, unit, gport, ingress_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_egress_multicast_config_get( \
    int unit, bcm_gport_t gport, bcm_cos_t ingress_pri, bcm_color_t ingress_dp, uint32 flags, bcm_cosq_egress_multicast_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_egress_multicast_config_get,
static int (*_cosq_gport_egress_multicast_config_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_t ingress_pri, 
    bcm_color_t ingress_dp, 
    uint32 flags, 
    bcm_cosq_egress_multicast_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_egress_multicast_config_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_t ingress_pri, 
    bcm_color_t ingress_dp, 
    uint32 flags, 
    bcm_cosq_egress_multicast_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_egress_multicast_config_get_dispatch[dtype](unit, gport, ingress_pri, ingress_dp, flags, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_egress_multicast_config_get", 6, 3, unit, gport, ingress_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_egress_multicast_config_set( \
    int unit, bcm_gport_t gport, bcm_cos_t ingress_pri, bcm_color_t ingress_dp, uint32 flags, bcm_cosq_egress_multicast_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_egress_multicast_config_set,
static int (*_cosq_gport_egress_multicast_config_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_t ingress_pri, 
    bcm_color_t ingress_dp, 
    uint32 flags, 
    bcm_cosq_egress_multicast_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_egress_multicast_config_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_t ingress_pri, 
    bcm_color_t ingress_dp, 
    uint32 flags, 
    bcm_cosq_egress_multicast_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_egress_multicast_config_set_dispatch[dtype](unit, gport, ingress_pri, ingress_dp, flags, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_egress_multicast_config_set", 6, 3, unit, gport, ingress_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_enable_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_enable_get,
static int (*_cosq_gport_enable_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_enable_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_enable_get_dispatch[dtype](unit, gport, cosq, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_enable_get", 4, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_enable_set( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_enable_set,
static int (*_cosq_gport_enable_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_enable_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_enable_set_dispatch[dtype](unit, gport, cosq, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_enable_set", 4, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_flow_control_get( \
    int unit, bcm_gport_t port, bcm_cos_t int_pri, uint32 *flow_control_mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_flow_control_get,
static int (*_cosq_gport_flow_control_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_t int_pri, 
    uint32 *flow_control_mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_flow_control_get(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_t int_pri, 
    uint32 *flow_control_mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_flow_control_get_dispatch[dtype](unit, port, int_pri, flow_control_mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_flow_control_get", 4, 3, unit, port, int_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_flow_control_set( \
    int unit, bcm_gport_t port, bcm_cos_t int_pri, uint32 flow_control_mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_flow_control_set,
static int (*_cosq_gport_flow_control_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_t int_pri, 
    uint32 flow_control_mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_flow_control_set(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_t int_pri, 
    uint32 flow_control_mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_flow_control_set_dispatch[dtype](unit, port, int_pri, flow_control_mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_flow_control_set", 4, 3, unit, port, int_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_get( \
    int unit, bcm_gport_t gport, bcm_gport_t *physical_port, int *num_cos_levels, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_get,
static int (*_cosq_gport_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t *physical_port, 
    int *num_cos_levels, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t *physical_port, 
    int *num_cos_levels, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_get_dispatch[dtype](unit, gport, physical_port, num_cos_levels, flags);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,physical_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_get", 5, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_handle_core_get( \
    int unit, int core, bcm_cosq_gport_info_core_t *gport_info, bcm_gport_t *out_gport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_handle_core_get,
static int (*_cosq_gport_handle_core_get_dispatch[])(
    int unit, 
    int core, 
    bcm_cosq_gport_info_core_t *gport_info, 
    bcm_gport_t *out_gport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_handle_core_get(
    int unit, 
    int core, 
    bcm_cosq_gport_info_core_t *gport_info, 
    bcm_gport_t *out_gport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(gport_info_in_gport);
		BCM_API_XLATE_PORT_COND(gport_info) BCM_API_XLATE_PORT_SAVE(gport_info_in_gport,gport_info->in_gport);
		BCM_API_XLATE_PORT_COND(gport_info) BCM_API_XLATE_PORT_A2P(unit,&gport_info->in_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_handle_core_get_dispatch[dtype](unit, core, gport_info, out_gport);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(gport_info) BCM_API_XLATE_PORT_RESTORE(gport_info->in_gport,gport_info_in_gport);
		BCM_API_XLATE_PORT_P2A(unit,out_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_handle_core_get", 4, 2, unit, core, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_handle_get( \
    int unit, bcm_cosq_gport_type_t gport_type, bcm_cosq_gport_info_t *gport_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_handle_get,
static int (*_cosq_gport_handle_get_dispatch[])(
    int unit, 
    bcm_cosq_gport_type_t gport_type, 
    bcm_cosq_gport_info_t *gport_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_handle_get(
    int unit, 
    bcm_cosq_gport_type_t gport_type, 
    bcm_cosq_gport_info_t *gport_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(gport_info) BCM_API_XLATE_PORT_A2P(unit,&gport_info->in_gport);
		BCM_API_XLATE_PORT_COND(gport_info) BCM_API_XLATE_PORT_A2P(unit,&gport_info->out_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_handle_get_dispatch[dtype](unit, gport_type, gport_info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(gport_info) BCM_API_XLATE_PORT_P2A(unit,&gport_info->in_gport);
		BCM_API_XLATE_PORT_COND(gport_info) BCM_API_XLATE_PORT_P2A(unit,&gport_info->out_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_handle_get", 3, 2, unit, gport_type, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_mapping_get( \
    int unit, bcm_port_t ing_port, bcm_cos_t int_pri, uint32 flags, bcm_gport_t *gport, bcm_cos_queue_t *cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_mapping_get,
static int (*_cosq_gport_mapping_get_dispatch[])(
    int unit, 
    bcm_port_t ing_port, 
    bcm_cos_t int_pri, 
    uint32 flags, 
    bcm_gport_t *gport, 
    bcm_cos_queue_t *cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_mapping_get(
    int unit, 
    bcm_port_t ing_port, 
    bcm_cos_t int_pri, 
    uint32 flags, 
    bcm_gport_t *gport, 
    bcm_cos_queue_t *cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&ing_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_mapping_get_dispatch[dtype](unit, ing_port, int_pri, flags, gport, cosq);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_mapping_get", 6, 3, unit, ing_port, int_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_mapping_set( \
    int unit, bcm_port_t ing_port, bcm_cos_t int_pri, uint32 flags, bcm_gport_t gport, bcm_cos_queue_t cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_mapping_set,
static int (*_cosq_gport_mapping_set_dispatch[])(
    int unit, 
    bcm_port_t ing_port, 
    bcm_cos_t int_pri, 
    uint32 flags, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_mapping_set(
    int unit, 
    bcm_port_t ing_port, 
    bcm_cos_t int_pri, 
    uint32 flags, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&ing_port);
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_mapping_set_dispatch[dtype](unit, ing_port, int_pri, flags, gport, cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_mapping_set", 6, 3, unit, ing_port, int_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_multipath_add( \
    int unit, bcm_gport_t multipath_gport, bcm_gport_t member_gport, bcm_cos_queue_t member_gport_cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_multipath_add,
static int (*_cosq_gport_multipath_add_dispatch[])(
    int unit, 
    bcm_gport_t multipath_gport, 
    bcm_gport_t member_gport, 
    bcm_cos_queue_t member_gport_cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_multipath_add(
    int unit, 
    bcm_gport_t multipath_gport, 
    bcm_gport_t member_gport, 
    bcm_cos_queue_t member_gport_cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&multipath_gport);
		BCM_API_XLATE_PORT_A2P(unit,&member_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_multipath_add_dispatch[dtype](unit, multipath_gport, member_gport, member_gport_cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_multipath_add", 4, 3, unit, multipath_gport, member_gport, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_multipath_delete( \
    int unit, bcm_gport_t multipath_gport, bcm_gport_t member_gport, bcm_cos_queue_t member_gport_cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_multipath_delete,
static int (*_cosq_gport_multipath_delete_dispatch[])(
    int unit, 
    bcm_gport_t multipath_gport, 
    bcm_gport_t member_gport, 
    bcm_cos_queue_t member_gport_cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_multipath_delete(
    int unit, 
    bcm_gport_t multipath_gport, 
    bcm_gport_t member_gport, 
    bcm_cos_queue_t member_gport_cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&multipath_gport);
		BCM_API_XLATE_PORT_A2P(unit,&member_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_multipath_delete_dispatch[dtype](unit, multipath_gport, member_gport, member_gport_cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_multipath_delete", 4, 3, unit, multipath_gport, member_gport, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_multipath_get( \
    int unit, bcm_gport_t multipath_gport, int member_gport_max, bcm_gport_t *member_gport_array, bcm_cos_queue_t *member_gport_cosq_array, int *member_gport_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_multipath_get,
static int (*_cosq_gport_multipath_get_dispatch[])(
    int unit, 
    bcm_gport_t multipath_gport, 
    int member_gport_max, 
    bcm_gport_t *member_gport_array, 
    bcm_cos_queue_t *member_gport_cosq_array, 
    int *member_gport_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_multipath_get(
    int unit, 
    bcm_gport_t multipath_gport, 
    int member_gport_max, 
    bcm_gport_t *member_gport_array, 
    bcm_cos_queue_t *member_gport_cosq_array, 
    int *member_gport_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_A2P(unit,&multipath_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_multipath_get_dispatch[dtype](unit, multipath_gport, member_gport_max, member_gport_array, member_gport_cosq_array, member_gport_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(member_gport_max,idx)
				BCM_API_XLATE_PORT_COND(member_gport_array) BCM_API_XLATE_PORT_P2A(unit,&(member_gport_array)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_multipath_get", 6, 3, unit, multipath_gport, member_gport_max, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_parent_get( \
    int unit, bcm_gport_t child_port, bcm_cos_queue_t cos, bcm_gport_t *parent_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_parent_get,
static int (*_cosq_gport_parent_get_dispatch[])(
    int unit, 
    bcm_gport_t child_port, 
    bcm_cos_queue_t cos, 
    bcm_gport_t *parent_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_parent_get(
    int unit, 
    bcm_gport_t child_port, 
    bcm_cos_queue_t cos, 
    bcm_gport_t *parent_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&child_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_parent_get_dispatch[dtype](unit, child_port, cos, parent_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,parent_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_parent_get", 4, 3, unit, child_port, cos, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_pon_link_sla_get( \
    int unit, bcm_gport_t gport, bcm_cos_pon_link_sla_t *link_sla);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_pon_link_sla_get,
static int (*_cosq_gport_pon_link_sla_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_pon_link_sla_t *link_sla) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_pon_link_sla_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_pon_link_sla_t *link_sla)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_pon_link_sla_get_dispatch[dtype](unit, gport, link_sla);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_pon_link_sla_get", 3, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_pon_link_sla_set( \
    int unit, bcm_gport_t gport, bcm_cos_pon_link_sla_t *link_sla);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_pon_link_sla_set,
static int (*_cosq_gport_pon_link_sla_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_pon_link_sla_t *link_sla) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_pon_link_sla_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_pon_link_sla_t *link_sla)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_pon_link_sla_set_dispatch[dtype](unit, gport, link_sla);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_pon_link_sla_set", 3, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_queue_attach( \
    int unit, uint32 flags, bcm_gport_t ingress_queue, bcm_cos_t ingress_int_pri, bcm_gport_t egress_queue, bcm_cos_t egress_int_pri, int *attach_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_queue_attach,
static int (*_cosq_gport_queue_attach_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_gport_t ingress_queue, 
    bcm_cos_t ingress_int_pri, 
    bcm_gport_t egress_queue, 
    bcm_cos_t egress_int_pri, 
    int *attach_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_queue_attach(
    int unit, 
    uint32 flags, 
    bcm_gport_t ingress_queue, 
    bcm_cos_t ingress_int_pri, 
    bcm_gport_t egress_queue, 
    bcm_cos_t egress_int_pri, 
    int *attach_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&ingress_queue);
		BCM_API_XLATE_PORT_A2P(unit,&egress_queue);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_queue_attach_dispatch[dtype](unit, flags, ingress_queue, ingress_int_pri, egress_queue, egress_int_pri, attach_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_queue_attach", 7, 3, unit, flags, ingress_queue, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_queue_attach_get( \
    int unit, bcm_gport_t ingress_queue, bcm_cos_t ingress_int_pri, bcm_gport_t *egress_queue, bcm_cos_t *egress_int_pri, int attach_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_queue_attach_get,
static int (*_cosq_gport_queue_attach_get_dispatch[])(
    int unit, 
    bcm_gport_t ingress_queue, 
    bcm_cos_t ingress_int_pri, 
    bcm_gport_t *egress_queue, 
    bcm_cos_t *egress_int_pri, 
    int attach_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_queue_attach_get(
    int unit, 
    bcm_gport_t ingress_queue, 
    bcm_cos_t ingress_int_pri, 
    bcm_gport_t *egress_queue, 
    bcm_cos_t *egress_int_pri, 
    int attach_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&ingress_queue);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_queue_attach_get_dispatch[dtype](unit, ingress_queue, ingress_int_pri, egress_queue, egress_int_pri, attach_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,egress_queue);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_queue_attach_get", 6, 3, unit, ingress_queue, ingress_int_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_queue_detach( \
    int unit, bcm_gport_t ingress_queue, bcm_cos_t ingress_int_pri, int attach_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_queue_detach,
static int (*_cosq_gport_queue_detach_dispatch[])(
    int unit, 
    bcm_gport_t ingress_queue, 
    bcm_cos_t ingress_int_pri, 
    int attach_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_queue_detach(
    int unit, 
    bcm_gport_t ingress_queue, 
    bcm_cos_t ingress_int_pri, 
    int attach_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&ingress_queue);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_queue_detach_dispatch[dtype](unit, ingress_queue, ingress_int_pri, attach_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_queue_detach", 4, 3, unit, ingress_queue, ingress_int_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_reattach( \
    int unit, bcm_gport_t sched_port, bcm_gport_t input_port, bcm_cos_queue_t cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_reattach,
static int (*_cosq_gport_reattach_dispatch[])(
    int unit, 
    bcm_gport_t sched_port, 
    bcm_gport_t input_port, 
    bcm_cos_queue_t cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_reattach(
    int unit, 
    bcm_gport_t sched_port, 
    bcm_gport_t input_port, 
    bcm_cos_queue_t cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&sched_port);
		BCM_API_XLATE_PORT_A2P(unit,&input_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_reattach_dispatch[dtype](unit, sched_port, input_port, cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_reattach", 4, 3, unit, sched_port, input_port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_report_threshold_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_report_threshold_t *threshold);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_report_threshold_get,
static int (*_cosq_gport_report_threshold_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_report_threshold_t *threshold) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_report_threshold_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_report_threshold_t *threshold)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_report_threshold_get_dispatch[dtype](unit, gport, cosq, threshold);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_report_threshold_get", 4, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_report_threshold_set( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_report_threshold_t *threshold);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_report_threshold_set,
static int (*_cosq_gport_report_threshold_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_report_threshold_t *threshold) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_report_threshold_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_report_threshold_t *threshold)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_report_threshold_set_dispatch[dtype](unit, gport, cosq, threshold);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_report_threshold_set", 4, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_sched_config_get( \
    int unit, bcm_gport_t gport, int sched_mode, int int_pri, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_sched_config_get,
static int (*_cosq_gport_sched_config_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    int sched_mode, 
    int int_pri, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_sched_config_get(
    int unit, 
    bcm_gport_t gport, 
    int sched_mode, 
    int int_pri, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_sched_config_get_dispatch[dtype](unit, gport, sched_mode, int_pri, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_sched_config_get", 5, 3, unit, gport, sched_mode, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_sched_config_set( \
    int unit, bcm_gport_t gport, int sched_mode, int int_pri, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_sched_config_set,
static int (*_cosq_gport_sched_config_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    int sched_mode, 
    int int_pri, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_sched_config_set(
    int unit, 
    bcm_gport_t gport, 
    int sched_mode, 
    int int_pri, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_sched_config_set_dispatch[dtype](unit, gport, sched_mode, int_pri, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_sched_config_set", 5, 3, unit, gport, sched_mode, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_sched_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, int *mode, int *weight);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_sched_get,
static int (*_cosq_gport_sched_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    int *mode, 
    int *weight) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_sched_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    int *mode, 
    int *weight)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_sched_get_dispatch[dtype](unit, gport, cosq, mode, weight);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_sched_get", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_sched_set( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, int mode, int weight);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_sched_set,
static int (*_cosq_gport_sched_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    int mode, 
    int weight) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_sched_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    int mode, 
    int weight)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_sched_set_dispatch[dtype](unit, gport, cosq, mode, weight);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_sched_set", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_size_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, uint32 *bytes_min, uint32 *bytes_max);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_size_get,
static int (*_cosq_gport_size_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 *bytes_min, 
    uint32 *bytes_max) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_size_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 *bytes_min, 
    uint32 *bytes_max)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_size_get_dispatch[dtype](unit, gport, cosq, bytes_min, bytes_max);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_size_get", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_size_set( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, uint32 bytes_min, uint32 bytes_max);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_size_set,
static int (*_cosq_gport_size_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 bytes_min, 
    uint32 bytes_max) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_size_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 bytes_min, 
    uint32 bytes_max)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_size_set_dispatch[dtype](unit, gport, cosq, bytes_min, bytes_max);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_size_set", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_stat_config_get( \
    int unit, bcm_gport_t gport, bcm_gport_t lgl_gport, bcm_cos_queue_t cosq, uint32 flags, bcm_cosq_gport_stat_profile_t *profile);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_stat_config_get,
static int (*_cosq_gport_stat_config_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t lgl_gport, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_gport_stat_profile_t *profile) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_stat_config_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t lgl_gport, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_gport_stat_profile_t *profile)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		BCM_API_XLATE_PORT_A2P(unit,&lgl_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_stat_config_get_dispatch[dtype](unit, gport, lgl_gport, cosq, flags, profile);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_stat_config_get", 6, 3, unit, gport, lgl_gport, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_stat_config_set( \
    int unit, bcm_gport_t gport, bcm_gport_t lgl_gport, bcm_cos_queue_t cosq, uint32 flags, bcm_cosq_gport_stat_profile_t profile);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_stat_config_set,
static int (*_cosq_gport_stat_config_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t lgl_gport, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_gport_stat_profile_t profile) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_stat_config_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t lgl_gport, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_gport_stat_profile_t profile)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		BCM_API_XLATE_PORT_A2P(unit,&lgl_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_stat_config_set_dispatch[dtype](unit, gport, lgl_gport, cosq, flags, profile);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_stat_config_set", 6, 3, unit, gport, lgl_gport, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_stat_enable_get( \
    int unit, bcm_gport_t gport, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_stat_enable_get,
static int (*_cosq_gport_stat_enable_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_stat_enable_get(
    int unit, 
    bcm_gport_t gport, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_stat_enable_get_dispatch[dtype](unit, gport, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_stat_enable_get", 3, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_stat_enable_set( \
    int unit, bcm_gport_t gport, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_stat_enable_set,
static int (*_cosq_gport_stat_enable_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_stat_enable_set(
    int unit, 
    bcm_gport_t gport, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_stat_enable_set_dispatch[dtype](unit, gport, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_stat_enable_set", 3, 3, unit, gport, enable, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_stat_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_gport_stats_t stat, uint64 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_stat_get,
static int (*_cosq_gport_stat_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_gport_stats_t stat, 
    uint64 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_stat_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_gport_stats_t stat, 
    uint64 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_stat_get_dispatch[dtype](unit, gport, cosq, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_stat_get", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_stat_set( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_gport_stats_t stat, uint64 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_stat_set,
static int (*_cosq_gport_stat_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_gport_stats_t stat, 
    uint64 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_stat_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_gport_stats_t stat, 
    uint64 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_stat_set_dispatch[dtype](unit, gport, cosq, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_stat_set", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_stat_sync_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_gport_stats_t stat, uint64 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_stat_sync_get,
static int (*_cosq_gport_stat_sync_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_gport_stats_t stat, 
    uint64 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_stat_sync_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_gport_stats_t stat, 
    uint64 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_stat_sync_get_dispatch[dtype](unit, gport, cosq, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_stat_sync_get", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_statistic_get( \
    int unit, bcm_gport_t gport, bcm_gport_t lgl_gport, bcm_cos_queue_t cosq, uint32 flags, bcm_cosq_gport_stats_t stat, uint64 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_statistic_get,
static int (*_cosq_gport_statistic_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t lgl_gport, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_gport_stats_t stat, 
    uint64 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_statistic_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t lgl_gport, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_gport_stats_t stat, 
    uint64 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		BCM_API_XLATE_PORT_A2P(unit,&lgl_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_statistic_get_dispatch[dtype](unit, gport, lgl_gport, cosq, flags, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_statistic_get", 7, 3, unit, gport, lgl_gport, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_statistic_multi_get( \
    int unit, bcm_gport_t gport, bcm_gport_t lgl_gport, bcm_cos_queue_t cosq, int stat_count, bcm_cosq_gport_stats_t *stats_array, int value_count, uint64 *value_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_statistic_multi_get,
static int (*_cosq_gport_statistic_multi_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t lgl_gport, 
    bcm_cos_queue_t cosq, 
    int stat_count, 
    bcm_cosq_gport_stats_t *stats_array, 
    int value_count, 
    uint64 *value_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_statistic_multi_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t lgl_gport, 
    bcm_cos_queue_t cosq, 
    int stat_count, 
    bcm_cosq_gport_stats_t *stats_array, 
    int value_count, 
    uint64 *value_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		BCM_API_XLATE_PORT_A2P(unit,&lgl_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_statistic_multi_get_dispatch[dtype](unit, gport, lgl_gport, cosq, stat_count, stats_array, value_count, value_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_statistic_multi_get", 8, 3, unit, gport, lgl_gport, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_statistic_multi_set( \
    int unit, bcm_gport_t gport, bcm_gport_t lgl_gport, bcm_cos_queue_t cosq, int stat_count, bcm_cosq_gport_stats_t *stats_array, uint64 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_statistic_multi_set,
static int (*_cosq_gport_statistic_multi_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t lgl_gport, 
    bcm_cos_queue_t cosq, 
    int stat_count, 
    bcm_cosq_gport_stats_t *stats_array, 
    uint64 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_statistic_multi_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t lgl_gport, 
    bcm_cos_queue_t cosq, 
    int stat_count, 
    bcm_cosq_gport_stats_t *stats_array, 
    uint64 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		BCM_API_XLATE_PORT_A2P(unit,&lgl_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_statistic_multi_set_dispatch[dtype](unit, gport, lgl_gport, cosq, stat_count, stats_array, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_statistic_multi_set", 7, 3, unit, gport, lgl_gport, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_statistic_set( \
    int unit, bcm_gport_t gport, bcm_gport_t lgl_gport, bcm_cos_queue_t cosq, uint32 flags, bcm_cosq_gport_stats_t stat, uint64 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_statistic_set,
static int (*_cosq_gport_statistic_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t lgl_gport, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_gport_stats_t stat, 
    uint64 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_statistic_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t lgl_gport, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_gport_stats_t stat, 
    uint64 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		BCM_API_XLATE_PORT_A2P(unit,&lgl_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_statistic_set_dispatch[dtype](unit, gport, lgl_gport, cosq, flags, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_statistic_set", 7, 3, unit, gport, lgl_gport, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_threshold_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t *threshold);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_threshold_get,
static int (*_cosq_gport_threshold_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_threshold_t *threshold) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_threshold_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_threshold_t *threshold)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_threshold_get_dispatch[dtype](unit, gport, cosq, threshold);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_threshold_get", 4, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_threshold_set( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t *threshold);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_threshold_set,
static int (*_cosq_gport_threshold_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_threshold_t *threshold) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_threshold_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_threshold_t *threshold)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_threshold_set_dispatch[dtype](unit, gport, cosq, threshold);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_threshold_set", 4, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_traverse( \
    int unit, bcm_cosq_gport_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_traverse,
static int (*_cosq_gport_traverse_dispatch[])(
    int unit, 
    bcm_cosq_gport_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_traverse(
    int unit, 
    bcm_cosq_gport_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_vsq_add( \
    int unit, bcm_gport_t vsq, bcm_gport_t queue, bcm_cos_queue_t cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_vsq_add,
static int (*_cosq_gport_vsq_add_dispatch[])(
    int unit, 
    bcm_gport_t vsq, 
    bcm_gport_t queue, 
    bcm_cos_queue_t cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_vsq_add(
    int unit, 
    bcm_gport_t vsq, 
    bcm_gport_t queue, 
    bcm_cos_queue_t cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&vsq);
		BCM_API_XLATE_PORT_A2P(unit,&queue);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_vsq_add_dispatch[dtype](unit, vsq, queue, cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_vsq_add", 4, 3, unit, vsq, queue, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_vsq_create( \
    int unit, bcm_cosq_vsq_info_t *vsq_info, bcm_gport_t *vsq_gport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_vsq_create,
static int (*_cosq_gport_vsq_create_dispatch[])(
    int unit, 
    bcm_cosq_vsq_info_t *vsq_info, 
    bcm_gport_t *vsq_gport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_vsq_create(
    int unit, 
    bcm_cosq_vsq_info_t *vsq_info, 
    bcm_gport_t *vsq_gport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(vsq_info_src_port);
		BCM_API_XLATE_PORT_COND(vsq_info) BCM_API_XLATE_PORT_SAVE(vsq_info_src_port,vsq_info->src_port);
		BCM_API_XLATE_PORT_COND(vsq_info) BCM_API_XLATE_PORT_A2P(unit,&vsq_info->src_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_vsq_create_dispatch[dtype](unit, vsq_info, vsq_gport);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(vsq_info) BCM_API_XLATE_PORT_RESTORE(vsq_info->src_port,vsq_info_src_port);
		BCM_API_XLATE_PORT_P2A(unit,vsq_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_vsq_create", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_vsq_delete( \
    int unit, bcm_gport_t vsq, bcm_gport_t queue, bcm_cos_queue_t cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_vsq_delete,
static int (*_cosq_gport_vsq_delete_dispatch[])(
    int unit, 
    bcm_gport_t vsq, 
    bcm_gport_t queue, 
    bcm_cos_queue_t cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_vsq_delete(
    int unit, 
    bcm_gport_t vsq, 
    bcm_gport_t queue, 
    bcm_cos_queue_t cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&vsq);
		BCM_API_XLATE_PORT_A2P(unit,&queue);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_vsq_delete_dispatch[dtype](unit, vsq, queue, cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_vsq_delete", 4, 3, unit, vsq, queue, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_vsq_delete_all( \
    int unit, bcm_gport_t vsq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_vsq_delete_all,
static int (*_cosq_gport_vsq_delete_all_dispatch[])(
    int unit, 
    bcm_gport_t vsq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_vsq_delete_all(
    int unit, 
    bcm_gport_t vsq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&vsq);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_vsq_delete_all_dispatch[dtype](unit, vsq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_vsq_delete_all", 2, 2, unit, vsq, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_vsq_destroy( \
    int unit, bcm_gport_t vsq_gport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_vsq_destroy,
static int (*_cosq_gport_vsq_destroy_dispatch[])(
    int unit, 
    bcm_gport_t vsq_gport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_vsq_destroy(
    int unit, 
    bcm_gport_t vsq_gport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&vsq_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_vsq_destroy_dispatch[dtype](unit, vsq_gport);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_vsq_destroy", 2, 2, unit, vsq_gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_gport_vsq_get( \
    int unit, bcm_gport_t vsq, int queue_max, bcm_gport_t *queue_array, bcm_cos_queue_t *cosq_array, int *queue_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_gport_vsq_get,
static int (*_cosq_gport_vsq_get_dispatch[])(
    int unit, 
    bcm_gport_t vsq, 
    int queue_max, 
    bcm_gport_t *queue_array, 
    bcm_cos_queue_t *cosq_array, 
    int *queue_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_gport_vsq_get(
    int unit, 
    bcm_gport_t vsq, 
    int queue_max, 
    bcm_gport_t *queue_array, 
    bcm_cos_queue_t *cosq_array, 
    int *queue_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&vsq);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_gport_vsq_get_dispatch[dtype](unit, vsq, queue_max, queue_array, cosq_array, queue_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,queue_array);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_gport_vsq_get", 6, 3, unit, vsq, queue_max, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_init,
static int (*_cosq_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_mapping_get( \
    int unit, bcm_cos_t priority, bcm_cos_queue_t *cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_mapping_get,
static int (*_cosq_mapping_get_dispatch[])(
    int unit, 
    bcm_cos_t priority, 
    bcm_cos_queue_t *cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_mapping_get(
    int unit, 
    bcm_cos_t priority, 
    bcm_cos_queue_t *cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_mapping_get_dispatch[dtype](unit, priority, cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_mapping_get", 3, 2, unit, priority, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_mapping_set( \
    int unit, bcm_cos_t priority, bcm_cos_queue_t cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_mapping_set,
static int (*_cosq_mapping_set_dispatch[])(
    int unit, 
    bcm_cos_t priority, 
    bcm_cos_queue_t cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_mapping_set(
    int unit, 
    bcm_cos_t priority, 
    bcm_cos_queue_t cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_mapping_set_dispatch[dtype](unit, priority, cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_mapping_set", 3, 3, unit, priority, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_pfc_config_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, uint32 flags, bcm_cosq_pfc_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_pfc_config_get,
static int (*_cosq_pfc_config_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_pfc_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_pfc_config_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_pfc_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_pfc_config_get_dispatch[dtype](unit, gport, cosq, flags, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_pfc_config_get", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_pfc_config_set( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, uint32 flags, bcm_cosq_pfc_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_pfc_config_set,
static int (*_cosq_pfc_config_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_pfc_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_pfc_config_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_pfc_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_pfc_config_set_dispatch[dtype](unit, gport, cosq, flags, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_pfc_config_set", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_port_bandwidth_get( \
    int unit, bcm_port_t port, bcm_cos_queue_t cosq, uint32 *kbits_sec_min, uint32 *kbits_sec_max, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_port_bandwidth_get,
static int (*_cosq_port_bandwidth_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_cos_queue_t cosq, 
    uint32 *kbits_sec_min, 
    uint32 *kbits_sec_max, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_port_bandwidth_get(
    int unit, 
    bcm_port_t port, 
    bcm_cos_queue_t cosq, 
    uint32 *kbits_sec_min, 
    uint32 *kbits_sec_max, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_port_bandwidth_get_dispatch[dtype](unit, port, cosq, kbits_sec_min, kbits_sec_max, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_port_bandwidth_get", 6, 3, unit, port, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_port_bandwidth_set( \
    int unit, bcm_port_t port, bcm_cos_queue_t cosq, uint32 kbits_sec_min, uint32 kbits_sec_max, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_port_bandwidth_set,
static int (*_cosq_port_bandwidth_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_cos_queue_t cosq, 
    uint32 kbits_sec_min, 
    uint32 kbits_sec_max, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_port_bandwidth_set(
    int unit, 
    bcm_port_t port, 
    bcm_cos_queue_t cosq, 
    uint32 kbits_sec_min, 
    uint32 kbits_sec_max, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_port_bandwidth_set_dispatch[dtype](unit, port, cosq, kbits_sec_min, kbits_sec_max, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_port_bandwidth_set", 6, 3, unit, port, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_port_mapping_get( \
    int unit, bcm_port_t port, bcm_cos_t priority, bcm_cos_queue_t *cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_port_mapping_get,
static int (*_cosq_port_mapping_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_cos_t priority, 
    bcm_cos_queue_t *cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_port_mapping_get(
    int unit, 
    bcm_port_t port, 
    bcm_cos_t priority, 
    bcm_cos_queue_t *cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_port_mapping_get_dispatch[dtype](unit, port, priority, cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_port_mapping_get", 4, 3, unit, port, priority, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_port_mapping_set( \
    int unit, bcm_port_t port, bcm_cos_t priority, bcm_cos_queue_t cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_port_mapping_set,
static int (*_cosq_port_mapping_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_cos_t priority, 
    bcm_cos_queue_t cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_port_mapping_set(
    int unit, 
    bcm_port_t port, 
    bcm_cos_t priority, 
    bcm_cos_queue_t cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_port_mapping_set_dispatch[dtype](unit, port, priority, cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_port_mapping_set", 4, 3, unit, port, priority, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_port_sched_get( \
    int unit, bcm_pbmp_t pbm, int *mode, int weights[BCM_COS_COUNT], int *delay);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_port_sched_get,
static int (*_cosq_port_sched_get_dispatch[])(
    int unit, 
    bcm_pbmp_t pbm, 
    int *mode, 
    int weights[BCM_COS_COUNT], 
    int *delay) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_port_sched_get(
    int unit, 
    bcm_pbmp_t pbm, 
    int *mode, 
    int weights[BCM_COS_COUNT], 
    int *delay)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbm);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbm,pbm);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbm);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_port_sched_get_dispatch[dtype](unit, pbm, mode, weights, delay);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbm,t_pbm);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_port_sched_get", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_port_sched_set( \
    int unit, bcm_pbmp_t pbm, int mode, const int weights[BCM_COS_COUNT], int delay);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_port_sched_set,
static int (*_cosq_port_sched_set_dispatch[])(
    int unit, 
    bcm_pbmp_t pbm, 
    int mode, 
    const int weights[BCM_COS_COUNT], 
    int delay) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_port_sched_set(
    int unit, 
    bcm_pbmp_t pbm, 
    int mode, 
    const int weights[BCM_COS_COUNT], 
    int delay)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbm);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbm,pbm);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbm);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_port_sched_set_dispatch[dtype](unit, pbm, mode, weights, delay);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbm,t_pbm);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_port_sched_set", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_priority_get( \
    int unit, int start_queue, int end_queue, int *pri_profile_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_priority_get,
static int (*_cosq_priority_get_dispatch[])(
    int unit, 
    int start_queue, 
    int end_queue, 
    int *pri_profile_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_priority_get(
    int unit, 
    int start_queue, 
    int end_queue, 
    int *pri_profile_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_priority_get_dispatch[dtype](unit, start_queue, end_queue, pri_profile_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_priority_get", 4, 3, unit, start_queue, end_queue, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_priority_profile_get( \
    int unit, int pri_profile_id, int *count, bcm_cosq_gport_priority_profile_t *pri_profile);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_priority_profile_get,
static int (*_cosq_priority_profile_get_dispatch[])(
    int unit, 
    int pri_profile_id, 
    int *count, 
    bcm_cosq_gport_priority_profile_t *pri_profile) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_priority_profile_get(
    int unit, 
    int pri_profile_id, 
    int *count, 
    bcm_cosq_gport_priority_profile_t *pri_profile)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_priority_profile_get_dispatch[dtype](unit, pri_profile_id, count, pri_profile);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_priority_profile_get", 4, 2, unit, pri_profile_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_priority_profile_set( \
    int unit, int pri_profile_id, int count, bcm_cosq_gport_priority_profile_t *pri_profile);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_priority_profile_set,
static int (*_cosq_priority_profile_set_dispatch[])(
    int unit, 
    int pri_profile_id, 
    int count, 
    bcm_cosq_gport_priority_profile_t *pri_profile) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_priority_profile_set(
    int unit, 
    int pri_profile_id, 
    int count, 
    bcm_cosq_gport_priority_profile_t *pri_profile)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_priority_profile_set_dispatch[dtype](unit, pri_profile_id, count, pri_profile);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_priority_profile_set", 4, 3, unit, pri_profile_id, count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_priority_set( \
    int unit, int start_queue, int end_queue, int pri_profile_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_priority_set,
static int (*_cosq_priority_set_dispatch[])(
    int unit, 
    int start_queue, 
    int end_queue, 
    int pri_profile_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_priority_set(
    int unit, 
    int start_queue, 
    int end_queue, 
    int pri_profile_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_priority_set_dispatch[dtype](unit, start_queue, end_queue, pri_profile_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_priority_set", 4, 3, unit, start_queue, end_queue, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_profile_mapping_get( \
    int unit, bcm_gport_t gport_to_map, bcm_cos_queue_t cosq, uint32 flags, bcm_switch_profile_mapping_t *profile_mapping);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_profile_mapping_get,
static int (*_cosq_profile_mapping_get_dispatch[])(
    int unit, 
    bcm_gport_t gport_to_map, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_switch_profile_mapping_t *profile_mapping) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_profile_mapping_get(
    int unit, 
    bcm_gport_t gport_to_map, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_switch_profile_mapping_t *profile_mapping)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport_to_map);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_profile_mapping_get_dispatch[dtype](unit, gport_to_map, cosq, flags, profile_mapping);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(profile_mapping) BCM_API_XLATE_PORT_P2A(unit,&profile_mapping->mapped_profile);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_profile_mapping_get", 5, 3, unit, gport_to_map, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_profile_mapping_set( \
    int unit, bcm_gport_t gport_to_map, bcm_cos_queue_t cosq, uint32 flags, bcm_switch_profile_mapping_t *profile_mapping);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_profile_mapping_set,
static int (*_cosq_profile_mapping_set_dispatch[])(
    int unit, 
    bcm_gport_t gport_to_map, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_switch_profile_mapping_t *profile_mapping) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_profile_mapping_set(
    int unit, 
    bcm_gport_t gport_to_map, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_switch_profile_mapping_t *profile_mapping)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(profile_mapping_mapped_profile);
		BCM_API_XLATE_PORT_A2P(unit,&gport_to_map);
		BCM_API_XLATE_PORT_COND(profile_mapping) BCM_API_XLATE_PORT_SAVE(profile_mapping_mapped_profile,profile_mapping->mapped_profile);
		BCM_API_XLATE_PORT_COND(profile_mapping) BCM_API_XLATE_PORT_A2P(unit,&profile_mapping->mapped_profile);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_profile_mapping_set_dispatch[dtype](unit, gport_to_map, cosq, flags, profile_mapping);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(profile_mapping) BCM_API_XLATE_PORT_RESTORE(profile_mapping->mapped_profile,profile_mapping_mapped_profile);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_profile_mapping_set", 5, 3, unit, gport_to_map, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_qcn_config_get( \
    int unit, bcm_gport_t port, bcm_cos_queue_t cosq, uint32 flags, bcm_cosq_qcn_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_qcn_config_get,
static int (*_cosq_qcn_config_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_qcn_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_qcn_config_get(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_qcn_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_qcn_config_get_dispatch[dtype](unit, port, cosq, flags, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_qcn_config_get", 5, 3, unit, port, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_qcn_config_set( \
    int unit, bcm_gport_t port, bcm_cos_queue_t cosq, uint32 flags, bcm_cosq_qcn_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_qcn_config_set,
static int (*_cosq_qcn_config_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_qcn_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_qcn_config_set(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_cosq_qcn_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_qcn_config_set_dispatch[dtype](unit, port, cosq, flags, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_qcn_config_set", 5, 3, unit, port, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_sched_get( \
    int unit, int *mode, int weights[BCM_COS_COUNT], int *delay);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_sched_get,
static int (*_cosq_sched_get_dispatch[])(
    int unit, 
    int *mode, 
    int weights[BCM_COS_COUNT], 
    int *delay) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_sched_get(
    int unit, 
    int *mode, 
    int weights[BCM_COS_COUNT], 
    int *delay)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_sched_get_dispatch[dtype](unit, mode, weights, delay);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_sched_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_sched_set( \
    int unit, int mode, const int weights[BCM_COS_COUNT], int delay);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_sched_set,
static int (*_cosq_sched_set_dispatch[])(
    int unit, 
    int mode, 
    const int weights[BCM_COS_COUNT], 
    int delay) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_sched_set(
    int unit, 
    int mode, 
    const int weights[BCM_COS_COUNT], 
    int delay)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_sched_set_dispatch[dtype](unit, mode, weights, delay);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_sched_set", 4, 2, unit, mode, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_sched_weight_max_get( \
    int unit, int mode, int *weight_max);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_sched_weight_max_get,
static int (*_cosq_sched_weight_max_get_dispatch[])(
    int unit, 
    int mode, 
    int *weight_max) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_sched_weight_max_get(
    int unit, 
    int mode, 
    int *weight_max)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_sched_weight_max_get_dispatch[dtype](unit, mode, weight_max);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_sched_weight_max_get", 3, 2, unit, mode, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_service_pool_get( \
    int unit, bcm_service_pool_id_t id, bcm_cosq_service_pool_t *cosq_service_pool);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_service_pool_get,
static int (*_cosq_service_pool_get_dispatch[])(
    int unit, 
    bcm_service_pool_id_t id, 
    bcm_cosq_service_pool_t *cosq_service_pool) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_service_pool_get(
    int unit, 
    bcm_service_pool_id_t id, 
    bcm_cosq_service_pool_t *cosq_service_pool)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_service_pool_get_dispatch[dtype](unit, id, cosq_service_pool);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_service_pool_get", 3, 2, unit, id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_service_pool_set( \
    int unit, bcm_service_pool_id_t id, bcm_cosq_service_pool_t cosq_service_pool);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_service_pool_set,
static int (*_cosq_service_pool_set_dispatch[])(
    int unit, 
    bcm_service_pool_id_t id, 
    bcm_cosq_service_pool_t cosq_service_pool) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_service_pool_set(
    int unit, 
    bcm_service_pool_id_t id, 
    bcm_cosq_service_pool_t cosq_service_pool)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_service_pool_set_dispatch[dtype](unit, id, cosq_service_pool);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_service_pool_set", 3, 2, unit, id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_stat_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_stat_t stat, uint64 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_stat_get,
static int (*_cosq_stat_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_stat_t stat, 
    uint64 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_stat_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_stat_t stat, 
    uint64 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_stat_get_dispatch[dtype](unit, gport, cosq, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_stat_get", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_stat_get32( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_stat_t stat, uint32 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_stat_get32,
static int (*_cosq_stat_get32_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_stat_t stat, 
    uint32 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_stat_get32(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_stat_t stat, 
    uint32 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_stat_get32_dispatch[dtype](unit, gport, cosq, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_stat_get32", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_stat_set( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_stat_t stat, uint64 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_stat_set,
static int (*_cosq_stat_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_stat_t stat, 
    uint64 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_stat_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_stat_t stat, 
    uint64 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_stat_set_dispatch[dtype](unit, gport, cosq, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_stat_set", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_stat_set32( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_stat_t stat, uint32 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_stat_set32,
static int (*_cosq_stat_set32_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_stat_t stat, 
    uint32 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_stat_set32(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_stat_t stat, 
    uint32 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_stat_set32_dispatch[dtype](unit, gport, cosq, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_stat_set32", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_stat_sync_get( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_stat_t stat, uint64 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_stat_sync_get,
static int (*_cosq_stat_sync_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_stat_t stat, 
    uint64 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_stat_sync_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_stat_t stat, 
    uint64 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_stat_sync_get_dispatch[dtype](unit, gport, cosq, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_stat_sync_get", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_stat_sync_get32( \
    int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_stat_t stat, uint32 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_stat_sync_get32,
static int (*_cosq_stat_sync_get32_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_stat_t stat, 
    uint32 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_stat_sync_get32(
    int unit, 
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_stat_t stat, 
    uint32 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_stat_sync_get32_dispatch[dtype](unit, gport, cosq, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_stat_sync_get32", 5, 3, unit, gport, cosq, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_subscriber_map_add( \
    int unit, bcm_cosq_subscriber_map_t *map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_subscriber_map_add,
static int (*_cosq_subscriber_map_add_dispatch[])(
    int unit, 
    bcm_cosq_subscriber_map_t *map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_subscriber_map_add(
    int unit, 
    bcm_cosq_subscriber_map_t *map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(map_port);
		BCM_API_XLATE_PORT_DECL(map_queue_id);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_SAVE(map_port,map->port);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_A2P(unit,&map->port);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_SAVE(map_queue_id,map->queue_id);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_A2P(unit,&map->queue_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_subscriber_map_add_dispatch[dtype](unit, map);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_RESTORE(map->port,map_port);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_RESTORE(map->queue_id,map_queue_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_subscriber_map_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_subscriber_map_delete( \
    int unit, bcm_cosq_subscriber_map_t *map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_subscriber_map_delete,
static int (*_cosq_subscriber_map_delete_dispatch[])(
    int unit, 
    bcm_cosq_subscriber_map_t *map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_subscriber_map_delete(
    int unit, 
    bcm_cosq_subscriber_map_t *map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(map_port);
		BCM_API_XLATE_PORT_DECL(map_queue_id);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_SAVE(map_port,map->port);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_A2P(unit,&map->port);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_SAVE(map_queue_id,map->queue_id);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_A2P(unit,&map->queue_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_subscriber_map_delete_dispatch[dtype](unit, map);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_RESTORE(map->port,map_port);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_RESTORE(map->queue_id,map_queue_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_subscriber_map_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_subscriber_map_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_subscriber_map_delete_all,
static int (*_cosq_subscriber_map_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_subscriber_map_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_subscriber_map_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_subscriber_map_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_subscriber_map_get( \
    int unit, bcm_cosq_subscriber_map_t *map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_subscriber_map_get,
static int (*_cosq_subscriber_map_get_dispatch[])(
    int unit, 
    bcm_cosq_subscriber_map_t *map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_subscriber_map_get(
    int unit, 
    bcm_cosq_subscriber_map_t *map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(map_port);
		BCM_API_XLATE_PORT_DECL(map_queue_id);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_SAVE(map_port,map->port);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_A2P(unit,&map->port);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_SAVE(map_queue_id,map->queue_id);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_A2P(unit,&map->queue_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_subscriber_map_get_dispatch[dtype](unit, map);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_RESTORE(map->port,map_port);
		BCM_API_XLATE_PORT_COND(map) BCM_API_XLATE_PORT_RESTORE(map->queue_id,map_queue_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_subscriber_map_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_cosq_subscriber_traverse( \
    int unit, bcm_cosq_subscriber_map_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_cosq_subscriber_traverse,
static int (*_cosq_subscriber_traverse_dispatch[])(
    int unit, 
    bcm_cosq_subscriber_map_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_cosq_subscriber_traverse(
    int unit, 
    bcm_cosq_subscriber_map_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _cosq_subscriber_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_cosq_subscriber_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_custom_port_get( \
    int unit, bcm_port_t port, int type, int max_len, uint32 *args, int *actual_len);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_custom_port_get,
static int (*_custom_port_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int type, 
    int max_len, 
    uint32 *args, 
    int *actual_len) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_custom_port_get(
    int unit, 
    bcm_port_t port, 
    int type, 
    int max_len, 
    uint32 *args, 
    int *actual_len)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _custom_port_get_dispatch[dtype](unit, port, type, max_len, args, actual_len);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_custom_port_get", 6, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_custom_port_set( \
    int unit, bcm_port_t port, int type, int len, uint32 *args);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_custom_port_set,
static int (*_custom_port_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int type, 
    int len, 
    uint32 *args) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_custom_port_set(
    int unit, 
    bcm_port_t port, 
    int type, 
    int len, 
    uint32 *args)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _custom_port_set_dispatch[dtype](unit, port, type, len, args);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_custom_port_set", 5, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_custom_register( \
    int unit, bcm_custom_cb_t func, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_custom_register,
static int (*_custom_register_dispatch[])(
    int unit, 
    bcm_custom_cb_t func, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_custom_register(
    int unit, 
    bcm_custom_cb_t func, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _custom_register_dispatch[dtype](unit, func, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_custom_register", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_custom_unregister( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_custom_unregister,
static int (*_custom_unregister_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_custom_unregister(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _custom_unregister_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_custom_unregister", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_bandwidth_get( \
    int unit, bcm_port_t port, bcm_eav_stream_class_t type, uint32 *bytes_sec, uint32 *bytes_burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_bandwidth_get,
static int (*_eav_bandwidth_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_eav_stream_class_t type, 
    uint32 *bytes_sec, 
    uint32 *bytes_burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_bandwidth_get(
    int unit, 
    bcm_port_t port, 
    bcm_eav_stream_class_t type, 
    uint32 *bytes_sec, 
    uint32 *bytes_burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_bandwidth_get_dispatch[dtype](unit, port, type, bytes_sec, bytes_burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_bandwidth_get", 5, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_bandwidth_set( \
    int unit, bcm_port_t port, bcm_eav_stream_class_t type, uint32 bytes_sec, uint32 bytes_burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_bandwidth_set,
static int (*_eav_bandwidth_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_eav_stream_class_t type, 
    uint32 bytes_sec, 
    uint32 bytes_burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_bandwidth_set(
    int unit, 
    bcm_port_t port, 
    bcm_eav_stream_class_t type, 
    uint32 bytes_sec, 
    uint32 bytes_burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_bandwidth_set_dispatch[dtype](unit, port, type, bytes_sec, bytes_burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_bandwidth_set", 5, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_control_get( \
    int unit, bcm_eav_control_t type, uint32 *arg, uint32 *arg2);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_control_get,
static int (*_eav_control_get_dispatch[])(
    int unit, 
    bcm_eav_control_t type, 
    uint32 *arg, 
    uint32 *arg2) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_control_get(
    int unit, 
    bcm_eav_control_t type, 
    uint32 *arg, 
    uint32 *arg2)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_control_get_dispatch[dtype](unit, type, arg, arg2);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_control_get", 4, 2, unit, type, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_control_set( \
    int unit, bcm_eav_control_t type, uint32 arg, uint32 arg2);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_control_set,
static int (*_eav_control_set_dispatch[])(
    int unit, 
    bcm_eav_control_t type, 
    uint32 arg, 
    uint32 arg2) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_control_set(
    int unit, 
    bcm_eav_control_t type, 
    uint32 arg, 
    uint32 arg2)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_control_set_dispatch[dtype](unit, type, arg, arg2);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_control_set", 4, 3, unit, type, arg, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_init,
static int (*_eav_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_link_status_get( \
    int unit, bcm_port_t port, int *link);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_link_status_get,
static int (*_eav_link_status_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *link) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_link_status_get(
    int unit, 
    bcm_port_t port, 
    int *link)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_link_status_get_dispatch[dtype](unit, port, link);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_link_status_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_link_status_set( \
    int unit, bcm_port_t port, int link);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_link_status_set,
static int (*_eav_link_status_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int link) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_link_status_set(
    int unit, 
    bcm_port_t port, 
    int link)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_link_status_set_dispatch[dtype](unit, port, link);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_link_status_set", 3, 3, unit, port, link, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_pcp_mapping_get( \
    int unit, bcm_eav_stream_class_t type, int *pcp, int *remapped_pcp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_pcp_mapping_get,
static int (*_eav_pcp_mapping_get_dispatch[])(
    int unit, 
    bcm_eav_stream_class_t type, 
    int *pcp, 
    int *remapped_pcp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_pcp_mapping_get(
    int unit, 
    bcm_eav_stream_class_t type, 
    int *pcp, 
    int *remapped_pcp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_pcp_mapping_get_dispatch[dtype](unit, type, pcp, remapped_pcp);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_pcp_mapping_get", 4, 2, unit, type, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_pcp_mapping_set( \
    int unit, bcm_eav_stream_class_t type, int pcp, int remapped_pcp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_pcp_mapping_set,
static int (*_eav_pcp_mapping_set_dispatch[])(
    int unit, 
    bcm_eav_stream_class_t type, 
    int pcp, 
    int remapped_pcp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_pcp_mapping_set(
    int unit, 
    bcm_eav_stream_class_t type, 
    int pcp, 
    int remapped_pcp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_pcp_mapping_set_dispatch[dtype](unit, type, pcp, remapped_pcp);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_pcp_mapping_set", 4, 3, unit, type, pcp, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_port_enable_get( \
    int unit, bcm_port_t port, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_port_enable_get,
static int (*_eav_port_enable_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_port_enable_get(
    int unit, 
    bcm_port_t port, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_port_enable_get_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_port_enable_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_port_enable_set( \
    int unit, bcm_port_t port, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_port_enable_set,
static int (*_eav_port_enable_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_port_enable_set(
    int unit, 
    bcm_port_t port, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_port_enable_set_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_port_enable_set", 3, 3, unit, port, enable, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_srp_mac_ethertype_get( \
    int unit, bcm_mac_t mac, bcm_port_ethertype_t *ethertype);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_srp_mac_ethertype_get,
static int (*_eav_srp_mac_ethertype_get_dispatch[])(
    int unit, 
    bcm_mac_t mac, 
    bcm_port_ethertype_t *ethertype) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_srp_mac_ethertype_get(
    int unit, 
    bcm_mac_t mac, 
    bcm_port_ethertype_t *ethertype)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_srp_mac_ethertype_get_dispatch[dtype](unit, mac, ethertype);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_srp_mac_ethertype_get", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_srp_mac_ethertype_set( \
    int unit, bcm_mac_t mac, bcm_port_ethertype_t ethertype);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_srp_mac_ethertype_set,
static int (*_eav_srp_mac_ethertype_set_dispatch[])(
    int unit, 
    bcm_mac_t mac, 
    bcm_port_ethertype_t ethertype) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_srp_mac_ethertype_set(
    int unit, 
    bcm_mac_t mac, 
    bcm_port_ethertype_t ethertype)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_srp_mac_ethertype_set_dispatch[dtype](unit, mac, ethertype);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_srp_mac_ethertype_set", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_timestamp_get( \
    int unit, bcm_port_t port, uint32 *timestamp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_timestamp_get,
static int (*_eav_timestamp_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 *timestamp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_timestamp_get(
    int unit, 
    bcm_port_t port, 
    uint32 *timestamp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_timestamp_get_dispatch[dtype](unit, port, timestamp);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_timestamp_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_timesync_mac_get( \
    int unit, bcm_mac_t eav_mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_timesync_mac_get,
static int (*_eav_timesync_mac_get_dispatch[])(
    int unit, 
    bcm_mac_t eav_mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_timesync_mac_get(
    int unit, 
    bcm_mac_t eav_mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_timesync_mac_get_dispatch[dtype](unit, eav_mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_timesync_mac_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_eav_timesync_mac_set( \
    int unit, bcm_mac_t eav_mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_eav_timesync_mac_set,
static int (*_eav_timesync_mac_set_dispatch[])(
    int unit, 
    bcm_mac_t eav_mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_eav_timesync_mac_set(
    int unit, 
    bcm_mac_t eav_mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _eav_timesync_mac_set_dispatch[dtype](unit, eav_mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_eav_timesync_mac_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ecn_responsive_protocol_get( \
    int unit, uint8 ip_proto, int *responsive);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ecn_responsive_protocol_get,
static int (*_ecn_responsive_protocol_get_dispatch[])(
    int unit, 
    uint8 ip_proto, 
    int *responsive) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ecn_responsive_protocol_get(
    int unit, 
    uint8 ip_proto, 
    int *responsive)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ecn_responsive_protocol_get_dispatch[dtype](unit, ip_proto, responsive);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ecn_responsive_protocol_get", 3, 2, unit, ip_proto, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ecn_responsive_protocol_set( \
    int unit, uint8 ip_proto, int responsive);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ecn_responsive_protocol_set,
static int (*_ecn_responsive_protocol_set_dispatch[])(
    int unit, 
    uint8 ip_proto, 
    int responsive) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ecn_responsive_protocol_set(
    int unit, 
    uint8 ip_proto, 
    int responsive)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ecn_responsive_protocol_set_dispatch[dtype](unit, ip_proto, responsive);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ecn_responsive_protocol_set", 3, 3, unit, ip_proto, responsive, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ecn_traffic_action_config_get( \
    int unit, bcm_ecn_traffic_action_config_t *ecn_config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ecn_traffic_action_config_get,
static int (*_ecn_traffic_action_config_get_dispatch[])(
    int unit, 
    bcm_ecn_traffic_action_config_t *ecn_config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ecn_traffic_action_config_get(
    int unit, 
    bcm_ecn_traffic_action_config_t *ecn_config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ecn_traffic_action_config_get_dispatch[dtype](unit, ecn_config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ecn_traffic_action_config_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ecn_traffic_action_config_set( \
    int unit, bcm_ecn_traffic_action_config_t *ecn_config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ecn_traffic_action_config_set,
static int (*_ecn_traffic_action_config_set_dispatch[])(
    int unit, 
    bcm_ecn_traffic_action_config_t *ecn_config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ecn_traffic_action_config_set(
    int unit, 
    bcm_ecn_traffic_action_config_t *ecn_config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ecn_traffic_action_config_set_dispatch[dtype](unit, ecn_config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ecn_traffic_action_config_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ecn_traffic_map_get( \
    int unit, bcm_ecn_traffic_map_info_t *map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ecn_traffic_map_get,
static int (*_ecn_traffic_map_get_dispatch[])(
    int unit, 
    bcm_ecn_traffic_map_info_t *map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ecn_traffic_map_get(
    int unit, 
    bcm_ecn_traffic_map_info_t *map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ecn_traffic_map_get_dispatch[dtype](unit, map);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ecn_traffic_map_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ecn_traffic_map_set( \
    int unit, bcm_ecn_traffic_map_info_t *map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ecn_traffic_map_set,
static int (*_ecn_traffic_map_set_dispatch[])(
    int unit, 
    bcm_ecn_traffic_map_info_t *map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ecn_traffic_map_set(
    int unit, 
    bcm_ecn_traffic_map_info_t *map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ecn_traffic_map_set_dispatch[dtype](unit, map);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ecn_traffic_map_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_esmc_QL_SSM_map( \
    int unit, bcm_esmc_network_option_t opt, bcm_esmc_quality_level_t ql, uint8 *ssm_code);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_esmc_QL_SSM_map,
static int (*_esmc_QL_SSM_map_dispatch[])(
    int unit, 
    bcm_esmc_network_option_t opt, 
    bcm_esmc_quality_level_t ql, 
    uint8 *ssm_code) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_esmc_QL_SSM_map(
    int unit, 
    bcm_esmc_network_option_t opt, 
    bcm_esmc_quality_level_t ql, 
    uint8 *ssm_code)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _esmc_QL_SSM_map_dispatch[dtype](unit, opt, ql, ssm_code);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_esmc_QL_SSM_map", 4, 3, unit, opt, ql, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_esmc_SSM_QL_map( \
    int unit, bcm_esmc_network_option_t opt, uint8 ssm_code, bcm_esmc_quality_level_t *ql);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_esmc_SSM_QL_map,
static int (*_esmc_SSM_QL_map_dispatch[])(
    int unit, 
    bcm_esmc_network_option_t opt, 
    uint8 ssm_code, 
    bcm_esmc_quality_level_t *ql) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_esmc_SSM_QL_map(
    int unit, 
    bcm_esmc_network_option_t opt, 
    uint8 ssm_code, 
    bcm_esmc_quality_level_t *ql)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _esmc_SSM_QL_map_dispatch[dtype](unit, opt, ssm_code, ql);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_esmc_SSM_QL_map", 4, 3, unit, opt, ssm_code, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_esmc_g781_option_get( \
    int unit, int stack_id, bcm_esmc_network_option_t *g781_option);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_esmc_g781_option_get,
static int (*_esmc_g781_option_get_dispatch[])(
    int unit, 
    int stack_id, 
    bcm_esmc_network_option_t *g781_option) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_esmc_g781_option_get(
    int unit, 
    int stack_id, 
    bcm_esmc_network_option_t *g781_option)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _esmc_g781_option_get_dispatch[dtype](unit, stack_id, g781_option);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_esmc_g781_option_get", 3, 2, unit, stack_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_esmc_g781_option_set( \
    int unit, int stack_id, bcm_esmc_network_option_t g781_option);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_esmc_g781_option_set,
static int (*_esmc_g781_option_set_dispatch[])(
    int unit, 
    int stack_id, 
    bcm_esmc_network_option_t g781_option) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_esmc_g781_option_set(
    int unit, 
    int stack_id, 
    bcm_esmc_network_option_t g781_option)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _esmc_g781_option_set_dispatch[dtype](unit, stack_id, g781_option);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_esmc_g781_option_set", 3, 3, unit, stack_id, g781_option, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_esmc_rx_callback_register( \
    int unit, int stack_id, bcm_esmc_rx_cb rx_cb);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_esmc_rx_callback_register,
static int (*_esmc_rx_callback_register_dispatch[])(
    int unit, 
    int stack_id, 
    bcm_esmc_rx_cb rx_cb) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_esmc_rx_callback_register(
    int unit, 
    int stack_id, 
    bcm_esmc_rx_cb rx_cb)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _esmc_rx_callback_register_dispatch[dtype](unit, stack_id, rx_cb);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_esmc_rx_callback_register", 3, 2, unit, stack_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_esmc_rx_callback_unregister( \
    int unit, int stack_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_esmc_rx_callback_unregister,
static int (*_esmc_rx_callback_unregister_dispatch[])(
    int unit, 
    int stack_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_esmc_rx_callback_unregister(
    int unit, 
    int stack_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _esmc_rx_callback_unregister_dispatch[dtype](unit, stack_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_esmc_rx_callback_unregister", 2, 2, unit, stack_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_esmc_tunnel_get( \
    int unit, int stack_id, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_esmc_tunnel_get,
static int (*_esmc_tunnel_get_dispatch[])(
    int unit, 
    int stack_id, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_esmc_tunnel_get(
    int unit, 
    int stack_id, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _esmc_tunnel_get_dispatch[dtype](unit, stack_id, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_esmc_tunnel_get", 3, 2, unit, stack_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_esmc_tunnel_set( \
    int unit, int stack_id, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_esmc_tunnel_set,
static int (*_esmc_tunnel_set_dispatch[])(
    int unit, 
    int stack_id, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_esmc_tunnel_set(
    int unit, 
    int stack_id, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _esmc_tunnel_set_dispatch[dtype](unit, stack_id, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_esmc_tunnel_set", 3, 3, unit, stack_id, enable, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_esmc_tx( \
    int unit, int stack_id, bcm_pbmp_t pbmp, bcm_esmc_pdu_data_t *esmc_pdu_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_esmc_tx,
static int (*_esmc_tx_dispatch[])(
    int unit, 
    int stack_id, 
    bcm_pbmp_t pbmp, 
    bcm_esmc_pdu_data_t *esmc_pdu_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_esmc_tx(
    int unit, 
    int stack_id, 
    bcm_pbmp_t pbmp, 
    bcm_esmc_pdu_data_t *esmc_pdu_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _esmc_tx_dispatch[dtype](unit, stack_id, pbmp, esmc_pdu_data);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_esmc_tx", 4, 2, unit, stack_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_cleanup( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_cleanup,
static int (*_extender_cleanup_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_cleanup(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_cleanup_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_cleanup", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_encap_create( \
    int unit, bcm_extender_encap_t *extender_encap);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_encap_create,
static int (*_extender_encap_create_dispatch[])(
    int unit, 
    bcm_extender_encap_t *extender_encap) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_encap_create(
    int unit, 
    bcm_extender_encap_t *extender_encap)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(extender_encap) BCM_API_XLATE_PORT_A2P(unit,&extender_encap->extender_encap_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_encap_create_dispatch[dtype](unit, extender_encap);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(extender_encap) BCM_API_XLATE_PORT_P2A(unit,&extender_encap->extender_encap_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_encap_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_encap_destroy( \
    int unit, bcm_gport_t *extender_encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_encap_destroy,
static int (*_extender_encap_destroy_dispatch[])(
    int unit, 
    bcm_gport_t *extender_encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_encap_destroy(
    int unit, 
    bcm_gport_t *extender_encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&extender_encap_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_encap_destroy_dispatch[dtype](unit, extender_encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_encap_destroy", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_encap_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_encap_destroy_all,
static int (*_extender_encap_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_encap_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_encap_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_encap_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_encap_get( \
    int unit, bcm_extender_encap_t *extender_encap);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_encap_get,
static int (*_extender_encap_get_dispatch[])(
    int unit, 
    bcm_extender_encap_t *extender_encap) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_encap_get(
    int unit, 
    bcm_extender_encap_t *extender_encap)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(extender_encap) BCM_API_XLATE_PORT_A2P(unit,&extender_encap->extender_encap_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_encap_get_dispatch[dtype](unit, extender_encap);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(extender_encap) BCM_API_XLATE_PORT_P2A(unit,&extender_encap->extender_encap_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_encap_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_encap_traverse( \
    int unit, bcm_extender_encap_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_encap_traverse,
static int (*_extender_encap_traverse_dispatch[])(
    int unit, 
    bcm_extender_encap_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_encap_traverse(
    int unit, 
    bcm_extender_encap_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_encap_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_encap_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_forward_add( \
    int unit, bcm_extender_forward_t *extender_forward_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_forward_add,
static int (*_extender_forward_add_dispatch[])(
    int unit, 
    bcm_extender_forward_t *extender_forward_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_forward_add(
    int unit, 
    bcm_extender_forward_t *extender_forward_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(extender_forward_entry) BCM_API_XLATE_PORT_A2P(unit,&extender_forward_entry->dest_port);
		BCM_API_XLATE_PORT_COND(extender_forward_entry) BCM_API_XLATE_PORT_A2P(unit,&extender_forward_entry->extender_forward_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_forward_add_dispatch[dtype](unit, extender_forward_entry);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(extender_forward_entry) BCM_API_XLATE_PORT_P2A(unit,&extender_forward_entry->dest_port);
		BCM_API_XLATE_PORT_COND(extender_forward_entry) BCM_API_XLATE_PORT_P2A(unit,&extender_forward_entry->extender_forward_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_forward_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_forward_delete( \
    int unit, bcm_extender_forward_t *extender_forward_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_forward_delete,
static int (*_extender_forward_delete_dispatch[])(
    int unit, 
    bcm_extender_forward_t *extender_forward_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_forward_delete(
    int unit, 
    bcm_extender_forward_t *extender_forward_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(extender_forward_entry_dest_port);
		BCM_API_XLATE_PORT_DECL(extender_forward_entry_extender_forward_id);
		BCM_API_XLATE_PORT_COND(extender_forward_entry) BCM_API_XLATE_PORT_SAVE(extender_forward_entry_dest_port,extender_forward_entry->dest_port);
		BCM_API_XLATE_PORT_COND(extender_forward_entry) BCM_API_XLATE_PORT_A2P(unit,&extender_forward_entry->dest_port);
		BCM_API_XLATE_PORT_COND(extender_forward_entry) BCM_API_XLATE_PORT_SAVE(extender_forward_entry_extender_forward_id,extender_forward_entry->extender_forward_id);
		BCM_API_XLATE_PORT_COND(extender_forward_entry) BCM_API_XLATE_PORT_A2P(unit,&extender_forward_entry->extender_forward_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_forward_delete_dispatch[dtype](unit, extender_forward_entry);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(extender_forward_entry) BCM_API_XLATE_PORT_RESTORE(extender_forward_entry->dest_port,extender_forward_entry_dest_port);
		BCM_API_XLATE_PORT_COND(extender_forward_entry) BCM_API_XLATE_PORT_RESTORE(extender_forward_entry->extender_forward_id,extender_forward_entry_extender_forward_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_forward_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_forward_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_forward_delete_all,
static int (*_extender_forward_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_forward_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_forward_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_forward_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_forward_get( \
    int unit, bcm_extender_forward_t *extender_forward_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_forward_get,
static int (*_extender_forward_get_dispatch[])(
    int unit, 
    bcm_extender_forward_t *extender_forward_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_forward_get(
    int unit, 
    bcm_extender_forward_t *extender_forward_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(extender_forward_entry) BCM_API_XLATE_PORT_A2P(unit,&extender_forward_entry->dest_port);
		BCM_API_XLATE_PORT_COND(extender_forward_entry) BCM_API_XLATE_PORT_A2P(unit,&extender_forward_entry->extender_forward_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_forward_get_dispatch[dtype](unit, extender_forward_entry);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(extender_forward_entry) BCM_API_XLATE_PORT_P2A(unit,&extender_forward_entry->dest_port);
		BCM_API_XLATE_PORT_COND(extender_forward_entry) BCM_API_XLATE_PORT_P2A(unit,&extender_forward_entry->extender_forward_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_forward_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_forward_traverse( \
    int unit, bcm_extender_forward_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_forward_traverse,
static int (*_extender_forward_traverse_dispatch[])(
    int unit, 
    bcm_extender_forward_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_forward_traverse(
    int unit, 
    bcm_extender_forward_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_forward_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_forward_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_init,
static int (*_extender_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_port_add( \
    int unit, bcm_extender_port_t *extender_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_port_add,
static int (*_extender_port_add_dispatch[])(
    int unit, 
    bcm_extender_port_t *extender_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_port_add(
    int unit, 
    bcm_extender_port_t *extender_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(extender_port) BCM_API_XLATE_PORT_A2P(unit,&extender_port->extender_port_id);
		BCM_API_XLATE_PORT_COND(extender_port) BCM_API_XLATE_PORT_A2P(unit,&extender_port->failover_port_id);
		BCM_API_XLATE_PORT_COND(extender_port) BCM_API_XLATE_PORT_A2P(unit,&extender_port->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_port_add_dispatch[dtype](unit, extender_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(extender_port) BCM_API_XLATE_PORT_P2A(unit,&extender_port->extender_port_id);
		BCM_API_XLATE_PORT_COND(extender_port) BCM_API_XLATE_PORT_P2A(unit,&extender_port->failover_port_id);
		BCM_API_XLATE_PORT_COND(extender_port) BCM_API_XLATE_PORT_P2A(unit,&extender_port->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_port_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_port_delete( \
    int unit, bcm_gport_t extender_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_port_delete,
static int (*_extender_port_delete_dispatch[])(
    int unit, 
    bcm_gport_t extender_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_port_delete(
    int unit, 
    bcm_gport_t extender_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&extender_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_port_delete_dispatch[dtype](unit, extender_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_port_delete", 2, 2, unit, extender_port_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_port_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_port_delete_all,
static int (*_extender_port_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_port_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_port_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_port_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_port_get( \
    int unit, bcm_extender_port_t *extender_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_port_get,
static int (*_extender_port_get_dispatch[])(
    int unit, 
    bcm_extender_port_t *extender_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_port_get(
    int unit, 
    bcm_extender_port_t *extender_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(extender_port) BCM_API_XLATE_PORT_A2P(unit,&extender_port->extender_port_id);
		BCM_API_XLATE_PORT_COND(extender_port) BCM_API_XLATE_PORT_A2P(unit,&extender_port->failover_port_id);
		BCM_API_XLATE_PORT_COND(extender_port) BCM_API_XLATE_PORT_A2P(unit,&extender_port->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_port_get_dispatch[dtype](unit, extender_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(extender_port) BCM_API_XLATE_PORT_P2A(unit,&extender_port->extender_port_id);
		BCM_API_XLATE_PORT_COND(extender_port) BCM_API_XLATE_PORT_P2A(unit,&extender_port->failover_port_id);
		BCM_API_XLATE_PORT_COND(extender_port) BCM_API_XLATE_PORT_P2A(unit,&extender_port->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_port_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_extender_port_traverse( \
    int unit, bcm_extender_port_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_extender_port_traverse,
static int (*_extender_port_traverse_dispatch[])(
    int unit, 
    bcm_extender_port_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_extender_port_traverse(
    int unit, 
    bcm_extender_port_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _extender_port_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_extender_port_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_action_create( \
    int unit, bcm_fabric_action_info_t *action_info, bcm_fabric_action_t *action_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_action_create,
static int (*_fabric_action_create_dispatch[])(
    int unit, 
    bcm_fabric_action_info_t *action_info, 
    bcm_fabric_action_t *action_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_action_create(
    int unit, 
    bcm_fabric_action_info_t *action_info, 
    bcm_fabric_action_t *action_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_action_create_dispatch[dtype](unit, action_info, action_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_action_create", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_action_destroy( \
    int unit, bcm_fabric_action_t action_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_action_destroy,
static int (*_fabric_action_destroy_dispatch[])(
    int unit, 
    bcm_fabric_action_t action_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_action_destroy(
    int unit, 
    bcm_fabric_action_t action_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_action_destroy_dispatch[dtype](unit, action_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_action_destroy", 2, 2, unit, action_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_action_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_action_destroy_all,
static int (*_fabric_action_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_action_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_action_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_action_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_action_get( \
    int unit, bcm_fabric_action_t action_id, bcm_fabric_action_info_t *action_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_action_get,
static int (*_fabric_action_get_dispatch[])(
    int unit, 
    bcm_fabric_action_t action_id, 
    bcm_fabric_action_info_t *action_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_action_get(
    int unit, 
    bcm_fabric_action_t action_id, 
    bcm_fabric_action_info_t *action_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_action_get_dispatch[dtype](unit, action_id, action_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_action_get", 3, 2, unit, action_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_action_traverse( \
    int unit, bcm_fabric_action_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_action_traverse,
static int (*_fabric_action_traverse_dispatch[])(
    int unit, 
    bcm_fabric_action_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_action_traverse(
    int unit, 
    bcm_fabric_action_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_action_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_action_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_bandwidth_profile_get( \
    int unit, int profile_count, bcm_fabric_bandwidth_profile_t *profile_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_bandwidth_profile_get,
static int (*_fabric_bandwidth_profile_get_dispatch[])(
    int unit, 
    int profile_count, 
    bcm_fabric_bandwidth_profile_t *profile_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_bandwidth_profile_get(
    int unit, 
    int profile_count, 
    bcm_fabric_bandwidth_profile_t *profile_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_bandwidth_profile_get_dispatch[dtype](unit, profile_count, profile_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_bandwidth_profile_get", 3, 2, unit, profile_count, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_bandwidth_profile_set( \
    int unit, int profile_count, bcm_fabric_bandwidth_profile_t *profile_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_bandwidth_profile_set,
static int (*_fabric_bandwidth_profile_set_dispatch[])(
    int unit, 
    int profile_count, 
    bcm_fabric_bandwidth_profile_t *profile_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_bandwidth_profile_set(
    int unit, 
    int profile_count, 
    bcm_fabric_bandwidth_profile_t *profile_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_bandwidth_profile_set_dispatch[dtype](unit, profile_count, profile_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_bandwidth_profile_set", 3, 2, unit, profile_count, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_calendar_active( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_calendar_active,
static int (*_fabric_calendar_active_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_calendar_active(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_calendar_active_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_calendar_active", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_calendar_get( \
    int unit, int cindex, int *connection, bcm_gport_t *dest_port, bcm_cos_queue_t *dest_cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_calendar_get,
static int (*_fabric_calendar_get_dispatch[])(
    int unit, 
    int cindex, 
    int *connection, 
    bcm_gport_t *dest_port, 
    bcm_cos_queue_t *dest_cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_calendar_get(
    int unit, 
    int cindex, 
    int *connection, 
    bcm_gport_t *dest_port, 
    bcm_cos_queue_t *dest_cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_calendar_get_dispatch[dtype](unit, cindex, connection, dest_port, dest_cosq);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_calendar_get", 5, 2, unit, cindex, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_calendar_max_get( \
    int unit, int *max_size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_calendar_max_get,
static int (*_fabric_calendar_max_get_dispatch[])(
    int unit, 
    int *max_size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_calendar_max_get(
    int unit, 
    int *max_size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_calendar_max_get_dispatch[dtype](unit, max_size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_calendar_max_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_calendar_multi_get( \
    int unit, int array_size, int *connection_array, bcm_gport_t *dest_port_array, bcm_cos_queue_t *dest_cosq_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_calendar_multi_get,
static int (*_fabric_calendar_multi_get_dispatch[])(
    int unit, 
    int array_size, 
    int *connection_array, 
    bcm_gport_t *dest_port_array, 
    bcm_cos_queue_t *dest_cosq_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_calendar_multi_get(
    int unit, 
    int array_size, 
    int *connection_array, 
    bcm_gport_t *dest_port_array, 
    bcm_cos_queue_t *dest_cosq_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_calendar_multi_get_dispatch[dtype](unit, array_size, connection_array, dest_port_array, dest_cosq_array);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(array_size,idx)
				BCM_API_XLATE_PORT_COND(dest_port_array) BCM_API_XLATE_PORT_P2A(unit,&(dest_port_array)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_calendar_multi_get", 5, 2, unit, array_size, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_calendar_multi_set( \
    int unit, int array_size, int *connection_array, bcm_gport_t *dest_port_array, bcm_cos_queue_t *dest_cosq_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_calendar_multi_set,
static int (*_fabric_calendar_multi_set_dispatch[])(
    int unit, 
    int array_size, 
    int *connection_array, 
    bcm_gport_t *dest_port_array, 
    bcm_cos_queue_t *dest_cosq_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_calendar_multi_set(
    int unit, 
    int array_size, 
    int *connection_array, 
    bcm_gport_t *dest_port_array, 
    bcm_cos_queue_t *dest_cosq_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_ITER(array_size,idx)
			BCM_API_XLATE_PORT_COND(dest_port_array) BCM_API_XLATE_PORT_A2P(unit,&(dest_port_array)[idx]);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_calendar_multi_set_dispatch[dtype](unit, array_size, connection_array, dest_port_array, dest_cosq_array);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_ITER(array_size,idx)
			BCM_API_XLATE_PORT_COND(dest_port_array) BCM_API_XLATE_PORT_P2A(unit,&(dest_port_array)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_calendar_multi_set", 5, 2, unit, array_size, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_calendar_set( \
    int unit, int cindex, int connection, bcm_gport_t dest_port, bcm_cos_queue_t dest_cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_calendar_set,
static int (*_fabric_calendar_set_dispatch[])(
    int unit, 
    int cindex, 
    int connection, 
    bcm_gport_t dest_port, 
    bcm_cos_queue_t dest_cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_calendar_set(
    int unit, 
    int cindex, 
    int connection, 
    bcm_gport_t dest_port, 
    bcm_cos_queue_t dest_cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_calendar_set_dispatch[dtype](unit, cindex, connection, dest_port, dest_cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_calendar_set", 5, 3, unit, cindex, connection, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_calendar_size_get( \
    int unit, int *config_size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_calendar_size_get,
static int (*_fabric_calendar_size_get_dispatch[])(
    int unit, 
    int *config_size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_calendar_size_get(
    int unit, 
    int *config_size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_calendar_size_get_dispatch[dtype](unit, config_size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_calendar_size_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_calendar_size_set( \
    int unit, int config_size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_calendar_size_set,
static int (*_fabric_calendar_size_set_dispatch[])(
    int unit, 
    int config_size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_calendar_size_set(
    int unit, 
    int config_size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_calendar_size_set_dispatch[dtype](unit, config_size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_calendar_size_set", 2, 2, unit, config_size, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_config_discard_get( \
    int unit, bcm_fabric_config_discard_t *discard);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_config_discard_get,
static int (*_fabric_config_discard_get_dispatch[])(
    int unit, 
    bcm_fabric_config_discard_t *discard) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_config_discard_get(
    int unit, 
    bcm_fabric_config_discard_t *discard)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_config_discard_get_dispatch[dtype](unit, discard);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_config_discard_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_config_discard_set( \
    int unit, bcm_fabric_config_discard_t *discard);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_config_discard_set,
static int (*_fabric_config_discard_set_dispatch[])(
    int unit, 
    bcm_fabric_config_discard_t *discard) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_config_discard_set(
    int unit, 
    bcm_fabric_config_discard_t *discard)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_config_discard_set_dispatch[dtype](unit, discard);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_config_discard_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_congestion_size_get( \
    int unit, bcm_module_t module_id, int *max_ports);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_congestion_size_get,
static int (*_fabric_congestion_size_get_dispatch[])(
    int unit, 
    bcm_module_t module_id, 
    int *max_ports) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_congestion_size_get(
    int unit, 
    bcm_module_t module_id, 
    int *max_ports)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_congestion_size_get_dispatch[dtype](unit, module_id, max_ports);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_congestion_size_get", 3, 2, unit, module_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_congestion_size_set( \
    int unit, bcm_module_t module_id, int max_ports);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_congestion_size_set,
static int (*_fabric_congestion_size_set_dispatch[])(
    int unit, 
    bcm_module_t module_id, 
    int max_ports) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_congestion_size_set(
    int unit, 
    bcm_module_t module_id, 
    int max_ports)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_congestion_size_set_dispatch[dtype](unit, module_id, max_ports);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_congestion_size_set", 3, 3, unit, module_id, max_ports, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_connection_bytes_get( \
    int unit, int src_modid, int dst_modid, bcm_fabric_connection_mode_t mode, int link_fail_count, int *max_bytes);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_connection_bytes_get,
static int (*_fabric_connection_bytes_get_dispatch[])(
    int unit, 
    int src_modid, 
    int dst_modid, 
    bcm_fabric_connection_mode_t mode, 
    int link_fail_count, 
    int *max_bytes) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_connection_bytes_get(
    int unit, 
    int src_modid, 
    int dst_modid, 
    bcm_fabric_connection_mode_t mode, 
    int link_fail_count, 
    int *max_bytes)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_connection_bytes_get_dispatch[dtype](unit, src_modid, dst_modid, mode, link_fail_count, max_bytes);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_connection_bytes_get", 6, 3, unit, src_modid, dst_modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_connection_interval_get( \
    int unit, int link_fail_count, int *connection_interval);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_connection_interval_get,
static int (*_fabric_connection_interval_get_dispatch[])(
    int unit, 
    int link_fail_count, 
    int *connection_interval) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_connection_interval_get(
    int unit, 
    int link_fail_count, 
    int *connection_interval)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_connection_interval_get_dispatch[dtype](unit, link_fail_count, connection_interval);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_connection_interval_get", 3, 2, unit, link_fail_count, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_connection_max_get( \
    int unit, int link_fail_count, int *connection);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_connection_max_get,
static int (*_fabric_connection_max_get_dispatch[])(
    int unit, 
    int link_fail_count, 
    int *connection) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_connection_max_get(
    int unit, 
    int link_fail_count, 
    int *connection)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_connection_max_get_dispatch[dtype](unit, link_fail_count, connection);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_connection_max_get", 3, 2, unit, link_fail_count, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_control_get( \
    int unit, bcm_fabric_control_t type, int *arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_control_get,
static int (*_fabric_control_get_dispatch[])(
    int unit, 
    bcm_fabric_control_t type, 
    int *arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_control_get(
    int unit, 
    bcm_fabric_control_t type, 
    int *arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_control_get_dispatch[dtype](unit, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_control_get", 3, 2, unit, type, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_control_redundancy_register( \
    int unit, bcm_fabric_control_redundancy_handler_t f);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_control_redundancy_register,
static int (*_fabric_control_redundancy_register_dispatch[])(
    int unit, 
    bcm_fabric_control_redundancy_handler_t f) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_control_redundancy_register(
    int unit, 
    bcm_fabric_control_redundancy_handler_t f)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_control_redundancy_register_dispatch[dtype](unit, f);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_control_redundancy_register", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_control_redundancy_unregister( \
    int unit, bcm_fabric_control_redundancy_handler_t f);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_control_redundancy_unregister,
static int (*_fabric_control_redundancy_unregister_dispatch[])(
    int unit, 
    bcm_fabric_control_redundancy_handler_t f) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_control_redundancy_unregister(
    int unit, 
    bcm_fabric_control_redundancy_handler_t f)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_control_redundancy_unregister_dispatch[dtype](unit, f);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_control_redundancy_unregister", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_control_set( \
    int unit, bcm_fabric_control_t type, int arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_control_set,
static int (*_fabric_control_set_dispatch[])(
    int unit, 
    bcm_fabric_control_t type, 
    int arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_control_set(
    int unit, 
    bcm_fabric_control_t type, 
    int arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_control_set_dispatch[dtype](unit, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_control_set", 3, 3, unit, type, arg, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_crossbar_connection_get( \
    int unit, int xbar, int src_modid, bcm_port_t src_xbport, int dst_modid, bcm_port_t *dst_xbport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_crossbar_connection_get,
static int (*_fabric_crossbar_connection_get_dispatch[])(
    int unit, 
    int xbar, 
    int src_modid, 
    bcm_port_t src_xbport, 
    int dst_modid, 
    bcm_port_t *dst_xbport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_crossbar_connection_get(
    int unit, 
    int xbar, 
    int src_modid, 
    bcm_port_t src_xbport, 
    int dst_modid, 
    bcm_port_t *dst_xbport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_crossbar_connection_get_dispatch[dtype](unit, xbar, src_modid, src_xbport, dst_modid, dst_xbport);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_crossbar_connection_get", 6, 3, unit, xbar, src_modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_crossbar_connection_set( \
    int unit, int xbar, int src_modid, bcm_port_t src_xbport, int dst_modid, bcm_port_t dst_xbport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_crossbar_connection_set,
static int (*_fabric_crossbar_connection_set_dispatch[])(
    int unit, 
    int xbar, 
    int src_modid, 
    bcm_port_t src_xbport, 
    int dst_modid, 
    bcm_port_t dst_xbport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_crossbar_connection_set(
    int unit, 
    int xbar, 
    int src_modid, 
    bcm_port_t src_xbport, 
    int dst_modid, 
    bcm_port_t dst_xbport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_crossbar_connection_set_dispatch[dtype](unit, xbar, src_modid, src_xbport, dst_modid, dst_xbport);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_crossbar_connection_set", 6, 3, unit, xbar, src_modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_crossbar_connection_status_get( \
    int unit, int src_modid, int dst_modid, bcm_fabric_connection_mode_t mode, uint64 *xbars);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_crossbar_connection_status_get,
static int (*_fabric_crossbar_connection_status_get_dispatch[])(
    int unit, 
    int src_modid, 
    int dst_modid, 
    bcm_fabric_connection_mode_t mode, 
    uint64 *xbars) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_crossbar_connection_status_get(
    int unit, 
    int src_modid, 
    int dst_modid, 
    bcm_fabric_connection_mode_t mode, 
    uint64 *xbars)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_crossbar_connection_status_get_dispatch[dtype](unit, src_modid, dst_modid, mode, xbars);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_crossbar_connection_status_get", 5, 3, unit, src_modid, dst_modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_crossbar_enable_get( \
    int unit, uint64 *xbars);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_crossbar_enable_get,
static int (*_fabric_crossbar_enable_get_dispatch[])(
    int unit, 
    uint64 *xbars) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_crossbar_enable_get(
    int unit, 
    uint64 *xbars)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_crossbar_enable_get_dispatch[dtype](unit, xbars);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_crossbar_enable_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_crossbar_enable_set( \
    int unit, uint64 xbars);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_crossbar_enable_set,
static int (*_fabric_crossbar_enable_set_dispatch[])(
    int unit, 
    uint64 xbars) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_crossbar_enable_set(
    int unit, 
    uint64 xbars)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_crossbar_enable_set_dispatch[dtype](unit, xbars);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_crossbar_enable_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_crossbar_mapping_get( \
    int unit, int modid, int switch_fabric_arbiter_id, int xbar, bcm_port_t *port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_crossbar_mapping_get,
static int (*_fabric_crossbar_mapping_get_dispatch[])(
    int unit, 
    int modid, 
    int switch_fabric_arbiter_id, 
    int xbar, 
    bcm_port_t *port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_crossbar_mapping_get(
    int unit, 
    int modid, 
    int switch_fabric_arbiter_id, 
    int xbar, 
    bcm_port_t *port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_crossbar_mapping_get_dispatch[dtype](unit, modid, switch_fabric_arbiter_id, xbar, port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_crossbar_mapping_get", 5, 3, unit, modid, switch_fabric_arbiter_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_crossbar_mapping_set( \
    int unit, int modid, int switch_fabric_arbiter_id, int xbar, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_crossbar_mapping_set,
static int (*_fabric_crossbar_mapping_set_dispatch[])(
    int unit, 
    int modid, 
    int switch_fabric_arbiter_id, 
    int xbar, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_crossbar_mapping_set(
    int unit, 
    int modid, 
    int switch_fabric_arbiter_id, 
    int xbar, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_crossbar_mapping_set_dispatch[dtype](unit, modid, switch_fabric_arbiter_id, xbar, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_crossbar_mapping_set", 5, 3, unit, modid, switch_fabric_arbiter_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_crossbar_status_get( \
    int unit, uint64 *xbars);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_crossbar_status_get,
static int (*_fabric_crossbar_status_get_dispatch[])(
    int unit, 
    uint64 *xbars) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_crossbar_status_get(
    int unit, 
    uint64 *xbars)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_crossbar_status_get_dispatch[dtype](unit, xbars);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_crossbar_status_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_distribution_control_get( \
    int unit, bcm_fabric_distribution_t ds_id, bcm_fabric_distribution_control_t type, int *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_distribution_control_get,
static int (*_fabric_distribution_control_get_dispatch[])(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    bcm_fabric_distribution_control_t type, 
    int *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_distribution_control_get(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    bcm_fabric_distribution_control_t type, 
    int *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_distribution_control_get_dispatch[dtype](unit, ds_id, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_distribution_control_get", 4, 3, unit, ds_id, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_distribution_control_set( \
    int unit, bcm_fabric_distribution_t ds_id, bcm_fabric_distribution_control_t type, int value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_distribution_control_set,
static int (*_fabric_distribution_control_set_dispatch[])(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    bcm_fabric_distribution_control_t type, 
    int value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_distribution_control_set(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    bcm_fabric_distribution_control_t type, 
    int value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_distribution_control_set_dispatch[dtype](unit, ds_id, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_distribution_control_set", 4, 3, unit, ds_id, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_distribution_create( \
    int unit, uint32 flags, bcm_fabric_distribution_t *ds_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_distribution_create,
static int (*_fabric_distribution_create_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_fabric_distribution_t *ds_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_distribution_create(
    int unit, 
    uint32 flags, 
    bcm_fabric_distribution_t *ds_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_distribution_create_dispatch[dtype](unit, flags, ds_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_distribution_create", 3, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_distribution_destroy( \
    int unit, bcm_fabric_distribution_t ds_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_distribution_destroy,
static int (*_fabric_distribution_destroy_dispatch[])(
    int unit, 
    bcm_fabric_distribution_t ds_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_distribution_destroy(
    int unit, 
    bcm_fabric_distribution_t ds_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_distribution_destroy_dispatch[dtype](unit, ds_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_distribution_destroy", 2, 2, unit, ds_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_distribution_get( \
    int unit, bcm_fabric_distribution_t ds_id, int max_count, int *dist_modids, int *count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_distribution_get,
static int (*_fabric_distribution_get_dispatch[])(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    int max_count, 
    int *dist_modids, 
    int *count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_distribution_get(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    int max_count, 
    int *dist_modids, 
    int *count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_distribution_get_dispatch[dtype](unit, ds_id, max_count, dist_modids, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_distribution_get", 5, 3, unit, ds_id, max_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_distribution_set( \
    int unit, bcm_fabric_distribution_t ds_id, int modid_count, int *dist_modids);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_distribution_set,
static int (*_fabric_distribution_set_dispatch[])(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    int modid_count, 
    int *dist_modids) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_distribution_set(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    int modid_count, 
    int *dist_modids)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_distribution_set_dispatch[dtype](unit, ds_id, modid_count, dist_modids);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_distribution_set", 4, 3, unit, ds_id, modid_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_init,
static int (*_fabric_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_connectivity_status_get( \
    int unit, int link_partner_max, bcm_fabric_link_connectivity_t *link_partner_array, int *link_partner_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_connectivity_status_get,
static int (*_fabric_link_connectivity_status_get_dispatch[])(
    int unit, 
    int link_partner_max, 
    bcm_fabric_link_connectivity_t *link_partner_array, 
    int *link_partner_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_connectivity_status_get(
    int unit, 
    int link_partner_max, 
    bcm_fabric_link_connectivity_t *link_partner_array, 
    int *link_partner_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_connectivity_status_get_dispatch[dtype](unit, link_partner_max, link_partner_array, link_partner_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_connectivity_status_get", 4, 2, unit, link_partner_max, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_connectivity_status_single_get( \
    int unit, bcm_port_t link_id, bcm_fabric_link_connectivity_t *link_partner_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_connectivity_status_single_get,
static int (*_fabric_link_connectivity_status_single_get_dispatch[])(
    int unit, 
    bcm_port_t link_id, 
    bcm_fabric_link_connectivity_t *link_partner_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_connectivity_status_single_get(
    int unit, 
    bcm_port_t link_id, 
    bcm_fabric_link_connectivity_t *link_partner_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&link_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_connectivity_status_single_get_dispatch[dtype](unit, link_id, link_partner_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_connectivity_status_single_get", 3, 2, unit, link_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_control_get( \
    int unit, bcm_port_t link, bcm_fabric_link_control_t type, int *arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_control_get,
static int (*_fabric_link_control_get_dispatch[])(
    int unit, 
    bcm_port_t link, 
    bcm_fabric_link_control_t type, 
    int *arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_control_get(
    int unit, 
    bcm_port_t link, 
    bcm_fabric_link_control_t type, 
    int *arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&link);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_control_get_dispatch[dtype](unit, link, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_control_get", 4, 3, unit, link, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_control_set( \
    int unit, bcm_port_t link, bcm_fabric_link_control_t type, int arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_control_set,
static int (*_fabric_link_control_set_dispatch[])(
    int unit, 
    bcm_port_t link, 
    bcm_fabric_link_control_t type, 
    int arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_control_set(
    int unit, 
    bcm_port_t link, 
    bcm_fabric_link_control_t type, 
    int arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&link);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_control_set_dispatch[dtype](unit, link, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_control_set", 4, 3, unit, link, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_remote_pipe_mapping_get( \
    int unit, bcm_port_t port, bcm_fabric_link_remote_pipe_mapping_t *mapping_config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_remote_pipe_mapping_get,
static int (*_fabric_link_remote_pipe_mapping_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_fabric_link_remote_pipe_mapping_t *mapping_config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_remote_pipe_mapping_get(
    int unit, 
    bcm_port_t port, 
    bcm_fabric_link_remote_pipe_mapping_t *mapping_config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_remote_pipe_mapping_get_dispatch[dtype](unit, port, mapping_config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_remote_pipe_mapping_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_remote_pipe_mapping_set( \
    int unit, bcm_port_t port, bcm_fabric_link_remote_pipe_mapping_t *mapping_config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_remote_pipe_mapping_set,
static int (*_fabric_link_remote_pipe_mapping_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_fabric_link_remote_pipe_mapping_t *mapping_config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_remote_pipe_mapping_set(
    int unit, 
    bcm_port_t port, 
    bcm_fabric_link_remote_pipe_mapping_t *mapping_config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_remote_pipe_mapping_set_dispatch[dtype](unit, port, mapping_config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_remote_pipe_mapping_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_status_get( \
    int unit, bcm_port_t link_id, uint32 *link_status, uint32 *errored_token_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_status_get,
static int (*_fabric_link_status_get_dispatch[])(
    int unit, 
    bcm_port_t link_id, 
    uint32 *link_status, 
    uint32 *errored_token_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_status_get(
    int unit, 
    bcm_port_t link_id, 
    uint32 *link_status, 
    uint32 *errored_token_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&link_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_status_get_dispatch[dtype](unit, link_id, link_status, errored_token_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_status_get", 4, 2, unit, link_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_threshold_add( \
    int unit, uint32 flags, int *fifo_type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_threshold_add,
static int (*_fabric_link_threshold_add_dispatch[])(
    int unit, 
    uint32 flags, 
    int *fifo_type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_threshold_add(
    int unit, 
    uint32 flags, 
    int *fifo_type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_threshold_add_dispatch[dtype](unit, flags, fifo_type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_threshold_add", 3, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_threshold_delete( \
    int unit, int fifo_type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_threshold_delete,
static int (*_fabric_link_threshold_delete_dispatch[])(
    int unit, 
    int fifo_type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_threshold_delete(
    int unit, 
    int fifo_type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_threshold_delete_dispatch[dtype](unit, fifo_type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_threshold_delete", 2, 2, unit, fifo_type, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_thresholds_attach( \
    int unit, int fifo_type, uint32 links_count, bcm_port_t *links);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_thresholds_attach,
static int (*_fabric_link_thresholds_attach_dispatch[])(
    int unit, 
    int fifo_type, 
    uint32 links_count, 
    bcm_port_t *links) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_thresholds_attach(
    int unit, 
    int fifo_type, 
    uint32 links_count, 
    bcm_port_t *links)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_ITER(links_count,idx)
			BCM_API_XLATE_PORT_COND(links) BCM_API_XLATE_PORT_A2P(unit,&(links)[idx]);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_thresholds_attach_dispatch[dtype](unit, fifo_type, links_count, links);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_ITER(links_count,idx)
			BCM_API_XLATE_PORT_COND(links) BCM_API_XLATE_PORT_P2A(unit,&(links)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_thresholds_attach", 4, 3, unit, fifo_type, links_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_thresholds_get( \
    int unit, int fifo_type, uint32 count, bcm_fabric_link_threshold_type_t *type, int *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_thresholds_get,
static int (*_fabric_link_thresholds_get_dispatch[])(
    int unit, 
    int fifo_type, 
    uint32 count, 
    bcm_fabric_link_threshold_type_t *type, 
    int *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_thresholds_get(
    int unit, 
    int fifo_type, 
    uint32 count, 
    bcm_fabric_link_threshold_type_t *type, 
    int *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_thresholds_get_dispatch[dtype](unit, fifo_type, count, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_thresholds_get", 5, 3, unit, fifo_type, count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_thresholds_pipe_get( \
    int unit, int fifo_type, bcm_fabric_pipe_t pipe, uint32 flags, uint32 count, bcm_fabric_link_threshold_type_t *type, int *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_thresholds_pipe_get,
static int (*_fabric_link_thresholds_pipe_get_dispatch[])(
    int unit, 
    int fifo_type, 
    bcm_fabric_pipe_t pipe, 
    uint32 flags, 
    uint32 count, 
    bcm_fabric_link_threshold_type_t *type, 
    int *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_thresholds_pipe_get(
    int unit, 
    int fifo_type, 
    bcm_fabric_pipe_t pipe, 
    uint32 flags, 
    uint32 count, 
    bcm_fabric_link_threshold_type_t *type, 
    int *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_thresholds_pipe_get_dispatch[dtype](unit, fifo_type, pipe, flags, count, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_thresholds_pipe_get", 7, 3, unit, fifo_type, pipe, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_thresholds_pipe_set( \
    int unit, int fifo_type, bcm_fabric_pipe_t pipe, uint32 flags, uint32 count, bcm_fabric_link_threshold_type_t *type, int *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_thresholds_pipe_set,
static int (*_fabric_link_thresholds_pipe_set_dispatch[])(
    int unit, 
    int fifo_type, 
    bcm_fabric_pipe_t pipe, 
    uint32 flags, 
    uint32 count, 
    bcm_fabric_link_threshold_type_t *type, 
    int *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_thresholds_pipe_set(
    int unit, 
    int fifo_type, 
    bcm_fabric_pipe_t pipe, 
    uint32 flags, 
    uint32 count, 
    bcm_fabric_link_threshold_type_t *type, 
    int *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_thresholds_pipe_set_dispatch[dtype](unit, fifo_type, pipe, flags, count, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_thresholds_pipe_set", 7, 3, unit, fifo_type, pipe, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_thresholds_retrieve( \
    int unit, int fifo_type, uint32 links_count_max, bcm_port_t *links, uint32 *links_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_thresholds_retrieve,
static int (*_fabric_link_thresholds_retrieve_dispatch[])(
    int unit, 
    int fifo_type, 
    uint32 links_count_max, 
    bcm_port_t *links, 
    uint32 *links_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_thresholds_retrieve(
    int unit, 
    int fifo_type, 
    uint32 links_count_max, 
    bcm_port_t *links, 
    uint32 *links_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_thresholds_retrieve_dispatch[dtype](unit, fifo_type, links_count_max, links, links_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,links);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_thresholds_retrieve", 5, 3, unit, fifo_type, links_count_max, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_thresholds_set( \
    int unit, int fifo_type, uint32 count, bcm_fabric_link_threshold_type_t *type, int *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_thresholds_set,
static int (*_fabric_link_thresholds_set_dispatch[])(
    int unit, 
    int fifo_type, 
    uint32 count, 
    bcm_fabric_link_threshold_type_t *type, 
    int *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_thresholds_set(
    int unit, 
    int fifo_type, 
    uint32 count, 
    bcm_fabric_link_threshold_type_t *type, 
    int *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_thresholds_set_dispatch[dtype](unit, fifo_type, count, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_thresholds_set", 5, 3, unit, fifo_type, count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_topology_get( \
    int unit, bcm_module_t destination, int max_links_count, int *links_count, bcm_port_t *links_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_topology_get,
static int (*_fabric_link_topology_get_dispatch[])(
    int unit, 
    bcm_module_t destination, 
    int max_links_count, 
    int *links_count, 
    bcm_port_t *links_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_topology_get(
    int unit, 
    bcm_module_t destination, 
    int max_links_count, 
    int *links_count, 
    bcm_port_t *links_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_topology_get_dispatch[dtype](unit, destination, max_links_count, links_count, links_array);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,links_array);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_topology_get", 5, 3, unit, destination, max_links_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_link_topology_set( \
    int unit, bcm_module_t destination, int links_count, bcm_port_t *links_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_link_topology_set,
static int (*_fabric_link_topology_set_dispatch[])(
    int unit, 
    bcm_module_t destination, 
    int links_count, 
    bcm_port_t *links_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_link_topology_set(
    int unit, 
    bcm_module_t destination, 
    int links_count, 
    bcm_port_t *links_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_ITER(links_count,idx)
			BCM_API_XLATE_PORT_COND(links_array) BCM_API_XLATE_PORT_A2P(unit,&(links_array)[idx]);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_link_topology_set_dispatch[dtype](unit, destination, links_count, links_array);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_ITER(links_count,idx)
			BCM_API_XLATE_PORT_COND(links_array) BCM_API_XLATE_PORT_P2A(unit,&(links_array)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_link_topology_set", 4, 3, unit, destination, links_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_modid_group_find( \
    int unit, bcm_module_t modid, bcm_module_t *group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_modid_group_find,
static int (*_fabric_modid_group_find_dispatch[])(
    int unit, 
    bcm_module_t modid, 
    bcm_module_t *group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_modid_group_find(
    int unit, 
    bcm_module_t modid, 
    bcm_module_t *group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_modid_group_find_dispatch[dtype](unit, modid, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_modid_group_find", 3, 2, unit, modid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_modid_group_get( \
    int unit, bcm_module_t group, int modid_max_count, bcm_module_t *modid_array, int *modid_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_modid_group_get,
static int (*_fabric_modid_group_get_dispatch[])(
    int unit, 
    bcm_module_t group, 
    int modid_max_count, 
    bcm_module_t *modid_array, 
    int *modid_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_modid_group_get(
    int unit, 
    bcm_module_t group, 
    int modid_max_count, 
    bcm_module_t *modid_array, 
    int *modid_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_modid_group_get_dispatch[dtype](unit, group, modid_max_count, modid_array, modid_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_modid_group_get", 5, 3, unit, group, modid_max_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_modid_group_set( \
    int unit, bcm_module_t group, int modid_count, bcm_module_t *modid_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_modid_group_set,
static int (*_fabric_modid_group_set_dispatch[])(
    int unit, 
    bcm_module_t group, 
    int modid_count, 
    bcm_module_t *modid_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_modid_group_set(
    int unit, 
    bcm_module_t group, 
    int modid_count, 
    bcm_module_t *modid_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_modid_group_set_dispatch[dtype](unit, group, modid_count, modid_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_modid_group_set", 4, 3, unit, group, modid_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_modid_local_mapping_get( \
    int unit, bcm_module_t local_modid, bcm_module_t *modid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_modid_local_mapping_get,
static int (*_fabric_modid_local_mapping_get_dispatch[])(
    int unit, 
    bcm_module_t local_modid, 
    bcm_module_t *modid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_modid_local_mapping_get(
    int unit, 
    bcm_module_t local_modid, 
    bcm_module_t *modid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_modid_local_mapping_get_dispatch[dtype](unit, local_modid, modid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_modid_local_mapping_get", 3, 2, unit, local_modid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_modid_local_mapping_set( \
    int unit, bcm_module_t local_modid, bcm_module_t modid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_modid_local_mapping_set,
static int (*_fabric_modid_local_mapping_set_dispatch[])(
    int unit, 
    bcm_module_t local_modid, 
    bcm_module_t modid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_modid_local_mapping_set(
    int unit, 
    bcm_module_t local_modid, 
    bcm_module_t modid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_modid_local_mapping_set_dispatch[dtype](unit, local_modid, modid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_modid_local_mapping_set", 3, 3, unit, local_modid, modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_multicast_get( \
    int unit, bcm_multicast_t group, uint32 flags, int destid_count_max, int *destid_count, bcm_module_t *destid_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_multicast_get,
static int (*_fabric_multicast_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    uint32 flags, 
    int destid_count_max, 
    int *destid_count, 
    bcm_module_t *destid_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_multicast_get(
    int unit, 
    bcm_multicast_t group, 
    uint32 flags, 
    int destid_count_max, 
    int *destid_count, 
    bcm_module_t *destid_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_multicast_get_dispatch[dtype](unit, group, flags, destid_count_max, destid_count, destid_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_multicast_get", 6, 3, unit, group, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_multicast_multi_get( \
    int unit, uint32 flags, uint32 ngroups, bcm_multicast_t *groups, bcm_fabric_module_vector_t *dest_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_multicast_multi_get,
static int (*_fabric_multicast_multi_get_dispatch[])(
    int unit, 
    uint32 flags, 
    uint32 ngroups, 
    bcm_multicast_t *groups, 
    bcm_fabric_module_vector_t *dest_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_multicast_multi_get(
    int unit, 
    uint32 flags, 
    uint32 ngroups, 
    bcm_multicast_t *groups, 
    bcm_fabric_module_vector_t *dest_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_multicast_multi_get_dispatch[dtype](unit, flags, ngroups, groups, dest_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_multicast_multi_get", 5, 3, unit, flags, ngroups, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_multicast_multi_set( \
    int unit, uint32 flags, uint32 ngroups, bcm_multicast_t *groups, bcm_fabric_module_vector_t *dest_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_multicast_multi_set,
static int (*_fabric_multicast_multi_set_dispatch[])(
    int unit, 
    uint32 flags, 
    uint32 ngroups, 
    bcm_multicast_t *groups, 
    bcm_fabric_module_vector_t *dest_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_multicast_multi_set(
    int unit, 
    uint32 flags, 
    uint32 ngroups, 
    bcm_multicast_t *groups, 
    bcm_fabric_module_vector_t *dest_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_multicast_multi_set_dispatch[dtype](unit, flags, ngroups, groups, dest_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_multicast_multi_set", 5, 3, unit, flags, ngroups, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_multicast_set( \
    int unit, bcm_multicast_t group, uint32 flags, uint32 destid_count, bcm_module_t *destid_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_multicast_set,
static int (*_fabric_multicast_set_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    uint32 flags, 
    uint32 destid_count, 
    bcm_module_t *destid_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_multicast_set(
    int unit, 
    bcm_multicast_t group, 
    uint32 flags, 
    uint32 destid_count, 
    bcm_module_t *destid_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_multicast_set_dispatch[dtype](unit, group, flags, destid_count, destid_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_multicast_set", 5, 3, unit, group, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_operating_interval_get( \
    int unit, int link_fail_count, int *operating_interval);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_operating_interval_get,
static int (*_fabric_operating_interval_get_dispatch[])(
    int unit, 
    int link_fail_count, 
    int *operating_interval) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_operating_interval_get(
    int unit, 
    int link_fail_count, 
    int *operating_interval)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_operating_interval_get_dispatch[dtype](unit, link_fail_count, operating_interval);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_operating_interval_get", 3, 2, unit, link_fail_count, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_packet_adjust_get( \
    int unit, int pkt_adjust_selector, int *pkt_adjust_len);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_packet_adjust_get,
static int (*_fabric_packet_adjust_get_dispatch[])(
    int unit, 
    int pkt_adjust_selector, 
    int *pkt_adjust_len) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_packet_adjust_get(
    int unit, 
    int pkt_adjust_selector, 
    int *pkt_adjust_len)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_packet_adjust_get_dispatch[dtype](unit, pkt_adjust_selector, pkt_adjust_len);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_packet_adjust_get", 3, 2, unit, pkt_adjust_selector, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_packet_adjust_set( \
    int unit, int pkt_adjust_selector, int pkt_adjust_len);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_packet_adjust_set,
static int (*_fabric_packet_adjust_set_dispatch[])(
    int unit, 
    int pkt_adjust_selector, 
    int pkt_adjust_len) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_packet_adjust_set(
    int unit, 
    int pkt_adjust_selector, 
    int pkt_adjust_len)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_packet_adjust_set_dispatch[dtype](unit, pkt_adjust_selector, pkt_adjust_len);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_packet_adjust_set", 3, 3, unit, pkt_adjust_selector, pkt_adjust_len, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_pcp_dest_mode_config_get( \
    int unit, uint32 flags, bcm_module_t modid, bcm_fabric_pcp_mode_config_t *pcp_config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_pcp_dest_mode_config_get,
static int (*_fabric_pcp_dest_mode_config_get_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_module_t modid, 
    bcm_fabric_pcp_mode_config_t *pcp_config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_pcp_dest_mode_config_get(
    int unit, 
    uint32 flags, 
    bcm_module_t modid, 
    bcm_fabric_pcp_mode_config_t *pcp_config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_pcp_dest_mode_config_get_dispatch[dtype](unit, flags, modid, pcp_config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_pcp_dest_mode_config_get", 4, 3, unit, flags, modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_pcp_dest_mode_config_set( \
    int unit, uint32 flags, bcm_module_t modid, bcm_fabric_pcp_mode_config_t *pcp_config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_pcp_dest_mode_config_set,
static int (*_fabric_pcp_dest_mode_config_set_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_module_t modid, 
    bcm_fabric_pcp_mode_config_t *pcp_config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_pcp_dest_mode_config_set(
    int unit, 
    uint32 flags, 
    bcm_module_t modid, 
    bcm_fabric_pcp_mode_config_t *pcp_config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_pcp_dest_mode_config_set_dispatch[dtype](unit, flags, modid, pcp_config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_pcp_dest_mode_config_set", 4, 3, unit, flags, modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_port_create( \
    int unit, bcm_gport_t parent_port, int offset, uint32 flags, bcm_gport_t *port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_port_create,
static int (*_fabric_port_create_dispatch[])(
    int unit, 
    bcm_gport_t parent_port, 
    int offset, 
    uint32 flags, 
    bcm_gport_t *port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_port_create(
    int unit, 
    bcm_gport_t parent_port, 
    int offset, 
    uint32 flags, 
    bcm_gport_t *port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&parent_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_port_create_dispatch[dtype](unit, parent_port, offset, flags, port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_port_create", 5, 3, unit, parent_port, offset, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_port_destroy( \
    int unit, bcm_gport_t parent_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_port_destroy,
static int (*_fabric_port_destroy_dispatch[])(
    int unit, 
    bcm_gport_t parent_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_port_destroy(
    int unit, 
    bcm_gport_t parent_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&parent_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_port_destroy_dispatch[dtype](unit, parent_port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_port_destroy", 2, 2, unit, parent_port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_port_failover_get( \
    int unit, bcm_gport_t port, bcm_failover_t *failover_id, bcm_gport_t *failover_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_port_failover_get,
static int (*_fabric_port_failover_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_failover_t *failover_id, 
    bcm_gport_t *failover_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_port_failover_get(
    int unit, 
    bcm_gport_t port, 
    bcm_failover_t *failover_id, 
    bcm_gport_t *failover_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_port_failover_get_dispatch[dtype](unit, port, failover_id, failover_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,failover_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_port_failover_get", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_port_failover_set( \
    int unit, bcm_gport_t port, bcm_failover_t failover_id, bcm_gport_t failover_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_port_failover_set,
static int (*_fabric_port_failover_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_failover_t failover_id, 
    bcm_gport_t failover_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_port_failover_set(
    int unit, 
    bcm_gport_t port, 
    bcm_failover_t failover_id, 
    bcm_gport_t failover_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&failover_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_port_failover_set_dispatch[dtype](unit, port, failover_id, failover_port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_port_failover_set", 4, 3, unit, port, failover_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_port_get( \
    int unit, bcm_gport_t child_port, uint32 flags, bcm_gport_t *parent_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_port_get,
static int (*_fabric_port_get_dispatch[])(
    int unit, 
    bcm_gport_t child_port, 
    uint32 flags, 
    bcm_gport_t *parent_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_port_get(
    int unit, 
    bcm_gport_t child_port, 
    uint32 flags, 
    bcm_gport_t *parent_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&child_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_port_get_dispatch[dtype](unit, child_port, flags, parent_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,parent_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_port_get", 4, 3, unit, child_port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_predicate_action_create( \
    int unit, bcm_fabric_predicate_action_info_t *predicate_action, bcm_fabric_predicate_action_t *predicate_action_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_predicate_action_create,
static int (*_fabric_predicate_action_create_dispatch[])(
    int unit, 
    bcm_fabric_predicate_action_info_t *predicate_action, 
    bcm_fabric_predicate_action_t *predicate_action_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_predicate_action_create(
    int unit, 
    bcm_fabric_predicate_action_info_t *predicate_action, 
    bcm_fabric_predicate_action_t *predicate_action_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_predicate_action_create_dispatch[dtype](unit, predicate_action, predicate_action_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_predicate_action_create", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_predicate_action_destroy( \
    int unit, bcm_fabric_predicate_action_t predicate_action_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_predicate_action_destroy,
static int (*_fabric_predicate_action_destroy_dispatch[])(
    int unit, 
    bcm_fabric_predicate_action_t predicate_action_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_predicate_action_destroy(
    int unit, 
    bcm_fabric_predicate_action_t predicate_action_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_predicate_action_destroy_dispatch[dtype](unit, predicate_action_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_predicate_action_destroy", 2, 2, unit, predicate_action_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_predicate_action_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_predicate_action_destroy_all,
static int (*_fabric_predicate_action_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_predicate_action_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_predicate_action_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_predicate_action_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_predicate_action_get( \
    int unit, bcm_fabric_predicate_action_t predicate_action_id, bcm_fabric_predicate_action_info_t *predicate_action_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_predicate_action_get,
static int (*_fabric_predicate_action_get_dispatch[])(
    int unit, 
    bcm_fabric_predicate_action_t predicate_action_id, 
    bcm_fabric_predicate_action_info_t *predicate_action_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_predicate_action_get(
    int unit, 
    bcm_fabric_predicate_action_t predicate_action_id, 
    bcm_fabric_predicate_action_info_t *predicate_action_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_predicate_action_get_dispatch[dtype](unit, predicate_action_id, predicate_action_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_predicate_action_get", 3, 2, unit, predicate_action_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_predicate_action_traverse( \
    int unit, bcm_fabric_predicate_action_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_predicate_action_traverse,
static int (*_fabric_predicate_action_traverse_dispatch[])(
    int unit, 
    bcm_fabric_predicate_action_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_predicate_action_traverse(
    int unit, 
    bcm_fabric_predicate_action_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_predicate_action_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_predicate_action_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_predicate_create( \
    int unit, bcm_fabric_predicate_info_t *pred_info, bcm_fabric_predicate_t *pred_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_predicate_create,
static int (*_fabric_predicate_create_dispatch[])(
    int unit, 
    bcm_fabric_predicate_info_t *pred_info, 
    bcm_fabric_predicate_t *pred_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_predicate_create(
    int unit, 
    bcm_fabric_predicate_info_t *pred_info, 
    bcm_fabric_predicate_t *pred_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_predicate_create_dispatch[dtype](unit, pred_info, pred_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_predicate_create", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_predicate_destroy( \
    int unit, bcm_fabric_predicate_t pred_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_predicate_destroy,
static int (*_fabric_predicate_destroy_dispatch[])(
    int unit, 
    bcm_fabric_predicate_t pred_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_predicate_destroy(
    int unit, 
    bcm_fabric_predicate_t pred_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_predicate_destroy_dispatch[dtype](unit, pred_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_predicate_destroy", 2, 2, unit, pred_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_predicate_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_predicate_destroy_all,
static int (*_fabric_predicate_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_predicate_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_predicate_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_predicate_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_predicate_get( \
    int unit, bcm_fabric_predicate_t pred_id, bcm_fabric_predicate_info_t *pred_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_predicate_get,
static int (*_fabric_predicate_get_dispatch[])(
    int unit, 
    bcm_fabric_predicate_t pred_id, 
    bcm_fabric_predicate_info_t *pred_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_predicate_get(
    int unit, 
    bcm_fabric_predicate_t pred_id, 
    bcm_fabric_predicate_info_t *pred_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_predicate_get_dispatch[dtype](unit, pred_id, pred_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_predicate_get", 3, 2, unit, pred_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_predicate_traverse( \
    int unit, bcm_fabric_predicate_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_predicate_traverse,
static int (*_fabric_predicate_traverse_dispatch[])(
    int unit, 
    bcm_fabric_predicate_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_predicate_traverse(
    int unit, 
    bcm_fabric_predicate_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_predicate_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_predicate_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_priority_get( \
    int unit, uint32 flags, bcm_cos_t ingress_pri, bcm_color_t color, int *fabric_priority);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_priority_get,
static int (*_fabric_priority_get_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_cos_t ingress_pri, 
    bcm_color_t color, 
    int *fabric_priority) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_priority_get(
    int unit, 
    uint32 flags, 
    bcm_cos_t ingress_pri, 
    bcm_color_t color, 
    int *fabric_priority)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_priority_get_dispatch[dtype](unit, flags, ingress_pri, color, fabric_priority);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_priority_get", 5, 3, unit, flags, ingress_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_priority_set( \
    int unit, uint32 flags, bcm_cos_t ingress_pri, bcm_color_t color, int fabric_priority);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_priority_set,
static int (*_fabric_priority_set_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_cos_t ingress_pri, 
    bcm_color_t color, 
    int fabric_priority) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_priority_set(
    int unit, 
    uint32 flags, 
    bcm_cos_t ingress_pri, 
    bcm_color_t color, 
    int fabric_priority)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_priority_set_dispatch[dtype](unit, flags, ingress_pri, color, fabric_priority);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_priority_set", 5, 3, unit, flags, ingress_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_create( \
    int unit, uint32 flags, int base, int count, bcm_fabric_qsel_t *qsel_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_create,
static int (*_fabric_qsel_create_dispatch[])(
    int unit, 
    uint32 flags, 
    int base, 
    int count, 
    bcm_fabric_qsel_t *qsel_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_create(
    int unit, 
    uint32 flags, 
    int base, 
    int count, 
    bcm_fabric_qsel_t *qsel_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_create_dispatch[dtype](unit, flags, base, count, qsel_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_create", 5, 3, unit, flags, base, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_destroy( \
    int unit, bcm_fabric_qsel_t qsel_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_destroy,
static int (*_fabric_qsel_destroy_dispatch[])(
    int unit, 
    bcm_fabric_qsel_t qsel_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_destroy(
    int unit, 
    bcm_fabric_qsel_t qsel_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_destroy_dispatch[dtype](unit, qsel_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_destroy", 2, 2, unit, qsel_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_destroy_all,
static int (*_fabric_qsel_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_entry_get( \
    int unit, bcm_fabric_qsel_t qsel_id, int offset, bcm_gport_t *queue, bcm_fabric_qsel_offset_t *qsel_offset_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_entry_get,
static int (*_fabric_qsel_entry_get_dispatch[])(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    bcm_gport_t *queue, 
    bcm_fabric_qsel_offset_t *qsel_offset_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_entry_get(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    bcm_gport_t *queue, 
    bcm_fabric_qsel_offset_t *qsel_offset_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_entry_get_dispatch[dtype](unit, qsel_id, offset, queue, qsel_offset_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,queue);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_entry_get", 5, 3, unit, qsel_id, offset, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_entry_multi_get( \
    int unit, bcm_fabric_qsel_t qsel_id, int offset, int count, bcm_gport_t *queue, bcm_fabric_qsel_offset_t *qsel_offset_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_entry_multi_get,
static int (*_fabric_qsel_entry_multi_get_dispatch[])(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    int count, 
    bcm_gport_t *queue, 
    bcm_fabric_qsel_offset_t *qsel_offset_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_entry_multi_get(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    int count, 
    bcm_gport_t *queue, 
    bcm_fabric_qsel_offset_t *qsel_offset_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_entry_multi_get_dispatch[dtype](unit, qsel_id, offset, count, queue, qsel_offset_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(count,idx)
				BCM_API_XLATE_PORT_COND(queue) BCM_API_XLATE_PORT_P2A(unit,&(queue)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_entry_multi_get", 6, 3, unit, qsel_id, offset, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_entry_multi_set( \
    int unit, bcm_fabric_qsel_t qsel_id, int offset, int count, bcm_gport_t *queue, bcm_fabric_qsel_offset_t *qsel_offset_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_entry_multi_set,
static int (*_fabric_qsel_entry_multi_set_dispatch[])(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    int count, 
    bcm_gport_t *queue, 
    bcm_fabric_qsel_offset_t *qsel_offset_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_entry_multi_set(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    int count, 
    bcm_gport_t *queue, 
    bcm_fabric_qsel_offset_t *qsel_offset_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_ITER(count,idx)
			BCM_API_XLATE_PORT_COND(queue) BCM_API_XLATE_PORT_A2P(unit,&(queue)[idx]);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_entry_multi_set_dispatch[dtype](unit, qsel_id, offset, count, queue, qsel_offset_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_ITER(count,idx)
			BCM_API_XLATE_PORT_COND(queue) BCM_API_XLATE_PORT_P2A(unit,&(queue)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_entry_multi_set", 6, 3, unit, qsel_id, offset, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_entry_set( \
    int unit, bcm_fabric_qsel_t qsel_id, int offset, bcm_gport_t queue, bcm_fabric_qsel_offset_t qsel_offset_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_entry_set,
static int (*_fabric_qsel_entry_set_dispatch[])(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    bcm_gport_t queue, 
    bcm_fabric_qsel_offset_t qsel_offset_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_entry_set(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    bcm_gport_t queue, 
    bcm_fabric_qsel_offset_t qsel_offset_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&queue);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_entry_set_dispatch[dtype](unit, qsel_id, offset, queue, qsel_offset_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_entry_set", 5, 3, unit, qsel_id, offset, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_entry_traverse( \
    int unit, bcm_fabric_qsel_t qsel_id, bcm_fabric_qsel_entry_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_entry_traverse,
static int (*_fabric_qsel_entry_traverse_dispatch[])(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    bcm_fabric_qsel_entry_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_entry_traverse(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    bcm_fabric_qsel_entry_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_entry_traverse_dispatch[dtype](unit, qsel_id, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_entry_traverse", 4, 2, unit, qsel_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_get( \
    int unit, bcm_fabric_qsel_t qsel_id, uint32 *flags, int *base, int *count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_get,
static int (*_fabric_qsel_get_dispatch[])(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    uint32 *flags, 
    int *base, 
    int *count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_get(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    uint32 *flags, 
    int *base, 
    int *count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_get_dispatch[dtype](unit, qsel_id, flags, base, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_get", 5, 2, unit, qsel_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_offset_create( \
    int unit, uint32 flags, bcm_fabric_qsel_offset_t *qsel_offset_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_offset_create,
static int (*_fabric_qsel_offset_create_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_fabric_qsel_offset_t *qsel_offset_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_offset_create(
    int unit, 
    uint32 flags, 
    bcm_fabric_qsel_offset_t *qsel_offset_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_offset_create_dispatch[dtype](unit, flags, qsel_offset_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_offset_create", 3, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_offset_destroy( \
    int unit, bcm_fabric_qsel_offset_t qsel_offset_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_offset_destroy,
static int (*_fabric_qsel_offset_destroy_dispatch[])(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_offset_destroy(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_offset_destroy_dispatch[dtype](unit, qsel_offset_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_offset_destroy", 2, 2, unit, qsel_offset_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_offset_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_offset_destroy_all,
static int (*_fabric_qsel_offset_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_offset_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_offset_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_offset_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_offset_entry_get( \
    int unit, bcm_fabric_qsel_offset_t qsel_offset_id, bcm_cos_t int_pri, int *offset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_offset_entry_get,
static int (*_fabric_qsel_offset_entry_get_dispatch[])(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    bcm_cos_t int_pri, 
    int *offset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_offset_entry_get(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    bcm_cos_t int_pri, 
    int *offset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_offset_entry_get_dispatch[dtype](unit, qsel_offset_id, int_pri, offset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_offset_entry_get", 4, 3, unit, qsel_offset_id, int_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_offset_entry_set( \
    int unit, bcm_fabric_qsel_offset_t qsel_offset_id, bcm_cos_t int_pri, int offset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_offset_entry_set,
static int (*_fabric_qsel_offset_entry_set_dispatch[])(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    bcm_cos_t int_pri, 
    int offset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_offset_entry_set(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    bcm_cos_t int_pri, 
    int offset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_offset_entry_set_dispatch[dtype](unit, qsel_offset_id, int_pri, offset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_offset_entry_set", 4, 3, unit, qsel_offset_id, int_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_offset_entry_traverse( \
    int unit, bcm_fabric_qsel_offset_t qsel_offset_id, bcm_fabric_qsel_offset_entry_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_offset_entry_traverse,
static int (*_fabric_qsel_offset_entry_traverse_dispatch[])(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    bcm_fabric_qsel_offset_entry_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_offset_entry_traverse(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    bcm_fabric_qsel_offset_entry_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_offset_entry_traverse_dispatch[dtype](unit, qsel_offset_id, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_offset_entry_traverse", 4, 2, unit, qsel_offset_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_offset_traverse( \
    int unit, bcm_fabric_qsel_offset_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_offset_traverse,
static int (*_fabric_qsel_offset_traverse_dispatch[])(
    int unit, 
    bcm_fabric_qsel_offset_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_offset_traverse(
    int unit, 
    bcm_fabric_qsel_offset_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_offset_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_offset_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_qsel_traverse( \
    int unit, bcm_fabric_qsel_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_qsel_traverse,
static int (*_fabric_qsel_traverse_dispatch[])(
    int unit, 
    bcm_fabric_qsel_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_qsel_traverse(
    int unit, 
    bcm_fabric_qsel_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_qsel_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_qsel_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_reachability_status_get( \
    int unit, int moduleid, int links_max, uint32 *links_array, int *links_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_reachability_status_get,
static int (*_fabric_reachability_status_get_dispatch[])(
    int unit, 
    int moduleid, 
    int links_max, 
    uint32 *links_array, 
    int *links_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_reachability_status_get(
    int unit, 
    int moduleid, 
    int links_max, 
    uint32 *links_array, 
    int *links_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_reachability_status_get_dispatch[dtype](unit, moduleid, links_max, links_array, links_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_reachability_status_get", 5, 3, unit, moduleid, links_max, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_route_rx( \
    int unit, uint32 flags, uint32 data_out_max_size, uint32 *data_out, uint32 *data_out_size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_route_rx,
static int (*_fabric_route_rx_dispatch[])(
    int unit, 
    uint32 flags, 
    uint32 data_out_max_size, 
    uint32 *data_out, 
    uint32 *data_out_size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_route_rx(
    int unit, 
    uint32 flags, 
    uint32 data_out_max_size, 
    uint32 *data_out, 
    uint32 *data_out_size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_route_rx_dispatch[dtype](unit, flags, data_out_max_size, data_out, data_out_size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_route_rx", 5, 3, unit, flags, data_out_max_size, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_route_tx( \
    int unit, uint32 flags, bcm_fabric_route_t *route, uint32 data_in_size, uint32 *data_in);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_route_tx,
static int (*_fabric_route_tx_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_fabric_route_t *route, 
    uint32 data_in_size, 
    uint32 *data_in) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_route_tx(
    int unit, 
    uint32 flags, 
    bcm_fabric_route_t *route, 
    uint32 data_in_size, 
    uint32 *data_in)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_route_tx_dispatch[dtype](unit, flags, route, data_in_size, data_in);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_route_tx", 5, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_tdm_direct_routing_get( \
    int unit, bcm_gport_t gport, bcm_fabric_tdm_direct_routing_t *routing_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_tdm_direct_routing_get,
static int (*_fabric_tdm_direct_routing_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_fabric_tdm_direct_routing_t *routing_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_tdm_direct_routing_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_fabric_tdm_direct_routing_t *routing_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_tdm_direct_routing_get_dispatch[dtype](unit, gport, routing_info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(BCM_FABRIC_TDM_MAX_LINKS,idx)
				BCM_API_XLATE_PORT_COND(routing_info) BCM_API_XLATE_PORT_P2A(unit,&(routing_info)[idx].links);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_tdm_direct_routing_get", 3, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_tdm_direct_routing_set( \
    int unit, bcm_gport_t gport, bcm_fabric_tdm_direct_routing_t *routing_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_tdm_direct_routing_set,
static int (*_fabric_tdm_direct_routing_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_fabric_tdm_direct_routing_t *routing_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_tdm_direct_routing_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_fabric_tdm_direct_routing_t *routing_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		BCM_API_XLATE_PORT_ITER(BCM_FABRIC_TDM_MAX_LINKS,idx)
			BCM_API_XLATE_PORT_COND(routing_info) BCM_API_XLATE_PORT_A2P(unit,&(routing_info)[idx].links);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_tdm_direct_routing_set_dispatch[dtype](unit, gport, routing_info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_ITER(BCM_FABRIC_TDM_MAX_LINKS,idx)
			BCM_API_XLATE_PORT_COND(routing_info) BCM_API_XLATE_PORT_P2A(unit,&(routing_info)[idx].links);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_tdm_direct_routing_set", 3, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_tdm_editing_get( \
    int unit, bcm_gport_t gport, bcm_fabric_tdm_editing_t *editing);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_tdm_editing_get,
static int (*_fabric_tdm_editing_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_fabric_tdm_editing_t *editing) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_tdm_editing_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_fabric_tdm_editing_t *editing)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		BCM_API_XLATE_PORT_COND(editing) BCM_API_XLATE_PORT_A2P(unit,&editing->destination_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_tdm_editing_get_dispatch[dtype](unit, gport, editing);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(editing) BCM_API_XLATE_PORT_P2A(unit,&editing->destination_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_tdm_editing_get", 3, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_tdm_editing_set( \
    int unit, bcm_gport_t gport, bcm_fabric_tdm_editing_t *editing);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_tdm_editing_set,
static int (*_fabric_tdm_editing_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_fabric_tdm_editing_t *editing) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_tdm_editing_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_fabric_tdm_editing_t *editing)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(editing_destination_port);
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		BCM_API_XLATE_PORT_COND(editing) BCM_API_XLATE_PORT_SAVE(editing_destination_port,editing->destination_port);
		BCM_API_XLATE_PORT_COND(editing) BCM_API_XLATE_PORT_A2P(unit,&editing->destination_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_tdm_editing_set_dispatch[dtype](unit, gport, editing);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(editing) BCM_API_XLATE_PORT_RESTORE(editing->destination_port,editing_destination_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_tdm_editing_set", 3, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_tdm_enable_get( \
    int unit, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_tdm_enable_get,
static int (*_fabric_tdm_enable_get_dispatch[])(
    int unit, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_tdm_enable_get(
    int unit, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_tdm_enable_get_dispatch[dtype](unit, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_tdm_enable_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fabric_tdm_enable_set( \
    int unit, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fabric_tdm_enable_set,
static int (*_fabric_tdm_enable_set_dispatch[])(
    int unit, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fabric_tdm_enable_set(
    int unit, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fabric_tdm_enable_set_dispatch[dtype](unit, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fabric_tdm_enable_set", 2, 2, unit, enable, 0, r_rv);
	return r_rv;
}

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_failover_cleanup( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_failover_cleanup,
static int (*_failover_cleanup_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_failover_cleanup(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _failover_cleanup_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_failover_cleanup", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_failover_create( \
    int unit, uint32 flags, bcm_failover_t *failover_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_failover_create,
static int (*_failover_create_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_failover_t *failover_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_failover_create(
    int unit, 
    uint32 flags, 
    bcm_failover_t *failover_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _failover_create_dispatch[dtype](unit, flags, failover_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_failover_create", 3, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_failover_destroy( \
    int unit, bcm_failover_t failover_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_failover_destroy,
static int (*_failover_destroy_dispatch[])(
    int unit, 
    bcm_failover_t failover_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_failover_destroy(
    int unit, 
    bcm_failover_t failover_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _failover_destroy_dispatch[dtype](unit, failover_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_failover_destroy", 2, 2, unit, failover_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_failover_get( \
    int unit, bcm_failover_t failover_id, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_failover_get,
static int (*_failover_get_dispatch[])(
    int unit, 
    bcm_failover_t failover_id, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_failover_get(
    int unit, 
    bcm_failover_t failover_id, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _failover_get_dispatch[dtype](unit, failover_id, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_failover_get", 3, 2, unit, failover_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_failover_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_failover_init,
static int (*_failover_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_failover_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _failover_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_failover_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_failover_ring_config_get( \
    int unit, bcm_failover_ring_t *failover_ring);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_failover_ring_config_get,
static int (*_failover_ring_config_get_dispatch[])(
    int unit, 
    bcm_failover_ring_t *failover_ring) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_failover_ring_config_get(
    int unit, 
    bcm_failover_ring_t *failover_ring)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(failover_ring_port0);
		BCM_API_XLATE_PORT_DECL(failover_ring_port1);
		BCM_API_XLATE_PORT_COND(failover_ring) BCM_API_XLATE_PORT_SAVE(failover_ring_port0,failover_ring->port0);
		BCM_API_XLATE_PORT_COND(failover_ring) BCM_API_XLATE_PORT_A2P(unit,&failover_ring->port0);
		BCM_API_XLATE_PORT_COND(failover_ring) BCM_API_XLATE_PORT_SAVE(failover_ring_port1,failover_ring->port1);
		BCM_API_XLATE_PORT_COND(failover_ring) BCM_API_XLATE_PORT_A2P(unit,&failover_ring->port1);
		dtype = BCM_DTYPE(unit);
		r_rv = _failover_ring_config_get_dispatch[dtype](unit, failover_ring);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(failover_ring) BCM_API_XLATE_PORT_RESTORE(failover_ring->port0,failover_ring_port0);
		BCM_API_XLATE_PORT_COND(failover_ring) BCM_API_XLATE_PORT_RESTORE(failover_ring->port1,failover_ring_port1);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_failover_ring_config_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_failover_ring_config_set( \
    int unit, bcm_failover_ring_t *failover_ring);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_failover_ring_config_set,
static int (*_failover_ring_config_set_dispatch[])(
    int unit, 
    bcm_failover_ring_t *failover_ring) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_failover_ring_config_set(
    int unit, 
    bcm_failover_ring_t *failover_ring)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(failover_ring_port0);
		BCM_API_XLATE_PORT_DECL(failover_ring_port1);
		BCM_API_XLATE_PORT_COND(failover_ring) BCM_API_XLATE_PORT_SAVE(failover_ring_port0,failover_ring->port0);
		BCM_API_XLATE_PORT_COND(failover_ring) BCM_API_XLATE_PORT_A2P(unit,&failover_ring->port0);
		BCM_API_XLATE_PORT_COND(failover_ring) BCM_API_XLATE_PORT_SAVE(failover_ring_port1,failover_ring->port1);
		BCM_API_XLATE_PORT_COND(failover_ring) BCM_API_XLATE_PORT_A2P(unit,&failover_ring->port1);
		dtype = BCM_DTYPE(unit);
		r_rv = _failover_ring_config_set_dispatch[dtype](unit, failover_ring);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(failover_ring) BCM_API_XLATE_PORT_RESTORE(failover_ring->port0,failover_ring_port0);
		BCM_API_XLATE_PORT_COND(failover_ring) BCM_API_XLATE_PORT_RESTORE(failover_ring->port1,failover_ring_port1);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_failover_ring_config_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_failover_set( \
    int unit, bcm_failover_t failover_id, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_failover_set,
static int (*_failover_set_dispatch[])(
    int unit, 
    bcm_failover_t failover_id, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_failover_set(
    int unit, 
    bcm_failover_t failover_id, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _failover_set_dispatch[dtype](unit, failover_id, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_failover_set", 3, 3, unit, failover_id, enable, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_failover_status_get( \
    int unit, bcm_failover_element_t *failover, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_failover_status_get,
static int (*_failover_status_get_dispatch[])(
    int unit, 
    bcm_failover_element_t *failover, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_failover_status_get(
    int unit, 
    bcm_failover_element_t *failover, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(failover_port);
		BCM_API_XLATE_PORT_COND(failover) BCM_API_XLATE_PORT_SAVE(failover_port,failover->port);
		BCM_API_XLATE_PORT_COND(failover) BCM_API_XLATE_PORT_A2P(unit,&failover->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _failover_status_get_dispatch[dtype](unit, failover, enable);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(failover) BCM_API_XLATE_PORT_RESTORE(failover->port,failover_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_failover_status_get", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_failover_status_set( \
    int unit, bcm_failover_element_t *failover, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_failover_status_set,
static int (*_failover_status_set_dispatch[])(
    int unit, 
    bcm_failover_element_t *failover, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_failover_status_set(
    int unit, 
    bcm_failover_element_t *failover, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(failover_port);
		BCM_API_XLATE_PORT_COND(failover) BCM_API_XLATE_PORT_SAVE(failover_port,failover->port);
		BCM_API_XLATE_PORT_COND(failover) BCM_API_XLATE_PORT_A2P(unit,&failover->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _failover_status_set_dispatch[dtype](unit, failover, enable);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(failover) BCM_API_XLATE_PORT_RESTORE(failover->port,failover_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_failover_status_set", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_diag_get( \
    int unit, bcm_port_t port, bcm_fcmap_diag_code_t *diag);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_diag_get,
static int (*_fcmap_diag_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_diag_code_t *diag) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_diag_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_diag_code_t *diag)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_diag_get_dispatch[dtype](unit, port, diag);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_diag_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_event_enable_get( \
    int unit, bcm_fcmap_event_t t, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_event_enable_get,
static int (*_fcmap_event_enable_get_dispatch[])(
    int unit, 
    bcm_fcmap_event_t t, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_event_enable_get(
    int unit, 
    bcm_fcmap_event_t t, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_event_enable_get_dispatch[dtype](unit, t, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_event_enable_get", 3, 2, unit, t, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_event_enable_set( \
    int unit, bcm_fcmap_event_t t, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_event_enable_set,
static int (*_fcmap_event_enable_set_dispatch[])(
    int unit, 
    bcm_fcmap_event_t t, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_event_enable_set(
    int unit, 
    bcm_fcmap_event_t t, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_event_enable_set_dispatch[dtype](unit, t, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_event_enable_set", 3, 3, unit, t, enable, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_event_register( \
    int unit, bcm_fcmap_event_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_event_register,
static int (*_fcmap_event_register_dispatch[])(
    int unit, 
    bcm_fcmap_event_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_event_register(
    int unit, 
    bcm_fcmap_event_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_event_register_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_event_register", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_event_unregister( \
    int unit, bcm_fcmap_event_cb cb);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_event_unregister,
static int (*_fcmap_event_unregister_dispatch[])(
    int unit, 
    bcm_fcmap_event_cb cb) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_event_unregister(
    int unit, 
    bcm_fcmap_event_cb cb)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_event_unregister_dispatch[dtype](unit, cb);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_event_unregister", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_linkfault_trigger_rc_get( \
    int unit, bcm_port_t port, bcm_fcmap_lf_tr_t *trigger, bcm_fcmap_lf_rc_t *rc);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_linkfault_trigger_rc_get,
static int (*_fcmap_linkfault_trigger_rc_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_lf_tr_t *trigger, 
    bcm_fcmap_lf_rc_t *rc) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_linkfault_trigger_rc_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_lf_tr_t *trigger, 
    bcm_fcmap_lf_rc_t *rc)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_linkfault_trigger_rc_get_dispatch[dtype](unit, port, trigger, rc);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_linkfault_trigger_rc_get", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_port_config_get( \
    int unit, bcm_port_t port, bcm_fcmap_port_config_t *cfg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_port_config_get,
static int (*_fcmap_port_config_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_config_t *cfg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_port_config_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_config_t *cfg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_port_config_get_dispatch[dtype](unit, port, cfg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_port_config_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_port_config_selective_get( \
    int unit, bcm_port_t port, bcm_fcmap_port_config_t *cfg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_port_config_selective_get,
static int (*_fcmap_port_config_selective_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_config_t *cfg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_port_config_selective_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_config_t *cfg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_port_config_selective_get_dispatch[dtype](unit, port, cfg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_port_config_selective_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_port_config_selective_set( \
    int unit, bcm_port_t port, bcm_fcmap_port_config_t *cfg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_port_config_selective_set,
static int (*_fcmap_port_config_selective_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_config_t *cfg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_port_config_selective_set(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_config_t *cfg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_port_config_selective_set_dispatch[dtype](unit, port, cfg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_port_config_selective_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_port_config_set( \
    int unit, bcm_port_t port, bcm_fcmap_port_config_t *cfg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_port_config_set,
static int (*_fcmap_port_config_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_config_t *cfg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_port_config_set(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_config_t *cfg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_port_config_set_dispatch[dtype](unit, port, cfg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_port_config_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_port_enable( \
    int unit, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_port_enable,
static int (*_fcmap_port_enable_dispatch[])(
    int unit, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_port_enable(
    int unit, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_port_enable_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_port_enable", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_port_link_reset( \
    int unit, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_port_link_reset,
static int (*_fcmap_port_link_reset_dispatch[])(
    int unit, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_port_link_reset(
    int unit, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_port_link_reset_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_port_link_reset", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_port_shutdown( \
    int unit, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_port_shutdown,
static int (*_fcmap_port_shutdown_dispatch[])(
    int unit, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_port_shutdown(
    int unit, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_port_shutdown_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_port_shutdown", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_port_speed_set( \
    int unit, bcm_port_t port, bcm_fcmap_port_speed_t speed);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_port_speed_set,
static int (*_fcmap_port_speed_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_speed_t speed) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_port_speed_set(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_speed_t speed)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_port_speed_set_dispatch[dtype](unit, port, speed);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_port_speed_set", 3, 3, unit, port, speed, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_port_traverse( \
    int unit, bcm_fcmap_port_traverse_cb callbk, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_port_traverse,
static int (*_fcmap_port_traverse_dispatch[])(
    int unit, 
    bcm_fcmap_port_traverse_cb callbk, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_port_traverse(
    int unit, 
    bcm_fcmap_port_traverse_cb callbk, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_port_traverse_dispatch[dtype](unit, callbk, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_port_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_stat_clear( \
    int unit, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_stat_clear,
static int (*_fcmap_stat_clear_dispatch[])(
    int unit, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_stat_clear(
    int unit, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_stat_clear_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_stat_clear", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_stat_get( \
    int unit, bcm_port_t port, bcm_fcmap_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_stat_get,
static int (*_fcmap_stat_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_stat_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_stat_get_dispatch[dtype](unit, port, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_stat_get", 4, 3, unit, port, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_stat_get32( \
    int unit, bcm_port_t port, bcm_fcmap_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_stat_get32,
static int (*_fcmap_stat_get32_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_stat_get32(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_stat_get32_dispatch[dtype](unit, port, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_stat_get32", 4, 3, unit, port, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_vlan_map_add( \
    int unit, bcm_port_t port, bcm_fcmap_vlan_vsan_map_t *vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_vlan_map_add,
static int (*_fcmap_vlan_map_add_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_vlan_vsan_map_t *vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_vlan_map_add(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_vlan_vsan_map_t *vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_vlan_map_add_dispatch[dtype](unit, port, vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_vlan_map_add", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_vlan_map_delete( \
    int unit, bcm_port_t port, bcm_fcmap_vlan_vsan_map_t *vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_vlan_map_delete,
static int (*_fcmap_vlan_map_delete_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_vlan_vsan_map_t *vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_vlan_map_delete(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_vlan_vsan_map_t *vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_vlan_map_delete_dispatch[dtype](unit, port, vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_vlan_map_delete", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_FCMAP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcmap_vlan_map_get( \
    int unit, bcm_port_t port, bcm_fcmap_vlan_vsan_map_t *vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcmap_vlan_map_get,
static int (*_fcmap_vlan_map_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_vlan_vsan_map_t *vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcmap_vlan_map_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_vlan_vsan_map_t *vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcmap_vlan_map_get_dispatch[dtype](unit, port, vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcmap_vlan_map_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_cleanup( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_cleanup,
static int (*_fcoe_cleanup_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_cleanup(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_cleanup_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_cleanup", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_control_vsan_get( \
    int unit, bcm_fcoe_vsan_id_t vsan_id, bcm_fcoe_vsan_control_t type, int *arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_control_vsan_get,
static int (*_fcoe_control_vsan_get_dispatch[])(
    int unit, 
    bcm_fcoe_vsan_id_t vsan_id, 
    bcm_fcoe_vsan_control_t type, 
    int *arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_control_vsan_get(
    int unit, 
    bcm_fcoe_vsan_id_t vsan_id, 
    bcm_fcoe_vsan_control_t type, 
    int *arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_control_vsan_get_dispatch[dtype](unit, vsan_id, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_control_vsan_get", 4, 3, unit, vsan_id, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_control_vsan_set( \
    int unit, bcm_fcoe_vsan_id_t vsan_id, bcm_fcoe_vsan_control_t type, int arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_control_vsan_set,
static int (*_fcoe_control_vsan_set_dispatch[])(
    int unit, 
    bcm_fcoe_vsan_id_t vsan_id, 
    bcm_fcoe_vsan_control_t type, 
    int arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_control_vsan_set(
    int unit, 
    bcm_fcoe_vsan_id_t vsan_id, 
    bcm_fcoe_vsan_control_t type, 
    int arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_control_vsan_set_dispatch[dtype](unit, vsan_id, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_control_vsan_set", 4, 3, unit, vsan_id, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_enable_set( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_enable_set,
static int (*_fcoe_enable_set_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_enable_set(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_enable_set_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_enable_set", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_fc_header_type_get( \
    int unit, uint32 flags, uint8 r_ctl, bcm_fcoe_fc_header_type_t *hdr_type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_fc_header_type_get,
static int (*_fcoe_fc_header_type_get_dispatch[])(
    int unit, 
    uint32 flags, 
    uint8 r_ctl, 
    bcm_fcoe_fc_header_type_t *hdr_type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_fc_header_type_get(
    int unit, 
    uint32 flags, 
    uint8 r_ctl, 
    bcm_fcoe_fc_header_type_t *hdr_type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_fc_header_type_get_dispatch[dtype](unit, flags, r_ctl, hdr_type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_fc_header_type_get", 4, 3, unit, flags, r_ctl, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_fc_header_type_set( \
    int unit, uint32 flags, uint8 r_ctl, bcm_fcoe_fc_header_type_t hdr_type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_fc_header_type_set,
static int (*_fcoe_fc_header_type_set_dispatch[])(
    int unit, 
    uint32 flags, 
    uint8 r_ctl, 
    bcm_fcoe_fc_header_type_t hdr_type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_fc_header_type_set(
    int unit, 
    uint32 flags, 
    uint8 r_ctl, 
    bcm_fcoe_fc_header_type_t hdr_type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_fc_header_type_set_dispatch[dtype](unit, flags, r_ctl, hdr_type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_fc_header_type_set", 4, 3, unit, flags, r_ctl, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_init,
static int (*_fcoe_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_intf_config_get( \
    int unit, uint32 flags, bcm_if_t intf, bcm_fcoe_intf_config_t *cfg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_intf_config_get,
static int (*_fcoe_intf_config_get_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_if_t intf, 
    bcm_fcoe_intf_config_t *cfg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_intf_config_get(
    int unit, 
    uint32 flags, 
    bcm_if_t intf, 
    bcm_fcoe_intf_config_t *cfg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_intf_config_get_dispatch[dtype](unit, flags, intf, cfg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_intf_config_get", 4, 3, unit, flags, intf, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_intf_config_set( \
    int unit, uint32 flags, bcm_if_t intf, bcm_fcoe_intf_config_t *cfg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_intf_config_set,
static int (*_fcoe_intf_config_set_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_if_t intf, 
    bcm_fcoe_intf_config_t *cfg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_intf_config_set(
    int unit, 
    uint32 flags, 
    bcm_if_t intf, 
    bcm_fcoe_intf_config_t *cfg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_intf_config_set_dispatch[dtype](unit, flags, intf, cfg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_intf_config_set", 4, 3, unit, flags, intf, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_route_add( \
    int unit, bcm_fcoe_route_t *route);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_route_add,
static int (*_fcoe_route_add_dispatch[])(
    int unit, 
    bcm_fcoe_route_t *route) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_route_add(
    int unit, 
    bcm_fcoe_route_t *route)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(route_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_SAVE(route_port,route->port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_route_add_dispatch[dtype](unit, route);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_RESTORE(route->port,route_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_route_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_route_delete( \
    int unit, bcm_fcoe_route_t *route);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_route_delete,
static int (*_fcoe_route_delete_dispatch[])(
    int unit, 
    bcm_fcoe_route_t *route) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_route_delete(
    int unit, 
    bcm_fcoe_route_t *route)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(route_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_SAVE(route_port,route->port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_route_delete_dispatch[dtype](unit, route);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_RESTORE(route->port,route_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_route_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_route_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_route_delete_all,
static int (*_fcoe_route_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_route_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_route_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_route_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_route_delete_by_interface( \
    int unit, bcm_fcoe_route_t *route);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_route_delete_by_interface,
static int (*_fcoe_route_delete_by_interface_dispatch[])(
    int unit, 
    bcm_fcoe_route_t *route) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_route_delete_by_interface(
    int unit, 
    bcm_fcoe_route_t *route)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(route_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_SAVE(route_port,route->port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_route_delete_by_interface_dispatch[dtype](unit, route);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_RESTORE(route->port,route_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_route_delete_by_interface", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_route_delete_by_prefix( \
    int unit, bcm_fcoe_route_t *route);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_route_delete_by_prefix,
static int (*_fcoe_route_delete_by_prefix_dispatch[])(
    int unit, 
    bcm_fcoe_route_t *route) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_route_delete_by_prefix(
    int unit, 
    bcm_fcoe_route_t *route)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(route_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_SAVE(route_port,route->port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_route_delete_by_prefix_dispatch[dtype](unit, route);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_RESTORE(route->port,route_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_route_delete_by_prefix", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_route_find( \
    int unit, bcm_fcoe_route_t *route);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_route_find,
static int (*_fcoe_route_find_dispatch[])(
    int unit, 
    bcm_fcoe_route_t *route) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_route_find(
    int unit, 
    bcm_fcoe_route_t *route)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_route_find_dispatch[dtype](unit, route);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_P2A(unit,&route->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_route_find", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_route_stat_attach( \
    int unit, bcm_fcoe_route_t *route, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_route_stat_attach,
static int (*_fcoe_route_stat_attach_dispatch[])(
    int unit, 
    bcm_fcoe_route_t *route, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_route_stat_attach(
    int unit, 
    bcm_fcoe_route_t *route, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(route_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_SAVE(route_port,route->port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_route_stat_attach_dispatch[dtype](unit, route, stat_counter_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_RESTORE(route->port,route_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_route_stat_attach", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_route_stat_counter_get( \
    int unit, bcm_fcoe_route_t *route, bcm_fcoe_route_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_route_stat_counter_get,
static int (*_fcoe_route_stat_counter_get_dispatch[])(
    int unit, 
    bcm_fcoe_route_t *route, 
    bcm_fcoe_route_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_route_stat_counter_get(
    int unit, 
    bcm_fcoe_route_t *route, 
    bcm_fcoe_route_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(route_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_SAVE(route_port,route->port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_route_stat_counter_get_dispatch[dtype](unit, route, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_RESTORE(route->port,route_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_route_stat_counter_get", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_route_stat_counter_set( \
    int unit, bcm_fcoe_route_t *route, bcm_fcoe_route_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_route_stat_counter_set,
static int (*_fcoe_route_stat_counter_set_dispatch[])(
    int unit, 
    bcm_fcoe_route_t *route, 
    bcm_fcoe_route_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_route_stat_counter_set(
    int unit, 
    bcm_fcoe_route_t *route, 
    bcm_fcoe_route_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(route_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_SAVE(route_port,route->port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_route_stat_counter_set_dispatch[dtype](unit, route, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_RESTORE(route->port,route_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_route_stat_counter_set", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_route_stat_counter_sync_get( \
    int unit, bcm_fcoe_route_t *route, bcm_fcoe_route_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_route_stat_counter_sync_get,
static int (*_fcoe_route_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_fcoe_route_t *route, 
    bcm_fcoe_route_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_route_stat_counter_sync_get(
    int unit, 
    bcm_fcoe_route_t *route, 
    bcm_fcoe_route_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(route_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_SAVE(route_port,route->port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_route_stat_counter_sync_get_dispatch[dtype](unit, route, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_RESTORE(route->port,route_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_route_stat_counter_sync_get", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_route_stat_detach( \
    int unit, bcm_fcoe_route_t *route);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_route_stat_detach,
static int (*_fcoe_route_stat_detach_dispatch[])(
    int unit, 
    bcm_fcoe_route_t *route) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_route_stat_detach(
    int unit, 
    bcm_fcoe_route_t *route)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(route_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_SAVE(route_port,route->port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_route_stat_detach_dispatch[dtype](unit, route);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_RESTORE(route->port,route_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_route_stat_detach", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_route_stat_id_get( \
    int unit, bcm_fcoe_route_t *route, bcm_fcoe_route_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_route_stat_id_get,
static int (*_fcoe_route_stat_id_get_dispatch[])(
    int unit, 
    bcm_fcoe_route_t *route, 
    bcm_fcoe_route_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_route_stat_id_get(
    int unit, 
    bcm_fcoe_route_t *route, 
    bcm_fcoe_route_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(route_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_SAVE(route_port,route->port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_route_stat_id_get_dispatch[dtype](unit, route, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_RESTORE(route->port,route_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_route_stat_id_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_route_traverse( \
    int unit, uint32 flags, bcm_fcoe_route_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_route_traverse,
static int (*_fcoe_route_traverse_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_fcoe_route_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_route_traverse(
    int unit, 
    uint32 flags, 
    bcm_fcoe_route_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_route_traverse_dispatch[dtype](unit, flags, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_route_traverse", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_vsan_create( \
    int unit, uint32 options, bcm_fcoe_vsan_t *vsan, bcm_fcoe_vsan_id_t *vsan_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_vsan_create,
static int (*_fcoe_vsan_create_dispatch[])(
    int unit, 
    uint32 options, 
    bcm_fcoe_vsan_t *vsan, 
    bcm_fcoe_vsan_id_t *vsan_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_vsan_create(
    int unit, 
    uint32 options, 
    bcm_fcoe_vsan_t *vsan, 
    bcm_fcoe_vsan_id_t *vsan_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_vsan_create_dispatch[dtype](unit, options, vsan, vsan_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_vsan_create", 4, 2, unit, options, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_vsan_destroy( \
    int unit, bcm_fcoe_vsan_id_t vsan_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_vsan_destroy,
static int (*_fcoe_vsan_destroy_dispatch[])(
    int unit, 
    bcm_fcoe_vsan_id_t vsan_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_vsan_destroy(
    int unit, 
    bcm_fcoe_vsan_id_t vsan_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_vsan_destroy_dispatch[dtype](unit, vsan_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_vsan_destroy", 2, 2, unit, vsan_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_vsan_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_vsan_destroy_all,
static int (*_fcoe_vsan_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_vsan_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_vsan_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_vsan_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_vsan_get( \
    int unit, bcm_fcoe_vsan_id_t vsan_id, bcm_fcoe_vsan_t *vsan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_vsan_get,
static int (*_fcoe_vsan_get_dispatch[])(
    int unit, 
    bcm_fcoe_vsan_id_t vsan_id, 
    bcm_fcoe_vsan_t *vsan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_vsan_get(
    int unit, 
    bcm_fcoe_vsan_id_t vsan_id, 
    bcm_fcoe_vsan_t *vsan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_vsan_get_dispatch[dtype](unit, vsan_id, vsan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_vsan_get", 3, 2, unit, vsan_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_vsan_set( \
    int unit, bcm_fcoe_vsan_id_t vsan_id, bcm_fcoe_vsan_t *vsan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_vsan_set,
static int (*_fcoe_vsan_set_dispatch[])(
    int unit, 
    bcm_fcoe_vsan_id_t vsan_id, 
    bcm_fcoe_vsan_t *vsan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_vsan_set(
    int unit, 
    bcm_fcoe_vsan_id_t vsan_id, 
    bcm_fcoe_vsan_t *vsan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_vsan_set_dispatch[dtype](unit, vsan_id, vsan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_vsan_set", 3, 2, unit, vsan_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_vsan_stat_attach( \
    int unit, bcm_fcoe_vsan_id_t vsan, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_vsan_stat_attach,
static int (*_fcoe_vsan_stat_attach_dispatch[])(
    int unit, 
    bcm_fcoe_vsan_id_t vsan, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_vsan_stat_attach(
    int unit, 
    bcm_fcoe_vsan_id_t vsan, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_vsan_stat_attach_dispatch[dtype](unit, vsan, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_vsan_stat_attach", 3, 3, unit, vsan, stat_counter_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_vsan_stat_counter_get( \
    int unit, bcm_fcoe_vsan_id_t vsan, bcm_fcoe_vsan_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_vsan_stat_counter_get,
static int (*_fcoe_vsan_stat_counter_get_dispatch[])(
    int unit, 
    bcm_fcoe_vsan_id_t vsan, 
    bcm_fcoe_vsan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_vsan_stat_counter_get(
    int unit, 
    bcm_fcoe_vsan_id_t vsan, 
    bcm_fcoe_vsan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_vsan_stat_counter_get_dispatch[dtype](unit, vsan, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_vsan_stat_counter_get", 6, 3, unit, vsan, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_vsan_stat_counter_set( \
    int unit, bcm_fcoe_vsan_id_t vsan, bcm_fcoe_vsan_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_vsan_stat_counter_set,
static int (*_fcoe_vsan_stat_counter_set_dispatch[])(
    int unit, 
    bcm_fcoe_vsan_id_t vsan, 
    bcm_fcoe_vsan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_vsan_stat_counter_set(
    int unit, 
    bcm_fcoe_vsan_id_t vsan, 
    bcm_fcoe_vsan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_vsan_stat_counter_set_dispatch[dtype](unit, vsan, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_vsan_stat_counter_set", 6, 3, unit, vsan, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_vsan_stat_counter_sync_get( \
    int unit, bcm_fcoe_vsan_id_t vsan, bcm_fcoe_vsan_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_vsan_stat_counter_sync_get,
static int (*_fcoe_vsan_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_fcoe_vsan_id_t vsan, 
    bcm_fcoe_vsan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_vsan_stat_counter_sync_get(
    int unit, 
    bcm_fcoe_vsan_id_t vsan, 
    bcm_fcoe_vsan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_vsan_stat_counter_sync_get_dispatch[dtype](unit, vsan, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_vsan_stat_counter_sync_get", 6, 3, unit, vsan, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_vsan_stat_detach( \
    int unit, bcm_fcoe_vsan_id_t vsan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_vsan_stat_detach,
static int (*_fcoe_vsan_stat_detach_dispatch[])(
    int unit, 
    bcm_fcoe_vsan_id_t vsan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_vsan_stat_detach(
    int unit, 
    bcm_fcoe_vsan_id_t vsan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_vsan_stat_detach_dispatch[dtype](unit, vsan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_vsan_stat_detach", 2, 2, unit, vsan, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_vsan_stat_id_get( \
    int unit, bcm_fcoe_vsan_id_t vsan, bcm_fcoe_vsan_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_vsan_stat_id_get,
static int (*_fcoe_vsan_stat_id_get_dispatch[])(
    int unit, 
    bcm_fcoe_vsan_id_t vsan, 
    bcm_fcoe_vsan_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_vsan_stat_id_get(
    int unit, 
    bcm_fcoe_vsan_id_t vsan, 
    bcm_fcoe_vsan_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_vsan_stat_id_get_dispatch[dtype](unit, vsan, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_vsan_stat_id_get", 4, 3, unit, vsan, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_vsan_translate_action_add( \
    int unit, bcm_fcoe_vsan_translate_key_config_t *key, bcm_fcoe_vsan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_vsan_translate_action_add,
static int (*_fcoe_vsan_translate_action_add_dispatch[])(
    int unit, 
    bcm_fcoe_vsan_translate_key_config_t *key, 
    bcm_fcoe_vsan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_vsan_translate_action_add(
    int unit, 
    bcm_fcoe_vsan_translate_key_config_t *key, 
    bcm_fcoe_vsan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(key_port);
		BCM_API_XLATE_PORT_COND(key) BCM_API_XLATE_PORT_SAVE(key_port,key->port);
		BCM_API_XLATE_PORT_COND(key) BCM_API_XLATE_PORT_A2P(unit,&key->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_vsan_translate_action_add_dispatch[dtype](unit, key, action);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(key) BCM_API_XLATE_PORT_RESTORE(key->port,key_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_vsan_translate_action_add", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_vsan_translate_action_delete( \
    int unit, bcm_fcoe_vsan_translate_key_config_t *key);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_vsan_translate_action_delete,
static int (*_fcoe_vsan_translate_action_delete_dispatch[])(
    int unit, 
    bcm_fcoe_vsan_translate_key_config_t *key) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_vsan_translate_action_delete(
    int unit, 
    bcm_fcoe_vsan_translate_key_config_t *key)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(key_port);
		BCM_API_XLATE_PORT_COND(key) BCM_API_XLATE_PORT_SAVE(key_port,key->port);
		BCM_API_XLATE_PORT_COND(key) BCM_API_XLATE_PORT_A2P(unit,&key->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_vsan_translate_action_delete_dispatch[dtype](unit, key);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(key) BCM_API_XLATE_PORT_RESTORE(key->port,key_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_vsan_translate_action_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_vsan_traverse( \
    int unit, uint32 flags, bcm_fcoe_vsan_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_vsan_traverse,
static int (*_fcoe_vsan_traverse_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_fcoe_vsan_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_vsan_traverse(
    int unit, 
    uint32 flags, 
    bcm_fcoe_vsan_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_vsan_traverse_dispatch[dtype](unit, flags, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_vsan_traverse", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_zone_add( \
    int unit, bcm_fcoe_zone_entry_t *zone);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_zone_add,
static int (*_fcoe_zone_add_dispatch[])(
    int unit, 
    bcm_fcoe_zone_entry_t *zone) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_zone_add(
    int unit, 
    bcm_fcoe_zone_entry_t *zone)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(zone_dest_port);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_SAVE(zone_dest_port,zone->dest_port);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_A2P(unit,&zone->dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_zone_add_dispatch[dtype](unit, zone);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_RESTORE(zone->dest_port,zone_dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_zone_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_zone_delete( \
    int unit, bcm_fcoe_zone_entry_t *zone);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_zone_delete,
static int (*_fcoe_zone_delete_dispatch[])(
    int unit, 
    bcm_fcoe_zone_entry_t *zone) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_zone_delete(
    int unit, 
    bcm_fcoe_zone_entry_t *zone)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(zone_dest_port);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_SAVE(zone_dest_port,zone->dest_port);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_A2P(unit,&zone->dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_zone_delete_dispatch[dtype](unit, zone);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_RESTORE(zone->dest_port,zone_dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_zone_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_zone_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_zone_delete_all,
static int (*_fcoe_zone_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_zone_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_zone_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_zone_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_zone_delete_by_did( \
    int unit, bcm_fcoe_zone_entry_t *zone);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_zone_delete_by_did,
static int (*_fcoe_zone_delete_by_did_dispatch[])(
    int unit, 
    bcm_fcoe_zone_entry_t *zone) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_zone_delete_by_did(
    int unit, 
    bcm_fcoe_zone_entry_t *zone)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(zone_dest_port);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_SAVE(zone_dest_port,zone->dest_port);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_A2P(unit,&zone->dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_zone_delete_by_did_dispatch[dtype](unit, zone);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_RESTORE(zone->dest_port,zone_dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_zone_delete_by_did", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_zone_delete_by_sid( \
    int unit, bcm_fcoe_zone_entry_t *zone);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_zone_delete_by_sid,
static int (*_fcoe_zone_delete_by_sid_dispatch[])(
    int unit, 
    bcm_fcoe_zone_entry_t *zone) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_zone_delete_by_sid(
    int unit, 
    bcm_fcoe_zone_entry_t *zone)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(zone_dest_port);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_SAVE(zone_dest_port,zone->dest_port);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_A2P(unit,&zone->dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_zone_delete_by_sid_dispatch[dtype](unit, zone);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_RESTORE(zone->dest_port,zone_dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_zone_delete_by_sid", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_zone_delete_by_vsan( \
    int unit, bcm_fcoe_zone_entry_t *zone);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_zone_delete_by_vsan,
static int (*_fcoe_zone_delete_by_vsan_dispatch[])(
    int unit, 
    bcm_fcoe_zone_entry_t *zone) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_zone_delete_by_vsan(
    int unit, 
    bcm_fcoe_zone_entry_t *zone)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(zone_dest_port);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_SAVE(zone_dest_port,zone->dest_port);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_A2P(unit,&zone->dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_zone_delete_by_vsan_dispatch[dtype](unit, zone);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_RESTORE(zone->dest_port,zone_dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_zone_delete_by_vsan", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_zone_get( \
    int unit, bcm_fcoe_zone_entry_t *zone);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_zone_get,
static int (*_fcoe_zone_get_dispatch[])(
    int unit, 
    bcm_fcoe_zone_entry_t *zone) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_zone_get(
    int unit, 
    bcm_fcoe_zone_entry_t *zone)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_A2P(unit,&zone->dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_zone_get_dispatch[dtype](unit, zone);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(zone) BCM_API_XLATE_PORT_P2A(unit,&zone->dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_zone_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_fcoe_zone_traverse( \
    int unit, uint32 flags, bcm_fcoe_zone_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_fcoe_zone_traverse,
static int (*_fcoe_zone_traverse_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_fcoe_zone_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_fcoe_zone_traverse(
    int unit, 
    uint32 flags, 
    bcm_fcoe_zone_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _fcoe_zone_traverse_dispatch[dtype](unit, flags, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_fcoe_zone_traverse", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_action_add( \
    int unit, bcm_field_entry_t entry, bcm_field_action_t action, uint32 param0, uint32 param1);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_action_add,
static int (*_field_action_add_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    uint32 param0, 
    uint32 param1) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_action_add(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    uint32 param0, 
    uint32 param1)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_action_add_dispatch[dtype](unit, entry, action, param0, param1);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_action_add", 5, 3, unit, entry, action, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_action_delete( \
    int unit, bcm_field_entry_t entry, bcm_field_action_t action, uint32 param0, uint32 param1);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_action_delete,
static int (*_field_action_delete_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    uint32 param0, 
    uint32 param1) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_action_delete(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    uint32 param0, 
    uint32 param1)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_action_delete_dispatch[dtype](unit, entry, action, param0, param1);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_action_delete", 5, 3, unit, entry, action, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_action_get( \
    int unit, bcm_field_entry_t entry, bcm_field_action_t action, uint32 *param0, uint32 *param1);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_action_get,
static int (*_field_action_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    uint32 *param0, 
    uint32 *param1) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_action_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    uint32 *param0, 
    uint32 *param1)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_action_get_dispatch[dtype](unit, entry, action, param0, param1);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_action_get", 5, 3, unit, entry, action, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_action_mac_add( \
    int unit, bcm_field_entry_t entry, bcm_field_action_t action, bcm_mac_t mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_action_mac_add,
static int (*_field_action_mac_add_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    bcm_mac_t mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_action_mac_add(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    bcm_mac_t mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_action_mac_add_dispatch[dtype](unit, entry, action, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_action_mac_add", 4, 3, unit, entry, action, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_action_mac_get( \
    int unit, bcm_field_entry_t entry, bcm_field_action_t action, bcm_mac_t *mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_action_mac_get,
static int (*_field_action_mac_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    bcm_mac_t *mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_action_mac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    bcm_mac_t *mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_action_mac_get_dispatch[dtype](unit, entry, action, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_action_mac_get", 4, 3, unit, entry, action, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_action_ports_add( \
    int unit, bcm_field_entry_t entry, bcm_field_action_t action, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_action_ports_add,
static int (*_field_action_ports_add_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_action_ports_add(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_action_ports_add_dispatch[dtype](unit, entry, action, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_action_ports_add", 4, 3, unit, entry, action, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_action_ports_get( \
    int unit, bcm_field_entry_t entry, bcm_field_action_t action, bcm_pbmp_t *pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_action_ports_get,
static int (*_field_action_ports_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    bcm_pbmp_t *pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_action_ports_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action, 
    bcm_pbmp_t *pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_action_ports_get_dispatch[dtype](unit, entry, action, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_action_ports_get", 4, 3, unit, entry, action, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_action_remove( \
    int unit, bcm_field_entry_t entry, bcm_field_action_t action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_action_remove,
static int (*_field_action_remove_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_action_remove(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_action_t action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_action_remove_dispatch[dtype](unit, entry, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_action_remove", 3, 3, unit, entry, action, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_action_remove_all( \
    int unit, bcm_field_entry_t entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_action_remove_all,
static int (*_field_action_remove_all_dispatch[])(
    int unit, 
    bcm_field_entry_t entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_action_remove_all(
    int unit, 
    bcm_field_entry_t entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_action_remove_all_dispatch[dtype](unit, entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_action_remove_all", 2, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_control_get( \
    int unit, bcm_field_control_t control, uint32 *state);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_control_get,
static int (*_field_control_get_dispatch[])(
    int unit, 
    bcm_field_control_t control, 
    uint32 *state) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_control_get(
    int unit, 
    bcm_field_control_t control, 
    uint32 *state)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_control_get_dispatch[dtype](unit, control, state);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_control_get", 3, 2, unit, control, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_control_set( \
    int unit, bcm_field_control_t control, uint32 state);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_control_set,
static int (*_field_control_set_dispatch[])(
    int unit, 
    bcm_field_control_t control, 
    uint32 state) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_control_set(
    int unit, 
    bcm_field_control_t control, 
    uint32 state)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_control_set_dispatch[dtype](unit, control, state);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_control_set", 3, 3, unit, control, state, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_data_qualifier_create( \
    int unit, bcm_field_data_qualifier_t *data_qualifier);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_data_qualifier_create,
static int (*_field_data_qualifier_create_dispatch[])(
    int unit, 
    bcm_field_data_qualifier_t *data_qualifier) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_data_qualifier_create(
    int unit, 
    bcm_field_data_qualifier_t *data_qualifier)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_data_qualifier_create_dispatch[dtype](unit, data_qualifier);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_data_qualifier_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_data_qualifier_destroy( \
    int unit, int qual_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_data_qualifier_destroy,
static int (*_field_data_qualifier_destroy_dispatch[])(
    int unit, 
    int qual_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_data_qualifier_destroy(
    int unit, 
    int qual_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_data_qualifier_destroy_dispatch[dtype](unit, qual_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_data_qualifier_destroy", 2, 2, unit, qual_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_data_qualifier_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_data_qualifier_destroy_all,
static int (*_field_data_qualifier_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_data_qualifier_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_data_qualifier_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_data_qualifier_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_data_qualifier_ethertype_add( \
    int unit, int qual_id, bcm_field_data_ethertype_t *etype);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_data_qualifier_ethertype_add,
static int (*_field_data_qualifier_ethertype_add_dispatch[])(
    int unit, 
    int qual_id, 
    bcm_field_data_ethertype_t *etype) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_data_qualifier_ethertype_add(
    int unit, 
    int qual_id, 
    bcm_field_data_ethertype_t *etype)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_data_qualifier_ethertype_add_dispatch[dtype](unit, qual_id, etype);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_data_qualifier_ethertype_add", 3, 2, unit, qual_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_data_qualifier_ethertype_delete( \
    int unit, int qual_id, bcm_field_data_ethertype_t *etype);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_data_qualifier_ethertype_delete,
static int (*_field_data_qualifier_ethertype_delete_dispatch[])(
    int unit, 
    int qual_id, 
    bcm_field_data_ethertype_t *etype) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_data_qualifier_ethertype_delete(
    int unit, 
    int qual_id, 
    bcm_field_data_ethertype_t *etype)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_data_qualifier_ethertype_delete_dispatch[dtype](unit, qual_id, etype);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_data_qualifier_ethertype_delete", 3, 2, unit, qual_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_data_qualifier_get( \
    int unit, int qual_id, bcm_field_data_qualifier_t *qual);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_data_qualifier_get,
static int (*_field_data_qualifier_get_dispatch[])(
    int unit, 
    int qual_id, 
    bcm_field_data_qualifier_t *qual) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_data_qualifier_get(
    int unit, 
    int qual_id, 
    bcm_field_data_qualifier_t *qual)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_data_qualifier_get_dispatch[dtype](unit, qual_id, qual);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_data_qualifier_get", 3, 2, unit, qual_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_data_qualifier_ip_protocol_add( \
    int unit, int qual_id, bcm_field_data_ip_protocol_t *ip_protocol);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_data_qualifier_ip_protocol_add,
static int (*_field_data_qualifier_ip_protocol_add_dispatch[])(
    int unit, 
    int qual_id, 
    bcm_field_data_ip_protocol_t *ip_protocol) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_data_qualifier_ip_protocol_add(
    int unit, 
    int qual_id, 
    bcm_field_data_ip_protocol_t *ip_protocol)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_data_qualifier_ip_protocol_add_dispatch[dtype](unit, qual_id, ip_protocol);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_data_qualifier_ip_protocol_add", 3, 2, unit, qual_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_data_qualifier_ip_protocol_delete( \
    int unit, int qual_id, bcm_field_data_ip_protocol_t *ip_protocol);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_data_qualifier_ip_protocol_delete,
static int (*_field_data_qualifier_ip_protocol_delete_dispatch[])(
    int unit, 
    int qual_id, 
    bcm_field_data_ip_protocol_t *ip_protocol) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_data_qualifier_ip_protocol_delete(
    int unit, 
    int qual_id, 
    bcm_field_data_ip_protocol_t *ip_protocol)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_data_qualifier_ip_protocol_delete_dispatch[dtype](unit, qual_id, ip_protocol);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_data_qualifier_ip_protocol_delete", 3, 2, unit, qual_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_data_qualifier_multi_get( \
    int unit, int qual_size, int *qual_array, int *qual_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_data_qualifier_multi_get,
static int (*_field_data_qualifier_multi_get_dispatch[])(
    int unit, 
    int qual_size, 
    int *qual_array, 
    int *qual_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_data_qualifier_multi_get(
    int unit, 
    int qual_size, 
    int *qual_array, 
    int *qual_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_data_qualifier_multi_get_dispatch[dtype](unit, qual_size, qual_array, qual_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_data_qualifier_multi_get", 4, 2, unit, qual_size, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_data_qualifier_packet_format_add( \
    int unit, int qual_id, bcm_field_data_packet_format_t *packet_format);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_data_qualifier_packet_format_add,
static int (*_field_data_qualifier_packet_format_add_dispatch[])(
    int unit, 
    int qual_id, 
    bcm_field_data_packet_format_t *packet_format) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_data_qualifier_packet_format_add(
    int unit, 
    int qual_id, 
    bcm_field_data_packet_format_t *packet_format)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_data_qualifier_packet_format_add_dispatch[dtype](unit, qual_id, packet_format);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_data_qualifier_packet_format_add", 3, 2, unit, qual_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_data_qualifier_packet_format_delete( \
    int unit, int qual_id, bcm_field_data_packet_format_t *packet_format);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_data_qualifier_packet_format_delete,
static int (*_field_data_qualifier_packet_format_delete_dispatch[])(
    int unit, 
    int qual_id, 
    bcm_field_data_packet_format_t *packet_format) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_data_qualifier_packet_format_delete(
    int unit, 
    int qual_id, 
    bcm_field_data_packet_format_t *packet_format)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_data_qualifier_packet_format_delete_dispatch[dtype](unit, qual_id, packet_format);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_data_qualifier_packet_format_delete", 3, 2, unit, qual_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_detach,
static int (*_field_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_direct_extraction_action_add( \
    int unit, bcm_field_entry_t entry, bcm_field_extraction_action_t action, int count, bcm_field_extraction_field_t *extractions);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_direct_extraction_action_add,
static int (*_field_direct_extraction_action_add_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_extraction_action_t action, 
    int count, 
    bcm_field_extraction_field_t *extractions) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_direct_extraction_action_add(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_extraction_action_t action, 
    int count, 
    bcm_field_extraction_field_t *extractions)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_direct_extraction_action_add_dispatch[dtype](unit, entry, action, count, extractions);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_direct_extraction_action_add", 5, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_direct_extraction_action_get( \
    int unit, bcm_field_entry_t entry, bcm_field_extraction_action_t *action, int max_count, bcm_field_extraction_field_t *extractions, int *actual_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_direct_extraction_action_get,
static int (*_field_direct_extraction_action_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_extraction_action_t *action, 
    int max_count, 
    bcm_field_extraction_field_t *extractions, 
    int *actual_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_direct_extraction_action_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_extraction_action_t *action, 
    int max_count, 
    bcm_field_extraction_field_t *extractions, 
    int *actual_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_direct_extraction_action_get_dispatch[dtype](unit, entry, action, max_count, extractions, actual_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_direct_extraction_action_get", 6, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_copy( \
    int unit, bcm_field_entry_t src_entry, bcm_field_entry_t *dst_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_copy,
static int (*_field_entry_copy_dispatch[])(
    int unit, 
    bcm_field_entry_t src_entry, 
    bcm_field_entry_t *dst_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_copy(
    int unit, 
    bcm_field_entry_t src_entry, 
    bcm_field_entry_t *dst_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_copy_dispatch[dtype](unit, src_entry, dst_entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_copy", 3, 2, unit, src_entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_copy_id( \
    int unit, bcm_field_entry_t src_entry, bcm_field_entry_t dst_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_copy_id,
static int (*_field_entry_copy_id_dispatch[])(
    int unit, 
    bcm_field_entry_t src_entry, 
    bcm_field_entry_t dst_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_copy_id(
    int unit, 
    bcm_field_entry_t src_entry, 
    bcm_field_entry_t dst_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_copy_id_dispatch[dtype](unit, src_entry, dst_entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_copy_id", 3, 3, unit, src_entry, dst_entry, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_create( \
    int unit, bcm_field_group_t group, bcm_field_entry_t *entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_create,
static int (*_field_entry_create_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_entry_t *entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_create(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_entry_t *entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_create_dispatch[dtype](unit, group, entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_create", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_create_id( \
    int unit, bcm_field_group_t group, bcm_field_entry_t entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_create_id,
static int (*_field_entry_create_id_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_entry_t entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_create_id(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_entry_t entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_create_id_dispatch[dtype](unit, group, entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_create_id", 3, 3, unit, group, entry, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_destroy( \
    int unit, bcm_field_entry_t entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_destroy,
static int (*_field_entry_destroy_dispatch[])(
    int unit, 
    bcm_field_entry_t entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_destroy(
    int unit, 
    bcm_field_entry_t entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_destroy_dispatch[dtype](unit, entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_destroy", 2, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_destroy_all,
static int (*_field_entry_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

#if defined(BROADCOM_DEBUG)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_dump( \
    int unit, bcm_field_entry_t entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_dump,
static int (*_field_entry_dump_dispatch[])(
    int unit, 
    bcm_field_entry_t entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_dump(
    int unit, 
    bcm_field_entry_t entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_dump_dispatch[dtype](unit, entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_dump", 2, 2, unit, entry, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_enable_get( \
    int unit, bcm_field_entry_t entry, int *enable_flag);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_enable_get,
static int (*_field_entry_enable_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    int *enable_flag) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_enable_get(
    int unit, 
    bcm_field_entry_t entry, 
    int *enable_flag)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_enable_get_dispatch[dtype](unit, entry, enable_flag);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_enable_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_enable_set( \
    int unit, bcm_field_entry_t entry, int enable_flag);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_enable_set,
static int (*_field_entry_enable_set_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    int enable_flag) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_enable_set(
    int unit, 
    bcm_field_entry_t entry, 
    int enable_flag)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_enable_set_dispatch[dtype](unit, entry, enable_flag);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_enable_set", 3, 3, unit, entry, enable_flag, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_install( \
    int unit, bcm_field_entry_t entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_install,
static int (*_field_entry_install_dispatch[])(
    int unit, 
    bcm_field_entry_t entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_install(
    int unit, 
    bcm_field_entry_t entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_install_dispatch[dtype](unit, entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_install", 2, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_multi_get( \
    int unit, bcm_field_group_t group, int entry_size, bcm_field_entry_t *entry_array, int *entry_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_multi_get,
static int (*_field_entry_multi_get_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    int entry_size, 
    bcm_field_entry_t *entry_array, 
    int *entry_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_multi_get(
    int unit, 
    bcm_field_group_t group, 
    int entry_size, 
    bcm_field_entry_t *entry_array, 
    int *entry_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_multi_get_dispatch[dtype](unit, group, entry_size, entry_array, entry_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_multi_get", 5, 3, unit, group, entry_size, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_operation( \
    int unit, bcm_field_entry_oper_t *entry_oper);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_operation,
static int (*_field_entry_operation_dispatch[])(
    int unit, 
    bcm_field_entry_oper_t *entry_oper) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_operation(
    int unit, 
    bcm_field_entry_oper_t *entry_oper)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_operation_dispatch[dtype](unit, entry_oper);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_operation", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_policer_attach( \
    int unit, bcm_field_entry_t entry_id, int level, bcm_policer_t policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_policer_attach,
static int (*_field_entry_policer_attach_dispatch[])(
    int unit, 
    bcm_field_entry_t entry_id, 
    int level, 
    bcm_policer_t policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_policer_attach(
    int unit, 
    bcm_field_entry_t entry_id, 
    int level, 
    bcm_policer_t policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_policer_attach_dispatch[dtype](unit, entry_id, level, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_policer_attach", 4, 3, unit, entry_id, level, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_policer_detach( \
    int unit, bcm_field_entry_t entry_id, int level);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_policer_detach,
static int (*_field_entry_policer_detach_dispatch[])(
    int unit, 
    bcm_field_entry_t entry_id, 
    int level) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_policer_detach(
    int unit, 
    bcm_field_entry_t entry_id, 
    int level)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_policer_detach_dispatch[dtype](unit, entry_id, level);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_policer_detach", 3, 3, unit, entry_id, level, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_policer_detach_all( \
    int unit, bcm_field_entry_t entry_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_policer_detach_all,
static int (*_field_entry_policer_detach_all_dispatch[])(
    int unit, 
    bcm_field_entry_t entry_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_policer_detach_all(
    int unit, 
    bcm_field_entry_t entry_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_policer_detach_all_dispatch[dtype](unit, entry_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_policer_detach_all", 2, 2, unit, entry_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_policer_get( \
    int unit, bcm_field_entry_t entry_id, int level, bcm_policer_t *policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_policer_get,
static int (*_field_entry_policer_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry_id, 
    int level, 
    bcm_policer_t *policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_policer_get(
    int unit, 
    bcm_field_entry_t entry_id, 
    int level, 
    bcm_policer_t *policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_policer_get_dispatch[dtype](unit, entry_id, level, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_policer_get", 4, 3, unit, entry_id, level, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_prio_get( \
    int unit, bcm_field_entry_t entry, int *prio);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_prio_get,
static int (*_field_entry_prio_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    int *prio) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_prio_get(
    int unit, 
    bcm_field_entry_t entry, 
    int *prio)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_prio_get_dispatch[dtype](unit, entry, prio);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_prio_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_prio_set( \
    int unit, bcm_field_entry_t entry, int prio);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_prio_set,
static int (*_field_entry_prio_set_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    int prio) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_prio_set(
    int unit, 
    bcm_field_entry_t entry, 
    int prio)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_prio_set_dispatch[dtype](unit, entry, prio);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_prio_set", 3, 3, unit, entry, prio, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_reinstall( \
    int unit, bcm_field_entry_t entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_reinstall,
static int (*_field_entry_reinstall_dispatch[])(
    int unit, 
    bcm_field_entry_t entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_reinstall(
    int unit, 
    bcm_field_entry_t entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_reinstall_dispatch[dtype](unit, entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_reinstall", 2, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_remove( \
    int unit, bcm_field_entry_t entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_remove,
static int (*_field_entry_remove_dispatch[])(
    int unit, 
    bcm_field_entry_t entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_remove(
    int unit, 
    bcm_field_entry_t entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_remove_dispatch[dtype](unit, entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_remove", 2, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_stat_attach( \
    int unit, bcm_field_entry_t entry, int stat_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_stat_attach,
static int (*_field_entry_stat_attach_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    int stat_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_stat_attach(
    int unit, 
    bcm_field_entry_t entry, 
    int stat_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_stat_attach_dispatch[dtype](unit, entry, stat_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_stat_attach", 3, 3, unit, entry, stat_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_stat_detach( \
    int unit, bcm_field_entry_t entry, int stat_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_stat_detach,
static int (*_field_entry_stat_detach_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    int stat_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_stat_detach(
    int unit, 
    bcm_field_entry_t entry, 
    int stat_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_stat_detach_dispatch[dtype](unit, entry, stat_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_stat_detach", 3, 3, unit, entry, stat_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_entry_stat_get( \
    int unit, bcm_field_entry_t entry, int *stat_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_entry_stat_get,
static int (*_field_entry_stat_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    int *stat_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_entry_stat_get(
    int unit, 
    bcm_field_entry_t entry, 
    int *stat_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_entry_stat_get_dispatch[dtype](unit, entry, stat_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_entry_stat_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_action_get( \
    int unit, bcm_field_group_t group, bcm_field_aset_t *aset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_action_get,
static int (*_field_group_action_get_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_aset_t *aset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_action_get(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_aset_t *aset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_action_get_dispatch[dtype](unit, group, aset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_action_get", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_action_set( \
    int unit, bcm_field_group_t group, bcm_field_aset_t aset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_action_set,
static int (*_field_group_action_set_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_aset_t aset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_action_set(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_aset_t aset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_action_set_dispatch[dtype](unit, group, aset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_action_set", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_compress( \
    int unit, bcm_field_group_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_compress,
static int (*_field_group_compress_dispatch[])(
    int unit, 
    bcm_field_group_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_compress(
    int unit, 
    bcm_field_group_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_compress_dispatch[dtype](unit, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_compress", 2, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_config_create( \
    int unit, bcm_field_group_config_t *group_config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_config_create,
static int (*_field_group_config_create_dispatch[])(
    int unit, 
    bcm_field_group_config_t *group_config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_config_create(
    int unit, 
    bcm_field_group_config_t *group_config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(group_config) BCM_API_XLATE_PORT_PBMP_A2P(unit,&group_config->ports);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_config_create_dispatch[dtype](unit, group_config);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(group_config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&group_config->ports);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_config_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_create( \
    int unit, bcm_field_qset_t qset, int pri, bcm_field_group_t *group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_create,
static int (*_field_group_create_dispatch[])(
    int unit, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_t *group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_create(
    int unit, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_t *group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_create_dispatch[dtype](unit, qset, pri, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_create", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_create_id( \
    int unit, bcm_field_qset_t qset, int pri, bcm_field_group_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_create_id,
static int (*_field_group_create_id_dispatch[])(
    int unit, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_create_id(
    int unit, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_create_id_dispatch[dtype](unit, qset, pri, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_create_id", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_create_mode( \
    int unit, bcm_field_qset_t qset, int pri, bcm_field_group_mode_t mode, bcm_field_group_t *group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_create_mode,
static int (*_field_group_create_mode_dispatch[])(
    int unit, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t *group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_create_mode(
    int unit, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t *group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_create_mode_dispatch[dtype](unit, qset, pri, mode, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_create_mode", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_create_mode_id( \
    int unit, bcm_field_qset_t qset, int pri, bcm_field_group_mode_t mode, bcm_field_group_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_create_mode_id,
static int (*_field_group_create_mode_id_dispatch[])(
    int unit, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_create_mode_id(
    int unit, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_create_mode_id_dispatch[dtype](unit, qset, pri, mode, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_create_mode_id", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_destroy( \
    int unit, bcm_field_group_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_destroy,
static int (*_field_group_destroy_dispatch[])(
    int unit, 
    bcm_field_group_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_destroy(
    int unit, 
    bcm_field_group_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_destroy_dispatch[dtype](unit, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_destroy", 2, 2, unit, group, 0, r_rv);
	return r_rv;
}

#if defined(BROADCOM_DEBUG)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_dump( \
    int unit, bcm_field_group_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_dump,
static int (*_field_group_dump_dispatch[])(
    int unit, 
    bcm_field_group_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_dump(
    int unit, 
    bcm_field_group_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_dump_dispatch[dtype](unit, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_dump", 2, 2, unit, group, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_enable_get( \
    int unit, bcm_field_group_t group, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_enable_get,
static int (*_field_group_enable_get_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_enable_get(
    int unit, 
    bcm_field_group_t group, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_enable_get_dispatch[dtype](unit, group, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_enable_get", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_enable_set( \
    int unit, bcm_field_group_t group, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_enable_set,
static int (*_field_group_enable_set_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_enable_set(
    int unit, 
    bcm_field_group_t group, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_enable_set_dispatch[dtype](unit, group, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_enable_set", 3, 3, unit, group, enable, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_expansion_enable_get( \
    int unit, bcm_field_group_t group, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_expansion_enable_get,
static int (*_field_group_expansion_enable_get_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_expansion_enable_get(
    int unit, 
    bcm_field_group_t group, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_expansion_enable_get_dispatch[dtype](unit, group, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_expansion_enable_get", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_expansion_enable_set( \
    int unit, bcm_field_group_t group, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_expansion_enable_set,
static int (*_field_group_expansion_enable_set_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_expansion_enable_set(
    int unit, 
    bcm_field_group_t group, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_expansion_enable_set_dispatch[dtype](unit, group, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_expansion_enable_set", 3, 3, unit, group, enable, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_flush( \
    int unit, bcm_field_group_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_flush,
static int (*_field_group_flush_dispatch[])(
    int unit, 
    bcm_field_group_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_flush(
    int unit, 
    bcm_field_group_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_flush_dispatch[dtype](unit, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_flush", 2, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_get( \
    int unit, bcm_field_group_t group, bcm_field_qset_t *qset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_get,
static int (*_field_group_get_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_qset_t *qset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_get(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_qset_t *qset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_get_dispatch[dtype](unit, group, qset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_get", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_install( \
    int unit, bcm_field_group_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_install,
static int (*_field_group_install_dispatch[])(
    int unit, 
    bcm_field_group_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_install(
    int unit, 
    bcm_field_group_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_install_dispatch[dtype](unit, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_install", 2, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_mode_get( \
    int unit, bcm_field_group_t group, bcm_field_group_mode_t *mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_mode_get,
static int (*_field_group_mode_get_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_group_mode_t *mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_mode_get(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_group_mode_t *mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_mode_get_dispatch[dtype](unit, group, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_mode_get", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_port_create_mode( \
    int unit, bcm_port_t port, bcm_field_qset_t qset, int pri, bcm_field_group_mode_t mode, bcm_field_group_t *group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_port_create_mode,
static int (*_field_group_port_create_mode_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t *group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_port_create_mode(
    int unit, 
    bcm_port_t port, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t *group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_port_create_mode_dispatch[dtype](unit, port, qset, pri, mode, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_port_create_mode", 6, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_port_create_mode_id( \
    int unit, bcm_port_t port, bcm_field_qset_t qset, int pri, bcm_field_group_mode_t mode, bcm_field_group_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_port_create_mode_id,
static int (*_field_group_port_create_mode_id_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_port_create_mode_id(
    int unit, 
    bcm_port_t port, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_port_create_mode_id_dispatch[dtype](unit, port, qset, pri, mode, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_port_create_mode_id", 6, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_ports_create_mode( \
    int unit, bcm_pbmp_t pbmp, bcm_field_qset_t qset, int pri, bcm_field_group_mode_t mode, bcm_field_group_t *group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_ports_create_mode,
static int (*_field_group_ports_create_mode_dispatch[])(
    int unit, 
    bcm_pbmp_t pbmp, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t *group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_ports_create_mode(
    int unit, 
    bcm_pbmp_t pbmp, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t *group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_ports_create_mode_dispatch[dtype](unit, pbmp, qset, pri, mode, group);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_ports_create_mode", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_ports_create_mode_id( \
    int unit, bcm_pbmp_t pbmp, bcm_field_qset_t qset, int pri, bcm_field_group_mode_t mode, bcm_field_group_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_ports_create_mode_id,
static int (*_field_group_ports_create_mode_id_dispatch[])(
    int unit, 
    bcm_pbmp_t pbmp, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_ports_create_mode_id(
    int unit, 
    bcm_pbmp_t pbmp, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_ports_create_mode_id_dispatch[dtype](unit, pbmp, qset, pri, mode, group);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_ports_create_mode_id", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_presel_get( \
    int unit, bcm_field_group_t group, bcm_field_presel_set_t *presel);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_presel_get,
static int (*_field_group_presel_get_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_presel_set_t *presel) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_presel_get(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_presel_set_t *presel)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_presel_get_dispatch[dtype](unit, group, presel);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_presel_get", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_presel_set( \
    int unit, bcm_field_group_t group, bcm_field_presel_set_t *presel);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_presel_set,
static int (*_field_group_presel_set_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_presel_set_t *presel) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_presel_set(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_presel_set_t *presel)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_presel_set_dispatch[dtype](unit, group, presel);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_presel_set", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_priority_get( \
    int unit, bcm_field_group_t group, int *priority);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_priority_get,
static int (*_field_group_priority_get_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    int *priority) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_priority_get(
    int unit, 
    bcm_field_group_t group, 
    int *priority)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_priority_get_dispatch[dtype](unit, group, priority);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_priority_get", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_priority_set( \
    int unit, bcm_field_group_t group, int priority);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_priority_set,
static int (*_field_group_priority_set_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    int priority) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_priority_set(
    int unit, 
    bcm_field_group_t group, 
    int priority)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_priority_set_dispatch[dtype](unit, group, priority);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_priority_set", 3, 3, unit, group, priority, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_remove( \
    int unit, bcm_field_group_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_remove,
static int (*_field_group_remove_dispatch[])(
    int unit, 
    bcm_field_group_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_remove(
    int unit, 
    bcm_field_group_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_remove_dispatch[dtype](unit, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_remove", 2, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_set( \
    int unit, bcm_field_group_t group, bcm_field_qset_t qset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_set,
static int (*_field_group_set_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_qset_t qset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_set(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_qset_t qset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_set_dispatch[dtype](unit, group, qset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_set", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_status_get( \
    int unit, bcm_field_group_t group, bcm_field_group_status_t *status);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_status_get,
static int (*_field_group_status_get_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_group_status_t *status) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_status_get(
    int unit, 
    bcm_field_group_t group, 
    bcm_field_group_status_t *status)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_status_get_dispatch[dtype](unit, group, status);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_status_get", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_traverse( \
    int unit, bcm_field_group_traverse_cb callback, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_traverse,
static int (*_field_group_traverse_dispatch[])(
    int unit, 
    bcm_field_group_traverse_cb callback, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_traverse(
    int unit, 
    bcm_field_group_traverse_cb callback, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_traverse_dispatch[dtype](unit, callback, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_wlan_create_mode( \
    int unit, bcm_field_qset_t qset, int pri, bcm_field_group_mode_t mode, bcm_field_group_t *group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_wlan_create_mode,
static int (*_field_group_wlan_create_mode_dispatch[])(
    int unit, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t *group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_wlan_create_mode(
    int unit, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t *group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_wlan_create_mode_dispatch[dtype](unit, qset, pri, mode, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_wlan_create_mode", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_group_wlan_create_mode_id( \
    int unit, bcm_field_qset_t qset, int pri, bcm_field_group_mode_t mode, bcm_field_group_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_group_wlan_create_mode_id,
static int (*_field_group_wlan_create_mode_id_dispatch[])(
    int unit, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_group_wlan_create_mode_id(
    int unit, 
    bcm_field_qset_t qset, 
    int pri, 
    bcm_field_group_mode_t mode, 
    bcm_field_group_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_group_wlan_create_mode_id_dispatch[dtype](unit, qset, pri, mode, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_group_wlan_create_mode_id", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_init,
static int (*_field_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_presel_create( \
    int unit, bcm_field_presel_t *presel_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_presel_create,
static int (*_field_presel_create_dispatch[])(
    int unit, 
    bcm_field_presel_t *presel_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_presel_create(
    int unit, 
    bcm_field_presel_t *presel_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_presel_create_dispatch[dtype](unit, presel_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_presel_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_presel_create_id( \
    int unit, bcm_field_presel_t presel_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_presel_create_id,
static int (*_field_presel_create_id_dispatch[])(
    int unit, 
    bcm_field_presel_t presel_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_presel_create_id(
    int unit, 
    bcm_field_presel_t presel_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_presel_create_id_dispatch[dtype](unit, presel_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_presel_create_id", 2, 2, unit, presel_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_presel_destroy( \
    int unit, bcm_field_presel_t presel_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_presel_destroy,
static int (*_field_presel_destroy_dispatch[])(
    int unit, 
    bcm_field_presel_t presel_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_presel_destroy(
    int unit, 
    bcm_field_presel_t presel_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_presel_destroy_dispatch[dtype](unit, presel_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_presel_destroy", 2, 2, unit, presel_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qset_data_qualifier_add( \
    int unit, bcm_field_qset_t *qset, int qual_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qset_data_qualifier_add,
static int (*_field_qset_data_qualifier_add_dispatch[])(
    int unit, 
    bcm_field_qset_t *qset, 
    int qual_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qset_data_qualifier_add(
    int unit, 
    bcm_field_qset_t *qset, 
    int qual_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qset_data_qualifier_add_dispatch[dtype](unit, qset, qual_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qset_data_qualifier_add", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qset_data_qualifier_delete( \
    int unit, bcm_field_qset_t *qset, int qual_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qset_data_qualifier_delete,
static int (*_field_qset_data_qualifier_delete_dispatch[])(
    int unit, 
    bcm_field_qset_t *qset, 
    int qual_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qset_data_qualifier_delete(
    int unit, 
    bcm_field_qset_t *qset, 
    int qual_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qset_data_qualifier_delete_dispatch[dtype](unit, qset, qual_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qset_data_qualifier_delete", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qset_data_qualifier_get( \
    int unit, bcm_field_qset_t qset, int qual_max, int *qual_arr, int *qual_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qset_data_qualifier_get,
static int (*_field_qset_data_qualifier_get_dispatch[])(
    int unit, 
    bcm_field_qset_t qset, 
    int qual_max, 
    int *qual_arr, 
    int *qual_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qset_data_qualifier_get(
    int unit, 
    bcm_field_qset_t qset, 
    int qual_max, 
    int *qual_arr, 
    int *qual_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qset_data_qualifier_get_dispatch[dtype](unit, qset, qual_max, qual_arr, qual_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qset_data_qualifier_get", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qset_id_multi_delete( \
    int unit, bcm_field_qualify_t qualifier, int num_objects, int *object_list, bcm_field_qset_t *qset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qset_id_multi_delete,
static int (*_field_qset_id_multi_delete_dispatch[])(
    int unit, 
    bcm_field_qualify_t qualifier, 
    int num_objects, 
    int *object_list, 
    bcm_field_qset_t *qset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qset_id_multi_delete(
    int unit, 
    bcm_field_qualify_t qualifier, 
    int num_objects, 
    int *object_list, 
    bcm_field_qset_t *qset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qset_id_multi_delete_dispatch[dtype](unit, qualifier, num_objects, object_list, qset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qset_id_multi_delete", 5, 3, unit, qualifier, num_objects, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qset_id_multi_get( \
    int unit, bcm_field_qset_t qset, bcm_field_qualify_t qualifier, int max_objects, int *object_list, int *count_objects);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qset_id_multi_get,
static int (*_field_qset_id_multi_get_dispatch[])(
    int unit, 
    bcm_field_qset_t qset, 
    bcm_field_qualify_t qualifier, 
    int max_objects, 
    int *object_list, 
    int *count_objects) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qset_id_multi_get(
    int unit, 
    bcm_field_qset_t qset, 
    bcm_field_qualify_t qualifier, 
    int max_objects, 
    int *object_list, 
    int *count_objects)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qset_id_multi_get_dispatch[dtype](unit, qset, qualifier, max_objects, object_list, count_objects);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qset_id_multi_get", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qset_id_multi_set( \
    int unit, bcm_field_qualify_t qualifier, int num_objects, int *object_list, bcm_field_qset_t *qset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qset_id_multi_set,
static int (*_field_qset_id_multi_set_dispatch[])(
    int unit, 
    bcm_field_qualify_t qualifier, 
    int num_objects, 
    int *object_list, 
    bcm_field_qset_t *qset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qset_id_multi_set(
    int unit, 
    bcm_field_qualify_t qualifier, 
    int num_objects, 
    int *object_list, 
    bcm_field_qset_t *qset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qset_id_multi_set_dispatch[dtype](unit, qualifier, num_objects, object_list, qset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qset_id_multi_set", 5, 3, unit, qualifier, num_objects, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualifier_delete( \
    int unit, bcm_field_entry_t entry, bcm_field_qualify_t qual_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualifier_delete,
static int (*_field_qualifier_delete_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_qualify_t qual_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualifier_delete(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_qualify_t qual_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualifier_delete_dispatch[dtype](unit, entry, qual_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualifier_delete", 3, 3, unit, entry, qual_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_AppType( \
    int unit, bcm_field_entry_t entry, bcm_field_AppType_t type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_AppType,
static int (*_field_qualify_AppType_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_AppType_t type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_AppType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_AppType_t type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_AppType_dispatch[dtype](unit, entry, type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_AppType", 3, 3, unit, entry, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_AppType_get( \
    int unit, bcm_field_entry_t entry, bcm_field_AppType_t *type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_AppType_get,
static int (*_field_qualify_AppType_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_AppType_t *type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_AppType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_AppType_t *type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_AppType_get_dispatch[dtype](unit, entry, type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_AppType_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ArpOpcode( \
    int unit, bcm_field_entry_t entry, bcm_field_ArpOpcode_t data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ArpOpcode,
static int (*_field_qualify_ArpOpcode_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ArpOpcode_t data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ArpOpcode(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ArpOpcode_t data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ArpOpcode_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ArpOpcode", 3, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ArpOpcode_get( \
    int unit, bcm_field_entry_t entry, bcm_field_ArpOpcode_t *data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ArpOpcode_get,
static int (*_field_qualify_ArpOpcode_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ArpOpcode_t *data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ArpOpcode_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ArpOpcode_t *data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ArpOpcode_get_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ArpOpcode_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ArpSenderIp4( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ArpSenderIp4,
static int (*_field_qualify_ArpSenderIp4_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ArpSenderIp4(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ArpSenderIp4_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ArpSenderIp4", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ArpSenderIp4_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ArpSenderIp4_get,
static int (*_field_qualify_ArpSenderIp4_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ArpSenderIp4_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ArpSenderIp4_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ArpSenderIp4_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ArpTargetIp4( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ArpTargetIp4,
static int (*_field_qualify_ArpTargetIp4_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ArpTargetIp4(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ArpTargetIp4_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ArpTargetIp4", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ArpTargetIp4_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ArpTargetIp4_get,
static int (*_field_qualify_ArpTargetIp4_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ArpTargetIp4_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ArpTargetIp4_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ArpTargetIp4_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_BigIcmpCheck( \
    int unit, bcm_field_entry_t entry, uint32 flag, uint32 size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_BigIcmpCheck,
static int (*_field_qualify_BigIcmpCheck_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 flag, 
    uint32 size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_BigIcmpCheck(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 flag, 
    uint32 size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_BigIcmpCheck_dispatch[dtype](unit, entry, flag, size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_BigIcmpCheck", 4, 3, unit, entry, flag, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_BigIcmpCheck_get( \
    int unit, bcm_field_entry_t entry, uint32 *flag, uint32 *size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_BigIcmpCheck_get,
static int (*_field_qualify_BigIcmpCheck_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *flag, 
    uint32 *size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_BigIcmpCheck_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *flag, 
    uint32 *size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_BigIcmpCheck_get_dispatch[dtype](unit, entry, flag, size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_BigIcmpCheck_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_BypassFilter( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_BypassFilter,
static int (*_field_qualify_BypassFilter_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_BypassFilter(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_BypassFilter_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_BypassFilter", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_BypassFilter32( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_BypassFilter32,
static int (*_field_qualify_BypassFilter32_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_BypassFilter32(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_BypassFilter32_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_BypassFilter32", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_BypassFilter32_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_BypassFilter32_get,
static int (*_field_qualify_BypassFilter32_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_BypassFilter32_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_BypassFilter32_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_BypassFilter32_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_BypassFilter_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_BypassFilter_get,
static int (*_field_qualify_BypassFilter_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_BypassFilter_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_BypassFilter_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_BypassFilter_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_BypassSrcMacFilter( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_BypassSrcMacFilter,
static int (*_field_qualify_BypassSrcMacFilter_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_BypassSrcMacFilter(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_BypassSrcMacFilter_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_BypassSrcMacFilter", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_BypassSrcMacFilter_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_BypassSrcMacFilter_get,
static int (*_field_qualify_BypassSrcMacFilter_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_BypassSrcMacFilter_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_BypassSrcMacFilter_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_BypassSrcMacFilter_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_CascadedKeyValue( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_CascadedKeyValue,
static int (*_field_qualify_CascadedKeyValue_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_CascadedKeyValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_CascadedKeyValue_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_CascadedKeyValue", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_CascadedKeyValue_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_CascadedKeyValue_get,
static int (*_field_qualify_CascadedKeyValue_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_CascadedKeyValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_CascadedKeyValue_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_CascadedKeyValue_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ClassId( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ClassId,
static int (*_field_qualify_ClassId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ClassId(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ClassId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ClassId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ClassId_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ClassId_get,
static int (*_field_qualify_ClassId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ClassId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ClassId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ClassId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_CnTag( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_CnTag,
static int (*_field_qualify_CnTag_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_CnTag(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_CnTag_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_CnTag", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_CnTag_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_CnTag_get,
static int (*_field_qualify_CnTag_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_CnTag_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_CnTag_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_CnTag_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Color( \
    int unit, bcm_field_entry_t entry, uint8 color);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Color,
static int (*_field_qualify_Color_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 color) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Color(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 color)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Color_dispatch[dtype](unit, entry, color);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Color", 3, 3, unit, entry, color, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Color_get( \
    int unit, bcm_field_entry_t entry, uint8 *color);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Color_get,
static int (*_field_qualify_Color_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *color) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Color_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *color)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Color_get_dispatch[dtype](unit, entry, color);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Color_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_CpuQueue( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_CpuQueue,
static int (*_field_qualify_CpuQueue_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_CpuQueue(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_CpuQueue_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_CpuQueue", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_CpuQueue_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_CpuQueue_get,
static int (*_field_qualify_CpuQueue_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_CpuQueue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_CpuQueue_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_CpuQueue_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DSCP( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DSCP,
static int (*_field_qualify_DSCP_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DSCP(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DSCP_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DSCP", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DSCP_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DSCP_get,
static int (*_field_qualify_DSCP_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DSCP_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DSCP_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DSCP_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Decap( \
    int unit, bcm_field_entry_t entry, bcm_field_decap_t decap);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Decap,
static int (*_field_qualify_Decap_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_decap_t decap) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Decap(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_decap_t decap)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Decap_dispatch[dtype](unit, entry, decap);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Decap", 3, 3, unit, entry, decap, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Dhcp( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Dhcp,
static int (*_field_qualify_Dhcp_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Dhcp(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Dhcp_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Dhcp", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Dhcp_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Dhcp_get,
static int (*_field_qualify_Dhcp_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Dhcp_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Dhcp_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Dhcp_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DosAttack( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DosAttack,
static int (*_field_qualify_DosAttack_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DosAttack(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DosAttack_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DosAttack", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DosAttack_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DosAttack_get,
static int (*_field_qualify_DosAttack_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DosAttack_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DosAttack_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DosAttack_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Drop( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Drop,
static int (*_field_qualify_Drop_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Drop(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Drop_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Drop", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Drop_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Drop_get,
static int (*_field_qualify_Drop_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Drop_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Drop_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Drop_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstClassField( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstClassField,
static int (*_field_qualify_DstClassField_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstClassField(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstClassField_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstClassField", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstClassField_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstClassField_get,
static int (*_field_qualify_DstClassField_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstClassField_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstClassField_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstClassField_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstClassL2( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstClassL2,
static int (*_field_qualify_DstClassL2_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstClassL2(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstClassL2_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstClassL2", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstClassL2_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstClassL2_get,
static int (*_field_qualify_DstClassL2_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstClassL2_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstClassL2_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstClassL2_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstClassL3( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstClassL3,
static int (*_field_qualify_DstClassL3_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstClassL3(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstClassL3_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstClassL3", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstClassL3_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstClassL3_get,
static int (*_field_qualify_DstClassL3_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstClassL3_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstClassL3_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstClassL3_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstGport,
static int (*_field_qualify_DstGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstGport_dispatch[dtype](unit, entry, port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstGport", 3, 3, unit, entry, port_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstGport_get,
static int (*_field_qualify_DstGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstGport_get_dispatch[dtype](unit, entry, port_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstHiGig( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstHiGig,
static int (*_field_qualify_DstHiGig_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstHiGig(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstHiGig_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstHiGig", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstHiGig_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstHiGig_get,
static int (*_field_qualify_DstHiGig_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstHiGig_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstHiGig_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstHiGig_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstIp( \
    int unit, bcm_field_entry_t entry, bcm_ip_t data, bcm_ip_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstIp,
static int (*_field_qualify_DstIp_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t data, 
    bcm_ip_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstIp(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t data, 
    bcm_ip_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstIp_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstIp", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstIp6( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t data, bcm_ip6_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstIp6,
static int (*_field_qualify_DstIp6_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstIp6(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstIp6_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstIp6", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstIp6High( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t data, bcm_ip6_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstIp6High,
static int (*_field_qualify_DstIp6High_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstIp6High(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstIp6High_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstIp6High", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstIp6High_get( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t *data, bcm_ip6_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstIp6High_get,
static int (*_field_qualify_DstIp6High_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstIp6High_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstIp6High_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstIp6High_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstIp6Low( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t data, bcm_ip6_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstIp6Low,
static int (*_field_qualify_DstIp6Low_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstIp6Low(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstIp6Low_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstIp6Low", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstIp6Low_get( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t *data, bcm_ip6_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstIp6Low_get,
static int (*_field_qualify_DstIp6Low_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstIp6Low_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstIp6Low_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstIp6Low_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstIp6_get( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t *data, bcm_ip6_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstIp6_get,
static int (*_field_qualify_DstIp6_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstIp6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstIp6_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstIp6_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstIpLocal( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstIpLocal,
static int (*_field_qualify_DstIpLocal_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstIpLocal(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstIpLocal_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstIpLocal", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstIpLocal_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstIpLocal_get,
static int (*_field_qualify_DstIpLocal_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstIpLocal_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstIpLocal_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstIpLocal_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstIp_get( \
    int unit, bcm_field_entry_t entry, bcm_ip_t *data, bcm_ip_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstIp_get,
static int (*_field_qualify_DstIp_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstIp_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstIp_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstIp_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstL3Egress( \
    int unit, bcm_field_entry_t entry, bcm_if_t if_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstL3Egress,
static int (*_field_qualify_DstL3Egress_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_if_t if_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstL3Egress(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_if_t if_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstL3Egress_dispatch[dtype](unit, entry, if_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstL3Egress", 3, 3, unit, entry, if_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstL3EgressNextHops( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstL3EgressNextHops,
static int (*_field_qualify_DstL3EgressNextHops_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstL3EgressNextHops(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstL3EgressNextHops_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstL3EgressNextHops", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstL3EgressNextHops_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstL3EgressNextHops_get,
static int (*_field_qualify_DstL3EgressNextHops_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstL3EgressNextHops_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstL3EgressNextHops_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstL3EgressNextHops_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstL3Egress_get( \
    int unit, bcm_field_entry_t entry, bcm_if_t *if_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstL3Egress_get,
static int (*_field_qualify_DstL3Egress_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_if_t *if_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstL3Egress_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_if_t *if_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstL3Egress_get_dispatch[dtype](unit, entry, if_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstL3Egress_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstMac( \
    int unit, bcm_field_entry_t entry, bcm_mac_t data, bcm_mac_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstMac,
static int (*_field_qualify_DstMac_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t data, 
    bcm_mac_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstMac(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t data, 
    bcm_mac_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstMac_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstMac", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstMac_get( \
    int unit, bcm_field_entry_t entry, bcm_mac_t *data, bcm_mac_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstMac_get,
static int (*_field_qualify_DstMac_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstMac_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstMac_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstMimGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t mim_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstMimGport,
static int (*_field_qualify_DstMimGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t mim_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstMimGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t mim_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mim_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstMimGport_dispatch[dtype](unit, entry, mim_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstMimGport", 3, 3, unit, entry, mim_port_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstMimGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *mim_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstMimGport_get,
static int (*_field_qualify_DstMimGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *mim_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstMimGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *mim_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstMimGport_get_dispatch[dtype](unit, entry, mim_port_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,mim_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstMimGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstMplsGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t mpls_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstMplsGport,
static int (*_field_qualify_DstMplsGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t mpls_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstMplsGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t mpls_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mpls_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstMplsGport_dispatch[dtype](unit, entry, mpls_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstMplsGport", 3, 3, unit, entry, mpls_port_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstMplsGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *mpls_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstMplsGport_get,
static int (*_field_qualify_DstMplsGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *mpls_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstMplsGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *mpls_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstMplsGport_get_dispatch[dtype](unit, entry, mpls_port_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,mpls_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstMplsGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstMulticastGroup( \
    int unit, bcm_field_entry_t entry, bcm_gport_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstMulticastGroup,
static int (*_field_qualify_DstMulticastGroup_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstMulticastGroup(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&group);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstMulticastGroup_dispatch[dtype](unit, entry, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstMulticastGroup", 3, 3, unit, entry, group, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstMulticastGroup_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstMulticastGroup_get,
static int (*_field_qualify_DstMulticastGroup_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstMulticastGroup_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstMulticastGroup_get_dispatch[dtype](unit, entry, group);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,group);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstMulticastGroup_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstMultipath( \
    int unit, bcm_field_entry_t entry, bcm_if_t mpintf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstMultipath,
static int (*_field_qualify_DstMultipath_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_if_t mpintf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstMultipath(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_if_t mpintf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstMultipath_dispatch[dtype](unit, entry, mpintf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstMultipath", 3, 3, unit, entry, mpintf, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstMultipath_get( \
    int unit, bcm_field_entry_t entry, bcm_if_t *mpintf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstMultipath_get,
static int (*_field_qualify_DstMultipath_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_if_t *mpintf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstMultipath_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_if_t *mpintf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstMultipath_get_dispatch[dtype](unit, entry, mpintf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstMultipath_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstNivGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t niv_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstNivGport,
static int (*_field_qualify_DstNivGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t niv_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstNivGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t niv_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&niv_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstNivGport_dispatch[dtype](unit, entry, niv_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstNivGport", 3, 3, unit, entry, niv_port_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstNivGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *niv_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstNivGport_get,
static int (*_field_qualify_DstNivGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *niv_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstNivGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *niv_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstNivGport_get_dispatch[dtype](unit, entry, niv_port_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,niv_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstNivGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstPort( \
    int unit, bcm_field_entry_t entry, bcm_module_t data_modid, bcm_module_t mask_modid, bcm_port_t data_port, bcm_port_t mask_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstPort,
static int (*_field_qualify_DstPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_module_t data_modid, 
    bcm_module_t mask_modid, 
    bcm_port_t data_port, 
    bcm_port_t mask_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstPort(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_module_t data_modid, 
    bcm_module_t mask_modid, 
    bcm_port_t data_port, 
    bcm_port_t mask_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&data_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstPort_dispatch[dtype](unit, entry, data_modid, mask_modid, data_port, mask_port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstPort", 6, 3, unit, entry, data_modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstPort_get( \
    int unit, bcm_field_entry_t entry, bcm_module_t *data_modid, bcm_module_t *mask_modid, bcm_port_t *data_port, bcm_port_t *mask_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstPort_get,
static int (*_field_qualify_DstPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_module_t *data_modid, 
    bcm_module_t *mask_modid, 
    bcm_port_t *data_port, 
    bcm_port_t *mask_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_module_t *data_modid, 
    bcm_module_t *mask_modid, 
    bcm_port_t *data_port, 
    bcm_port_t *mask_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstPort_get_dispatch[dtype](unit, entry, data_modid, mask_modid, data_port, mask_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,data_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstPort_get", 6, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstRpfGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstRpfGport,
static int (*_field_qualify_DstRpfGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstRpfGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&data);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstRpfGport_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstRpfGport", 3, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstRpfGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstRpfGport_get,
static int (*_field_qualify_DstRpfGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstRpfGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstRpfGport_get_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,data);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstRpfGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstTrunk( \
    int unit, bcm_field_entry_t entry, bcm_trunk_t data, bcm_trunk_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstTrunk,
static int (*_field_qualify_DstTrunk_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_trunk_t data, 
    bcm_trunk_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstTrunk(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_trunk_t data, 
    bcm_trunk_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstTrunk_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstTrunk", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstTrunk_get( \
    int unit, bcm_field_entry_t entry, bcm_trunk_t *data, bcm_trunk_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstTrunk_get,
static int (*_field_qualify_DstTrunk_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_trunk_t *data, 
    bcm_trunk_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstTrunk_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_trunk_t *data, 
    bcm_trunk_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstTrunk_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstTrunk_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstVxlanGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t vxlan_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstVxlanGport,
static int (*_field_qualify_DstVxlanGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t vxlan_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstVxlanGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t vxlan_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&vxlan_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstVxlanGport_dispatch[dtype](unit, entry, vxlan_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstVxlanGport", 3, 3, unit, entry, vxlan_port_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstVxlanGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *vxlan_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstVxlanGport_get,
static int (*_field_qualify_DstVxlanGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *vxlan_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstVxlanGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *vxlan_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstVxlanGport_get_dispatch[dtype](unit, entry, vxlan_port_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,vxlan_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstVxlanGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstWlanGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t wlan_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstWlanGport,
static int (*_field_qualify_DstWlanGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t wlan_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstWlanGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t wlan_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&wlan_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstWlanGport_dispatch[dtype](unit, entry, wlan_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstWlanGport", 3, 3, unit, entry, wlan_port_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_DstWlanGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *wlan_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_DstWlanGport_get,
static int (*_field_qualify_DstWlanGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *wlan_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_DstWlanGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *wlan_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_DstWlanGport_get_dispatch[dtype](unit, entry, wlan_port_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,wlan_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_DstWlanGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ECid( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ECid,
static int (*_field_qualify_ECid_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ECid(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ECid_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ECid", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ECid_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ECid_get,
static int (*_field_qualify_ECid_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ECid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ECid_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ECid_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ETag( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ETag,
static int (*_field_qualify_ETag_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ETag(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ETag_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ETag", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ETag_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ETag_get,
static int (*_field_qualify_ETag_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ETag_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ETag_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ETag_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EcnValue( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EcnValue,
static int (*_field_qualify_EcnValue_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EcnValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EcnValue_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EcnValue", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EcnValue_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EcnValue_get,
static int (*_field_qualify_EcnValue_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EcnValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EcnValue_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EcnValue_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EgressClass( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EgressClass,
static int (*_field_qualify_EgressClass_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EgressClass(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EgressClass_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EgressClass", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EgressClassL2Gre( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EgressClassL2Gre,
static int (*_field_qualify_EgressClassL2Gre_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EgressClassL2Gre(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EgressClassL2Gre_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EgressClassL2Gre", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EgressClassL2Gre_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EgressClassL2Gre_get,
static int (*_field_qualify_EgressClassL2Gre_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EgressClassL2Gre_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EgressClassL2Gre_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EgressClassL2Gre_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EgressClassL3Interface( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EgressClassL3Interface,
static int (*_field_qualify_EgressClassL3Interface_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EgressClassL3Interface(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EgressClassL3Interface_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EgressClassL3Interface", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EgressClassL3Interface_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EgressClassL3Interface_get,
static int (*_field_qualify_EgressClassL3Interface_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EgressClassL3Interface_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EgressClassL3Interface_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EgressClassL3Interface_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EgressClassTrill( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EgressClassTrill,
static int (*_field_qualify_EgressClassTrill_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EgressClassTrill(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EgressClassTrill_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EgressClassTrill", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EgressClassTrill_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EgressClassTrill_get,
static int (*_field_qualify_EgressClassTrill_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EgressClassTrill_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EgressClassTrill_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EgressClassTrill_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EgressClassWlan( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EgressClassWlan,
static int (*_field_qualify_EgressClassWlan_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EgressClassWlan(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EgressClassWlan_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EgressClassWlan", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EgressClassWlan_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EgressClassWlan_get,
static int (*_field_qualify_EgressClassWlan_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EgressClassWlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EgressClassWlan_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EgressClassWlan_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EgressClass_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EgressClass_get,
static int (*_field_qualify_EgressClass_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EgressClass_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EgressClass_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EgressClass_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EqualL4Port( \
    int unit, bcm_field_entry_t entry, uint32 flag);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EqualL4Port,
static int (*_field_qualify_EqualL4Port_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 flag) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EqualL4Port(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 flag)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EqualL4Port_dispatch[dtype](unit, entry, flag);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EqualL4Port", 3, 3, unit, entry, flag, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EqualL4Port_get( \
    int unit, bcm_field_entry_t entry, uint32 *flag);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EqualL4Port_get,
static int (*_field_qualify_EqualL4Port_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *flag) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EqualL4Port_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *flag)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EqualL4Port_get_dispatch[dtype](unit, entry, flag);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EqualL4Port_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EtherType( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EtherType,
static int (*_field_qualify_EtherType_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EtherType(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EtherType_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EtherType", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_EtherType_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_EtherType_get,
static int (*_field_qualify_EtherType_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_EtherType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_EtherType_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_EtherType_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExtensionHeader2Type( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExtensionHeader2Type,
static int (*_field_qualify_ExtensionHeader2Type_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExtensionHeader2Type(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExtensionHeader2Type_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExtensionHeader2Type", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExtensionHeader2Type_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExtensionHeader2Type_get,
static int (*_field_qualify_ExtensionHeader2Type_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExtensionHeader2Type_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExtensionHeader2Type_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExtensionHeader2Type_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExtensionHeaderSubCode( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExtensionHeaderSubCode,
static int (*_field_qualify_ExtensionHeaderSubCode_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExtensionHeaderSubCode(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExtensionHeaderSubCode_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExtensionHeaderSubCode", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExtensionHeaderSubCode_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExtensionHeaderSubCode_get,
static int (*_field_qualify_ExtensionHeaderSubCode_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExtensionHeaderSubCode_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExtensionHeaderSubCode_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExtensionHeaderSubCode_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExtensionHeaderType( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExtensionHeaderType,
static int (*_field_qualify_ExtensionHeaderType_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExtensionHeaderType(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExtensionHeaderType_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExtensionHeaderType", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExtensionHeaderType_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExtensionHeaderType_get,
static int (*_field_qualify_ExtensionHeaderType_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExtensionHeaderType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExtensionHeaderType_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExtensionHeaderType_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalHit0( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalHit0,
static int (*_field_qualify_ExternalHit0_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalHit0(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalHit0_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalHit0", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalHit0_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalHit0_get,
static int (*_field_qualify_ExternalHit0_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalHit0_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalHit0_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalHit0_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalHit1( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalHit1,
static int (*_field_qualify_ExternalHit1_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalHit1(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalHit1_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalHit1", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalHit1_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalHit1_get,
static int (*_field_qualify_ExternalHit1_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalHit1_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalHit1_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalHit1_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalHit2( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalHit2,
static int (*_field_qualify_ExternalHit2_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalHit2(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalHit2_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalHit2", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalHit2_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalHit2_get,
static int (*_field_qualify_ExternalHit2_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalHit2_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalHit2_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalHit2_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalHit3( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalHit3,
static int (*_field_qualify_ExternalHit3_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalHit3(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalHit3_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalHit3", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalHit3_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalHit3_get,
static int (*_field_qualify_ExternalHit3_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalHit3_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalHit3_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalHit3_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalValue0( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalValue0,
static int (*_field_qualify_ExternalValue0_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalValue0(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalValue0_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalValue0", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalValue0_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalValue0_get,
static int (*_field_qualify_ExternalValue0_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalValue0_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalValue0_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalValue0_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalValue1( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalValue1,
static int (*_field_qualify_ExternalValue1_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalValue1(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalValue1_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalValue1", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalValue1_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalValue1_get,
static int (*_field_qualify_ExternalValue1_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalValue1_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalValue1_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalValue1_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalValue2( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalValue2,
static int (*_field_qualify_ExternalValue2_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalValue2(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalValue2_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalValue2", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalValue2_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalValue2_get,
static int (*_field_qualify_ExternalValue2_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalValue2_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalValue2_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalValue2_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalValue3( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalValue3,
static int (*_field_qualify_ExternalValue3_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalValue3(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalValue3_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalValue3", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ExternalValue3_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ExternalValue3_get,
static int (*_field_qualify_ExternalValue3_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ExternalValue3_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ExternalValue3_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ExternalValue3_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FabricQueueTag( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FabricQueueTag,
static int (*_field_qualify_FabricQueueTag_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FabricQueueTag(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FabricQueueTag_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FabricQueueTag", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FabricQueueTag_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FabricQueueTag_get,
static int (*_field_qualify_FabricQueueTag_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FabricQueueTag_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FabricQueueTag_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FabricQueueTag_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FcoeSOF( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FcoeSOF,
static int (*_field_qualify_FcoeSOF_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FcoeSOF(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FcoeSOF_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FcoeSOF", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FcoeSOF_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FcoeSOF_get,
static int (*_field_qualify_FcoeSOF_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FcoeSOF_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FcoeSOF_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FcoeSOF_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FcoeVersionIsZero( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FcoeVersionIsZero,
static int (*_field_qualify_FcoeVersionIsZero_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FcoeVersionIsZero(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FcoeVersionIsZero_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FcoeVersionIsZero", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FcoeVersionIsZero_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FcoeVersionIsZero_get,
static int (*_field_qualify_FcoeVersionIsZero_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FcoeVersionIsZero_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FcoeVersionIsZero_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FcoeVersionIsZero_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Fhei( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Fhei,
static int (*_field_qualify_Fhei_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Fhei(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Fhei_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Fhei", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FheiSize( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FheiSize,
static int (*_field_qualify_FheiSize_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FheiSize(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FheiSize_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FheiSize", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FheiSize_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FheiSize_get,
static int (*_field_qualify_FheiSize_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FheiSize_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FheiSize_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FheiSize_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Fhei_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Fhei_get,
static int (*_field_qualify_Fhei_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Fhei_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Fhei_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Fhei_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanCSCtl( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanCSCtl,
static int (*_field_qualify_FibreChanCSCtl_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanCSCtl(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanCSCtl_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanCSCtl", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanCSCtl_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanCSCtl_get,
static int (*_field_qualify_FibreChanCSCtl_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanCSCtl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanCSCtl_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanCSCtl_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanDFCtl( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanDFCtl,
static int (*_field_qualify_FibreChanDFCtl_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanDFCtl(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanDFCtl_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanDFCtl", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanDFCtl_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanDFCtl_get,
static int (*_field_qualify_FibreChanDFCtl_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanDFCtl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanDFCtl_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanDFCtl_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanDstId( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanDstId,
static int (*_field_qualify_FibreChanDstId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanDstId(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanDstId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanDstId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanDstId_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanDstId_get,
static int (*_field_qualify_FibreChanDstId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanDstId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanDstId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanDstId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanFCtl( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanFCtl,
static int (*_field_qualify_FibreChanFCtl_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanFCtl(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanFCtl_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanFCtl", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanFCtl_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanFCtl_get,
static int (*_field_qualify_FibreChanFCtl_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanFCtl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanFCtl_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanFCtl_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanInner( \
    int unit, bcm_field_entry_t entry, bcm_field_FibreChan_t fibre_chan_type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanInner,
static int (*_field_qualify_FibreChanInner_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_FibreChan_t fibre_chan_type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanInner(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_FibreChan_t fibre_chan_type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanInner_dispatch[dtype](unit, entry, fibre_chan_type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanInner", 3, 3, unit, entry, fibre_chan_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanInner_get( \
    int unit, bcm_field_entry_t entry, bcm_field_FibreChan_t *fibre_chan_type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanInner_get,
static int (*_field_qualify_FibreChanInner_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_FibreChan_t *fibre_chan_type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanInner_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_FibreChan_t *fibre_chan_type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanInner_get_dispatch[dtype](unit, entry, fibre_chan_type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanInner_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanOuter( \
    int unit, bcm_field_entry_t entry, bcm_field_FibreChan_t fibre_chan_type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanOuter,
static int (*_field_qualify_FibreChanOuter_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_FibreChan_t fibre_chan_type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanOuter(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_FibreChan_t fibre_chan_type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanOuter_dispatch[dtype](unit, entry, fibre_chan_type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanOuter", 3, 3, unit, entry, fibre_chan_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanOuter_get( \
    int unit, bcm_field_entry_t entry, bcm_field_FibreChan_t *fibre_chan_type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanOuter_get,
static int (*_field_qualify_FibreChanOuter_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_FibreChan_t *fibre_chan_type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanOuter_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_FibreChan_t *fibre_chan_type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanOuter_get_dispatch[dtype](unit, entry, fibre_chan_type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanOuter_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanRCtl( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanRCtl,
static int (*_field_qualify_FibreChanRCtl_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanRCtl(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanRCtl_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanRCtl", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanRCtl_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanRCtl_get,
static int (*_field_qualify_FibreChanRCtl_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanRCtl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanRCtl_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanRCtl_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanSrcBindCheck( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanSrcBindCheck,
static int (*_field_qualify_FibreChanSrcBindCheck_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanSrcBindCheck(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanSrcBindCheck_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanSrcBindCheck", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanSrcBindCheck_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanSrcBindCheck_get,
static int (*_field_qualify_FibreChanSrcBindCheck_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanSrcBindCheck_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanSrcBindCheck_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanSrcBindCheck_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanSrcFpmaCheck( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanSrcFpmaCheck,
static int (*_field_qualify_FibreChanSrcFpmaCheck_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanSrcFpmaCheck(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanSrcFpmaCheck_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanSrcFpmaCheck", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanSrcFpmaCheck_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanSrcFpmaCheck_get,
static int (*_field_qualify_FibreChanSrcFpmaCheck_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanSrcFpmaCheck_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanSrcFpmaCheck_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanSrcFpmaCheck_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanSrcId( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanSrcId,
static int (*_field_qualify_FibreChanSrcId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanSrcId(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanSrcId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanSrcId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanSrcId_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanSrcId_get,
static int (*_field_qualify_FibreChanSrcId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanSrcId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanSrcId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanSrcId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanType( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanType,
static int (*_field_qualify_FibreChanType_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanType(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanType_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanType", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanType_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanType_get,
static int (*_field_qualify_FibreChanType_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanType_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanType_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanVFTFabricId( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanVFTFabricId,
static int (*_field_qualify_FibreChanVFTFabricId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanVFTFabricId(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanVFTFabricId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanVFTFabricId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanVFTFabricId_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanVFTFabricId_get,
static int (*_field_qualify_FibreChanVFTFabricId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanVFTFabricId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanVFTFabricId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanVFTFabricId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanVFTHopCount( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanVFTHopCount,
static int (*_field_qualify_FibreChanVFTHopCount_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanVFTHopCount(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanVFTHopCount_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanVFTHopCount", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanVFTHopCount_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanVFTHopCount_get,
static int (*_field_qualify_FibreChanVFTHopCount_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanVFTHopCount_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanVFTHopCount_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanVFTHopCount_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanVFTPri( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanVFTPri,
static int (*_field_qualify_FibreChanVFTPri_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanVFTPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanVFTPri_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanVFTPri", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanVFTPri_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanVFTPri_get,
static int (*_field_qualify_FibreChanVFTPri_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanVFTPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanVFTPri_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanVFTPri_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanVFTValid( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanVFTValid,
static int (*_field_qualify_FibreChanVFTValid_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanVFTValid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanVFTValid_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanVFTValid", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanVFTValid_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanVFTValid_get,
static int (*_field_qualify_FibreChanVFTValid_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanVFTValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanVFTValid_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanVFTValid_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanVFTVersion( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanVFTVersion,
static int (*_field_qualify_FibreChanVFTVersion_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanVFTVersion(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanVFTVersion_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanVFTVersion", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanVFTVersion_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanVFTVersion_get,
static int (*_field_qualify_FibreChanVFTVersion_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanVFTVersion_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanVFTVersion_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanVFTVersion_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanVFTVsanId( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanVFTVsanId,
static int (*_field_qualify_FibreChanVFTVsanId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanVFTVsanId(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanVFTVsanId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanVFTVsanId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanVFTVsanId_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanVFTVsanId_get,
static int (*_field_qualify_FibreChanVFTVsanId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanVFTVsanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanVFTVsanId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanVFTVsanId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanVFTVsanPri( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanVFTVsanPri,
static int (*_field_qualify_FibreChanVFTVsanPri_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanVFTVsanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanVFTVsanPri_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanVFTVsanPri", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanVFTVsanPri_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanVFTVsanPri_get,
static int (*_field_qualify_FibreChanVFTVsanPri_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanVFTVsanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanVFTVsanPri_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanVFTVsanPri_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanZoneCheck( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanZoneCheck,
static int (*_field_qualify_FibreChanZoneCheck_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanZoneCheck(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanZoneCheck_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanZoneCheck", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FibreChanZoneCheck_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FibreChanZoneCheck_get,
static int (*_field_qualify_FibreChanZoneCheck_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FibreChanZoneCheck_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FibreChanZoneCheck_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FibreChanZoneCheck_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FlowId( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FlowId,
static int (*_field_qualify_FlowId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FlowId(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FlowId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FlowId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_FlowId_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_FlowId_get,
static int (*_field_qualify_FlowId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_FlowId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_FlowId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_FlowId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ForwardCopy( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ForwardCopy,
static int (*_field_qualify_ForwardCopy_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ForwardCopy(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ForwardCopy_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ForwardCopy", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ForwardCopy_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ForwardCopy_get,
static int (*_field_qualify_ForwardCopy_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ForwardCopy_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ForwardCopy_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ForwardCopy_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ForwardingHeaderOffset( \
    int unit, bcm_field_entry_t entry, bcm_field_data_offset_base_t base_header, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ForwardingHeaderOffset,
static int (*_field_qualify_ForwardingHeaderOffset_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_data_offset_base_t base_header, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ForwardingHeaderOffset(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_data_offset_base_t base_header, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ForwardingHeaderOffset_dispatch[dtype](unit, entry, base_header, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ForwardingHeaderOffset", 5, 3, unit, entry, base_header, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ForwardingHeaderOffset_get( \
    int unit, bcm_field_entry_t entry, bcm_field_data_offset_base_t *base_header, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ForwardingHeaderOffset_get,
static int (*_field_qualify_ForwardingHeaderOffset_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_data_offset_base_t *base_header, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ForwardingHeaderOffset_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_data_offset_base_t *base_header, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ForwardingHeaderOffset_get_dispatch[dtype](unit, entry, base_header, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ForwardingHeaderOffset_get", 5, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ForwardingType( \
    int unit, bcm_field_entry_t entry, bcm_field_ForwardingType_t type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ForwardingType,
static int (*_field_qualify_ForwardingType_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ForwardingType_t type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ForwardingType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ForwardingType_t type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ForwardingType_dispatch[dtype](unit, entry, type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ForwardingType", 3, 3, unit, entry, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ForwardingType_get( \
    int unit, bcm_field_entry_t entry, bcm_field_ForwardingType_t *type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ForwardingType_get,
static int (*_field_qualify_ForwardingType_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ForwardingType_t *type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ForwardingType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_ForwardingType_t *type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ForwardingType_get_dispatch[dtype](unit, entry, type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ForwardingType_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ForwardingVlanId( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t data, bcm_vlan_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ForwardingVlanId,
static int (*_field_qualify_ForwardingVlanId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ForwardingVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ForwardingVlanId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ForwardingVlanId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ForwardingVlanId_get( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t *data, bcm_vlan_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ForwardingVlanId_get,
static int (*_field_qualify_ForwardingVlanId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ForwardingVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ForwardingVlanId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ForwardingVlanId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ForwardingVlanValid( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ForwardingVlanValid,
static int (*_field_qualify_ForwardingVlanValid_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ForwardingVlanValid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ForwardingVlanValid_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ForwardingVlanValid", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ForwardingVlanValid_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ForwardingVlanValid_get,
static int (*_field_qualify_ForwardingVlanValid_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ForwardingVlanValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ForwardingVlanValid_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ForwardingVlanValid_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_GenericAssociatedChannelLabelValid( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_GenericAssociatedChannelLabelValid,
static int (*_field_qualify_GenericAssociatedChannelLabelValid_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_GenericAssociatedChannelLabelValid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_GenericAssociatedChannelLabelValid_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_GenericAssociatedChannelLabelValid", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_GenericAssociatedChannelLabelValid_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_GenericAssociatedChannelLabelValid_get,
static int (*_field_qualify_GenericAssociatedChannelLabelValid_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_GenericAssociatedChannelLabelValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_GenericAssociatedChannelLabelValid_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_GenericAssociatedChannelLabelValid_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_HeaderFormat( \
    int unit, bcm_field_entry_t entry, bcm_field_header_format_t header_format);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_HeaderFormat,
static int (*_field_qualify_HeaderFormat_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_header_format_t header_format) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_HeaderFormat(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_header_format_t header_format)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_HeaderFormat_dispatch[dtype](unit, entry, header_format);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_HeaderFormat", 3, 3, unit, entry, header_format, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_HeaderFormatSet( \
    int unit, bcm_field_entry_t entry, bcm_field_header_format_set_t header_format_set);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_HeaderFormatSet,
static int (*_field_qualify_HeaderFormatSet_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_header_format_set_t header_format_set) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_HeaderFormatSet(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_header_format_set_t header_format_set)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_HeaderFormatSet_dispatch[dtype](unit, entry, header_format_set);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_HeaderFormatSet", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_HeaderFormatSet_get( \
    int unit, bcm_field_entry_t entry, bcm_field_header_format_set_t *header_format_set);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_HeaderFormatSet_get,
static int (*_field_qualify_HeaderFormatSet_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_header_format_set_t *header_format_set) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_HeaderFormatSet_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_header_format_set_t *header_format_set)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_HeaderFormatSet_get_dispatch[dtype](unit, entry, header_format_set);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_HeaderFormatSet_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_HeaderFormat_get( \
    int unit, bcm_field_entry_t entry, bcm_field_header_format_t *header_format);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_HeaderFormat_get,
static int (*_field_qualify_HeaderFormat_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_header_format_t *header_format) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_HeaderFormat_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_header_format_t *header_format)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_HeaderFormat_get_dispatch[dtype](unit, entry, header_format);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_HeaderFormat_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_HiGig( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_HiGig,
static int (*_field_qualify_HiGig_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_HiGig(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_HiGig_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_HiGig", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_HiGigProxy( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_HiGigProxy,
static int (*_field_qualify_HiGigProxy_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_HiGigProxy(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_HiGigProxy_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_HiGigProxy", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_HiGigProxy_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_HiGigProxy_get,
static int (*_field_qualify_HiGigProxy_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_HiGigProxy_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_HiGigProxy_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_HiGigProxy_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_HiGig_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_HiGig_get,
static int (*_field_qualify_HiGig_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_HiGig_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_HiGig_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_HiGig_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ISid( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ISid,
static int (*_field_qualify_ISid_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ISid(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ISid_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ISid", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ISid_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ISid_get,
static int (*_field_qualify_ISid_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ISid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ISid_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ISid_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IcmpError( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IcmpError,
static int (*_field_qualify_IcmpError_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IcmpError(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IcmpError_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IcmpError", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IcmpError_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IcmpError_get,
static int (*_field_qualify_IcmpError_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IcmpError_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IcmpError_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IcmpError_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IcmpTypeCode( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IcmpTypeCode,
static int (*_field_qualify_IcmpTypeCode_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IcmpTypeCode(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IcmpTypeCode_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IcmpTypeCode", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IcmpTypeCode_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IcmpTypeCode_get,
static int (*_field_qualify_IcmpTypeCode_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IcmpTypeCode_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IcmpTypeCode_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IcmpTypeCode_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IgmpTypeMaxRespTime( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IgmpTypeMaxRespTime,
static int (*_field_qualify_IgmpTypeMaxRespTime_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IgmpTypeMaxRespTime(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IgmpTypeMaxRespTime_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IgmpTypeMaxRespTime", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IgmpTypeMaxRespTime_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IgmpTypeMaxRespTime_get,
static int (*_field_qualify_IgmpTypeMaxRespTime_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IgmpTypeMaxRespTime_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IgmpTypeMaxRespTime_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IgmpTypeMaxRespTime_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InPort( \
    int unit, bcm_field_entry_t entry, bcm_port_t data, bcm_port_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InPort,
static int (*_field_qualify_InPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_port_t data, 
    bcm_port_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InPort(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_port_t data, 
    bcm_port_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&data);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InPort_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InPort", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InPort_get( \
    int unit, bcm_field_entry_t entry, bcm_port_t *data, bcm_port_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InPort_get,
static int (*_field_qualify_InPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_port_t *data, 
    bcm_port_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_port_t *data, 
    bcm_port_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InPort_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,data);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InPort_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InPorts( \
    int unit, bcm_field_entry_t entry, bcm_pbmp_t data, bcm_pbmp_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InPorts,
static int (*_field_qualify_InPorts_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_pbmp_t data, 
    bcm_pbmp_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InPorts(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_pbmp_t data, 
    bcm_pbmp_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_data);
		BCM_API_XLATE_PORT_PBMP_DECL(t_mask);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_data,data);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&data);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_mask,mask);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&mask);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InPorts_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(data,t_data);
		BCM_API_XLATE_PORT_PBMP_RESTORE(mask,t_mask);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InPorts", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InPorts_get( \
    int unit, bcm_field_entry_t entry, bcm_pbmp_t *data, bcm_pbmp_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InPorts_get,
static int (*_field_qualify_InPorts_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_pbmp_t *data, 
    bcm_pbmp_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InPorts_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_pbmp_t *data, 
    bcm_pbmp_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InPorts_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,data);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,mask);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InPorts_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InVPort( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InVPort,
static int (*_field_qualify_InVPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InVPort(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InVPort_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InVPort", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InVPort32( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InVPort32,
static int (*_field_qualify_InVPort32_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InVPort32(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InVPort32_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InVPort32", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InVPort32_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InVPort32_get,
static int (*_field_qualify_InVPort32_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InVPort32_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InVPort32_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InVPort32_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InVPort_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InVPort_get,
static int (*_field_qualify_InVPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InVPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InVPort_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InVPort_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IncomingIpIfClass( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IncomingIpIfClass,
static int (*_field_qualify_IncomingIpIfClass_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IncomingIpIfClass(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IncomingIpIfClass_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IncomingIpIfClass", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IncomingIpIfClass_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IncomingIpIfClass_get,
static int (*_field_qualify_IncomingIpIfClass_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IncomingIpIfClass_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IncomingIpIfClass_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IncomingIpIfClass_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IngressClassField( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IngressClassField,
static int (*_field_qualify_IngressClassField_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IngressClassField(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IngressClassField_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IngressClassField", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IngressClassField_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IngressClassField_get,
static int (*_field_qualify_IngressClassField_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IngressClassField_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IngressClassField_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IngressClassField_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IngressECid( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IngressECid,
static int (*_field_qualify_IngressECid_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IngressECid(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IngressECid_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IngressECid", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IngressECid_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IngressECid_get,
static int (*_field_qualify_IngressECid_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IngressECid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IngressECid_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IngressECid_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IngressInterfaceClassPort( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IngressInterfaceClassPort,
static int (*_field_qualify_IngressInterfaceClassPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IngressInterfaceClassPort(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IngressInterfaceClassPort_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IngressInterfaceClassPort", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IngressInterfaceClassPort_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IngressInterfaceClassPort_get,
static int (*_field_qualify_IngressInterfaceClassPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IngressInterfaceClassPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IngressInterfaceClassPort_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IngressInterfaceClassPort_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IngressStpState( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IngressStpState,
static int (*_field_qualify_IngressStpState_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IngressStpState(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IngressStpState_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IngressStpState", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IngressStpState_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IngressStpState_get,
static int (*_field_qualify_IngressStpState_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IngressStpState_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IngressStpState_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IngressStpState_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IngressVPortBridgeDisable( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IngressVPortBridgeDisable,
static int (*_field_qualify_IngressVPortBridgeDisable_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IngressVPortBridgeDisable(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IngressVPortBridgeDisable_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IngressVPortBridgeDisable", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IngressVPortBridgeDisable_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IngressVPortBridgeDisable_get,
static int (*_field_qualify_IngressVPortBridgeDisable_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IngressVPortBridgeDisable_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IngressVPortBridgeDisable_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IngressVPortBridgeDisable_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerDSCP( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerDSCP,
static int (*_field_qualify_InnerDSCP_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerDSCP(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerDSCP_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerDSCP", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerDSCP_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerDSCP_get,
static int (*_field_qualify_InnerDSCP_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerDSCP_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerDSCP_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerDSCP_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerDstIp( \
    int unit, bcm_field_entry_t entry, bcm_ip_t data, bcm_ip_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerDstIp,
static int (*_field_qualify_InnerDstIp_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t data, 
    bcm_ip_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerDstIp(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t data, 
    bcm_ip_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerDstIp_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerDstIp", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerDstIp6( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t data, bcm_ip6_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerDstIp6,
static int (*_field_qualify_InnerDstIp6_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerDstIp6(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerDstIp6_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerDstIp6", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerDstIp6High( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t data, bcm_ip6_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerDstIp6High,
static int (*_field_qualify_InnerDstIp6High_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerDstIp6High(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerDstIp6High_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerDstIp6High", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerDstIp6High_get( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t *data, bcm_ip6_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerDstIp6High_get,
static int (*_field_qualify_InnerDstIp6High_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerDstIp6High_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerDstIp6High_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerDstIp6High_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerDstIp6_get( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t *data, bcm_ip6_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerDstIp6_get,
static int (*_field_qualify_InnerDstIp6_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerDstIp6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerDstIp6_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerDstIp6_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerDstIp_get( \
    int unit, bcm_field_entry_t entry, bcm_ip_t *data, bcm_ip_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerDstIp_get,
static int (*_field_qualify_InnerDstIp_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerDstIp_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerDstIp_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerDstIp_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerDstMac( \
    int unit, bcm_field_entry_t entry, bcm_mac_t data, bcm_mac_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerDstMac,
static int (*_field_qualify_InnerDstMac_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t data, 
    bcm_mac_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerDstMac(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t data, 
    bcm_mac_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerDstMac_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerDstMac", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerDstMac_get( \
    int unit, bcm_field_entry_t entry, bcm_mac_t *data, bcm_mac_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerDstMac_get,
static int (*_field_qualify_InnerDstMac_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerDstMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerDstMac_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerDstMac_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerEtherType( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerEtherType,
static int (*_field_qualify_InnerEtherType_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerEtherType(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerEtherType_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerEtherType", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerEtherType_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerEtherType_get,
static int (*_field_qualify_InnerEtherType_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerEtherType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerEtherType_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerEtherType_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerIp6FlowLabel( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerIp6FlowLabel,
static int (*_field_qualify_InnerIp6FlowLabel_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerIp6FlowLabel(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerIp6FlowLabel_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerIp6FlowLabel", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerIp6FlowLabel_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerIp6FlowLabel_get,
static int (*_field_qualify_InnerIp6FlowLabel_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerIp6FlowLabel_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerIp6FlowLabel_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerIp6FlowLabel_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerIp6HopLimit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerIp6HopLimit,
static int (*_field_qualify_InnerIp6HopLimit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerIp6HopLimit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerIp6HopLimit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerIp6HopLimit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerIp6HopLimit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerIp6HopLimit_get,
static int (*_field_qualify_InnerIp6HopLimit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerIp6HopLimit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerIp6HopLimit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerIp6HopLimit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerIp6NextHeader( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerIp6NextHeader,
static int (*_field_qualify_InnerIp6NextHeader_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerIp6NextHeader(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerIp6NextHeader_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerIp6NextHeader", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerIp6NextHeader_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerIp6NextHeader_get,
static int (*_field_qualify_InnerIp6NextHeader_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerIp6NextHeader_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerIp6NextHeader_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerIp6NextHeader_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerIpFrag( \
    int unit, bcm_field_entry_t entry, bcm_field_IpFrag_t frag_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerIpFrag,
static int (*_field_qualify_InnerIpFrag_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpFrag_t frag_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerIpFrag(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpFrag_t frag_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerIpFrag_dispatch[dtype](unit, entry, frag_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerIpFrag", 3, 3, unit, entry, frag_info, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerIpFrag_get( \
    int unit, bcm_field_entry_t entry, bcm_field_IpFrag_t *frag_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerIpFrag_get,
static int (*_field_qualify_InnerIpFrag_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpFrag_t *frag_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerIpFrag_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpFrag_t *frag_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerIpFrag_get_dispatch[dtype](unit, entry, frag_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerIpFrag_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerIpProtocol( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerIpProtocol,
static int (*_field_qualify_InnerIpProtocol_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerIpProtocol(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerIpProtocol_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerIpProtocol", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerIpProtocolCommon( \
    int unit, bcm_field_entry_t entry, bcm_field_IpProtocolCommon_t protocol);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerIpProtocolCommon,
static int (*_field_qualify_InnerIpProtocolCommon_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpProtocolCommon_t protocol) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerIpProtocolCommon(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpProtocolCommon_t protocol)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerIpProtocolCommon_dispatch[dtype](unit, entry, protocol);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerIpProtocolCommon", 3, 3, unit, entry, protocol, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerIpProtocolCommon_get( \
    int unit, bcm_field_entry_t entry, bcm_field_IpProtocolCommon_t *protocol);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerIpProtocolCommon_get,
static int (*_field_qualify_InnerIpProtocolCommon_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpProtocolCommon_t *protocol) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerIpProtocolCommon_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpProtocolCommon_t *protocol)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerIpProtocolCommon_get_dispatch[dtype](unit, entry, protocol);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerIpProtocolCommon_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerIpProtocol_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerIpProtocol_get,
static int (*_field_qualify_InnerIpProtocol_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerIpProtocol_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerIpProtocol_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerIpProtocol_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerIpType( \
    int unit, bcm_field_entry_t entry, bcm_field_IpType_t type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerIpType,
static int (*_field_qualify_InnerIpType_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpType_t type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerIpType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpType_t type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerIpType_dispatch[dtype](unit, entry, type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerIpType", 3, 3, unit, entry, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerIpType_get( \
    int unit, bcm_field_entry_t entry, bcm_field_IpType_t *type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerIpType_get,
static int (*_field_qualify_InnerIpType_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpType_t *type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerIpType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpType_t *type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerIpType_get_dispatch[dtype](unit, entry, type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerIpType_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerL4DstPort( \
    int unit, bcm_field_entry_t entry, bcm_l4_port_t data, bcm_l4_port_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerL4DstPort,
static int (*_field_qualify_InnerL4DstPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t data, 
    bcm_l4_port_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerL4DstPort(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t data, 
    bcm_l4_port_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerL4DstPort_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerL4DstPort", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerL4DstPort_get( \
    int unit, bcm_field_entry_t entry, bcm_l4_port_t *data, bcm_l4_port_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerL4DstPort_get,
static int (*_field_qualify_InnerL4DstPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerL4DstPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerL4DstPort_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerL4DstPort_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerL4SrcPort( \
    int unit, bcm_field_entry_t entry, bcm_l4_port_t data, bcm_l4_port_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerL4SrcPort,
static int (*_field_qualify_InnerL4SrcPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t data, 
    bcm_l4_port_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerL4SrcPort(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t data, 
    bcm_l4_port_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerL4SrcPort_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerL4SrcPort", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerL4SrcPort_get( \
    int unit, bcm_field_entry_t entry, bcm_l4_port_t *data, bcm_l4_port_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerL4SrcPort_get,
static int (*_field_qualify_InnerL4SrcPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerL4SrcPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerL4SrcPort_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerL4SrcPort_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerSrcIp( \
    int unit, bcm_field_entry_t entry, bcm_ip_t data, bcm_ip_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerSrcIp,
static int (*_field_qualify_InnerSrcIp_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t data, 
    bcm_ip_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerSrcIp(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t data, 
    bcm_ip_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerSrcIp_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerSrcIp", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerSrcIp6( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t data, bcm_ip6_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerSrcIp6,
static int (*_field_qualify_InnerSrcIp6_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerSrcIp6(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerSrcIp6_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerSrcIp6", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerSrcIp6High( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t data, bcm_ip6_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerSrcIp6High,
static int (*_field_qualify_InnerSrcIp6High_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerSrcIp6High(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerSrcIp6High_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerSrcIp6High", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerSrcIp6High_get( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t *data, bcm_ip6_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerSrcIp6High_get,
static int (*_field_qualify_InnerSrcIp6High_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerSrcIp6High_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerSrcIp6High_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerSrcIp6High_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerSrcIp6_get( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t *data, bcm_ip6_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerSrcIp6_get,
static int (*_field_qualify_InnerSrcIp6_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerSrcIp6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerSrcIp6_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerSrcIp6_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerSrcIp_get( \
    int unit, bcm_field_entry_t entry, bcm_ip_t *data, bcm_ip_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerSrcIp_get,
static int (*_field_qualify_InnerSrcIp_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerSrcIp_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerSrcIp_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerSrcIp_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerSrcMac( \
    int unit, bcm_field_entry_t entry, bcm_mac_t data, bcm_mac_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerSrcMac,
static int (*_field_qualify_InnerSrcMac_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t data, 
    bcm_mac_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerSrcMac(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t data, 
    bcm_mac_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerSrcMac_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerSrcMac", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerSrcMac_get( \
    int unit, bcm_field_entry_t entry, bcm_mac_t *data, bcm_mac_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerSrcMac_get,
static int (*_field_qualify_InnerSrcMac_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerSrcMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerSrcMac_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerSrcMac_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerTos( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerTos,
static int (*_field_qualify_InnerTos_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerTos(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerTos_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerTos", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerTos_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerTos_get,
static int (*_field_qualify_InnerTos_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerTos_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerTos_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerTos_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerTpid( \
    int unit, bcm_field_entry_t entry, uint16 tpid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerTpid,
static int (*_field_qualify_InnerTpid_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 tpid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerTpid(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 tpid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerTpid_dispatch[dtype](unit, entry, tpid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerTpid", 3, 3, unit, entry, tpid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerTpid_get( \
    int unit, bcm_field_entry_t entry, uint16 *tpid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerTpid_get,
static int (*_field_qualify_InnerTpid_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *tpid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerTpid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *tpid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerTpid_get_dispatch[dtype](unit, entry, tpid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerTpid_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerTtl( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerTtl,
static int (*_field_qualify_InnerTtl_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerTtl(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerTtl_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerTtl", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerTtl_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerTtl_get,
static int (*_field_qualify_InnerTtl_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerTtl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerTtl_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerTtl_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerVlan( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t data, bcm_vlan_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerVlan,
static int (*_field_qualify_InnerVlan_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerVlan(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerVlan_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerVlan", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerVlanActionRange( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t data, bcm_vlan_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerVlanActionRange,
static int (*_field_qualify_InnerVlanActionRange_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerVlanActionRange(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerVlanActionRange_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerVlanActionRange", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerVlanActionRange_get( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t *data, bcm_vlan_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerVlanActionRange_get,
static int (*_field_qualify_InnerVlanActionRange_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerVlanActionRange_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerVlanActionRange_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerVlanActionRange_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerVlanCfi( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerVlanCfi,
static int (*_field_qualify_InnerVlanCfi_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerVlanCfi_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerVlanCfi", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerVlanCfi_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerVlanCfi_get,
static int (*_field_qualify_InnerVlanCfi_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerVlanCfi_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerVlanCfi_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerVlanId( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t data, bcm_vlan_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerVlanId,
static int (*_field_qualify_InnerVlanId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerVlanId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerVlanId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerVlanId_get( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t *data, bcm_vlan_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerVlanId_get,
static int (*_field_qualify_InnerVlanId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerVlanId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerVlanId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerVlanPri( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerVlanPri,
static int (*_field_qualify_InnerVlanPri_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerVlanPri_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerVlanPri", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerVlanPri_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerVlanPri_get,
static int (*_field_qualify_InnerVlanPri_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerVlanPri_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerVlanPri_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InnerVlan_get( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t *data, bcm_vlan_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InnerVlan_get,
static int (*_field_qualify_InnerVlan_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InnerVlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InnerVlan_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InnerVlan_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IntCongestionNotification( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IntCongestionNotification,
static int (*_field_qualify_IntCongestionNotification_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IntCongestionNotification(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IntCongestionNotification_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IntCongestionNotification", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IntCongestionNotification_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IntCongestionNotification_get,
static int (*_field_qualify_IntCongestionNotification_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IntCongestionNotification_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IntCongestionNotification_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IntCongestionNotification_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IntPriority( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IntPriority,
static int (*_field_qualify_IntPriority_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IntPriority(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IntPriority_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IntPriority", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IntPriority_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IntPriority_get,
static int (*_field_qualify_IntPriority_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IntPriority_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IntPriority_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IntPriority_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InterfaceClassL2( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InterfaceClassL2,
static int (*_field_qualify_InterfaceClassL2_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InterfaceClassL2(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InterfaceClassL2_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InterfaceClassL2", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InterfaceClassL2_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InterfaceClassL2_get,
static int (*_field_qualify_InterfaceClassL2_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InterfaceClassL2_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InterfaceClassL2_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InterfaceClassL2_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InterfaceClassL3( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InterfaceClassL3,
static int (*_field_qualify_InterfaceClassL3_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InterfaceClassL3(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InterfaceClassL3_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InterfaceClassL3", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InterfaceClassL3_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InterfaceClassL3_get,
static int (*_field_qualify_InterfaceClassL3_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InterfaceClassL3_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InterfaceClassL3_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InterfaceClassL3_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InterfaceClassPort( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InterfaceClassPort,
static int (*_field_qualify_InterfaceClassPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InterfaceClassPort(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InterfaceClassPort_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InterfaceClassPort", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InterfaceClassPort_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InterfaceClassPort_get,
static int (*_field_qualify_InterfaceClassPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InterfaceClassPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InterfaceClassPort_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InterfaceClassPort_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InterfaceClassProcessingPort( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InterfaceClassProcessingPort,
static int (*_field_qualify_InterfaceClassProcessingPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InterfaceClassProcessingPort(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InterfaceClassProcessingPort_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InterfaceClassProcessingPort", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InterfaceClassProcessingPort_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InterfaceClassProcessingPort_get,
static int (*_field_qualify_InterfaceClassProcessingPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InterfaceClassProcessingPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InterfaceClassProcessingPort_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InterfaceClassProcessingPort_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InterfaceClassVPort( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InterfaceClassVPort,
static int (*_field_qualify_InterfaceClassVPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InterfaceClassVPort(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InterfaceClassVPort_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InterfaceClassVPort", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_InterfaceClassVPort_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_InterfaceClassVPort_get,
static int (*_field_qualify_InterfaceClassVPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_InterfaceClassVPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_InterfaceClassVPort_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_InterfaceClassVPort_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Ip6FlowLabel( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Ip6FlowLabel,
static int (*_field_qualify_Ip6FlowLabel_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Ip6FlowLabel(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Ip6FlowLabel_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Ip6FlowLabel", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Ip6FlowLabel_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Ip6FlowLabel_get,
static int (*_field_qualify_Ip6FlowLabel_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Ip6FlowLabel_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Ip6FlowLabel_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Ip6FlowLabel_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Ip6HopLimit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Ip6HopLimit,
static int (*_field_qualify_Ip6HopLimit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Ip6HopLimit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Ip6HopLimit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Ip6HopLimit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Ip6HopLimit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Ip6HopLimit_get,
static int (*_field_qualify_Ip6HopLimit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Ip6HopLimit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Ip6HopLimit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Ip6HopLimit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Ip6NextHeader( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Ip6NextHeader,
static int (*_field_qualify_Ip6NextHeader_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Ip6NextHeader(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Ip6NextHeader_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Ip6NextHeader", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Ip6NextHeader_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Ip6NextHeader_get,
static int (*_field_qualify_Ip6NextHeader_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Ip6NextHeader_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Ip6NextHeader_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Ip6NextHeader_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Ip6TrafficClass( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Ip6TrafficClass,
static int (*_field_qualify_Ip6TrafficClass_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Ip6TrafficClass(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Ip6TrafficClass_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Ip6TrafficClass", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Ip6TrafficClass_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Ip6TrafficClass_get,
static int (*_field_qualify_Ip6TrafficClass_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Ip6TrafficClass_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Ip6TrafficClass_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Ip6TrafficClass_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpAddrsNormalized( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpAddrsNormalized,
static int (*_field_qualify_IpAddrsNormalized_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpAddrsNormalized(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpAddrsNormalized_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpAddrsNormalized", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpAddrsNormalized_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpAddrsNormalized_get,
static int (*_field_qualify_IpAddrsNormalized_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpAddrsNormalized_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpAddrsNormalized_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpAddrsNormalized_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpAuth( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpAuth,
static int (*_field_qualify_IpAuth_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpAuth(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpAuth_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpAuth", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpAuth_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpAuth_get,
static int (*_field_qualify_IpAuth_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpAuth_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpAuth_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpAuth_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpFlags( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpFlags,
static int (*_field_qualify_IpFlags_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpFlags(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpFlags_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpFlags", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpFlags_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpFlags_get,
static int (*_field_qualify_IpFlags_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpFlags_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpFlags_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpFlags_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpFrag( \
    int unit, bcm_field_entry_t entry, bcm_field_IpFrag_t frag_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpFrag,
static int (*_field_qualify_IpFrag_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpFrag_t frag_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpFrag(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpFrag_t frag_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpFrag_dispatch[dtype](unit, entry, frag_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpFrag", 3, 3, unit, entry, frag_info, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpFrag_get( \
    int unit, bcm_field_entry_t entry, bcm_field_IpFrag_t *frag_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpFrag_get,
static int (*_field_qualify_IpFrag_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpFrag_t *frag_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpFrag_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpFrag_t *frag_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpFrag_get_dispatch[dtype](unit, entry, frag_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpFrag_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpInfo( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpInfo,
static int (*_field_qualify_IpInfo_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpInfo(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpInfo_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpInfo", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpInfo_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpInfo_get,
static int (*_field_qualify_IpInfo_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpInfo_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpInfo_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpInfo_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpProtocol( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpProtocol,
static int (*_field_qualify_IpProtocol_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpProtocol(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpProtocol_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpProtocol", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpProtocolCommon( \
    int unit, bcm_field_entry_t entry, bcm_field_IpProtocolCommon_t protocol);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpProtocolCommon,
static int (*_field_qualify_IpProtocolCommon_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpProtocolCommon_t protocol) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpProtocolCommon(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpProtocolCommon_t protocol)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpProtocolCommon_dispatch[dtype](unit, entry, protocol);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpProtocolCommon", 3, 3, unit, entry, protocol, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpProtocolCommon_get( \
    int unit, bcm_field_entry_t entry, bcm_field_IpProtocolCommon_t *protocol);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpProtocolCommon_get,
static int (*_field_qualify_IpProtocolCommon_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpProtocolCommon_t *protocol) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpProtocolCommon_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpProtocolCommon_t *protocol)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpProtocolCommon_get_dispatch[dtype](unit, entry, protocol);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpProtocolCommon_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpProtocol_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpProtocol_get,
static int (*_field_qualify_IpProtocol_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpProtocol_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpProtocol_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpProtocol_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpTunnelHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpTunnelHit,
static int (*_field_qualify_IpTunnelHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpTunnelHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpTunnelHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpTunnelHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpTunnelHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpTunnelHit_get,
static int (*_field_qualify_IpTunnelHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpTunnelHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpTunnelHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpTunnelHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpTunnelValue( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpTunnelValue,
static int (*_field_qualify_IpTunnelValue_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpTunnelValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpTunnelValue_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpTunnelValue", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpTunnelValue_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpTunnelValue_get,
static int (*_field_qualify_IpTunnelValue_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpTunnelValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpTunnelValue_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpTunnelValue_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpType( \
    int unit, bcm_field_entry_t entry, bcm_field_IpType_t type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpType,
static int (*_field_qualify_IpType_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpType_t type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpType_t type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpType_dispatch[dtype](unit, entry, type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpType", 3, 3, unit, entry, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpType_get( \
    int unit, bcm_field_entry_t entry, bcm_field_IpType_t *type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpType_get,
static int (*_field_qualify_IpType_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpType_t *type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_IpType_t *type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpType_get_dispatch[dtype](unit, entry, type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpType_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpmcHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpmcHit,
static int (*_field_qualify_IpmcHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpmcHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpmcHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpmcHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpmcHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpmcHit_get,
static int (*_field_qualify_IpmcHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpmcHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpmcHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpmcHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpmcStarGroupHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpmcStarGroupHit,
static int (*_field_qualify_IpmcStarGroupHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpmcStarGroupHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpmcStarGroupHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpmcStarGroupHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpmcStarGroupHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpmcStarGroupHit_get,
static int (*_field_qualify_IpmcStarGroupHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpmcStarGroupHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpmcStarGroupHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpmcStarGroupHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpmcStarGroupValue( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpmcStarGroupValue,
static int (*_field_qualify_IpmcStarGroupValue_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpmcStarGroupValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpmcStarGroupValue_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpmcStarGroupValue", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpmcStarGroupValue_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpmcStarGroupValue_get,
static int (*_field_qualify_IpmcStarGroupValue_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpmcStarGroupValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpmcStarGroupValue_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpmcStarGroupValue_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpmcValue( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpmcValue,
static int (*_field_qualify_IpmcValue_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpmcValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpmcValue_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpmcValue", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IpmcValue_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IpmcValue_get,
static int (*_field_qualify_IpmcValue_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IpmcValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IpmcValue_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IpmcValue_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IsEqualValue( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IsEqualValue,
static int (*_field_qualify_IsEqualValue_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IsEqualValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IsEqualValue_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IsEqualValue", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_IsEqualValue_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_IsEqualValue_get,
static int (*_field_qualify_IsEqualValue_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_IsEqualValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_IsEqualValue_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_IsEqualValue_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2CacheHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2CacheHit,
static int (*_field_qualify_L2CacheHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2CacheHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2CacheHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2CacheHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2CacheHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2CacheHit_get,
static int (*_field_qualify_L2CacheHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2CacheHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2CacheHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2CacheHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2DestHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2DestHit,
static int (*_field_qualify_L2DestHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2DestHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2DestHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2DestHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2DestHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2DestHit_get,
static int (*_field_qualify_L2DestHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2DestHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2DestHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2DestHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2DestValue( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2DestValue,
static int (*_field_qualify_L2DestValue_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2DestValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2DestValue_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2DestValue", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2DestValue_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2DestValue_get,
static int (*_field_qualify_L2DestValue_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2DestValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2DestValue_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2DestValue_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2Format( \
    int unit, bcm_field_entry_t entry, bcm_field_L2Format_t type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2Format,
static int (*_field_qualify_L2Format_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_L2Format_t type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2Format(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_L2Format_t type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2Format_dispatch[dtype](unit, entry, type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2Format", 3, 3, unit, entry, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2Format_get( \
    int unit, bcm_field_entry_t entry, bcm_field_L2Format_t *type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2Format_get,
static int (*_field_qualify_L2Format_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_L2Format_t *type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2Format_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_L2Format_t *type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2Format_get_dispatch[dtype](unit, entry, type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2Format_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2GreFlowId( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2GreFlowId,
static int (*_field_qualify_L2GreFlowId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2GreFlowId(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2GreFlowId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2GreFlowId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2GreFlowId_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2GreFlowId_get,
static int (*_field_qualify_L2GreFlowId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2GreFlowId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2GreFlowId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2GreFlowId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2GreProtocolType( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2GreProtocolType,
static int (*_field_qualify_L2GreProtocolType_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2GreProtocolType(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2GreProtocolType_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2GreProtocolType", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2GreProtocolType_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2GreProtocolType_get,
static int (*_field_qualify_L2GreProtocolType_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2GreProtocolType_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2GreProtocolType_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2GreProtocolType_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2GreSrcIpHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2GreSrcIpHit,
static int (*_field_qualify_L2GreSrcIpHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2GreSrcIpHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2GreSrcIpHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2GreSrcIpHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2GreSrcIpHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2GreSrcIpHit_get,
static int (*_field_qualify_L2GreSrcIpHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2GreSrcIpHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2GreSrcIpHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2GreSrcIpHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2GreVfiHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2GreVfiHit,
static int (*_field_qualify_L2GreVfiHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2GreVfiHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2GreVfiHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2GreVfiHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2GreVfiHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2GreVfiHit_get,
static int (*_field_qualify_L2GreVfiHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2GreVfiHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2GreVfiHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2GreVfiHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2GreVsid( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2GreVsid,
static int (*_field_qualify_L2GreVsid_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2GreVsid(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2GreVsid_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2GreVsid", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2GreVsid_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2GreVsid_get,
static int (*_field_qualify_L2GreVsid_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2GreVsid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2GreVsid_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2GreVsid_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2Learn( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2Learn,
static int (*_field_qualify_L2Learn_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2Learn(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2Learn_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2Learn", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2Learn_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2Learn_get,
static int (*_field_qualify_L2Learn_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2Learn_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2Learn_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2Learn_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2PayloadFirstEightBytes( \
    int unit, bcm_field_entry_t entry, uint32 data1, uint32 data2, uint32 mask1, uint32 mask2);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2PayloadFirstEightBytes,
static int (*_field_qualify_L2PayloadFirstEightBytes_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data1, 
    uint32 data2, 
    uint32 mask1, 
    uint32 mask2) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2PayloadFirstEightBytes(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data1, 
    uint32 data2, 
    uint32 mask1, 
    uint32 mask2)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2PayloadFirstEightBytes_dispatch[dtype](unit, entry, data1, data2, mask1, mask2);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2PayloadFirstEightBytes", 6, 3, unit, entry, data1, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2PayloadFirstEightBytes_get( \
    int unit, bcm_field_entry_t entry, uint32 *data1, uint32 *data2, uint32 *mask1, uint32 *mask2);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2PayloadFirstEightBytes_get,
static int (*_field_qualify_L2PayloadFirstEightBytes_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data1, 
    uint32 *data2, 
    uint32 *mask1, 
    uint32 *mask2) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2PayloadFirstEightBytes_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data1, 
    uint32 *data2, 
    uint32 *mask1, 
    uint32 *mask2)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2PayloadFirstEightBytes_get_dispatch[dtype](unit, entry, data1, data2, mask1, mask2);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2PayloadFirstEightBytes_get", 6, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2SrcHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2SrcHit,
static int (*_field_qualify_L2SrcHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2SrcHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2SrcHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2SrcHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2SrcHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2SrcHit_get,
static int (*_field_qualify_L2SrcHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2SrcHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2SrcHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2SrcHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2SrcStatic( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2SrcStatic,
static int (*_field_qualify_L2SrcStatic_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2SrcStatic(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2SrcStatic_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2SrcStatic", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2SrcStatic_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2SrcStatic_get,
static int (*_field_qualify_L2SrcStatic_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2SrcStatic_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2SrcStatic_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2SrcStatic_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2SrcValue( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2SrcValue,
static int (*_field_qualify_L2SrcValue_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2SrcValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2SrcValue_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2SrcValue", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2SrcValue_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2SrcValue_get,
static int (*_field_qualify_L2SrcValue_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2SrcValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2SrcValue_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2SrcValue_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2StationMove( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2StationMove,
static int (*_field_qualify_L2StationMove_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2StationMove(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2StationMove_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2StationMove", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L2StationMove_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L2StationMove_get,
static int (*_field_qualify_L2StationMove_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L2StationMove_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L2StationMove_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L2StationMove_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3DestHostHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3DestHostHit,
static int (*_field_qualify_L3DestHostHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3DestHostHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3DestHostHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3DestHostHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3DestHostHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3DestHostHit_get,
static int (*_field_qualify_L3DestHostHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3DestHostHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3DestHostHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3DestHostHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3DestRouteHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3DestRouteHit,
static int (*_field_qualify_L3DestRouteHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3DestRouteHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3DestRouteHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3DestRouteHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3DestRouteHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3DestRouteHit_get,
static int (*_field_qualify_L3DestRouteHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3DestRouteHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3DestRouteHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3DestRouteHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3DestRouteValue( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3DestRouteValue,
static int (*_field_qualify_L3DestRouteValue_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3DestRouteValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3DestRouteValue_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3DestRouteValue", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3DestRouteValue_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3DestRouteValue_get,
static int (*_field_qualify_L3DestRouteValue_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3DestRouteValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3DestRouteValue_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3DestRouteValue_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3Ingress( \
    int unit, bcm_field_entry_t entry, uint32 intf_id, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3Ingress,
static int (*_field_qualify_L3Ingress_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 intf_id, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3Ingress(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 intf_id, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3Ingress_dispatch[dtype](unit, entry, intf_id, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3Ingress", 4, 3, unit, entry, intf_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3Ingress_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3Ingress_get,
static int (*_field_qualify_L3Ingress_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3Ingress_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3Ingress_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3Ingress_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3Routable( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3Routable,
static int (*_field_qualify_L3Routable_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3Routable(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3Routable_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3Routable", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3Routable_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3Routable_get,
static int (*_field_qualify_L3Routable_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3Routable_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3Routable_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3Routable_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3SrcBind( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3SrcBind,
static int (*_field_qualify_L3SrcBind_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3SrcBind(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3SrcBind_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3SrcBind", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3SrcBind_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3SrcBind_get,
static int (*_field_qualify_L3SrcBind_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3SrcBind_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3SrcBind_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3SrcBind_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3SrcHostHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3SrcHostHit,
static int (*_field_qualify_L3SrcHostHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3SrcHostHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3SrcHostHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3SrcHostHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3SrcHostHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3SrcHostHit_get,
static int (*_field_qualify_L3SrcHostHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3SrcHostHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3SrcHostHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3SrcHostHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3SrcRouteHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3SrcRouteHit,
static int (*_field_qualify_L3SrcRouteHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3SrcRouteHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3SrcRouteHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3SrcRouteHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3SrcRouteHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3SrcRouteHit_get,
static int (*_field_qualify_L3SrcRouteHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3SrcRouteHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3SrcRouteHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3SrcRouteHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3SrcRouteValue( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3SrcRouteValue,
static int (*_field_qualify_L3SrcRouteValue_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3SrcRouteValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3SrcRouteValue_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3SrcRouteValue", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L3SrcRouteValue_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L3SrcRouteValue_get,
static int (*_field_qualify_L3SrcRouteValue_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L3SrcRouteValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L3SrcRouteValue_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L3SrcRouteValue_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L4DstPort( \
    int unit, bcm_field_entry_t entry, bcm_l4_port_t data, bcm_l4_port_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L4DstPort,
static int (*_field_qualify_L4DstPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t data, 
    bcm_l4_port_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L4DstPort(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t data, 
    bcm_l4_port_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L4DstPort_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L4DstPort", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L4DstPort_get( \
    int unit, bcm_field_entry_t entry, bcm_l4_port_t *data, bcm_l4_port_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L4DstPort_get,
static int (*_field_qualify_L4DstPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L4DstPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L4DstPort_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L4DstPort_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L4PortRangeCheck( \
    int unit, bcm_field_entry_t entry, bcm_field_range_t range, int invert);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L4PortRangeCheck,
static int (*_field_qualify_L4PortRangeCheck_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_range_t range, 
    int invert) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L4PortRangeCheck(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_range_t range, 
    int invert)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L4PortRangeCheck_dispatch[dtype](unit, entry, range, invert);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L4PortRangeCheck", 4, 3, unit, entry, range, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L4PortRangeCheck_get( \
    int unit, bcm_field_entry_t entry, int max_count, bcm_field_range_t *range, int *invert, int *count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L4PortRangeCheck_get,
static int (*_field_qualify_L4PortRangeCheck_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    int max_count, 
    bcm_field_range_t *range, 
    int *invert, 
    int *count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L4PortRangeCheck_get(
    int unit, 
    bcm_field_entry_t entry, 
    int max_count, 
    bcm_field_range_t *range, 
    int *invert, 
    int *count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L4PortRangeCheck_get_dispatch[dtype](unit, entry, max_count, range, invert, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L4PortRangeCheck_get", 6, 3, unit, entry, max_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L4Ports( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L4Ports,
static int (*_field_qualify_L4Ports_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L4Ports(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L4Ports_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L4Ports", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L4Ports_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L4Ports_get,
static int (*_field_qualify_L4Ports_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L4Ports_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L4Ports_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L4Ports_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L4SrcPort( \
    int unit, bcm_field_entry_t entry, bcm_l4_port_t data, bcm_l4_port_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L4SrcPort,
static int (*_field_qualify_L4SrcPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t data, 
    bcm_l4_port_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L4SrcPort(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t data, 
    bcm_l4_port_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L4SrcPort_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L4SrcPort", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_L4SrcPort_get( \
    int unit, bcm_field_entry_t entry, bcm_l4_port_t *data, bcm_l4_port_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_L4SrcPort_get,
static int (*_field_qualify_L4SrcPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_L4SrcPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_l4_port_t *data, 
    bcm_l4_port_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_L4SrcPort_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_L4SrcPort_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_LearnSrcMac( \
    int unit, bcm_field_entry_t entry, bcm_mac_t data, bcm_mac_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_LearnSrcMac,
static int (*_field_qualify_LearnSrcMac_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t data, 
    bcm_mac_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_LearnSrcMac(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t data, 
    bcm_mac_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_LearnSrcMac_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_LearnSrcMac", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_LearnSrcMac_get( \
    int unit, bcm_field_entry_t entry, bcm_mac_t *data, bcm_mac_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_LearnSrcMac_get,
static int (*_field_qualify_LearnSrcMac_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_LearnSrcMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_LearnSrcMac_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_LearnSrcMac_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_LearnSrcPort( \
    int unit, bcm_field_entry_t entry, bcm_gport_t data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_LearnSrcPort,
static int (*_field_qualify_LearnSrcPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_LearnSrcPort(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&data);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_LearnSrcPort_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_LearnSrcPort", 3, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_LearnSrcPort_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_LearnSrcPort_get,
static int (*_field_qualify_LearnSrcPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_LearnSrcPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_LearnSrcPort_get_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,data);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_LearnSrcPort_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_LearnVlan( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t data, bcm_vlan_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_LearnVlan,
static int (*_field_qualify_LearnVlan_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_LearnVlan(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_LearnVlan_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_LearnVlan", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_LearnVlan_get( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t *data, bcm_vlan_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_LearnVlan_get,
static int (*_field_qualify_LearnVlan_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_LearnVlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_LearnVlan_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_LearnVlan_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Llc( \
    int unit, bcm_field_entry_t entry, bcm_field_llc_header_t data, bcm_field_llc_header_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Llc,
static int (*_field_qualify_Llc_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_llc_header_t data, 
    bcm_field_llc_header_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Llc(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_llc_header_t data, 
    bcm_field_llc_header_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Llc_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Llc", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Llc_get( \
    int unit, bcm_field_entry_t entry, bcm_field_llc_header_t *data, bcm_field_llc_header_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Llc_get,
static int (*_field_qualify_Llc_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_llc_header_t *data, 
    bcm_field_llc_header_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Llc_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_llc_header_t *data, 
    bcm_field_llc_header_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Llc_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Llc_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_LlidValue( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_LlidValue,
static int (*_field_qualify_LlidValue_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_LlidValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_LlidValue_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_LlidValue", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_LlidValue_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_LlidValue_get,
static int (*_field_qualify_LlidValue_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_LlidValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_LlidValue_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_LlidValue_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Loopback( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Loopback,
static int (*_field_qualify_Loopback_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Loopback(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Loopback_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Loopback", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_LoopbackType( \
    int unit, bcm_field_entry_t entry, bcm_field_LoopbackType_t loopback_type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_LoopbackType,
static int (*_field_qualify_LoopbackType_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_LoopbackType_t loopback_type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_LoopbackType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_LoopbackType_t loopback_type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_LoopbackType_dispatch[dtype](unit, entry, loopback_type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_LoopbackType", 3, 3, unit, entry, loopback_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_LoopbackType_get( \
    int unit, bcm_field_entry_t entry, bcm_field_LoopbackType_t *loopback_type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_LoopbackType_get,
static int (*_field_qualify_LoopbackType_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_LoopbackType_t *loopback_type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_LoopbackType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_LoopbackType_t *loopback_type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_LoopbackType_get_dispatch[dtype](unit, entry, loopback_type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_LoopbackType_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Loopback_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Loopback_get,
static int (*_field_qualify_Loopback_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Loopback_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Loopback_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Loopback_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MHOpcode( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MHOpcode,
static int (*_field_qualify_MHOpcode_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MHOpcode(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MHOpcode_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MHOpcode", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MHOpcode_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MHOpcode_get,
static int (*_field_qualify_MHOpcode_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MHOpcode_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MHOpcode_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MHOpcode_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MacAddrsNormalized( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MacAddrsNormalized,
static int (*_field_qualify_MacAddrsNormalized_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MacAddrsNormalized(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MacAddrsNormalized_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MacAddrsNormalized", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MacAddrsNormalized_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MacAddrsNormalized_get,
static int (*_field_qualify_MacAddrsNormalized_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MacAddrsNormalized_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MacAddrsNormalized_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MacAddrsNormalized_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MimSrcGportHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MimSrcGportHit,
static int (*_field_qualify_MimSrcGportHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MimSrcGportHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MimSrcGportHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MimSrcGportHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MimSrcGportHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MimSrcGportHit_get,
static int (*_field_qualify_MimSrcGportHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MimSrcGportHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MimSrcGportHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MimSrcGportHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MimVfiHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MimVfiHit,
static int (*_field_qualify_MimVfiHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MimVfiHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MimVfiHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MimVfiHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MimVfiHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MimVfiHit_get,
static int (*_field_qualify_MimVfiHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MimVfiHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MimVfiHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MimVfiHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MimVlanCfi( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MimVlanCfi,
static int (*_field_qualify_MimVlanCfi_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MimVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MimVlanCfi_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MimVlanCfi", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MimVlanCfi_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MimVlanCfi_get,
static int (*_field_qualify_MimVlanCfi_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MimVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MimVlanCfi_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MimVlanCfi_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MimVlanPri( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MimVlanPri,
static int (*_field_qualify_MimVlanPri_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MimVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MimVlanPri_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MimVlanPri", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MimVlanPri_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MimVlanPri_get,
static int (*_field_qualify_MimVlanPri_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MimVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MimVlanPri_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MimVlanPri_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MirrorCopy( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MirrorCopy,
static int (*_field_qualify_MirrorCopy_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MirrorCopy(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MirrorCopy_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MirrorCopy", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MirrorCopy_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MirrorCopy_get,
static int (*_field_qualify_MirrorCopy_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MirrorCopy_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MirrorCopy_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MirrorCopy_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MirrorEgressDisabled( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MirrorEgressDisabled,
static int (*_field_qualify_MirrorEgressDisabled_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MirrorEgressDisabled(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MirrorEgressDisabled_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MirrorEgressDisabled", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MirrorEgressDisabled_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MirrorEgressDisabled_get,
static int (*_field_qualify_MirrorEgressDisabled_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MirrorEgressDisabled_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MirrorEgressDisabled_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MirrorEgressDisabled_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsBos( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsBos,
static int (*_field_qualify_MplsBos_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsBos(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsBos_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsBos", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsBos_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsBos_get,
static int (*_field_qualify_MplsBos_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsBos_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsBos_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsBos_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsControlWord( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsControlWord,
static int (*_field_qualify_MplsControlWord_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsControlWord(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsControlWord_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsControlWord", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsControlWordValid( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsControlWordValid,
static int (*_field_qualify_MplsControlWordValid_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsControlWordValid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsControlWordValid_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsControlWordValid", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsControlWordValid_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsControlWordValid_get,
static int (*_field_qualify_MplsControlWordValid_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsControlWordValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsControlWordValid_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsControlWordValid_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsControlWord_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsControlWord_get,
static int (*_field_qualify_MplsControlWord_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsControlWord_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsControlWord_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsControlWord_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabel( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabel,
static int (*_field_qualify_MplsForwardingLabel_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabel(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabel_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabel", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabelAction( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabelAction,
static int (*_field_qualify_MplsForwardingLabelAction_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabelAction(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabelAction_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabelAction", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabelAction32( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabelAction32,
static int (*_field_qualify_MplsForwardingLabelAction32_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabelAction32(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabelAction32_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabelAction32", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabelAction32_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabelAction32_get,
static int (*_field_qualify_MplsForwardingLabelAction32_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabelAction32_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabelAction32_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabelAction32_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabelAction_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabelAction_get,
static int (*_field_qualify_MplsForwardingLabelAction_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabelAction_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabelAction_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabelAction_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabelBos( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabelBos,
static int (*_field_qualify_MplsForwardingLabelBos_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabelBos(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabelBos_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabelBos", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabelBos_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabelBos_get,
static int (*_field_qualify_MplsForwardingLabelBos_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabelBos_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabelBos_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabelBos_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabelExp( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabelExp,
static int (*_field_qualify_MplsForwardingLabelExp_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabelExp(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabelExp_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabelExp", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabelExp_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabelExp_get,
static int (*_field_qualify_MplsForwardingLabelExp_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabelExp_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabelExp_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabelExp_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabelId( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabelId,
static int (*_field_qualify_MplsForwardingLabelId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabelId(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabelId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabelId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabelId_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabelId_get,
static int (*_field_qualify_MplsForwardingLabelId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabelId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabelId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabelId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabelPayload( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabelPayload,
static int (*_field_qualify_MplsForwardingLabelPayload_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabelPayload(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabelPayload_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabelPayload", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabelPayload_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabelPayload_get,
static int (*_field_qualify_MplsForwardingLabelPayload_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabelPayload_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabelPayload_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabelPayload_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabelTtl( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabelTtl,
static int (*_field_qualify_MplsForwardingLabelTtl_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabelTtl(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabelTtl_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabelTtl", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabelTtl_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabelTtl_get,
static int (*_field_qualify_MplsForwardingLabelTtl_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabelTtl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabelTtl_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabelTtl_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsForwardingLabel_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsForwardingLabel_get,
static int (*_field_qualify_MplsForwardingLabel_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsForwardingLabel_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsForwardingLabel_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsForwardingLabel_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel1( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel1,
static int (*_field_qualify_MplsLabel1_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel1(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel1_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel1", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel1Bos( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel1Bos,
static int (*_field_qualify_MplsLabel1Bos_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel1Bos(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel1Bos_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel1Bos", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel1Bos_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel1Bos_get,
static int (*_field_qualify_MplsLabel1Bos_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel1Bos_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel1Bos_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel1Bos_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel1Exp( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel1Exp,
static int (*_field_qualify_MplsLabel1Exp_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel1Exp(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel1Exp_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel1Exp", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel1Exp_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel1Exp_get,
static int (*_field_qualify_MplsLabel1Exp_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel1Exp_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel1Exp_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel1Exp_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel1Hit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel1Hit,
static int (*_field_qualify_MplsLabel1Hit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel1Hit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel1Hit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel1Hit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel1Hit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel1Hit_get,
static int (*_field_qualify_MplsLabel1Hit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel1Hit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel1Hit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel1Hit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel1Id( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel1Id,
static int (*_field_qualify_MplsLabel1Id_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel1Id(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel1Id_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel1Id", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel1Id_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel1Id_get,
static int (*_field_qualify_MplsLabel1Id_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel1Id_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel1Id_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel1Id_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel1Ttl( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel1Ttl,
static int (*_field_qualify_MplsLabel1Ttl_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel1Ttl(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel1Ttl_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel1Ttl", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel1Ttl_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel1Ttl_get,
static int (*_field_qualify_MplsLabel1Ttl_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel1Ttl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel1Ttl_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel1Ttl_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel1_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel1_get,
static int (*_field_qualify_MplsLabel1_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel1_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel1_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel1_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel2( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel2,
static int (*_field_qualify_MplsLabel2_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel2(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel2_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel2", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel2Bos( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel2Bos,
static int (*_field_qualify_MplsLabel2Bos_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel2Bos(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel2Bos_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel2Bos", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel2Bos_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel2Bos_get,
static int (*_field_qualify_MplsLabel2Bos_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel2Bos_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel2Bos_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel2Bos_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel2Exp( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel2Exp,
static int (*_field_qualify_MplsLabel2Exp_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel2Exp(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel2Exp_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel2Exp", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel2Exp_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel2Exp_get,
static int (*_field_qualify_MplsLabel2Exp_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel2Exp_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel2Exp_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel2Exp_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel2Hit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel2Hit,
static int (*_field_qualify_MplsLabel2Hit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel2Hit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel2Hit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel2Hit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel2Hit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel2Hit_get,
static int (*_field_qualify_MplsLabel2Hit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel2Hit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel2Hit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel2Hit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel2Id( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel2Id,
static int (*_field_qualify_MplsLabel2Id_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel2Id(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel2Id_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel2Id", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel2Id_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel2Id_get,
static int (*_field_qualify_MplsLabel2Id_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel2Id_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel2Id_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel2Id_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel2Ttl( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel2Ttl,
static int (*_field_qualify_MplsLabel2Ttl_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel2Ttl(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel2Ttl_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel2Ttl", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel2Ttl_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel2Ttl_get,
static int (*_field_qualify_MplsLabel2Ttl_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel2Ttl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel2Ttl_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel2Ttl_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel2_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel2_get,
static int (*_field_qualify_MplsLabel2_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel2_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel2_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel2_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel3( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel3,
static int (*_field_qualify_MplsLabel3_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel3(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel3_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel3", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel3Bos( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel3Bos,
static int (*_field_qualify_MplsLabel3Bos_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel3Bos(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel3Bos_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel3Bos", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel3Bos_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel3Bos_get,
static int (*_field_qualify_MplsLabel3Bos_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel3Bos_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel3Bos_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel3Bos_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel3Exp( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel3Exp,
static int (*_field_qualify_MplsLabel3Exp_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel3Exp(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel3Exp_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel3Exp", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel3Exp_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel3Exp_get,
static int (*_field_qualify_MplsLabel3Exp_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel3Exp_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel3Exp_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel3Exp_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel3Id( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel3Id,
static int (*_field_qualify_MplsLabel3Id_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel3Id(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel3Id_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel3Id", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel3Id_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel3Id_get,
static int (*_field_qualify_MplsLabel3Id_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel3Id_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel3Id_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel3Id_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel3Ttl( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel3Ttl,
static int (*_field_qualify_MplsLabel3Ttl_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel3Ttl(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel3Ttl_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel3Ttl", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel3Ttl_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel3Ttl_get,
static int (*_field_qualify_MplsLabel3Ttl_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel3Ttl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel3Ttl_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel3Ttl_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsLabel3_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsLabel3_get,
static int (*_field_qualify_MplsLabel3_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsLabel3_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsLabel3_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsLabel3_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsOuterLabelPop( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsOuterLabelPop,
static int (*_field_qualify_MplsOuterLabelPop_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsOuterLabelPop(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsOuterLabelPop_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsOuterLabelPop", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsOuterLabelPop_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsOuterLabelPop_get,
static int (*_field_qualify_MplsOuterLabelPop_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsOuterLabelPop_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsOuterLabelPop_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsOuterLabelPop_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsStationHitTunnelUnterminated( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsStationHitTunnelUnterminated,
static int (*_field_qualify_MplsStationHitTunnelUnterminated_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsStationHitTunnelUnterminated(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsStationHitTunnelUnterminated_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsStationHitTunnelUnterminated", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsStationHitTunnelUnterminated_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsStationHitTunnelUnterminated_get,
static int (*_field_qualify_MplsStationHitTunnelUnterminated_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsStationHitTunnelUnterminated_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsStationHitTunnelUnterminated_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsStationHitTunnelUnterminated_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsTerminated( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsTerminated,
static int (*_field_qualify_MplsTerminated_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsTerminated(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsTerminated_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsTerminated", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsTerminatedHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsTerminatedHit,
static int (*_field_qualify_MplsTerminatedHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsTerminatedHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsTerminatedHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsTerminatedHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsTerminatedHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsTerminatedHit_get,
static int (*_field_qualify_MplsTerminatedHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsTerminatedHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsTerminatedHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsTerminatedHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsTerminatedValue( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsTerminatedValue,
static int (*_field_qualify_MplsTerminatedValue_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsTerminatedValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsTerminatedValue_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsTerminatedValue", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsTerminatedValue_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsTerminatedValue_get,
static int (*_field_qualify_MplsTerminatedValue_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsTerminatedValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsTerminatedValue_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsTerminatedValue_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MplsTerminated_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MplsTerminated_get,
static int (*_field_qualify_MplsTerminated_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MplsTerminated_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MplsTerminated_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MplsTerminated_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MyStationHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MyStationHit,
static int (*_field_qualify_MyStationHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MyStationHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MyStationHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MyStationHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_MyStationHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_MyStationHit_get,
static int (*_field_qualify_MyStationHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_MyStationHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_MyStationHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_MyStationHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_NatDstRealmId( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_NatDstRealmId,
static int (*_field_qualify_NatDstRealmId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_NatDstRealmId(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_NatDstRealmId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_NatDstRealmId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_NatDstRealmId_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_NatDstRealmId_get,
static int (*_field_qualify_NatDstRealmId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_NatDstRealmId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_NatDstRealmId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_NatDstRealmId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_NatNeeded( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_NatNeeded,
static int (*_field_qualify_NatNeeded_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_NatNeeded(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_NatNeeded_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_NatNeeded", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_NatNeeded_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_NatNeeded_get,
static int (*_field_qualify_NatNeeded_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_NatNeeded_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_NatNeeded_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_NatNeeded_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_NatSrcRealmId( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_NatSrcRealmId,
static int (*_field_qualify_NatSrcRealmId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_NatSrcRealmId(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_NatSrcRealmId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_NatSrcRealmId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_NatSrcRealmId_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_NatSrcRealmId_get,
static int (*_field_qualify_NatSrcRealmId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_NatSrcRealmId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_NatSrcRealmId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_NatSrcRealmId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_NativeVSwitch( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t data, bcm_vlan_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_NativeVSwitch,
static int (*_field_qualify_NativeVSwitch_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_NativeVSwitch(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_NativeVSwitch_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_NativeVSwitch", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_NativeVSwitchValid( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_NativeVSwitchValid,
static int (*_field_qualify_NativeVSwitchValid_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_NativeVSwitchValid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_NativeVSwitchValid_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_NativeVSwitchValid", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_NativeVSwitchValid_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_NativeVSwitchValid_get,
static int (*_field_qualify_NativeVSwitchValid_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_NativeVSwitchValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_NativeVSwitchValid_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_NativeVSwitchValid_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_NativeVSwitch_get( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t *data, bcm_vlan_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_NativeVSwitch_get,
static int (*_field_qualify_NativeVSwitch_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_NativeVSwitch_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_NativeVSwitch_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_NativeVSwitch_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OamMdl( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OamMdl,
static int (*_field_qualify_OamMdl_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OamMdl(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OamMdl_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OamMdl", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OamMdl_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OamMdl_get,
static int (*_field_qualify_OamMdl_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OamMdl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OamMdl_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OamMdl_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OutPort( \
    int unit, bcm_field_entry_t entry, bcm_port_t data, bcm_port_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OutPort,
static int (*_field_qualify_OutPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_port_t data, 
    bcm_port_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OutPort(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_port_t data, 
    bcm_port_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&data);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OutPort_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OutPort", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OutPort_get( \
    int unit, bcm_field_entry_t entry, bcm_port_t *data, bcm_port_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OutPort_get,
static int (*_field_qualify_OutPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_port_t *data, 
    bcm_port_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OutPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_port_t *data, 
    bcm_port_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OutPort_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,data);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OutPort_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OutPorts( \
    int unit, bcm_field_entry_t entry, bcm_pbmp_t data, bcm_pbmp_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OutPorts,
static int (*_field_qualify_OutPorts_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_pbmp_t data, 
    bcm_pbmp_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OutPorts(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_pbmp_t data, 
    bcm_pbmp_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_data);
		BCM_API_XLATE_PORT_PBMP_DECL(t_mask);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_data,data);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&data);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_mask,mask);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&mask);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OutPorts_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(data,t_data);
		BCM_API_XLATE_PORT_PBMP_RESTORE(mask,t_mask);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OutPorts", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OutPorts_get( \
    int unit, bcm_field_entry_t entry, bcm_pbmp_t *data, bcm_pbmp_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OutPorts_get,
static int (*_field_qualify_OutPorts_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_pbmp_t *data, 
    bcm_pbmp_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OutPorts_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_pbmp_t *data, 
    bcm_pbmp_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OutPorts_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,data);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,mask);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OutPorts_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OutVPort( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OutVPort,
static int (*_field_qualify_OutVPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OutVPort(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OutVPort_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OutVPort", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OutVPort32( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OutVPort32,
static int (*_field_qualify_OutVPort32_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OutVPort32(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OutVPort32_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OutVPort32", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OutVPort32_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OutVPort32_get,
static int (*_field_qualify_OutVPort32_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OutVPort32_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OutVPort32_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OutVPort32_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OutVPort_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OutVPort_get,
static int (*_field_qualify_OutVPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OutVPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OutVPort_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OutVPort_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OuterTpid( \
    int unit, bcm_field_entry_t entry, uint16 tpid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OuterTpid,
static int (*_field_qualify_OuterTpid_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 tpid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OuterTpid(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 tpid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OuterTpid_dispatch[dtype](unit, entry, tpid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OuterTpid", 3, 3, unit, entry, tpid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OuterTpid_get( \
    int unit, bcm_field_entry_t entry, uint16 *tpid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OuterTpid_get,
static int (*_field_qualify_OuterTpid_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *tpid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OuterTpid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *tpid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OuterTpid_get_dispatch[dtype](unit, entry, tpid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OuterTpid_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OuterVlan( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t data, bcm_vlan_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OuterVlan,
static int (*_field_qualify_OuterVlan_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OuterVlan(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OuterVlan_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OuterVlan", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OuterVlanActionRange( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t data, bcm_vlan_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OuterVlanActionRange,
static int (*_field_qualify_OuterVlanActionRange_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OuterVlanActionRange(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OuterVlanActionRange_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OuterVlanActionRange", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OuterVlanActionRange_get( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t *data, bcm_vlan_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OuterVlanActionRange_get,
static int (*_field_qualify_OuterVlanActionRange_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OuterVlanActionRange_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OuterVlanActionRange_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OuterVlanActionRange_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OuterVlanCfi( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OuterVlanCfi,
static int (*_field_qualify_OuterVlanCfi_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OuterVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OuterVlanCfi_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OuterVlanCfi", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OuterVlanCfi_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OuterVlanCfi_get,
static int (*_field_qualify_OuterVlanCfi_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OuterVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OuterVlanCfi_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OuterVlanCfi_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OuterVlanId( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t data, bcm_vlan_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OuterVlanId,
static int (*_field_qualify_OuterVlanId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OuterVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OuterVlanId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OuterVlanId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OuterVlanId_get( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t *data, bcm_vlan_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OuterVlanId_get,
static int (*_field_qualify_OuterVlanId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OuterVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OuterVlanId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OuterVlanId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OuterVlanPri( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OuterVlanPri,
static int (*_field_qualify_OuterVlanPri_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OuterVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OuterVlanPri_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OuterVlanPri", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OuterVlanPri_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OuterVlanPri_get,
static int (*_field_qualify_OuterVlanPri_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OuterVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OuterVlanPri_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OuterVlanPri_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_OuterVlan_get( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t *data, bcm_vlan_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_OuterVlan_get,
static int (*_field_qualify_OuterVlan_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_OuterVlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_OuterVlan_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_OuterVlan_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_PacketLengthRangeCheck( \
    int unit, bcm_field_entry_t entry, bcm_field_range_t range, int invert);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_PacketLengthRangeCheck,
static int (*_field_qualify_PacketLengthRangeCheck_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_range_t range, 
    int invert) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_PacketLengthRangeCheck(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_range_t range, 
    int invert)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_PacketLengthRangeCheck_dispatch[dtype](unit, entry, range, invert);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_PacketLengthRangeCheck", 4, 3, unit, entry, range, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_PacketLengthRangeCheck_get( \
    int unit, bcm_field_entry_t entry, int max_count, bcm_field_range_t *range, int *invert, int *count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_PacketLengthRangeCheck_get,
static int (*_field_qualify_PacketLengthRangeCheck_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    int max_count, 
    bcm_field_range_t *range, 
    int *invert, 
    int *count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_PacketLengthRangeCheck_get(
    int unit, 
    bcm_field_entry_t entry, 
    int max_count, 
    bcm_field_range_t *range, 
    int *invert, 
    int *count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_PacketLengthRangeCheck_get_dispatch[dtype](unit, entry, max_count, range, invert, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_PacketLengthRangeCheck_get", 6, 3, unit, entry, max_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_PacketRes( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_PacketRes,
static int (*_field_qualify_PacketRes_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_PacketRes(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_PacketRes_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_PacketRes", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_PacketRes_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_PacketRes_get,
static int (*_field_qualify_PacketRes_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_PacketRes_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_PacketRes_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_PacketRes_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_PacketSize( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_PacketSize,
static int (*_field_qualify_PacketSize_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_PacketSize(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_PacketSize_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_PacketSize", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_PacketSize_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_PacketSize_get,
static int (*_field_qualify_PacketSize_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_PacketSize_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_PacketSize_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_PacketSize_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_PacketTerminatedBytes( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_PacketTerminatedBytes,
static int (*_field_qualify_PacketTerminatedBytes_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_PacketTerminatedBytes(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_PacketTerminatedBytes_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_PacketTerminatedBytes", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_PacketTerminatedBytes_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_PacketTerminatedBytes_get,
static int (*_field_qualify_PacketTerminatedBytes_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_PacketTerminatedBytes_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_PacketTerminatedBytes_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_PacketTerminatedBytes_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_PolicerIntPrio( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_PolicerIntPrio,
static int (*_field_qualify_PolicerIntPrio_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_PolicerIntPrio(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_PolicerIntPrio_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_PolicerIntPrio", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_PolicerIntPrio_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_PolicerIntPrio_get,
static int (*_field_qualify_PolicerIntPrio_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_PolicerIntPrio_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_PolicerIntPrio_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_PolicerIntPrio_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_PortOrientation( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_PortOrientation,
static int (*_field_qualify_PortOrientation_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_PortOrientation(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_PortOrientation_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_PortOrientation", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_PortOrientation_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_PortOrientation_get,
static int (*_field_qualify_PortOrientation_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_PortOrientation_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_PortOrientation_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_PortOrientation_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Ptch( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Ptch,
static int (*_field_qualify_Ptch_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Ptch(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Ptch_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Ptch", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Ptch_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Ptch_get,
static int (*_field_qualify_Ptch_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Ptch_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Ptch_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Ptch_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_RangeCheck( \
    int unit, bcm_field_entry_t entry, bcm_field_range_t range, int invert);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_RangeCheck,
static int (*_field_qualify_RangeCheck_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_range_t range, 
    int invert) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_RangeCheck(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_range_t range, 
    int invert)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_RangeCheck_dispatch[dtype](unit, entry, range, invert);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_RangeCheck", 4, 3, unit, entry, range, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_RangeCheck_get( \
    int unit, bcm_field_entry_t entry, int max_count, bcm_field_range_t *range, int *invert, int *count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_RangeCheck_get,
static int (*_field_qualify_RangeCheck_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    int max_count, 
    bcm_field_range_t *range, 
    int *invert, 
    int *count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_RangeCheck_get(
    int unit, 
    bcm_field_entry_t entry, 
    int max_count, 
    bcm_field_range_t *range, 
    int *invert, 
    int *count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_RangeCheck_get_dispatch[dtype](unit, entry, max_count, range, invert, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_RangeCheck_get", 6, 3, unit, entry, max_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_RecoverableDrop( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_RecoverableDrop,
static int (*_field_qualify_RecoverableDrop_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_RecoverableDrop(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_RecoverableDrop_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_RecoverableDrop", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_RecoverableDrop_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_RecoverableDrop_get,
static int (*_field_qualify_RecoverableDrop_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_RecoverableDrop_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_RecoverableDrop_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_RecoverableDrop_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_RepCopy( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_RepCopy,
static int (*_field_qualify_RepCopy_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_RepCopy(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_RepCopy_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_RepCopy", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_RepCopy_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_RepCopy_get,
static int (*_field_qualify_RepCopy_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_RepCopy_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_RepCopy_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_RepCopy_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ReplicantAny( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ReplicantAny,
static int (*_field_qualify_ReplicantAny_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ReplicantAny(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ReplicantAny_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ReplicantAny", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ReplicantAny_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ReplicantAny_get,
static int (*_field_qualify_ReplicantAny_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ReplicantAny_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ReplicantAny_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ReplicantAny_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ReplicantFirst( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ReplicantFirst,
static int (*_field_qualify_ReplicantFirst_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ReplicantFirst(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ReplicantFirst_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ReplicantFirst", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_ReplicantFirst_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_ReplicantFirst_get,
static int (*_field_qualify_ReplicantFirst_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_ReplicantFirst_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_ReplicantFirst_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_ReplicantFirst_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_RouterAlertLabelValid( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_RouterAlertLabelValid,
static int (*_field_qualify_RouterAlertLabelValid_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_RouterAlertLabelValid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_RouterAlertLabelValid_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_RouterAlertLabelValid", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_RouterAlertLabelValid_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_RouterAlertLabelValid_get,
static int (*_field_qualify_RouterAlertLabelValid_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_RouterAlertLabelValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_RouterAlertLabelValid_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_RouterAlertLabelValid_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Rtag7AHashLower( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Rtag7AHashLower,
static int (*_field_qualify_Rtag7AHashLower_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Rtag7AHashLower(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Rtag7AHashLower_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Rtag7AHashLower", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Rtag7AHashLower_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Rtag7AHashLower_get,
static int (*_field_qualify_Rtag7AHashLower_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Rtag7AHashLower_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Rtag7AHashLower_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Rtag7AHashLower_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Rtag7AHashUpper( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Rtag7AHashUpper,
static int (*_field_qualify_Rtag7AHashUpper_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Rtag7AHashUpper(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Rtag7AHashUpper_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Rtag7AHashUpper", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Rtag7AHashUpper_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Rtag7AHashUpper_get,
static int (*_field_qualify_Rtag7AHashUpper_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Rtag7AHashUpper_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Rtag7AHashUpper_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Rtag7AHashUpper_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Rtag7BHashLower( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Rtag7BHashLower,
static int (*_field_qualify_Rtag7BHashLower_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Rtag7BHashLower(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Rtag7BHashLower_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Rtag7BHashLower", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Rtag7BHashLower_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Rtag7BHashLower_get,
static int (*_field_qualify_Rtag7BHashLower_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Rtag7BHashLower_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Rtag7BHashLower_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Rtag7BHashLower_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Rtag7BHashUpper( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Rtag7BHashUpper,
static int (*_field_qualify_Rtag7BHashUpper_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Rtag7BHashUpper(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Rtag7BHashUpper_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Rtag7BHashUpper", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Rtag7BHashUpper_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Rtag7BHashUpper_get,
static int (*_field_qualify_Rtag7BHashUpper_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Rtag7BHashUpper_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Rtag7BHashUpper_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Rtag7BHashUpper_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_RxTrapCode( \
    int unit, bcm_field_entry_t entry, bcm_rx_trap_t data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_RxTrapCode,
static int (*_field_qualify_RxTrapCode_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_rx_trap_t data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_RxTrapCode(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_rx_trap_t data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_RxTrapCode_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_RxTrapCode", 3, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_RxTrapCodeForSnoop( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_RxTrapCodeForSnoop,
static int (*_field_qualify_RxTrapCodeForSnoop_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_RxTrapCodeForSnoop(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_RxTrapCodeForSnoop_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_RxTrapCodeForSnoop", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_RxTrapCodeForSnoop_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_RxTrapCodeForSnoop_get,
static int (*_field_qualify_RxTrapCodeForSnoop_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_RxTrapCodeForSnoop_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_RxTrapCodeForSnoop_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_RxTrapCodeForSnoop_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_RxTrapCode_get( \
    int unit, bcm_field_entry_t entry, bcm_rx_trap_t *data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_RxTrapCode_get,
static int (*_field_qualify_RxTrapCode_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_rx_trap_t *data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_RxTrapCode_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_rx_trap_t *data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_RxTrapCode_get_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_RxTrapCode_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_RxTrapData( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_RxTrapData,
static int (*_field_qualify_RxTrapData_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_RxTrapData(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_RxTrapData_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_RxTrapData", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_RxTrapData_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_RxTrapData_get,
static int (*_field_qualify_RxTrapData_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_RxTrapData_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_RxTrapData_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_RxTrapData_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Snap( \
    int unit, bcm_field_entry_t entry, bcm_field_snap_header_t data, bcm_field_snap_header_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Snap,
static int (*_field_qualify_Snap_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_snap_header_t data, 
    bcm_field_snap_header_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Snap(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_snap_header_t data, 
    bcm_field_snap_header_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Snap_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Snap", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Snap_get( \
    int unit, bcm_field_entry_t entry, bcm_field_snap_header_t *data, bcm_field_snap_header_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Snap_get,
static int (*_field_qualify_Snap_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_snap_header_t *data, 
    bcm_field_snap_header_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Snap_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_snap_header_t *data, 
    bcm_field_snap_header_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Snap_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Snap_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SnoopCopy( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SnoopCopy,
static int (*_field_qualify_SnoopCopy_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SnoopCopy(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SnoopCopy_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SnoopCopy", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SnoopCopy_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SnoopCopy_get,
static int (*_field_qualify_SnoopCopy_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SnoopCopy_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SnoopCopy_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SnoopCopy_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcClassField( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcClassField,
static int (*_field_qualify_SrcClassField_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcClassField(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcClassField_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcClassField", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcClassField_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcClassField_get,
static int (*_field_qualify_SrcClassField_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcClassField_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcClassField_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcClassField_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcClassL2( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcClassL2,
static int (*_field_qualify_SrcClassL2_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcClassL2(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcClassL2_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcClassL2", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcClassL2_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcClassL2_get,
static int (*_field_qualify_SrcClassL2_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcClassL2_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcClassL2_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcClassL2_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcClassL3( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcClassL3,
static int (*_field_qualify_SrcClassL3_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcClassL3(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcClassL3_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcClassL3", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcClassL3_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcClassL3_get,
static int (*_field_qualify_SrcClassL3_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcClassL3_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcClassL3_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcClassL3_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcGport,
static int (*_field_qualify_SrcGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcGport_dispatch[dtype](unit, entry, port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcGport", 3, 3, unit, entry, port_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcGport_get,
static int (*_field_qualify_SrcGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcGport_get_dispatch[dtype](unit, entry, port_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcIp( \
    int unit, bcm_field_entry_t entry, bcm_ip_t data, bcm_ip_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcIp,
static int (*_field_qualify_SrcIp_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t data, 
    bcm_ip_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcIp(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t data, 
    bcm_ip_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcIp_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcIp", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcIp6( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t data, bcm_ip6_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcIp6,
static int (*_field_qualify_SrcIp6_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcIp6(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcIp6_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcIp6", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcIp6High( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t data, bcm_ip6_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcIp6High,
static int (*_field_qualify_SrcIp6High_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcIp6High(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcIp6High_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcIp6High", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcIp6High_get( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t *data, bcm_ip6_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcIp6High_get,
static int (*_field_qualify_SrcIp6High_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcIp6High_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcIp6High_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcIp6High_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcIp6Low( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t data, bcm_ip6_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcIp6Low,
static int (*_field_qualify_SrcIp6Low_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcIp6Low(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t data, 
    bcm_ip6_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcIp6Low_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcIp6Low", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcIp6Low_get( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t *data, bcm_ip6_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcIp6Low_get,
static int (*_field_qualify_SrcIp6Low_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcIp6Low_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcIp6Low_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcIp6Low_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcIp6_get( \
    int unit, bcm_field_entry_t entry, bcm_ip6_t *data, bcm_ip6_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcIp6_get,
static int (*_field_qualify_SrcIp6_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcIp6_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip6_t *data, 
    bcm_ip6_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcIp6_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcIp6_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcIpEqualDstIp( \
    int unit, bcm_field_entry_t entry, uint32 flag);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcIpEqualDstIp,
static int (*_field_qualify_SrcIpEqualDstIp_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 flag) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcIpEqualDstIp(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 flag)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcIpEqualDstIp_dispatch[dtype](unit, entry, flag);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcIpEqualDstIp", 3, 3, unit, entry, flag, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcIpEqualDstIp_get( \
    int unit, bcm_field_entry_t entry, uint32 *flag);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcIpEqualDstIp_get,
static int (*_field_qualify_SrcIpEqualDstIp_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *flag) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcIpEqualDstIp_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *flag)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcIpEqualDstIp_get_dispatch[dtype](unit, entry, flag);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcIpEqualDstIp_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcIp_get( \
    int unit, bcm_field_entry_t entry, bcm_ip_t *data, bcm_ip_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcIp_get,
static int (*_field_qualify_SrcIp_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcIp_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_ip_t *data, 
    bcm_ip_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcIp_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcIp_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcMac( \
    int unit, bcm_field_entry_t entry, bcm_mac_t data, bcm_mac_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcMac,
static int (*_field_qualify_SrcMac_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t data, 
    bcm_mac_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcMac(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t data, 
    bcm_mac_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcMac_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcMac", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcMac_get( \
    int unit, bcm_field_entry_t entry, bcm_mac_t *data, bcm_mac_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcMac_get,
static int (*_field_qualify_SrcMac_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcMac_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_mac_t *data, 
    bcm_mac_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcMac_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcMac_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcMimGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t mim_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcMimGport,
static int (*_field_qualify_SrcMimGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t mim_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcMimGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t mim_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mim_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcMimGport_dispatch[dtype](unit, entry, mim_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcMimGport", 3, 3, unit, entry, mim_port_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcMimGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *mim_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcMimGport_get,
static int (*_field_qualify_SrcMimGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *mim_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcMimGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *mim_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcMimGport_get_dispatch[dtype](unit, entry, mim_port_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,mim_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcMimGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcModPortGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcModPortGport,
static int (*_field_qualify_SrcModPortGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcModPortGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&data);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcModPortGport_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcModPortGport", 3, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcModPortGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcModPortGport_get,
static int (*_field_qualify_SrcModPortGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcModPortGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcModPortGport_get_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,data);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcModPortGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcModuleGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcModuleGport,
static int (*_field_qualify_SrcModuleGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcModuleGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&data);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcModuleGport_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcModuleGport", 3, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcModuleGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcModuleGport_get,
static int (*_field_qualify_SrcModuleGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcModuleGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcModuleGport_get_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,data);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcModuleGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcMplsGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t mpls_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcMplsGport,
static int (*_field_qualify_SrcMplsGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t mpls_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcMplsGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t mpls_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mpls_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcMplsGport_dispatch[dtype](unit, entry, mpls_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcMplsGport", 3, 3, unit, entry, mpls_port_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcMplsGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *mpls_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcMplsGport_get,
static int (*_field_qualify_SrcMplsGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *mpls_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcMplsGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *mpls_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcMplsGport_get_dispatch[dtype](unit, entry, mpls_port_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,mpls_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcMplsGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcNivGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t niv_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcNivGport,
static int (*_field_qualify_SrcNivGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t niv_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcNivGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t niv_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&niv_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcNivGport_dispatch[dtype](unit, entry, niv_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcNivGport", 3, 3, unit, entry, niv_port_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcNivGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *niv_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcNivGport_get,
static int (*_field_qualify_SrcNivGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *niv_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcNivGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *niv_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcNivGport_get_dispatch[dtype](unit, entry, niv_port_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,niv_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcNivGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcPort( \
    int unit, bcm_field_entry_t entry, bcm_module_t data_modid, bcm_module_t mask_modid, bcm_port_t data_port, bcm_port_t mask_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcPort,
static int (*_field_qualify_SrcPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_module_t data_modid, 
    bcm_module_t mask_modid, 
    bcm_port_t data_port, 
    bcm_port_t mask_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcPort(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_module_t data_modid, 
    bcm_module_t mask_modid, 
    bcm_port_t data_port, 
    bcm_port_t mask_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&data_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcPort_dispatch[dtype](unit, entry, data_modid, mask_modid, data_port, mask_port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcPort", 6, 3, unit, entry, data_modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcPort_get( \
    int unit, bcm_field_entry_t entry, bcm_module_t *data_modid, bcm_module_t *mask_modid, bcm_port_t *data_port, bcm_port_t *mask_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcPort_get,
static int (*_field_qualify_SrcPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_module_t *data_modid, 
    bcm_module_t *mask_modid, 
    bcm_port_t *data_port, 
    bcm_port_t *mask_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_module_t *data_modid, 
    bcm_module_t *mask_modid, 
    bcm_port_t *data_port, 
    bcm_port_t *mask_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcPort_get_dispatch[dtype](unit, entry, data_modid, mask_modid, data_port, mask_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,data_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcPort_get", 6, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcTrunk( \
    int unit, bcm_field_entry_t entry, bcm_trunk_t data, bcm_trunk_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcTrunk,
static int (*_field_qualify_SrcTrunk_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_trunk_t data, 
    bcm_trunk_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcTrunk(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_trunk_t data, 
    bcm_trunk_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcTrunk_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcTrunk", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcTrunkMemberGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcTrunkMemberGport,
static int (*_field_qualify_SrcTrunkMemberGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcTrunkMemberGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&data);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcTrunkMemberGport_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcTrunkMemberGport", 3, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcTrunkMemberGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcTrunkMemberGport_get,
static int (*_field_qualify_SrcTrunkMemberGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcTrunkMemberGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcTrunkMemberGport_get_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,data);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcTrunkMemberGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcTrunk_get( \
    int unit, bcm_field_entry_t entry, bcm_trunk_t *data, bcm_trunk_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcTrunk_get,
static int (*_field_qualify_SrcTrunk_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_trunk_t *data, 
    bcm_trunk_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcTrunk_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_trunk_t *data, 
    bcm_trunk_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcTrunk_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcTrunk_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcVirtualPortValid( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcVirtualPortValid,
static int (*_field_qualify_SrcVirtualPortValid_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcVirtualPortValid(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcVirtualPortValid_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcVirtualPortValid", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcVirtualPortValid_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcVirtualPortValid_get,
static int (*_field_qualify_SrcVirtualPortValid_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcVirtualPortValid_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcVirtualPortValid_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcVirtualPortValid_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcVxlanGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t vxlan_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcVxlanGport,
static int (*_field_qualify_SrcVxlanGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t vxlan_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcVxlanGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t vxlan_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&vxlan_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcVxlanGport_dispatch[dtype](unit, entry, vxlan_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcVxlanGport", 3, 3, unit, entry, vxlan_port_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcVxlanGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *vxlan_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcVxlanGport_get,
static int (*_field_qualify_SrcVxlanGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *vxlan_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcVxlanGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *vxlan_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcVxlanGport_get_dispatch[dtype](unit, entry, vxlan_port_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,vxlan_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcVxlanGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcWlanGport( \
    int unit, bcm_field_entry_t entry, bcm_gport_t wlan_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcWlanGport,
static int (*_field_qualify_SrcWlanGport_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t wlan_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcWlanGport(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t wlan_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&wlan_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcWlanGport_dispatch[dtype](unit, entry, wlan_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcWlanGport", 3, 3, unit, entry, wlan_port_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SrcWlanGport_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *wlan_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SrcWlanGport_get,
static int (*_field_qualify_SrcWlanGport_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *wlan_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SrcWlanGport_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *wlan_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SrcWlanGport_get_dispatch[dtype](unit, entry, wlan_port_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,wlan_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SrcWlanGport_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Stage( \
    int unit, bcm_field_entry_t entry, bcm_field_stage_t data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Stage,
static int (*_field_qualify_Stage_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_stage_t data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Stage(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_stage_t data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Stage_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Stage", 3, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Stage_get( \
    int unit, bcm_field_entry_t entry, bcm_field_stage_t *data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Stage_get,
static int (*_field_qualify_Stage_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_stage_t *data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Stage_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_stage_t *data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Stage_get_dispatch[dtype](unit, entry, data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Stage_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SubportPktTag( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SubportPktTag,
static int (*_field_qualify_SubportPktTag_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SubportPktTag(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SubportPktTag_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SubportPktTag", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_SubportPktTag_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_SubportPktTag_get,
static int (*_field_qualify_SubportPktTag_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_SubportPktTag_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_SubportPktTag_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_SubportPktTag_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TcpControl( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TcpControl,
static int (*_field_qualify_TcpControl_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TcpControl(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TcpControl_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TcpControl", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TcpControl_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TcpControl_get,
static int (*_field_qualify_TcpControl_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TcpControl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TcpControl_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TcpControl_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TcpHeaderSize( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TcpHeaderSize,
static int (*_field_qualify_TcpHeaderSize_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TcpHeaderSize(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TcpHeaderSize_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TcpHeaderSize", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TcpHeaderSize_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TcpHeaderSize_get,
static int (*_field_qualify_TcpHeaderSize_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TcpHeaderSize_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TcpHeaderSize_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TcpHeaderSize_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TcpSequenceZero( \
    int unit, bcm_field_entry_t entry, uint32 flag);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TcpSequenceZero,
static int (*_field_qualify_TcpSequenceZero_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 flag) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TcpSequenceZero(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 flag)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TcpSequenceZero_dispatch[dtype](unit, entry, flag);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TcpSequenceZero", 3, 3, unit, entry, flag, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TcpSequenceZero_get( \
    int unit, bcm_field_entry_t entry, uint32 *flag);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TcpSequenceZero_get,
static int (*_field_qualify_TcpSequenceZero_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *flag) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TcpSequenceZero_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *flag)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TcpSequenceZero_get_dispatch[dtype](unit, entry, flag);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TcpSequenceZero_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Tos( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Tos,
static int (*_field_qualify_Tos_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Tos(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Tos_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Tos", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Tos_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Tos_get,
static int (*_field_qualify_Tos_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Tos_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Tos_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Tos_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedInnerVlan( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t data, bcm_vlan_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedInnerVlan,
static int (*_field_qualify_TranslatedInnerVlan_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedInnerVlan(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedInnerVlan_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedInnerVlan", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedInnerVlanCfi( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedInnerVlanCfi,
static int (*_field_qualify_TranslatedInnerVlanCfi_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedInnerVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedInnerVlanCfi_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedInnerVlanCfi", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedInnerVlanCfi_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedInnerVlanCfi_get,
static int (*_field_qualify_TranslatedInnerVlanCfi_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedInnerVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedInnerVlanCfi_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedInnerVlanCfi_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedInnerVlanId( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t data, bcm_vlan_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedInnerVlanId,
static int (*_field_qualify_TranslatedInnerVlanId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedInnerVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedInnerVlanId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedInnerVlanId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedInnerVlanId_get( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t *data, bcm_vlan_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedInnerVlanId_get,
static int (*_field_qualify_TranslatedInnerVlanId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedInnerVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedInnerVlanId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedInnerVlanId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedInnerVlanPri( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedInnerVlanPri,
static int (*_field_qualify_TranslatedInnerVlanPri_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedInnerVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedInnerVlanPri_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedInnerVlanPri", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedInnerVlanPri_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedInnerVlanPri_get,
static int (*_field_qualify_TranslatedInnerVlanPri_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedInnerVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedInnerVlanPri_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedInnerVlanPri_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedInnerVlan_get( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t *data, bcm_vlan_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedInnerVlan_get,
static int (*_field_qualify_TranslatedInnerVlan_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedInnerVlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedInnerVlan_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedInnerVlan_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedOuterVlan( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t data, bcm_vlan_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedOuterVlan,
static int (*_field_qualify_TranslatedOuterVlan_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedOuterVlan(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedOuterVlan_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedOuterVlan", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedOuterVlanCfi( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedOuterVlanCfi,
static int (*_field_qualify_TranslatedOuterVlanCfi_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedOuterVlanCfi(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedOuterVlanCfi_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedOuterVlanCfi", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedOuterVlanCfi_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedOuterVlanCfi_get,
static int (*_field_qualify_TranslatedOuterVlanCfi_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedOuterVlanCfi_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedOuterVlanCfi_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedOuterVlanCfi_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedOuterVlanId( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t data, bcm_vlan_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedOuterVlanId,
static int (*_field_qualify_TranslatedOuterVlanId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedOuterVlanId(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t data, 
    bcm_vlan_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedOuterVlanId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedOuterVlanId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedOuterVlanId_get( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t *data, bcm_vlan_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedOuterVlanId_get,
static int (*_field_qualify_TranslatedOuterVlanId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedOuterVlanId_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedOuterVlanId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedOuterVlanId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedOuterVlanPri( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedOuterVlanPri,
static int (*_field_qualify_TranslatedOuterVlanPri_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedOuterVlanPri(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedOuterVlanPri_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedOuterVlanPri", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedOuterVlanPri_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedOuterVlanPri_get,
static int (*_field_qualify_TranslatedOuterVlanPri_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedOuterVlanPri_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedOuterVlanPri_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedOuterVlanPri_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedOuterVlan_get( \
    int unit, bcm_field_entry_t entry, bcm_vlan_t *data, bcm_vlan_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedOuterVlan_get,
static int (*_field_qualify_TranslatedOuterVlan_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedOuterVlan_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vlan_t *data, 
    bcm_vlan_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedOuterVlan_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedOuterVlan_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedVlanFormat( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedVlanFormat,
static int (*_field_qualify_TranslatedVlanFormat_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedVlanFormat(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedVlanFormat_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedVlanFormat", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TranslatedVlanFormat_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TranslatedVlanFormat_get,
static int (*_field_qualify_TranslatedVlanFormat_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TranslatedVlanFormat_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TranslatedVlanFormat_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TranslatedVlanFormat_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillEgressRbridge( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillEgressRbridge,
static int (*_field_qualify_TrillEgressRbridge_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillEgressRbridge(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillEgressRbridge_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillEgressRbridge", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillEgressRbridgeHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillEgressRbridgeHit,
static int (*_field_qualify_TrillEgressRbridgeHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillEgressRbridgeHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillEgressRbridgeHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillEgressRbridgeHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillEgressRbridgeHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillEgressRbridgeHit_get,
static int (*_field_qualify_TrillEgressRbridgeHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillEgressRbridgeHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillEgressRbridgeHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillEgressRbridgeHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillEgressRbridge_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillEgressRbridge_get,
static int (*_field_qualify_TrillEgressRbridge_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillEgressRbridge_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillEgressRbridge_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillEgressRbridge_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillHopCount( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillHopCount,
static int (*_field_qualify_TrillHopCount_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillHopCount(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillHopCount_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillHopCount", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillHopCount_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillHopCount_get,
static int (*_field_qualify_TrillHopCount_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillHopCount_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillHopCount_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillHopCount_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillIVersion( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillIVersion,
static int (*_field_qualify_TrillIVersion_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillIVersion(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillIVersion_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillIVersion", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillIVersion_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillIVersion_get,
static int (*_field_qualify_TrillIVersion_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillIVersion_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillIVersion_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillIVersion_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillIngressRbridge( \
    int unit, bcm_field_entry_t entry, uint16 data, uint16 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillIngressRbridge,
static int (*_field_qualify_TrillIngressRbridge_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillIngressRbridge(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 data, 
    uint16 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillIngressRbridge_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillIngressRbridge", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillIngressRbridgeHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillIngressRbridgeHit,
static int (*_field_qualify_TrillIngressRbridgeHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillIngressRbridgeHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillIngressRbridgeHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillIngressRbridgeHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillIngressRbridgeHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillIngressRbridgeHit_get,
static int (*_field_qualify_TrillIngressRbridgeHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillIngressRbridgeHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillIngressRbridgeHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillIngressRbridgeHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillIngressRbridge_get( \
    int unit, bcm_field_entry_t entry, uint16 *data, uint16 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillIngressRbridge_get,
static int (*_field_qualify_TrillIngressRbridge_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillIngressRbridge_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint16 *data, 
    uint16 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillIngressRbridge_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillIngressRbridge_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillMultiDestination( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillMultiDestination,
static int (*_field_qualify_TrillMultiDestination_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillMultiDestination(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillMultiDestination_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillMultiDestination", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillMultiDestination_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillMultiDestination_get,
static int (*_field_qualify_TrillMultiDestination_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillMultiDestination_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillMultiDestination_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillMultiDestination_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillOpLength( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillOpLength,
static int (*_field_qualify_TrillOpLength_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillOpLength(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillOpLength_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillOpLength", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillOpLength_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillOpLength_get,
static int (*_field_qualify_TrillOpLength_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillOpLength_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillOpLength_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillOpLength_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillPayload( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillPayload,
static int (*_field_qualify_TrillPayload_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillPayload(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillPayload_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillPayload", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrillPayload_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrillPayload_get,
static int (*_field_qualify_TrillPayload_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrillPayload_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrillPayload_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrillPayload_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrunkHashResult( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrunkHashResult,
static int (*_field_qualify_TrunkHashResult_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrunkHashResult(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrunkHashResult_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrunkHashResult", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TrunkHashResult_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TrunkHashResult_get,
static int (*_field_qualify_TrunkHashResult_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TrunkHashResult_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TrunkHashResult_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TrunkHashResult_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Ttl( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Ttl,
static int (*_field_qualify_Ttl_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Ttl(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Ttl_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Ttl", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Ttl_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Ttl_get,
static int (*_field_qualify_Ttl_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Ttl_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Ttl_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Ttl_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TunnelId( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TunnelId,
static int (*_field_qualify_TunnelId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TunnelId(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TunnelId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TunnelId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TunnelId_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TunnelId_get,
static int (*_field_qualify_TunnelId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TunnelId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TunnelId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TunnelId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TunnelTerminated( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TunnelTerminated,
static int (*_field_qualify_TunnelTerminated_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TunnelTerminated(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TunnelTerminated_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TunnelTerminated", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TunnelTerminatedHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TunnelTerminatedHit,
static int (*_field_qualify_TunnelTerminatedHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TunnelTerminatedHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TunnelTerminatedHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TunnelTerminatedHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TunnelTerminatedHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TunnelTerminatedHit_get,
static int (*_field_qualify_TunnelTerminatedHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TunnelTerminatedHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TunnelTerminatedHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TunnelTerminatedHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TunnelTerminatedValue( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TunnelTerminatedValue,
static int (*_field_qualify_TunnelTerminatedValue_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TunnelTerminatedValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TunnelTerminatedValue_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TunnelTerminatedValue", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TunnelTerminatedValue_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TunnelTerminatedValue_get,
static int (*_field_qualify_TunnelTerminatedValue_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TunnelTerminatedValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TunnelTerminatedValue_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TunnelTerminatedValue_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TunnelTerminated_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TunnelTerminated_get,
static int (*_field_qualify_TunnelTerminated_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TunnelTerminated_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TunnelTerminated_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TunnelTerminated_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TunnelType( \
    int unit, bcm_field_entry_t entry, bcm_field_TunnelType_t tunnel_type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TunnelType,
static int (*_field_qualify_TunnelType_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_TunnelType_t tunnel_type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TunnelType(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_TunnelType_t tunnel_type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TunnelType_dispatch[dtype](unit, entry, tunnel_type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TunnelType", 3, 3, unit, entry, tunnel_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_TunnelType_get( \
    int unit, bcm_field_entry_t entry, bcm_field_TunnelType_t *tunnel_type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_TunnelType_get,
static int (*_field_qualify_TunnelType_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_TunnelType_t *tunnel_type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_TunnelType_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_TunnelType_t *tunnel_type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_TunnelType_get_dispatch[dtype](unit, entry, tunnel_type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_TunnelType_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VPortRangeCheck( \
    int unit, bcm_field_entry_t entry, bcm_field_range_t range, int invert);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VPortRangeCheck,
static int (*_field_qualify_VPortRangeCheck_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_range_t range, 
    int invert) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VPortRangeCheck(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_field_range_t range, 
    int invert)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VPortRangeCheck_dispatch[dtype](unit, entry, range, invert);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VPortRangeCheck", 4, 3, unit, entry, range, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VPortRangeCheck_get( \
    int unit, bcm_field_entry_t entry, int max_count, bcm_field_range_t *range, int *invert, int *count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VPortRangeCheck_get,
static int (*_field_qualify_VPortRangeCheck_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    int max_count, 
    bcm_field_range_t *range, 
    int *invert, 
    int *count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VPortRangeCheck_get(
    int unit, 
    bcm_field_entry_t entry, 
    int max_count, 
    bcm_field_range_t *range, 
    int *invert, 
    int *count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VPortRangeCheck_get_dispatch[dtype](unit, entry, max_count, range, invert, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VPortRangeCheck_get", 6, 3, unit, entry, max_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VlanFormat( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VlanFormat,
static int (*_field_qualify_VlanFormat_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VlanFormat(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VlanFormat_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VlanFormat", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VlanFormat_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VlanFormat_get,
static int (*_field_qualify_VlanFormat_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VlanFormat_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VlanFormat_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VlanFormat_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VlanTranslationHit( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VlanTranslationHit,
static int (*_field_qualify_VlanTranslationHit_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VlanTranslationHit(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VlanTranslationHit_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VlanTranslationHit", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VlanTranslationHit_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VlanTranslationHit_get,
static int (*_field_qualify_VlanTranslationHit_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VlanTranslationHit_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VlanTranslationHit_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VlanTranslationHit_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VlanTranslationValue( \
    int unit, bcm_field_entry_t entry, uint64 data, uint64 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VlanTranslationValue,
static int (*_field_qualify_VlanTranslationValue_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VlanTranslationValue(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 data, 
    uint64 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VlanTranslationValue_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VlanTranslationValue", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VlanTranslationValue_get( \
    int unit, bcm_field_entry_t entry, uint64 *data, uint64 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VlanTranslationValue_get,
static int (*_field_qualify_VlanTranslationValue_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VlanTranslationValue_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint64 *data, 
    uint64 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VlanTranslationValue_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VlanTranslationValue_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VnTag( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VnTag,
static int (*_field_qualify_VnTag_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VnTag(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VnTag_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VnTag", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VnTag_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VnTag_get,
static int (*_field_qualify_VnTag_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VnTag_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VnTag_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VnTag_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Vpn( \
    int unit, bcm_field_entry_t entry, bcm_vpn_t data, bcm_vpn_t mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Vpn,
static int (*_field_qualify_Vpn_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vpn_t data, 
    bcm_vpn_t mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Vpn(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vpn_t data, 
    bcm_vpn_t mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Vpn_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Vpn", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VpnUnknownDstMacDstPort( \
    int unit, bcm_field_entry_t entry, bcm_gport_t port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VpnUnknownDstMacDstPort,
static int (*_field_qualify_VpnUnknownDstMacDstPort_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VpnUnknownDstMacDstPort(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VpnUnknownDstMacDstPort_dispatch[dtype](unit, entry, port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VpnUnknownDstMacDstPort", 3, 3, unit, entry, port_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VpnUnknownDstMacDstPort_get( \
    int unit, bcm_field_entry_t entry, bcm_gport_t *port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VpnUnknownDstMacDstPort_get,
static int (*_field_qualify_VpnUnknownDstMacDstPort_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VpnUnknownDstMacDstPort_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_gport_t *port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VpnUnknownDstMacDstPort_get_dispatch[dtype](unit, entry, port_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VpnUnknownDstMacDstPort_get", 3, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Vpn_get( \
    int unit, bcm_field_entry_t entry, bcm_vpn_t *data, bcm_vpn_t *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Vpn_get,
static int (*_field_qualify_Vpn_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vpn_t *data, 
    bcm_vpn_t *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Vpn_get(
    int unit, 
    bcm_field_entry_t entry, 
    bcm_vpn_t *data, 
    bcm_vpn_t *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Vpn_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Vpn_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Vrf( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Vrf,
static int (*_field_qualify_Vrf_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Vrf(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Vrf_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Vrf", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_Vrf_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_Vrf_get,
static int (*_field_qualify_Vrf_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_Vrf_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_Vrf_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_Vrf_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VxlanFlags( \
    int unit, bcm_field_entry_t entry, uint8 data, uint8 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VxlanFlags,
static int (*_field_qualify_VxlanFlags_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VxlanFlags(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 data, 
    uint8 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VxlanFlags_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VxlanFlags", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VxlanFlags_get( \
    int unit, bcm_field_entry_t entry, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VxlanFlags_get,
static int (*_field_qualify_VxlanFlags_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VxlanFlags_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VxlanFlags_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VxlanFlags_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VxlanNetworkId( \
    int unit, bcm_field_entry_t entry, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VxlanNetworkId,
static int (*_field_qualify_VxlanNetworkId_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VxlanNetworkId(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VxlanNetworkId_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VxlanNetworkId", 4, 3, unit, entry, data, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_VxlanNetworkId_get( \
    int unit, bcm_field_entry_t entry, uint32 *data, uint32 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_VxlanNetworkId_get,
static int (*_field_qualify_VxlanNetworkId_get_dispatch[])(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_VxlanNetworkId_get(
    int unit, 
    bcm_field_entry_t entry, 
    uint32 *data, 
    uint32 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_VxlanNetworkId_get_dispatch[dtype](unit, entry, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_VxlanNetworkId_get", 4, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_clear( \
    int unit, bcm_field_entry_t entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_clear,
static int (*_field_qualify_clear_dispatch[])(
    int unit, 
    bcm_field_entry_t entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_clear(
    int unit, 
    bcm_field_entry_t entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_clear_dispatch[dtype](unit, entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_clear", 2, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_data( \
    int unit, bcm_field_entry_t eid, int qual_id, uint8 *data, uint8 *mask, uint16 length);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_data,
static int (*_field_qualify_data_dispatch[])(
    int unit, 
    bcm_field_entry_t eid, 
    int qual_id, 
    uint8 *data, 
    uint8 *mask, 
    uint16 length) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_data(
    int unit, 
    bcm_field_entry_t eid, 
    int qual_id, 
    uint8 *data, 
    uint8 *mask, 
    uint16 length)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_data_dispatch[dtype](unit, eid, qual_id, data, mask, length);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_data", 6, 3, unit, eid, qual_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_data_get( \
    int unit, bcm_field_entry_t eid, int qual_id, uint16 length_max, uint8 *data, uint8 *mask, uint16 *length);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_data_get,
static int (*_field_qualify_data_get_dispatch[])(
    int unit, 
    bcm_field_entry_t eid, 
    int qual_id, 
    uint16 length_max, 
    uint8 *data, 
    uint8 *mask, 
    uint16 *length) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_data_get(
    int unit, 
    bcm_field_entry_t eid, 
    int qual_id, 
    uint16 length_max, 
    uint8 *data, 
    uint8 *mask, 
    uint16 *length)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_data_get_dispatch[dtype](unit, eid, qual_id, length_max, data, mask, length);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_data_get", 7, 3, unit, eid, qual_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_udf( \
    int unit, bcm_field_entry_t eid, bcm_udf_id_t udf_id, int length, uint8 *data, uint8 *mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_udf,
static int (*_field_qualify_udf_dispatch[])(
    int unit, 
    bcm_field_entry_t eid, 
    bcm_udf_id_t udf_id, 
    int length, 
    uint8 *data, 
    uint8 *mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_udf(
    int unit, 
    bcm_field_entry_t eid, 
    bcm_udf_id_t udf_id, 
    int length, 
    uint8 *data, 
    uint8 *mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_udf_dispatch[dtype](unit, eid, udf_id, length, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_udf", 6, 3, unit, eid, udf_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_qualify_udf_get( \
    int unit, bcm_field_entry_t eid, bcm_udf_id_t udf_id, int max_length, uint8 *data, uint8 *mask, int *actual_length);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_qualify_udf_get,
static int (*_field_qualify_udf_get_dispatch[])(
    int unit, 
    bcm_field_entry_t eid, 
    bcm_udf_id_t udf_id, 
    int max_length, 
    uint8 *data, 
    uint8 *mask, 
    int *actual_length) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_qualify_udf_get(
    int unit, 
    bcm_field_entry_t eid, 
    bcm_udf_id_t udf_id, 
    int max_length, 
    uint8 *data, 
    uint8 *mask, 
    int *actual_length)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_qualify_udf_get_dispatch[dtype](unit, eid, udf_id, max_length, data, mask, actual_length);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_qualify_udf_get", 7, 3, unit, eid, udf_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_range_create( \
    int unit, bcm_field_range_t *range, uint32 flags, bcm_l4_port_t min, bcm_l4_port_t max);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_range_create,
static int (*_field_range_create_dispatch[])(
    int unit, 
    bcm_field_range_t *range, 
    uint32 flags, 
    bcm_l4_port_t min, 
    bcm_l4_port_t max) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_range_create(
    int unit, 
    bcm_field_range_t *range, 
    uint32 flags, 
    bcm_l4_port_t min, 
    bcm_l4_port_t max)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_range_create_dispatch[dtype](unit, range, flags, min, max);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_range_create", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_range_create_id( \
    int unit, bcm_field_range_t range, uint32 flags, bcm_l4_port_t min, bcm_l4_port_t max);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_range_create_id,
static int (*_field_range_create_id_dispatch[])(
    int unit, 
    bcm_field_range_t range, 
    uint32 flags, 
    bcm_l4_port_t min, 
    bcm_l4_port_t max) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_range_create_id(
    int unit, 
    bcm_field_range_t range, 
    uint32 flags, 
    bcm_l4_port_t min, 
    bcm_l4_port_t max)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_range_create_id_dispatch[dtype](unit, range, flags, min, max);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_range_create_id", 5, 3, unit, range, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_range_destroy( \
    int unit, bcm_field_range_t range);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_range_destroy,
static int (*_field_range_destroy_dispatch[])(
    int unit, 
    bcm_field_range_t range) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_range_destroy(
    int unit, 
    bcm_field_range_t range)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_range_destroy_dispatch[dtype](unit, range);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_range_destroy", 2, 2, unit, range, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_range_get( \
    int unit, bcm_field_range_t range, uint32 *flags, bcm_l4_port_t *min, bcm_l4_port_t *max);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_range_get,
static int (*_field_range_get_dispatch[])(
    int unit, 
    bcm_field_range_t range, 
    uint32 *flags, 
    bcm_l4_port_t *min, 
    bcm_l4_port_t *max) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_range_get(
    int unit, 
    bcm_field_range_t range, 
    uint32 *flags, 
    bcm_l4_port_t *min, 
    bcm_l4_port_t *max)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_range_get_dispatch[dtype](unit, range, flags, min, max);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_range_get", 5, 2, unit, range, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_range_group_create( \
    int unit, bcm_field_range_t *range, uint32 flags, bcm_l4_port_t min, bcm_l4_port_t max, bcm_if_group_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_range_group_create,
static int (*_field_range_group_create_dispatch[])(
    int unit, 
    bcm_field_range_t *range, 
    uint32 flags, 
    bcm_l4_port_t min, 
    bcm_l4_port_t max, 
    bcm_if_group_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_range_group_create(
    int unit, 
    bcm_field_range_t *range, 
    uint32 flags, 
    bcm_l4_port_t min, 
    bcm_l4_port_t max, 
    bcm_if_group_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_range_group_create_dispatch[dtype](unit, range, flags, min, max, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_range_group_create", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_range_group_create_id( \
    int unit, bcm_field_range_t range, uint32 flags, bcm_l4_port_t min, bcm_l4_port_t max, bcm_if_group_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_range_group_create_id,
static int (*_field_range_group_create_id_dispatch[])(
    int unit, 
    bcm_field_range_t range, 
    uint32 flags, 
    bcm_l4_port_t min, 
    bcm_l4_port_t max, 
    bcm_if_group_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_range_group_create_id(
    int unit, 
    bcm_field_range_t range, 
    uint32 flags, 
    bcm_l4_port_t min, 
    bcm_l4_port_t max, 
    bcm_if_group_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_range_group_create_id_dispatch[dtype](unit, range, flags, min, max, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_range_group_create_id", 6, 3, unit, range, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_range_multi_create( \
    int unit, bcm_field_range_t *range_id, uint32 create_flags, int count, uint32 *range_flags, uint32 *min_value, uint32 *max_value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_range_multi_create,
static int (*_field_range_multi_create_dispatch[])(
    int unit, 
    bcm_field_range_t *range_id, 
    uint32 create_flags, 
    int count, 
    uint32 *range_flags, 
    uint32 *min_value, 
    uint32 *max_value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_range_multi_create(
    int unit, 
    bcm_field_range_t *range_id, 
    uint32 create_flags, 
    int count, 
    uint32 *range_flags, 
    uint32 *min_value, 
    uint32 *max_value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_range_multi_create_dispatch[dtype](unit, range_id, create_flags, count, range_flags, min_value, max_value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_range_multi_create", 7, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_range_multi_get( \
    int unit, bcm_field_range_t range_id, int max_count, uint32 *range_flags, uint32 *minimum_value, uint32 *maxamum_value, int *actual_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_range_multi_get,
static int (*_field_range_multi_get_dispatch[])(
    int unit, 
    bcm_field_range_t range_id, 
    int max_count, 
    uint32 *range_flags, 
    uint32 *minimum_value, 
    uint32 *maxamum_value, 
    int *actual_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_range_multi_get(
    int unit, 
    bcm_field_range_t range_id, 
    int max_count, 
    uint32 *range_flags, 
    uint32 *minimum_value, 
    uint32 *maxamum_value, 
    int *actual_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_range_multi_get_dispatch[dtype](unit, range_id, max_count, range_flags, minimum_value, maxamum_value, actual_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_range_multi_get", 7, 3, unit, range_id, max_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_resync( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_resync,
static int (*_field_resync_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_resync(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_resync_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_resync", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

#if defined(BROADCOM_DEBUG)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_show( \
    int unit, const char *pfx);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_show,
static int (*_field_show_dispatch[])(
    int unit, 
    const char *pfx) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_show(
    int unit, 
    const char *pfx)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_show_dispatch[dtype](unit, pfx);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_show", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stage_info_get( \
    int unit, bcm_field_stage_t stage, bcm_field_stage_info_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stage_info_get,
static int (*_field_stage_info_get_dispatch[])(
    int unit, 
    bcm_field_stage_t stage, 
    bcm_field_stage_info_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stage_info_get(
    int unit, 
    bcm_field_stage_t stage, 
    bcm_field_stage_info_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stage_info_get_dispatch[dtype](unit, stage, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stage_info_get", 3, 2, unit, stage, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_all_set( \
    int unit, int stat_id, uint64 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_all_set,
static int (*_field_stat_all_set_dispatch[])(
    int unit, 
    int stat_id, 
    uint64 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_all_set(
    int unit, 
    int stat_id, 
    uint64 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_all_set_dispatch[dtype](unit, stat_id, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_all_set", 3, 2, unit, stat_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_all_set32( \
    int unit, int stat_id, uint32 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_all_set32,
static int (*_field_stat_all_set32_dispatch[])(
    int unit, 
    int stat_id, 
    uint32 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_all_set32(
    int unit, 
    int stat_id, 
    uint32 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_all_set32_dispatch[dtype](unit, stat_id, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_all_set32", 3, 3, unit, stat_id, value, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_attach( \
    int unit, bcm_field_group_t group, uint32 stat_counter_id, uint32 *stat_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_attach,
static int (*_field_stat_attach_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    uint32 stat_counter_id, 
    uint32 *stat_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_attach(
    int unit, 
    bcm_field_group_t group, 
    uint32 stat_counter_id, 
    uint32 *stat_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_attach_dispatch[dtype](unit, group, stat_counter_id, stat_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_attach", 4, 3, unit, group, stat_counter_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_config_get( \
    int unit, int stat_id, int nstat, bcm_field_stat_t *stat_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_config_get,
static int (*_field_stat_config_get_dispatch[])(
    int unit, 
    int stat_id, 
    int nstat, 
    bcm_field_stat_t *stat_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_config_get(
    int unit, 
    int stat_id, 
    int nstat, 
    bcm_field_stat_t *stat_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_config_get_dispatch[dtype](unit, stat_id, nstat, stat_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_config_get", 4, 3, unit, stat_id, nstat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_counter_get( \
    int unit, uint32 stat_id, bcm_field_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_counter_get,
static int (*_field_stat_counter_get_dispatch[])(
    int unit, 
    uint32 stat_id, 
    bcm_field_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_counter_get(
    int unit, 
    uint32 stat_id, 
    bcm_field_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_counter_get_dispatch[dtype](unit, stat_id, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_counter_get", 6, 3, unit, stat_id, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_counter_set( \
    int unit, uint32 stat_id, bcm_field_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_counter_set,
static int (*_field_stat_counter_set_dispatch[])(
    int unit, 
    uint32 stat_id, 
    bcm_field_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_counter_set(
    int unit, 
    uint32 stat_id, 
    bcm_field_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_counter_set_dispatch[dtype](unit, stat_id, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_counter_set", 6, 3, unit, stat_id, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_counter_sync_get( \
    int unit, uint32 stat_id, bcm_field_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_counter_sync_get,
static int (*_field_stat_counter_sync_get_dispatch[])(
    int unit, 
    uint32 stat_id, 
    bcm_field_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_counter_sync_get(
    int unit, 
    uint32 stat_id, 
    bcm_field_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_counter_sync_get_dispatch[dtype](unit, stat_id, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_counter_sync_get", 6, 3, unit, stat_id, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_create( \
    int unit, bcm_field_group_t group, int nstat, bcm_field_stat_t *stat_arr, int *stat_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_create,
static int (*_field_stat_create_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    int nstat, 
    bcm_field_stat_t *stat_arr, 
    int *stat_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_create(
    int unit, 
    bcm_field_group_t group, 
    int nstat, 
    bcm_field_stat_t *stat_arr, 
    int *stat_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_create_dispatch[dtype](unit, group, nstat, stat_arr, stat_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_create", 5, 3, unit, group, nstat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_create_id( \
    int unit, bcm_field_group_t group, int nstat, bcm_field_stat_t *stat_arr, int stat_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_create_id,
static int (*_field_stat_create_id_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    int nstat, 
    bcm_field_stat_t *stat_arr, 
    int stat_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_create_id(
    int unit, 
    bcm_field_group_t group, 
    int nstat, 
    bcm_field_stat_t *stat_arr, 
    int stat_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_create_id_dispatch[dtype](unit, group, nstat, stat_arr, stat_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_create_id", 5, 3, unit, group, nstat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_destroy( \
    int unit, int stat_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_destroy,
static int (*_field_stat_destroy_dispatch[])(
    int unit, 
    int stat_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_destroy(
    int unit, 
    int stat_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_destroy_dispatch[dtype](unit, stat_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_destroy", 2, 2, unit, stat_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_detach( \
    int unit, uint32 stat_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_detach,
static int (*_field_stat_detach_dispatch[])(
    int unit, 
    uint32 stat_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_detach(
    int unit, 
    uint32 stat_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_detach_dispatch[dtype](unit, stat_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_detach", 2, 2, unit, stat_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_get( \
    int unit, int stat_id, bcm_field_stat_t stat, uint64 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_get,
static int (*_field_stat_get_dispatch[])(
    int unit, 
    int stat_id, 
    bcm_field_stat_t stat, 
    uint64 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_get(
    int unit, 
    int stat_id, 
    bcm_field_stat_t stat, 
    uint64 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_get_dispatch[dtype](unit, stat_id, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_get", 4, 3, unit, stat_id, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_get32( \
    int unit, int stat_id, bcm_field_stat_t stat, uint32 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_get32,
static int (*_field_stat_get32_dispatch[])(
    int unit, 
    int stat_id, 
    bcm_field_stat_t stat, 
    uint32 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_get32(
    int unit, 
    int stat_id, 
    bcm_field_stat_t stat, 
    uint32 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_get32_dispatch[dtype](unit, stat_id, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_get32", 4, 3, unit, stat_id, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_id_get( \
    int unit, bcm_field_group_t group, uint32 stat_id, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_id_get,
static int (*_field_stat_id_get_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    uint32 stat_id, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_id_get(
    int unit, 
    bcm_field_group_t group, 
    uint32 stat_id, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_id_get_dispatch[dtype](unit, group, stat_id, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_id_get", 4, 3, unit, group, stat_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_multi_get( \
    int unit, int stat_id, int nstat, bcm_field_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_multi_get,
static int (*_field_stat_multi_get_dispatch[])(
    int unit, 
    int stat_id, 
    int nstat, 
    bcm_field_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_multi_get(
    int unit, 
    int stat_id, 
    int nstat, 
    bcm_field_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_multi_get_dispatch[dtype](unit, stat_id, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_multi_get", 5, 3, unit, stat_id, nstat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_multi_get32( \
    int unit, int stat_id, int nstat, bcm_field_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_multi_get32,
static int (*_field_stat_multi_get32_dispatch[])(
    int unit, 
    int stat_id, 
    int nstat, 
    bcm_field_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_multi_get32(
    int unit, 
    int stat_id, 
    int nstat, 
    bcm_field_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_multi_get32_dispatch[dtype](unit, stat_id, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_multi_get32", 5, 3, unit, stat_id, nstat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_set( \
    int unit, int stat_id, bcm_field_stat_t stat, uint64 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_set,
static int (*_field_stat_set_dispatch[])(
    int unit, 
    int stat_id, 
    bcm_field_stat_t stat, 
    uint64 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_set(
    int unit, 
    int stat_id, 
    bcm_field_stat_t stat, 
    uint64 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_set_dispatch[dtype](unit, stat_id, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_set", 4, 3, unit, stat_id, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_set32( \
    int unit, int stat_id, bcm_field_stat_t stat, uint32 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_set32,
static int (*_field_stat_set32_dispatch[])(
    int unit, 
    int stat_id, 
    bcm_field_stat_t stat, 
    uint32 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_set32(
    int unit, 
    int stat_id, 
    bcm_field_stat_t stat, 
    uint32 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_set32_dispatch[dtype](unit, stat_id, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_set32", 4, 3, unit, stat_id, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_size( \
    int unit, int stat_id, int *stat_size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_size,
static int (*_field_stat_size_dispatch[])(
    int unit, 
    int stat_id, 
    int *stat_size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_size(
    int unit, 
    int stat_id, 
    int *stat_size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_size_dispatch[dtype](unit, stat_id, stat_size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_size", 3, 2, unit, stat_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_sync_get( \
    int unit, int stat_id, bcm_field_stat_t stat, uint64 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_sync_get,
static int (*_field_stat_sync_get_dispatch[])(
    int unit, 
    int stat_id, 
    bcm_field_stat_t stat, 
    uint64 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_sync_get(
    int unit, 
    int stat_id, 
    bcm_field_stat_t stat, 
    uint64 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_sync_get_dispatch[dtype](unit, stat_id, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_sync_get", 4, 3, unit, stat_id, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_field_stat_sync_get32( \
    int unit, int stat_id, bcm_field_stat_t stat, uint32 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_field_stat_sync_get32,
static int (*_field_stat_sync_get32_dispatch[])(
    int unit, 
    int stat_id, 
    bcm_field_stat_t stat, 
    uint32 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_field_stat_sync_get32(
    int unit, 
    int stat_id, 
    bcm_field_stat_t stat, 
    uint32 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _field_stat_sync_get32_dispatch[dtype](unit, stat_id, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_field_stat_sync_get32", 4, 3, unit, stat_id, stat, r_rv);
	return r_rv;
}

#if defined(INCLUDE_I2C)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_i2c_ioctl( \
    int unit, int fd, int opcode, void *data, int len);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_i2c_ioctl,
static int (*_i2c_ioctl_dispatch[])(
    int unit, 
    int fd, 
    int opcode, 
    void *data, 
    int len) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_i2c_ioctl(
    int unit, 
    int fd, 
    int opcode, 
    void *data, 
    int len)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _i2c_ioctl_dispatch[dtype](unit, fd, opcode, data, len);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_i2c_ioctl", 5, 3, unit, fd, opcode, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_I2C)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_i2c_open( \
    int unit, char *devname, uint32 flags, int speed);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_i2c_open,
static int (*_i2c_open_dispatch[])(
    int unit, 
    char *devname, 
    uint32 flags, 
    int speed) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_i2c_open(
    int unit, 
    char *devname, 
    uint32 flags, 
    int speed)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _i2c_open_dispatch[dtype](unit, devname, flags, speed);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_i2c_open", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_I2C)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_i2c_read( \
    int unit, int fd, uint32 addr, uint8 *data, uint32 *nbytes);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_i2c_read,
static int (*_i2c_read_dispatch[])(
    int unit, 
    int fd, 
    uint32 addr, 
    uint8 *data, 
    uint32 *nbytes) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_i2c_read(
    int unit, 
    int fd, 
    uint32 addr, 
    uint8 *data, 
    uint32 *nbytes)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _i2c_read_dispatch[dtype](unit, fd, addr, data, nbytes);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_i2c_read", 5, 3, unit, fd, addr, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_I2C)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_i2c_write( \
    int unit, int fd, uint32 addr, uint8 *data, uint32 nbytes);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_i2c_write,
static int (*_i2c_write_dispatch[])(
    int unit, 
    int fd, 
    uint32 addr, 
    uint8 *data, 
    uint32 nbytes) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_i2c_write(
    int unit, 
    int fd, 
    uint32 addr, 
    uint8 *data, 
    uint32 nbytes)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _i2c_write_dispatch[dtype](unit, fd, addr, data, nbytes);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_i2c_write", 5, 3, unit, fd, addr, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_info_get( \
    int unit, bcm_info_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_info_get,
static int (*_info_get_dispatch[])(
    int unit, 
    bcm_info_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_info_get(
    int unit, 
    bcm_info_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _info_get_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_info_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_init_check( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_init_check,
static int (*_init_check_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_init_check(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _init_check_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_init_check", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_init_selective( \
    int unit, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_init_selective,
static int (*_init_selective_dispatch[])(
    int unit, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_init_selective(
    int unit, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _init_selective_dispatch[dtype](unit, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_init_selective", 2, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_config_get( \
    int unit, bcm_ipfix_stage_t stage, bcm_port_t port, bcm_ipfix_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_config_get,
static int (*_ipfix_config_get_dispatch[])(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_port_t port, 
    bcm_ipfix_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_config_get(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_port_t port, 
    bcm_ipfix_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_config_get_dispatch[dtype](unit, stage, port, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_config_get", 4, 3, unit, stage, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_config_set( \
    int unit, bcm_ipfix_stage_t stage, bcm_port_t port, bcm_ipfix_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_config_set,
static int (*_ipfix_config_set_dispatch[])(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_port_t port, 
    bcm_ipfix_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_config_set(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_port_t port, 
    bcm_ipfix_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_config_set_dispatch[dtype](unit, stage, port, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_config_set", 4, 3, unit, stage, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_mirror_config_get( \
    int unit, bcm_ipfix_stage_t stage, bcm_gport_t port, bcm_ipfix_mirror_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_mirror_config_get,
static int (*_ipfix_mirror_config_get_dispatch[])(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_gport_t port, 
    bcm_ipfix_mirror_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_mirror_config_get(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_gport_t port, 
    bcm_ipfix_mirror_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_mirror_config_get_dispatch[dtype](unit, stage, port, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_mirror_config_get", 4, 3, unit, stage, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_mirror_config_set( \
    int unit, bcm_ipfix_stage_t stage, bcm_gport_t port, bcm_ipfix_mirror_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_mirror_config_set,
static int (*_ipfix_mirror_config_set_dispatch[])(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_gport_t port, 
    bcm_ipfix_mirror_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_mirror_config_set(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_gport_t port, 
    bcm_ipfix_mirror_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_mirror_config_set_dispatch[dtype](unit, stage, port, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_mirror_config_set", 4, 3, unit, stage, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_mirror_port_dest_add( \
    int unit, bcm_ipfix_stage_t stage, bcm_gport_t port, bcm_gport_t mirror_dest_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_mirror_port_dest_add,
static int (*_ipfix_mirror_port_dest_add_dispatch[])(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_gport_t port, 
    bcm_gport_t mirror_dest_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_mirror_port_dest_add(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_gport_t port, 
    bcm_gport_t mirror_dest_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&mirror_dest_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_mirror_port_dest_add_dispatch[dtype](unit, stage, port, mirror_dest_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_mirror_port_dest_add", 4, 3, unit, stage, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_mirror_port_dest_delete( \
    int unit, bcm_ipfix_stage_t stage, bcm_gport_t port, bcm_gport_t mirror_dest_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_mirror_port_dest_delete,
static int (*_ipfix_mirror_port_dest_delete_dispatch[])(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_gport_t port, 
    bcm_gport_t mirror_dest_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_mirror_port_dest_delete(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_gport_t port, 
    bcm_gport_t mirror_dest_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&mirror_dest_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_mirror_port_dest_delete_dispatch[dtype](unit, stage, port, mirror_dest_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_mirror_port_dest_delete", 4, 3, unit, stage, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_mirror_port_dest_delete_all( \
    int unit, bcm_ipfix_stage_t stage, bcm_gport_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_mirror_port_dest_delete_all,
static int (*_ipfix_mirror_port_dest_delete_all_dispatch[])(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_gport_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_mirror_port_dest_delete_all(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_gport_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_mirror_port_dest_delete_all_dispatch[dtype](unit, stage, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_mirror_port_dest_delete_all", 3, 3, unit, stage, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_mirror_port_dest_get( \
    int unit, bcm_ipfix_stage_t stage, bcm_gport_t port, int mirror_dest_size, bcm_gport_t *mirror_dest_id, int *mirror_dest_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_mirror_port_dest_get,
static int (*_ipfix_mirror_port_dest_get_dispatch[])(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_gport_t port, 
    int mirror_dest_size, 
    bcm_gport_t *mirror_dest_id, 
    int *mirror_dest_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_mirror_port_dest_get(
    int unit, 
    bcm_ipfix_stage_t stage, 
    bcm_gport_t port, 
    int mirror_dest_size, 
    bcm_gport_t *mirror_dest_id, 
    int *mirror_dest_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_mirror_port_dest_get_dispatch[dtype](unit, stage, port, mirror_dest_size, mirror_dest_id, mirror_dest_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(mirror_dest_size,idx)
				BCM_API_XLATE_PORT_COND(mirror_dest_id) BCM_API_XLATE_PORT_P2A(unit,&(mirror_dest_id)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_mirror_port_dest_get", 6, 3, unit, stage, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_rate_create( \
    int unit, bcm_ipfix_rate_t *rate_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_rate_create,
static int (*_ipfix_rate_create_dispatch[])(
    int unit, 
    bcm_ipfix_rate_t *rate_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_rate_create(
    int unit, 
    bcm_ipfix_rate_t *rate_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_rate_create_dispatch[dtype](unit, rate_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_rate_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_rate_destroy( \
    int unit, bcm_ipfix_rate_id_t rate_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_rate_destroy,
static int (*_ipfix_rate_destroy_dispatch[])(
    int unit, 
    bcm_ipfix_rate_id_t rate_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_rate_destroy(
    int unit, 
    bcm_ipfix_rate_id_t rate_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_rate_destroy_dispatch[dtype](unit, rate_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_rate_destroy", 2, 2, unit, rate_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_rate_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_rate_destroy_all,
static int (*_ipfix_rate_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_rate_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_rate_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_rate_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_rate_get( \
    int unit, bcm_ipfix_rate_t *rate_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_rate_get,
static int (*_ipfix_rate_get_dispatch[])(
    int unit, 
    bcm_ipfix_rate_t *rate_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_rate_get(
    int unit, 
    bcm_ipfix_rate_t *rate_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_rate_get_dispatch[dtype](unit, rate_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_rate_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_rate_mirror_add( \
    int unit, bcm_ipfix_rate_id_t rate_id, bcm_gport_t mirror_dest_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_rate_mirror_add,
static int (*_ipfix_rate_mirror_add_dispatch[])(
    int unit, 
    bcm_ipfix_rate_id_t rate_id, 
    bcm_gport_t mirror_dest_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_rate_mirror_add(
    int unit, 
    bcm_ipfix_rate_id_t rate_id, 
    bcm_gport_t mirror_dest_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mirror_dest_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_rate_mirror_add_dispatch[dtype](unit, rate_id, mirror_dest_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_rate_mirror_add", 3, 3, unit, rate_id, mirror_dest_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_rate_mirror_delete( \
    int unit, bcm_ipfix_rate_id_t rate_id, bcm_gport_t mirror_dest_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_rate_mirror_delete,
static int (*_ipfix_rate_mirror_delete_dispatch[])(
    int unit, 
    bcm_ipfix_rate_id_t rate_id, 
    bcm_gport_t mirror_dest_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_rate_mirror_delete(
    int unit, 
    bcm_ipfix_rate_id_t rate_id, 
    bcm_gport_t mirror_dest_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mirror_dest_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_rate_mirror_delete_dispatch[dtype](unit, rate_id, mirror_dest_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_rate_mirror_delete", 3, 3, unit, rate_id, mirror_dest_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_rate_mirror_delete_all( \
    int unit, bcm_ipfix_rate_id_t rate_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_rate_mirror_delete_all,
static int (*_ipfix_rate_mirror_delete_all_dispatch[])(
    int unit, 
    bcm_ipfix_rate_id_t rate_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_rate_mirror_delete_all(
    int unit, 
    bcm_ipfix_rate_id_t rate_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_rate_mirror_delete_all_dispatch[dtype](unit, rate_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_rate_mirror_delete_all", 2, 2, unit, rate_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_rate_mirror_get( \
    int unit, bcm_ipfix_rate_id_t rate_id, int mirror_dest_size, bcm_gport_t *mirror_dest_id, int *mirror_dest_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_rate_mirror_get,
static int (*_ipfix_rate_mirror_get_dispatch[])(
    int unit, 
    bcm_ipfix_rate_id_t rate_id, 
    int mirror_dest_size, 
    bcm_gport_t *mirror_dest_id, 
    int *mirror_dest_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_rate_mirror_get(
    int unit, 
    bcm_ipfix_rate_id_t rate_id, 
    int mirror_dest_size, 
    bcm_gport_t *mirror_dest_id, 
    int *mirror_dest_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_rate_mirror_get_dispatch[dtype](unit, rate_id, mirror_dest_size, mirror_dest_id, mirror_dest_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(mirror_dest_size,idx)
				BCM_API_XLATE_PORT_COND(mirror_dest_id) BCM_API_XLATE_PORT_P2A(unit,&(mirror_dest_id)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_rate_mirror_get", 5, 3, unit, rate_id, mirror_dest_size, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_rate_traverse( \
    int unit, bcm_ipfix_rate_traverse_cb cb, void *userdata);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_rate_traverse,
static int (*_ipfix_rate_traverse_dispatch[])(
    int unit, 
    bcm_ipfix_rate_traverse_cb cb, 
    void *userdata) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_rate_traverse(
    int unit, 
    bcm_ipfix_rate_traverse_cb cb, 
    void *userdata)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_rate_traverse_dispatch[dtype](unit, cb, userdata);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_rate_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_register( \
    int unit, bcm_ipfix_callback_t callback, void *userdata);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_register,
static int (*_ipfix_register_dispatch[])(
    int unit, 
    bcm_ipfix_callback_t callback, 
    void *userdata) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_register(
    int unit, 
    bcm_ipfix_callback_t callback, 
    void *userdata)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_register_dispatch[dtype](unit, callback, userdata);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_register", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipfix_unregister( \
    int unit, bcm_ipfix_callback_t callback, void *userdata);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipfix_unregister,
static int (*_ipfix_unregister_dispatch[])(
    int unit, 
    bcm_ipfix_callback_t callback, 
    void *userdata) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipfix_unregister(
    int unit, 
    bcm_ipfix_callback_t callback, 
    void *userdata)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipfix_unregister_dispatch[dtype](unit, callback, userdata);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipfix_unregister", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_add( \
    int unit, bcm_ipmc_addr_t *data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_add,
static int (*_ipmc_add_dispatch[])(
    int unit, 
    bcm_ipmc_addr_t *data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_add(
    int unit, 
    bcm_ipmc_addr_t *data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_add_dispatch[dtype](unit, data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_age( \
    int unit, uint32 flags, bcm_ipmc_traverse_cb age_cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_age,
static int (*_ipmc_age_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_ipmc_traverse_cb age_cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_age(
    int unit, 
    uint32 flags, 
    bcm_ipmc_traverse_cb age_cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_age_dispatch[dtype](unit, flags, age_cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_age", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_bitmap_del( \
    int unit, int ipmc_idx, bcm_port_t port, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_bitmap_del,
static int (*_ipmc_bitmap_del_dispatch[])(
    int unit, 
    int ipmc_idx, 
    bcm_port_t port, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_bitmap_del(
    int unit, 
    int ipmc_idx, 
    bcm_port_t port, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_bitmap_del_dispatch[dtype](unit, ipmc_idx, port, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_bitmap_del", 4, 3, unit, ipmc_idx, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_bitmap_get( \
    int unit, int ipmc_idx, bcm_port_t port, bcm_pbmp_t *pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_bitmap_get,
static int (*_ipmc_bitmap_get_dispatch[])(
    int unit, 
    int ipmc_idx, 
    bcm_port_t port, 
    bcm_pbmp_t *pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_bitmap_get(
    int unit, 
    int ipmc_idx, 
    bcm_port_t port, 
    bcm_pbmp_t *pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_bitmap_get_dispatch[dtype](unit, ipmc_idx, port, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_bitmap_get", 4, 3, unit, ipmc_idx, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_bitmap_max_get( \
    int unit, int *max_index);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_bitmap_max_get,
static int (*_ipmc_bitmap_max_get_dispatch[])(
    int unit, 
    int *max_index) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_bitmap_max_get(
    int unit, 
    int *max_index)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_bitmap_max_get_dispatch[dtype](unit, max_index);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_bitmap_max_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_bitmap_set( \
    int unit, int ipmc_idx, bcm_port_t port, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_bitmap_set,
static int (*_ipmc_bitmap_set_dispatch[])(
    int unit, 
    int ipmc_idx, 
    bcm_port_t port, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_bitmap_set(
    int unit, 
    int ipmc_idx, 
    bcm_port_t port, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_bitmap_set_dispatch[dtype](unit, ipmc_idx, port, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_bitmap_set", 4, 3, unit, ipmc_idx, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_counters_get( \
    int unit, bcm_port_t port, bcm_ipmc_counters_t *counters);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_counters_get,
static int (*_ipmc_counters_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_ipmc_counters_t *counters) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_counters_get(
    int unit, 
    bcm_port_t port, 
    bcm_ipmc_counters_t *counters)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_counters_get_dispatch[dtype](unit, port, counters);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_counters_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_detach,
static int (*_ipmc_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_egress_port_get( \
    int unit, bcm_port_t port, bcm_mac_t mac, int *untag, bcm_vlan_t *vid, int *ttl_threshold);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_egress_port_get,
static int (*_ipmc_egress_port_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_mac_t mac, 
    int *untag, 
    bcm_vlan_t *vid, 
    int *ttl_threshold) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_egress_port_get(
    int unit, 
    bcm_port_t port, 
    bcm_mac_t mac, 
    int *untag, 
    bcm_vlan_t *vid, 
    int *ttl_threshold)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_egress_port_get_dispatch[dtype](unit, port, mac, untag, vid, ttl_threshold);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_egress_port_get", 6, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_egress_port_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_egress_port_init,
static int (*_ipmc_egress_port_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_egress_port_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_egress_port_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_egress_port_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_egress_port_set( \
    int unit, bcm_port_t port, const bcm_mac_t mac, int untag, bcm_vlan_t vid, int ttl_threshold);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_egress_port_set,
static int (*_ipmc_egress_port_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    const bcm_mac_t mac, 
    int untag, 
    bcm_vlan_t vid, 
    int ttl_threshold) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_egress_port_set(
    int unit, 
    bcm_port_t port, 
    const bcm_mac_t mac, 
    int untag, 
    bcm_vlan_t vid, 
    int ttl_threshold)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_egress_port_set_dispatch[dtype](unit, port, mac, untag, vid, ttl_threshold);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_egress_port_set", 6, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_enable( \
    int unit, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_enable,
static int (*_ipmc_enable_dispatch[])(
    int unit, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_enable(
    int unit, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_enable_dispatch[dtype](unit, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_enable", 2, 2, unit, enable, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_find( \
    int unit, bcm_ipmc_addr_t *data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_find,
static int (*_ipmc_find_dispatch[])(
    int unit, 
    bcm_ipmc_addr_t *data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_find(
    int unit, 
    bcm_ipmc_addr_t *data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_find_dispatch[dtype](unit, data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_find", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_init,
static int (*_ipmc_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_range_add( \
    int unit, int *range_id, bcm_ipmc_range_t *range);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_range_add,
static int (*_ipmc_range_add_dispatch[])(
    int unit, 
    int *range_id, 
    bcm_ipmc_range_t *range) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_range_add(
    int unit, 
    int *range_id, 
    bcm_ipmc_range_t *range)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_range_add_dispatch[dtype](unit, range_id, range);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_range_add", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_range_delete( \
    int unit, int range_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_range_delete,
static int (*_ipmc_range_delete_dispatch[])(
    int unit, 
    int range_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_range_delete(
    int unit, 
    int range_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_range_delete_dispatch[dtype](unit, range_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_range_delete", 2, 2, unit, range_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_range_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_range_delete_all,
static int (*_ipmc_range_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_range_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_range_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_range_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_range_get( \
    int unit, int range_id, bcm_ipmc_range_t *range);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_range_get,
static int (*_ipmc_range_get_dispatch[])(
    int unit, 
    int range_id, 
    bcm_ipmc_range_t *range) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_range_get(
    int unit, 
    int range_id, 
    bcm_ipmc_range_t *range)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_range_get_dispatch[dtype](unit, range_id, range);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_range_get", 3, 2, unit, range_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_range_size_get( \
    int unit, int *size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_range_size_get,
static int (*_ipmc_range_size_get_dispatch[])(
    int unit, 
    int *size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_range_size_get(
    int unit, 
    int *size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_range_size_get_dispatch[dtype](unit, size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_range_size_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_remove( \
    int unit, bcm_ipmc_addr_t *data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_remove,
static int (*_ipmc_remove_dispatch[])(
    int unit, 
    bcm_ipmc_addr_t *data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_remove(
    int unit, 
    bcm_ipmc_addr_t *data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_remove_dispatch[dtype](unit, data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_remove", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_remove_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_remove_all,
static int (*_ipmc_remove_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_remove_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_remove_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_remove_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_rp_add( \
    int unit, int rp_id, bcm_if_t intf_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_rp_add,
static int (*_ipmc_rp_add_dispatch[])(
    int unit, 
    int rp_id, 
    bcm_if_t intf_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_rp_add(
    int unit, 
    int rp_id, 
    bcm_if_t intf_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_rp_add_dispatch[dtype](unit, rp_id, intf_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_rp_add", 3, 3, unit, rp_id, intf_id, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_rp_create( \
    int unit, uint32 flags, int *rp_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_rp_create,
static int (*_ipmc_rp_create_dispatch[])(
    int unit, 
    uint32 flags, 
    int *rp_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_rp_create(
    int unit, 
    uint32 flags, 
    int *rp_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_rp_create_dispatch[dtype](unit, flags, rp_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_rp_create", 3, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_rp_delete( \
    int unit, int rp_id, bcm_if_t intf_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_rp_delete,
static int (*_ipmc_rp_delete_dispatch[])(
    int unit, 
    int rp_id, 
    bcm_if_t intf_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_rp_delete(
    int unit, 
    int rp_id, 
    bcm_if_t intf_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_rp_delete_dispatch[dtype](unit, rp_id, intf_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_rp_delete", 3, 3, unit, rp_id, intf_id, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_rp_delete_all( \
    int unit, int rp_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_rp_delete_all,
static int (*_ipmc_rp_delete_all_dispatch[])(
    int unit, 
    int rp_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_rp_delete_all(
    int unit, 
    int rp_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_rp_delete_all_dispatch[dtype](unit, rp_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_rp_delete_all", 2, 2, unit, rp_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_rp_destroy( \
    int unit, int rp_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_rp_destroy,
static int (*_ipmc_rp_destroy_dispatch[])(
    int unit, 
    int rp_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_rp_destroy(
    int unit, 
    int rp_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_rp_destroy_dispatch[dtype](unit, rp_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_rp_destroy", 2, 2, unit, rp_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_rp_get( \
    int unit, int rp_id, int intf_max, bcm_if_t *intf_array, int *intf_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_rp_get,
static int (*_ipmc_rp_get_dispatch[])(
    int unit, 
    int rp_id, 
    int intf_max, 
    bcm_if_t *intf_array, 
    int *intf_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_rp_get(
    int unit, 
    int rp_id, 
    int intf_max, 
    bcm_if_t *intf_array, 
    int *intf_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_rp_get_dispatch[dtype](unit, rp_id, intf_max, intf_array, intf_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_rp_get", 5, 3, unit, rp_id, intf_max, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_rp_set( \
    int unit, int rp_id, int intf_count, bcm_if_t *intf_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_rp_set,
static int (*_ipmc_rp_set_dispatch[])(
    int unit, 
    int rp_id, 
    int intf_count, 
    bcm_if_t *intf_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_rp_set(
    int unit, 
    int rp_id, 
    int intf_count, 
    bcm_if_t *intf_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_rp_set_dispatch[dtype](unit, rp_id, intf_count, intf_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_rp_set", 4, 3, unit, rp_id, intf_count, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_stat_attach( \
    int unit, bcm_ipmc_addr_t *info, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_stat_attach,
static int (*_ipmc_stat_attach_dispatch[])(
    int unit, 
    bcm_ipmc_addr_t *info, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_stat_attach(
    int unit, 
    bcm_ipmc_addr_t *info, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_stat_attach_dispatch[dtype](unit, info, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_stat_attach", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_stat_counter_get( \
    int unit, bcm_ipmc_addr_t *info, bcm_ipmc_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_stat_counter_get,
static int (*_ipmc_stat_counter_get_dispatch[])(
    int unit, 
    bcm_ipmc_addr_t *info, 
    bcm_ipmc_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_stat_counter_get(
    int unit, 
    bcm_ipmc_addr_t *info, 
    bcm_ipmc_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_stat_counter_get_dispatch[dtype](unit, info, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_stat_counter_get", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_stat_counter_set( \
    int unit, bcm_ipmc_addr_t *info, bcm_ipmc_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_stat_counter_set,
static int (*_ipmc_stat_counter_set_dispatch[])(
    int unit, 
    bcm_ipmc_addr_t *info, 
    bcm_ipmc_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_stat_counter_set(
    int unit, 
    bcm_ipmc_addr_t *info, 
    bcm_ipmc_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_stat_counter_set_dispatch[dtype](unit, info, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_stat_counter_set", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_stat_counter_sync_get( \
    int unit, bcm_ipmc_addr_t *info, bcm_ipmc_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_stat_counter_sync_get,
static int (*_ipmc_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_ipmc_addr_t *info, 
    bcm_ipmc_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_stat_counter_sync_get(
    int unit, 
    bcm_ipmc_addr_t *info, 
    bcm_ipmc_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_stat_counter_sync_get_dispatch[dtype](unit, info, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_stat_counter_sync_get", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_stat_detach( \
    int unit, bcm_ipmc_addr_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_stat_detach,
static int (*_ipmc_stat_detach_dispatch[])(
    int unit, 
    bcm_ipmc_addr_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_stat_detach(
    int unit, 
    bcm_ipmc_addr_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_stat_detach_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_stat_detach", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_stat_id_get( \
    int unit, bcm_ipmc_addr_t *info, bcm_ipmc_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_stat_id_get,
static int (*_ipmc_stat_id_get_dispatch[])(
    int unit, 
    bcm_ipmc_addr_t *info, 
    bcm_ipmc_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_stat_id_get(
    int unit, 
    bcm_ipmc_addr_t *info, 
    bcm_ipmc_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_stat_id_get_dispatch[dtype](unit, info, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_stat_id_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_stat_multi_get( \
    int unit, bcm_ipmc_addr_t *info, int nstat, bcm_ipmc_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_stat_multi_get,
static int (*_ipmc_stat_multi_get_dispatch[])(
    int unit, 
    bcm_ipmc_addr_t *info, 
    int nstat, 
    bcm_ipmc_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_stat_multi_get(
    int unit, 
    bcm_ipmc_addr_t *info, 
    int nstat, 
    bcm_ipmc_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_stat_multi_get_dispatch[dtype](unit, info, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_stat_multi_get", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_stat_multi_get32( \
    int unit, bcm_ipmc_addr_t *info, int nstat, bcm_ipmc_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_stat_multi_get32,
static int (*_ipmc_stat_multi_get32_dispatch[])(
    int unit, 
    bcm_ipmc_addr_t *info, 
    int nstat, 
    bcm_ipmc_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_stat_multi_get32(
    int unit, 
    bcm_ipmc_addr_t *info, 
    int nstat, 
    bcm_ipmc_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_stat_multi_get32_dispatch[dtype](unit, info, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_stat_multi_get32", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_stat_multi_set( \
    int unit, bcm_ipmc_addr_t *info, int nstat, bcm_ipmc_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_stat_multi_set,
static int (*_ipmc_stat_multi_set_dispatch[])(
    int unit, 
    bcm_ipmc_addr_t *info, 
    int nstat, 
    bcm_ipmc_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_stat_multi_set(
    int unit, 
    bcm_ipmc_addr_t *info, 
    int nstat, 
    bcm_ipmc_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_stat_multi_set_dispatch[dtype](unit, info, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_stat_multi_set", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_stat_multi_set32( \
    int unit, bcm_ipmc_addr_t *info, int nstat, bcm_ipmc_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_stat_multi_set32,
static int (*_ipmc_stat_multi_set32_dispatch[])(
    int unit, 
    bcm_ipmc_addr_t *info, 
    int nstat, 
    bcm_ipmc_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_stat_multi_set32(
    int unit, 
    bcm_ipmc_addr_t *info, 
    int nstat, 
    bcm_ipmc_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_stat_multi_set32_dispatch[dtype](unit, info, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_stat_multi_set32", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ipmc_traverse( \
    int unit, uint32 flags, bcm_ipmc_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ipmc_traverse,
static int (*_ipmc_traverse_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_ipmc_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ipmc_traverse(
    int unit, 
    uint32 flags, 
    bcm_ipmc_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ipmc_traverse_dispatch[dtype](unit, flags, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ipmc_traverse", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_knet_cleanup( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_knet_cleanup,
static int (*_knet_cleanup_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_knet_cleanup(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _knet_cleanup_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_knet_cleanup", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_knet_filter_create( \
    int unit, bcm_knet_filter_t *filter);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_knet_filter_create,
static int (*_knet_filter_create_dispatch[])(
    int unit, 
    bcm_knet_filter_t *filter) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_knet_filter_create(
    int unit, 
    bcm_knet_filter_t *filter)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(filter) BCM_API_XLATE_PORT_A2P(unit,&filter->m_ingport);
		dtype = BCM_DTYPE(unit);
		r_rv = _knet_filter_create_dispatch[dtype](unit, filter);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(filter) BCM_API_XLATE_PORT_P2A(unit,&filter->m_ingport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_knet_filter_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_knet_filter_destroy( \
    int unit, int filter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_knet_filter_destroy,
static int (*_knet_filter_destroy_dispatch[])(
    int unit, 
    int filter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_knet_filter_destroy(
    int unit, 
    int filter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _knet_filter_destroy_dispatch[dtype](unit, filter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_knet_filter_destroy", 2, 2, unit, filter_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_knet_filter_get( \
    int unit, int filter_id, bcm_knet_filter_t *filter);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_knet_filter_get,
static int (*_knet_filter_get_dispatch[])(
    int unit, 
    int filter_id, 
    bcm_knet_filter_t *filter) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_knet_filter_get(
    int unit, 
    int filter_id, 
    bcm_knet_filter_t *filter)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _knet_filter_get_dispatch[dtype](unit, filter_id, filter);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(filter) BCM_API_XLATE_PORT_P2A(unit,&filter->m_ingport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_knet_filter_get", 3, 2, unit, filter_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_knet_filter_traverse( \
    int unit, bcm_knet_filter_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_knet_filter_traverse,
static int (*_knet_filter_traverse_dispatch[])(
    int unit, 
    bcm_knet_filter_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_knet_filter_traverse(
    int unit, 
    bcm_knet_filter_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _knet_filter_traverse_dispatch[dtype](unit, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_knet_filter_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_knet_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_knet_init,
static int (*_knet_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_knet_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _knet_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_knet_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_knet_netif_create( \
    int unit, bcm_knet_netif_t *netif);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_knet_netif_create,
static int (*_knet_netif_create_dispatch[])(
    int unit, 
    bcm_knet_netif_t *netif) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_knet_netif_create(
    int unit, 
    bcm_knet_netif_t *netif)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(netif) BCM_API_XLATE_PORT_A2P(unit,&netif->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _knet_netif_create_dispatch[dtype](unit, netif);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(netif) BCM_API_XLATE_PORT_P2A(unit,&netif->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_knet_netif_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_knet_netif_destroy( \
    int unit, int netif_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_knet_netif_destroy,
static int (*_knet_netif_destroy_dispatch[])(
    int unit, 
    int netif_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_knet_netif_destroy(
    int unit, 
    int netif_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _knet_netif_destroy_dispatch[dtype](unit, netif_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_knet_netif_destroy", 2, 2, unit, netif_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_knet_netif_get( \
    int unit, int netif_id, bcm_knet_netif_t *netif);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_knet_netif_get,
static int (*_knet_netif_get_dispatch[])(
    int unit, 
    int netif_id, 
    bcm_knet_netif_t *netif) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_knet_netif_get(
    int unit, 
    int netif_id, 
    bcm_knet_netif_t *netif)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _knet_netif_get_dispatch[dtype](unit, netif_id, netif);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(netif) BCM_API_XLATE_PORT_P2A(unit,&netif->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_knet_netif_get", 3, 2, unit, netif_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_knet_netif_traverse( \
    int unit, bcm_knet_netif_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_knet_netif_traverse,
static int (*_knet_netif_traverse_dispatch[])(
    int unit, 
    bcm_knet_netif_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_knet_netif_traverse(
    int unit, 
    bcm_knet_netif_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _knet_netif_traverse_dispatch[dtype](unit, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_knet_netif_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_add( \
    int unit, bcm_l2_addr_t *l2addr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_add,
static int (*_l2_addr_add_dispatch[])(
    int unit, 
    bcm_l2_addr_t *l2addr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_add(
    int unit, 
    bcm_l2_addr_t *l2addr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(l2addr_block_bitmap);
		BCM_API_XLATE_PORT_COND(l2addr) BCM_API_XLATE_PORT_PBMP_SAVE(l2addr_block_bitmap,l2addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(l2addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&l2addr->block_bitmap);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_add_dispatch[dtype](unit, l2addr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(l2addr) BCM_API_XLATE_PORT_PBMP_RESTORE(l2addr->block_bitmap,l2addr_block_bitmap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_delete( \
    int unit, bcm_mac_t mac, bcm_vlan_t vid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_delete,
static int (*_l2_addr_delete_dispatch[])(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_delete(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_delete_dispatch[dtype](unit, mac, vid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_delete", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_delete_by_mac( \
    int unit, bcm_mac_t mac, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_delete_by_mac,
static int (*_l2_addr_delete_by_mac_dispatch[])(
    int unit, 
    bcm_mac_t mac, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_delete_by_mac(
    int unit, 
    bcm_mac_t mac, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_delete_by_mac_dispatch[dtype](unit, mac, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_delete_by_mac", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_delete_by_mac_port( \
    int unit, bcm_mac_t mac, bcm_module_t mod, bcm_port_t port, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_delete_by_mac_port,
static int (*_l2_addr_delete_by_mac_port_dispatch[])(
    int unit, 
    bcm_mac_t mac, 
    bcm_module_t mod, 
    bcm_port_t port, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_delete_by_mac_port(
    int unit, 
    bcm_mac_t mac, 
    bcm_module_t mod, 
    bcm_port_t port, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_delete_by_mac_port_dispatch[dtype](unit, mac, mod, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_delete_by_mac_port", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_delete_by_port( \
    int unit, bcm_module_t mod, bcm_port_t port, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_delete_by_port,
static int (*_l2_addr_delete_by_port_dispatch[])(
    int unit, 
    bcm_module_t mod, 
    bcm_port_t port, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_delete_by_port(
    int unit, 
    bcm_module_t mod, 
    bcm_port_t port, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_delete_by_port_dispatch[dtype](unit, mod, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_delete_by_port", 4, 3, unit, mod, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_delete_by_trunk( \
    int unit, bcm_trunk_t tid, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_delete_by_trunk,
static int (*_l2_addr_delete_by_trunk_dispatch[])(
    int unit, 
    bcm_trunk_t tid, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_delete_by_trunk(
    int unit, 
    bcm_trunk_t tid, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_delete_by_trunk_dispatch[dtype](unit, tid, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_delete_by_trunk", 3, 3, unit, tid, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_delete_by_vlan( \
    int unit, bcm_vlan_t vid, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_delete_by_vlan,
static int (*_l2_addr_delete_by_vlan_dispatch[])(
    int unit, 
    bcm_vlan_t vid, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_delete_by_vlan(
    int unit, 
    bcm_vlan_t vid, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_delete_by_vlan_dispatch[dtype](unit, vid, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_delete_by_vlan", 3, 3, unit, vid, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_delete_by_vlan_gport_multi( \
    int unit, uint32 flags, int num_pairs, bcm_vlan_t *vlan, bcm_gport_t *gport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_delete_by_vlan_gport_multi,
static int (*_l2_addr_delete_by_vlan_gport_multi_dispatch[])(
    int unit, 
    uint32 flags, 
    int num_pairs, 
    bcm_vlan_t *vlan, 
    bcm_gport_t *gport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_delete_by_vlan_gport_multi(
    int unit, 
    uint32 flags, 
    int num_pairs, 
    bcm_vlan_t *vlan, 
    bcm_gport_t *gport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_ITER(num_pairs,idx)
			BCM_API_XLATE_PORT_COND(gport) BCM_API_XLATE_PORT_A2P(unit,&(gport)[idx]);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_delete_by_vlan_gport_multi_dispatch[dtype](unit, flags, num_pairs, vlan, gport);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_ITER(num_pairs,idx)
			BCM_API_XLATE_PORT_COND(gport) BCM_API_XLATE_PORT_P2A(unit,&(gport)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_delete_by_vlan_gport_multi", 5, 3, unit, flags, num_pairs, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_delete_by_vlan_port( \
    int unit, bcm_vlan_t vid, bcm_module_t mod, bcm_port_t port, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_delete_by_vlan_port,
static int (*_l2_addr_delete_by_vlan_port_dispatch[])(
    int unit, 
    bcm_vlan_t vid, 
    bcm_module_t mod, 
    bcm_port_t port, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_delete_by_vlan_port(
    int unit, 
    bcm_vlan_t vid, 
    bcm_module_t mod, 
    bcm_port_t port, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_delete_by_vlan_port_dispatch[dtype](unit, vid, mod, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_delete_by_vlan_port", 5, 3, unit, vid, mod, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_delete_by_vlan_trunk( \
    int unit, bcm_vlan_t vid, bcm_trunk_t tid, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_delete_by_vlan_trunk,
static int (*_l2_addr_delete_by_vlan_trunk_dispatch[])(
    int unit, 
    bcm_vlan_t vid, 
    bcm_trunk_t tid, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_delete_by_vlan_trunk(
    int unit, 
    bcm_vlan_t vid, 
    bcm_trunk_t tid, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_delete_by_vlan_trunk_dispatch[dtype](unit, vid, tid, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_delete_by_vlan_trunk", 4, 3, unit, vid, tid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_freeze( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_freeze,
static int (*_l2_addr_freeze_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_freeze(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_freeze_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_freeze", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_get( \
    int unit, bcm_mac_t mac_addr, bcm_vlan_t vid, bcm_l2_addr_t *l2addr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_get,
static int (*_l2_addr_get_dispatch[])(
    int unit, 
    bcm_mac_t mac_addr, 
    bcm_vlan_t vid, 
    bcm_l2_addr_t *l2addr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_get(
    int unit, 
    bcm_mac_t mac_addr, 
    bcm_vlan_t vid, 
    bcm_l2_addr_t *l2addr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_get_dispatch[dtype](unit, mac_addr, vid, l2addr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(l2addr) BCM_API_XLATE_PORT_PBMP_P2A(unit,&l2addr->block_bitmap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_msg_distribute_get( \
    int unit, bcm_l2_addr_distribute_t *distribution);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_msg_distribute_get,
static int (*_l2_addr_msg_distribute_get_dispatch[])(
    int unit, 
    bcm_l2_addr_distribute_t *distribution) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_msg_distribute_get(
    int unit, 
    bcm_l2_addr_distribute_t *distribution)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_msg_distribute_get_dispatch[dtype](unit, distribution);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_msg_distribute_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_msg_distribute_set( \
    int unit, bcm_l2_addr_distribute_t *distribution);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_msg_distribute_set,
static int (*_l2_addr_msg_distribute_set_dispatch[])(
    int unit, 
    bcm_l2_addr_distribute_t *distribution) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_msg_distribute_set(
    int unit, 
    bcm_l2_addr_distribute_t *distribution)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_msg_distribute_set_dispatch[dtype](unit, distribution);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_msg_distribute_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_register( \
    int unit, bcm_l2_addr_callback_t callback, void *userdata);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_register,
static int (*_l2_addr_register_dispatch[])(
    int unit, 
    bcm_l2_addr_callback_t callback, 
    void *userdata) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_register(
    int unit, 
    bcm_l2_addr_callback_t callback, 
    void *userdata)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_register_dispatch[dtype](unit, callback, userdata);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_register", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_thaw( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_thaw,
static int (*_l2_addr_thaw_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_thaw(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_thaw_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_thaw", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_addr_unregister( \
    int unit, bcm_l2_addr_callback_t callback, void *userdata);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_addr_unregister,
static int (*_l2_addr_unregister_dispatch[])(
    int unit, 
    bcm_l2_addr_callback_t callback, 
    void *userdata) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_addr_unregister(
    int unit, 
    bcm_l2_addr_callback_t callback, 
    void *userdata)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_addr_unregister_dispatch[dtype](unit, callback, userdata);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_addr_unregister", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_age_timer_get( \
    int unit, int *age_seconds);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_age_timer_get,
static int (*_l2_age_timer_get_dispatch[])(
    int unit, 
    int *age_seconds) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_age_timer_get(
    int unit, 
    int *age_seconds)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_age_timer_get_dispatch[dtype](unit, age_seconds);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_age_timer_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_age_timer_set( \
    int unit, int age_seconds);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_age_timer_set,
static int (*_l2_age_timer_set_dispatch[])(
    int unit, 
    int age_seconds) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_age_timer_set(
    int unit, 
    int age_seconds)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_age_timer_set_dispatch[dtype](unit, age_seconds);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_age_timer_set", 2, 2, unit, age_seconds, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_auth_add( \
    int unit, bcm_l2_auth_addr_t *addr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_auth_add,
static int (*_l2_auth_add_dispatch[])(
    int unit, 
    bcm_l2_auth_addr_t *addr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_auth_add(
    int unit, 
    bcm_l2_auth_addr_t *addr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(addr_src_port);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_SAVE(addr_src_port,addr->src_port);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_A2P(unit,&addr->src_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_auth_add_dispatch[dtype](unit, addr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_RESTORE(addr->src_port,addr_src_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_auth_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_auth_delete( \
    int unit, bcm_l2_auth_addr_t *addr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_auth_delete,
static int (*_l2_auth_delete_dispatch[])(
    int unit, 
    bcm_l2_auth_addr_t *addr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_auth_delete(
    int unit, 
    bcm_l2_auth_addr_t *addr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(addr_src_port);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_SAVE(addr_src_port,addr->src_port);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_A2P(unit,&addr->src_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_auth_delete_dispatch[dtype](unit, addr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_RESTORE(addr->src_port,addr_src_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_auth_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_auth_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_auth_delete_all,
static int (*_l2_auth_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_auth_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_auth_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_auth_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_auth_get( \
    int unit, bcm_l2_auth_addr_t *addr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_auth_get,
static int (*_l2_auth_get_dispatch[])(
    int unit, 
    bcm_l2_auth_addr_t *addr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_auth_get(
    int unit, 
    bcm_l2_auth_addr_t *addr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_auth_get_dispatch[dtype](unit, addr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_P2A(unit,&addr->src_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_auth_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_auth_traverse( \
    int unit, bcm_l2_auth_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_auth_traverse,
static int (*_l2_auth_traverse_dispatch[])(
    int unit, 
    bcm_l2_auth_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_auth_traverse(
    int unit, 
    bcm_l2_auth_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_auth_traverse_dispatch[dtype](unit, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_auth_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_cache_delete( \
    int unit, int index);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_cache_delete,
static int (*_l2_cache_delete_dispatch[])(
    int unit, 
    int index) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_cache_delete(
    int unit, 
    int index)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_cache_delete_dispatch[dtype](unit, index);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_cache_delete", 2, 2, unit, index, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_cache_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_cache_delete_all,
static int (*_l2_cache_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_cache_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_cache_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_cache_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_cache_get( \
    int unit, int index, bcm_l2_cache_addr_t *addr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_cache_get,
static int (*_l2_cache_get_dispatch[])(
    int unit, 
    int index, 
    bcm_l2_cache_addr_t *addr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_cache_get(
    int unit, 
    int index, 
    bcm_l2_cache_addr_t *addr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_cache_get_dispatch[dtype](unit, index, addr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_PBMP_P2A(unit,&addr->dest_ports);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_P2A(unit,&addr->src_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_cache_get", 3, 2, unit, index, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_cache_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_cache_init,
static int (*_l2_cache_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_cache_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_cache_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_cache_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_cache_set( \
    int unit, int index, bcm_l2_cache_addr_t *addr, int *index_used);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_cache_set,
static int (*_l2_cache_set_dispatch[])(
    int unit, 
    int index, 
    bcm_l2_cache_addr_t *addr, 
    int *index_used) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_cache_set(
    int unit, 
    int index, 
    bcm_l2_cache_addr_t *addr, 
    int *index_used)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(addr_dest_ports);
		BCM_API_XLATE_PORT_DECL(addr_src_port);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_PBMP_SAVE(addr_dest_ports,addr->dest_ports);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&addr->dest_ports);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_SAVE(addr_src_port,addr->src_port);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_A2P(unit,&addr->src_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_cache_set_dispatch[dtype](unit, index, addr, index_used);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_PBMP_RESTORE(addr->dest_ports,addr_dest_ports);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_RESTORE(addr->src_port,addr_src_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_cache_set", 4, 2, unit, index, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_cache_size_get( \
    int unit, int *size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_cache_size_get,
static int (*_l2_cache_size_get_dispatch[])(
    int unit, 
    int *size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_cache_size_get(
    int unit, 
    int *size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_cache_size_get_dispatch[dtype](unit, size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_cache_size_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_clear( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_clear,
static int (*_l2_clear_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_clear(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_clear_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_clear", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_conflict_get( \
    int unit, bcm_l2_addr_t *addr, bcm_l2_addr_t *cf_array, int cf_max, int *cf_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_conflict_get,
static int (*_l2_conflict_get_dispatch[])(
    int unit, 
    bcm_l2_addr_t *addr, 
    bcm_l2_addr_t *cf_array, 
    int cf_max, 
    int *cf_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_conflict_get(
    int unit, 
    bcm_l2_addr_t *addr, 
    bcm_l2_addr_t *cf_array, 
    int cf_max, 
    int *cf_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(addr_block_bitmap);
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_PBMP_SAVE(addr_block_bitmap,addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&addr->block_bitmap);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_conflict_get_dispatch[dtype](unit, addr, cf_array, cf_max, cf_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(addr) BCM_API_XLATE_PORT_PBMP_RESTORE(addr->block_bitmap,addr_block_bitmap);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(cf_max,idx)
				BCM_API_XLATE_PORT_COND(cf_array) BCM_API_XLATE_PORT_PBMP_P2A(unit,&(cf_array)[idx].block_bitmap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_conflict_get", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_detach,
static int (*_l2_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_egress_create( \
    int unit, bcm_l2_egress_t *egr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_egress_create,
static int (*_l2_egress_create_dispatch[])(
    int unit, 
    bcm_l2_egress_t *egr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_egress_create(
    int unit, 
    bcm_l2_egress_t *egr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(egr) BCM_API_XLATE_PORT_A2P(unit,&egr->dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_egress_create_dispatch[dtype](unit, egr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(egr) BCM_API_XLATE_PORT_P2A(unit,&egr->dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_egress_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_egress_destroy( \
    int unit, bcm_if_t encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_egress_destroy,
static int (*_l2_egress_destroy_dispatch[])(
    int unit, 
    bcm_if_t encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_egress_destroy(
    int unit, 
    bcm_if_t encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_egress_destroy_dispatch[dtype](unit, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_egress_destroy", 2, 2, unit, encap_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_egress_find( \
    int unit, bcm_l2_egress_t *egr, bcm_if_t *encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_egress_find,
static int (*_l2_egress_find_dispatch[])(
    int unit, 
    bcm_l2_egress_t *egr, 
    bcm_if_t *encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_egress_find(
    int unit, 
    bcm_l2_egress_t *egr, 
    bcm_if_t *encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(egr_dest_port);
		BCM_API_XLATE_PORT_COND(egr) BCM_API_XLATE_PORT_SAVE(egr_dest_port,egr->dest_port);
		BCM_API_XLATE_PORT_COND(egr) BCM_API_XLATE_PORT_A2P(unit,&egr->dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_egress_find_dispatch[dtype](unit, egr, encap_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(egr) BCM_API_XLATE_PORT_RESTORE(egr->dest_port,egr_dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_egress_find", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_egress_get( \
    int unit, bcm_if_t encap_id, bcm_l2_egress_t *egr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_egress_get,
static int (*_l2_egress_get_dispatch[])(
    int unit, 
    bcm_if_t encap_id, 
    bcm_l2_egress_t *egr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_egress_get(
    int unit, 
    bcm_if_t encap_id, 
    bcm_l2_egress_t *egr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_egress_get_dispatch[dtype](unit, encap_id, egr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(egr) BCM_API_XLATE_PORT_P2A(unit,&egr->dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_egress_get", 3, 2, unit, encap_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_egress_traverse( \
    int unit, bcm_l2_egress_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_egress_traverse,
static int (*_l2_egress_traverse_dispatch[])(
    int unit, 
    bcm_l2_egress_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_egress_traverse(
    int unit, 
    bcm_l2_egress_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_egress_traverse_dispatch[dtype](unit, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_egress_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_gport_forward_info_get( \
    int unit, int gport_id, bcm_l2_gport_forward_info_t *forward_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_gport_forward_info_get,
static int (*_l2_gport_forward_info_get_dispatch[])(
    int unit, 
    int gport_id, 
    bcm_l2_gport_forward_info_t *forward_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_gport_forward_info_get(
    int unit, 
    int gport_id, 
    bcm_l2_gport_forward_info_t *forward_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_gport_forward_info_get_dispatch[dtype](unit, gport_id, forward_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_gport_forward_info_get", 3, 2, unit, gport_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_init,
static int (*_l2_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_key_dump( \
    int unit, char *pfx, bcm_l2_addr_t *entry, char *sfx);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_key_dump,
static int (*_l2_key_dump_dispatch[])(
    int unit, 
    char *pfx, 
    bcm_l2_addr_t *entry, 
    char *sfx) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_key_dump(
    int unit, 
    char *pfx, 
    bcm_l2_addr_t *entry, 
    char *sfx)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(entry_block_bitmap);
		BCM_API_XLATE_PORT_COND(entry) BCM_API_XLATE_PORT_PBMP_SAVE(entry_block_bitmap,entry->block_bitmap);
		BCM_API_XLATE_PORT_COND(entry) BCM_API_XLATE_PORT_PBMP_A2P(unit,&entry->block_bitmap);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_key_dump_dispatch[dtype](unit, pfx, entry, sfx);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(entry) BCM_API_XLATE_PORT_PBMP_RESTORE(entry->block_bitmap,entry_block_bitmap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_key_dump", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_learn_class_get( \
    int unit, int lclass, int *lclass_prio, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_learn_class_get,
static int (*_l2_learn_class_get_dispatch[])(
    int unit, 
    int lclass, 
    int *lclass_prio, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_learn_class_get(
    int unit, 
    int lclass, 
    int *lclass_prio, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_learn_class_get_dispatch[dtype](unit, lclass, lclass_prio, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_learn_class_get", 4, 2, unit, lclass, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_learn_class_set( \
    int unit, int lclass, int lclass_prio, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_learn_class_set,
static int (*_l2_learn_class_set_dispatch[])(
    int unit, 
    int lclass, 
    int lclass_prio, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_learn_class_set(
    int unit, 
    int lclass, 
    int lclass_prio, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_learn_class_set_dispatch[dtype](unit, lclass, lclass_prio, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_learn_class_set", 4, 3, unit, lclass, lclass_prio, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_learn_limit_get( \
    int unit, bcm_l2_learn_limit_t *limit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_learn_limit_get,
static int (*_l2_learn_limit_get_dispatch[])(
    int unit, 
    bcm_l2_learn_limit_t *limit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_learn_limit_get(
    int unit, 
    bcm_l2_learn_limit_t *limit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(limit) BCM_API_XLATE_PORT_A2P(unit,&limit->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_learn_limit_get_dispatch[dtype](unit, limit);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(limit) BCM_API_XLATE_PORT_P2A(unit,&limit->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_learn_limit_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_learn_limit_set( \
    int unit, bcm_l2_learn_limit_t *limit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_learn_limit_set,
static int (*_l2_learn_limit_set_dispatch[])(
    int unit, 
    bcm_l2_learn_limit_t *limit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_learn_limit_set(
    int unit, 
    bcm_l2_learn_limit_t *limit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(limit_port);
		BCM_API_XLATE_PORT_COND(limit) BCM_API_XLATE_PORT_SAVE(limit_port,limit->port);
		BCM_API_XLATE_PORT_COND(limit) BCM_API_XLATE_PORT_A2P(unit,&limit->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_learn_limit_set_dispatch[dtype](unit, limit);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(limit) BCM_API_XLATE_PORT_RESTORE(limit->port,limit_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_learn_limit_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_learn_msgs_config_get( \
    int unit, bcm_l2_learn_msgs_config_t *learn_msg_config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_learn_msgs_config_get,
static int (*_l2_learn_msgs_config_get_dispatch[])(
    int unit, 
    bcm_l2_learn_msgs_config_t *learn_msg_config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_learn_msgs_config_get(
    int unit, 
    bcm_l2_learn_msgs_config_t *learn_msg_config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(learn_msg_config) BCM_API_XLATE_PORT_A2P(unit,&learn_msg_config->dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_learn_msgs_config_get_dispatch[dtype](unit, learn_msg_config);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(learn_msg_config) BCM_API_XLATE_PORT_P2A(unit,&learn_msg_config->dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_learn_msgs_config_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_learn_msgs_config_set( \
    int unit, bcm_l2_learn_msgs_config_t *learn_msg_config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_learn_msgs_config_set,
static int (*_l2_learn_msgs_config_set_dispatch[])(
    int unit, 
    bcm_l2_learn_msgs_config_t *learn_msg_config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_learn_msgs_config_set(
    int unit, 
    bcm_l2_learn_msgs_config_t *learn_msg_config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(learn_msg_config_dest_port);
		BCM_API_XLATE_PORT_COND(learn_msg_config) BCM_API_XLATE_PORT_SAVE(learn_msg_config_dest_port,learn_msg_config->dest_port);
		BCM_API_XLATE_PORT_COND(learn_msg_config) BCM_API_XLATE_PORT_A2P(unit,&learn_msg_config->dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_learn_msgs_config_set_dispatch[dtype](unit, learn_msg_config);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(learn_msg_config) BCM_API_XLATE_PORT_RESTORE(learn_msg_config->dest_port,learn_msg_config_dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_learn_msgs_config_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_learn_port_class_get( \
    int unit, bcm_gport_t port, int *lclass);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_learn_port_class_get,
static int (*_l2_learn_port_class_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int *lclass) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_learn_port_class_get(
    int unit, 
    bcm_gport_t port, 
    int *lclass)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_learn_port_class_get_dispatch[dtype](unit, port, lclass);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_learn_port_class_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_learn_port_class_set( \
    int unit, bcm_gport_t port, int lclass);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_learn_port_class_set,
static int (*_l2_learn_port_class_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int lclass) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_learn_port_class_set(
    int unit, 
    bcm_gport_t port, 
    int lclass)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_learn_port_class_set_dispatch[dtype](unit, port, lclass);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_learn_port_class_set", 3, 3, unit, port, lclass, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_mac_port_create( \
    int unit, bcm_l2_mac_port_t *mac_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_mac_port_create,
static int (*_l2_mac_port_create_dispatch[])(
    int unit, 
    bcm_l2_mac_port_t *mac_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_mac_port_create(
    int unit, 
    bcm_l2_mac_port_t *mac_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(mac_port) BCM_API_XLATE_PORT_A2P(unit,&mac_port->mac_port_id);
		BCM_API_XLATE_PORT_COND(mac_port) BCM_API_XLATE_PORT_A2P(unit,&mac_port->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_mac_port_create_dispatch[dtype](unit, mac_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(mac_port) BCM_API_XLATE_PORT_P2A(unit,&mac_port->mac_port_id);
		BCM_API_XLATE_PORT_COND(mac_port) BCM_API_XLATE_PORT_P2A(unit,&mac_port->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_mac_port_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_mac_port_destroy( \
    int unit, bcm_gport_t mac_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_mac_port_destroy,
static int (*_l2_mac_port_destroy_dispatch[])(
    int unit, 
    bcm_gport_t mac_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_mac_port_destroy(
    int unit, 
    bcm_gport_t mac_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mac_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_mac_port_destroy_dispatch[dtype](unit, mac_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_mac_port_destroy", 2, 2, unit, mac_port_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_mac_port_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_mac_port_destroy_all,
static int (*_l2_mac_port_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_mac_port_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_mac_port_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_mac_port_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_mac_port_get( \
    int unit, bcm_l2_mac_port_t *mac_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_mac_port_get,
static int (*_l2_mac_port_get_dispatch[])(
    int unit, 
    bcm_l2_mac_port_t *mac_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_mac_port_get(
    int unit, 
    bcm_l2_mac_port_t *mac_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(mac_port) BCM_API_XLATE_PORT_A2P(unit,&mac_port->mac_port_id);
		BCM_API_XLATE_PORT_COND(mac_port) BCM_API_XLATE_PORT_A2P(unit,&mac_port->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_mac_port_get_dispatch[dtype](unit, mac_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(mac_port) BCM_API_XLATE_PORT_P2A(unit,&mac_port->mac_port_id);
		BCM_API_XLATE_PORT_COND(mac_port) BCM_API_XLATE_PORT_P2A(unit,&mac_port->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_mac_port_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_mac_port_traverse( \
    int unit, bcm_l2_mac_port_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_mac_port_traverse,
static int (*_l2_mac_port_traverse_dispatch[])(
    int unit, 
    bcm_l2_mac_port_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_mac_port_traverse(
    int unit, 
    bcm_l2_mac_port_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_mac_port_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_mac_port_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_match_masked_traverse( \
    int unit, uint32 flags, bcm_l2_addr_t *match_addr, bcm_l2_addr_t *mask_addr, bcm_l2_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_match_masked_traverse,
static int (*_l2_match_masked_traverse_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_l2_addr_t *match_addr, 
    bcm_l2_addr_t *mask_addr, 
    bcm_l2_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_match_masked_traverse(
    int unit, 
    uint32 flags, 
    bcm_l2_addr_t *match_addr, 
    bcm_l2_addr_t *mask_addr, 
    bcm_l2_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(match_addr_block_bitmap);
		BCM_API_XLATE_PORT_PBMP_DECL(mask_addr_block_bitmap);
		BCM_API_XLATE_PORT_COND(match_addr) BCM_API_XLATE_PORT_PBMP_SAVE(match_addr_block_bitmap,match_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(match_addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&match_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(mask_addr) BCM_API_XLATE_PORT_PBMP_SAVE(mask_addr_block_bitmap,mask_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(mask_addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&mask_addr->block_bitmap);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_match_masked_traverse_dispatch[dtype](unit, flags, match_addr, mask_addr, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(match_addr) BCM_API_XLATE_PORT_PBMP_RESTORE(match_addr->block_bitmap,match_addr_block_bitmap);
		BCM_API_XLATE_PORT_COND(mask_addr) BCM_API_XLATE_PORT_PBMP_RESTORE(mask_addr->block_bitmap,mask_addr_block_bitmap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_match_masked_traverse", 6, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_matched_traverse( \
    int unit, uint32 flags, bcm_l2_addr_t *match_addr, bcm_l2_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_matched_traverse,
static int (*_l2_matched_traverse_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_l2_addr_t *match_addr, 
    bcm_l2_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_matched_traverse(
    int unit, 
    uint32 flags, 
    bcm_l2_addr_t *match_addr, 
    bcm_l2_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(match_addr_block_bitmap);
		BCM_API_XLATE_PORT_COND(match_addr) BCM_API_XLATE_PORT_PBMP_SAVE(match_addr_block_bitmap,match_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(match_addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&match_addr->block_bitmap);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_matched_traverse_dispatch[dtype](unit, flags, match_addr, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(match_addr) BCM_API_XLATE_PORT_PBMP_RESTORE(match_addr->block_bitmap,match_addr_block_bitmap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_matched_traverse", 5, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_port_native( \
    int unit, int modid, int port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_port_native,
static int (*_l2_port_native_dispatch[])(
    int unit, 
    int modid, 
    int port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_port_native(
    int unit, 
    int modid, 
    int port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_port_native_dispatch[dtype](unit, modid, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_port_native", 3, 3, unit, modid, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_replace( \
    int unit, uint32 flags, bcm_l2_addr_t *match_addr, bcm_module_t new_module, bcm_port_t new_port, bcm_trunk_t new_trunk);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_replace,
static int (*_l2_replace_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_l2_addr_t *match_addr, 
    bcm_module_t new_module, 
    bcm_port_t new_port, 
    bcm_trunk_t new_trunk) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_replace(
    int unit, 
    uint32 flags, 
    bcm_l2_addr_t *match_addr, 
    bcm_module_t new_module, 
    bcm_port_t new_port, 
    bcm_trunk_t new_trunk)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(match_addr_block_bitmap);
		BCM_API_XLATE_PORT_COND(match_addr) BCM_API_XLATE_PORT_PBMP_SAVE(match_addr_block_bitmap,match_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(match_addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&match_addr->block_bitmap);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_replace_dispatch[dtype](unit, flags, match_addr, new_module, new_port, new_trunk);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(match_addr) BCM_API_XLATE_PORT_PBMP_RESTORE(match_addr->block_bitmap,match_addr_block_bitmap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_replace", 6, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_replace_match( \
    int unit, uint32 flags, bcm_l2_addr_t *match_addr, bcm_l2_addr_t *mask_addr, bcm_l2_addr_t *replace_addr, bcm_l2_addr_t *replace_mask_addr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_replace_match,
static int (*_l2_replace_match_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_l2_addr_t *match_addr, 
    bcm_l2_addr_t *mask_addr, 
    bcm_l2_addr_t *replace_addr, 
    bcm_l2_addr_t *replace_mask_addr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_replace_match(
    int unit, 
    uint32 flags, 
    bcm_l2_addr_t *match_addr, 
    bcm_l2_addr_t *mask_addr, 
    bcm_l2_addr_t *replace_addr, 
    bcm_l2_addr_t *replace_mask_addr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(match_addr_block_bitmap);
		BCM_API_XLATE_PORT_PBMP_DECL(mask_addr_block_bitmap);
		BCM_API_XLATE_PORT_PBMP_DECL(replace_addr_block_bitmap);
		BCM_API_XLATE_PORT_PBMP_DECL(replace_mask_addr_block_bitmap);
		BCM_API_XLATE_PORT_COND(match_addr) BCM_API_XLATE_PORT_PBMP_SAVE(match_addr_block_bitmap,match_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(match_addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&match_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(mask_addr) BCM_API_XLATE_PORT_PBMP_SAVE(mask_addr_block_bitmap,mask_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(mask_addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&mask_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(replace_addr) BCM_API_XLATE_PORT_PBMP_SAVE(replace_addr_block_bitmap,replace_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(replace_addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&replace_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(replace_mask_addr) BCM_API_XLATE_PORT_PBMP_SAVE(replace_mask_addr_block_bitmap,replace_mask_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(replace_mask_addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&replace_mask_addr->block_bitmap);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_replace_match_dispatch[dtype](unit, flags, match_addr, mask_addr, replace_addr, replace_mask_addr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(match_addr) BCM_API_XLATE_PORT_PBMP_RESTORE(match_addr->block_bitmap,match_addr_block_bitmap);
		BCM_API_XLATE_PORT_COND(mask_addr) BCM_API_XLATE_PORT_PBMP_RESTORE(mask_addr->block_bitmap,mask_addr_block_bitmap);
		BCM_API_XLATE_PORT_COND(replace_addr) BCM_API_XLATE_PORT_PBMP_RESTORE(replace_addr->block_bitmap,replace_addr_block_bitmap);
		BCM_API_XLATE_PORT_COND(replace_mask_addr) BCM_API_XLATE_PORT_PBMP_RESTORE(replace_mask_addr->block_bitmap,replace_mask_addr_block_bitmap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_replace_match", 6, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_ring_replace( \
    int unit, bcm_l2_ring_t *l2_ring);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_ring_replace,
static int (*_l2_ring_replace_dispatch[])(
    int unit, 
    bcm_l2_ring_t *l2_ring) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_ring_replace(
    int unit, 
    bcm_l2_ring_t *l2_ring)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(l2_ring_port0);
		BCM_API_XLATE_PORT_DECL(l2_ring_port1);
		BCM_API_XLATE_PORT_COND(l2_ring) BCM_API_XLATE_PORT_SAVE(l2_ring_port0,l2_ring->port0);
		BCM_API_XLATE_PORT_COND(l2_ring) BCM_API_XLATE_PORT_A2P(unit,&l2_ring->port0);
		BCM_API_XLATE_PORT_COND(l2_ring) BCM_API_XLATE_PORT_SAVE(l2_ring_port1,l2_ring->port1);
		BCM_API_XLATE_PORT_COND(l2_ring) BCM_API_XLATE_PORT_A2P(unit,&l2_ring->port1);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_ring_replace_dispatch[dtype](unit, l2_ring);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(l2_ring) BCM_API_XLATE_PORT_RESTORE(l2_ring->port0,l2_ring_port0);
		BCM_API_XLATE_PORT_COND(l2_ring) BCM_API_XLATE_PORT_RESTORE(l2_ring->port1,l2_ring_port1);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_ring_replace", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_stat_enable_set( \
    int unit, bcm_l2_addr_t *l2_addr, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_stat_enable_set,
static int (*_l2_stat_enable_set_dispatch[])(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_stat_enable_set(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(l2_addr_block_bitmap);
		BCM_API_XLATE_PORT_COND(l2_addr) BCM_API_XLATE_PORT_PBMP_SAVE(l2_addr_block_bitmap,l2_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(l2_addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&l2_addr->block_bitmap);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_stat_enable_set_dispatch[dtype](unit, l2_addr, enable);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(l2_addr) BCM_API_XLATE_PORT_PBMP_RESTORE(l2_addr->block_bitmap,l2_addr_block_bitmap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_stat_enable_set", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_stat_get( \
    int unit, bcm_l2_addr_t *l2_addr, bcm_l2_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_stat_get,
static int (*_l2_stat_get_dispatch[])(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_stat_get(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(l2_addr_block_bitmap);
		BCM_API_XLATE_PORT_COND(l2_addr) BCM_API_XLATE_PORT_PBMP_SAVE(l2_addr_block_bitmap,l2_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(l2_addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&l2_addr->block_bitmap);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_stat_get_dispatch[dtype](unit, l2_addr, stat, val);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(l2_addr) BCM_API_XLATE_PORT_PBMP_RESTORE(l2_addr->block_bitmap,l2_addr_block_bitmap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_stat_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_stat_get32( \
    int unit, bcm_l2_addr_t *l2_addr, bcm_l2_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_stat_get32,
static int (*_l2_stat_get32_dispatch[])(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_stat_get32(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(l2_addr_block_bitmap);
		BCM_API_XLATE_PORT_COND(l2_addr) BCM_API_XLATE_PORT_PBMP_SAVE(l2_addr_block_bitmap,l2_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(l2_addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&l2_addr->block_bitmap);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_stat_get32_dispatch[dtype](unit, l2_addr, stat, val);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(l2_addr) BCM_API_XLATE_PORT_PBMP_RESTORE(l2_addr->block_bitmap,l2_addr_block_bitmap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_stat_get32", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_stat_set( \
    int unit, bcm_l2_addr_t *l2_addr, bcm_l2_stat_t stat, uint64 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_stat_set,
static int (*_l2_stat_set_dispatch[])(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint64 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_stat_set(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint64 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(l2_addr_block_bitmap);
		BCM_API_XLATE_PORT_COND(l2_addr) BCM_API_XLATE_PORT_PBMP_SAVE(l2_addr_block_bitmap,l2_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(l2_addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&l2_addr->block_bitmap);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_stat_set_dispatch[dtype](unit, l2_addr, stat, val);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(l2_addr) BCM_API_XLATE_PORT_PBMP_RESTORE(l2_addr->block_bitmap,l2_addr_block_bitmap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_stat_set", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_stat_set32( \
    int unit, bcm_l2_addr_t *l2_addr, bcm_l2_stat_t stat, uint32 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_stat_set32,
static int (*_l2_stat_set32_dispatch[])(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint32 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_stat_set32(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint32 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(l2_addr_block_bitmap);
		BCM_API_XLATE_PORT_COND(l2_addr) BCM_API_XLATE_PORT_PBMP_SAVE(l2_addr_block_bitmap,l2_addr->block_bitmap);
		BCM_API_XLATE_PORT_COND(l2_addr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&l2_addr->block_bitmap);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_stat_set32_dispatch[dtype](unit, l2_addr, stat, val);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(l2_addr) BCM_API_XLATE_PORT_PBMP_RESTORE(l2_addr->block_bitmap,l2_addr_block_bitmap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_stat_set32", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_station_add( \
    int unit, int *station_id, bcm_l2_station_t *station);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_station_add,
static int (*_l2_station_add_dispatch[])(
    int unit, 
    int *station_id, 
    bcm_l2_station_t *station) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_station_add(
    int unit, 
    int *station_id, 
    bcm_l2_station_t *station)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(station_src_port);
		BCM_API_XLATE_PORT_COND(station) BCM_API_XLATE_PORT_SAVE(station_src_port,station->src_port);
		BCM_API_XLATE_PORT_COND(station) BCM_API_XLATE_PORT_A2P(unit,&station->src_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_station_add_dispatch[dtype](unit, station_id, station);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(station) BCM_API_XLATE_PORT_RESTORE(station->src_port,station_src_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_station_add", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_station_delete( \
    int unit, int station_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_station_delete,
static int (*_l2_station_delete_dispatch[])(
    int unit, 
    int station_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_station_delete(
    int unit, 
    int station_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_station_delete_dispatch[dtype](unit, station_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_station_delete", 2, 2, unit, station_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_station_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_station_delete_all,
static int (*_l2_station_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_station_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_station_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_station_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_station_get( \
    int unit, int station_id, bcm_l2_station_t *station);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_station_get,
static int (*_l2_station_get_dispatch[])(
    int unit, 
    int station_id, 
    bcm_l2_station_t *station) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_station_get(
    int unit, 
    int station_id, 
    bcm_l2_station_t *station)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_station_get_dispatch[dtype](unit, station_id, station);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(station) BCM_API_XLATE_PORT_P2A(unit,&station->src_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_station_get", 3, 2, unit, station_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_station_size_get( \
    int unit, int *size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_station_size_get,
static int (*_l2_station_size_get_dispatch[])(
    int unit, 
    int *size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_station_size_get(
    int unit, 
    int *size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_station_size_get_dispatch[dtype](unit, size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_station_size_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_traverse( \
    int unit, bcm_l2_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_traverse,
static int (*_l2_traverse_dispatch[])(
    int unit, 
    bcm_l2_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_traverse(
    int unit, 
    bcm_l2_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_traverse_dispatch[dtype](unit, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_tunnel_add( \
    int unit, bcm_mac_t mac, bcm_vlan_t vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_tunnel_add,
static int (*_l2_tunnel_add_dispatch[])(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_tunnel_add(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_tunnel_add_dispatch[dtype](unit, mac, vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_tunnel_add", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_tunnel_delete( \
    int unit, bcm_mac_t mac, bcm_vlan_t vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_tunnel_delete,
static int (*_l2_tunnel_delete_dispatch[])(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_tunnel_delete(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_tunnel_delete_dispatch[dtype](unit, mac, vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_tunnel_delete", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2_tunnel_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2_tunnel_delete_all,
static int (*_l2_tunnel_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2_tunnel_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2_tunnel_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2_tunnel_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_cleanup( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_cleanup,
static int (*_l2gre_cleanup_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_cleanup(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_cleanup_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_cleanup", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_init,
static int (*_l2gre_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_port_add( \
    int unit, bcm_vpn_t l2vpn, bcm_l2gre_port_t *l2gre_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_port_add,
static int (*_l2gre_port_add_dispatch[])(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_l2gre_port_t *l2gre_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_port_add(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_l2gre_port_t *l2gre_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_A2P(unit,&l2gre_port->egress_tunnel_id);
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_A2P(unit,&l2gre_port->l2gre_port_id);
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_A2P(unit,&l2gre_port->match_port);
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_A2P(unit,&l2gre_port->match_tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_port_add_dispatch[dtype](unit, l2vpn, l2gre_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_P2A(unit,&l2gre_port->egress_tunnel_id);
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_P2A(unit,&l2gre_port->l2gre_port_id);
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_P2A(unit,&l2gre_port->match_port);
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_P2A(unit,&l2gre_port->match_tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_port_add", 3, 2, unit, l2vpn, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_port_delete( \
    int unit, bcm_vpn_t l2vpn, bcm_gport_t l2gre_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_port_delete,
static int (*_l2gre_port_delete_dispatch[])(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_gport_t l2gre_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_port_delete(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_gport_t l2gre_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&l2gre_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_port_delete_dispatch[dtype](unit, l2vpn, l2gre_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_port_delete", 3, 3, unit, l2vpn, l2gre_port_id, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_port_delete_all( \
    int unit, bcm_vpn_t l2vpn);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_port_delete_all,
static int (*_l2gre_port_delete_all_dispatch[])(
    int unit, 
    bcm_vpn_t l2vpn) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_port_delete_all(
    int unit, 
    bcm_vpn_t l2vpn)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_port_delete_all_dispatch[dtype](unit, l2vpn);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_port_delete_all", 2, 2, unit, l2vpn, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_port_get( \
    int unit, bcm_vpn_t l2vpn, bcm_l2gre_port_t *l2gre_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_port_get,
static int (*_l2gre_port_get_dispatch[])(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_l2gre_port_t *l2gre_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_port_get(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_l2gre_port_t *l2gre_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_A2P(unit,&l2gre_port->egress_tunnel_id);
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_A2P(unit,&l2gre_port->l2gre_port_id);
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_A2P(unit,&l2gre_port->match_port);
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_A2P(unit,&l2gre_port->match_tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_port_get_dispatch[dtype](unit, l2vpn, l2gre_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_P2A(unit,&l2gre_port->egress_tunnel_id);
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_P2A(unit,&l2gre_port->l2gre_port_id);
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_P2A(unit,&l2gre_port->match_port);
		BCM_API_XLATE_PORT_COND(l2gre_port) BCM_API_XLATE_PORT_P2A(unit,&l2gre_port->match_tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_port_get", 3, 2, unit, l2vpn, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_port_get_all( \
    int unit, bcm_vpn_t l2vpn, int port_max, bcm_l2gre_port_t *port_array, int *port_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_port_get_all,
static int (*_l2gre_port_get_all_dispatch[])(
    int unit, 
    bcm_vpn_t l2vpn, 
    int port_max, 
    bcm_l2gre_port_t *port_array, 
    int *port_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_port_get_all(
    int unit, 
    bcm_vpn_t l2vpn, 
    int port_max, 
    bcm_l2gre_port_t *port_array, 
    int *port_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_port_get_all_dispatch[dtype](unit, l2vpn, port_max, port_array, port_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].egress_tunnel_id);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].l2gre_port_id);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].match_port);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].match_tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_port_get_all", 5, 3, unit, l2vpn, port_max, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_stat_attach( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_stat_attach,
static int (*_l2gre_stat_attach_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_stat_attach(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_stat_attach_dispatch[dtype](unit, port, vpn, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_stat_attach", 4, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_stat_counter_get( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, bcm_l2gre_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_stat_counter_get,
static int (*_l2gre_stat_counter_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_l2gre_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_stat_counter_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_l2gre_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_stat_counter_get_dispatch[dtype](unit, port, vpn, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_stat_counter_get", 7, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_stat_counter_set( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, bcm_l2gre_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_stat_counter_set,
static int (*_l2gre_stat_counter_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_l2gre_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_stat_counter_set(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_l2gre_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_stat_counter_set_dispatch[dtype](unit, port, vpn, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_stat_counter_set", 7, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_stat_counter_sync_get( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, bcm_l2gre_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_stat_counter_sync_get,
static int (*_l2gre_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_l2gre_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_stat_counter_sync_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_l2gre_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_stat_counter_sync_get_dispatch[dtype](unit, port, vpn, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_stat_counter_sync_get", 7, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_stat_detach( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_stat_detach,
static int (*_l2gre_stat_detach_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_stat_detach(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_stat_detach_dispatch[dtype](unit, port, vpn);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_stat_detach", 3, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_stat_id_get( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, bcm_l2gre_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_stat_id_get,
static int (*_l2gre_stat_id_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_l2gre_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_stat_id_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_l2gre_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_stat_id_get_dispatch[dtype](unit, port, vpn, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_stat_id_get", 5, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_stat_multi_get( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, int nstat, bcm_l2gre_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_stat_multi_get,
static int (*_l2gre_stat_multi_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_l2gre_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_stat_multi_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_l2gre_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_stat_multi_get_dispatch[dtype](unit, port, vpn, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_stat_multi_get", 6, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_stat_multi_get32( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, int nstat, bcm_l2gre_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_stat_multi_get32,
static int (*_l2gre_stat_multi_get32_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_l2gre_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_stat_multi_get32(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_l2gre_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_stat_multi_get32_dispatch[dtype](unit, port, vpn, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_stat_multi_get32", 6, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_stat_multi_set( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, int nstat, bcm_l2gre_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_stat_multi_set,
static int (*_l2gre_stat_multi_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_l2gre_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_stat_multi_set(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_l2gre_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_stat_multi_set_dispatch[dtype](unit, port, vpn, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_stat_multi_set", 6, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_stat_multi_set32( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, int nstat, bcm_l2gre_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_stat_multi_set32,
static int (*_l2gre_stat_multi_set32_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_l2gre_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_stat_multi_set32(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_l2gre_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_stat_multi_set32_dispatch[dtype](unit, port, vpn, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_stat_multi_set32", 6, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_tunnel_initiator_create( \
    int unit, bcm_tunnel_initiator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_tunnel_initiator_create,
static int (*_l2gre_tunnel_initiator_create_dispatch[])(
    int unit, 
    bcm_tunnel_initiator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_tunnel_initiator_create(
    int unit, 
    bcm_tunnel_initiator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_tunnel_initiator_create_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_tunnel_initiator_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_tunnel_initiator_destroy( \
    int unit, bcm_gport_t l2gre_tunnel_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_tunnel_initiator_destroy,
static int (*_l2gre_tunnel_initiator_destroy_dispatch[])(
    int unit, 
    bcm_gport_t l2gre_tunnel_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_tunnel_initiator_destroy(
    int unit, 
    bcm_gport_t l2gre_tunnel_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&l2gre_tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_tunnel_initiator_destroy_dispatch[dtype](unit, l2gre_tunnel_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_tunnel_initiator_destroy", 2, 2, unit, l2gre_tunnel_id, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_tunnel_initiator_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_tunnel_initiator_destroy_all,
static int (*_l2gre_tunnel_initiator_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_tunnel_initiator_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_tunnel_initiator_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_tunnel_initiator_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_tunnel_initiator_get( \
    int unit, bcm_tunnel_initiator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_tunnel_initiator_get,
static int (*_l2gre_tunnel_initiator_get_dispatch[])(
    int unit, 
    bcm_tunnel_initiator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_tunnel_initiator_get(
    int unit, 
    bcm_tunnel_initiator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_tunnel_initiator_get_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_tunnel_initiator_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_tunnel_initiator_traverse( \
    int unit, bcm_tunnel_initiator_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_tunnel_initiator_traverse,
static int (*_l2gre_tunnel_initiator_traverse_dispatch[])(
    int unit, 
    bcm_tunnel_initiator_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_tunnel_initiator_traverse(
    int unit, 
    bcm_tunnel_initiator_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_tunnel_initiator_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_tunnel_initiator_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_tunnel_terminator_create( \
    int unit, bcm_tunnel_terminator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_tunnel_terminator_create,
static int (*_l2gre_tunnel_terminator_create_dispatch[])(
    int unit, 
    bcm_tunnel_terminator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_tunnel_terminator_create(
    int unit, 
    bcm_tunnel_terminator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_A2P(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_tunnel_terminator_create_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_P2A(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_tunnel_terminator_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_tunnel_terminator_destroy( \
    int unit, bcm_gport_t l2gre_tunnel_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_tunnel_terminator_destroy,
static int (*_l2gre_tunnel_terminator_destroy_dispatch[])(
    int unit, 
    bcm_gport_t l2gre_tunnel_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_tunnel_terminator_destroy(
    int unit, 
    bcm_gport_t l2gre_tunnel_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&l2gre_tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_tunnel_terminator_destroy_dispatch[dtype](unit, l2gre_tunnel_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_tunnel_terminator_destroy", 2, 2, unit, l2gre_tunnel_id, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_tunnel_terminator_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_tunnel_terminator_destroy_all,
static int (*_l2gre_tunnel_terminator_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_tunnel_terminator_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_tunnel_terminator_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_tunnel_terminator_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_tunnel_terminator_get( \
    int unit, bcm_tunnel_terminator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_tunnel_terminator_get,
static int (*_l2gre_tunnel_terminator_get_dispatch[])(
    int unit, 
    bcm_tunnel_terminator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_tunnel_terminator_get(
    int unit, 
    bcm_tunnel_terminator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_A2P(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_tunnel_terminator_get_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_P2A(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_tunnel_terminator_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_tunnel_terminator_traverse( \
    int unit, bcm_tunnel_terminator_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_tunnel_terminator_traverse,
static int (*_l2gre_tunnel_terminator_traverse_dispatch[])(
    int unit, 
    bcm_tunnel_terminator_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_tunnel_terminator_traverse(
    int unit, 
    bcm_tunnel_terminator_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_tunnel_terminator_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_tunnel_terminator_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_tunnel_terminator_update( \
    int unit, bcm_tunnel_terminator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_tunnel_terminator_update,
static int (*_l2gre_tunnel_terminator_update_dispatch[])(
    int unit, 
    bcm_tunnel_terminator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_tunnel_terminator_update(
    int unit, 
    bcm_tunnel_terminator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_A2P(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_tunnel_terminator_update_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_P2A(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_tunnel_terminator_update", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_vpn_create( \
    int unit, bcm_l2gre_vpn_config_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_vpn_create,
static int (*_l2gre_vpn_create_dispatch[])(
    int unit, 
    bcm_l2gre_vpn_config_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_vpn_create(
    int unit, 
    bcm_l2gre_vpn_config_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_vpn_create_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_vpn_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_vpn_destroy( \
    int unit, bcm_vpn_t l2vpn);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_vpn_destroy,
static int (*_l2gre_vpn_destroy_dispatch[])(
    int unit, 
    bcm_vpn_t l2vpn) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_vpn_destroy(
    int unit, 
    bcm_vpn_t l2vpn)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_vpn_destroy_dispatch[dtype](unit, l2vpn);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_vpn_destroy", 2, 2, unit, l2vpn, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_vpn_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_vpn_destroy_all,
static int (*_l2gre_vpn_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_vpn_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_vpn_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_vpn_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_vpn_get( \
    int unit, bcm_vpn_t l2vpn, bcm_l2gre_vpn_config_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_vpn_get,
static int (*_l2gre_vpn_get_dispatch[])(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_l2gre_vpn_config_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_vpn_get(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_l2gre_vpn_config_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_vpn_get_dispatch[dtype](unit, l2vpn, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_vpn_get", 3, 2, unit, l2vpn, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l2gre_vpn_traverse( \
    int unit, bcm_l2gre_vpn_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l2gre_vpn_traverse,
static int (*_l2gre_vpn_traverse_dispatch[])(
    int unit, 
    bcm_l2gre_vpn_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l2gre_vpn_traverse(
    int unit, 
    bcm_l2gre_vpn_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l2gre_vpn_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l2gre_vpn_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_cleanup( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_cleanup,
static int (*_l3_cleanup_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_cleanup(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_cleanup_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_cleanup", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_create( \
    int unit, uint32 flags, bcm_l3_egress_t *egr, bcm_if_t *if_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_create,
static int (*_l3_egress_create_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_l3_egress_t *egr, 
    bcm_if_t *if_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_create(
    int unit, 
    uint32 flags, 
    bcm_l3_egress_t *egr, 
    bcm_if_t *if_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_create_dispatch[dtype](unit, flags, egr, if_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_create", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_destroy( \
    int unit, bcm_if_t intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_destroy,
static int (*_l3_egress_destroy_dispatch[])(
    int unit, 
    bcm_if_t intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_destroy(
    int unit, 
    bcm_if_t intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_destroy_dispatch[dtype](unit, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_destroy", 2, 2, unit, intf, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_ecmp_add( \
    int unit, bcm_l3_egress_ecmp_t *ecmp, bcm_if_t intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_ecmp_add,
static int (*_l3_egress_ecmp_add_dispatch[])(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp, 
    bcm_if_t intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_ecmp_add(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp, 
    bcm_if_t intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_ecmp_add_dispatch[dtype](unit, ecmp, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_ecmp_add", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_ecmp_create( \
    int unit, bcm_l3_egress_ecmp_t *ecmp, int intf_count, bcm_if_t *intf_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_ecmp_create,
static int (*_l3_egress_ecmp_create_dispatch[])(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp, 
    int intf_count, 
    bcm_if_t *intf_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_ecmp_create(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp, 
    int intf_count, 
    bcm_if_t *intf_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_ecmp_create_dispatch[dtype](unit, ecmp, intf_count, intf_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_ecmp_create", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_ecmp_delete( \
    int unit, bcm_l3_egress_ecmp_t *ecmp, bcm_if_t intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_ecmp_delete,
static int (*_l3_egress_ecmp_delete_dispatch[])(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp, 
    bcm_if_t intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_ecmp_delete(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp, 
    bcm_if_t intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_ecmp_delete_dispatch[dtype](unit, ecmp, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_ecmp_delete", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_ecmp_destroy( \
    int unit, bcm_l3_egress_ecmp_t *ecmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_ecmp_destroy,
static int (*_l3_egress_ecmp_destroy_dispatch[])(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_ecmp_destroy(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_ecmp_destroy_dispatch[dtype](unit, ecmp);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_ecmp_destroy", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_ecmp_ethertype_get( \
    int unit, uint32 *flags, int ethertype_max, int *ethertype_array, int *ethertype_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_ecmp_ethertype_get,
static int (*_l3_egress_ecmp_ethertype_get_dispatch[])(
    int unit, 
    uint32 *flags, 
    int ethertype_max, 
    int *ethertype_array, 
    int *ethertype_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_ecmp_ethertype_get(
    int unit, 
    uint32 *flags, 
    int ethertype_max, 
    int *ethertype_array, 
    int *ethertype_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_ecmp_ethertype_get_dispatch[dtype](unit, flags, ethertype_max, ethertype_array, ethertype_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_ecmp_ethertype_get", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_ecmp_ethertype_set( \
    int unit, uint32 flags, int ethertype_count, int *ethertype_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_ecmp_ethertype_set,
static int (*_l3_egress_ecmp_ethertype_set_dispatch[])(
    int unit, 
    uint32 flags, 
    int ethertype_count, 
    int *ethertype_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_ecmp_ethertype_set(
    int unit, 
    uint32 flags, 
    int ethertype_count, 
    int *ethertype_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_ecmp_ethertype_set_dispatch[dtype](unit, flags, ethertype_count, ethertype_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_ecmp_ethertype_set", 4, 3, unit, flags, ethertype_count, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_ecmp_find( \
    int unit, int intf_count, bcm_if_t *intf_array, bcm_l3_egress_ecmp_t *ecmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_ecmp_find,
static int (*_l3_egress_ecmp_find_dispatch[])(
    int unit, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_l3_egress_ecmp_t *ecmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_ecmp_find(
    int unit, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_l3_egress_ecmp_t *ecmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_ecmp_find_dispatch[dtype](unit, intf_count, intf_array, ecmp);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_ecmp_find", 4, 2, unit, intf_count, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_ecmp_get( \
    int unit, bcm_l3_egress_ecmp_t *ecmp, int intf_size, bcm_if_t *intf_array, int *intf_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_ecmp_get,
static int (*_l3_egress_ecmp_get_dispatch[])(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp, 
    int intf_size, 
    bcm_if_t *intf_array, 
    int *intf_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_ecmp_get(
    int unit, 
    bcm_l3_egress_ecmp_t *ecmp, 
    int intf_size, 
    bcm_if_t *intf_array, 
    int *intf_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_ecmp_get_dispatch[dtype](unit, ecmp, intf_size, intf_array, intf_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_ecmp_get", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_ecmp_member_status_get( \
    int unit, bcm_if_t intf, int *status);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_ecmp_member_status_get,
static int (*_l3_egress_ecmp_member_status_get_dispatch[])(
    int unit, 
    bcm_if_t intf, 
    int *status) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_ecmp_member_status_get(
    int unit, 
    bcm_if_t intf, 
    int *status)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_ecmp_member_status_get_dispatch[dtype](unit, intf, status);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_ecmp_member_status_get", 3, 2, unit, intf, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_ecmp_member_status_set( \
    int unit, bcm_if_t intf, int status);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_ecmp_member_status_set,
static int (*_l3_egress_ecmp_member_status_set_dispatch[])(
    int unit, 
    bcm_if_t intf, 
    int status) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_ecmp_member_status_set(
    int unit, 
    bcm_if_t intf, 
    int status)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_ecmp_member_status_set_dispatch[dtype](unit, intf, status);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_ecmp_member_status_set", 3, 3, unit, intf, status, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_ecmp_resilient_replace( \
    int unit, uint32 flags, bcm_l3_egress_ecmp_resilient_entry_t *match_entry, int *num_entries, bcm_l3_egress_ecmp_resilient_entry_t *replace_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_ecmp_resilient_replace,
static int (*_l3_egress_ecmp_resilient_replace_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_l3_egress_ecmp_resilient_entry_t *match_entry, 
    int *num_entries, 
    bcm_l3_egress_ecmp_resilient_entry_t *replace_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_ecmp_resilient_replace(
    int unit, 
    uint32 flags, 
    bcm_l3_egress_ecmp_resilient_entry_t *match_entry, 
    int *num_entries, 
    bcm_l3_egress_ecmp_resilient_entry_t *replace_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_ecmp_resilient_replace_dispatch[dtype](unit, flags, match_entry, num_entries, replace_entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_ecmp_resilient_replace", 5, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_ecmp_resilient_traverse( \
    int unit, uint32 flags, bcm_l3_egress_ecmp_resilient_entry_t *match_entry, bcm_l3_egress_ecmp_resilient_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_ecmp_resilient_traverse,
static int (*_l3_egress_ecmp_resilient_traverse_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_l3_egress_ecmp_resilient_entry_t *match_entry, 
    bcm_l3_egress_ecmp_resilient_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_ecmp_resilient_traverse(
    int unit, 
    uint32 flags, 
    bcm_l3_egress_ecmp_resilient_entry_t *match_entry, 
    bcm_l3_egress_ecmp_resilient_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_ecmp_resilient_traverse_dispatch[dtype](unit, flags, match_entry, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_ecmp_resilient_traverse", 5, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_ecmp_traverse( \
    int unit, bcm_l3_egress_ecmp_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_ecmp_traverse,
static int (*_l3_egress_ecmp_traverse_dispatch[])(
    int unit, 
    bcm_l3_egress_ecmp_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_ecmp_traverse(
    int unit, 
    bcm_l3_egress_ecmp_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_ecmp_traverse_dispatch[dtype](unit, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_ecmp_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_find( \
    int unit, bcm_l3_egress_t *egr, bcm_if_t *intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_find,
static int (*_l3_egress_find_dispatch[])(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_if_t *intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_find(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_if_t *intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_find_dispatch[dtype](unit, egr, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_find", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_get( \
    int unit, bcm_if_t intf, bcm_l3_egress_t *egr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_get,
static int (*_l3_egress_get_dispatch[])(
    int unit, 
    bcm_if_t intf, 
    bcm_l3_egress_t *egr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_get(
    int unit, 
    bcm_if_t intf, 
    bcm_l3_egress_t *egr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_get_dispatch[dtype](unit, intf, egr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_get", 3, 2, unit, intf, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_multipath_add( \
    int unit, bcm_if_t mpintf, bcm_if_t intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_multipath_add,
static int (*_l3_egress_multipath_add_dispatch[])(
    int unit, 
    bcm_if_t mpintf, 
    bcm_if_t intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_multipath_add(
    int unit, 
    bcm_if_t mpintf, 
    bcm_if_t intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_multipath_add_dispatch[dtype](unit, mpintf, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_multipath_add", 3, 3, unit, mpintf, intf, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_multipath_create( \
    int unit, uint32 flags, int intf_count, bcm_if_t *intf_array, bcm_if_t *mpintf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_multipath_create,
static int (*_l3_egress_multipath_create_dispatch[])(
    int unit, 
    uint32 flags, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_if_t *mpintf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_multipath_create(
    int unit, 
    uint32 flags, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_if_t *mpintf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_multipath_create_dispatch[dtype](unit, flags, intf_count, intf_array, mpintf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_multipath_create", 5, 3, unit, flags, intf_count, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_multipath_delete( \
    int unit, bcm_if_t mpintf, bcm_if_t intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_multipath_delete,
static int (*_l3_egress_multipath_delete_dispatch[])(
    int unit, 
    bcm_if_t mpintf, 
    bcm_if_t intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_multipath_delete(
    int unit, 
    bcm_if_t mpintf, 
    bcm_if_t intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_multipath_delete_dispatch[dtype](unit, mpintf, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_multipath_delete", 3, 3, unit, mpintf, intf, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_multipath_destroy( \
    int unit, bcm_if_t mpintf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_multipath_destroy,
static int (*_l3_egress_multipath_destroy_dispatch[])(
    int unit, 
    bcm_if_t mpintf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_multipath_destroy(
    int unit, 
    bcm_if_t mpintf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_multipath_destroy_dispatch[dtype](unit, mpintf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_multipath_destroy", 2, 2, unit, mpintf, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_multipath_find( \
    int unit, int intf_count, bcm_if_t *intf_array, bcm_if_t *mpintf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_multipath_find,
static int (*_l3_egress_multipath_find_dispatch[])(
    int unit, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_if_t *mpintf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_multipath_find(
    int unit, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_if_t *mpintf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_multipath_find_dispatch[dtype](unit, intf_count, intf_array, mpintf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_multipath_find", 4, 2, unit, intf_count, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_multipath_get( \
    int unit, bcm_if_t mpintf, int intf_size, bcm_if_t *intf_array, int *intf_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_multipath_get,
static int (*_l3_egress_multipath_get_dispatch[])(
    int unit, 
    bcm_if_t mpintf, 
    int intf_size, 
    bcm_if_t *intf_array, 
    int *intf_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_multipath_get(
    int unit, 
    bcm_if_t mpintf, 
    int intf_size, 
    bcm_if_t *intf_array, 
    int *intf_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_multipath_get_dispatch[dtype](unit, mpintf, intf_size, intf_array, intf_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_multipath_get", 5, 3, unit, mpintf, intf_size, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_multipath_max_create( \
    int unit, uint32 flags, int max_paths, int intf_count, bcm_if_t *intf_array, bcm_if_t *mpintf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_multipath_max_create,
static int (*_l3_egress_multipath_max_create_dispatch[])(
    int unit, 
    uint32 flags, 
    int max_paths, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_if_t *mpintf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_multipath_max_create(
    int unit, 
    uint32 flags, 
    int max_paths, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_if_t *mpintf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_multipath_max_create_dispatch[dtype](unit, flags, max_paths, intf_count, intf_array, mpintf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_multipath_max_create", 6, 3, unit, flags, max_paths, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_multipath_traverse( \
    int unit, bcm_l3_egress_multipath_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_multipath_traverse,
static int (*_l3_egress_multipath_traverse_dispatch[])(
    int unit, 
    bcm_l3_egress_multipath_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_multipath_traverse(
    int unit, 
    bcm_l3_egress_multipath_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_multipath_traverse_dispatch[dtype](unit, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_multipath_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_stat_attach( \
    int unit, bcm_if_t intf_id, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_stat_attach,
static int (*_l3_egress_stat_attach_dispatch[])(
    int unit, 
    bcm_if_t intf_id, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_stat_attach(
    int unit, 
    bcm_if_t intf_id, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_stat_attach_dispatch[dtype](unit, intf_id, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_stat_attach", 3, 3, unit, intf_id, stat_counter_id, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_stat_counter_get( \
    int unit, bcm_if_t intf_id, bcm_l3_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_stat_counter_get,
static int (*_l3_egress_stat_counter_get_dispatch[])(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_stat_counter_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_stat_counter_get_dispatch[dtype](unit, intf_id, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_stat_counter_get", 6, 3, unit, intf_id, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_stat_counter_set( \
    int unit, bcm_if_t intf_id, bcm_l3_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_stat_counter_set,
static int (*_l3_egress_stat_counter_set_dispatch[])(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_stat_counter_set(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_stat_counter_set_dispatch[dtype](unit, intf_id, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_stat_counter_set", 6, 3, unit, intf_id, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_stat_counter_sync_get( \
    int unit, bcm_if_t intf_id, bcm_l3_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_stat_counter_sync_get,
static int (*_l3_egress_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_stat_counter_sync_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_stat_counter_sync_get_dispatch[dtype](unit, intf_id, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_stat_counter_sync_get", 6, 3, unit, intf_id, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_stat_detach( \
    int unit, bcm_if_t intf_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_stat_detach,
static int (*_l3_egress_stat_detach_dispatch[])(
    int unit, 
    bcm_if_t intf_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_stat_detach(
    int unit, 
    bcm_if_t intf_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_stat_detach_dispatch[dtype](unit, intf_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_stat_detach", 2, 2, unit, intf_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_stat_enable_set( \
    int unit, bcm_l3_egress_t *egr, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_stat_enable_set,
static int (*_l3_egress_stat_enable_set_dispatch[])(
    int unit, 
    bcm_l3_egress_t *egr, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_stat_enable_set(
    int unit, 
    bcm_l3_egress_t *egr, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_stat_enable_set_dispatch[dtype](unit, egr, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_stat_enable_set", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_stat_get( \
    int unit, bcm_l3_egress_t *egr, bcm_l3_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_stat_get,
static int (*_l3_egress_stat_get_dispatch[])(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_stat_get(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_stat_get_dispatch[dtype](unit, egr, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_stat_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_stat_get32( \
    int unit, bcm_l3_egress_t *egr, bcm_l3_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_stat_get32,
static int (*_l3_egress_stat_get32_dispatch[])(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_stat_get32(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_stat_get32_dispatch[dtype](unit, egr, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_stat_get32", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_stat_id_get( \
    int unit, bcm_if_t intf_id, bcm_l3_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_stat_id_get,
static int (*_l3_egress_stat_id_get_dispatch[])(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_stat_id_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_stat_id_get_dispatch[dtype](unit, intf_id, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_stat_id_get", 4, 3, unit, intf_id, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_stat_set( \
    int unit, bcm_l3_egress_t *egr, bcm_l3_stat_t stat, uint64 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_stat_set,
static int (*_l3_egress_stat_set_dispatch[])(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint64 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_stat_set(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint64 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_stat_set_dispatch[dtype](unit, egr, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_stat_set", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_stat_set32( \
    int unit, bcm_l3_egress_t *egr, bcm_l3_stat_t stat, uint32 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_stat_set32,
static int (*_l3_egress_stat_set32_dispatch[])(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint32 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_stat_set32(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint32 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_stat_set32_dispatch[dtype](unit, egr, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_stat_set32", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_egress_traverse( \
    int unit, bcm_l3_egress_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_egress_traverse,
static int (*_l3_egress_traverse_dispatch[])(
    int unit, 
    bcm_l3_egress_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_egress_traverse(
    int unit, 
    bcm_l3_egress_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_egress_traverse_dispatch[dtype](unit, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_egress_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_enable_set( \
    int unit, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_enable_set,
static int (*_l3_enable_set_dispatch[])(
    int unit, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_enable_set(
    int unit, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_enable_set_dispatch[dtype](unit, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_enable_set", 2, 2, unit, enable, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_add( \
    int unit, bcm_l3_host_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_add,
static int (*_l3_host_add_dispatch[])(
    int unit, 
    bcm_l3_host_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_add(
    int unit, 
    bcm_l3_host_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_add_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_age( \
    int unit, uint32 flags, bcm_l3_host_traverse_cb age_cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_age,
static int (*_l3_host_age_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_l3_host_traverse_cb age_cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_age(
    int unit, 
    uint32 flags, 
    bcm_l3_host_traverse_cb age_cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_age_dispatch[dtype](unit, flags, age_cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_age", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_conflict_get( \
    int unit, bcm_l3_key_t *ipkey, bcm_l3_key_t *cf_array, int cf_max, int *cf_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_conflict_get,
static int (*_l3_host_conflict_get_dispatch[])(
    int unit, 
    bcm_l3_key_t *ipkey, 
    bcm_l3_key_t *cf_array, 
    int cf_max, 
    int *cf_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_conflict_get(
    int unit, 
    bcm_l3_key_t *ipkey, 
    bcm_l3_key_t *cf_array, 
    int cf_max, 
    int *cf_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_conflict_get_dispatch[dtype](unit, ipkey, cf_array, cf_max, cf_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_conflict_get", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_delete( \
    int unit, bcm_l3_host_t *ip_addr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_delete,
static int (*_l3_host_delete_dispatch[])(
    int unit, 
    bcm_l3_host_t *ip_addr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_delete(
    int unit, 
    bcm_l3_host_t *ip_addr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(ip_addr_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(ip_addr) BCM_API_XLATE_PORT_SAVE(ip_addr_l3a_stack_port,ip_addr->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(ip_addr) BCM_API_XLATE_PORT_A2P(unit,&ip_addr->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_delete_dispatch[dtype](unit, ip_addr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(ip_addr) BCM_API_XLATE_PORT_RESTORE(ip_addr->l3a_stack_port,ip_addr_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_delete_all( \
    int unit, bcm_l3_host_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_delete_all,
static int (*_l3_host_delete_all_dispatch[])(
    int unit, 
    bcm_l3_host_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_delete_all(
    int unit, 
    bcm_l3_host_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_delete_all_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_delete_all", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_delete_by_interface( \
    int unit, bcm_l3_host_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_delete_by_interface,
static int (*_l3_host_delete_by_interface_dispatch[])(
    int unit, 
    bcm_l3_host_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_delete_by_interface(
    int unit, 
    bcm_l3_host_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_delete_by_interface_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_delete_by_interface", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_delete_by_network( \
    int unit, bcm_l3_route_t *ip_addr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_delete_by_network,
static int (*_l3_host_delete_by_network_dispatch[])(
    int unit, 
    bcm_l3_route_t *ip_addr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_delete_by_network(
    int unit, 
    bcm_l3_route_t *ip_addr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(ip_addr_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(ip_addr) BCM_API_XLATE_PORT_SAVE(ip_addr_l3a_stack_port,ip_addr->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(ip_addr) BCM_API_XLATE_PORT_A2P(unit,&ip_addr->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_delete_by_network_dispatch[dtype](unit, ip_addr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(ip_addr) BCM_API_XLATE_PORT_RESTORE(ip_addr->l3a_stack_port,ip_addr_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_delete_by_network", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_find( \
    int unit, bcm_l3_host_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_find,
static int (*_l3_host_find_dispatch[])(
    int unit, 
    bcm_l3_host_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_find(
    int unit, 
    bcm_l3_host_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_find_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_find", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_invalidate_entry( \
    int unit, bcm_ip_t info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_invalidate_entry,
static int (*_l3_host_invalidate_entry_dispatch[])(
    int unit, 
    bcm_ip_t info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_invalidate_entry(
    int unit, 
    bcm_ip_t info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_invalidate_entry_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_invalidate_entry", 2, 2, unit, info, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_stat_attach( \
    int unit, bcm_l3_host_t *info, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_stat_attach,
static int (*_l3_host_stat_attach_dispatch[])(
    int unit, 
    bcm_l3_host_t *info, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_stat_attach(
    int unit, 
    bcm_l3_host_t *info, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_stat_attach_dispatch[dtype](unit, info, stat_counter_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_stat_attach", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_stat_counter_get( \
    int unit, bcm_l3_host_t *info, bcm_l3_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_stat_counter_get,
static int (*_l3_host_stat_counter_get_dispatch[])(
    int unit, 
    bcm_l3_host_t *info, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_stat_counter_get(
    int unit, 
    bcm_l3_host_t *info, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_stat_counter_get_dispatch[dtype](unit, info, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_stat_counter_get", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_stat_counter_set( \
    int unit, bcm_l3_host_t *info, bcm_l3_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_stat_counter_set,
static int (*_l3_host_stat_counter_set_dispatch[])(
    int unit, 
    bcm_l3_host_t *info, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_stat_counter_set(
    int unit, 
    bcm_l3_host_t *info, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_stat_counter_set_dispatch[dtype](unit, info, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_stat_counter_set", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_stat_counter_sync_get( \
    int unit, bcm_l3_host_t *info, bcm_l3_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_stat_counter_sync_get,
static int (*_l3_host_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_l3_host_t *info, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_stat_counter_sync_get(
    int unit, 
    bcm_l3_host_t *info, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_stat_counter_sync_get_dispatch[dtype](unit, info, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_stat_counter_sync_get", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_stat_detach( \
    int unit, bcm_l3_host_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_stat_detach,
static int (*_l3_host_stat_detach_dispatch[])(
    int unit, 
    bcm_l3_host_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_stat_detach(
    int unit, 
    bcm_l3_host_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_stat_detach_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_stat_detach", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_stat_enable_set( \
    int unit, bcm_l3_host_t *host, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_stat_enable_set,
static int (*_l3_host_stat_enable_set_dispatch[])(
    int unit, 
    bcm_l3_host_t *host, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_stat_enable_set(
    int unit, 
    bcm_l3_host_t *host, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(host_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_SAVE(host_l3a_stack_port,host->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_A2P(unit,&host->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_stat_enable_set_dispatch[dtype](unit, host, enable);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_RESTORE(host->l3a_stack_port,host_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_stat_enable_set", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_stat_get( \
    int unit, bcm_l3_host_t *host, bcm_l3_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_stat_get,
static int (*_l3_host_stat_get_dispatch[])(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_stat_get(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(host_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_SAVE(host_l3a_stack_port,host->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_A2P(unit,&host->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_stat_get_dispatch[dtype](unit, host, stat, val);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_RESTORE(host->l3a_stack_port,host_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_stat_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_stat_get32( \
    int unit, bcm_l3_host_t *host, bcm_l3_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_stat_get32,
static int (*_l3_host_stat_get32_dispatch[])(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_stat_get32(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(host_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_SAVE(host_l3a_stack_port,host->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_A2P(unit,&host->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_stat_get32_dispatch[dtype](unit, host, stat, val);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_RESTORE(host->l3a_stack_port,host_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_stat_get32", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_stat_id_get( \
    int unit, bcm_l3_host_t *info, bcm_l3_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_stat_id_get,
static int (*_l3_host_stat_id_get_dispatch[])(
    int unit, 
    bcm_l3_host_t *info, 
    bcm_l3_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_stat_id_get(
    int unit, 
    bcm_l3_host_t *info, 
    bcm_l3_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_stat_id_get_dispatch[dtype](unit, info, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_stat_id_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_stat_set( \
    int unit, bcm_l3_host_t *host, bcm_l3_stat_t stat, uint64 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_stat_set,
static int (*_l3_host_stat_set_dispatch[])(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint64 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_stat_set(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint64 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(host_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_SAVE(host_l3a_stack_port,host->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_A2P(unit,&host->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_stat_set_dispatch[dtype](unit, host, stat, val);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_RESTORE(host->l3a_stack_port,host_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_stat_set", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_stat_set32( \
    int unit, bcm_l3_host_t *host, bcm_l3_stat_t stat, uint32 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_stat_set32,
static int (*_l3_host_stat_set32_dispatch[])(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint32 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_stat_set32(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint32 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(host_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_SAVE(host_l3a_stack_port,host->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_A2P(unit,&host->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_stat_set32_dispatch[dtype](unit, host, stat, val);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_RESTORE(host->l3a_stack_port,host_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_stat_set32", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_traverse( \
    int unit, uint32 flags, uint32 start, uint32 end, bcm_l3_host_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_traverse,
static int (*_l3_host_traverse_dispatch[])(
    int unit, 
    uint32 flags, 
    uint32 start, 
    uint32 end, 
    bcm_l3_host_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_traverse(
    int unit, 
    uint32 flags, 
    uint32 start, 
    uint32 end, 
    bcm_l3_host_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_traverse_dispatch[dtype](unit, flags, start, end, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_traverse", 6, 3, unit, flags, start, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_host_validate_entry( \
    int unit, bcm_ip_t info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_host_validate_entry,
static int (*_l3_host_validate_entry_dispatch[])(
    int unit, 
    bcm_ip_t info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_host_validate_entry(
    int unit, 
    bcm_ip_t info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_host_validate_entry_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_host_validate_entry", 2, 2, unit, info, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_info( \
    int unit, bcm_l3_info_t *l3info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_info,
static int (*_l3_info_dispatch[])(
    int unit, 
    bcm_l3_info_t *l3info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_info(
    int unit, 
    bcm_l3_info_t *l3info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_info_dispatch[dtype](unit, l3info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_info", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ingress_create( \
    int unit, bcm_l3_ingress_t *ing_intf, bcm_if_t *intf_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ingress_create,
static int (*_l3_ingress_create_dispatch[])(
    int unit, 
    bcm_l3_ingress_t *ing_intf, 
    bcm_if_t *intf_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ingress_create(
    int unit, 
    bcm_l3_ingress_t *ing_intf, 
    bcm_if_t *intf_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ingress_create_dispatch[dtype](unit, ing_intf, intf_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ingress_create", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ingress_destroy( \
    int unit, bcm_if_t intf_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ingress_destroy,
static int (*_l3_ingress_destroy_dispatch[])(
    int unit, 
    bcm_if_t intf_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ingress_destroy(
    int unit, 
    bcm_if_t intf_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ingress_destroy_dispatch[dtype](unit, intf_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ingress_destroy", 2, 2, unit, intf_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ingress_find( \
    int unit, bcm_l3_ingress_t *ing_intf, bcm_if_t *intf_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ingress_find,
static int (*_l3_ingress_find_dispatch[])(
    int unit, 
    bcm_l3_ingress_t *ing_intf, 
    bcm_if_t *intf_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ingress_find(
    int unit, 
    bcm_l3_ingress_t *ing_intf, 
    bcm_if_t *intf_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ingress_find_dispatch[dtype](unit, ing_intf, intf_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ingress_find", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ingress_get( \
    int unit, bcm_if_t intf, bcm_l3_ingress_t *ing_intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ingress_get,
static int (*_l3_ingress_get_dispatch[])(
    int unit, 
    bcm_if_t intf, 
    bcm_l3_ingress_t *ing_intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ingress_get(
    int unit, 
    bcm_if_t intf, 
    bcm_l3_ingress_t *ing_intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ingress_get_dispatch[dtype](unit, intf, ing_intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ingress_get", 3, 2, unit, intf, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ingress_stat_attach( \
    int unit, bcm_if_t intf_id, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ingress_stat_attach,
static int (*_l3_ingress_stat_attach_dispatch[])(
    int unit, 
    bcm_if_t intf_id, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ingress_stat_attach(
    int unit, 
    bcm_if_t intf_id, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ingress_stat_attach_dispatch[dtype](unit, intf_id, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ingress_stat_attach", 3, 3, unit, intf_id, stat_counter_id, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ingress_stat_counter_get( \
    int unit, bcm_if_t intf_id, bcm_l3_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ingress_stat_counter_get,
static int (*_l3_ingress_stat_counter_get_dispatch[])(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ingress_stat_counter_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ingress_stat_counter_get_dispatch[dtype](unit, intf_id, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ingress_stat_counter_get", 6, 3, unit, intf_id, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ingress_stat_counter_set( \
    int unit, bcm_if_t intf_id, bcm_l3_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ingress_stat_counter_set,
static int (*_l3_ingress_stat_counter_set_dispatch[])(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ingress_stat_counter_set(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ingress_stat_counter_set_dispatch[dtype](unit, intf_id, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ingress_stat_counter_set", 6, 3, unit, intf_id, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ingress_stat_counter_sync_get( \
    int unit, bcm_if_t intf_id, bcm_l3_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ingress_stat_counter_sync_get,
static int (*_l3_ingress_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ingress_stat_counter_sync_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ingress_stat_counter_sync_get_dispatch[dtype](unit, intf_id, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ingress_stat_counter_sync_get", 6, 3, unit, intf_id, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ingress_stat_detach( \
    int unit, bcm_if_t intf_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ingress_stat_detach,
static int (*_l3_ingress_stat_detach_dispatch[])(
    int unit, 
    bcm_if_t intf_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ingress_stat_detach(
    int unit, 
    bcm_if_t intf_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ingress_stat_detach_dispatch[dtype](unit, intf_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ingress_stat_detach", 2, 2, unit, intf_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ingress_stat_id_get( \
    int unit, bcm_if_t intf_id, bcm_l3_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ingress_stat_id_get,
static int (*_l3_ingress_stat_id_get_dispatch[])(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ingress_stat_id_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ingress_stat_id_get_dispatch[dtype](unit, intf_id, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ingress_stat_id_get", 4, 3, unit, intf_id, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ingress_traverse( \
    int unit, bcm_l3_ingress_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ingress_traverse,
static int (*_l3_ingress_traverse_dispatch[])(
    int unit, 
    bcm_l3_ingress_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ingress_traverse(
    int unit, 
    bcm_l3_ingress_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ingress_traverse_dispatch[dtype](unit, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ingress_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_init,
static int (*_l3_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_intf_create( \
    int unit, bcm_l3_intf_t *intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_intf_create,
static int (*_l3_intf_create_dispatch[])(
    int unit, 
    bcm_l3_intf_t *intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_intf_create(
    int unit, 
    bcm_l3_intf_t *intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_intf_create_dispatch[dtype](unit, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_intf_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_intf_delete( \
    int unit, bcm_l3_intf_t *intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_intf_delete,
static int (*_l3_intf_delete_dispatch[])(
    int unit, 
    bcm_l3_intf_t *intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_intf_delete(
    int unit, 
    bcm_l3_intf_t *intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_intf_delete_dispatch[dtype](unit, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_intf_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_intf_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_intf_delete_all,
static int (*_l3_intf_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_intf_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_intf_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_intf_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_intf_find( \
    int unit, bcm_l3_intf_t *intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_intf_find,
static int (*_l3_intf_find_dispatch[])(
    int unit, 
    bcm_l3_intf_t *intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_intf_find(
    int unit, 
    bcm_l3_intf_t *intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_intf_find_dispatch[dtype](unit, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_intf_find", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_intf_find_vlan( \
    int unit, bcm_l3_intf_t *intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_intf_find_vlan,
static int (*_l3_intf_find_vlan_dispatch[])(
    int unit, 
    bcm_l3_intf_t *intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_intf_find_vlan(
    int unit, 
    bcm_l3_intf_t *intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_intf_find_vlan_dispatch[dtype](unit, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_intf_find_vlan", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_intf_get( \
    int unit, bcm_l3_intf_t *intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_intf_get,
static int (*_l3_intf_get_dispatch[])(
    int unit, 
    bcm_l3_intf_t *intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_intf_get(
    int unit, 
    bcm_l3_intf_t *intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_intf_get_dispatch[dtype](unit, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_intf_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ip4_options_action_get( \
    int unit, int ip4_options_profile_id, int ip4_option, bcm_l3_ip4_options_action_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ip4_options_action_get,
static int (*_l3_ip4_options_action_get_dispatch[])(
    int unit, 
    int ip4_options_profile_id, 
    int ip4_option, 
    bcm_l3_ip4_options_action_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ip4_options_action_get(
    int unit, 
    int ip4_options_profile_id, 
    int ip4_option, 
    bcm_l3_ip4_options_action_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ip4_options_action_get_dispatch[dtype](unit, ip4_options_profile_id, ip4_option, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ip4_options_action_get", 4, 3, unit, ip4_options_profile_id, ip4_option, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ip4_options_action_set( \
    int unit, int ip4_options_profile_id, int ip4_option, bcm_l3_ip4_options_action_t action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ip4_options_action_set,
static int (*_l3_ip4_options_action_set_dispatch[])(
    int unit, 
    int ip4_options_profile_id, 
    int ip4_option, 
    bcm_l3_ip4_options_action_t action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ip4_options_action_set(
    int unit, 
    int ip4_options_profile_id, 
    int ip4_option, 
    bcm_l3_ip4_options_action_t action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ip4_options_action_set_dispatch[dtype](unit, ip4_options_profile_id, ip4_option, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ip4_options_action_set", 4, 3, unit, ip4_options_profile_id, ip4_option, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ip4_options_profile_create( \
    int unit, uint32 flags, bcm_l3_ip4_options_action_t default_action, int *ip4_options_profile_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ip4_options_profile_create,
static int (*_l3_ip4_options_profile_create_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_l3_ip4_options_action_t default_action, 
    int *ip4_options_profile_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ip4_options_profile_create(
    int unit, 
    uint32 flags, 
    bcm_l3_ip4_options_action_t default_action, 
    int *ip4_options_profile_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ip4_options_profile_create_dispatch[dtype](unit, flags, default_action, ip4_options_profile_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ip4_options_profile_create", 4, 3, unit, flags, default_action, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ip4_options_profile_destroy( \
    int unit, int ip4_options_profile_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ip4_options_profile_destroy,
static int (*_l3_ip4_options_profile_destroy_dispatch[])(
    int unit, 
    int ip4_options_profile_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ip4_options_profile_destroy(
    int unit, 
    int ip4_options_profile_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ip4_options_profile_destroy_dispatch[dtype](unit, ip4_options_profile_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ip4_options_profile_destroy", 2, 2, unit, ip4_options_profile_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ip6_prefix_map_add( \
    int unit, bcm_ip6_t ip6_addr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ip6_prefix_map_add,
static int (*_l3_ip6_prefix_map_add_dispatch[])(
    int unit, 
    bcm_ip6_t ip6_addr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ip6_prefix_map_add(
    int unit, 
    bcm_ip6_t ip6_addr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ip6_prefix_map_add_dispatch[dtype](unit, ip6_addr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ip6_prefix_map_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ip6_prefix_map_delete( \
    int unit, bcm_ip6_t ip6_addr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ip6_prefix_map_delete,
static int (*_l3_ip6_prefix_map_delete_dispatch[])(
    int unit, 
    bcm_ip6_t ip6_addr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ip6_prefix_map_delete(
    int unit, 
    bcm_ip6_t ip6_addr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ip6_prefix_map_delete_dispatch[dtype](unit, ip6_addr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ip6_prefix_map_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ip6_prefix_map_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ip6_prefix_map_delete_all,
static int (*_l3_ip6_prefix_map_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ip6_prefix_map_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ip6_prefix_map_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ip6_prefix_map_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_ip6_prefix_map_get( \
    int unit, int map_size, bcm_ip6_t *ip6_array, int *ip6_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_ip6_prefix_map_get,
static int (*_l3_ip6_prefix_map_get_dispatch[])(
    int unit, 
    int map_size, 
    bcm_ip6_t *ip6_array, 
    int *ip6_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_ip6_prefix_map_get(
    int unit, 
    int map_size, 
    bcm_ip6_t *ip6_array, 
    int *ip6_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_ip6_prefix_map_get_dispatch[dtype](unit, map_size, ip6_array, ip6_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_ip6_prefix_map_get", 4, 2, unit, map_size, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_egress_add( \
    int unit, bcm_l3_nat_egress_t *nat_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_egress_add,
static int (*_l3_nat_egress_add_dispatch[])(
    int unit, 
    bcm_l3_nat_egress_t *nat_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_egress_add(
    int unit, 
    bcm_l3_nat_egress_t *nat_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_egress_add_dispatch[dtype](unit, nat_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_egress_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_egress_delete( \
    int unit, bcm_l3_nat_id_t nat_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_egress_delete,
static int (*_l3_nat_egress_delete_dispatch[])(
    int unit, 
    bcm_l3_nat_id_t nat_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_egress_delete(
    int unit, 
    bcm_l3_nat_id_t nat_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_egress_delete_dispatch[dtype](unit, nat_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_egress_delete", 2, 2, unit, nat_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_egress_get( \
    int unit, bcm_l3_nat_egress_t *nat_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_egress_get,
static int (*_l3_nat_egress_get_dispatch[])(
    int unit, 
    bcm_l3_nat_egress_t *nat_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_egress_get(
    int unit, 
    bcm_l3_nat_egress_t *nat_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_egress_get_dispatch[dtype](unit, nat_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_egress_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_egress_stat_attach( \
    int unit, bcm_l3_nat_egress_t *info, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_egress_stat_attach,
static int (*_l3_nat_egress_stat_attach_dispatch[])(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_egress_stat_attach(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_egress_stat_attach_dispatch[dtype](unit, info, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_egress_stat_attach", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_egress_stat_counter_get( \
    int unit, bcm_l3_nat_egress_t *info, bcm_l3_nat_egress_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_egress_stat_counter_get,
static int (*_l3_nat_egress_stat_counter_get_dispatch[])(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    bcm_l3_nat_egress_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_egress_stat_counter_get(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    bcm_l3_nat_egress_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_egress_stat_counter_get_dispatch[dtype](unit, info, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_egress_stat_counter_get", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_egress_stat_counter_set( \
    int unit, bcm_l3_nat_egress_t *info, bcm_l3_nat_egress_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_egress_stat_counter_set,
static int (*_l3_nat_egress_stat_counter_set_dispatch[])(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    bcm_l3_nat_egress_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_egress_stat_counter_set(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    bcm_l3_nat_egress_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_egress_stat_counter_set_dispatch[dtype](unit, info, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_egress_stat_counter_set", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_egress_stat_counter_sync_get( \
    int unit, bcm_l3_nat_egress_t *info, bcm_l3_nat_egress_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_egress_stat_counter_sync_get,
static int (*_l3_nat_egress_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    bcm_l3_nat_egress_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_egress_stat_counter_sync_get(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    bcm_l3_nat_egress_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_egress_stat_counter_sync_get_dispatch[dtype](unit, info, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_egress_stat_counter_sync_get", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_egress_stat_detach( \
    int unit, bcm_l3_nat_egress_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_egress_stat_detach,
static int (*_l3_nat_egress_stat_detach_dispatch[])(
    int unit, 
    bcm_l3_nat_egress_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_egress_stat_detach(
    int unit, 
    bcm_l3_nat_egress_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_egress_stat_detach_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_egress_stat_detach", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_egress_stat_id_get( \
    int unit, bcm_l3_nat_egress_t *info, bcm_l3_nat_egress_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_egress_stat_id_get,
static int (*_l3_nat_egress_stat_id_get_dispatch[])(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    bcm_l3_nat_egress_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_egress_stat_id_get(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    bcm_l3_nat_egress_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_egress_stat_id_get_dispatch[dtype](unit, info, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_egress_stat_id_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_egress_stat_multi_get( \
    int unit, bcm_l3_nat_egress_t *info, int nstat, bcm_l3_nat_egress_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_egress_stat_multi_get,
static int (*_l3_nat_egress_stat_multi_get_dispatch[])(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    int nstat, 
    bcm_l3_nat_egress_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_egress_stat_multi_get(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    int nstat, 
    bcm_l3_nat_egress_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_egress_stat_multi_get_dispatch[dtype](unit, info, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_egress_stat_multi_get", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_egress_stat_multi_get32( \
    int unit, bcm_l3_nat_egress_t *info, int nstat, bcm_l3_nat_egress_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_egress_stat_multi_get32,
static int (*_l3_nat_egress_stat_multi_get32_dispatch[])(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    int nstat, 
    bcm_l3_nat_egress_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_egress_stat_multi_get32(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    int nstat, 
    bcm_l3_nat_egress_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_egress_stat_multi_get32_dispatch[dtype](unit, info, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_egress_stat_multi_get32", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_egress_stat_multi_set( \
    int unit, bcm_l3_nat_egress_t *info, int nstat, bcm_l3_nat_egress_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_egress_stat_multi_set,
static int (*_l3_nat_egress_stat_multi_set_dispatch[])(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    int nstat, 
    bcm_l3_nat_egress_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_egress_stat_multi_set(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    int nstat, 
    bcm_l3_nat_egress_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_egress_stat_multi_set_dispatch[dtype](unit, info, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_egress_stat_multi_set", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_egress_stat_multi_set32( \
    int unit, bcm_l3_nat_egress_t *info, int nstat, bcm_l3_nat_egress_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_egress_stat_multi_set32,
static int (*_l3_nat_egress_stat_multi_set32_dispatch[])(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    int nstat, 
    bcm_l3_nat_egress_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_egress_stat_multi_set32(
    int unit, 
    bcm_l3_nat_egress_t *info, 
    int nstat, 
    bcm_l3_nat_egress_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_egress_stat_multi_set32_dispatch[dtype](unit, info, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_egress_stat_multi_set32", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_egress_traverse( \
    int unit, uint32 flags, uint32 start, uint32 end, bcm_l3_nat_egress_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_egress_traverse,
static int (*_l3_nat_egress_traverse_dispatch[])(
    int unit, 
    uint32 flags, 
    uint32 start, 
    uint32 end, 
    bcm_l3_nat_egress_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_egress_traverse(
    int unit, 
    uint32 flags, 
    uint32 start, 
    uint32 end, 
    bcm_l3_nat_egress_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_egress_traverse_dispatch[dtype](unit, flags, start, end, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_egress_traverse", 6, 3, unit, flags, start, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_ingress_add( \
    int unit, bcm_l3_nat_ingress_t *nat_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_ingress_add,
static int (*_l3_nat_ingress_add_dispatch[])(
    int unit, 
    bcm_l3_nat_ingress_t *nat_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_ingress_add(
    int unit, 
    bcm_l3_nat_ingress_t *nat_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_ingress_add_dispatch[dtype](unit, nat_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_ingress_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_ingress_age( \
    int unit, uint32 flags, bcm_l3_nat_ingress_traverse_cb age_cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_ingress_age,
static int (*_l3_nat_ingress_age_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_l3_nat_ingress_traverse_cb age_cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_ingress_age(
    int unit, 
    uint32 flags, 
    bcm_l3_nat_ingress_traverse_cb age_cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_ingress_age_dispatch[dtype](unit, flags, age_cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_ingress_age", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_ingress_delete( \
    int unit, bcm_l3_nat_ingress_t *nat_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_ingress_delete,
static int (*_l3_nat_ingress_delete_dispatch[])(
    int unit, 
    bcm_l3_nat_ingress_t *nat_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_ingress_delete(
    int unit, 
    bcm_l3_nat_ingress_t *nat_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_ingress_delete_dispatch[dtype](unit, nat_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_ingress_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_ingress_delete_all( \
    int unit, bcm_l3_nat_ingress_t *nat_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_ingress_delete_all,
static int (*_l3_nat_ingress_delete_all_dispatch[])(
    int unit, 
    bcm_l3_nat_ingress_t *nat_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_ingress_delete_all(
    int unit, 
    bcm_l3_nat_ingress_t *nat_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_ingress_delete_all_dispatch[dtype](unit, nat_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_ingress_delete_all", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_ingress_find( \
    int unit, bcm_l3_nat_ingress_t *nat_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_ingress_find,
static int (*_l3_nat_ingress_find_dispatch[])(
    int unit, 
    bcm_l3_nat_ingress_t *nat_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_ingress_find(
    int unit, 
    bcm_l3_nat_ingress_t *nat_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_ingress_find_dispatch[dtype](unit, nat_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_ingress_find", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_nat_ingress_traverse( \
    int unit, uint32 flags, uint32 start, uint32 end, bcm_l3_nat_ingress_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_nat_ingress_traverse,
static int (*_l3_nat_ingress_traverse_dispatch[])(
    int unit, 
    uint32 flags, 
    uint32 start, 
    uint32 end, 
    bcm_l3_nat_ingress_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_nat_ingress_traverse(
    int unit, 
    uint32 flags, 
    uint32 start, 
    uint32 end, 
    bcm_l3_nat_ingress_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_nat_ingress_traverse_dispatch[dtype](unit, flags, start, end, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_nat_ingress_traverse", 6, 3, unit, flags, start, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_add( \
    int unit, bcm_l3_route_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_add,
static int (*_l3_route_add_dispatch[])(
    int unit, 
    bcm_l3_route_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_add(
    int unit, 
    bcm_l3_route_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_add_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_age( \
    int unit, uint32 flags, bcm_l3_route_traverse_cb age_out, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_age,
static int (*_l3_route_age_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_l3_route_traverse_cb age_out, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_age(
    int unit, 
    uint32 flags, 
    bcm_l3_route_traverse_cb age_out, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_age_dispatch[dtype](unit, flags, age_out, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_age", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_delete( \
    int unit, bcm_l3_route_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_delete,
static int (*_l3_route_delete_dispatch[])(
    int unit, 
    bcm_l3_route_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_delete(
    int unit, 
    bcm_l3_route_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_delete_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_delete_all( \
    int unit, bcm_l3_route_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_delete_all,
static int (*_l3_route_delete_all_dispatch[])(
    int unit, 
    bcm_l3_route_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_delete_all(
    int unit, 
    bcm_l3_route_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_delete_all_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_delete_all", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_delete_by_interface( \
    int unit, bcm_l3_route_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_delete_by_interface,
static int (*_l3_route_delete_by_interface_dispatch[])(
    int unit, 
    bcm_l3_route_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_delete_by_interface(
    int unit, 
    bcm_l3_route_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_delete_by_interface_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_delete_by_interface", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_find( \
    int unit, bcm_l3_host_t *host, bcm_l3_route_t *route);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_find,
static int (*_l3_route_find_dispatch[])(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_route_t *route) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_find(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_route_t *route)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(host_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_SAVE(host_l3a_stack_port,host->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_A2P(unit,&host->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_find_dispatch[dtype](unit, host, route);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(host) BCM_API_XLATE_PORT_RESTORE(host->l3a_stack_port,host_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_P2A(unit,&route->l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_find", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_get( \
    int unit, bcm_l3_route_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_get,
static int (*_l3_route_get_dispatch[])(
    int unit, 
    bcm_l3_route_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_get(
    int unit, 
    bcm_l3_route_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_get_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_max_ecmp_get( \
    int unit, int *max);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_max_ecmp_get,
static int (*_l3_route_max_ecmp_get_dispatch[])(
    int unit, 
    int *max) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_max_ecmp_get(
    int unit, 
    int *max)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_max_ecmp_get_dispatch[dtype](unit, max);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_max_ecmp_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_max_ecmp_set( \
    int unit, int max);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_max_ecmp_set,
static int (*_l3_route_max_ecmp_set_dispatch[])(
    int unit, 
    int max) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_max_ecmp_set(
    int unit, 
    int max)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_max_ecmp_set_dispatch[dtype](unit, max);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_max_ecmp_set", 2, 2, unit, max, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_multipath_get( \
    int unit, bcm_l3_route_t *the_route, bcm_l3_route_t *path_array, int max_path, int *path_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_multipath_get,
static int (*_l3_route_multipath_get_dispatch[])(
    int unit, 
    bcm_l3_route_t *the_route, 
    bcm_l3_route_t *path_array, 
    int max_path, 
    int *path_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_multipath_get(
    int unit, 
    bcm_l3_route_t *the_route, 
    bcm_l3_route_t *path_array, 
    int max_path, 
    int *path_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(the_route_l3a_stack_port);
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_COND(the_route) BCM_API_XLATE_PORT_SAVE(the_route_l3a_stack_port,the_route->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(the_route) BCM_API_XLATE_PORT_A2P(unit,&the_route->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_multipath_get_dispatch[dtype](unit, the_route, path_array, max_path, path_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(the_route) BCM_API_XLATE_PORT_RESTORE(the_route->l3a_stack_port,the_route_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(max_path,idx)
				BCM_API_XLATE_PORT_COND(path_array) BCM_API_XLATE_PORT_P2A(unit,&(path_array)[idx].l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_multipath_get", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_stat_attach( \
    int unit, bcm_l3_route_t *info, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_stat_attach,
static int (*_l3_route_stat_attach_dispatch[])(
    int unit, 
    bcm_l3_route_t *info, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_stat_attach(
    int unit, 
    bcm_l3_route_t *info, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_stat_attach_dispatch[dtype](unit, info, stat_counter_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_stat_attach", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_stat_counter_get( \
    int unit, bcm_l3_route_t *info, bcm_l3_route_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_stat_counter_get,
static int (*_l3_route_stat_counter_get_dispatch[])(
    int unit, 
    bcm_l3_route_t *info, 
    bcm_l3_route_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_stat_counter_get(
    int unit, 
    bcm_l3_route_t *info, 
    bcm_l3_route_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_stat_counter_get_dispatch[dtype](unit, info, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_stat_counter_get", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_stat_counter_set( \
    int unit, bcm_l3_route_t *info, bcm_l3_route_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_stat_counter_set,
static int (*_l3_route_stat_counter_set_dispatch[])(
    int unit, 
    bcm_l3_route_t *info, 
    bcm_l3_route_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_stat_counter_set(
    int unit, 
    bcm_l3_route_t *info, 
    bcm_l3_route_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_stat_counter_set_dispatch[dtype](unit, info, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_stat_counter_set", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_stat_counter_sync_get( \
    int unit, bcm_l3_route_t *info, bcm_l3_route_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_stat_counter_sync_get,
static int (*_l3_route_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_l3_route_t *info, 
    bcm_l3_route_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_stat_counter_sync_get(
    int unit, 
    bcm_l3_route_t *info, 
    bcm_l3_route_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_stat_counter_sync_get_dispatch[dtype](unit, info, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_stat_counter_sync_get", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_stat_detach( \
    int unit, bcm_l3_route_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_stat_detach,
static int (*_l3_route_stat_detach_dispatch[])(
    int unit, 
    bcm_l3_route_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_stat_detach(
    int unit, 
    bcm_l3_route_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_stat_detach_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_stat_detach", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_stat_enable_set( \
    int unit, bcm_l3_route_t *route, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_stat_enable_set,
static int (*_l3_route_stat_enable_set_dispatch[])(
    int unit, 
    bcm_l3_route_t *route, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_stat_enable_set(
    int unit, 
    bcm_l3_route_t *route, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(route_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_SAVE(route_l3a_stack_port,route->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_stat_enable_set_dispatch[dtype](unit, route, enable);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_RESTORE(route->l3a_stack_port,route_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_stat_enable_set", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_stat_get( \
    int unit, bcm_l3_route_t *route, bcm_l3_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_stat_get,
static int (*_l3_route_stat_get_dispatch[])(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_stat_get(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(route_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_SAVE(route_l3a_stack_port,route->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_stat_get_dispatch[dtype](unit, route, stat, val);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_RESTORE(route->l3a_stack_port,route_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_stat_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_stat_get32( \
    int unit, bcm_l3_route_t *route, bcm_l3_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_stat_get32,
static int (*_l3_route_stat_get32_dispatch[])(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_stat_get32(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(route_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_SAVE(route_l3a_stack_port,route->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_stat_get32_dispatch[dtype](unit, route, stat, val);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_RESTORE(route->l3a_stack_port,route_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_stat_get32", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_stat_id_get( \
    int unit, bcm_l3_route_t *info, bcm_l3_route_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_stat_id_get,
static int (*_l3_route_stat_id_get_dispatch[])(
    int unit, 
    bcm_l3_route_t *info, 
    bcm_l3_route_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_stat_id_get(
    int unit, 
    bcm_l3_route_t *info, 
    bcm_l3_route_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_stat_id_get_dispatch[dtype](unit, info, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_stat_id_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_stat_multi_get( \
    int unit, bcm_l3_route_t *info, int nstat, bcm_l3_route_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_stat_multi_get,
static int (*_l3_route_stat_multi_get_dispatch[])(
    int unit, 
    bcm_l3_route_t *info, 
    int nstat, 
    bcm_l3_route_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_stat_multi_get(
    int unit, 
    bcm_l3_route_t *info, 
    int nstat, 
    bcm_l3_route_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_stat_multi_get_dispatch[dtype](unit, info, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_stat_multi_get", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_stat_multi_get32( \
    int unit, bcm_l3_route_t *info, int nstat, bcm_l3_route_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_stat_multi_get32,
static int (*_l3_route_stat_multi_get32_dispatch[])(
    int unit, 
    bcm_l3_route_t *info, 
    int nstat, 
    bcm_l3_route_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_stat_multi_get32(
    int unit, 
    bcm_l3_route_t *info, 
    int nstat, 
    bcm_l3_route_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_stat_multi_get32_dispatch[dtype](unit, info, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_stat_multi_get32", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_stat_multi_set( \
    int unit, bcm_l3_route_t *info, int nstat, bcm_l3_route_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_stat_multi_set,
static int (*_l3_route_stat_multi_set_dispatch[])(
    int unit, 
    bcm_l3_route_t *info, 
    int nstat, 
    bcm_l3_route_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_stat_multi_set(
    int unit, 
    bcm_l3_route_t *info, 
    int nstat, 
    bcm_l3_route_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_stat_multi_set_dispatch[dtype](unit, info, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_stat_multi_set", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_stat_multi_set32( \
    int unit, bcm_l3_route_t *info, int nstat, bcm_l3_route_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_stat_multi_set32,
static int (*_l3_route_stat_multi_set32_dispatch[])(
    int unit, 
    bcm_l3_route_t *info, 
    int nstat, 
    bcm_l3_route_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_stat_multi_set32(
    int unit, 
    bcm_l3_route_t *info, 
    int nstat, 
    bcm_l3_route_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_l3a_stack_port,info->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_stat_multi_set32_dispatch[dtype](unit, info, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->l3a_stack_port,info_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_stat_multi_set32", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_stat_set( \
    int unit, bcm_l3_route_t *route, bcm_l3_stat_t stat, uint64 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_stat_set,
static int (*_l3_route_stat_set_dispatch[])(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint64 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_stat_set(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint64 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(route_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_SAVE(route_l3a_stack_port,route->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_stat_set_dispatch[dtype](unit, route, stat, val);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_RESTORE(route->l3a_stack_port,route_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_stat_set", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_stat_set32( \
    int unit, bcm_l3_route_t *route, bcm_l3_stat_t stat, uint32 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_stat_set32,
static int (*_l3_route_stat_set32_dispatch[])(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint32 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_stat_set32(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint32 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(route_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_SAVE(route_l3a_stack_port,route->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_A2P(unit,&route->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_stat_set32_dispatch[dtype](unit, route, stat, val);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_RESTORE(route->l3a_stack_port,route_l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_stat_set32", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_route_traverse( \
    int unit, uint32 flags, uint32 start, uint32 end, bcm_l3_route_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_route_traverse,
static int (*_l3_route_traverse_dispatch[])(
    int unit, 
    uint32 flags, 
    uint32 start, 
    uint32 end, 
    bcm_l3_route_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_route_traverse(
    int unit, 
    uint32 flags, 
    uint32 start, 
    uint32 end, 
    bcm_l3_route_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_route_traverse_dispatch[dtype](unit, flags, start, end, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_route_traverse", 6, 3, unit, flags, start, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_source_bind_add( \
    int unit, bcm_l3_source_bind_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_source_bind_add,
static int (*_l3_source_bind_add_dispatch[])(
    int unit, 
    bcm_l3_source_bind_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_source_bind_add(
    int unit, 
    bcm_l3_source_bind_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_port,info->port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_source_bind_add_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->port,info_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_source_bind_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_source_bind_delete( \
    int unit, bcm_l3_source_bind_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_source_bind_delete,
static int (*_l3_source_bind_delete_dispatch[])(
    int unit, 
    bcm_l3_source_bind_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_source_bind_delete(
    int unit, 
    bcm_l3_source_bind_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_port,info->port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_source_bind_delete_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->port,info_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_source_bind_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_source_bind_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_source_bind_delete_all,
static int (*_l3_source_bind_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_source_bind_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_source_bind_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_source_bind_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_source_bind_enable_get( \
    int unit, bcm_port_t port, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_source_bind_enable_get,
static int (*_l3_source_bind_enable_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_source_bind_enable_get(
    int unit, 
    bcm_port_t port, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_source_bind_enable_get_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_source_bind_enable_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_source_bind_enable_set( \
    int unit, bcm_port_t port, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_source_bind_enable_set,
static int (*_l3_source_bind_enable_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_source_bind_enable_set(
    int unit, 
    bcm_port_t port, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_source_bind_enable_set_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_source_bind_enable_set", 3, 3, unit, port, enable, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_source_bind_get( \
    int unit, bcm_l3_source_bind_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_source_bind_get,
static int (*_l3_source_bind_get_dispatch[])(
    int unit, 
    bcm_l3_source_bind_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_source_bind_get(
    int unit, 
    bcm_l3_source_bind_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_source_bind_get_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_source_bind_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_source_bind_traverse( \
    int unit, bcm_l3_source_bind_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_source_bind_traverse,
static int (*_l3_source_bind_traverse_dispatch[])(
    int unit, 
    bcm_l3_source_bind_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_source_bind_traverse(
    int unit, 
    bcm_l3_source_bind_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_source_bind_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_source_bind_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_subnet_route_find( \
    int unit, bcm_l3_route_t *input, bcm_l3_route_t *route);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_subnet_route_find,
static int (*_l3_subnet_route_find_dispatch[])(
    int unit, 
    bcm_l3_route_t *input, 
    bcm_l3_route_t *route) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_subnet_route_find(
    int unit, 
    bcm_l3_route_t *input, 
    bcm_l3_route_t *route)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(input_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(input) BCM_API_XLATE_PORT_SAVE(input_l3a_stack_port,input->l3a_stack_port);
		BCM_API_XLATE_PORT_COND(input) BCM_API_XLATE_PORT_A2P(unit,&input->l3a_stack_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_subnet_route_find_dispatch[dtype](unit, input, route);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(input) BCM_API_XLATE_PORT_RESTORE(input->l3a_stack_port,input_l3a_stack_port);
		BCM_API_XLATE_PORT_COND(route) BCM_API_XLATE_PORT_P2A(unit,&route->l3a_stack_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_subnet_route_find", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_attach( \
    int unit, bcm_vrf_t vrf, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_attach,
static int (*_l3_vrf_stat_attach_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_attach(
    int unit, 
    bcm_vrf_t vrf, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_attach_dispatch[dtype](unit, vrf, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_attach", 3, 3, unit, vrf, stat_counter_id, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_counter_get( \
    int unit, bcm_vrf_t vrf, bcm_l3_vrf_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_counter_get,
static int (*_l3_vrf_stat_counter_get_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_counter_get(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_counter_get_dispatch[dtype](unit, vrf, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_counter_get", 6, 3, unit, vrf, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_counter_set( \
    int unit, bcm_vrf_t vrf, bcm_l3_vrf_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_counter_set,
static int (*_l3_vrf_stat_counter_set_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_counter_set(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_counter_set_dispatch[dtype](unit, vrf, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_counter_set", 6, 3, unit, vrf, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_counter_sync_get( \
    int unit, bcm_vrf_t vrf, bcm_l3_vrf_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_counter_sync_get,
static int (*_l3_vrf_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_counter_sync_get(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_counter_sync_get_dispatch[dtype](unit, vrf, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_counter_sync_get", 6, 3, unit, vrf, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_detach( \
    int unit, bcm_vrf_t vrf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_detach,
static int (*_l3_vrf_stat_detach_dispatch[])(
    int unit, 
    bcm_vrf_t vrf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_detach(
    int unit, 
    bcm_vrf_t vrf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_detach_dispatch[dtype](unit, vrf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_detach", 2, 2, unit, vrf, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_enable_set( \
    int unit, bcm_vrf_t vrf, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_enable_set,
static int (*_l3_vrf_stat_enable_set_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_enable_set(
    int unit, 
    bcm_vrf_t vrf, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_enable_set_dispatch[dtype](unit, vrf, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_enable_set", 3, 3, unit, vrf, enable, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_get( \
    int unit, bcm_vrf_t vrf, bcm_l3_vrf_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_get,
static int (*_l3_vrf_stat_get_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_get(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_get_dispatch[dtype](unit, vrf, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_get", 4, 3, unit, vrf, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_get32( \
    int unit, bcm_vrf_t vrf, bcm_l3_vrf_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_get32,
static int (*_l3_vrf_stat_get32_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_get32(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_get32_dispatch[dtype](unit, vrf, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_get32", 4, 3, unit, vrf, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_id_get( \
    int unit, bcm_vrf_t vrf, bcm_l3_vrf_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_id_get,
static int (*_l3_vrf_stat_id_get_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_id_get(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_id_get_dispatch[dtype](unit, vrf, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_id_get", 4, 3, unit, vrf, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_multi_get( \
    int unit, bcm_vrf_t vrf, int nstat, bcm_l3_vrf_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_multi_get,
static int (*_l3_vrf_stat_multi_get_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_multi_get(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_multi_get_dispatch[dtype](unit, vrf, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_multi_get", 5, 3, unit, vrf, nstat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_multi_get32( \
    int unit, bcm_vrf_t vrf, int nstat, bcm_l3_vrf_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_multi_get32,
static int (*_l3_vrf_stat_multi_get32_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_multi_get32(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_multi_get32_dispatch[dtype](unit, vrf, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_multi_get32", 5, 3, unit, vrf, nstat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_multi_set( \
    int unit, bcm_vrf_t vrf, int nstat, bcm_l3_vrf_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_multi_set,
static int (*_l3_vrf_stat_multi_set_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_multi_set(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_multi_set_dispatch[dtype](unit, vrf, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_multi_set", 5, 3, unit, vrf, nstat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_multi_set32( \
    int unit, bcm_vrf_t vrf, int nstat, bcm_l3_vrf_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_multi_set32,
static int (*_l3_vrf_stat_multi_set32_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_multi_set32(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_multi_set32_dispatch[dtype](unit, vrf, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_multi_set32", 5, 3, unit, vrf, nstat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_set( \
    int unit, bcm_vrf_t vrf, bcm_l3_vrf_stat_t stat, uint64 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_set,
static int (*_l3_vrf_stat_set_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint64 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_set(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint64 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_set_dispatch[dtype](unit, vrf, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_set", 4, 3, unit, vrf, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_set32( \
    int unit, bcm_vrf_t vrf, bcm_l3_vrf_stat_t stat, uint32 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_set32,
static int (*_l3_vrf_stat_set32_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_set32(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_set32_dispatch[dtype](unit, vrf, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_set32", 4, 3, unit, vrf, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_sync_get( \
    int unit, bcm_vrf_t vrf, bcm_l3_vrf_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_sync_get,
static int (*_l3_vrf_stat_sync_get_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_sync_get(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_sync_get_dispatch[dtype](unit, vrf, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_sync_get", 4, 3, unit, vrf, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrf_stat_sync_get32( \
    int unit, bcm_vrf_t vrf, bcm_l3_vrf_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrf_stat_sync_get32,
static int (*_l3_vrf_stat_sync_get32_dispatch[])(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrf_stat_sync_get32(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrf_stat_sync_get32_dispatch[dtype](unit, vrf, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrf_stat_sync_get32", 4, 3, unit, vrf, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrrp_add( \
    int unit, bcm_vlan_t vlan, uint32 vrid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrrp_add,
static int (*_l3_vrrp_add_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 vrid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrrp_add(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 vrid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrrp_add_dispatch[dtype](unit, vlan, vrid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrrp_add", 3, 3, unit, vlan, vrid, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrrp_config_add( \
    int unit, uint32 flags, bcm_vlan_t vlan, uint32 vrid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrrp_config_add,
static int (*_l3_vrrp_config_add_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_vlan_t vlan, 
    uint32 vrid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrrp_config_add(
    int unit, 
    uint32 flags, 
    bcm_vlan_t vlan, 
    uint32 vrid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrrp_config_add_dispatch[dtype](unit, flags, vlan, vrid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrrp_config_add", 4, 3, unit, flags, vlan, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrrp_config_delete( \
    int unit, uint32 flags, bcm_vlan_t vlan, uint32 vrid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrrp_config_delete,
static int (*_l3_vrrp_config_delete_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_vlan_t vlan, 
    uint32 vrid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrrp_config_delete(
    int unit, 
    uint32 flags, 
    bcm_vlan_t vlan, 
    uint32 vrid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrrp_config_delete_dispatch[dtype](unit, flags, vlan, vrid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrrp_config_delete", 4, 3, unit, flags, vlan, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrrp_config_delete_all( \
    int unit, uint32 flags, bcm_vlan_t vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrrp_config_delete_all,
static int (*_l3_vrrp_config_delete_all_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_vlan_t vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrrp_config_delete_all(
    int unit, 
    uint32 flags, 
    bcm_vlan_t vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrrp_config_delete_all_dispatch[dtype](unit, flags, vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrrp_config_delete_all", 3, 3, unit, flags, vlan, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrrp_config_get( \
    int unit, uint32 flags, bcm_vlan_t vlan, uint32 alloc_size, uint32 *vrid_array, uint32 *count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrrp_config_get,
static int (*_l3_vrrp_config_get_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_vlan_t vlan, 
    uint32 alloc_size, 
    uint32 *vrid_array, 
    uint32 *count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrrp_config_get(
    int unit, 
    uint32 flags, 
    bcm_vlan_t vlan, 
    uint32 alloc_size, 
    uint32 *vrid_array, 
    uint32 *count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrrp_config_get_dispatch[dtype](unit, flags, vlan, alloc_size, vrid_array, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrrp_config_get", 6, 3, unit, flags, vlan, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrrp_delete( \
    int unit, bcm_vlan_t vlan, uint32 vrid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrrp_delete,
static int (*_l3_vrrp_delete_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 vrid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrrp_delete(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 vrid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrrp_delete_dispatch[dtype](unit, vlan, vrid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrrp_delete", 3, 3, unit, vlan, vrid, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrrp_delete_all( \
    int unit, bcm_vlan_t vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrrp_delete_all,
static int (*_l3_vrrp_delete_all_dispatch[])(
    int unit, 
    bcm_vlan_t vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrrp_delete_all(
    int unit, 
    bcm_vlan_t vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrrp_delete_all_dispatch[dtype](unit, vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrrp_delete_all", 2, 2, unit, vlan, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_l3_vrrp_get( \
    int unit, bcm_vlan_t vlan, int alloc_size, int *vrid_array, int *count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_l3_vrrp_get,
static int (*_l3_vrrp_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    int alloc_size, 
    int *vrid_array, 
    int *count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_l3_vrrp_get(
    int unit, 
    bcm_vlan_t vlan, 
    int alloc_size, 
    int *vrid_array, 
    int *count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _l3_vrrp_get_dispatch[dtype](unit, vlan, alloc_size, vrid_array, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_l3_vrrp_get", 5, 3, unit, vlan, alloc_size, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_link_change( \
    int unit, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_link_change,
static int (*_link_change_dispatch[])(
    int unit, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_link_change(
    int unit, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _link_change_dispatch[dtype](unit, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_link_change", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_link_wait( \
    int unit, bcm_pbmp_t *pbm, int us);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_link_wait,
static int (*_link_wait_dispatch[])(
    int unit, 
    bcm_pbmp_t *pbm, 
    int us) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_link_wait(
    int unit, 
    bcm_pbmp_t *pbm, 
    int us)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_A2P(unit,pbm);
		dtype = BCM_DTYPE(unit);
		r_rv = _link_wait_dispatch[dtype](unit, pbm, us);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,pbm);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_link_wait", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_linkscan_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_linkscan_detach,
static int (*_linkscan_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_linkscan_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _linkscan_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_linkscan_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

#if defined(BROADCOM_DEBUG)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_linkscan_dump( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_linkscan_dump,
static int (*_linkscan_dump_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_linkscan_dump(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _linkscan_dump_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_linkscan_dump", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_linkscan_enable_get( \
    int unit, int *us);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_linkscan_enable_get,
static int (*_linkscan_enable_get_dispatch[])(
    int unit, 
    int *us) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_linkscan_enable_get(
    int unit, 
    int *us)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _linkscan_enable_get_dispatch[dtype](unit, us);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_linkscan_enable_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_linkscan_enable_port_get( \
    int unit, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_linkscan_enable_port_get,
static int (*_linkscan_enable_port_get_dispatch[])(
    int unit, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_linkscan_enable_port_get(
    int unit, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _linkscan_enable_port_get_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_linkscan_enable_port_get", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_linkscan_enable_set( \
    int unit, int us);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_linkscan_enable_set,
static int (*_linkscan_enable_set_dispatch[])(
    int unit, 
    int us) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_linkscan_enable_set(
    int unit, 
    int us)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _linkscan_enable_set_dispatch[dtype](unit, us);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_linkscan_enable_set", 2, 2, unit, us, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_linkscan_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_linkscan_init,
static int (*_linkscan_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_linkscan_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _linkscan_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_linkscan_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_linkscan_mode_get( \
    int unit, bcm_port_t port, int *mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_linkscan_mode_get,
static int (*_linkscan_mode_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_linkscan_mode_get(
    int unit, 
    bcm_port_t port, 
    int *mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _linkscan_mode_get_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_linkscan_mode_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_linkscan_mode_set( \
    int unit, bcm_port_t port, int mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_linkscan_mode_set,
static int (*_linkscan_mode_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_linkscan_mode_set(
    int unit, 
    bcm_port_t port, 
    int mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _linkscan_mode_set_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_linkscan_mode_set", 3, 3, unit, port, mode, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_linkscan_mode_set_pbm( \
    int unit, bcm_pbmp_t pbm, int mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_linkscan_mode_set_pbm,
static int (*_linkscan_mode_set_pbm_dispatch[])(
    int unit, 
    bcm_pbmp_t pbm, 
    int mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_linkscan_mode_set_pbm(
    int unit, 
    bcm_pbmp_t pbm, 
    int mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbm);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbm,pbm);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbm);
		dtype = BCM_DTYPE(unit);
		r_rv = _linkscan_mode_set_pbm_dispatch[dtype](unit, pbm, mode);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbm,t_pbm);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_linkscan_mode_set_pbm", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_linkscan_port_register( \
    int unit, bcm_port_t port, bcm_linkscan_port_handler_t f);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_linkscan_port_register,
static int (*_linkscan_port_register_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_linkscan_port_handler_t f) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_linkscan_port_register(
    int unit, 
    bcm_port_t port, 
    bcm_linkscan_port_handler_t f)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _linkscan_port_register_dispatch[dtype](unit, port, f);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_linkscan_port_register", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_linkscan_port_unregister( \
    int unit, bcm_port_t port, bcm_linkscan_port_handler_t f);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_linkscan_port_unregister,
static int (*_linkscan_port_unregister_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_linkscan_port_handler_t f) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_linkscan_port_unregister(
    int unit, 
    bcm_port_t port, 
    bcm_linkscan_port_handler_t f)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _linkscan_port_unregister_dispatch[dtype](unit, port, f);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_linkscan_port_unregister", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_linkscan_register( \
    int unit, bcm_linkscan_handler_t f);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_linkscan_register,
static int (*_linkscan_register_dispatch[])(
    int unit, 
    bcm_linkscan_handler_t f) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_linkscan_register(
    int unit, 
    bcm_linkscan_handler_t f)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _linkscan_register_dispatch[dtype](unit, f);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_linkscan_register", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_linkscan_unregister( \
    int unit, bcm_linkscan_handler_t f);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_linkscan_unregister,
static int (*_linkscan_unregister_dispatch[])(
    int unit, 
    bcm_linkscan_handler_t f) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_linkscan_unregister(
    int unit, 
    bcm_linkscan_handler_t f)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _linkscan_unregister_dispatch[dtype](unit, f);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_linkscan_unregister", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_linkscan_update( \
    int unit, bcm_pbmp_t pbm);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_linkscan_update,
static int (*_linkscan_update_dispatch[])(
    int unit, 
    bcm_pbmp_t pbm) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_linkscan_update(
    int unit, 
    bcm_pbmp_t pbm)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbm);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbm,pbm);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbm);
		dtype = BCM_DTYPE(unit);
		r_rv = _linkscan_update_dispatch[dtype](unit, pbm);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbm,t_pbm);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_linkscan_update", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_event_enable_get( \
    int unit, bcm_macsec_event_t t, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_event_enable_get,
static int (*_macsec_event_enable_get_dispatch[])(
    int unit, 
    bcm_macsec_event_t t, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_event_enable_get(
    int unit, 
    bcm_macsec_event_t t, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_event_enable_get_dispatch[dtype](unit, t, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_event_enable_get", 3, 2, unit, t, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_event_enable_set( \
    int unit, bcm_macsec_event_t t, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_event_enable_set,
static int (*_macsec_event_enable_set_dispatch[])(
    int unit, 
    bcm_macsec_event_t t, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_event_enable_set(
    int unit, 
    bcm_macsec_event_t t, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_event_enable_set_dispatch[dtype](unit, t, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_event_enable_set", 3, 3, unit, t, enable, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_event_register( \
    int unit, bcm_macsec_event_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_event_register,
static int (*_macsec_event_register_dispatch[])(
    int unit, 
    bcm_macsec_event_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_event_register(
    int unit, 
    bcm_macsec_event_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_event_register_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_event_register", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_event_unregister( \
    int unit, bcm_macsec_event_cb cb);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_event_unregister,
static int (*_macsec_event_unregister_dispatch[])(
    int unit, 
    bcm_macsec_event_cb cb) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_event_unregister(
    int unit, 
    bcm_macsec_event_cb cb)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_event_unregister_dispatch[dtype](unit, cb);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_event_unregister", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_flow_create( \
    int unit, bcm_port_t port, uint32 flags, bcm_macsec_flow_match_t *flow, bcm_macsec_flow_action_t *action, int *flowId);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_flow_create,
static int (*_macsec_flow_create_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_macsec_flow_match_t *flow, 
    bcm_macsec_flow_action_t *action, 
    int *flowId) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_flow_create(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_macsec_flow_match_t *flow, 
    bcm_macsec_flow_action_t *action, 
    int *flowId)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_flow_create_dispatch[dtype](unit, port, flags, flow, action, flowId);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_flow_create", 6, 3, unit, port, flags, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_flow_destroy( \
    int unit, bcm_port_t port, int flowId);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_flow_destroy,
static int (*_macsec_flow_destroy_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int flowId) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_flow_destroy(
    int unit, 
    bcm_port_t port, 
    int flowId)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_flow_destroy_dispatch[dtype](unit, port, flowId);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_flow_destroy", 3, 3, unit, port, flowId, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_flow_get( \
    int unit, bcm_port_t port, int flowId, bcm_macsec_flow_match_t *flow, bcm_macsec_flow_action_t *a);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_flow_get,
static int (*_macsec_flow_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int flowId, 
    bcm_macsec_flow_match_t *flow, 
    bcm_macsec_flow_action_t *a) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_flow_get(
    int unit, 
    bcm_port_t port, 
    int flowId, 
    bcm_macsec_flow_match_t *flow, 
    bcm_macsec_flow_action_t *a)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_flow_get_dispatch[dtype](unit, port, flowId, flow, a);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_flow_get", 5, 3, unit, port, flowId, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_flow_traverse( \
    int unit, bcm_port_t port, bcm_macsec_flow_traverse_cb callbk, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_flow_traverse,
static int (*_macsec_flow_traverse_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_flow_traverse_cb callbk, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_flow_traverse(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_flow_traverse_cb callbk, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_flow_traverse_dispatch[dtype](unit, port, callbk, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_flow_traverse", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_port_capability_get( \
    int unit, bcm_port_t port, bcm_macsec_port_capability_t *cap);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_port_capability_get,
static int (*_macsec_port_capability_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_port_capability_t *cap) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_port_capability_get(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_port_capability_t *cap)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_port_capability_get_dispatch[dtype](unit, port, cap);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_port_capability_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_port_config_get( \
    int unit, bcm_port_t port, bcm_macsec_port_config_t *cfg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_port_config_get,
static int (*_macsec_port_config_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_port_config_t *cfg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_port_config_get(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_port_config_t *cfg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_port_config_get_dispatch[dtype](unit, port, cfg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_port_config_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_port_config_set( \
    int unit, bcm_port_t port, bcm_macsec_port_config_t *cfg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_port_config_set,
static int (*_macsec_port_config_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_port_config_t *cfg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_port_config_set(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_port_config_t *cfg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_port_config_set_dispatch[dtype](unit, port, cfg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_port_config_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_port_traverse( \
    int unit, bcm_macsec_port_traverse_cb callbk, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_port_traverse,
static int (*_macsec_port_traverse_dispatch[])(
    int unit, 
    bcm_macsec_port_traverse_cb callbk, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_port_traverse(
    int unit, 
    bcm_macsec_port_traverse_cb callbk, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_port_traverse_dispatch[dtype](unit, callbk, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_port_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_secure_assoc_create( \
    int unit, bcm_port_t port, uint32 flags, int chanId, bcm_macsec_secure_assoc_t *assoc, int *assocId);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_secure_assoc_create,
static int (*_macsec_secure_assoc_create_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int chanId, 
    bcm_macsec_secure_assoc_t *assoc, 
    int *assocId) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_secure_assoc_create(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int chanId, 
    bcm_macsec_secure_assoc_t *assoc, 
    int *assocId)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_secure_assoc_create_dispatch[dtype](unit, port, flags, chanId, assoc, assocId);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_secure_assoc_create", 6, 3, unit, port, flags, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_secure_assoc_destroy( \
    int unit, bcm_port_t port, int assocId);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_secure_assoc_destroy,
static int (*_macsec_secure_assoc_destroy_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int assocId) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_secure_assoc_destroy(
    int unit, 
    bcm_port_t port, 
    int assocId)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_secure_assoc_destroy_dispatch[dtype](unit, port, assocId);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_secure_assoc_destroy", 3, 3, unit, port, assocId, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_secure_assoc_get( \
    int unit, bcm_port_t port, int assocId, bcm_macsec_secure_assoc_t *assoc, int *chanId);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_secure_assoc_get,
static int (*_macsec_secure_assoc_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int assocId, 
    bcm_macsec_secure_assoc_t *assoc, 
    int *chanId) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_secure_assoc_get(
    int unit, 
    bcm_port_t port, 
    int assocId, 
    bcm_macsec_secure_assoc_t *assoc, 
    int *chanId)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_secure_assoc_get_dispatch[dtype](unit, port, assocId, assoc, chanId);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_secure_assoc_get", 5, 3, unit, port, assocId, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_secure_assoc_traverse( \
    int unit, bcm_port_t port, int chanId, bcm_macsec_secure_assoc_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_secure_assoc_traverse,
static int (*_macsec_secure_assoc_traverse_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int chanId, 
    bcm_macsec_secure_assoc_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_secure_assoc_traverse(
    int unit, 
    bcm_port_t port, 
    int chanId, 
    bcm_macsec_secure_assoc_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_secure_assoc_traverse_dispatch[dtype](unit, port, chanId, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_secure_assoc_traverse", 5, 3, unit, port, chanId, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_secure_chan_create( \
    int unit, bcm_port_t port, uint32 flags, bcm_macsec_secure_chan_t *chan, int *chanId);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_secure_chan_create,
static int (*_macsec_secure_chan_create_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_macsec_secure_chan_t *chan, 
    int *chanId) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_secure_chan_create(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_macsec_secure_chan_t *chan, 
    int *chanId)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_secure_chan_create_dispatch[dtype](unit, port, flags, chan, chanId);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_secure_chan_create", 5, 3, unit, port, flags, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_secure_chan_destroy( \
    int unit, bcm_port_t port, int chanId);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_secure_chan_destroy,
static int (*_macsec_secure_chan_destroy_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int chanId) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_secure_chan_destroy(
    int unit, 
    bcm_port_t port, 
    int chanId)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_secure_chan_destroy_dispatch[dtype](unit, port, chanId);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_secure_chan_destroy", 3, 3, unit, port, chanId, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_secure_chan_get( \
    int unit, bcm_port_t port, int chanId, bcm_macsec_secure_chan_t *chan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_secure_chan_get,
static int (*_macsec_secure_chan_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int chanId, 
    bcm_macsec_secure_chan_t *chan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_secure_chan_get(
    int unit, 
    bcm_port_t port, 
    int chanId, 
    bcm_macsec_secure_chan_t *chan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_secure_chan_get_dispatch[dtype](unit, port, chanId, chan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_secure_chan_get", 4, 3, unit, port, chanId, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_secure_chan_traverse( \
    int unit, bcm_port_t port, bcm_macsec_chan_traverse_cb calback, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_secure_chan_traverse,
static int (*_macsec_secure_chan_traverse_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_chan_traverse_cb calback, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_secure_chan_traverse(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_chan_traverse_cb calback, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_secure_chan_traverse_dispatch[dtype](unit, port, calback, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_secure_chan_traverse", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_stat_clear( \
    int unit, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_stat_clear,
static int (*_macsec_stat_clear_dispatch[])(
    int unit, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_stat_clear(
    int unit, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_stat_clear_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_stat_clear", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_stat_get( \
    int unit, bcm_port_t port, bcm_macsec_stat_t stat, int chanId, int assocId, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_stat_get,
static int (*_macsec_stat_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_stat_get(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_stat_get_dispatch[dtype](unit, port, stat, chanId, assocId, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_stat_get", 6, 3, unit, port, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_stat_get32( \
    int unit, bcm_port_t port, bcm_macsec_stat_t stat, int chanId, int assocId, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_stat_get32,
static int (*_macsec_stat_get32_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_stat_get32(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_stat_get32_dispatch[dtype](unit, port, stat, chanId, assocId, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_stat_get32", 6, 3, unit, port, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_stat_set( \
    int unit, bcm_port_t port, bcm_macsec_stat_t stat, int chanId, int assocId, uint64 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_stat_set,
static int (*_macsec_stat_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint64 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_stat_set(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint64 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_stat_set_dispatch[dtype](unit, port, stat, chanId, assocId, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_stat_set", 6, 3, unit, port, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_MACSEC)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_macsec_stat_set32( \
    int unit, bcm_port_t port, bcm_macsec_stat_t stat, int chanId, int assocId, uint32 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_macsec_stat_set32,
static int (*_macsec_stat_set32_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint32 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_macsec_stat_set32(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint32 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _macsec_stat_set32_dispatch[dtype](unit, port, stat, chanId, assocId, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_macsec_stat_set32", 6, 3, unit, port, stat, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mcast_addr_add( \
    int unit, bcm_mcast_addr_t *mcaddr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mcast_addr_add,
static int (*_mcast_addr_add_dispatch[])(
    int unit, 
    bcm_mcast_addr_t *mcaddr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mcast_addr_add(
    int unit, 
    bcm_mcast_addr_t *mcaddr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(mcaddr_pbmp);
		BCM_API_XLATE_PORT_PBMP_DECL(mcaddr_ubmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_SAVE(mcaddr_pbmp,mcaddr->pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&mcaddr->pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_SAVE(mcaddr_ubmp,mcaddr->ubmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&mcaddr->ubmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _mcast_addr_add_dispatch[dtype](unit, mcaddr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_RESTORE(mcaddr->pbmp,mcaddr_pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_RESTORE(mcaddr->ubmp,mcaddr_ubmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mcast_addr_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mcast_addr_add_w_l2mcindex( \
    int unit, bcm_mcast_addr_t *mcaddr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mcast_addr_add_w_l2mcindex,
static int (*_mcast_addr_add_w_l2mcindex_dispatch[])(
    int unit, 
    bcm_mcast_addr_t *mcaddr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mcast_addr_add_w_l2mcindex(
    int unit, 
    bcm_mcast_addr_t *mcaddr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(mcaddr_pbmp);
		BCM_API_XLATE_PORT_PBMP_DECL(mcaddr_ubmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_SAVE(mcaddr_pbmp,mcaddr->pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&mcaddr->pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_SAVE(mcaddr_ubmp,mcaddr->ubmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&mcaddr->ubmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _mcast_addr_add_w_l2mcindex_dispatch[dtype](unit, mcaddr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_RESTORE(mcaddr->pbmp,mcaddr_pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_RESTORE(mcaddr->ubmp,mcaddr_ubmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mcast_addr_add_w_l2mcindex", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mcast_addr_remove( \
    int unit, bcm_mac_t mac, bcm_vlan_t vid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mcast_addr_remove,
static int (*_mcast_addr_remove_dispatch[])(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mcast_addr_remove(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mcast_addr_remove_dispatch[dtype](unit, mac, vid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mcast_addr_remove", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mcast_addr_remove_w_l2mcindex( \
    int unit, bcm_mcast_addr_t *mcaddr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mcast_addr_remove_w_l2mcindex,
static int (*_mcast_addr_remove_w_l2mcindex_dispatch[])(
    int unit, 
    bcm_mcast_addr_t *mcaddr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mcast_addr_remove_w_l2mcindex(
    int unit, 
    bcm_mcast_addr_t *mcaddr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(mcaddr_pbmp);
		BCM_API_XLATE_PORT_PBMP_DECL(mcaddr_ubmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_SAVE(mcaddr_pbmp,mcaddr->pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&mcaddr->pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_SAVE(mcaddr_ubmp,mcaddr->ubmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&mcaddr->ubmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _mcast_addr_remove_w_l2mcindex_dispatch[dtype](unit, mcaddr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_RESTORE(mcaddr->pbmp,mcaddr_pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_RESTORE(mcaddr->ubmp,mcaddr_ubmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mcast_addr_remove_w_l2mcindex", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mcast_bitmap_del( \
    int unit, int mc_idx, bcm_port_t in_port, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mcast_bitmap_del,
static int (*_mcast_bitmap_del_dispatch[])(
    int unit, 
    int mc_idx, 
    bcm_port_t in_port, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mcast_bitmap_del(
    int unit, 
    int mc_idx, 
    bcm_port_t in_port, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_A2P(unit,&in_port);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _mcast_bitmap_del_dispatch[dtype](unit, mc_idx, in_port, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mcast_bitmap_del", 4, 3, unit, mc_idx, in_port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mcast_bitmap_get( \
    int unit, int mc_idx, bcm_port_t in_port, bcm_pbmp_t *pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mcast_bitmap_get,
static int (*_mcast_bitmap_get_dispatch[])(
    int unit, 
    int mc_idx, 
    bcm_port_t in_port, 
    bcm_pbmp_t *pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mcast_bitmap_get(
    int unit, 
    int mc_idx, 
    bcm_port_t in_port, 
    bcm_pbmp_t *pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&in_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mcast_bitmap_get_dispatch[dtype](unit, mc_idx, in_port, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mcast_bitmap_get", 4, 3, unit, mc_idx, in_port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mcast_bitmap_max_get( \
    int unit, int *max_index);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mcast_bitmap_max_get,
static int (*_mcast_bitmap_max_get_dispatch[])(
    int unit, 
    int *max_index) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mcast_bitmap_max_get(
    int unit, 
    int *max_index)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mcast_bitmap_max_get_dispatch[dtype](unit, max_index);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mcast_bitmap_max_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mcast_bitmap_set( \
    int unit, int mc_idx, bcm_port_t in_port, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mcast_bitmap_set,
static int (*_mcast_bitmap_set_dispatch[])(
    int unit, 
    int mc_idx, 
    bcm_port_t in_port, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mcast_bitmap_set(
    int unit, 
    int mc_idx, 
    bcm_port_t in_port, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_A2P(unit,&in_port);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _mcast_bitmap_set_dispatch[dtype](unit, mc_idx, in_port, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mcast_bitmap_set", 4, 3, unit, mc_idx, in_port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mcast_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mcast_init,
static int (*_mcast_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mcast_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mcast_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mcast_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mcast_join( \
    int unit, bcm_mac_t mcMacAddr, bcm_vlan_t vlanId, int srcPort, bcm_mcast_addr_t *mcaddr, bcm_pbmp_t *allRouterBmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mcast_join,
static int (*_mcast_join_dispatch[])(
    int unit, 
    bcm_mac_t mcMacAddr, 
    bcm_vlan_t vlanId, 
    int srcPort, 
    bcm_mcast_addr_t *mcaddr, 
    bcm_pbmp_t *allRouterBmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mcast_join(
    int unit, 
    bcm_mac_t mcMacAddr, 
    bcm_vlan_t vlanId, 
    int srcPort, 
    bcm_mcast_addr_t *mcaddr, 
    bcm_pbmp_t *allRouterBmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&srcPort);
		dtype = BCM_DTYPE(unit);
		r_rv = _mcast_join_dispatch[dtype](unit, mcMacAddr, vlanId, srcPort, mcaddr, allRouterBmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_P2A(unit,&mcaddr->pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_P2A(unit,&mcaddr->ubmp);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,allRouterBmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mcast_join", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mcast_leave( \
    int unit, bcm_mac_t mcMacAddr, bcm_vlan_t vlanId, int srcPort);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mcast_leave,
static int (*_mcast_leave_dispatch[])(
    int unit, 
    bcm_mac_t mcMacAddr, 
    bcm_vlan_t vlanId, 
    int srcPort) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mcast_leave(
    int unit, 
    bcm_mac_t mcMacAddr, 
    bcm_vlan_t vlanId, 
    int srcPort)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&srcPort);
		dtype = BCM_DTYPE(unit);
		r_rv = _mcast_leave_dispatch[dtype](unit, mcMacAddr, vlanId, srcPort);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mcast_leave", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mcast_port_add( \
    int unit, bcm_mcast_addr_t *mcaddr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mcast_port_add,
static int (*_mcast_port_add_dispatch[])(
    int unit, 
    bcm_mcast_addr_t *mcaddr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mcast_port_add(
    int unit, 
    bcm_mcast_addr_t *mcaddr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(mcaddr_pbmp);
		BCM_API_XLATE_PORT_PBMP_DECL(mcaddr_ubmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_SAVE(mcaddr_pbmp,mcaddr->pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&mcaddr->pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_SAVE(mcaddr_ubmp,mcaddr->ubmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&mcaddr->ubmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _mcast_port_add_dispatch[dtype](unit, mcaddr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_RESTORE(mcaddr->pbmp,mcaddr_pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_RESTORE(mcaddr->ubmp,mcaddr_ubmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mcast_port_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mcast_port_get( \
    int unit, bcm_mac_t mac, bcm_vlan_t vid, bcm_mcast_addr_t *mcaddr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mcast_port_get,
static int (*_mcast_port_get_dispatch[])(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vid, 
    bcm_mcast_addr_t *mcaddr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mcast_port_get(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vid, 
    bcm_mcast_addr_t *mcaddr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mcast_port_get_dispatch[dtype](unit, mac, vid, mcaddr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_P2A(unit,&mcaddr->pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_P2A(unit,&mcaddr->ubmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mcast_port_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mcast_port_remove( \
    int unit, bcm_mcast_addr_t *mcaddr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mcast_port_remove,
static int (*_mcast_port_remove_dispatch[])(
    int unit, 
    bcm_mcast_addr_t *mcaddr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mcast_port_remove(
    int unit, 
    bcm_mcast_addr_t *mcaddr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(mcaddr_pbmp);
		BCM_API_XLATE_PORT_PBMP_DECL(mcaddr_ubmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_SAVE(mcaddr_pbmp,mcaddr->pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&mcaddr->pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_SAVE(mcaddr_ubmp,mcaddr->ubmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_A2P(unit,&mcaddr->ubmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _mcast_port_remove_dispatch[dtype](unit, mcaddr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_RESTORE(mcaddr->pbmp,mcaddr_pbmp);
		BCM_API_XLATE_PORT_COND(mcaddr) BCM_API_XLATE_PORT_PBMP_RESTORE(mcaddr->ubmp,mcaddr_ubmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mcast_port_remove", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_detach,
static int (*_mim_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_init,
static int (*_mim_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_lookup_id_stat_attach( \
    int unit, int lookup_id, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_lookup_id_stat_attach,
static int (*_mim_lookup_id_stat_attach_dispatch[])(
    int unit, 
    int lookup_id, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_lookup_id_stat_attach(
    int unit, 
    int lookup_id, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_lookup_id_stat_attach_dispatch[dtype](unit, lookup_id, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_lookup_id_stat_attach", 3, 3, unit, lookup_id, stat_counter_id, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_lookup_id_stat_counter_get( \
    int unit, int lookup_id, bcm_mim_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_lookup_id_stat_counter_get,
static int (*_mim_lookup_id_stat_counter_get_dispatch[])(
    int unit, 
    int lookup_id, 
    bcm_mim_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_lookup_id_stat_counter_get(
    int unit, 
    int lookup_id, 
    bcm_mim_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_lookup_id_stat_counter_get_dispatch[dtype](unit, lookup_id, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_lookup_id_stat_counter_get", 6, 3, unit, lookup_id, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_lookup_id_stat_counter_set( \
    int unit, int lookup_id, bcm_mim_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_lookup_id_stat_counter_set,
static int (*_mim_lookup_id_stat_counter_set_dispatch[])(
    int unit, 
    int lookup_id, 
    bcm_mim_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_lookup_id_stat_counter_set(
    int unit, 
    int lookup_id, 
    bcm_mim_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_lookup_id_stat_counter_set_dispatch[dtype](unit, lookup_id, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_lookup_id_stat_counter_set", 6, 3, unit, lookup_id, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_lookup_id_stat_counter_sync_get( \
    int unit, int lookup_id, bcm_mim_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_lookup_id_stat_counter_sync_get,
static int (*_mim_lookup_id_stat_counter_sync_get_dispatch[])(
    int unit, 
    int lookup_id, 
    bcm_mim_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_lookup_id_stat_counter_sync_get(
    int unit, 
    int lookup_id, 
    bcm_mim_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_lookup_id_stat_counter_sync_get_dispatch[dtype](unit, lookup_id, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_lookup_id_stat_counter_sync_get", 6, 3, unit, lookup_id, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_lookup_id_stat_detach( \
    int unit, int lookup_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_lookup_id_stat_detach,
static int (*_mim_lookup_id_stat_detach_dispatch[])(
    int unit, 
    int lookup_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_lookup_id_stat_detach(
    int unit, 
    int lookup_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_lookup_id_stat_detach_dispatch[dtype](unit, lookup_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_lookup_id_stat_detach", 2, 2, unit, lookup_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_lookup_id_stat_id_get( \
    int unit, int lookup_id, bcm_mim_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_lookup_id_stat_id_get,
static int (*_mim_lookup_id_stat_id_get_dispatch[])(
    int unit, 
    int lookup_id, 
    bcm_mim_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_lookup_id_stat_id_get(
    int unit, 
    int lookup_id, 
    bcm_mim_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_lookup_id_stat_id_get_dispatch[dtype](unit, lookup_id, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_lookup_id_stat_id_get", 4, 3, unit, lookup_id, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_port_add( \
    int unit, bcm_mim_vpn_t vpn, bcm_mim_port_t *mim_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_port_add,
static int (*_mim_port_add_dispatch[])(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_mim_port_t *mim_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_port_add(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_mim_port_t *mim_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(mim_port) BCM_API_XLATE_PORT_A2P(unit,&mim_port->failover_gport_id);
		BCM_API_XLATE_PORT_COND(mim_port) BCM_API_XLATE_PORT_A2P(unit,&mim_port->mim_port_id);
		BCM_API_XLATE_PORT_COND(mim_port) BCM_API_XLATE_PORT_A2P(unit,&mim_port->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_port_add_dispatch[dtype](unit, vpn, mim_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(mim_port) BCM_API_XLATE_PORT_P2A(unit,&mim_port->failover_gport_id);
		BCM_API_XLATE_PORT_COND(mim_port) BCM_API_XLATE_PORT_P2A(unit,&mim_port->mim_port_id);
		BCM_API_XLATE_PORT_COND(mim_port) BCM_API_XLATE_PORT_P2A(unit,&mim_port->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_port_add", 3, 2, unit, vpn, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_port_delete( \
    int unit, bcm_mim_vpn_t vpn, bcm_gport_t mim_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_port_delete,
static int (*_mim_port_delete_dispatch[])(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_gport_t mim_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_port_delete(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_gport_t mim_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mim_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_port_delete_dispatch[dtype](unit, vpn, mim_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_port_delete", 3, 3, unit, vpn, mim_port_id, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_port_delete_all( \
    int unit, bcm_mim_vpn_t vpn);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_port_delete_all,
static int (*_mim_port_delete_all_dispatch[])(
    int unit, 
    bcm_mim_vpn_t vpn) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_port_delete_all(
    int unit, 
    bcm_mim_vpn_t vpn)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_port_delete_all_dispatch[dtype](unit, vpn);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_port_delete_all", 2, 2, unit, vpn, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_port_get( \
    int unit, bcm_mim_vpn_t vpn, bcm_mim_port_t *mim_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_port_get,
static int (*_mim_port_get_dispatch[])(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_mim_port_t *mim_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_port_get(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_mim_port_t *mim_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(mim_port) BCM_API_XLATE_PORT_A2P(unit,&mim_port->failover_gport_id);
		BCM_API_XLATE_PORT_COND(mim_port) BCM_API_XLATE_PORT_A2P(unit,&mim_port->mim_port_id);
		BCM_API_XLATE_PORT_COND(mim_port) BCM_API_XLATE_PORT_A2P(unit,&mim_port->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_port_get_dispatch[dtype](unit, vpn, mim_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(mim_port) BCM_API_XLATE_PORT_P2A(unit,&mim_port->failover_gport_id);
		BCM_API_XLATE_PORT_COND(mim_port) BCM_API_XLATE_PORT_P2A(unit,&mim_port->mim_port_id);
		BCM_API_XLATE_PORT_COND(mim_port) BCM_API_XLATE_PORT_P2A(unit,&mim_port->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_port_get", 3, 2, unit, vpn, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_port_get_all( \
    int unit, bcm_mim_vpn_t vpn, int port_max, bcm_mim_port_t *port_array, int *port_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_port_get_all,
static int (*_mim_port_get_all_dispatch[])(
    int unit, 
    bcm_mim_vpn_t vpn, 
    int port_max, 
    bcm_mim_port_t *port_array, 
    int *port_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_port_get_all(
    int unit, 
    bcm_mim_vpn_t vpn, 
    int port_max, 
    bcm_mim_port_t *port_array, 
    int *port_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_port_get_all_dispatch[dtype](unit, vpn, port_max, port_array, port_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].failover_gport_id);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].mim_port_id);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_port_get_all", 5, 3, unit, vpn, port_max, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_vpn_create( \
    int unit, bcm_mim_vpn_config_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_vpn_create,
static int (*_mim_vpn_create_dispatch[])(
    int unit, 
    bcm_mim_vpn_config_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_vpn_create(
    int unit, 
    bcm_mim_vpn_config_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_vpn_create_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_vpn_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_vpn_destroy( \
    int unit, bcm_mim_vpn_t vpn);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_vpn_destroy,
static int (*_mim_vpn_destroy_dispatch[])(
    int unit, 
    bcm_mim_vpn_t vpn) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_vpn_destroy(
    int unit, 
    bcm_mim_vpn_t vpn)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_vpn_destroy_dispatch[dtype](unit, vpn);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_vpn_destroy", 2, 2, unit, vpn, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_vpn_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_vpn_destroy_all,
static int (*_mim_vpn_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_vpn_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_vpn_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_vpn_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_vpn_get( \
    int unit, bcm_mim_vpn_t vpn, bcm_mim_vpn_config_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_vpn_get,
static int (*_mim_vpn_get_dispatch[])(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_mim_vpn_config_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_vpn_get(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_mim_vpn_config_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_vpn_get_dispatch[dtype](unit, vpn, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_vpn_get", 3, 2, unit, vpn, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_vpn_stat_attach( \
    int unit, bcm_mim_vpn_t vpn, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_vpn_stat_attach,
static int (*_mim_vpn_stat_attach_dispatch[])(
    int unit, 
    bcm_mim_vpn_t vpn, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_vpn_stat_attach(
    int unit, 
    bcm_mim_vpn_t vpn, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_vpn_stat_attach_dispatch[dtype](unit, vpn, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_vpn_stat_attach", 3, 3, unit, vpn, stat_counter_id, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_vpn_stat_counter_get( \
    int unit, bcm_mim_vpn_t vpn, bcm_mim_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_vpn_stat_counter_get,
static int (*_mim_vpn_stat_counter_get_dispatch[])(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_mim_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_vpn_stat_counter_get(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_mim_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_vpn_stat_counter_get_dispatch[dtype](unit, vpn, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_vpn_stat_counter_get", 6, 3, unit, vpn, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_vpn_stat_counter_set( \
    int unit, bcm_mim_vpn_t vpn, bcm_mim_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_vpn_stat_counter_set,
static int (*_mim_vpn_stat_counter_set_dispatch[])(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_mim_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_vpn_stat_counter_set(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_mim_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_vpn_stat_counter_set_dispatch[dtype](unit, vpn, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_vpn_stat_counter_set", 6, 3, unit, vpn, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_vpn_stat_counter_sync_get( \
    int unit, bcm_mim_vpn_t vpn, bcm_mim_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_vpn_stat_counter_sync_get,
static int (*_mim_vpn_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_mim_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_vpn_stat_counter_sync_get(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_mim_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_vpn_stat_counter_sync_get_dispatch[dtype](unit, vpn, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_vpn_stat_counter_sync_get", 6, 3, unit, vpn, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_vpn_stat_detach( \
    int unit, bcm_mim_vpn_t vpn);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_vpn_stat_detach,
static int (*_mim_vpn_stat_detach_dispatch[])(
    int unit, 
    bcm_mim_vpn_t vpn) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_vpn_stat_detach(
    int unit, 
    bcm_mim_vpn_t vpn)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_vpn_stat_detach_dispatch[dtype](unit, vpn);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_vpn_stat_detach", 2, 2, unit, vpn, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_vpn_stat_id_get( \
    int unit, bcm_mim_vpn_t vpn, bcm_mim_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_vpn_stat_id_get,
static int (*_mim_vpn_stat_id_get_dispatch[])(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_mim_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_vpn_stat_id_get(
    int unit, 
    bcm_mim_vpn_t vpn, 
    bcm_mim_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_vpn_stat_id_get_dispatch[dtype](unit, vpn, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_vpn_stat_id_get", 4, 3, unit, vpn, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mim_vpn_traverse( \
    int unit, bcm_mim_vpn_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mim_vpn_traverse,
static int (*_mim_vpn_traverse_dispatch[])(
    int unit, 
    bcm_mim_vpn_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mim_vpn_traverse(
    int unit, 
    bcm_mim_vpn_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mim_vpn_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mim_vpn_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_destination_create( \
    int unit, bcm_mirror_destination_t *mirror_dest);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_destination_create,
static int (*_mirror_destination_create_dispatch[])(
    int unit, 
    bcm_mirror_destination_t *mirror_dest) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_destination_create(
    int unit, 
    bcm_mirror_destination_t *mirror_dest)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(mirror_dest) BCM_API_XLATE_PORT_A2P(unit,&mirror_dest->gport);
		BCM_API_XLATE_PORT_COND(mirror_dest) BCM_API_XLATE_PORT_A2P(unit,&mirror_dest->mirror_dest_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_destination_create_dispatch[dtype](unit, mirror_dest);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(mirror_dest) BCM_API_XLATE_PORT_P2A(unit,&mirror_dest->gport);
		BCM_API_XLATE_PORT_COND(mirror_dest) BCM_API_XLATE_PORT_P2A(unit,&mirror_dest->mirror_dest_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_destination_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_destination_destroy( \
    int unit, bcm_gport_t mirror_dest_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_destination_destroy,
static int (*_mirror_destination_destroy_dispatch[])(
    int unit, 
    bcm_gport_t mirror_dest_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_destination_destroy(
    int unit, 
    bcm_gport_t mirror_dest_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mirror_dest_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_destination_destroy_dispatch[dtype](unit, mirror_dest_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_destination_destroy", 2, 2, unit, mirror_dest_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_destination_get( \
    int unit, bcm_gport_t mirror_dest_id, bcm_mirror_destination_t *mirror_dest);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_destination_get,
static int (*_mirror_destination_get_dispatch[])(
    int unit, 
    bcm_gport_t mirror_dest_id, 
    bcm_mirror_destination_t *mirror_dest) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_destination_get(
    int unit, 
    bcm_gport_t mirror_dest_id, 
    bcm_mirror_destination_t *mirror_dest)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mirror_dest_id);
		BCM_API_XLATE_PORT_COND(mirror_dest) BCM_API_XLATE_PORT_A2P(unit,&mirror_dest->gport);
		BCM_API_XLATE_PORT_COND(mirror_dest) BCM_API_XLATE_PORT_A2P(unit,&mirror_dest->mirror_dest_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_destination_get_dispatch[dtype](unit, mirror_dest_id, mirror_dest);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(mirror_dest) BCM_API_XLATE_PORT_P2A(unit,&mirror_dest->gport);
		BCM_API_XLATE_PORT_COND(mirror_dest) BCM_API_XLATE_PORT_P2A(unit,&mirror_dest->mirror_dest_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_destination_get", 3, 2, unit, mirror_dest_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_destination_traverse( \
    int unit, bcm_mirror_destination_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_destination_traverse,
static int (*_mirror_destination_traverse_dispatch[])(
    int unit, 
    bcm_mirror_destination_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_destination_traverse(
    int unit, 
    bcm_mirror_destination_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_destination_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_destination_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_egress_get( \
    int unit, bcm_port_t port, int *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_egress_get,
static int (*_mirror_egress_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_egress_get(
    int unit, 
    bcm_port_t port, 
    int *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_egress_get_dispatch[dtype](unit, port, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_egress_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_egress_set( \
    int unit, bcm_port_t port, int val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_egress_set,
static int (*_mirror_egress_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_egress_set(
    int unit, 
    bcm_port_t port, 
    int val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_egress_set_dispatch[dtype](unit, port, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_egress_set", 3, 3, unit, port, val, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_ingress_get( \
    int unit, bcm_port_t port, int *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_ingress_get,
static int (*_mirror_ingress_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_ingress_get(
    int unit, 
    bcm_port_t port, 
    int *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_ingress_get_dispatch[dtype](unit, port, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_ingress_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_ingress_set( \
    int unit, bcm_port_t port, int val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_ingress_set,
static int (*_mirror_ingress_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_ingress_set(
    int unit, 
    bcm_port_t port, 
    int val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_ingress_set_dispatch[dtype](unit, port, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_ingress_set", 3, 3, unit, port, val, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_init,
static int (*_mirror_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_mode_get( \
    int unit, int *mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_mode_get,
static int (*_mirror_mode_get_dispatch[])(
    int unit, 
    int *mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_mode_get(
    int unit, 
    int *mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_mode_get_dispatch[dtype](unit, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_mode_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_mode_set( \
    int unit, int mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_mode_set,
static int (*_mirror_mode_set_dispatch[])(
    int unit, 
    int mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_mode_set(
    int unit, 
    int mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_mode_set_dispatch[dtype](unit, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_mode_set", 2, 2, unit, mode, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_dest_add( \
    int unit, bcm_port_t port, uint32 flags, bcm_gport_t mirror_dest_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_dest_add,
static int (*_mirror_port_dest_add_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_gport_t mirror_dest_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_dest_add(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_gport_t mirror_dest_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&mirror_dest_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_dest_add_dispatch[dtype](unit, port, flags, mirror_dest_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_dest_add", 4, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_dest_delete( \
    int unit, bcm_port_t port, uint32 flags, bcm_gport_t mirror_dest_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_dest_delete,
static int (*_mirror_port_dest_delete_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_gport_t mirror_dest_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_dest_delete(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_gport_t mirror_dest_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&mirror_dest_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_dest_delete_dispatch[dtype](unit, port, flags, mirror_dest_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_dest_delete", 4, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_dest_delete_all( \
    int unit, bcm_port_t port, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_dest_delete_all,
static int (*_mirror_port_dest_delete_all_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_dest_delete_all(
    int unit, 
    bcm_port_t port, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_dest_delete_all_dispatch[dtype](unit, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_dest_delete_all", 3, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_dest_get( \
    int unit, bcm_port_t port, uint32 flags, int mirror_dest_size, bcm_gport_t *mirror_dest, int *mirror_dest_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_dest_get,
static int (*_mirror_port_dest_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int mirror_dest_size, 
    bcm_gport_t *mirror_dest, 
    int *mirror_dest_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_dest_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int mirror_dest_size, 
    bcm_gport_t *mirror_dest, 
    int *mirror_dest_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_dest_get_dispatch[dtype](unit, port, flags, mirror_dest_size, mirror_dest, mirror_dest_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(mirror_dest_size,idx)
				BCM_API_XLATE_PORT_COND(mirror_dest) BCM_API_XLATE_PORT_P2A(unit,&(mirror_dest)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_dest_get", 6, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_destination_add( \
    int unit, bcm_port_t port, uint32 flags, bcm_gport_t mirror_dest, bcm_mirror_options_t options);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_destination_add,
static int (*_mirror_port_destination_add_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_gport_t mirror_dest, 
    bcm_mirror_options_t options) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_destination_add(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_gport_t mirror_dest, 
    bcm_mirror_options_t options)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&mirror_dest);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_destination_add_dispatch[dtype](unit, port, flags, mirror_dest, options);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_destination_add", 5, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_destination_get( \
    int unit, bcm_port_t port, uint32 flags, int mirror_dest_size, bcm_gport_t *mirror_dest, int *mirror_dest_count, bcm_mirror_options_t *options);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_destination_get,
static int (*_mirror_port_destination_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int mirror_dest_size, 
    bcm_gport_t *mirror_dest, 
    int *mirror_dest_count, 
    bcm_mirror_options_t *options) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_destination_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int mirror_dest_size, 
    bcm_gport_t *mirror_dest, 
    int *mirror_dest_count, 
    bcm_mirror_options_t *options)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_destination_get_dispatch[dtype](unit, port, flags, mirror_dest_size, mirror_dest, mirror_dest_count, options);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(mirror_dest_size,idx)
				BCM_API_XLATE_PORT_COND(mirror_dest) BCM_API_XLATE_PORT_P2A(unit,&(mirror_dest)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_destination_get", 7, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_get( \
    int unit, bcm_port_t port, bcm_module_t *dest_mod, bcm_port_t *dest_port, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_get,
static int (*_mirror_port_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_module_t *dest_mod, 
    bcm_port_t *dest_port, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_get(
    int unit, 
    bcm_port_t port, 
    bcm_module_t *dest_mod, 
    bcm_port_t *dest_port, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_get_dispatch[dtype](unit, port, dest_mod, dest_port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_get", 5, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_info_get( \
    int unit, bcm_port_t port, uint32 flags, bcm_mirror_port_info_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_info_get,
static int (*_mirror_port_info_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_mirror_port_info_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_info_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_mirror_port_info_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_info_get_dispatch[dtype](unit, port, flags, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->mirror_system_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_info_get", 4, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_info_set( \
    int unit, bcm_port_t port, uint32 flags, bcm_mirror_port_info_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_info_set,
static int (*_mirror_port_info_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_mirror_port_info_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_info_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_mirror_port_info_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_mirror_system_id);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_mirror_system_id,info->mirror_system_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->mirror_system_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_info_set_dispatch[dtype](unit, port, flags, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->mirror_system_id,info_mirror_system_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_info_set", 4, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_set( \
    int unit, bcm_port_t port, bcm_module_t dest_mod, bcm_port_t dest_port, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_set,
static int (*_mirror_port_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_module_t dest_mod, 
    bcm_port_t dest_port, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_set(
    int unit, 
    bcm_port_t port, 
    bcm_module_t dest_mod, 
    bcm_port_t dest_port, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_set_dispatch[dtype](unit, port, dest_mod, dest_port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_set", 5, 3, unit, port, dest_mod, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_vlan_dest_add( \
    int unit, bcm_port_t port, bcm_vlan_t vlan, uint32 flags, bcm_gport_t destid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_vlan_dest_add,
static int (*_mirror_port_vlan_dest_add_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    uint32 flags, 
    bcm_gport_t destid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_vlan_dest_add(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    uint32 flags, 
    bcm_gport_t destid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&destid);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_vlan_dest_add_dispatch[dtype](unit, port, vlan, flags, destid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_vlan_dest_add", 5, 3, unit, port, vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_vlan_dest_delete( \
    int unit, bcm_port_t port, bcm_vlan_t vlan, uint32 flags, bcm_gport_t destid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_vlan_dest_delete,
static int (*_mirror_port_vlan_dest_delete_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    uint32 flags, 
    bcm_gport_t destid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_vlan_dest_delete(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    uint32 flags, 
    bcm_gport_t destid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&destid);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_vlan_dest_delete_dispatch[dtype](unit, port, vlan, flags, destid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_vlan_dest_delete", 5, 3, unit, port, vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_vlan_dest_delete_all( \
    int unit, bcm_port_t port, bcm_vlan_t vlan, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_vlan_dest_delete_all,
static int (*_mirror_port_vlan_dest_delete_all_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_vlan_dest_delete_all(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_vlan_dest_delete_all_dispatch[dtype](unit, port, vlan, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_vlan_dest_delete_all", 4, 3, unit, port, vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_vlan_dest_get( \
    int unit, bcm_port_t port, bcm_vlan_t vlan, uint32 flags, uint32 mirror_dest_size, bcm_gport_t *destid, uint32 *destcount);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_vlan_dest_get,
static int (*_mirror_port_vlan_dest_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    uint32 flags, 
    uint32 mirror_dest_size, 
    bcm_gport_t *destid, 
    uint32 *destcount) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_vlan_dest_get(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    uint32 flags, 
    uint32 mirror_dest_size, 
    bcm_gport_t *destid, 
    uint32 *destcount)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_vlan_dest_get_dispatch[dtype](unit, port, vlan, flags, mirror_dest_size, destid, destcount);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(mirror_dest_size,idx)
				BCM_API_XLATE_PORT_COND(destid) BCM_API_XLATE_PORT_P2A(unit,&(destid)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_vlan_dest_get", 7, 3, unit, port, vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_vlan_destination_add( \
    int unit, bcm_port_t port, bcm_vlan_t vlan, uint32 flags, bcm_gport_t destid, bcm_mirror_options_t options);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_vlan_destination_add,
static int (*_mirror_port_vlan_destination_add_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    uint32 flags, 
    bcm_gport_t destid, 
    bcm_mirror_options_t options) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_vlan_destination_add(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    uint32 flags, 
    bcm_gport_t destid, 
    bcm_mirror_options_t options)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&destid);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_vlan_destination_add_dispatch[dtype](unit, port, vlan, flags, destid, options);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_vlan_destination_add", 6, 3, unit, port, vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_vlan_destination_get( \
    int unit, bcm_port_t port, bcm_vlan_t vlan, uint32 flags, uint32 mirror_dest_size, bcm_gport_t *destid, uint32 *destcount, bcm_mirror_options_t *options);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_vlan_destination_get,
static int (*_mirror_port_vlan_destination_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    uint32 flags, 
    uint32 mirror_dest_size, 
    bcm_gport_t *destid, 
    uint32 *destcount, 
    bcm_mirror_options_t *options) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_vlan_destination_get(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    uint32 flags, 
    uint32 mirror_dest_size, 
    bcm_gport_t *destid, 
    uint32 *destcount, 
    bcm_mirror_options_t *options)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_vlan_destination_get_dispatch[dtype](unit, port, vlan, flags, mirror_dest_size, destid, destcount, options);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(mirror_dest_size,idx)
				BCM_API_XLATE_PORT_COND(destid) BCM_API_XLATE_PORT_P2A(unit,&(destid)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_vlan_destination_get", 8, 3, unit, port, vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_vlan_get( \
    int unit, bcm_port_t port, bcm_vlan_t vlan, bcm_gport_t *dest_port, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_vlan_get,
static int (*_mirror_port_vlan_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    bcm_gport_t *dest_port, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_vlan_get(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    bcm_gport_t *dest_port, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_vlan_get_dispatch[dtype](unit, port, vlan, dest_port, flags);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_vlan_get", 5, 3, unit, port, vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_port_vlan_set( \
    int unit, bcm_port_t port, bcm_vlan_t vlan, bcm_gport_t destport, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_port_vlan_set,
static int (*_mirror_port_vlan_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    bcm_gport_t destport, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_port_vlan_set(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    bcm_gport_t destport, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&destport);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_port_vlan_set_dispatch[dtype](unit, port, vlan, destport, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_port_vlan_set", 5, 3, unit, port, vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_to_get( \
    int unit, bcm_port_t *port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_to_get,
static int (*_mirror_to_get_dispatch[])(
    int unit, 
    bcm_port_t *port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_to_get(
    int unit, 
    bcm_port_t *port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_to_get_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_to_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_to_pbmp_get( \
    int unit, bcm_port_t port, bcm_pbmp_t *pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_to_pbmp_get,
static int (*_mirror_to_pbmp_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_pbmp_t *pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_to_pbmp_get(
    int unit, 
    bcm_port_t port, 
    bcm_pbmp_t *pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_to_pbmp_get_dispatch[dtype](unit, port, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_to_pbmp_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_to_pbmp_set( \
    int unit, bcm_port_t port, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_to_pbmp_set,
static int (*_mirror_to_pbmp_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_to_pbmp_set(
    int unit, 
    bcm_port_t port, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_to_pbmp_set_dispatch[dtype](unit, port, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_to_pbmp_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_to_set( \
    int unit, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_to_set,
static int (*_mirror_to_set_dispatch[])(
    int unit, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_to_set(
    int unit, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_to_set_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_to_set", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_vlan_get( \
    int unit, bcm_port_t port, uint16 *tpid, uint16 *vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_vlan_get,
static int (*_mirror_vlan_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint16 *tpid, 
    uint16 *vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_vlan_get(
    int unit, 
    bcm_port_t port, 
    uint16 *tpid, 
    uint16 *vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_vlan_get_dispatch[dtype](unit, port, tpid, vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_vlan_get", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mirror_vlan_set( \
    int unit, bcm_port_t port, uint16 tpid, uint16 vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mirror_vlan_set,
static int (*_mirror_vlan_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint16 tpid, 
    uint16 vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mirror_vlan_set(
    int unit, 
    bcm_port_t port, 
    uint16 tpid, 
    uint16 vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mirror_vlan_set_dispatch[dtype](unit, port, tpid, vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mirror_vlan_set", 4, 3, unit, port, tpid, r_rv);
	return r_rv;
}

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_cleanup( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_cleanup,
static int (*_mpls_cleanup_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_cleanup(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_cleanup_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_cleanup", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_exp_map_create( \
    int unit, uint32 flags, int *exp_map_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_exp_map_create,
static int (*_mpls_exp_map_create_dispatch[])(
    int unit, 
    uint32 flags, 
    int *exp_map_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_exp_map_create(
    int unit, 
    uint32 flags, 
    int *exp_map_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_exp_map_create_dispatch[dtype](unit, flags, exp_map_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_exp_map_create", 3, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_exp_map_destroy( \
    int unit, int exp_map_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_exp_map_destroy,
static int (*_mpls_exp_map_destroy_dispatch[])(
    int unit, 
    int exp_map_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_exp_map_destroy(
    int unit, 
    int exp_map_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_exp_map_destroy_dispatch[dtype](unit, exp_map_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_exp_map_destroy", 2, 2, unit, exp_map_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_exp_map_get( \
    int unit, int exp_map_id, bcm_mpls_exp_map_t *exp_map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_exp_map_get,
static int (*_mpls_exp_map_get_dispatch[])(
    int unit, 
    int exp_map_id, 
    bcm_mpls_exp_map_t *exp_map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_exp_map_get(
    int unit, 
    int exp_map_id, 
    bcm_mpls_exp_map_t *exp_map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_exp_map_get_dispatch[dtype](unit, exp_map_id, exp_map);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_exp_map_get", 3, 2, unit, exp_map_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_exp_map_set( \
    int unit, int exp_map_id, bcm_mpls_exp_map_t *exp_map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_exp_map_set,
static int (*_mpls_exp_map_set_dispatch[])(
    int unit, 
    int exp_map_id, 
    bcm_mpls_exp_map_t *exp_map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_exp_map_set(
    int unit, 
    int exp_map_id, 
    bcm_mpls_exp_map_t *exp_map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_exp_map_set_dispatch[dtype](unit, exp_map_id, exp_map);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_exp_map_set", 3, 2, unit, exp_map_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_init,
static int (*_mpls_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_label_stat_attach( \
    int unit, bcm_mpls_label_t label, bcm_gport_t port, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_label_stat_attach,
static int (*_mpls_label_stat_attach_dispatch[])(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_label_stat_attach(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_label_stat_attach_dispatch[dtype](unit, label, port, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_label_stat_attach", 4, 3, unit, label, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_label_stat_clear( \
    int unit, bcm_mpls_label_t label, bcm_gport_t port, bcm_mpls_stat_t stat);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_label_stat_clear,
static int (*_mpls_label_stat_clear_dispatch[])(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_label_stat_clear(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_label_stat_clear_dispatch[dtype](unit, label, port, stat);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_label_stat_clear", 4, 3, unit, label, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_label_stat_counter_get( \
    int unit, bcm_mpls_label_t label, bcm_gport_t port, bcm_mpls_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_label_stat_counter_get,
static int (*_mpls_label_stat_counter_get_dispatch[])(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_label_stat_counter_get(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_label_stat_counter_get_dispatch[dtype](unit, label, port, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_label_stat_counter_get", 7, 3, unit, label, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_label_stat_counter_set( \
    int unit, bcm_mpls_label_t label, bcm_gport_t port, bcm_mpls_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_label_stat_counter_set,
static int (*_mpls_label_stat_counter_set_dispatch[])(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_label_stat_counter_set(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_label_stat_counter_set_dispatch[dtype](unit, label, port, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_label_stat_counter_set", 7, 3, unit, label, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_label_stat_counter_sync_get( \
    int unit, bcm_mpls_label_t label, bcm_gport_t port, bcm_mpls_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_label_stat_counter_sync_get,
static int (*_mpls_label_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_label_stat_counter_sync_get(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_label_stat_counter_sync_get_dispatch[dtype](unit, label, port, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_label_stat_counter_sync_get", 7, 3, unit, label, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_label_stat_detach( \
    int unit, bcm_mpls_label_t label, bcm_gport_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_label_stat_detach,
static int (*_mpls_label_stat_detach_dispatch[])(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_label_stat_detach(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_label_stat_detach_dispatch[dtype](unit, label, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_label_stat_detach", 3, 3, unit, label, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_label_stat_enable_set( \
    int unit, bcm_mpls_label_t label, bcm_gport_t port, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_label_stat_enable_set,
static int (*_mpls_label_stat_enable_set_dispatch[])(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_label_stat_enable_set(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_label_stat_enable_set_dispatch[dtype](unit, label, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_label_stat_enable_set", 4, 3, unit, label, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_label_stat_get( \
    int unit, bcm_mpls_label_t label, bcm_gport_t port, bcm_mpls_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_label_stat_get,
static int (*_mpls_label_stat_get_dispatch[])(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_label_stat_get(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_label_stat_get_dispatch[dtype](unit, label, port, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_label_stat_get", 5, 3, unit, label, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_label_stat_get32( \
    int unit, bcm_mpls_label_t label, bcm_gport_t port, bcm_mpls_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_label_stat_get32,
static int (*_mpls_label_stat_get32_dispatch[])(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_label_stat_get32(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_label_stat_get32_dispatch[dtype](unit, label, port, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_label_stat_get32", 5, 3, unit, label, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_label_stat_id_get( \
    int unit, bcm_mpls_label_t label, bcm_gport_t port, bcm_mpls_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_label_stat_id_get,
static int (*_mpls_label_stat_id_get_dispatch[])(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_label_stat_id_get(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_label_stat_id_get_dispatch[dtype](unit, label, port, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_label_stat_id_get", 5, 3, unit, label, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_label_stat_sync_get( \
    int unit, bcm_mpls_label_t label, bcm_gport_t port, bcm_mpls_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_label_stat_sync_get,
static int (*_mpls_label_stat_sync_get_dispatch[])(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_label_stat_sync_get(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_label_stat_sync_get_dispatch[dtype](unit, label, port, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_label_stat_sync_get", 5, 3, unit, label, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_label_stat_sync_get32( \
    int unit, bcm_mpls_label_t label, bcm_gport_t port, bcm_mpls_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_label_stat_sync_get32,
static int (*_mpls_label_stat_sync_get32_dispatch[])(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_label_stat_sync_get32(
    int unit, 
    bcm_mpls_label_t label, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_label_stat_sync_get32_dispatch[dtype](unit, label, port, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_label_stat_sync_get32", 5, 3, unit, label, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_add( \
    int unit, bcm_vpn_t vpn, bcm_mpls_port_t *mpls_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_add,
static int (*_mpls_port_add_dispatch[])(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_port_t *mpls_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_add(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_port_t *mpls_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_A2P(unit,&mpls_port->egress_failover_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_A2P(unit,&mpls_port->failover_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_A2P(unit,&mpls_port->mpls_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_A2P(unit,&mpls_port->per_flow_queue_base);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_A2P(unit,&mpls_port->port);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_A2P(unit,&mpls_port->pw_failover_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_A2P(unit,&mpls_port->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_add_dispatch[dtype](unit, vpn, mpls_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_P2A(unit,&mpls_port->egress_failover_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_P2A(unit,&mpls_port->failover_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_P2A(unit,&mpls_port->mpls_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_P2A(unit,&mpls_port->per_flow_queue_base);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_P2A(unit,&mpls_port->port);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_P2A(unit,&mpls_port->pw_failover_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_P2A(unit,&mpls_port->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_add", 3, 2, unit, vpn, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_delete( \
    int unit, bcm_vpn_t vpn, bcm_gport_t mpls_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_delete,
static int (*_mpls_port_delete_dispatch[])(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t mpls_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_delete(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t mpls_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mpls_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_delete_dispatch[dtype](unit, vpn, mpls_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_delete", 3, 3, unit, vpn, mpls_port_id, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_delete_all( \
    int unit, bcm_vpn_t vpn);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_delete_all,
static int (*_mpls_port_delete_all_dispatch[])(
    int unit, 
    bcm_vpn_t vpn) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_delete_all(
    int unit, 
    bcm_vpn_t vpn)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_delete_all_dispatch[dtype](unit, vpn);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_delete_all", 2, 2, unit, vpn, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_get( \
    int unit, bcm_vpn_t vpn, bcm_mpls_port_t *mpls_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_get,
static int (*_mpls_port_get_dispatch[])(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_port_t *mpls_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_get(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_port_t *mpls_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_A2P(unit,&mpls_port->egress_failover_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_A2P(unit,&mpls_port->failover_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_A2P(unit,&mpls_port->mpls_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_A2P(unit,&mpls_port->per_flow_queue_base);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_A2P(unit,&mpls_port->port);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_A2P(unit,&mpls_port->pw_failover_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_A2P(unit,&mpls_port->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_get_dispatch[dtype](unit, vpn, mpls_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_P2A(unit,&mpls_port->egress_failover_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_P2A(unit,&mpls_port->failover_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_P2A(unit,&mpls_port->mpls_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_P2A(unit,&mpls_port->per_flow_queue_base);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_P2A(unit,&mpls_port->port);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_P2A(unit,&mpls_port->pw_failover_port_id);
		BCM_API_XLATE_PORT_COND(mpls_port) BCM_API_XLATE_PORT_P2A(unit,&mpls_port->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_get", 3, 2, unit, vpn, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_get_all( \
    int unit, bcm_vpn_t vpn, int port_max, bcm_mpls_port_t *port_array, int *port_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_get_all,
static int (*_mpls_port_get_all_dispatch[])(
    int unit, 
    bcm_vpn_t vpn, 
    int port_max, 
    bcm_mpls_port_t *port_array, 
    int *port_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_get_all(
    int unit, 
    bcm_vpn_t vpn, 
    int port_max, 
    bcm_mpls_port_t *port_array, 
    int *port_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_get_all_dispatch[dtype](unit, vpn, port_max, port_array, port_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].egress_failover_port_id);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].failover_port_id);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].mpls_port_id);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].per_flow_queue_base);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].port);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].pw_failover_port_id);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_get_all", 5, 3, unit, vpn, port_max, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_stat_attach( \
    int unit, bcm_vpn_t vpn, bcm_gport_t port, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_stat_attach,
static int (*_mpls_port_stat_attach_dispatch[])(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_stat_attach(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_stat_attach_dispatch[dtype](unit, vpn, port, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_stat_attach", 4, 3, unit, vpn, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_stat_counter_get( \
    int unit, bcm_vpn_t vpn, bcm_gport_t port, bcm_mpls_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_stat_counter_get,
static int (*_mpls_port_stat_counter_get_dispatch[])(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_stat_counter_get(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_stat_counter_get_dispatch[dtype](unit, vpn, port, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_stat_counter_get", 7, 3, unit, vpn, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_stat_counter_set( \
    int unit, bcm_vpn_t vpn, bcm_gport_t port, bcm_mpls_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_stat_counter_set,
static int (*_mpls_port_stat_counter_set_dispatch[])(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_stat_counter_set(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_stat_counter_set_dispatch[dtype](unit, vpn, port, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_stat_counter_set", 7, 3, unit, vpn, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_stat_counter_sync_get( \
    int unit, bcm_vpn_t vpn, bcm_gport_t port, bcm_mpls_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_stat_counter_sync_get,
static int (*_mpls_port_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_stat_counter_sync_get(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_stat_counter_sync_get_dispatch[dtype](unit, vpn, port, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_stat_counter_sync_get", 7, 3, unit, vpn, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_stat_detach( \
    int unit, bcm_vpn_t vpn, bcm_gport_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_stat_detach,
static int (*_mpls_port_stat_detach_dispatch[])(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_stat_detach(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_stat_detach_dispatch[dtype](unit, vpn, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_stat_detach", 3, 3, unit, vpn, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_stat_enable_set( \
    int unit, bcm_gport_t mpls_port, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_stat_enable_set,
static int (*_mpls_port_stat_enable_set_dispatch[])(
    int unit, 
    bcm_gport_t mpls_port, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_stat_enable_set(
    int unit, 
    bcm_gport_t mpls_port, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mpls_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_stat_enable_set_dispatch[dtype](unit, mpls_port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_stat_enable_set", 3, 3, unit, mpls_port, enable, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_stat_get( \
    int unit, bcm_gport_t mpls_port, bcm_cos_t cos, bcm_mpls_port_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_stat_get,
static int (*_mpls_port_stat_get_dispatch[])(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_stat_get(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mpls_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_stat_get_dispatch[dtype](unit, mpls_port, cos, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_stat_get", 5, 3, unit, mpls_port, cos, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_stat_get32( \
    int unit, bcm_gport_t mpls_port, bcm_cos_t cos, bcm_mpls_port_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_stat_get32,
static int (*_mpls_port_stat_get32_dispatch[])(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_stat_get32(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mpls_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_stat_get32_dispatch[dtype](unit, mpls_port, cos, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_stat_get32", 5, 3, unit, mpls_port, cos, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_stat_id_get( \
    int unit, bcm_vpn_t vpn, bcm_gport_t port, bcm_mpls_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_stat_id_get,
static int (*_mpls_port_stat_id_get_dispatch[])(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_stat_id_get(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_gport_t port, 
    bcm_mpls_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_stat_id_get_dispatch[dtype](unit, vpn, port, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_stat_id_get", 5, 3, unit, vpn, port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_stat_set( \
    int unit, bcm_gport_t mpls_port, bcm_cos_t cos, bcm_mpls_port_stat_t stat, uint64 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_stat_set,
static int (*_mpls_port_stat_set_dispatch[])(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint64 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_stat_set(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint64 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mpls_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_stat_set_dispatch[dtype](unit, mpls_port, cos, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_stat_set", 5, 3, unit, mpls_port, cos, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_port_stat_set32( \
    int unit, bcm_gport_t mpls_port, bcm_cos_t cos, bcm_mpls_port_stat_t stat, uint32 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_port_stat_set32,
static int (*_mpls_port_stat_set32_dispatch[])(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint32 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_port_stat_set32(
    int unit, 
    bcm_gport_t mpls_port, 
    bcm_cos_t cos, 
    bcm_mpls_port_stat_t stat, 
    uint32 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&mpls_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_port_stat_set32_dispatch[dtype](unit, mpls_port, cos, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_port_stat_set32", 5, 3, unit, mpls_port, cos, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_tunnel_initiator_clear( \
    int unit, bcm_if_t intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_tunnel_initiator_clear,
static int (*_mpls_tunnel_initiator_clear_dispatch[])(
    int unit, 
    bcm_if_t intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_tunnel_initiator_clear(
    int unit, 
    bcm_if_t intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_tunnel_initiator_clear_dispatch[dtype](unit, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_tunnel_initiator_clear", 2, 2, unit, intf, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_tunnel_initiator_clear_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_tunnel_initiator_clear_all,
static int (*_mpls_tunnel_initiator_clear_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_tunnel_initiator_clear_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_tunnel_initiator_clear_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_tunnel_initiator_clear_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_tunnel_initiator_create( \
    int unit, bcm_if_t intf, int num_labels, bcm_mpls_egress_label_t *label_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_tunnel_initiator_create,
static int (*_mpls_tunnel_initiator_create_dispatch[])(
    int unit, 
    bcm_if_t intf, 
    int num_labels, 
    bcm_mpls_egress_label_t *label_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_tunnel_initiator_create(
    int unit, 
    bcm_if_t intf, 
    int num_labels, 
    bcm_mpls_egress_label_t *label_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_tunnel_initiator_create_dispatch[dtype](unit, intf, num_labels, label_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_tunnel_initiator_create", 4, 3, unit, intf, num_labels, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_tunnel_initiator_get( \
    int unit, bcm_if_t intf, int label_max, bcm_mpls_egress_label_t *label_array, int *label_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_tunnel_initiator_get,
static int (*_mpls_tunnel_initiator_get_dispatch[])(
    int unit, 
    bcm_if_t intf, 
    int label_max, 
    bcm_mpls_egress_label_t *label_array, 
    int *label_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_tunnel_initiator_get(
    int unit, 
    bcm_if_t intf, 
    int label_max, 
    bcm_mpls_egress_label_t *label_array, 
    int *label_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_tunnel_initiator_get_dispatch[dtype](unit, intf, label_max, label_array, label_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_tunnel_initiator_get", 5, 3, unit, intf, label_max, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_tunnel_initiator_set( \
    int unit, bcm_if_t intf, int num_labels, bcm_mpls_egress_label_t *label_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_tunnel_initiator_set,
static int (*_mpls_tunnel_initiator_set_dispatch[])(
    int unit, 
    bcm_if_t intf, 
    int num_labels, 
    bcm_mpls_egress_label_t *label_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_tunnel_initiator_set(
    int unit, 
    bcm_if_t intf, 
    int num_labels, 
    bcm_mpls_egress_label_t *label_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_tunnel_initiator_set_dispatch[dtype](unit, intf, num_labels, label_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_tunnel_initiator_set", 4, 3, unit, intf, num_labels, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_tunnel_switch_add( \
    int unit, bcm_mpls_tunnel_switch_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_tunnel_switch_add,
static int (*_mpls_tunnel_switch_add_dispatch[])(
    int unit, 
    bcm_mpls_tunnel_switch_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_tunnel_switch_add(
    int unit, 
    bcm_mpls_tunnel_switch_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_egress_port);
		BCM_API_XLATE_PORT_DECL(info_failover_tunnel_id);
		BCM_API_XLATE_PORT_DECL(info_port);
		BCM_API_XLATE_PORT_DECL(info_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_egress_port,info->egress_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->egress_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_failover_tunnel_id,info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_port,info->port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_tunnel_id,info->tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_tunnel_switch_add_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->egress_port,info_egress_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->failover_tunnel_id,info_failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->port,info_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->tunnel_id,info_tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_tunnel_switch_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_tunnel_switch_create( \
    int unit, bcm_mpls_tunnel_switch_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_tunnel_switch_create,
static int (*_mpls_tunnel_switch_create_dispatch[])(
    int unit, 
    bcm_mpls_tunnel_switch_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_tunnel_switch_create(
    int unit, 
    bcm_mpls_tunnel_switch_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->egress_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_tunnel_switch_create_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->egress_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_tunnel_switch_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_tunnel_switch_delete( \
    int unit, bcm_mpls_tunnel_switch_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_tunnel_switch_delete,
static int (*_mpls_tunnel_switch_delete_dispatch[])(
    int unit, 
    bcm_mpls_tunnel_switch_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_tunnel_switch_delete(
    int unit, 
    bcm_mpls_tunnel_switch_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_egress_port);
		BCM_API_XLATE_PORT_DECL(info_failover_tunnel_id);
		BCM_API_XLATE_PORT_DECL(info_port);
		BCM_API_XLATE_PORT_DECL(info_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_egress_port,info->egress_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->egress_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_failover_tunnel_id,info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_port,info->port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_tunnel_id,info->tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_tunnel_switch_delete_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->egress_port,info_egress_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->failover_tunnel_id,info_failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->port,info_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->tunnel_id,info_tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_tunnel_switch_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_tunnel_switch_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_tunnel_switch_delete_all,
static int (*_mpls_tunnel_switch_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_tunnel_switch_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_tunnel_switch_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_tunnel_switch_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_tunnel_switch_get( \
    int unit, bcm_mpls_tunnel_switch_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_tunnel_switch_get,
static int (*_mpls_tunnel_switch_get_dispatch[])(
    int unit, 
    bcm_mpls_tunnel_switch_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_tunnel_switch_get(
    int unit, 
    bcm_mpls_tunnel_switch_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->egress_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_tunnel_switch_get_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->egress_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_tunnel_switch_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_tunnel_switch_traverse( \
    int unit, bcm_mpls_tunnel_switch_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_tunnel_switch_traverse,
static int (*_mpls_tunnel_switch_traverse_dispatch[])(
    int unit, 
    bcm_mpls_tunnel_switch_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_tunnel_switch_traverse(
    int unit, 
    bcm_mpls_tunnel_switch_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_tunnel_switch_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_tunnel_switch_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_vpn_id_create( \
    int unit, bcm_mpls_vpn_config_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_vpn_id_create,
static int (*_mpls_vpn_id_create_dispatch[])(
    int unit, 
    bcm_mpls_vpn_config_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_vpn_id_create(
    int unit, 
    bcm_mpls_vpn_config_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_vpn_id_create_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_vpn_id_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_vpn_id_destroy( \
    int unit, bcm_vpn_t vpn);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_vpn_id_destroy,
static int (*_mpls_vpn_id_destroy_dispatch[])(
    int unit, 
    bcm_vpn_t vpn) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_vpn_id_destroy(
    int unit, 
    bcm_vpn_t vpn)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_vpn_id_destroy_dispatch[dtype](unit, vpn);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_vpn_id_destroy", 2, 2, unit, vpn, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_vpn_id_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_vpn_id_destroy_all,
static int (*_mpls_vpn_id_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_vpn_id_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_vpn_id_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_vpn_id_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_vpn_id_get( \
    int unit, bcm_vpn_t vpn, bcm_mpls_vpn_config_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_vpn_id_get,
static int (*_mpls_vpn_id_get_dispatch[])(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_vpn_config_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_vpn_id_get(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_mpls_vpn_config_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_vpn_id_get_dispatch[dtype](unit, vpn, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_vpn_id_get", 3, 2, unit, vpn, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_mpls_vpn_traverse( \
    int unit, bcm_mpls_vpn_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_mpls_vpn_traverse,
static int (*_mpls_vpn_traverse_dispatch[])(
    int unit, 
    bcm_mpls_vpn_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_mpls_vpn_traverse(
    int unit, 
    bcm_mpls_vpn_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _mpls_vpn_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_mpls_vpn_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_add( \
    int unit, bcm_multicast_t group, uint32 flags, int nof_replications, bcm_multicast_replication_t *rep_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_add,
static int (*_multicast_add_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    uint32 flags, 
    int nof_replications, 
    bcm_multicast_replication_t *rep_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_add(
    int unit, 
    bcm_multicast_t group, 
    uint32 flags, 
    int nof_replications, 
    bcm_multicast_replication_t *rep_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(rep_array_port);
		BCM_API_XLATE_PORT_COND(rep_array) BCM_API_XLATE_PORT_SAVE(rep_array_port,rep_array->port);
		BCM_API_XLATE_PORT_COND(rep_array) BCM_API_XLATE_PORT_A2P(unit,&rep_array->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_add_dispatch[dtype](unit, group, flags, nof_replications, rep_array);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(rep_array) BCM_API_XLATE_PORT_RESTORE(rep_array->port,rep_array_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_add", 5, 3, unit, group, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_control_get( \
    int unit, bcm_multicast_t group, bcm_multicast_control_t type, int *arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_control_get,
static int (*_multicast_control_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_multicast_control_t type, 
    int *arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_control_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_multicast_control_t type, 
    int *arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_control_get_dispatch[dtype](unit, group, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_control_get", 4, 3, unit, group, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_control_set( \
    int unit, bcm_multicast_t group, bcm_multicast_control_t type, int arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_control_set,
static int (*_multicast_control_set_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_multicast_control_t type, 
    int arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_control_set(
    int unit, 
    bcm_multicast_t group, 
    bcm_multicast_control_t type, 
    int arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_control_set_dispatch[dtype](unit, group, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_control_set", 4, 3, unit, group, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_create( \
    int unit, uint32 flags, bcm_multicast_t *group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_create,
static int (*_multicast_create_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_multicast_t *group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_create(
    int unit, 
    uint32 flags, 
    bcm_multicast_t *group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_create_dispatch[dtype](unit, flags, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_create", 3, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_delete( \
    int unit, bcm_multicast_t group, uint32 flags, int nof_replications, bcm_multicast_replication_t *rep_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_delete,
static int (*_multicast_delete_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    uint32 flags, 
    int nof_replications, 
    bcm_multicast_replication_t *rep_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_delete(
    int unit, 
    bcm_multicast_t group, 
    uint32 flags, 
    int nof_replications, 
    bcm_multicast_replication_t *rep_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(rep_array_port);
		BCM_API_XLATE_PORT_COND(rep_array) BCM_API_XLATE_PORT_SAVE(rep_array_port,rep_array->port);
		BCM_API_XLATE_PORT_COND(rep_array) BCM_API_XLATE_PORT_A2P(unit,&rep_array->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_delete_dispatch[dtype](unit, group, flags, nof_replications, rep_array);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(rep_array) BCM_API_XLATE_PORT_RESTORE(rep_array->port,rep_array_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_delete", 5, 3, unit, group, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_destroy( \
    int unit, bcm_multicast_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_destroy,
static int (*_multicast_destroy_dispatch[])(
    int unit, 
    bcm_multicast_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_destroy(
    int unit, 
    bcm_multicast_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_destroy_dispatch[dtype](unit, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_destroy", 2, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_detach,
static int (*_multicast_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_egress_add( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_if_t encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_egress_add,
static int (*_multicast_egress_add_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_egress_add(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_egress_add_dispatch[dtype](unit, group, port, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_egress_add", 4, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_egress_delete( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_if_t encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_egress_delete,
static int (*_multicast_egress_delete_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_egress_delete(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_egress_delete_dispatch[dtype](unit, group, port, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_egress_delete", 4, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_egress_delete_all( \
    int unit, bcm_multicast_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_egress_delete_all,
static int (*_multicast_egress_delete_all_dispatch[])(
    int unit, 
    bcm_multicast_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_egress_delete_all(
    int unit, 
    bcm_multicast_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_egress_delete_all_dispatch[dtype](unit, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_egress_delete_all", 2, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_egress_get( \
    int unit, bcm_multicast_t group, int port_max, bcm_gport_t *port_array, bcm_if_t *encap_id_array, int *port_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_egress_get,
static int (*_multicast_egress_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    int port_max, 
    bcm_gport_t *port_array, 
    bcm_if_t *encap_id_array, 
    int *port_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_egress_get(
    int unit, 
    bcm_multicast_t group, 
    int port_max, 
    bcm_gport_t *port_array, 
    bcm_if_t *encap_id_array, 
    int *port_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_egress_get_dispatch[dtype](unit, group, port_max, port_array, encap_id_array, port_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_egress_get", 6, 3, unit, group, port_max, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_egress_object_encap_get( \
    int unit, bcm_multicast_t group, bcm_if_t intf, bcm_if_t *encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_egress_object_encap_get,
static int (*_multicast_egress_object_encap_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_if_t intf, 
    bcm_if_t *encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_egress_object_encap_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_if_t intf, 
    bcm_if_t *encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_egress_object_encap_get_dispatch[dtype](unit, group, intf, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_egress_object_encap_get", 4, 3, unit, group, intf, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_egress_set( \
    int unit, bcm_multicast_t group, int port_count, bcm_gport_t *port_array, bcm_if_t *encap_id_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_egress_set,
static int (*_multicast_egress_set_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    int port_count, 
    bcm_gport_t *port_array, 
    bcm_if_t *encap_id_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_egress_set(
    int unit, 
    bcm_multicast_t group, 
    int port_count, 
    bcm_gport_t *port_array, 
    bcm_if_t *encap_id_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_ITER(port_count,idx)
			BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_A2P(unit,&(port_array)[idx]);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_egress_set_dispatch[dtype](unit, group, port_count, port_array, encap_id_array);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_ITER(port_count,idx)
			BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_egress_set", 5, 3, unit, group, port_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_egress_subscriber_add( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_if_t encap_id, bcm_gport_t subscriber_queue);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_egress_subscriber_add,
static int (*_multicast_egress_subscriber_add_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t encap_id, 
    bcm_gport_t subscriber_queue) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_egress_subscriber_add(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t encap_id, 
    bcm_gport_t subscriber_queue)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&subscriber_queue);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_egress_subscriber_add_dispatch[dtype](unit, group, port, encap_id, subscriber_queue);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_egress_subscriber_add", 5, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_egress_subscriber_delete( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_if_t encap_id, bcm_gport_t subscriber_queue);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_egress_subscriber_delete,
static int (*_multicast_egress_subscriber_delete_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t encap_id, 
    bcm_gport_t subscriber_queue) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_egress_subscriber_delete(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t encap_id, 
    bcm_gport_t subscriber_queue)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&subscriber_queue);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_egress_subscriber_delete_dispatch[dtype](unit, group, port, encap_id, subscriber_queue);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_egress_subscriber_delete", 5, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_egress_subscriber_get( \
    int unit, bcm_multicast_t group, int port_max, bcm_gport_t *port_array, bcm_if_t *encap_id_array, bcm_gport_t *subscriber_queue_array, int *port_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_egress_subscriber_get,
static int (*_multicast_egress_subscriber_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    int port_max, 
    bcm_gport_t *port_array, 
    bcm_if_t *encap_id_array, 
    bcm_gport_t *subscriber_queue_array, 
    int *port_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_egress_subscriber_get(
    int unit, 
    bcm_multicast_t group, 
    int port_max, 
    bcm_gport_t *port_array, 
    bcm_if_t *encap_id_array, 
    bcm_gport_t *subscriber_queue_array, 
    int *port_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_egress_subscriber_get_dispatch[dtype](unit, group, port_max, port_array, encap_id_array, subscriber_queue_array, port_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx]);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(subscriber_queue_array) BCM_API_XLATE_PORT_P2A(unit,&(subscriber_queue_array)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_egress_subscriber_get", 7, 3, unit, group, port_max, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_egress_subscriber_set( \
    int unit, bcm_multicast_t group, int port_count, bcm_gport_t *port_array, bcm_if_t *encap_id_array, bcm_gport_t *subscriber_queue_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_egress_subscriber_set,
static int (*_multicast_egress_subscriber_set_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    int port_count, 
    bcm_gport_t *port_array, 
    bcm_if_t *encap_id_array, 
    bcm_gport_t *subscriber_queue_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_egress_subscriber_set(
    int unit, 
    bcm_multicast_t group, 
    int port_count, 
    bcm_gport_t *port_array, 
    bcm_if_t *encap_id_array, 
    bcm_gport_t *subscriber_queue_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_ITER(port_count,idx)
			BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_A2P(unit,&(port_array)[idx]);
		BCM_API_XLATE_PORT_ITER(port_count,idx)
			BCM_API_XLATE_PORT_COND(subscriber_queue_array) BCM_API_XLATE_PORT_A2P(unit,&(subscriber_queue_array)[idx]);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_egress_subscriber_set_dispatch[dtype](unit, group, port_count, port_array, encap_id_array, subscriber_queue_array);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_ITER(port_count,idx)
			BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx]);
		BCM_API_XLATE_PORT_ITER(port_count,idx)
			BCM_API_XLATE_PORT_COND(subscriber_queue_array) BCM_API_XLATE_PORT_P2A(unit,&(subscriber_queue_array)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_egress_subscriber_set", 6, 3, unit, group, port_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_extender_encap_get( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_gport_t extender_port_id, bcm_if_t *encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_extender_encap_get,
static int (*_multicast_extender_encap_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t extender_port_id, 
    bcm_if_t *encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_extender_encap_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t extender_port_id, 
    bcm_if_t *encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&extender_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_extender_encap_get_dispatch[dtype](unit, group, port, extender_port_id, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_extender_encap_get", 5, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_fabric_distribution_get( \
    int unit, bcm_multicast_t group, bcm_fabric_distribution_t *ds_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_fabric_distribution_get,
static int (*_multicast_fabric_distribution_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_fabric_distribution_t *ds_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_fabric_distribution_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_fabric_distribution_t *ds_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_fabric_distribution_get_dispatch[dtype](unit, group, ds_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_fabric_distribution_get", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_fabric_distribution_set( \
    int unit, bcm_multicast_t group, bcm_fabric_distribution_t ds_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_fabric_distribution_set,
static int (*_multicast_fabric_distribution_set_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_fabric_distribution_t ds_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_fabric_distribution_set(
    int unit, 
    bcm_multicast_t group, 
    bcm_fabric_distribution_t ds_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_fabric_distribution_set_dispatch[dtype](unit, group, ds_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_fabric_distribution_set", 3, 3, unit, group, ds_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_get( \
    int unit, bcm_multicast_t group, uint32 flags, int replication_max, bcm_multicast_replication_t *out_rep_array, int *rep_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_get,
static int (*_multicast_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    uint32 flags, 
    int replication_max, 
    bcm_multicast_replication_t *out_rep_array, 
    int *rep_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_get(
    int unit, 
    bcm_multicast_t group, 
    uint32 flags, 
    int replication_max, 
    bcm_multicast_replication_t *out_rep_array, 
    int *rep_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_get_dispatch[dtype](unit, group, flags, replication_max, out_rep_array, rep_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(out_rep_array) BCM_API_XLATE_PORT_P2A(unit,&out_rep_array->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_get", 6, 3, unit, group, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_group_free_range_get( \
    int unit, uint32 type_flag, bcm_multicast_t *group_min, bcm_multicast_t *group_max);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_group_free_range_get,
static int (*_multicast_group_free_range_get_dispatch[])(
    int unit, 
    uint32 type_flag, 
    bcm_multicast_t *group_min, 
    bcm_multicast_t *group_max) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_group_free_range_get(
    int unit, 
    uint32 type_flag, 
    bcm_multicast_t *group_min, 
    bcm_multicast_t *group_max)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_group_free_range_get_dispatch[dtype](unit, type_flag, group_min, group_max);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_group_free_range_get", 4, 2, unit, type_flag, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_group_get( \
    int unit, bcm_multicast_t group, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_group_get,
static int (*_multicast_group_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_group_get(
    int unit, 
    bcm_multicast_t group, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_group_get_dispatch[dtype](unit, group, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_group_get", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_group_is_free( \
    int unit, bcm_multicast_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_group_is_free,
static int (*_multicast_group_is_free_dispatch[])(
    int unit, 
    bcm_multicast_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_group_is_free(
    int unit, 
    bcm_multicast_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_group_is_free_dispatch[dtype](unit, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_group_is_free", 2, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_group_traverse( \
    int unit, bcm_multicast_group_traverse_cb_t trav_fn, uint32 flags, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_group_traverse,
static int (*_multicast_group_traverse_dispatch[])(
    int unit, 
    bcm_multicast_group_traverse_cb_t trav_fn, 
    uint32 flags, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_group_traverse(
    int unit, 
    bcm_multicast_group_traverse_cb_t trav_fn, 
    uint32 flags, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_group_traverse_dispatch[dtype](unit, trav_fn, flags, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_group_traverse", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_ingress_add( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_if_t encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_ingress_add,
static int (*_multicast_ingress_add_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_ingress_add(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_ingress_add_dispatch[dtype](unit, group, port, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_ingress_add", 4, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_ingress_delete( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_if_t encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_ingress_delete,
static int (*_multicast_ingress_delete_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_ingress_delete(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_ingress_delete_dispatch[dtype](unit, group, port, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_ingress_delete", 4, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_ingress_delete_all( \
    int unit, bcm_multicast_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_ingress_delete_all,
static int (*_multicast_ingress_delete_all_dispatch[])(
    int unit, 
    bcm_multicast_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_ingress_delete_all(
    int unit, 
    bcm_multicast_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_ingress_delete_all_dispatch[dtype](unit, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_ingress_delete_all", 2, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_ingress_get( \
    int unit, bcm_multicast_t group, int port_max, bcm_gport_t *port_array, bcm_if_t *encap_id_array, int *port_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_ingress_get,
static int (*_multicast_ingress_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    int port_max, 
    bcm_gport_t *port_array, 
    bcm_if_t *encap_id_array, 
    int *port_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_ingress_get(
    int unit, 
    bcm_multicast_t group, 
    int port_max, 
    bcm_gport_t *port_array, 
    bcm_if_t *encap_id_array, 
    int *port_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_ingress_get_dispatch[dtype](unit, group, port_max, port_array, encap_id_array, port_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_ingress_get", 6, 3, unit, group, port_max, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_ingress_set( \
    int unit, bcm_multicast_t group, int port_count, bcm_gport_t *port_array, bcm_if_t *encap_id_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_ingress_set,
static int (*_multicast_ingress_set_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    int port_count, 
    bcm_gport_t *port_array, 
    bcm_if_t *encap_id_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_ingress_set(
    int unit, 
    bcm_multicast_t group, 
    int port_count, 
    bcm_gport_t *port_array, 
    bcm_if_t *encap_id_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_ITER(port_count,idx)
			BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_A2P(unit,&(port_array)[idx]);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_ingress_set_dispatch[dtype](unit, group, port_count, port_array, encap_id_array);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_ITER(port_count,idx)
			BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_ingress_set", 5, 3, unit, group, port_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_init,
static int (*_multicast_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_l2_encap_get( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_vlan_t vlan, bcm_if_t *encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_l2_encap_get,
static int (*_multicast_l2_encap_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_vlan_t vlan, 
    bcm_if_t *encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_l2_encap_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_vlan_t vlan, 
    bcm_if_t *encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_l2_encap_get_dispatch[dtype](unit, group, port, vlan, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_l2_encap_get", 5, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_l2gre_encap_get( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_gport_t l2gre_port_id, bcm_if_t *encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_l2gre_encap_get,
static int (*_multicast_l2gre_encap_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t l2gre_port_id, 
    bcm_if_t *encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_l2gre_encap_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t l2gre_port_id, 
    bcm_if_t *encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&l2gre_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_l2gre_encap_get_dispatch[dtype](unit, group, port, l2gre_port_id, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_l2gre_encap_get", 5, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_l3_encap_get( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_if_t intf, bcm_if_t *encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_l3_encap_get,
static int (*_multicast_l3_encap_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t intf, 
    bcm_if_t *encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_l3_encap_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t intf, 
    bcm_if_t *encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_l3_encap_get_dispatch[dtype](unit, group, port, intf, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_l3_encap_get", 5, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_mac_encap_get( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_gport_t mac_port_id, bcm_if_t *encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_mac_encap_get,
static int (*_multicast_mac_encap_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t mac_port_id, 
    bcm_if_t *encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_mac_encap_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t mac_port_id, 
    bcm_if_t *encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&mac_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_mac_encap_get_dispatch[dtype](unit, group, port, mac_port_id, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_mac_encap_get", 5, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_mim_encap_get( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_gport_t mim_port_id, bcm_if_t *encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_mim_encap_get,
static int (*_multicast_mim_encap_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t mim_port_id, 
    bcm_if_t *encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_mim_encap_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t mim_port_id, 
    bcm_if_t *encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&mim_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_mim_encap_get_dispatch[dtype](unit, group, port, mim_port_id, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_mim_encap_get", 5, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_niv_encap_get( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_gport_t niv_port_id, bcm_if_t *encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_niv_encap_get,
static int (*_multicast_niv_encap_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t niv_port_id, 
    bcm_if_t *encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_niv_encap_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t niv_port_id, 
    bcm_if_t *encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&niv_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_niv_encap_get_dispatch[dtype](unit, group, port, niv_port_id, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_niv_encap_get", 5, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_repl_get( \
    int unit, int index, bcm_port_t port, bcm_vlan_vector_t vlan_vec);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_repl_get,
static int (*_multicast_repl_get_dispatch[])(
    int unit, 
    int index, 
    bcm_port_t port, 
    bcm_vlan_vector_t vlan_vec) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_repl_get(
    int unit, 
    int index, 
    bcm_port_t port, 
    bcm_vlan_vector_t vlan_vec)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_repl_get_dispatch[dtype](unit, index, port, vlan_vec);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_repl_get", 4, 3, unit, index, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_repl_set( \
    int unit, int mc_index, bcm_port_t port, bcm_vlan_vector_t vlan_vec);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_repl_set,
static int (*_multicast_repl_set_dispatch[])(
    int unit, 
    int mc_index, 
    bcm_port_t port, 
    bcm_vlan_vector_t vlan_vec) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_repl_set(
    int unit, 
    int mc_index, 
    bcm_port_t port, 
    bcm_vlan_vector_t vlan_vec)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_repl_set_dispatch[dtype](unit, mc_index, port, vlan_vec);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_repl_set", 4, 3, unit, mc_index, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_set( \
    int unit, bcm_multicast_t group, uint32 flags, int nof_replications, bcm_multicast_replication_t *rep_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_set,
static int (*_multicast_set_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    uint32 flags, 
    int nof_replications, 
    bcm_multicast_replication_t *rep_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_set(
    int unit, 
    bcm_multicast_t group, 
    uint32 flags, 
    int nof_replications, 
    bcm_multicast_replication_t *rep_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(rep_array_port);
		BCM_API_XLATE_PORT_COND(rep_array) BCM_API_XLATE_PORT_SAVE(rep_array_port,rep_array->port);
		BCM_API_XLATE_PORT_COND(rep_array) BCM_API_XLATE_PORT_A2P(unit,&rep_array->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_set_dispatch[dtype](unit, group, flags, nof_replications, rep_array);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(rep_array) BCM_API_XLATE_PORT_RESTORE(rep_array->port,rep_array_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_set", 5, 3, unit, group, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_subport_encap_get( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_gport_t subport, bcm_if_t *encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_subport_encap_get,
static int (*_multicast_subport_encap_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t subport, 
    bcm_if_t *encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_subport_encap_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t subport, 
    bcm_if_t *encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&subport);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_subport_encap_get_dispatch[dtype](unit, group, port, subport, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_subport_encap_get", 5, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_trill_encap_get( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_if_t intf, bcm_if_t *encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_trill_encap_get,
static int (*_multicast_trill_encap_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t intf, 
    bcm_if_t *encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_trill_encap_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_if_t intf, 
    bcm_if_t *encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_trill_encap_get_dispatch[dtype](unit, group, port, intf, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_trill_encap_get", 5, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_vlan_encap_get( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_gport_t vlan_port_id, bcm_if_t *encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_vlan_encap_get,
static int (*_multicast_vlan_encap_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t vlan_port_id, 
    bcm_if_t *encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_vlan_encap_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t vlan_port_id, 
    bcm_if_t *encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&vlan_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_vlan_encap_get_dispatch[dtype](unit, group, port, vlan_port_id, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_vlan_encap_get", 5, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_vpls_encap_get( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_gport_t mpls_port_id, bcm_if_t *encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_vpls_encap_get,
static int (*_multicast_vpls_encap_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t mpls_port_id, 
    bcm_if_t *encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_vpls_encap_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t mpls_port_id, 
    bcm_if_t *encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&mpls_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_vpls_encap_get_dispatch[dtype](unit, group, port, mpls_port_id, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_vpls_encap_get", 5, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_vxlan_encap_get( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_gport_t vxlan_port_id, bcm_if_t *encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_vxlan_encap_get,
static int (*_multicast_vxlan_encap_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t vxlan_port_id, 
    bcm_if_t *encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_vxlan_encap_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t vxlan_port_id, 
    bcm_if_t *encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&vxlan_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_vxlan_encap_get_dispatch[dtype](unit, group, port, vxlan_port_id, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_vxlan_encap_get", 5, 3, unit, group, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_multicast_wlan_encap_get( \
    int unit, bcm_multicast_t group, bcm_gport_t port, bcm_gport_t wlan_port_id, bcm_if_t *encap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_multicast_wlan_encap_get,
static int (*_multicast_wlan_encap_get_dispatch[])(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t wlan_port_id, 
    bcm_if_t *encap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_multicast_wlan_encap_get(
    int unit, 
    bcm_multicast_t group, 
    bcm_gport_t port, 
    bcm_gport_t wlan_port_id, 
    bcm_if_t *encap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&wlan_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _multicast_wlan_encap_get_dispatch[dtype](unit, group, port, wlan_port_id, encap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_multicast_wlan_encap_get", 5, 3, unit, group, port, r_rv);
	return r_rv;
}

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_cleanup( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_cleanup,
static int (*_niv_cleanup_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_cleanup(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_cleanup_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_cleanup", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_egress_add( \
    int unit, bcm_gport_t niv_port, bcm_niv_egress_t *niv_egress);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_egress_add,
static int (*_niv_egress_add_dispatch[])(
    int unit, 
    bcm_gport_t niv_port, 
    bcm_niv_egress_t *niv_egress) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_egress_add(
    int unit, 
    bcm_gport_t niv_port, 
    bcm_niv_egress_t *niv_egress)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&niv_port);
		BCM_API_XLATE_PORT_COND(niv_egress) BCM_API_XLATE_PORT_A2P(unit,&niv_egress->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_egress_add_dispatch[dtype](unit, niv_port, niv_egress);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(niv_egress) BCM_API_XLATE_PORT_P2A(unit,&niv_egress->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_egress_add", 3, 2, unit, niv_port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_egress_delete( \
    int unit, bcm_gport_t niv_port, bcm_niv_egress_t *niv_egress);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_egress_delete,
static int (*_niv_egress_delete_dispatch[])(
    int unit, 
    bcm_gport_t niv_port, 
    bcm_niv_egress_t *niv_egress) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_egress_delete(
    int unit, 
    bcm_gport_t niv_port, 
    bcm_niv_egress_t *niv_egress)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(niv_egress_port);
		BCM_API_XLATE_PORT_A2P(unit,&niv_port);
		BCM_API_XLATE_PORT_COND(niv_egress) BCM_API_XLATE_PORT_SAVE(niv_egress_port,niv_egress->port);
		BCM_API_XLATE_PORT_COND(niv_egress) BCM_API_XLATE_PORT_A2P(unit,&niv_egress->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_egress_delete_dispatch[dtype](unit, niv_port, niv_egress);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(niv_egress) BCM_API_XLATE_PORT_RESTORE(niv_egress->port,niv_egress_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_egress_delete", 3, 2, unit, niv_port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_egress_delete_all( \
    int unit, bcm_gport_t niv_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_egress_delete_all,
static int (*_niv_egress_delete_all_dispatch[])(
    int unit, 
    bcm_gport_t niv_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_egress_delete_all(
    int unit, 
    bcm_gport_t niv_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&niv_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_egress_delete_all_dispatch[dtype](unit, niv_port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_egress_delete_all", 2, 2, unit, niv_port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_egress_get( \
    int unit, bcm_gport_t niv_port, int array_size, bcm_niv_egress_t *niv_egress_array, int *count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_egress_get,
static int (*_niv_egress_get_dispatch[])(
    int unit, 
    bcm_gport_t niv_port, 
    int array_size, 
    bcm_niv_egress_t *niv_egress_array, 
    int *count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_egress_get(
    int unit, 
    bcm_gport_t niv_port, 
    int array_size, 
    bcm_niv_egress_t *niv_egress_array, 
    int *count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_A2P(unit,&niv_port);
		BCM_API_XLATE_PORT_ITER(array_size,idx)
			BCM_API_XLATE_PORT_COND(niv_egress_array) BCM_API_XLATE_PORT_A2P(unit,&(niv_egress_array)[idx].port);
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_egress_get_dispatch[dtype](unit, niv_port, array_size, niv_egress_array, count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(array_size,idx)
				BCM_API_XLATE_PORT_COND(niv_egress_array) BCM_API_XLATE_PORT_P2A(unit,&(niv_egress_array)[idx].port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_egress_get", 5, 3, unit, niv_port, array_size, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_egress_set( \
    int unit, bcm_gport_t niv_port, int array_size, bcm_niv_egress_t *niv_egress_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_egress_set,
static int (*_niv_egress_set_dispatch[])(
    int unit, 
    bcm_gport_t niv_port, 
    int array_size, 
    bcm_niv_egress_t *niv_egress_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_egress_set(
    int unit, 
    bcm_gport_t niv_port, 
    int array_size, 
    bcm_niv_egress_t *niv_egress_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_A2P(unit,&niv_port);
		BCM_API_XLATE_PORT_ITER(array_size,idx)
			BCM_API_XLATE_PORT_COND(niv_egress_array) BCM_API_XLATE_PORT_A2P(unit,&(niv_egress_array)[idx].port);
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_egress_set_dispatch[dtype](unit, niv_port, array_size, niv_egress_array);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(array_size,idx)
				BCM_API_XLATE_PORT_COND(niv_egress_array) BCM_API_XLATE_PORT_P2A(unit,&(niv_egress_array)[idx].port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_egress_set", 4, 3, unit, niv_port, array_size, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_forward_add( \
    int unit, bcm_niv_forward_t *iv_fwd_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_forward_add,
static int (*_niv_forward_add_dispatch[])(
    int unit, 
    bcm_niv_forward_t *iv_fwd_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_forward_add(
    int unit, 
    bcm_niv_forward_t *iv_fwd_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(iv_fwd_entry_dest_port);
		BCM_API_XLATE_PORT_COND(iv_fwd_entry) BCM_API_XLATE_PORT_SAVE(iv_fwd_entry_dest_port,iv_fwd_entry->dest_port);
		BCM_API_XLATE_PORT_COND(iv_fwd_entry) BCM_API_XLATE_PORT_A2P(unit,&iv_fwd_entry->dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_forward_add_dispatch[dtype](unit, iv_fwd_entry);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(iv_fwd_entry) BCM_API_XLATE_PORT_RESTORE(iv_fwd_entry->dest_port,iv_fwd_entry_dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_forward_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_forward_delete( \
    int unit, bcm_niv_forward_t *iv_fwd_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_forward_delete,
static int (*_niv_forward_delete_dispatch[])(
    int unit, 
    bcm_niv_forward_t *iv_fwd_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_forward_delete(
    int unit, 
    bcm_niv_forward_t *iv_fwd_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(iv_fwd_entry_dest_port);
		BCM_API_XLATE_PORT_COND(iv_fwd_entry) BCM_API_XLATE_PORT_SAVE(iv_fwd_entry_dest_port,iv_fwd_entry->dest_port);
		BCM_API_XLATE_PORT_COND(iv_fwd_entry) BCM_API_XLATE_PORT_A2P(unit,&iv_fwd_entry->dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_forward_delete_dispatch[dtype](unit, iv_fwd_entry);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(iv_fwd_entry) BCM_API_XLATE_PORT_RESTORE(iv_fwd_entry->dest_port,iv_fwd_entry_dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_forward_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_forward_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_forward_delete_all,
static int (*_niv_forward_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_forward_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_forward_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_forward_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_forward_get( \
    int unit, bcm_niv_forward_t *iv_fwd_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_forward_get,
static int (*_niv_forward_get_dispatch[])(
    int unit, 
    bcm_niv_forward_t *iv_fwd_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_forward_get(
    int unit, 
    bcm_niv_forward_t *iv_fwd_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(iv_fwd_entry) BCM_API_XLATE_PORT_A2P(unit,&iv_fwd_entry->dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_forward_get_dispatch[dtype](unit, iv_fwd_entry);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(iv_fwd_entry) BCM_API_XLATE_PORT_P2A(unit,&iv_fwd_entry->dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_forward_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_forward_traverse( \
    int unit, bcm_niv_forward_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_forward_traverse,
static int (*_niv_forward_traverse_dispatch[])(
    int unit, 
    bcm_niv_forward_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_forward_traverse(
    int unit, 
    bcm_niv_forward_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_forward_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_forward_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_init,
static int (*_niv_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_port_add( \
    int unit, bcm_niv_port_t *niv_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_port_add,
static int (*_niv_port_add_dispatch[])(
    int unit, 
    bcm_niv_port_t *niv_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_port_add(
    int unit, 
    bcm_niv_port_t *niv_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(niv_port) BCM_API_XLATE_PORT_A2P(unit,&niv_port->niv_port_id);
		BCM_API_XLATE_PORT_COND(niv_port) BCM_API_XLATE_PORT_A2P(unit,&niv_port->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_port_add_dispatch[dtype](unit, niv_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(niv_port) BCM_API_XLATE_PORT_P2A(unit,&niv_port->niv_port_id);
		BCM_API_XLATE_PORT_COND(niv_port) BCM_API_XLATE_PORT_P2A(unit,&niv_port->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_port_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_port_delete( \
    int unit, bcm_gport_t niv_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_port_delete,
static int (*_niv_port_delete_dispatch[])(
    int unit, 
    bcm_gport_t niv_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_port_delete(
    int unit, 
    bcm_gport_t niv_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&niv_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_port_delete_dispatch[dtype](unit, niv_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_port_delete", 2, 2, unit, niv_port_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_port_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_port_delete_all,
static int (*_niv_port_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_port_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_port_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_port_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_port_get( \
    int unit, bcm_niv_port_t *niv_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_port_get,
static int (*_niv_port_get_dispatch[])(
    int unit, 
    bcm_niv_port_t *niv_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_port_get(
    int unit, 
    bcm_niv_port_t *niv_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(niv_port) BCM_API_XLATE_PORT_A2P(unit,&niv_port->niv_port_id);
		BCM_API_XLATE_PORT_COND(niv_port) BCM_API_XLATE_PORT_A2P(unit,&niv_port->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_port_get_dispatch[dtype](unit, niv_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(niv_port) BCM_API_XLATE_PORT_P2A(unit,&niv_port->niv_port_id);
		BCM_API_XLATE_PORT_COND(niv_port) BCM_API_XLATE_PORT_P2A(unit,&niv_port->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_port_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_niv_port_traverse( \
    int unit, bcm_niv_port_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_niv_port_traverse,
static int (*_niv_port_traverse_dispatch[])(
    int unit, 
    bcm_niv_port_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_niv_port_traverse(
    int unit, 
    bcm_niv_port_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _niv_port_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_niv_port_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_control_get( \
    int unit, bcm_oam_control_type_t type, uint64 *arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_control_get,
static int (*_oam_control_get_dispatch[])(
    int unit, 
    bcm_oam_control_type_t type, 
    uint64 *arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_control_get(
    int unit, 
    bcm_oam_control_type_t type, 
    uint64 *arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_control_get_dispatch[dtype](unit, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_control_get", 3, 2, unit, type, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_control_set( \
    int unit, bcm_oam_control_type_t type, uint64 arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_control_set,
static int (*_oam_control_set_dispatch[])(
    int unit, 
    bcm_oam_control_type_t type, 
    uint64 arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_control_set(
    int unit, 
    bcm_oam_control_type_t type, 
    uint64 arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_control_set_dispatch[dtype](unit, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_control_set", 3, 2, unit, type, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_delay_add( \
    int unit, bcm_oam_delay_t *delay_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_delay_add,
static int (*_oam_delay_add_dispatch[])(
    int unit, 
    bcm_oam_delay_t *delay_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_delay_add(
    int unit, 
    bcm_oam_delay_t *delay_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_delay_add_dispatch[dtype](unit, delay_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_delay_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_delay_delete( \
    int unit, bcm_oam_delay_t *delay_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_delay_delete,
static int (*_oam_delay_delete_dispatch[])(
    int unit, 
    bcm_oam_delay_t *delay_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_delay_delete(
    int unit, 
    bcm_oam_delay_t *delay_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_delay_delete_dispatch[dtype](unit, delay_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_delay_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_delay_get( \
    int unit, bcm_oam_delay_t *delay_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_delay_get,
static int (*_oam_delay_get_dispatch[])(
    int unit, 
    bcm_oam_delay_t *delay_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_delay_get(
    int unit, 
    bcm_oam_delay_t *delay_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_delay_get_dispatch[dtype](unit, delay_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_delay_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_detach,
static int (*_oam_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_endpoint_action_set( \
    int unit, bcm_oam_endpoint_t id, bcm_oam_endpoint_action_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_endpoint_action_set,
static int (*_oam_endpoint_action_set_dispatch[])(
    int unit, 
    bcm_oam_endpoint_t id, 
    bcm_oam_endpoint_action_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_endpoint_action_set(
    int unit, 
    bcm_oam_endpoint_t id, 
    bcm_oam_endpoint_action_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(action) BCM_API_XLATE_PORT_A2P(unit,&action->destination);
		BCM_API_XLATE_PORT_COND(action) BCM_API_XLATE_PORT_A2P(unit,&action->rx_trap);
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_endpoint_action_set_dispatch[dtype](unit, id, action);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(action) BCM_API_XLATE_PORT_P2A(unit,&action->destination);
		BCM_API_XLATE_PORT_COND(action) BCM_API_XLATE_PORT_P2A(unit,&action->rx_trap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_endpoint_action_set", 3, 2, unit, id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_endpoint_create( \
    int unit, bcm_oam_endpoint_info_t *endpoint_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_endpoint_create,
static int (*_oam_endpoint_create_dispatch[])(
    int unit, 
    bcm_oam_endpoint_info_t *endpoint_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_endpoint_create(
    int unit, 
    bcm_oam_endpoint_info_t *endpoint_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_A2P(unit,&endpoint_info->gport);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_A2P(unit,&endpoint_info->remote_gport);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_A2P(unit,&endpoint_info->tx_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_endpoint_create_dispatch[dtype](unit, endpoint_info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->gport);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->remote_gport);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->tx_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_endpoint_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_endpoint_destroy( \
    int unit, bcm_oam_endpoint_t endpoint);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_endpoint_destroy,
static int (*_oam_endpoint_destroy_dispatch[])(
    int unit, 
    bcm_oam_endpoint_t endpoint) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_endpoint_destroy(
    int unit, 
    bcm_oam_endpoint_t endpoint)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_endpoint_destroy_dispatch[dtype](unit, endpoint);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_endpoint_destroy", 2, 2, unit, endpoint, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_endpoint_destroy_all( \
    int unit, bcm_oam_group_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_endpoint_destroy_all,
static int (*_oam_endpoint_destroy_all_dispatch[])(
    int unit, 
    bcm_oam_group_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_endpoint_destroy_all(
    int unit, 
    bcm_oam_group_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_endpoint_destroy_all_dispatch[dtype](unit, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_endpoint_destroy_all", 2, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_endpoint_get( \
    int unit, bcm_oam_endpoint_t endpoint, bcm_oam_endpoint_info_t *endpoint_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_endpoint_get,
static int (*_oam_endpoint_get_dispatch[])(
    int unit, 
    bcm_oam_endpoint_t endpoint, 
    bcm_oam_endpoint_info_t *endpoint_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_endpoint_get(
    int unit, 
    bcm_oam_endpoint_t endpoint, 
    bcm_oam_endpoint_info_t *endpoint_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_endpoint_get_dispatch[dtype](unit, endpoint, endpoint_info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->gport);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->remote_gport);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->tx_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_endpoint_get", 3, 2, unit, endpoint, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_endpoint_traverse( \
    int unit, bcm_oam_group_t group, bcm_oam_endpoint_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_endpoint_traverse,
static int (*_oam_endpoint_traverse_dispatch[])(
    int unit, 
    bcm_oam_group_t group, 
    bcm_oam_endpoint_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_endpoint_traverse(
    int unit, 
    bcm_oam_group_t group, 
    bcm_oam_endpoint_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_endpoint_traverse_dispatch[dtype](unit, group, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_endpoint_traverse", 4, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_event_register( \
    int unit, bcm_oam_event_types_t event_types, bcm_oam_event_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_event_register,
static int (*_oam_event_register_dispatch[])(
    int unit, 
    bcm_oam_event_types_t event_types, 
    bcm_oam_event_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_event_register(
    int unit, 
    bcm_oam_event_types_t event_types, 
    bcm_oam_event_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_event_register_dispatch[dtype](unit, event_types, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_event_register", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_event_unregister( \
    int unit, bcm_oam_event_types_t event_types, bcm_oam_event_cb cb);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_event_unregister,
static int (*_oam_event_unregister_dispatch[])(
    int unit, 
    bcm_oam_event_types_t event_types, 
    bcm_oam_event_cb cb) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_event_unregister(
    int unit, 
    bcm_oam_event_types_t event_types, 
    bcm_oam_event_cb cb)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_event_unregister_dispatch[dtype](unit, event_types, cb);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_event_unregister", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_group_create( \
    int unit, bcm_oam_group_info_t *group_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_group_create,
static int (*_oam_group_create_dispatch[])(
    int unit, 
    bcm_oam_group_info_t *group_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_group_create(
    int unit, 
    bcm_oam_group_info_t *group_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_group_create_dispatch[dtype](unit, group_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_group_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_group_destroy( \
    int unit, bcm_oam_group_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_group_destroy,
static int (*_oam_group_destroy_dispatch[])(
    int unit, 
    bcm_oam_group_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_group_destroy(
    int unit, 
    bcm_oam_group_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_group_destroy_dispatch[dtype](unit, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_group_destroy", 2, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_group_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_group_destroy_all,
static int (*_oam_group_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_group_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_group_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_group_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_group_get( \
    int unit, bcm_oam_group_t group, bcm_oam_group_info_t *group_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_group_get,
static int (*_oam_group_get_dispatch[])(
    int unit, 
    bcm_oam_group_t group, 
    bcm_oam_group_info_t *group_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_group_get(
    int unit, 
    bcm_oam_group_t group, 
    bcm_oam_group_info_t *group_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_group_get_dispatch[dtype](unit, group, group_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_group_get", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_group_traverse( \
    int unit, bcm_oam_group_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_group_traverse,
static int (*_oam_group_traverse_dispatch[])(
    int unit, 
    bcm_oam_group_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_group_traverse(
    int unit, 
    bcm_oam_group_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_group_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_group_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_init,
static int (*_oam_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_loopback_add( \
    int unit, bcm_oam_loopback_t *loopback_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_loopback_add,
static int (*_oam_loopback_add_dispatch[])(
    int unit, 
    bcm_oam_loopback_t *loopback_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_loopback_add(
    int unit, 
    bcm_oam_loopback_t *loopback_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_loopback_add_dispatch[dtype](unit, loopback_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_loopback_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_loopback_delete( \
    int unit, bcm_oam_loopback_t *loopback_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_loopback_delete,
static int (*_oam_loopback_delete_dispatch[])(
    int unit, 
    bcm_oam_loopback_t *loopback_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_loopback_delete(
    int unit, 
    bcm_oam_loopback_t *loopback_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_loopback_delete_dispatch[dtype](unit, loopback_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_loopback_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_loopback_get( \
    int unit, bcm_oam_loopback_t *loopback_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_loopback_get,
static int (*_oam_loopback_get_dispatch[])(
    int unit, 
    bcm_oam_loopback_t *loopback_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_loopback_get(
    int unit, 
    bcm_oam_loopback_t *loopback_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_loopback_get_dispatch[dtype](unit, loopback_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_loopback_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_loss_add( \
    int unit, bcm_oam_loss_t *loss_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_loss_add,
static int (*_oam_loss_add_dispatch[])(
    int unit, 
    bcm_oam_loss_t *loss_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_loss_add(
    int unit, 
    bcm_oam_loss_t *loss_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(loss_ptr) BCM_API_XLATE_PORT_A2P(unit,&loss_ptr->gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_loss_add_dispatch[dtype](unit, loss_ptr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(loss_ptr) BCM_API_XLATE_PORT_P2A(unit,&loss_ptr->gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_loss_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_loss_delete( \
    int unit, bcm_oam_loss_t *loss_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_loss_delete,
static int (*_oam_loss_delete_dispatch[])(
    int unit, 
    bcm_oam_loss_t *loss_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_loss_delete(
    int unit, 
    bcm_oam_loss_t *loss_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(loss_ptr_gport);
		BCM_API_XLATE_PORT_COND(loss_ptr) BCM_API_XLATE_PORT_SAVE(loss_ptr_gport,loss_ptr->gport);
		BCM_API_XLATE_PORT_COND(loss_ptr) BCM_API_XLATE_PORT_A2P(unit,&loss_ptr->gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_loss_delete_dispatch[dtype](unit, loss_ptr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(loss_ptr) BCM_API_XLATE_PORT_RESTORE(loss_ptr->gport,loss_ptr_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_loss_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_loss_get( \
    int unit, bcm_oam_loss_t *loss_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_loss_get,
static int (*_oam_loss_get_dispatch[])(
    int unit, 
    bcm_oam_loss_t *loss_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_loss_get(
    int unit, 
    bcm_oam_loss_t *loss_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(loss_ptr) BCM_API_XLATE_PORT_A2P(unit,&loss_ptr->gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_loss_get_dispatch[dtype](unit, loss_ptr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(loss_ptr) BCM_API_XLATE_PORT_P2A(unit,&loss_ptr->gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_loss_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_opcode_map_get( \
    int unit, int opcode, int *profile);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_opcode_map_get,
static int (*_oam_opcode_map_get_dispatch[])(
    int unit, 
    int opcode, 
    int *profile) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_opcode_map_get(
    int unit, 
    int opcode, 
    int *profile)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_opcode_map_get_dispatch[dtype](unit, opcode, profile);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_opcode_map_get", 3, 2, unit, opcode, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_opcode_map_set( \
    int unit, int opcode, int profile);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_opcode_map_set,
static int (*_oam_opcode_map_set_dispatch[])(
    int unit, 
    int opcode, 
    int profile) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_opcode_map_set(
    int unit, 
    int opcode, 
    int profile)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_opcode_map_set_dispatch[dtype](unit, opcode, profile);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_opcode_map_set", 3, 3, unit, opcode, profile, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_psc_add( \
    int unit, bcm_oam_psc_t *psc_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_psc_add,
static int (*_oam_psc_add_dispatch[])(
    int unit, 
    bcm_oam_psc_t *psc_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_psc_add(
    int unit, 
    bcm_oam_psc_t *psc_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_psc_add_dispatch[dtype](unit, psc_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_psc_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_psc_delete( \
    int unit, bcm_oam_psc_t *psc_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_psc_delete,
static int (*_oam_psc_delete_dispatch[])(
    int unit, 
    bcm_oam_psc_t *psc_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_psc_delete(
    int unit, 
    bcm_oam_psc_t *psc_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_psc_delete_dispatch[dtype](unit, psc_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_psc_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_psc_get( \
    int unit, bcm_oam_psc_t *psc_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_psc_get,
static int (*_oam_psc_get_dispatch[])(
    int unit, 
    bcm_oam_psc_t *psc_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_psc_get(
    int unit, 
    bcm_oam_psc_t *psc_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_psc_get_dispatch[dtype](unit, psc_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_psc_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_pw_status_add( \
    int unit, bcm_oam_pw_status_t *pw_status_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_pw_status_add,
static int (*_oam_pw_status_add_dispatch[])(
    int unit, 
    bcm_oam_pw_status_t *pw_status_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_pw_status_add(
    int unit, 
    bcm_oam_pw_status_t *pw_status_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_pw_status_add_dispatch[dtype](unit, pw_status_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_pw_status_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_pw_status_delete( \
    int unit, bcm_oam_pw_status_t *pw_status_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_pw_status_delete,
static int (*_oam_pw_status_delete_dispatch[])(
    int unit, 
    bcm_oam_pw_status_t *pw_status_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_pw_status_delete(
    int unit, 
    bcm_oam_pw_status_t *pw_status_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_pw_status_delete_dispatch[dtype](unit, pw_status_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_pw_status_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_oam_pw_status_get( \
    int unit, bcm_oam_pw_status_t *pw_status_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_oam_pw_status_get,
static int (*_oam_pw_status_get_dispatch[])(
    int unit, 
    bcm_oam_pw_status_t *pw_status_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_oam_pw_status_get(
    int unit, 
    bcm_oam_pw_status_t *pw_status_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _oam_pw_status_get_dispatch[dtype](unit, pw_status_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_oam_pw_status_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_action_add( \
    int unit, uint32 action_id, bcm_policer_action_t action, uint32 param0);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_action_add,
static int (*_policer_action_add_dispatch[])(
    int unit, 
    uint32 action_id, 
    bcm_policer_action_t action, 
    uint32 param0) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_action_add(
    int unit, 
    uint32 action_id, 
    bcm_policer_action_t action, 
    uint32 param0)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_action_add_dispatch[dtype](unit, action_id, action, param0);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_action_add", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_action_attach( \
    int unit, bcm_policer_t policer_id, uint32 action_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_action_attach,
static int (*_policer_action_attach_dispatch[])(
    int unit, 
    bcm_policer_t policer_id, 
    uint32 action_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_action_attach(
    int unit, 
    bcm_policer_t policer_id, 
    uint32 action_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_action_attach_dispatch[dtype](unit, policer_id, action_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_action_attach", 3, 3, unit, policer_id, action_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_action_attach_get( \
    int unit, bcm_policer_t policer_id, uint32 *action_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_action_attach_get,
static int (*_policer_action_attach_get_dispatch[])(
    int unit, 
    bcm_policer_t policer_id, 
    uint32 *action_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_action_attach_get(
    int unit, 
    bcm_policer_t policer_id, 
    uint32 *action_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_action_attach_get_dispatch[dtype](unit, policer_id, action_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_action_attach_get", 3, 2, unit, policer_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_action_create( \
    int unit, uint32 *action_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_action_create,
static int (*_policer_action_create_dispatch[])(
    int unit, 
    uint32 *action_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_action_create(
    int unit, 
    uint32 *action_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_action_create_dispatch[dtype](unit, action_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_action_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_action_destroy( \
    int unit, uint32 action_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_action_destroy,
static int (*_policer_action_destroy_dispatch[])(
    int unit, 
    uint32 action_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_action_destroy(
    int unit, 
    uint32 action_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_action_destroy_dispatch[dtype](unit, action_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_action_destroy", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_action_detach( \
    int unit, bcm_policer_t policer_id, uint32 action_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_action_detach,
static int (*_policer_action_detach_dispatch[])(
    int unit, 
    bcm_policer_t policer_id, 
    uint32 action_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_action_detach(
    int unit, 
    bcm_policer_t policer_id, 
    uint32 action_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_action_detach_dispatch[dtype](unit, policer_id, action_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_action_detach", 3, 3, unit, policer_id, action_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_action_get( \
    int unit, uint32 action_id, bcm_policer_action_t action, uint32 *param0);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_action_get,
static int (*_policer_action_get_dispatch[])(
    int unit, 
    uint32 action_id, 
    bcm_policer_action_t action, 
    uint32 *param0) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_action_get(
    int unit, 
    uint32 action_id, 
    bcm_policer_action_t action, 
    uint32 *param0)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_action_get_dispatch[dtype](unit, action_id, action, param0);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_action_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_create( \
    int unit, bcm_policer_config_t *pol_cfg, bcm_policer_t *policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_create,
static int (*_policer_create_dispatch[])(
    int unit, 
    bcm_policer_config_t *pol_cfg, 
    bcm_policer_t *policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_create(
    int unit, 
    bcm_policer_config_t *pol_cfg, 
    bcm_policer_t *policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_create_dispatch[dtype](unit, pol_cfg, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_create", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_destroy( \
    int unit, bcm_policer_t policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_destroy,
static int (*_policer_destroy_dispatch[])(
    int unit, 
    bcm_policer_t policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_destroy(
    int unit, 
    bcm_policer_t policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_destroy_dispatch[dtype](unit, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_destroy", 2, 2, unit, policer_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_destroy_all,
static int (*_policer_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_envelop_create( \
    int unit, uint32 flag, bcm_policer_t macro_flow_policer_id, bcm_policer_t *policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_envelop_create,
static int (*_policer_envelop_create_dispatch[])(
    int unit, 
    uint32 flag, 
    bcm_policer_t macro_flow_policer_id, 
    bcm_policer_t *policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_envelop_create(
    int unit, 
    uint32 flag, 
    bcm_policer_t macro_flow_policer_id, 
    bcm_policer_t *policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_envelop_create_dispatch[dtype](unit, flag, macro_flow_policer_id, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_envelop_create", 4, 2, unit, flag, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_envelop_group_create( \
    int unit, uint32 flag, bcm_policer_group_mode_t mode, bcm_policer_t macro_flow_policer_id, bcm_policer_t *policer_id, int *npolicers);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_envelop_group_create,
static int (*_policer_envelop_group_create_dispatch[])(
    int unit, 
    uint32 flag, 
    bcm_policer_group_mode_t mode, 
    bcm_policer_t macro_flow_policer_id, 
    bcm_policer_t *policer_id, 
    int *npolicers) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_envelop_group_create(
    int unit, 
    uint32 flag, 
    bcm_policer_group_mode_t mode, 
    bcm_policer_t macro_flow_policer_id, 
    bcm_policer_t *policer_id, 
    int *npolicers)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_envelop_group_create_dispatch[dtype](unit, flag, mode, macro_flow_policer_id, policer_id, npolicers);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_envelop_group_create", 6, 3, unit, flag, mode, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_get( \
    int unit, bcm_policer_t policer_id, bcm_policer_config_t *pol_cfg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_get,
static int (*_policer_get_dispatch[])(
    int unit, 
    bcm_policer_t policer_id, 
    bcm_policer_config_t *pol_cfg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_get(
    int unit, 
    bcm_policer_t policer_id, 
    bcm_policer_config_t *pol_cfg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_get_dispatch[dtype](unit, policer_id, pol_cfg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_get", 3, 2, unit, policer_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_group_create( \
    int unit, bcm_policer_group_mode_t mode, bcm_policer_t *policer_id, int *npolicers);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_group_create,
static int (*_policer_group_create_dispatch[])(
    int unit, 
    bcm_policer_group_mode_t mode, 
    bcm_policer_t *policer_id, 
    int *npolicers) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_group_create(
    int unit, 
    bcm_policer_group_mode_t mode, 
    bcm_policer_t *policer_id, 
    int *npolicers)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_group_create_dispatch[dtype](unit, mode, policer_id, npolicers);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_group_create", 4, 2, unit, mode, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_init,
static int (*_policer_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_set( \
    int unit, bcm_policer_t policer_id, bcm_policer_config_t *pol_cfg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_set,
static int (*_policer_set_dispatch[])(
    int unit, 
    bcm_policer_t policer_id, 
    bcm_policer_config_t *pol_cfg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_set(
    int unit, 
    bcm_policer_t policer_id, 
    bcm_policer_config_t *pol_cfg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_set_dispatch[dtype](unit, policer_id, pol_cfg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_set", 3, 2, unit, policer_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_stat_enable_get( \
    int unit, bcm_policer_t policer_id, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_stat_enable_get,
static int (*_policer_stat_enable_get_dispatch[])(
    int unit, 
    bcm_policer_t policer_id, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_stat_enable_get(
    int unit, 
    bcm_policer_t policer_id, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_stat_enable_get_dispatch[dtype](unit, policer_id, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_stat_enable_get", 3, 2, unit, policer_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_stat_enable_set( \
    int unit, bcm_policer_t policer_id, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_stat_enable_set,
static int (*_policer_stat_enable_set_dispatch[])(
    int unit, 
    bcm_policer_t policer_id, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_stat_enable_set(
    int unit, 
    bcm_policer_t policer_id, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_stat_enable_set_dispatch[dtype](unit, policer_id, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_stat_enable_set", 3, 3, unit, policer_id, enable, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_stat_get( \
    int unit, bcm_policer_t policer_id, bcm_cos_t int_pri, bcm_policer_stat_t stat, uint64 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_stat_get,
static int (*_policer_stat_get_dispatch[])(
    int unit, 
    bcm_policer_t policer_id, 
    bcm_cos_t int_pri, 
    bcm_policer_stat_t stat, 
    uint64 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_stat_get(
    int unit, 
    bcm_policer_t policer_id, 
    bcm_cos_t int_pri, 
    bcm_policer_stat_t stat, 
    uint64 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_stat_get_dispatch[dtype](unit, policer_id, int_pri, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_stat_get", 5, 3, unit, policer_id, int_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_stat_get32( \
    int unit, bcm_policer_t policer_id, bcm_cos_t int_pri, bcm_policer_stat_t stat, uint32 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_stat_get32,
static int (*_policer_stat_get32_dispatch[])(
    int unit, 
    bcm_policer_t policer_id, 
    bcm_cos_t int_pri, 
    bcm_policer_stat_t stat, 
    uint32 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_stat_get32(
    int unit, 
    bcm_policer_t policer_id, 
    bcm_cos_t int_pri, 
    bcm_policer_stat_t stat, 
    uint32 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_stat_get32_dispatch[dtype](unit, policer_id, int_pri, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_stat_get32", 5, 3, unit, policer_id, int_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_stat_set( \
    int unit, bcm_policer_t policer_id, bcm_cos_t int_pri, bcm_policer_stat_t stat, uint64 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_stat_set,
static int (*_policer_stat_set_dispatch[])(
    int unit, 
    bcm_policer_t policer_id, 
    bcm_cos_t int_pri, 
    bcm_policer_stat_t stat, 
    uint64 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_stat_set(
    int unit, 
    bcm_policer_t policer_id, 
    bcm_cos_t int_pri, 
    bcm_policer_stat_t stat, 
    uint64 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_stat_set_dispatch[dtype](unit, policer_id, int_pri, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_stat_set", 5, 3, unit, policer_id, int_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_stat_set32( \
    int unit, bcm_policer_t policer_id, bcm_cos_t int_pri, bcm_policer_stat_t stat, uint32 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_stat_set32,
static int (*_policer_stat_set32_dispatch[])(
    int unit, 
    bcm_policer_t policer_id, 
    bcm_cos_t int_pri, 
    bcm_policer_stat_t stat, 
    uint32 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_stat_set32(
    int unit, 
    bcm_policer_t policer_id, 
    bcm_cos_t int_pri, 
    bcm_policer_stat_t stat, 
    uint32 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_stat_set32_dispatch[dtype](unit, policer_id, int_pri, stat, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_stat_set32", 5, 3, unit, policer_id, int_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_policer_traverse( \
    int unit, bcm_policer_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_policer_traverse,
static int (*_policer_traverse_dispatch[])(
    int unit, 
    bcm_policer_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_policer_traverse(
    int unit, 
    bcm_policer_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _policer_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_policer_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_ability_advert_get( \
    int unit, bcm_port_t port, bcm_port_ability_t *ability_mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_ability_advert_get,
static int (*_port_ability_advert_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_ability_t *ability_mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_ability_advert_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_ability_t *ability_mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_ability_advert_get_dispatch[dtype](unit, port, ability_mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_ability_advert_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_ability_advert_set( \
    int unit, bcm_port_t port, bcm_port_ability_t *ability_mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_ability_advert_set,
static int (*_port_ability_advert_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_ability_t *ability_mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_ability_advert_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_ability_t *ability_mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_ability_advert_set_dispatch[dtype](unit, port, ability_mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_ability_advert_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_ability_get( \
    int unit, bcm_port_t port, bcm_port_abil_t *local_ability_mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_ability_get,
static int (*_port_ability_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_abil_t *local_ability_mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_ability_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_abil_t *local_ability_mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_ability_get_dispatch[dtype](unit, port, local_ability_mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_ability_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_ability_local_get( \
    int unit, bcm_port_t port, bcm_port_ability_t *local_ability_mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_ability_local_get,
static int (*_port_ability_local_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_ability_t *local_ability_mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_ability_local_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_ability_t *local_ability_mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_ability_local_get_dispatch[dtype](unit, port, local_ability_mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_ability_local_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_ability_remote_get( \
    int unit, bcm_port_t port, bcm_port_ability_t *ability_mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_ability_remote_get,
static int (*_port_ability_remote_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_ability_t *ability_mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_ability_remote_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_ability_t *ability_mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_ability_remote_get_dispatch[dtype](unit, port, ability_mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_ability_remote_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_advert_get( \
    int unit, bcm_port_t port, bcm_port_abil_t *ability_mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_advert_get,
static int (*_port_advert_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_abil_t *ability_mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_advert_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_abil_t *ability_mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_advert_get_dispatch[dtype](unit, port, ability_mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_advert_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_advert_remote_get( \
    int unit, bcm_port_t port, bcm_port_abil_t *ability_mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_advert_remote_get,
static int (*_port_advert_remote_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_abil_t *ability_mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_advert_remote_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_abil_t *ability_mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_advert_remote_get_dispatch[dtype](unit, port, ability_mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_advert_remote_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_advert_set( \
    int unit, bcm_port_t port, bcm_port_abil_t ability_mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_advert_set,
static int (*_port_advert_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_abil_t ability_mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_advert_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_abil_t ability_mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_advert_set_dispatch[dtype](unit, port, ability_mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_advert_set", 3, 3, unit, port, ability_mask, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_autoneg_get( \
    int unit, bcm_port_t port, int *autoneg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_autoneg_get,
static int (*_port_autoneg_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *autoneg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_autoneg_get(
    int unit, 
    bcm_port_t port, 
    int *autoneg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_autoneg_get_dispatch[dtype](unit, port, autoneg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_autoneg_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_autoneg_set( \
    int unit, bcm_port_t port, int autoneg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_autoneg_set,
static int (*_port_autoneg_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int autoneg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_autoneg_set(
    int unit, 
    bcm_port_t port, 
    int autoneg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_autoneg_set_dispatch[dtype](unit, port, autoneg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_autoneg_set", 3, 3, unit, port, autoneg, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_bpdu_enable_get( \
    int unit, bcm_port_t port, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_bpdu_enable_get,
static int (*_port_bpdu_enable_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_bpdu_enable_get(
    int unit, 
    bcm_port_t port, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_bpdu_enable_get_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_bpdu_enable_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_bpdu_enable_set( \
    int unit, bcm_port_t port, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_bpdu_enable_set,
static int (*_port_bpdu_enable_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_bpdu_enable_set(
    int unit, 
    bcm_port_t port, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_bpdu_enable_set_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_bpdu_enable_set", 3, 3, unit, port, enable, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_cable_diag( \
    int unit, bcm_port_t port, bcm_port_cable_diag_t *status);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_cable_diag,
static int (*_port_cable_diag_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_cable_diag_t *status) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_cable_diag(
    int unit, 
    bcm_port_t port, 
    bcm_port_cable_diag_t *status)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_cable_diag_dispatch[dtype](unit, port, status);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_cable_diag", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_cfi_color_get( \
    int unit, bcm_port_t port, int cfi, bcm_color_t *color);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_cfi_color_get,
static int (*_port_cfi_color_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int cfi, 
    bcm_color_t *color) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_cfi_color_get(
    int unit, 
    bcm_port_t port, 
    int cfi, 
    bcm_color_t *color)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_cfi_color_get_dispatch[dtype](unit, port, cfi, color);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_cfi_color_get", 4, 3, unit, port, cfi, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_cfi_color_set( \
    int unit, bcm_port_t port, int cfi, bcm_color_t color);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_cfi_color_set,
static int (*_port_cfi_color_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int cfi, 
    bcm_color_t color) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_cfi_color_set(
    int unit, 
    bcm_port_t port, 
    int cfi, 
    bcm_color_t color)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_cfi_color_set_dispatch[dtype](unit, port, cfi, color);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_cfi_color_set", 4, 3, unit, port, cfi, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_class_get( \
    int unit, bcm_port_t port, bcm_port_class_t pclass, uint32 *class_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_class_get,
static int (*_port_class_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_class_t pclass, 
    uint32 *class_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_class_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_class_t pclass, 
    uint32 *class_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_class_get_dispatch[dtype](unit, port, pclass, class_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_class_get", 4, 3, unit, port, pclass, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_class_set( \
    int unit, bcm_port_t port, bcm_port_class_t pclass, uint32 class_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_class_set,
static int (*_port_class_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_class_t pclass, 
    uint32 class_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_class_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_class_t pclass, 
    uint32 class_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_class_set_dispatch[dtype](unit, port, pclass, class_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_class_set", 4, 3, unit, port, pclass, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_clear( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_clear,
static int (*_port_clear_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_clear(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _port_clear_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_clear", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_config_get( \
    int unit, bcm_port_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_config_get,
static int (*_port_config_get_dispatch[])(
    int unit, 
    bcm_port_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_config_get(
    int unit, 
    bcm_port_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _port_config_get_dispatch[dtype](unit, config);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->all);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->ce);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->cpu);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->e);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->fe);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->ge);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->hg);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->il);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->llid);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->pon);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->rcy);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->sci);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->sfi);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->spi);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->spi_subport);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->stack_ext);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->stack_int);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->tdm);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->xe);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_PBMP_P2A(unit,&config->xl);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_config_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_config_phy_oam_get( \
    int unit, bcm_port_t port, bcm_port_config_phy_oam_t *conf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_config_phy_oam_get,
static int (*_port_config_phy_oam_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_config_phy_oam_t *conf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_config_phy_oam_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_config_phy_oam_t *conf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_config_phy_oam_get_dispatch[dtype](unit, port, conf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_config_phy_oam_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_config_phy_oam_set( \
    int unit, bcm_port_t port, bcm_port_config_phy_oam_t *conf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_config_phy_oam_set,
static int (*_port_config_phy_oam_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_config_phy_oam_t *conf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_config_phy_oam_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_config_phy_oam_t *conf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_config_phy_oam_set_dispatch[dtype](unit, port, conf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_config_phy_oam_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_congestion_config_get( \
    int unit, bcm_gport_t port, bcm_port_congestion_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_congestion_config_get,
static int (*_port_congestion_config_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_port_congestion_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_congestion_config_get(
    int unit, 
    bcm_gport_t port, 
    bcm_port_congestion_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_A2P(unit,&config->dst_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_A2P(unit,&config->src_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_congestion_config_get_dispatch[dtype](unit, port, config);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_P2A(unit,&config->dst_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_P2A(unit,&config->src_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_congestion_config_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_congestion_config_set( \
    int unit, bcm_gport_t port, bcm_port_congestion_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_congestion_config_set,
static int (*_port_congestion_config_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_port_congestion_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_congestion_config_set(
    int unit, 
    bcm_gport_t port, 
    bcm_port_congestion_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(config_dst_port);
		BCM_API_XLATE_PORT_DECL(config_src_port);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_SAVE(config_dst_port,config->dst_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_A2P(unit,&config->dst_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_SAVE(config_src_port,config->src_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_A2P(unit,&config->src_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_congestion_config_set_dispatch[dtype](unit, port, config);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_RESTORE(config->dst_port,config_dst_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_RESTORE(config->src_port,config_src_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_congestion_config_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_congestion_get( \
    int unit, bcm_gport_t congestion_port, bcm_gport_t port, uint32 flags, int *channel_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_congestion_get,
static int (*_port_congestion_get_dispatch[])(
    int unit, 
    bcm_gport_t congestion_port, 
    bcm_gport_t port, 
    uint32 flags, 
    int *channel_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_congestion_get(
    int unit, 
    bcm_gport_t congestion_port, 
    bcm_gport_t port, 
    uint32 flags, 
    int *channel_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&congestion_port);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_congestion_get_dispatch[dtype](unit, congestion_port, port, flags, channel_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_congestion_get", 5, 3, unit, congestion_port, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_congestion_set( \
    int unit, bcm_gport_t congestion_port, bcm_gport_t port, uint32 flags, int channel_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_congestion_set,
static int (*_port_congestion_set_dispatch[])(
    int unit, 
    bcm_gport_t congestion_port, 
    bcm_gport_t port, 
    uint32 flags, 
    int channel_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_congestion_set(
    int unit, 
    bcm_gport_t congestion_port, 
    bcm_gport_t port, 
    uint32 flags, 
    int channel_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&congestion_port);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_congestion_set_dispatch[dtype](unit, congestion_port, port, flags, channel_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_congestion_set", 5, 3, unit, congestion_port, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_control_get( \
    int unit, bcm_port_t port, bcm_port_control_t type, int *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_control_get,
static int (*_port_control_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_control_t type, 
    int *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_control_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_control_t type, 
    int *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_control_get_dispatch[dtype](unit, port, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_control_get", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_control_phy_oam_get( \
    int unit, bcm_port_t port, bcm_port_control_phy_oam_t type, uint64 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_control_phy_oam_get,
static int (*_port_control_phy_oam_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_control_phy_oam_t type, 
    uint64 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_control_phy_oam_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_control_phy_oam_t type, 
    uint64 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_control_phy_oam_get_dispatch[dtype](unit, port, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_control_phy_oam_get", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_control_phy_oam_set( \
    int unit, bcm_port_t port, bcm_port_control_phy_oam_t type, uint64 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_control_phy_oam_set,
static int (*_port_control_phy_oam_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_control_phy_oam_t type, 
    uint64 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_control_phy_oam_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_control_phy_oam_t type, 
    uint64 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_control_phy_oam_set_dispatch[dtype](unit, port, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_control_phy_oam_set", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_control_phy_timesync_get( \
    int unit, bcm_port_t port, bcm_port_control_phy_timesync_t type, uint64 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_control_phy_timesync_get,
static int (*_port_control_phy_timesync_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_control_phy_timesync_t type, 
    uint64 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_control_phy_timesync_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_control_phy_timesync_t type, 
    uint64 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_control_phy_timesync_get_dispatch[dtype](unit, port, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_control_phy_timesync_get", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_control_phy_timesync_set( \
    int unit, bcm_port_t port, bcm_port_control_phy_timesync_t type, uint64 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_control_phy_timesync_set,
static int (*_port_control_phy_timesync_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_control_phy_timesync_t type, 
    uint64 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_control_phy_timesync_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_control_phy_timesync_t type, 
    uint64 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_control_phy_timesync_set_dispatch[dtype](unit, port, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_control_phy_timesync_set", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_control_set( \
    int unit, bcm_port_t port, bcm_port_control_t type, int value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_control_set,
static int (*_port_control_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_control_t type, 
    int value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_control_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_control_t type, 
    int value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_control_set_dispatch[dtype](unit, port, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_control_set", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_detach( \
    int unit, bcm_pbmp_t pbmp, bcm_pbmp_t *detached);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_detach,
static int (*_port_detach_dispatch[])(
    int unit, 
    bcm_pbmp_t pbmp, 
    bcm_pbmp_t *detached) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_detach(
    int unit, 
    bcm_pbmp_t pbmp, 
    bcm_pbmp_t *detached)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_detach_dispatch[dtype](unit, pbmp, detached);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,detached);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_detach", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_discard_get( \
    int unit, bcm_port_t port, int *mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_discard_get,
static int (*_port_discard_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_discard_get(
    int unit, 
    bcm_port_t port, 
    int *mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_discard_get_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_discard_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_discard_set( \
    int unit, bcm_port_t port, int mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_discard_set,
static int (*_port_discard_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_discard_set(
    int unit, 
    bcm_port_t port, 
    int mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_discard_set_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_discard_set", 3, 3, unit, port, mode, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_dscp_map_get( \
    int unit, bcm_port_t port, int srccp, int *mapcp, int *prio);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_dscp_map_get,
static int (*_port_dscp_map_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int srccp, 
    int *mapcp, 
    int *prio) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_dscp_map_get(
    int unit, 
    bcm_port_t port, 
    int srccp, 
    int *mapcp, 
    int *prio)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_dscp_map_get_dispatch[dtype](unit, port, srccp, mapcp, prio);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_dscp_map_get", 5, 3, unit, port, srccp, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_dscp_map_mode_get( \
    int unit, bcm_port_t port, int *mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_dscp_map_mode_get,
static int (*_port_dscp_map_mode_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_dscp_map_mode_get(
    int unit, 
    bcm_port_t port, 
    int *mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_dscp_map_mode_get_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_dscp_map_mode_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_dscp_map_mode_set( \
    int unit, bcm_port_t port, int mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_dscp_map_mode_set,
static int (*_port_dscp_map_mode_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_dscp_map_mode_set(
    int unit, 
    bcm_port_t port, 
    int mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_dscp_map_mode_set_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_dscp_map_mode_set", 3, 3, unit, port, mode, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_dscp_map_set( \
    int unit, bcm_port_t port, int srccp, int mapcp, int prio);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_dscp_map_set,
static int (*_port_dscp_map_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int srccp, 
    int mapcp, 
    int prio) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_dscp_map_set(
    int unit, 
    bcm_port_t port, 
    int srccp, 
    int mapcp, 
    int prio)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_dscp_map_set_dispatch[dtype](unit, port, srccp, mapcp, prio);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_dscp_map_set", 5, 3, unit, port, srccp, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_dscp_unmap_get( \
    int unit, bcm_port_t port, int internal_pri, bcm_color_t color, int *pkt_dscp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_dscp_unmap_get,
static int (*_port_dscp_unmap_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int internal_pri, 
    bcm_color_t color, 
    int *pkt_dscp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_dscp_unmap_get(
    int unit, 
    bcm_port_t port, 
    int internal_pri, 
    bcm_color_t color, 
    int *pkt_dscp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_dscp_unmap_get_dispatch[dtype](unit, port, internal_pri, color, pkt_dscp);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_dscp_unmap_get", 5, 3, unit, port, internal_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_dscp_unmap_set( \
    int unit, bcm_port_t port, int internal_pri, bcm_color_t color, int pkt_dscp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_dscp_unmap_set,
static int (*_port_dscp_unmap_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int internal_pri, 
    bcm_color_t color, 
    int pkt_dscp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_dscp_unmap_set(
    int unit, 
    bcm_port_t port, 
    int internal_pri, 
    bcm_color_t color, 
    int pkt_dscp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_dscp_unmap_set_dispatch[dtype](unit, port, internal_pri, color, pkt_dscp);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_dscp_unmap_set", 5, 3, unit, port, internal_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_dtag_mode_get( \
    int unit, bcm_port_t port, int *mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_dtag_mode_get,
static int (*_port_dtag_mode_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_dtag_mode_get(
    int unit, 
    bcm_port_t port, 
    int *mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_dtag_mode_get_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_dtag_mode_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_dtag_mode_set( \
    int unit, bcm_port_t port, int mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_dtag_mode_set,
static int (*_port_dtag_mode_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_dtag_mode_set(
    int unit, 
    bcm_port_t port, 
    int mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_dtag_mode_set_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_dtag_mode_set", 3, 3, unit, port, mode, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_duplex_get( \
    int unit, bcm_port_t port, int *duplex);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_duplex_get,
static int (*_port_duplex_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *duplex) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_duplex_get(
    int unit, 
    bcm_port_t port, 
    int *duplex)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_duplex_get_dispatch[dtype](unit, port, duplex);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_duplex_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_duplex_set( \
    int unit, bcm_port_t port, int duplex);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_duplex_set,
static int (*_port_duplex_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int duplex) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_duplex_set(
    int unit, 
    bcm_port_t port, 
    int duplex)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_duplex_set_dispatch[dtype](unit, port, duplex);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_duplex_set", 3, 3, unit, port, duplex, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_egress_get( \
    int unit, bcm_port_t port, int modid, bcm_pbmp_t *pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_egress_get,
static int (*_port_egress_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int modid, 
    bcm_pbmp_t *pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_egress_get(
    int unit, 
    bcm_port_t port, 
    int modid, 
    bcm_pbmp_t *pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _port_egress_get_dispatch[dtype](unit, port, modid, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_egress_get", 4, 3, unit, port, modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_egress_policer_set( \
    int unit, bcm_port_t port, bcm_policer_t policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_egress_policer_set,
static int (*_port_egress_policer_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_policer_t policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_egress_policer_set(
    int unit, 
    bcm_port_t port, 
    bcm_policer_t policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_egress_policer_set_dispatch[dtype](unit, port, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_egress_policer_set", 3, 3, unit, port, policer_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_egress_set( \
    int unit, bcm_port_t port, int modid, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_egress_set,
static int (*_port_egress_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int modid, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_egress_set(
    int unit, 
    bcm_port_t port, 
    int modid, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_egress_set_dispatch[dtype](unit, port, modid, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_egress_set", 4, 3, unit, port, modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_enable_get( \
    int unit, bcm_port_t port, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_enable_get,
static int (*_port_enable_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_enable_get(
    int unit, 
    bcm_port_t port, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_enable_get_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_enable_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_enable_set( \
    int unit, bcm_port_t port, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_enable_set,
static int (*_port_enable_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_enable_set(
    int unit, 
    bcm_port_t port, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_enable_set_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_enable_set", 3, 3, unit, port, enable, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_encap_config_get( \
    int unit, bcm_gport_t gport, bcm_port_encap_config_t *encap_config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_encap_config_get,
static int (*_port_encap_config_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_port_encap_config_t *encap_config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_encap_config_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_port_encap_config_t *encap_config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_encap_config_get_dispatch[dtype](unit, gport, encap_config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_encap_config_get", 3, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_encap_config_set( \
    int unit, bcm_gport_t gport, bcm_port_encap_config_t *encap_config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_encap_config_set,
static int (*_port_encap_config_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_port_encap_config_t *encap_config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_encap_config_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_port_encap_config_t *encap_config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_encap_config_set_dispatch[dtype](unit, gport, encap_config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_encap_config_set", 3, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_encap_get( \
    int unit, bcm_port_t port, int *mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_encap_get,
static int (*_port_encap_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_encap_get(
    int unit, 
    bcm_port_t port, 
    int *mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_encap_get_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_encap_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_encap_map_get( \
    int unit, uint32 flags, bcm_if_t encap_id, bcm_gport_t *port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_encap_map_get,
static int (*_port_encap_map_get_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_if_t encap_id, 
    bcm_gport_t *port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_encap_map_get(
    int unit, 
    uint32 flags, 
    bcm_if_t encap_id, 
    bcm_gport_t *port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _port_encap_map_get_dispatch[dtype](unit, flags, encap_id, port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_encap_map_get", 4, 3, unit, flags, encap_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_encap_map_set( \
    int unit, uint32 flags, bcm_if_t encap_id, bcm_gport_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_encap_map_set,
static int (*_port_encap_map_set_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_if_t encap_id, 
    bcm_gport_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_encap_map_set(
    int unit, 
    uint32 flags, 
    bcm_if_t encap_id, 
    bcm_gport_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_encap_map_set_dispatch[dtype](unit, flags, encap_id, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_encap_map_set", 4, 3, unit, flags, encap_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_encap_set( \
    int unit, bcm_port_t port, int mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_encap_set,
static int (*_port_encap_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_encap_set(
    int unit, 
    bcm_port_t port, 
    int mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_encap_set_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_encap_set", 3, 3, unit, port, mode, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_fault_get( \
    int unit, bcm_port_t port, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_fault_get,
static int (*_port_fault_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_fault_get(
    int unit, 
    bcm_port_t port, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_fault_get_dispatch[dtype](unit, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_fault_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_flood_block_get( \
    int unit, bcm_port_t ingress_port, bcm_port_t egress_port, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_flood_block_get,
static int (*_port_flood_block_get_dispatch[])(
    int unit, 
    bcm_port_t ingress_port, 
    bcm_port_t egress_port, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_flood_block_get(
    int unit, 
    bcm_port_t ingress_port, 
    bcm_port_t egress_port, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&ingress_port);
		BCM_API_XLATE_PORT_A2P(unit,&egress_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_flood_block_get_dispatch[dtype](unit, ingress_port, egress_port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_flood_block_get", 4, 3, unit, ingress_port, egress_port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_flood_block_set( \
    int unit, bcm_port_t ingress_port, bcm_port_t egress_port, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_flood_block_set,
static int (*_port_flood_block_set_dispatch[])(
    int unit, 
    bcm_port_t ingress_port, 
    bcm_port_t egress_port, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_flood_block_set(
    int unit, 
    bcm_port_t ingress_port, 
    bcm_port_t egress_port, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&ingress_port);
		BCM_API_XLATE_PORT_A2P(unit,&egress_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_flood_block_set_dispatch[dtype](unit, ingress_port, egress_port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_flood_block_set", 4, 3, unit, ingress_port, egress_port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_force_dest_get( \
    int unit, bcm_gport_t gport, bcm_port_dest_info_t *dest_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_force_dest_get,
static int (*_port_force_dest_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_port_dest_info_t *dest_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_force_dest_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_port_dest_info_t *dest_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_force_dest_get_dispatch[dtype](unit, gport, dest_info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(dest_info) BCM_API_XLATE_PORT_P2A(unit,&dest_info->gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_force_dest_get", 3, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_force_dest_set( \
    int unit, bcm_gport_t gport, bcm_port_dest_info_t *dest_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_force_dest_set,
static int (*_port_force_dest_set_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_port_dest_info_t *dest_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_force_dest_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_port_dest_info_t *dest_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(dest_info_gport);
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		BCM_API_XLATE_PORT_COND(dest_info) BCM_API_XLATE_PORT_SAVE(dest_info_gport,dest_info->gport);
		BCM_API_XLATE_PORT_COND(dest_info) BCM_API_XLATE_PORT_A2P(unit,&dest_info->gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_force_dest_set_dispatch[dtype](unit, gport, dest_info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(dest_info) BCM_API_XLATE_PORT_RESTORE(dest_info->gport,dest_info_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_force_dest_set", 3, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_force_forward_get( \
    int unit, bcm_port_t port, bcm_port_t *egr_port, int *enabled);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_force_forward_get,
static int (*_port_force_forward_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_t *egr_port, 
    int *enabled) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_force_forward_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_t *egr_port, 
    int *enabled)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_force_forward_get_dispatch[dtype](unit, port, egr_port, enabled);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,egr_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_force_forward_get", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_force_forward_mode_get( \
    int unit, bcm_port_t port, bcm_port_t *egr_port, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_force_forward_mode_get,
static int (*_port_force_forward_mode_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_t *egr_port, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_force_forward_mode_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_t *egr_port, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_force_forward_mode_get_dispatch[dtype](unit, port, egr_port, flags);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,egr_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_force_forward_mode_get", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_force_forward_mode_set( \
    int unit, bcm_port_t port, bcm_port_t egr_port, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_force_forward_mode_set,
static int (*_port_force_forward_mode_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_t egr_port, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_force_forward_mode_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_t egr_port, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&egr_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_force_forward_mode_set_dispatch[dtype](unit, port, egr_port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_force_forward_mode_set", 4, 3, unit, port, egr_port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_force_forward_set( \
    int unit, bcm_port_t port, bcm_port_t egr_port, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_force_forward_set,
static int (*_port_force_forward_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_t egr_port, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_force_forward_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_t egr_port, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&egr_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_force_forward_set_dispatch[dtype](unit, port, egr_port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_force_forward_set", 4, 3, unit, port, egr_port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_force_vlan_get( \
    int unit, bcm_port_t port, bcm_vlan_t *vlan, int *pkt_prio, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_force_vlan_get,
static int (*_port_force_vlan_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t *vlan, 
    int *pkt_prio, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_force_vlan_get(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t *vlan, 
    int *pkt_prio, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_force_vlan_get_dispatch[dtype](unit, port, vlan, pkt_prio, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_force_vlan_get", 5, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_force_vlan_set( \
    int unit, bcm_port_t port, bcm_vlan_t vlan, int pkt_prio, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_force_vlan_set,
static int (*_port_force_vlan_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    int pkt_prio, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_force_vlan_set(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    int pkt_prio, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_force_vlan_set_dispatch[dtype](unit, port, vlan, pkt_prio, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_force_vlan_set", 5, 3, unit, port, vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_frame_max_get( \
    int unit, bcm_port_t port, int *size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_frame_max_get,
static int (*_port_frame_max_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_frame_max_get(
    int unit, 
    bcm_port_t port, 
    int *size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_frame_max_get_dispatch[dtype](unit, port, size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_frame_max_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_frame_max_set( \
    int unit, bcm_port_t port, int size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_frame_max_set,
static int (*_port_frame_max_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_frame_max_set(
    int unit, 
    bcm_port_t port, 
    int size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_frame_max_set_dispatch[dtype](unit, port, size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_frame_max_set", 3, 3, unit, port, size, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_gport_free_range_get( \
    int unit, uint32 gport_type, bcm_gport_t *gport_min, bcm_gport_t *gport_max);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_gport_free_range_get,
static int (*_port_gport_free_range_get_dispatch[])(
    int unit, 
    uint32 gport_type, 
    bcm_gport_t *gport_min, 
    bcm_gport_t *gport_max) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_gport_free_range_get(
    int unit, 
    uint32 gport_type, 
    bcm_gport_t *gport_min, 
    bcm_gport_t *gport_max)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _port_gport_free_range_get_dispatch[dtype](unit, gport_type, gport_min, gport_max);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,gport_min);
		BCM_API_XLATE_PORT_P2A(unit,gport_max);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_gport_free_range_get", 4, 2, unit, gport_type, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_gport_get( \
    int unit, bcm_port_t port, bcm_gport_t *gport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_gport_get,
static int (*_port_gport_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_gport_t *gport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_gport_get(
    int unit, 
    bcm_port_t port, 
    bcm_gport_t *gport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_gport_get_dispatch[dtype](unit, port, gport);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_gport_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_gport_is_free( \
    int unit, bcm_gport_t gport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_gport_is_free,
static int (*_port_gport_is_free_dispatch[])(
    int unit, 
    bcm_gport_t gport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_gport_is_free(
    int unit, 
    bcm_gport_t gport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_gport_is_free_dispatch[dtype](unit, gport);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_gport_is_free", 2, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_ifg_get( \
    int unit, bcm_port_t port, int speed, bcm_port_duplex_t duplex, int *bit_times);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_ifg_get,
static int (*_port_ifg_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int speed, 
    bcm_port_duplex_t duplex, 
    int *bit_times) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_ifg_get(
    int unit, 
    bcm_port_t port, 
    int speed, 
    bcm_port_duplex_t duplex, 
    int *bit_times)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_ifg_get_dispatch[dtype](unit, port, speed, duplex, bit_times);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_ifg_get", 5, 3, unit, port, speed, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_ifg_set( \
    int unit, bcm_port_t port, int speed, bcm_port_duplex_t duplex, int bit_times);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_ifg_set,
static int (*_port_ifg_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int speed, 
    bcm_port_duplex_t duplex, 
    int bit_times) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_ifg_set(
    int unit, 
    bcm_port_t port, 
    int speed, 
    bcm_port_duplex_t duplex, 
    int bit_times)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_ifg_set_dispatch[dtype](unit, port, speed, duplex, bit_times);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_ifg_set", 5, 3, unit, port, speed, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_ifilter_get( \
    int unit, bcm_port_t port, int *mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_ifilter_get,
static int (*_port_ifilter_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_ifilter_get(
    int unit, 
    bcm_port_t port, 
    int *mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_ifilter_get_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_ifilter_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_ifilter_set( \
    int unit, bcm_port_t port, int mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_ifilter_set,
static int (*_port_ifilter_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_ifilter_set(
    int unit, 
    bcm_port_t port, 
    int mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_ifilter_set_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_ifilter_set", 3, 3, unit, port, mode, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_info_get( \
    int unit, bcm_port_t port, bcm_port_info_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_info_get,
static int (*_port_info_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_info_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_info_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_info_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_info_get_dispatch[dtype](unit, port, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_info_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_info_restore( \
    int unit, bcm_port_t port, bcm_port_info_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_info_restore,
static int (*_port_info_restore_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_info_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_info_restore(
    int unit, 
    bcm_port_t port, 
    bcm_port_info_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_info_restore_dispatch[dtype](unit, port, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_info_restore", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_info_save( \
    int unit, bcm_port_t port, bcm_port_info_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_info_save,
static int (*_port_info_save_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_info_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_info_save(
    int unit, 
    bcm_port_t port, 
    bcm_port_info_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_info_save_dispatch[dtype](unit, port, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_info_save", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_info_set( \
    int unit, bcm_port_t port, bcm_port_info_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_info_set,
static int (*_port_info_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_info_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_info_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_info_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_info_set_dispatch[dtype](unit, port, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_info_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_init,
static int (*_port_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _port_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_inner_tpid_get( \
    int unit, bcm_port_t port, uint16 *tpid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_inner_tpid_get,
static int (*_port_inner_tpid_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint16 *tpid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_inner_tpid_get(
    int unit, 
    bcm_port_t port, 
    uint16 *tpid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_inner_tpid_get_dispatch[dtype](unit, port, tpid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_inner_tpid_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_inner_tpid_set( \
    int unit, bcm_port_t port, uint16 tpid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_inner_tpid_set,
static int (*_port_inner_tpid_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint16 tpid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_inner_tpid_set(
    int unit, 
    bcm_port_t port, 
    uint16 tpid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_inner_tpid_set_dispatch[dtype](unit, port, tpid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_inner_tpid_set", 3, 3, unit, port, tpid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_interface_config_get( \
    int unit, bcm_port_t port, bcm_port_interface_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_interface_config_get,
static int (*_port_interface_config_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_interface_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_interface_config_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_interface_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_interface_config_get_dispatch[dtype](unit, port, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_interface_config_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_interface_config_set( \
    int unit, bcm_port_t port, bcm_port_interface_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_interface_config_set,
static int (*_port_interface_config_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_interface_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_interface_config_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_interface_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_interface_config_set_dispatch[dtype](unit, port, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_interface_config_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_interface_get( \
    int unit, bcm_port_t port, bcm_port_if_t *intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_interface_get,
static int (*_port_interface_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_if_t *intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_interface_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_if_t *intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_interface_get_dispatch[dtype](unit, port, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_interface_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_interface_set( \
    int unit, bcm_port_t port, bcm_port_if_t intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_interface_set,
static int (*_port_interface_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_if_t intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_interface_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_if_t intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_interface_set_dispatch[dtype](unit, port, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_interface_set", 3, 3, unit, port, intf, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_internal_get( \
    int unit, uint32 flags, int internal_ports_max, bcm_gport_t *internal_gport, int *internal_ports_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_internal_get,
static int (*_port_internal_get_dispatch[])(
    int unit, 
    uint32 flags, 
    int internal_ports_max, 
    bcm_gport_t *internal_gport, 
    int *internal_ports_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_internal_get(
    int unit, 
    uint32 flags, 
    int internal_ports_max, 
    bcm_gport_t *internal_gport, 
    int *internal_ports_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_internal_get_dispatch[dtype](unit, flags, internal_ports_max, internal_gport, internal_ports_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(internal_ports_max,idx)
				BCM_API_XLATE_PORT_COND(internal_gport) BCM_API_XLATE_PORT_P2A(unit,&(internal_gport)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_internal_get", 5, 3, unit, flags, internal_ports_max, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_ipmc_modify_get( \
    int unit, bcm_port_t port, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_ipmc_modify_get,
static int (*_port_ipmc_modify_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_ipmc_modify_get(
    int unit, 
    bcm_port_t port, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_ipmc_modify_get_dispatch[dtype](unit, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_ipmc_modify_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_ipmc_modify_set( \
    int unit, bcm_port_t port, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_ipmc_modify_set,
static int (*_port_ipmc_modify_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_ipmc_modify_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_ipmc_modify_set_dispatch[dtype](unit, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_ipmc_modify_set", 3, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_jam_get( \
    int unit, bcm_port_t port, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_jam_get,
static int (*_port_jam_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_jam_get(
    int unit, 
    bcm_port_t port, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_jam_get_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_jam_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_jam_set( \
    int unit, bcm_port_t port, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_jam_set,
static int (*_port_jam_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_jam_set(
    int unit, 
    bcm_port_t port, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_jam_set_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_jam_set", 3, 3, unit, port, enable, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_l3_enable_get( \
    int unit, bcm_port_t port, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_l3_enable_get,
static int (*_port_l3_enable_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_l3_enable_get(
    int unit, 
    bcm_port_t port, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_l3_enable_get_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_l3_enable_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_l3_enable_set( \
    int unit, bcm_port_t port, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_l3_enable_set,
static int (*_port_l3_enable_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_l3_enable_set(
    int unit, 
    bcm_port_t port, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_l3_enable_set_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_l3_enable_set", 3, 3, unit, port, enable, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_l3_modify_get( \
    int unit, bcm_port_t port, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_l3_modify_get,
static int (*_port_l3_modify_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_l3_modify_get(
    int unit, 
    bcm_port_t port, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_l3_modify_get_dispatch[dtype](unit, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_l3_modify_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_l3_modify_set( \
    int unit, bcm_port_t port, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_l3_modify_set,
static int (*_port_l3_modify_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_l3_modify_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_l3_modify_set_dispatch[dtype](unit, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_l3_modify_set", 3, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_l3_mtu_get( \
    int unit, bcm_port_t port, int *size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_l3_mtu_get,
static int (*_port_l3_mtu_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_l3_mtu_get(
    int unit, 
    bcm_port_t port, 
    int *size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_l3_mtu_get_dispatch[dtype](unit, port, size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_l3_mtu_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_l3_mtu_set( \
    int unit, bcm_port_t port, int size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_l3_mtu_set,
static int (*_port_l3_mtu_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_l3_mtu_set(
    int unit, 
    bcm_port_t port, 
    int size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_l3_mtu_set_dispatch[dtype](unit, port, size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_l3_mtu_set", 3, 3, unit, port, size, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_learn_get( \
    int unit, bcm_port_t port, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_learn_get,
static int (*_port_learn_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_learn_get(
    int unit, 
    bcm_port_t port, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_learn_get_dispatch[dtype](unit, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_learn_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_learn_modify( \
    int unit, bcm_port_t port, uint32 add, uint32 remove);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_learn_modify,
static int (*_port_learn_modify_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 add, 
    uint32 remove) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_learn_modify(
    int unit, 
    bcm_port_t port, 
    uint32 add, 
    uint32 remove)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_learn_modify_dispatch[dtype](unit, port, add, remove);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_learn_modify", 4, 3, unit, port, add, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_learn_set( \
    int unit, bcm_port_t port, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_learn_set,
static int (*_port_learn_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_learn_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_learn_set_dispatch[dtype](unit, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_learn_set", 3, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_link_failed_clear( \
    int unit, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_link_failed_clear,
static int (*_port_link_failed_clear_dispatch[])(
    int unit, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_link_failed_clear(
    int unit, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_link_failed_clear_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_link_failed_clear", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_link_state_get( \
    int unit, bcm_port_t port, uint32 flags, bcm_port_link_state_t *state);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_link_state_get,
static int (*_port_link_state_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_port_link_state_t *state) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_link_state_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_port_link_state_t *state)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_link_state_get_dispatch[dtype](unit, port, flags, state);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_link_state_get", 4, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_link_status_get( \
    int unit, bcm_port_t port, int *status);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_link_status_get,
static int (*_port_link_status_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *status) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_link_status_get(
    int unit, 
    bcm_port_t port, 
    int *status)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_link_status_get_dispatch[dtype](unit, port, status);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_link_status_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_linkscan_get( \
    int unit, bcm_port_t port, int *linkscan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_linkscan_get,
static int (*_port_linkscan_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *linkscan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_linkscan_get(
    int unit, 
    bcm_port_t port, 
    int *linkscan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_linkscan_get_dispatch[dtype](unit, port, linkscan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_linkscan_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_linkscan_set( \
    int unit, bcm_port_t port, int linkscan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_linkscan_set,
static int (*_port_linkscan_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int linkscan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_linkscan_set(
    int unit, 
    bcm_port_t port, 
    int linkscan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_linkscan_set_dispatch[dtype](unit, port, linkscan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_linkscan_set", 3, 3, unit, port, linkscan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_local_get( \
    int unit, bcm_gport_t gport, bcm_port_t *local_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_local_get,
static int (*_port_local_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_port_t *local_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_local_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_port_t *local_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_local_get_dispatch[dtype](unit, gport, local_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,local_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_local_get", 3, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_loopback_get( \
    int unit, bcm_port_t port, int *loopback);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_loopback_get,
static int (*_port_loopback_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *loopback) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_loopback_get(
    int unit, 
    bcm_port_t port, 
    int *loopback)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_loopback_get_dispatch[dtype](unit, port, loopback);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_loopback_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_loopback_set( \
    int unit, bcm_port_t port, int loopback);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_loopback_set,
static int (*_port_loopback_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int loopback) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_loopback_set(
    int unit, 
    bcm_port_t port, 
    int loopback)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_loopback_set_dispatch[dtype](unit, port, loopback);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_loopback_set", 3, 3, unit, port, loopback, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_management_packet_config_get( \
    int unit, bcm_port_t port, bcm_port_management_packet_config_t *config_array, int max_config, int *config_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_management_packet_config_get,
static int (*_port_management_packet_config_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_management_packet_config_t *config_array, 
    int max_config, 
    int *config_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_management_packet_config_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_management_packet_config_t *config_array, 
    int max_config, 
    int *config_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_management_packet_config_get_dispatch[dtype](unit, port, config_array, max_config, config_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_management_packet_config_get", 5, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_management_packet_config_set( \
    int unit, bcm_port_t port, bcm_port_management_packet_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_management_packet_config_set,
static int (*_port_management_packet_config_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_management_packet_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_management_packet_config_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_management_packet_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_management_packet_config_set_dispatch[dtype](unit, port, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_management_packet_config_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_master_get( \
    int unit, bcm_port_t port, int *ms);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_master_get,
static int (*_port_master_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *ms) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_master_get(
    int unit, 
    bcm_port_t port, 
    int *ms)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_master_get_dispatch[dtype](unit, port, ms);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_master_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_master_set( \
    int unit, bcm_port_t port, int ms);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_master_set,
static int (*_port_master_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int ms) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_master_set(
    int unit, 
    bcm_port_t port, 
    int ms)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_master_set_dispatch[dtype](unit, port, ms);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_master_set", 3, 3, unit, port, ms, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_match_add( \
    int unit, bcm_gport_t port, bcm_port_match_info_t *match);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_match_add,
static int (*_port_match_add_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_port_match_info_t *match) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_match_add(
    int unit, 
    bcm_gport_t port, 
    bcm_port_match_info_t *match)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(match_port);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_COND(match) BCM_API_XLATE_PORT_SAVE(match_port,match->port);
		BCM_API_XLATE_PORT_COND(match) BCM_API_XLATE_PORT_A2P(unit,&match->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_match_add_dispatch[dtype](unit, port, match);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(match) BCM_API_XLATE_PORT_RESTORE(match->port,match_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_match_add", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_match_delete( \
    int unit, bcm_gport_t port, bcm_port_match_info_t *match);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_match_delete,
static int (*_port_match_delete_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_port_match_info_t *match) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_match_delete(
    int unit, 
    bcm_gport_t port, 
    bcm_port_match_info_t *match)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(match_port);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_COND(match) BCM_API_XLATE_PORT_SAVE(match_port,match->port);
		BCM_API_XLATE_PORT_COND(match) BCM_API_XLATE_PORT_A2P(unit,&match->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_match_delete_dispatch[dtype](unit, port, match);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(match) BCM_API_XLATE_PORT_RESTORE(match->port,match_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_match_delete", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_match_delete_all( \
    int unit, bcm_gport_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_match_delete_all,
static int (*_port_match_delete_all_dispatch[])(
    int unit, 
    bcm_gport_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_match_delete_all(
    int unit, 
    bcm_gport_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_match_delete_all_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_match_delete_all", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_match_multi_get( \
    int unit, bcm_gport_t port, int size, bcm_port_match_info_t *match_array, int *count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_match_multi_get,
static int (*_port_match_multi_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int size, 
    bcm_port_match_info_t *match_array, 
    int *count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_match_multi_get(
    int unit, 
    bcm_gport_t port, 
    int size, 
    bcm_port_match_info_t *match_array, 
    int *count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_match_multi_get_dispatch[dtype](unit, port, size, match_array, count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(size,idx)
				BCM_API_XLATE_PORT_COND(match_array) BCM_API_XLATE_PORT_P2A(unit,&(match_array)[idx].port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_match_multi_get", 5, 3, unit, port, size, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_match_replace( \
    int unit, bcm_gport_t port, bcm_port_match_info_t *old_match, bcm_port_match_info_t *new_match);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_match_replace,
static int (*_port_match_replace_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_port_match_info_t *old_match, 
    bcm_port_match_info_t *new_match) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_match_replace(
    int unit, 
    bcm_gport_t port, 
    bcm_port_match_info_t *old_match, 
    bcm_port_match_info_t *new_match)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(old_match_port);
		BCM_API_XLATE_PORT_DECL(new_match_port);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_COND(old_match) BCM_API_XLATE_PORT_SAVE(old_match_port,old_match->port);
		BCM_API_XLATE_PORT_COND(old_match) BCM_API_XLATE_PORT_A2P(unit,&old_match->port);
		BCM_API_XLATE_PORT_COND(new_match) BCM_API_XLATE_PORT_SAVE(new_match_port,new_match->port);
		BCM_API_XLATE_PORT_COND(new_match) BCM_API_XLATE_PORT_A2P(unit,&new_match->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_match_replace_dispatch[dtype](unit, port, old_match, new_match);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(old_match) BCM_API_XLATE_PORT_RESTORE(old_match->port,old_match_port);
		BCM_API_XLATE_PORT_COND(new_match) BCM_API_XLATE_PORT_RESTORE(new_match->port,new_match_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_match_replace", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_match_set( \
    int unit, bcm_gport_t port, int size, bcm_port_match_info_t *match_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_match_set,
static int (*_port_match_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int size, 
    bcm_port_match_info_t *match_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_match_set(
    int unit, 
    bcm_gport_t port, 
    int size, 
    bcm_port_match_info_t *match_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_ITER(size,idx)
			BCM_API_XLATE_PORT_COND(match_array) BCM_API_XLATE_PORT_A2P(unit,&(match_array)[idx].port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_match_set_dispatch[dtype](unit, port, size, match_array);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_ITER(size,idx)
			BCM_API_XLATE_PORT_COND(match_array) BCM_API_XLATE_PORT_P2A(unit,&(match_array)[idx].port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_match_set", 4, 3, unit, port, size, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_mdix_get( \
    int unit, bcm_port_t port, bcm_port_mdix_t *mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_mdix_get,
static int (*_port_mdix_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_mdix_t *mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_mdix_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_mdix_t *mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_mdix_get_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_mdix_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_mdix_set( \
    int unit, bcm_port_t port, bcm_port_mdix_t mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_mdix_set,
static int (*_port_mdix_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_mdix_t mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_mdix_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_mdix_t mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_mdix_set_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_mdix_set", 3, 3, unit, port, mode, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_mdix_status_get( \
    int unit, bcm_port_t port, bcm_port_mdix_status_t *status);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_mdix_status_get,
static int (*_port_mdix_status_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_mdix_status_t *status) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_mdix_status_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_mdix_status_t *status)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_mdix_status_get_dispatch[dtype](unit, port, status);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_mdix_status_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_medium_config_get( \
    int unit, bcm_port_t port, bcm_port_medium_t medium, bcm_phy_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_medium_config_get,
static int (*_port_medium_config_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_medium_t medium, 
    bcm_phy_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_medium_config_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_medium_t medium, 
    bcm_phy_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_medium_config_get_dispatch[dtype](unit, port, medium, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_medium_config_get", 4, 3, unit, port, medium, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_medium_config_set( \
    int unit, bcm_port_t port, bcm_port_medium_t medium, bcm_phy_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_medium_config_set,
static int (*_port_medium_config_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_medium_t medium, 
    bcm_phy_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_medium_config_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_medium_t medium, 
    bcm_phy_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_medium_config_set_dispatch[dtype](unit, port, medium, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_medium_config_set", 4, 3, unit, port, medium, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_medium_get( \
    int unit, bcm_port_t port, bcm_port_medium_t *medium);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_medium_get,
static int (*_port_medium_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_medium_t *medium) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_medium_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_medium_t *medium)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_medium_get_dispatch[dtype](unit, port, medium);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_medium_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_medium_status_register( \
    int unit, bcm_port_t port, bcm_port_medium_status_cb_t callback, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_medium_status_register,
static int (*_port_medium_status_register_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_medium_status_cb_t callback, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_medium_status_register(
    int unit, 
    bcm_port_t port, 
    bcm_port_medium_status_cb_t callback, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_medium_status_register_dispatch[dtype](unit, port, callback, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_medium_status_register", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_medium_status_unregister( \
    int unit, bcm_port_t port, bcm_port_medium_status_cb_t callback, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_medium_status_unregister,
static int (*_port_medium_status_unregister_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_medium_status_cb_t callback, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_medium_status_unregister(
    int unit, 
    bcm_port_t port, 
    bcm_port_medium_status_cb_t callback, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_medium_status_unregister_dispatch[dtype](unit, port, callback, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_medium_status_unregister", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_modid_egress_get( \
    int unit, bcm_port_t port, bcm_module_t modid, bcm_pbmp_t *pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_modid_egress_get,
static int (*_port_modid_egress_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_module_t modid, 
    bcm_pbmp_t *pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_modid_egress_get(
    int unit, 
    bcm_port_t port, 
    bcm_module_t modid, 
    bcm_pbmp_t *pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_modid_egress_get_dispatch[dtype](unit, port, modid, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_modid_egress_get", 4, 3, unit, port, modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_modid_egress_set( \
    int unit, bcm_port_t port, bcm_module_t modid, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_modid_egress_set,
static int (*_port_modid_egress_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_module_t modid, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_modid_egress_set(
    int unit, 
    bcm_port_t port, 
    bcm_module_t modid, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_modid_egress_set_dispatch[dtype](unit, port, modid, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_modid_egress_set", 4, 3, unit, port, modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_modid_enable_get( \
    int unit, bcm_port_t port, int modid, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_modid_enable_get,
static int (*_port_modid_enable_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int modid, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_modid_enable_get(
    int unit, 
    bcm_port_t port, 
    int modid, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_modid_enable_get_dispatch[dtype](unit, port, modid, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_modid_enable_get", 4, 3, unit, port, modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_modid_enable_set( \
    int unit, bcm_port_t port, int modid, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_modid_enable_set,
static int (*_port_modid_enable_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int modid, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_modid_enable_set(
    int unit, 
    bcm_port_t port, 
    int modid, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_modid_enable_set_dispatch[dtype](unit, port, modid, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_modid_enable_set", 4, 3, unit, port, modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_pause_addr_get( \
    int unit, bcm_port_t port, bcm_mac_t mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_pause_addr_get,
static int (*_port_pause_addr_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_mac_t mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_pause_addr_get(
    int unit, 
    bcm_port_t port, 
    bcm_mac_t mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_pause_addr_get_dispatch[dtype](unit, port, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_pause_addr_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_pause_addr_set( \
    int unit, bcm_port_t port, bcm_mac_t mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_pause_addr_set,
static int (*_port_pause_addr_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_mac_t mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_pause_addr_set(
    int unit, 
    bcm_port_t port, 
    bcm_mac_t mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_pause_addr_set_dispatch[dtype](unit, port, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_pause_addr_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_pause_get( \
    int unit, bcm_port_t port, int *pause_tx, int *pause_rx);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_pause_get,
static int (*_port_pause_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *pause_tx, 
    int *pause_rx) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_pause_get(
    int unit, 
    bcm_port_t port, 
    int *pause_tx, 
    int *pause_rx)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_pause_get_dispatch[dtype](unit, port, pause_tx, pause_rx);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_pause_get", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_pause_set( \
    int unit, bcm_port_t port, int pause_tx, int pause_rx);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_pause_set,
static int (*_port_pause_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int pause_tx, 
    int pause_rx) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_pause_set(
    int unit, 
    bcm_port_t port, 
    int pause_tx, 
    int pause_rx)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_pause_set_dispatch[dtype](unit, port, pause_tx, pause_rx);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_pause_set", 4, 3, unit, port, pause_tx, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_pause_sym_get( \
    int unit, bcm_port_t port, int *pause);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_pause_sym_get,
static int (*_port_pause_sym_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *pause) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_pause_sym_get(
    int unit, 
    bcm_port_t port, 
    int *pause)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_pause_sym_get_dispatch[dtype](unit, port, pause);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_pause_sym_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_pause_sym_set( \
    int unit, bcm_port_t port, int pause);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_pause_sym_set,
static int (*_port_pause_sym_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int pause) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_pause_sym_set(
    int unit, 
    bcm_port_t port, 
    int pause)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_pause_sym_set_dispatch[dtype](unit, port, pause);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_pause_sym_set", 3, 3, unit, port, pause, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_pfm_get( \
    int unit, bcm_port_t port, int *mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_pfm_get,
static int (*_port_pfm_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_pfm_get(
    int unit, 
    bcm_port_t port, 
    int *mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_pfm_get_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_pfm_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_pfm_set( \
    int unit, bcm_port_t port, int mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_pfm_set,
static int (*_port_pfm_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_pfm_set(
    int unit, 
    bcm_port_t port, 
    int mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_pfm_set_dispatch[dtype](unit, port, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_pfm_set", 3, 3, unit, port, mode, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_phy_control_get( \
    int unit, bcm_port_t port, bcm_port_phy_control_t type, uint32 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_phy_control_get,
static int (*_port_phy_control_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_control_t type, 
    uint32 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_phy_control_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_control_t type, 
    uint32 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_phy_control_get_dispatch[dtype](unit, port, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_phy_control_get", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_phy_control_set( \
    int unit, bcm_port_t port, bcm_port_phy_control_t type, uint32 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_phy_control_set,
static int (*_port_phy_control_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_control_t type, 
    uint32 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_phy_control_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_control_t type, 
    uint32 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_phy_control_set_dispatch[dtype](unit, port, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_phy_control_set", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_phy_drv_name_get( \
    int unit, bcm_port_t port, char *name, int len);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_phy_drv_name_get,
static int (*_port_phy_drv_name_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    char *name, 
    int len) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_phy_drv_name_get(
    int unit, 
    bcm_port_t port, 
    char *name, 
    int len)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_phy_drv_name_get_dispatch[dtype](unit, port, name, len);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_phy_drv_name_get", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_phy_firmware_set( \
    int unit, bcm_port_t port, uint32 flags, int offset, uint8 *array, int length);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_phy_firmware_set,
static int (*_port_phy_firmware_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int offset, 
    uint8 *array, 
    int length) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_phy_firmware_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int offset, 
    uint8 *array, 
    int length)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_phy_firmware_set_dispatch[dtype](unit, port, flags, offset, array, length);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_phy_firmware_set", 6, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_phy_get( \
    int unit, bcm_port_t port, uint32 flags, uint32 phy_reg_addr, uint32 *phy_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_phy_get,
static int (*_port_phy_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 phy_reg_addr, 
    uint32 *phy_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_phy_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 phy_reg_addr, 
    uint32 *phy_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_phy_get_dispatch[dtype](unit, port, flags, phy_reg_addr, phy_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_phy_get", 5, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_phy_modify( \
    int unit, bcm_port_t port, uint32 flags, uint32 phy_reg_addr, uint32 phy_data, uint32 phy_mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_phy_modify,
static int (*_port_phy_modify_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 phy_reg_addr, 
    uint32 phy_data, 
    uint32 phy_mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_phy_modify(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 phy_reg_addr, 
    uint32 phy_data, 
    uint32 phy_mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_phy_modify_dispatch[dtype](unit, port, flags, phy_reg_addr, phy_data, phy_mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_phy_modify", 6, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_phy_multi_get( \
    int unit, bcm_port_t port, uint32 flags, uint32 dev_addr, uint32 offset, int max_size, uint8 *data, int *actual_size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_phy_multi_get,
static int (*_port_phy_multi_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 dev_addr, 
    uint32 offset, 
    int max_size, 
    uint8 *data, 
    int *actual_size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_phy_multi_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 dev_addr, 
    uint32 offset, 
    int max_size, 
    uint8 *data, 
    int *actual_size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_phy_multi_get_dispatch[dtype](unit, port, flags, dev_addr, offset, max_size, data, actual_size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_phy_multi_get", 8, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_phy_reset( \
    int unit, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_phy_reset,
static int (*_port_phy_reset_dispatch[])(
    int unit, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_phy_reset(
    int unit, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_phy_reset_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_phy_reset", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_phy_reset_register( \
    int unit, bcm_port_t port, bcm_port_phy_reset_cb_t callback, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_phy_reset_register,
static int (*_port_phy_reset_register_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_reset_cb_t callback, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_phy_reset_register(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_reset_cb_t callback, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_phy_reset_register_dispatch[dtype](unit, port, callback, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_phy_reset_register", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_phy_reset_unregister( \
    int unit, bcm_port_t port, bcm_port_phy_reset_cb_t callback, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_phy_reset_unregister,
static int (*_port_phy_reset_unregister_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_reset_cb_t callback, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_phy_reset_unregister(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_reset_cb_t callback, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_phy_reset_unregister_dispatch[dtype](unit, port, callback, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_phy_reset_unregister", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_phy_set( \
    int unit, bcm_port_t port, uint32 flags, uint32 phy_reg_addr, uint32 phy_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_phy_set,
static int (*_port_phy_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 phy_reg_addr, 
    uint32 phy_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_phy_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 phy_reg_addr, 
    uint32 phy_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_phy_set_dispatch[dtype](unit, port, flags, phy_reg_addr, phy_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_phy_set", 5, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_phy_timesync_config_get( \
    int unit, bcm_port_t port, bcm_port_phy_timesync_config_t *conf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_phy_timesync_config_get,
static int (*_port_phy_timesync_config_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_timesync_config_t *conf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_phy_timesync_config_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_timesync_config_t *conf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_phy_timesync_config_get_dispatch[dtype](unit, port, conf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_phy_timesync_config_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_phy_timesync_config_set( \
    int unit, bcm_port_t port, bcm_port_phy_timesync_config_t *conf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_phy_timesync_config_set,
static int (*_port_phy_timesync_config_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_timesync_config_t *conf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_phy_timesync_config_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_timesync_config_t *conf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_phy_timesync_config_set_dispatch[dtype](unit, port, conf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_phy_timesync_config_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_phy_timesync_enhanced_capture_get( \
    int unit, bcm_port_t port, bcm_port_phy_timesync_enhanced_capture_t *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_phy_timesync_enhanced_capture_get,
static int (*_port_phy_timesync_enhanced_capture_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_timesync_enhanced_capture_t *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_phy_timesync_enhanced_capture_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_timesync_enhanced_capture_t *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_phy_timesync_enhanced_capture_get_dispatch[dtype](unit, port, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_phy_timesync_enhanced_capture_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_policer_get( \
    int unit, bcm_port_t port, bcm_policer_t *policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_policer_get,
static int (*_port_policer_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_policer_t *policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_policer_get(
    int unit, 
    bcm_port_t port, 
    bcm_policer_t *policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_policer_get_dispatch[dtype](unit, port, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_policer_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_policer_set( \
    int unit, bcm_port_t port, bcm_policer_t policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_policer_set,
static int (*_port_policer_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_policer_t policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_policer_set(
    int unit, 
    bcm_port_t port, 
    bcm_policer_t policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_policer_set_dispatch[dtype](unit, port, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_policer_set", 3, 3, unit, port, policer_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_pon_info_get( \
    int unit, bcm_port_t pon_port, bcm_port_pon_info_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_pon_info_get,
static int (*_port_pon_info_get_dispatch[])(
    int unit, 
    bcm_port_t pon_port, 
    bcm_port_pon_info_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_pon_info_get(
    int unit, 
    bcm_port_t pon_port, 
    bcm_port_pon_info_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&pon_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_pon_info_get_dispatch[dtype](unit, pon_port, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_pon_info_get", 3, 2, unit, pon_port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_pon_info_set( \
    int unit, bcm_port_t pon_port, bcm_port_pon_info_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_pon_info_set,
static int (*_port_pon_info_set_dispatch[])(
    int unit, 
    bcm_port_t pon_port, 
    bcm_port_pon_info_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_pon_info_set(
    int unit, 
    bcm_port_t pon_port, 
    bcm_port_pon_info_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&pon_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_pon_info_set_dispatch[dtype](unit, pon_port, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_pon_info_set", 3, 2, unit, pon_port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_pon_tunnel_add( \
    int unit, bcm_gport_t pon_port, uint32 flags, bcm_gport_t *tunnel_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_pon_tunnel_add,
static int (*_port_pon_tunnel_add_dispatch[])(
    int unit, 
    bcm_gport_t pon_port, 
    uint32 flags, 
    bcm_gport_t *tunnel_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_pon_tunnel_add(
    int unit, 
    bcm_gport_t pon_port, 
    uint32 flags, 
    bcm_gport_t *tunnel_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&pon_port);
		BCM_API_XLATE_PORT_A2P(unit,tunnel_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_pon_tunnel_add_dispatch[dtype](unit, pon_port, flags, tunnel_port_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,tunnel_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_pon_tunnel_add", 4, 3, unit, pon_port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_pon_tunnel_map_get( \
    int unit, bcm_gport_t pon_port, bcm_tunnel_id_t tunnel_id, bcm_gport_t *tunnel_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_pon_tunnel_map_get,
static int (*_port_pon_tunnel_map_get_dispatch[])(
    int unit, 
    bcm_gport_t pon_port, 
    bcm_tunnel_id_t tunnel_id, 
    bcm_gport_t *tunnel_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_pon_tunnel_map_get(
    int unit, 
    bcm_gport_t pon_port, 
    bcm_tunnel_id_t tunnel_id, 
    bcm_gport_t *tunnel_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&pon_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_pon_tunnel_map_get_dispatch[dtype](unit, pon_port, tunnel_id, tunnel_port_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,tunnel_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_pon_tunnel_map_get", 4, 3, unit, pon_port, tunnel_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_pon_tunnel_map_set( \
    int unit, bcm_gport_t pon_port, bcm_tunnel_id_t tunnel_id, bcm_gport_t tunnel_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_pon_tunnel_map_set,
static int (*_port_pon_tunnel_map_set_dispatch[])(
    int unit, 
    bcm_gport_t pon_port, 
    bcm_tunnel_id_t tunnel_id, 
    bcm_gport_t tunnel_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_pon_tunnel_map_set(
    int unit, 
    bcm_gport_t pon_port, 
    bcm_tunnel_id_t tunnel_id, 
    bcm_gport_t tunnel_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&pon_port);
		BCM_API_XLATE_PORT_A2P(unit,&tunnel_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_pon_tunnel_map_set_dispatch[dtype](unit, pon_port, tunnel_id, tunnel_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_pon_tunnel_map_set", 4, 3, unit, pon_port, tunnel_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_pon_tunnel_remove( \
    int unit, bcm_gport_t tunnel_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_pon_tunnel_remove,
static int (*_port_pon_tunnel_remove_dispatch[])(
    int unit, 
    bcm_gport_t tunnel_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_pon_tunnel_remove(
    int unit, 
    bcm_gport_t tunnel_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&tunnel_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_pon_tunnel_remove_dispatch[dtype](unit, tunnel_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_pon_tunnel_remove", 2, 2, unit, tunnel_port_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_priority_color_get( \
    int unit, bcm_port_t port, int prio, bcm_color_t *color);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_priority_color_get,
static int (*_port_priority_color_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int prio, 
    bcm_color_t *color) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_priority_color_get(
    int unit, 
    bcm_port_t port, 
    int prio, 
    bcm_color_t *color)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_priority_color_get_dispatch[dtype](unit, port, prio, color);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_priority_color_get", 4, 3, unit, port, prio, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_priority_color_set( \
    int unit, bcm_port_t port, int prio, bcm_color_t color);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_priority_color_set,
static int (*_port_priority_color_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int prio, 
    bcm_color_t color) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_priority_color_set(
    int unit, 
    bcm_port_t port, 
    int prio, 
    bcm_color_t color)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_priority_color_set_dispatch[dtype](unit, port, prio, color);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_priority_color_set", 4, 3, unit, port, prio, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_probe( \
    int unit, bcm_pbmp_t pbmp, bcm_pbmp_t *okay_pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_probe,
static int (*_port_probe_dispatch[])(
    int unit, 
    bcm_pbmp_t pbmp, 
    bcm_pbmp_t *okay_pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_probe(
    int unit, 
    bcm_pbmp_t pbmp, 
    bcm_pbmp_t *okay_pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_probe_dispatch[dtype](unit, pbmp, okay_pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,okay_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_probe", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_protocol_vlan_add( \
    int unit, bcm_port_t port, bcm_port_frametype_t frame, bcm_port_ethertype_t ether, bcm_vlan_t vid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_protocol_vlan_add,
static int (*_port_protocol_vlan_add_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_frametype_t frame, 
    bcm_port_ethertype_t ether, 
    bcm_vlan_t vid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_protocol_vlan_add(
    int unit, 
    bcm_port_t port, 
    bcm_port_frametype_t frame, 
    bcm_port_ethertype_t ether, 
    bcm_vlan_t vid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_protocol_vlan_add_dispatch[dtype](unit, port, frame, ether, vid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_protocol_vlan_add", 5, 3, unit, port, frame, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_protocol_vlan_delete( \
    int unit, bcm_port_t port, bcm_port_frametype_t frame, bcm_port_ethertype_t ether);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_protocol_vlan_delete,
static int (*_port_protocol_vlan_delete_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_frametype_t frame, 
    bcm_port_ethertype_t ether) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_protocol_vlan_delete(
    int unit, 
    bcm_port_t port, 
    bcm_port_frametype_t frame, 
    bcm_port_ethertype_t ether)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_protocol_vlan_delete_dispatch[dtype](unit, port, frame, ether);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_protocol_vlan_delete", 4, 3, unit, port, frame, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_protocol_vlan_delete_all( \
    int unit, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_protocol_vlan_delete_all,
static int (*_port_protocol_vlan_delete_all_dispatch[])(
    int unit, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_protocol_vlan_delete_all(
    int unit, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_protocol_vlan_delete_all_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_protocol_vlan_delete_all", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_queued_count_get( \
    int unit, bcm_port_t port, uint32 *count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_queued_count_get,
static int (*_port_queued_count_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 *count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_queued_count_get(
    int unit, 
    bcm_port_t port, 
    uint32 *count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_queued_count_get_dispatch[dtype](unit, port, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_queued_count_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_rate_egress_get( \
    int unit, bcm_port_t port, uint32 *kbits_sec, uint32 *kbits_burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_rate_egress_get,
static int (*_port_rate_egress_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 *kbits_sec, 
    uint32 *kbits_burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_rate_egress_get(
    int unit, 
    bcm_port_t port, 
    uint32 *kbits_sec, 
    uint32 *kbits_burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_rate_egress_get_dispatch[dtype](unit, port, kbits_sec, kbits_burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_rate_egress_get", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_rate_egress_pps_get( \
    int unit, bcm_port_t port, uint32 *pps, uint32 *burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_rate_egress_pps_get,
static int (*_port_rate_egress_pps_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 *pps, 
    uint32 *burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_rate_egress_pps_get(
    int unit, 
    bcm_port_t port, 
    uint32 *pps, 
    uint32 *burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_rate_egress_pps_get_dispatch[dtype](unit, port, pps, burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_rate_egress_pps_get", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_rate_egress_pps_set( \
    int unit, bcm_port_t port, uint32 pps, uint32 burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_rate_egress_pps_set,
static int (*_port_rate_egress_pps_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 pps, 
    uint32 burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_rate_egress_pps_set(
    int unit, 
    bcm_port_t port, 
    uint32 pps, 
    uint32 burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_rate_egress_pps_set_dispatch[dtype](unit, port, pps, burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_rate_egress_pps_set", 4, 3, unit, port, pps, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_rate_egress_set( \
    int unit, bcm_port_t port, uint32 kbits_sec, uint32 kbits_burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_rate_egress_set,
static int (*_port_rate_egress_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 kbits_sec, 
    uint32 kbits_burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_rate_egress_set(
    int unit, 
    bcm_port_t port, 
    uint32 kbits_sec, 
    uint32 kbits_burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_rate_egress_set_dispatch[dtype](unit, port, kbits_sec, kbits_burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_rate_egress_set", 4, 3, unit, port, kbits_sec, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_rate_egress_traffic_get( \
    int unit, bcm_port_t port, uint32 *traffic_types, uint32 *kbits_sec, uint32 *kbits_burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_rate_egress_traffic_get,
static int (*_port_rate_egress_traffic_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 *traffic_types, 
    uint32 *kbits_sec, 
    uint32 *kbits_burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_rate_egress_traffic_get(
    int unit, 
    bcm_port_t port, 
    uint32 *traffic_types, 
    uint32 *kbits_sec, 
    uint32 *kbits_burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_rate_egress_traffic_get_dispatch[dtype](unit, port, traffic_types, kbits_sec, kbits_burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_rate_egress_traffic_get", 5, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_rate_egress_traffic_set( \
    int unit, bcm_port_t port, uint32 traffic_types, uint32 kbits_sec, uint32 kbits_burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_rate_egress_traffic_set,
static int (*_port_rate_egress_traffic_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 traffic_types, 
    uint32 kbits_sec, 
    uint32 kbits_burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_rate_egress_traffic_set(
    int unit, 
    bcm_port_t port, 
    uint32 traffic_types, 
    uint32 kbits_sec, 
    uint32 kbits_burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_rate_egress_traffic_set_dispatch[dtype](unit, port, traffic_types, kbits_sec, kbits_burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_rate_egress_traffic_set", 5, 3, unit, port, traffic_types, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_rate_ingress_get( \
    int unit, bcm_port_t port, uint32 *kbits_sec, uint32 *kbits_burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_rate_ingress_get,
static int (*_port_rate_ingress_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 *kbits_sec, 
    uint32 *kbits_burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_rate_ingress_get(
    int unit, 
    bcm_port_t port, 
    uint32 *kbits_sec, 
    uint32 *kbits_burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_rate_ingress_get_dispatch[dtype](unit, port, kbits_sec, kbits_burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_rate_ingress_get", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_rate_ingress_set( \
    int unit, bcm_port_t port, uint32 kbits_sec, uint32 kbits_burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_rate_ingress_set,
static int (*_port_rate_ingress_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 kbits_sec, 
    uint32 kbits_burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_rate_ingress_set(
    int unit, 
    bcm_port_t port, 
    uint32 kbits_sec, 
    uint32 kbits_burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_rate_ingress_set_dispatch[dtype](unit, port, kbits_sec, kbits_burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_rate_ingress_set", 4, 3, unit, port, kbits_sec, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_rate_pause_get( \
    int unit, bcm_port_t port, uint32 *kbits_pause, uint32 *kbits_resume);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_rate_pause_get,
static int (*_port_rate_pause_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 *kbits_pause, 
    uint32 *kbits_resume) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_rate_pause_get(
    int unit, 
    bcm_port_t port, 
    uint32 *kbits_pause, 
    uint32 *kbits_resume)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_rate_pause_get_dispatch[dtype](unit, port, kbits_pause, kbits_resume);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_rate_pause_get", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_rate_pause_set( \
    int unit, bcm_port_t port, uint32 kbits_pause, uint32 kbits_resume);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_rate_pause_set,
static int (*_port_rate_pause_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 kbits_pause, 
    uint32 kbits_resume) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_rate_pause_set(
    int unit, 
    bcm_port_t port, 
    uint32 kbits_pause, 
    uint32 kbits_resume)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_rate_pause_set_dispatch[dtype](unit, port, kbits_pause, kbits_resume);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_rate_pause_set", 4, 3, unit, port, kbits_pause, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_sample_rate_get( \
    int unit, bcm_port_t port, int *ingress_rate, int *egress_rate);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_sample_rate_get,
static int (*_port_sample_rate_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *ingress_rate, 
    int *egress_rate) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_sample_rate_get(
    int unit, 
    bcm_port_t port, 
    int *ingress_rate, 
    int *egress_rate)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_sample_rate_get_dispatch[dtype](unit, port, ingress_rate, egress_rate);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_sample_rate_get", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_sample_rate_set( \
    int unit, bcm_port_t port, int ingress_rate, int egress_rate);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_sample_rate_set,
static int (*_port_sample_rate_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int ingress_rate, 
    int egress_rate) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_sample_rate_set(
    int unit, 
    bcm_port_t port, 
    int ingress_rate, 
    int egress_rate)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_sample_rate_set_dispatch[dtype](unit, port, ingress_rate, egress_rate);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_sample_rate_set", 4, 3, unit, port, ingress_rate, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_selective_get( \
    int unit, bcm_port_t port, bcm_port_info_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_selective_get,
static int (*_port_selective_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_info_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_selective_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_info_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_selective_get_dispatch[dtype](unit, port, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_selective_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_selective_set( \
    int unit, bcm_port_t port, bcm_port_info_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_selective_set,
static int (*_port_selective_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_info_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_selective_set(
    int unit, 
    bcm_port_t port, 
    bcm_port_info_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_selective_set_dispatch[dtype](unit, port, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_selective_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_speed_get( \
    int unit, bcm_port_t port, int *speed);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_speed_get,
static int (*_port_speed_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *speed) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_speed_get(
    int unit, 
    bcm_port_t port, 
    int *speed)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_speed_get_dispatch[dtype](unit, port, speed);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_speed_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_speed_max( \
    int unit, bcm_port_t port, int *speed);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_speed_max,
static int (*_port_speed_max_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *speed) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_speed_max(
    int unit, 
    bcm_port_t port, 
    int *speed)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_speed_max_dispatch[dtype](unit, port, speed);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_speed_max", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_speed_set( \
    int unit, bcm_port_t port, int speed);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_speed_set,
static int (*_port_speed_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int speed) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_speed_set(
    int unit, 
    bcm_port_t port, 
    int speed)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_speed_set_dispatch[dtype](unit, port, speed);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_speed_set", 3, 3, unit, port, speed, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_attach( \
    int unit, bcm_gport_t port, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_attach,
static int (*_port_stat_attach_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_attach(
    int unit, 
    bcm_gport_t port, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_attach_dispatch[dtype](unit, port, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_attach", 3, 3, unit, port, stat_counter_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_counter_get( \
    int unit, bcm_gport_t port, bcm_port_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_counter_get,
static int (*_port_stat_counter_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_counter_get(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_counter_get_dispatch[dtype](unit, port, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_counter_get", 6, 3, unit, port, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_counter_set( \
    int unit, bcm_gport_t port, bcm_port_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_counter_set,
static int (*_port_stat_counter_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_counter_set(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_counter_set_dispatch[dtype](unit, port, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_counter_set", 6, 3, unit, port, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_counter_sync_get( \
    int unit, bcm_gport_t port, bcm_port_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_counter_sync_get,
static int (*_port_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_counter_sync_get(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_counter_sync_get_dispatch[dtype](unit, port, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_counter_sync_get", 6, 3, unit, port, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_detach( \
    int unit, bcm_gport_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_detach,
static int (*_port_stat_detach_dispatch[])(
    int unit, 
    bcm_gport_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_detach(
    int unit, 
    bcm_gport_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_detach_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_detach", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_detach_with_id( \
    int unit, bcm_gport_t port, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_detach_with_id,
static int (*_port_stat_detach_with_id_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_detach_with_id(
    int unit, 
    bcm_gport_t port, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_detach_with_id_dispatch[dtype](unit, port, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_detach_with_id", 3, 3, unit, port, stat_counter_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_enable_set( \
    int unit, bcm_gport_t port, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_enable_set,
static int (*_port_stat_enable_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_enable_set(
    int unit, 
    bcm_gport_t port, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_enable_set_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_enable_set", 3, 3, unit, port, enable, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_get( \
    int unit, bcm_gport_t port, bcm_port_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_get,
static int (*_port_stat_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_get(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_get_dispatch[dtype](unit, port, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_get", 4, 3, unit, port, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_get32( \
    int unit, bcm_gport_t port, bcm_port_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_get32,
static int (*_port_stat_get32_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_get32(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_get32_dispatch[dtype](unit, port, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_get32", 4, 3, unit, port, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_id_get( \
    int unit, bcm_gport_t port, bcm_port_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_id_get,
static int (*_port_stat_id_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_id_get(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_id_get_dispatch[dtype](unit, port, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_id_get", 4, 3, unit, port, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_multi_get( \
    int unit, bcm_gport_t port, int nstat, bcm_port_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_multi_get,
static int (*_port_stat_multi_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int nstat, 
    bcm_port_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_multi_get(
    int unit, 
    bcm_gport_t port, 
    int nstat, 
    bcm_port_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_multi_get_dispatch[dtype](unit, port, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_multi_get", 5, 3, unit, port, nstat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_multi_get32( \
    int unit, bcm_gport_t port, int nstat, bcm_port_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_multi_get32,
static int (*_port_stat_multi_get32_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int nstat, 
    bcm_port_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_multi_get32(
    int unit, 
    bcm_gport_t port, 
    int nstat, 
    bcm_port_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_multi_get32_dispatch[dtype](unit, port, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_multi_get32", 5, 3, unit, port, nstat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_multi_set( \
    int unit, bcm_gport_t port, int nstat, bcm_port_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_multi_set,
static int (*_port_stat_multi_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int nstat, 
    bcm_port_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_multi_set(
    int unit, 
    bcm_gport_t port, 
    int nstat, 
    bcm_port_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_multi_set_dispatch[dtype](unit, port, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_multi_set", 5, 3, unit, port, nstat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_multi_set32( \
    int unit, bcm_gport_t port, int nstat, bcm_port_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_multi_set32,
static int (*_port_stat_multi_set32_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int nstat, 
    bcm_port_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_multi_set32(
    int unit, 
    bcm_gport_t port, 
    int nstat, 
    bcm_port_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_multi_set32_dispatch[dtype](unit, port, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_multi_set32", 5, 3, unit, port, nstat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_set( \
    int unit, bcm_gport_t port, bcm_port_stat_t stat, uint64 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_set,
static int (*_port_stat_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint64 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_set(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint64 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_set_dispatch[dtype](unit, port, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_set", 4, 3, unit, port, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_set32( \
    int unit, bcm_gport_t port, bcm_port_stat_t stat, uint32 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_set32,
static int (*_port_stat_set32_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint32 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_set32(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint32 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_set32_dispatch[dtype](unit, port, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_set32", 4, 3, unit, port, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_sync_get( \
    int unit, bcm_gport_t port, bcm_port_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_sync_get,
static int (*_port_stat_sync_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_sync_get(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_sync_get_dispatch[dtype](unit, port, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_sync_get", 4, 3, unit, port, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stat_sync_get32( \
    int unit, bcm_gport_t port, bcm_port_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stat_sync_get32,
static int (*_port_stat_sync_get32_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stat_sync_get32(
    int unit, 
    bcm_gport_t port, 
    bcm_port_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stat_sync_get32_dispatch[dtype](unit, port, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stat_sync_get32", 4, 3, unit, port, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stp_get( \
    int unit, bcm_port_t port, int *state);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stp_get,
static int (*_port_stp_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *state) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stp_get(
    int unit, 
    bcm_port_t port, 
    int *state)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stp_get_dispatch[dtype](unit, port, state);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stp_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_stp_set( \
    int unit, bcm_port_t port, int state);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_stp_set,
static int (*_port_stp_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int state) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_stp_set(
    int unit, 
    bcm_port_t port, 
    int state)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_stp_set_dispatch[dtype](unit, port, state);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_stp_set", 3, 3, unit, port, state, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_subsidiary_ports_get( \
    int unit, bcm_port_t port, bcm_pbmp_t *pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_subsidiary_ports_get,
static int (*_port_subsidiary_ports_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_pbmp_t *pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_subsidiary_ports_get(
    int unit, 
    bcm_port_t port, 
    bcm_pbmp_t *pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_subsidiary_ports_get_dispatch[dtype](unit, port, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_subsidiary_ports_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_tdm_cas_abcd_get( \
    int unit, bcm_port_t tdm_port, bcm_tdm_port_cas_status_t status, uint8 *cas_abcd);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_tdm_cas_abcd_get,
static int (*_port_tdm_cas_abcd_get_dispatch[])(
    int unit, 
    bcm_port_t tdm_port, 
    bcm_tdm_port_cas_status_t status, 
    uint8 *cas_abcd) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_tdm_cas_abcd_get(
    int unit, 
    bcm_port_t tdm_port, 
    bcm_tdm_port_cas_status_t status, 
    uint8 *cas_abcd)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&tdm_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_tdm_cas_abcd_get_dispatch[dtype](unit, tdm_port, status, cas_abcd);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_tdm_cas_abcd_get", 4, 3, unit, tdm_port, status, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_tdm_cas_status_get( \
    int unit, bcm_port_t tdm_port, uint32 *cas_changed);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_tdm_cas_status_get,
static int (*_port_tdm_cas_status_get_dispatch[])(
    int unit, 
    bcm_port_t tdm_port, 
    uint32 *cas_changed) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_tdm_cas_status_get(
    int unit, 
    bcm_port_t tdm_port, 
    uint32 *cas_changed)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&tdm_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_tdm_cas_status_get_dispatch[dtype](unit, tdm_port, cas_changed);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_tdm_cas_status_get", 3, 2, unit, tdm_port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_tdm_ces_ports_get( \
    int unit, bcm_port_t tdm_port, uint32 *n_ports, uint32 ces_ports[BCM_CES_SLOT_MAX]);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_tdm_ces_ports_get,
static int (*_port_tdm_ces_ports_get_dispatch[])(
    int unit, 
    bcm_port_t tdm_port, 
    uint32 *n_ports, 
    uint32 ces_ports[BCM_CES_SLOT_MAX]) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_tdm_ces_ports_get(
    int unit, 
    bcm_port_t tdm_port, 
    uint32 *n_ports, 
    uint32 ces_ports[BCM_CES_SLOT_MAX])
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&tdm_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_tdm_ces_ports_get_dispatch[dtype](unit, tdm_port, n_ports, ces_ports);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_tdm_ces_ports_get", 4, 2, unit, tdm_port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_tdm_config_get( \
    int unit, bcm_port_t tdm_port, bcm_tdm_port_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_tdm_config_get,
static int (*_port_tdm_config_get_dispatch[])(
    int unit, 
    bcm_port_t tdm_port, 
    bcm_tdm_port_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_tdm_config_get(
    int unit, 
    bcm_port_t tdm_port, 
    bcm_tdm_port_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&tdm_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_tdm_config_get_dispatch[dtype](unit, tdm_port, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_tdm_config_get", 3, 2, unit, tdm_port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_CES)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_tdm_config_set( \
    int unit, bcm_port_t tdm_port, bcm_tdm_port_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_tdm_config_set,
static int (*_port_tdm_config_set_dispatch[])(
    int unit, 
    bcm_port_t tdm_port, 
    bcm_tdm_port_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_tdm_config_set(
    int unit, 
    bcm_port_t tdm_port, 
    bcm_tdm_port_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&tdm_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_tdm_config_set_dispatch[dtype](unit, tdm_port, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_tdm_config_set", 3, 2, unit, tdm_port, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_tgid_get( \
    int unit, bcm_port_t port, int *tgid, int *psc);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_tgid_get,
static int (*_port_tgid_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *tgid, 
    int *psc) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_tgid_get(
    int unit, 
    bcm_port_t port, 
    int *tgid, 
    int *psc)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_tgid_get_dispatch[dtype](unit, port, tgid, psc);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_tgid_get", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_tgid_set( \
    int unit, bcm_port_t port, int tgid, int psc);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_tgid_set,
static int (*_port_tgid_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int tgid, 
    int psc) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_tgid_set(
    int unit, 
    bcm_port_t port, 
    int tgid, 
    int psc)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_tgid_set_dispatch[dtype](unit, port, tgid, psc);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_tgid_set", 4, 3, unit, port, tgid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_timesync_config_get( \
    int unit, bcm_port_t port, int array_size, bcm_port_timesync_config_t *config_array, int *array_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_timesync_config_get,
static int (*_port_timesync_config_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int array_size, 
    bcm_port_timesync_config_t *config_array, 
    int *array_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_timesync_config_get(
    int unit, 
    bcm_port_t port, 
    int array_size, 
    bcm_port_timesync_config_t *config_array, 
    int *array_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_timesync_config_get_dispatch[dtype](unit, port, array_size, config_array, array_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_timesync_config_get", 5, 3, unit, port, array_size, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_timesync_config_set( \
    int unit, bcm_port_t port, int config_count, bcm_port_timesync_config_t *config_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_timesync_config_set,
static int (*_port_timesync_config_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int config_count, 
    bcm_port_timesync_config_t *config_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_timesync_config_set(
    int unit, 
    bcm_port_t port, 
    int config_count, 
    bcm_port_timesync_config_t *config_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_timesync_config_set_dispatch[dtype](unit, port, config_count, config_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_timesync_config_set", 4, 3, unit, port, config_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_tpid_add( \
    int unit, bcm_port_t port, uint16 tpid, int color_select);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_tpid_add,
static int (*_port_tpid_add_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint16 tpid, 
    int color_select) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_tpid_add(
    int unit, 
    bcm_port_t port, 
    uint16 tpid, 
    int color_select)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_tpid_add_dispatch[dtype](unit, port, tpid, color_select);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_tpid_add", 4, 3, unit, port, tpid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_tpid_class_get( \
    int unit, bcm_port_tpid_class_t *tpid_class);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_tpid_class_get,
static int (*_port_tpid_class_get_dispatch[])(
    int unit, 
    bcm_port_tpid_class_t *tpid_class) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_tpid_class_get(
    int unit, 
    bcm_port_tpid_class_t *tpid_class)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(tpid_class) BCM_API_XLATE_PORT_A2P(unit,&tpid_class->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_tpid_class_get_dispatch[dtype](unit, tpid_class);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(tpid_class) BCM_API_XLATE_PORT_P2A(unit,&tpid_class->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_tpid_class_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_tpid_class_set( \
    int unit, bcm_port_tpid_class_t *tpid_class);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_tpid_class_set,
static int (*_port_tpid_class_set_dispatch[])(
    int unit, 
    bcm_port_tpid_class_t *tpid_class) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_tpid_class_set(
    int unit, 
    bcm_port_tpid_class_t *tpid_class)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(tpid_class_port);
		BCM_API_XLATE_PORT_COND(tpid_class) BCM_API_XLATE_PORT_SAVE(tpid_class_port,tpid_class->port);
		BCM_API_XLATE_PORT_COND(tpid_class) BCM_API_XLATE_PORT_A2P(unit,&tpid_class->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_tpid_class_set_dispatch[dtype](unit, tpid_class);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(tpid_class) BCM_API_XLATE_PORT_RESTORE(tpid_class->port,tpid_class_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_tpid_class_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_tpid_delete( \
    int unit, bcm_port_t port, uint16 tpid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_tpid_delete,
static int (*_port_tpid_delete_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint16 tpid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_tpid_delete(
    int unit, 
    bcm_port_t port, 
    uint16 tpid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_tpid_delete_dispatch[dtype](unit, port, tpid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_tpid_delete", 3, 3, unit, port, tpid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_tpid_delete_all( \
    int unit, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_tpid_delete_all,
static int (*_port_tpid_delete_all_dispatch[])(
    int unit, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_tpid_delete_all(
    int unit, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_tpid_delete_all_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_tpid_delete_all", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_tpid_get( \
    int unit, bcm_port_t port, uint16 *tpid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_tpid_get,
static int (*_port_tpid_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint16 *tpid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_tpid_get(
    int unit, 
    bcm_port_t port, 
    uint16 *tpid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_tpid_get_dispatch[dtype](unit, port, tpid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_tpid_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_tpid_get_all( \
    int unit, bcm_port_t port, int size, uint16 *tpid_array, int *color_array, int *count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_tpid_get_all,
static int (*_port_tpid_get_all_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int size, 
    uint16 *tpid_array, 
    int *color_array, 
    int *count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_tpid_get_all(
    int unit, 
    bcm_port_t port, 
    int size, 
    uint16 *tpid_array, 
    int *color_array, 
    int *count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_tpid_get_all_dispatch[dtype](unit, port, size, tpid_array, color_array, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_tpid_get_all", 6, 3, unit, port, size, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_tpid_set( \
    int unit, bcm_port_t port, uint16 tpid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_tpid_set,
static int (*_port_tpid_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint16 tpid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_tpid_set(
    int unit, 
    bcm_port_t port, 
    uint16 tpid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_tpid_set_dispatch[dtype](unit, port, tpid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_tpid_set", 3, 3, unit, port, tpid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_trunk_index_get( \
    int unit, bcm_port_t port, int *port_index);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_trunk_index_get,
static int (*_port_trunk_index_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *port_index) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_trunk_index_get(
    int unit, 
    bcm_port_t port, 
    int *port_index)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_trunk_index_get_dispatch[dtype](unit, port, port_index);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_trunk_index_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_trunk_index_set( \
    int unit, bcm_port_t port, int port_index);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_trunk_index_set,
static int (*_port_trunk_index_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int port_index) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_trunk_index_set(
    int unit, 
    bcm_port_t port, 
    int port_index)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_trunk_index_set_dispatch[dtype](unit, port, port_index);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_trunk_index_set", 3, 3, unit, port, port_index, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_untagged_priority_get( \
    int unit, bcm_port_t port, int *priority);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_untagged_priority_get,
static int (*_port_untagged_priority_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *priority) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_untagged_priority_get(
    int unit, 
    bcm_port_t port, 
    int *priority)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_untagged_priority_get_dispatch[dtype](unit, port, priority);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_untagged_priority_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_untagged_priority_set( \
    int unit, bcm_port_t port, int priority);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_untagged_priority_set,
static int (*_port_untagged_priority_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int priority) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_untagged_priority_set(
    int unit, 
    bcm_port_t port, 
    int priority)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_untagged_priority_set_dispatch[dtype](unit, port, priority);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_untagged_priority_set", 3, 3, unit, port, priority, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_untagged_vlan_get( \
    int unit, bcm_port_t port, bcm_vlan_t *vid_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_untagged_vlan_get,
static int (*_port_untagged_vlan_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t *vid_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_untagged_vlan_get(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t *vid_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_untagged_vlan_get_dispatch[dtype](unit, port, vid_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_untagged_vlan_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_untagged_vlan_set( \
    int unit, bcm_port_t port, bcm_vlan_t vid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_untagged_vlan_set,
static int (*_port_untagged_vlan_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_untagged_vlan_set(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_untagged_vlan_set_dispatch[dtype](unit, port, vid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_untagged_vlan_set", 3, 3, unit, port, vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_update( \
    int unit, bcm_port_t port, int link);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_update,
static int (*_port_update_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int link) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_update(
    int unit, 
    bcm_port_t port, 
    int link)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_update_dispatch[dtype](unit, port, link);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_update", 3, 3, unit, port, link, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_dscp_map_get( \
    int unit, bcm_port_t port, bcm_vlan_t vlan, int dscp, int *internal_pri, bcm_color_t *color);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_dscp_map_get,
static int (*_port_vlan_dscp_map_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    int dscp, 
    int *internal_pri, 
    bcm_color_t *color) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_dscp_map_get(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    int dscp, 
    int *internal_pri, 
    bcm_color_t *color)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_dscp_map_get_dispatch[dtype](unit, port, vlan, dscp, internal_pri, color);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_dscp_map_get", 6, 3, unit, port, vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_dscp_map_set( \
    int unit, bcm_port_t port, bcm_vlan_t vlan, int dscp, int internal_pri, bcm_color_t color);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_dscp_map_set,
static int (*_port_vlan_dscp_map_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    int dscp, 
    int internal_pri, 
    bcm_color_t color) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_dscp_map_set(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    int dscp, 
    int internal_pri, 
    bcm_color_t color)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_dscp_map_set_dispatch[dtype](unit, port, vlan, dscp, internal_pri, color);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_dscp_map_set", 6, 3, unit, port, vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_inner_tag_get( \
    int unit, bcm_port_t port, uint16 *inner_tag);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_inner_tag_get,
static int (*_port_vlan_inner_tag_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint16 *inner_tag) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_inner_tag_get(
    int unit, 
    bcm_port_t port, 
    uint16 *inner_tag)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_inner_tag_get_dispatch[dtype](unit, port, inner_tag);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_inner_tag_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_inner_tag_set( \
    int unit, bcm_port_t port, uint16 inner_tag);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_inner_tag_set,
static int (*_port_vlan_inner_tag_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint16 inner_tag) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_inner_tag_set(
    int unit, 
    bcm_port_t port, 
    uint16 inner_tag)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_inner_tag_set_dispatch[dtype](unit, port, inner_tag);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_inner_tag_set", 3, 3, unit, port, inner_tag, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_member_get( \
    int unit, bcm_port_t port, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_member_get,
static int (*_port_vlan_member_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_member_get(
    int unit, 
    bcm_port_t port, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_member_get_dispatch[dtype](unit, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_member_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_member_set( \
    int unit, bcm_port_t port, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_member_set,
static int (*_port_vlan_member_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_member_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_member_set_dispatch[dtype](unit, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_member_set", 3, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_pri_map_get( \
    int unit, bcm_port_t port, bcm_vlan_t vlan, int pkt_pri, int cfi, int *internal_pri, bcm_color_t *color);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_pri_map_get,
static int (*_port_vlan_pri_map_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    int pkt_pri, 
    int cfi, 
    int *internal_pri, 
    bcm_color_t *color) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_pri_map_get(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    int pkt_pri, 
    int cfi, 
    int *internal_pri, 
    bcm_color_t *color)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_pri_map_get_dispatch[dtype](unit, port, vlan, pkt_pri, cfi, internal_pri, color);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_pri_map_get", 7, 3, unit, port, vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_pri_map_set( \
    int unit, bcm_port_t port, bcm_vlan_t vlan, int pkt_pri, int cfi, int internal_pri, bcm_color_t color);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_pri_map_set,
static int (*_port_vlan_pri_map_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    int pkt_pri, 
    int cfi, 
    int internal_pri, 
    bcm_color_t color) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_pri_map_set(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    int pkt_pri, 
    int cfi, 
    int internal_pri, 
    bcm_color_t color)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_pri_map_set_dispatch[dtype](unit, port, vlan, pkt_pri, cfi, internal_pri, color);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_pri_map_set", 7, 3, unit, port, vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_priority_map_get( \
    int unit, bcm_port_t port, int pkt_pri, int cfi, int *internal_pri, bcm_color_t *color);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_priority_map_get,
static int (*_port_vlan_priority_map_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int pkt_pri, 
    int cfi, 
    int *internal_pri, 
    bcm_color_t *color) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_priority_map_get(
    int unit, 
    bcm_port_t port, 
    int pkt_pri, 
    int cfi, 
    int *internal_pri, 
    bcm_color_t *color)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_priority_map_get_dispatch[dtype](unit, port, pkt_pri, cfi, internal_pri, color);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_priority_map_get", 6, 3, unit, port, pkt_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_priority_map_set( \
    int unit, bcm_port_t port, int pkt_pri, int cfi, int internal_pri, bcm_color_t color);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_priority_map_set,
static int (*_port_vlan_priority_map_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int pkt_pri, 
    int cfi, 
    int internal_pri, 
    bcm_color_t color) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_priority_map_set(
    int unit, 
    bcm_port_t port, 
    int pkt_pri, 
    int cfi, 
    int internal_pri, 
    bcm_color_t color)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_priority_map_set_dispatch[dtype](unit, port, pkt_pri, cfi, internal_pri, color);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_priority_map_set", 6, 3, unit, port, pkt_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_priority_mapping_get( \
    int unit, bcm_port_t port, bcm_vlan_t vid, int pkt_pri, int cfi, bcm_priority_mapping_t *pri_map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_priority_mapping_get,
static int (*_port_vlan_priority_mapping_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vid, 
    int pkt_pri, 
    int cfi, 
    bcm_priority_mapping_t *pri_map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_priority_mapping_get(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vid, 
    int pkt_pri, 
    int cfi, 
    bcm_priority_mapping_t *pri_map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_priority_mapping_get_dispatch[dtype](unit, port, vid, pkt_pri, cfi, pri_map);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_priority_mapping_get", 6, 3, unit, port, vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_priority_mapping_set( \
    int unit, bcm_port_t port, bcm_vlan_t vid, int pkt_pri, int cfi, bcm_priority_mapping_t *pri_map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_priority_mapping_set,
static int (*_port_vlan_priority_mapping_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vid, 
    int pkt_pri, 
    int cfi, 
    bcm_priority_mapping_t *pri_map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_priority_mapping_set(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vid, 
    int pkt_pri, 
    int cfi, 
    bcm_priority_mapping_t *pri_map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_priority_mapping_set_dispatch[dtype](unit, port, vid, pkt_pri, cfi, pri_map);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_priority_mapping_set", 6, 3, unit, port, vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_priority_unmap_get( \
    int unit, bcm_port_t port, int internal_pri, bcm_color_t color, int *pkt_pri, int *cfi);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_priority_unmap_get,
static int (*_port_vlan_priority_unmap_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int internal_pri, 
    bcm_color_t color, 
    int *pkt_pri, 
    int *cfi) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_priority_unmap_get(
    int unit, 
    bcm_port_t port, 
    int internal_pri, 
    bcm_color_t color, 
    int *pkt_pri, 
    int *cfi)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_priority_unmap_get_dispatch[dtype](unit, port, internal_pri, color, pkt_pri, cfi);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_priority_unmap_get", 6, 3, unit, port, internal_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_priority_unmap_set( \
    int unit, bcm_port_t port, int internal_pri, bcm_color_t color, int pkt_pri, int cfi);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_priority_unmap_set,
static int (*_port_vlan_priority_unmap_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int internal_pri, 
    bcm_color_t color, 
    int pkt_pri, 
    int cfi) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_priority_unmap_set(
    int unit, 
    bcm_port_t port, 
    int internal_pri, 
    bcm_color_t color, 
    int pkt_pri, 
    int cfi)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_priority_unmap_set_dispatch[dtype](unit, port, internal_pri, color, pkt_pri, cfi);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_priority_unmap_set", 6, 3, unit, port, internal_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_vector_get( \
    int unit, bcm_gport_t port_id, bcm_vlan_vector_t vlan_vec);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_vector_get,
static int (*_port_vlan_vector_get_dispatch[])(
    int unit, 
    bcm_gport_t port_id, 
    bcm_vlan_vector_t vlan_vec) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_vector_get(
    int unit, 
    bcm_gport_t port_id, 
    bcm_vlan_vector_t vlan_vec)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_vector_get_dispatch[dtype](unit, port_id, vlan_vec);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_vector_get", 3, 2, unit, port_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_port_vlan_vector_set( \
    int unit, bcm_gport_t port_id, bcm_vlan_vector_t vlan_vec);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_port_vlan_vector_set,
static int (*_port_vlan_vector_set_dispatch[])(
    int unit, 
    bcm_gport_t port_id, 
    bcm_vlan_vector_t vlan_vec) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_port_vlan_vector_set(
    int unit, 
    bcm_gport_t port_id, 
    bcm_vlan_vector_t vlan_vec)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _port_vlan_vector_set_dispatch[dtype](unit, port_id, vlan_vec);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_port_vlan_vector_set", 3, 2, unit, port_id, 0, r_rv);
	return r_rv;
}

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_proxy_cleanup( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_proxy_cleanup,
static int (*_proxy_cleanup_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_proxy_cleanup(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _proxy_cleanup_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_proxy_cleanup", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_proxy_client_set( \
    int unit, bcm_port_t client_port, bcm_proxy_proto_type_t proto_type, bcm_module_t server_modid, bcm_port_t server_port, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_proxy_client_set,
static int (*_proxy_client_set_dispatch[])(
    int unit, 
    bcm_port_t client_port, 
    bcm_proxy_proto_type_t proto_type, 
    bcm_module_t server_modid, 
    bcm_port_t server_port, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_proxy_client_set(
    int unit, 
    bcm_port_t client_port, 
    bcm_proxy_proto_type_t proto_type, 
    bcm_module_t server_modid, 
    bcm_port_t server_port, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&client_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _proxy_client_set_dispatch[dtype](unit, client_port, proto_type, server_modid, server_port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_proxy_client_set", 6, 3, unit, client_port, proto_type, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_proxy_egress_create( \
    int unit, uint32 flags, bcm_proxy_egress_t *proxy_egress, bcm_if_t *proxy_if_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_proxy_egress_create,
static int (*_proxy_egress_create_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_proxy_egress_t *proxy_egress, 
    bcm_if_t *proxy_if_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_proxy_egress_create(
    int unit, 
    uint32 flags, 
    bcm_proxy_egress_t *proxy_egress, 
    bcm_if_t *proxy_if_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(proxy_egress) BCM_API_XLATE_PORT_A2P(unit,&proxy_egress->gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _proxy_egress_create_dispatch[dtype](unit, flags, proxy_egress, proxy_if_id);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(proxy_egress) BCM_API_XLATE_PORT_P2A(unit,&proxy_egress->gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_proxy_egress_create", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_proxy_egress_destroy( \
    int unit, bcm_if_t proxy_if_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_proxy_egress_destroy,
static int (*_proxy_egress_destroy_dispatch[])(
    int unit, 
    bcm_if_t proxy_if_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_proxy_egress_destroy(
    int unit, 
    bcm_if_t proxy_if_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _proxy_egress_destroy_dispatch[dtype](unit, proxy_if_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_proxy_egress_destroy", 2, 2, unit, proxy_if_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_proxy_egress_get( \
    int unit, bcm_if_t proxy_if_id, bcm_proxy_egress_t *proxy_egress);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_proxy_egress_get,
static int (*_proxy_egress_get_dispatch[])(
    int unit, 
    bcm_if_t proxy_if_id, 
    bcm_proxy_egress_t *proxy_egress) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_proxy_egress_get(
    int unit, 
    bcm_if_t proxy_if_id, 
    bcm_proxy_egress_t *proxy_egress)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _proxy_egress_get_dispatch[dtype](unit, proxy_if_id, proxy_egress);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(proxy_egress) BCM_API_XLATE_PORT_P2A(unit,&proxy_egress->gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_proxy_egress_get", 3, 2, unit, proxy_if_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_proxy_egress_traverse( \
    int unit, bcm_proxy_egress_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_proxy_egress_traverse,
static int (*_proxy_egress_traverse_dispatch[])(
    int unit, 
    bcm_proxy_egress_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_proxy_egress_traverse(
    int unit, 
    bcm_proxy_egress_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _proxy_egress_traverse_dispatch[dtype](unit, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_proxy_egress_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_proxy_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_proxy_init,
static int (*_proxy_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_proxy_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _proxy_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_proxy_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_proxy_server_get( \
    int unit, bcm_port_t server_port, bcm_proxy_mode_t mode, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_proxy_server_get,
static int (*_proxy_server_get_dispatch[])(
    int unit, 
    bcm_port_t server_port, 
    bcm_proxy_mode_t mode, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_proxy_server_get(
    int unit, 
    bcm_port_t server_port, 
    bcm_proxy_mode_t mode, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&server_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _proxy_server_get_dispatch[dtype](unit, server_port, mode, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_proxy_server_get", 4, 3, unit, server_port, mode, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_proxy_server_port_get( \
    int unit, bcm_gport_t local_ingress_port, bcm_proxy_server_t *proxy_server, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_proxy_server_port_get,
static int (*_proxy_server_port_get_dispatch[])(
    int unit, 
    bcm_gport_t local_ingress_port, 
    bcm_proxy_server_t *proxy_server, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_proxy_server_port_get(
    int unit, 
    bcm_gport_t local_ingress_port, 
    bcm_proxy_server_t *proxy_server, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&local_ingress_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _proxy_server_port_get_dispatch[dtype](unit, local_ingress_port, proxy_server, enable);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(proxy_server) BCM_API_XLATE_PORT_P2A(unit,&proxy_server->server_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_proxy_server_port_get", 4, 2, unit, local_ingress_port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_proxy_server_port_set( \
    int unit, bcm_gport_t local_ingress_port, bcm_proxy_server_t *proxy_server, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_proxy_server_port_set,
static int (*_proxy_server_port_set_dispatch[])(
    int unit, 
    bcm_gport_t local_ingress_port, 
    bcm_proxy_server_t *proxy_server, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_proxy_server_port_set(
    int unit, 
    bcm_gport_t local_ingress_port, 
    bcm_proxy_server_t *proxy_server, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(proxy_server_server_gport);
		BCM_API_XLATE_PORT_A2P(unit,&local_ingress_port);
		BCM_API_XLATE_PORT_COND(proxy_server) BCM_API_XLATE_PORT_SAVE(proxy_server_server_gport,proxy_server->server_gport);
		BCM_API_XLATE_PORT_COND(proxy_server) BCM_API_XLATE_PORT_A2P(unit,&proxy_server->server_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _proxy_server_port_set_dispatch[dtype](unit, local_ingress_port, proxy_server, enable);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(proxy_server) BCM_API_XLATE_PORT_RESTORE(proxy_server->server_gport,proxy_server_server_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_proxy_server_port_set", 4, 2, unit, local_ingress_port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_proxy_server_set( \
    int unit, bcm_port_t server_port, bcm_proxy_mode_t mode, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_proxy_server_set,
static int (*_proxy_server_set_dispatch[])(
    int unit, 
    bcm_port_t server_port, 
    bcm_proxy_mode_t mode, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_proxy_server_set(
    int unit, 
    bcm_port_t server_port, 
    bcm_proxy_mode_t mode, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&server_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _proxy_server_set_dispatch[dtype](unit, server_port, mode, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_proxy_server_set", 4, 3, unit, server_port, mode, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_acceptable_master_add( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, int priority1_alt_value, bcm_ptp_clock_peer_address_t *master_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_acceptable_master_add,
static int (*_ptp_acceptable_master_add_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int priority1_alt_value, 
    bcm_ptp_clock_peer_address_t *master_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_acceptable_master_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int priority1_alt_value, 
    bcm_ptp_clock_peer_address_t *master_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_acceptable_master_add_dispatch[dtype](unit, ptp_id, clock_num, port_num, priority1_alt_value, master_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_acceptable_master_add", 6, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_acceptable_master_enabled_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, uint8 *enabled);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_acceptable_master_enabled_get,
static int (*_ptp_acceptable_master_enabled_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint8 *enabled) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_acceptable_master_enabled_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint8 *enabled)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_acceptable_master_enabled_get_dispatch[dtype](unit, ptp_id, clock_num, port_num, enabled);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_acceptable_master_enabled_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_acceptable_master_enabled_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, uint8 enabled);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_acceptable_master_enabled_set,
static int (*_ptp_acceptable_master_enabled_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint8 enabled) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_acceptable_master_enabled_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint8 enabled)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_acceptable_master_enabled_set_dispatch[dtype](unit, ptp_id, clock_num, port_num, enabled);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_acceptable_master_enabled_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_acceptable_master_list( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, int max_num_masters, int *num_masters, bcm_ptp_clock_peer_address_t *master_addr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_acceptable_master_list,
static int (*_ptp_acceptable_master_list_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_masters, 
    int *num_masters, 
    bcm_ptp_clock_peer_address_t *master_addr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_acceptable_master_list(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_masters, 
    int *num_masters, 
    bcm_ptp_clock_peer_address_t *master_addr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_acceptable_master_list_dispatch[dtype](unit, ptp_id, clock_num, port_num, max_num_masters, num_masters, master_addr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_acceptable_master_list", 7, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_acceptable_master_remove( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, bcm_ptp_clock_peer_address_t *master_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_acceptable_master_remove,
static int (*_ptp_acceptable_master_remove_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_address_t *master_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_acceptable_master_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_address_t *master_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_acceptable_master_remove_dispatch[dtype](unit, ptp_id, clock_num, port_num, master_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_acceptable_master_remove", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_acceptable_master_table_clear( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_acceptable_master_table_clear,
static int (*_ptp_acceptable_master_table_clear_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_acceptable_master_table_clear(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_acceptable_master_table_clear_dispatch[dtype](unit, ptp_id, clock_num, port_num);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_acceptable_master_table_clear", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_acceptable_master_table_size_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, int *max_table_entries);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_acceptable_master_table_size_get,
static int (*_ptp_acceptable_master_table_size_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int *max_table_entries) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_acceptable_master_table_size_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int *max_table_entries)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_acceptable_master_table_size_get_dispatch[dtype](unit, ptp_id, clock_num, port_num, max_table_entries);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_acceptable_master_table_size_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_cb_register( \
    int unit, bcm_ptp_cb_types_t cb_types, bcm_ptp_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_cb_register,
static int (*_ptp_cb_register_dispatch[])(
    int unit, 
    bcm_ptp_cb_types_t cb_types, 
    bcm_ptp_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_cb_register(
    int unit, 
    bcm_ptp_cb_types_t cb_types, 
    bcm_ptp_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_cb_register_dispatch[dtype](unit, cb_types, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_cb_register", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_cb_unregister( \
    int unit, bcm_ptp_cb_types_t cb_types, bcm_ptp_cb cb);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_cb_unregister,
static int (*_ptp_cb_unregister_dispatch[])(
    int unit, 
    bcm_ptp_cb_types_t cb_types, 
    bcm_ptp_cb cb) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_cb_unregister(
    int unit, 
    bcm_ptp_cb_types_t cb_types, 
    bcm_ptp_cb cb)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_cb_unregister_dispatch[dtype](unit, cb_types, cb);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_cb_unregister", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_accuracy_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_clock_accuracy_t *accuracy);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_accuracy_get,
static int (*_ptp_clock_accuracy_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_accuracy_t *accuracy) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_accuracy_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_accuracy_t *accuracy)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_accuracy_get_dispatch[dtype](unit, ptp_id, clock_num, accuracy);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_accuracy_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_accuracy_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_clock_accuracy_t *accuracy);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_accuracy_set,
static int (*_ptp_clock_accuracy_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_accuracy_t *accuracy) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_accuracy_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_accuracy_t *accuracy)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_accuracy_set_dispatch[dtype](unit, ptp_id, clock_num, accuracy);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_accuracy_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_create( \
    int unit, bcm_ptp_stack_id_t ptp_id, bcm_ptp_clock_info_t *clock_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_create,
static int (*_ptp_clock_create_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    bcm_ptp_clock_info_t *clock_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_create(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    bcm_ptp_clock_info_t *clock_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_create_dispatch[dtype](unit, ptp_id, clock_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_create", 3, 2, unit, ptp_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_current_dataset_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_current_dataset_t *dataset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_current_dataset_get,
static int (*_ptp_clock_current_dataset_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_current_dataset_t *dataset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_current_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_current_dataset_t *dataset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_current_dataset_get_dispatch[dtype](unit, ptp_id, clock_num, dataset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_current_dataset_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_default_dataset_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_default_dataset_t *dataset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_default_dataset_get,
static int (*_ptp_clock_default_dataset_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_default_dataset_t *dataset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_default_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_default_dataset_t *dataset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_default_dataset_get_dispatch[dtype](unit, ptp_id, clock_num, dataset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_default_dataset_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_domain_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 *domain);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_domain_get,
static int (*_ptp_clock_domain_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *domain) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_domain_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *domain)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_domain_get_dispatch[dtype](unit, ptp_id, clock_num, domain);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_domain_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_domain_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 domain);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_domain_set,
static int (*_ptp_clock_domain_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 domain) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_domain_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 domain)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_domain_set_dispatch[dtype](unit, ptp_id, clock_num, domain);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_domain_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_clock_info_t *clock_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_get,
static int (*_ptp_clock_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_info_t *clock_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_info_t *clock_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_get_dispatch[dtype](unit, ptp_id, clock_num, clock_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_parent_dataset_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_parent_dataset_t *dataset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_parent_dataset_get,
static int (*_ptp_clock_parent_dataset_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_parent_dataset_t *dataset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_parent_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_parent_dataset_t *dataset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_parent_dataset_get_dispatch[dtype](unit, ptp_id, clock_num, dataset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_parent_dataset_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_announce_receipt_timeout_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, uint32 *timeout);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_announce_receipt_timeout_get,
static int (*_ptp_clock_port_announce_receipt_timeout_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 *timeout) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_announce_receipt_timeout_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 *timeout)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_announce_receipt_timeout_get_dispatch[dtype](unit, ptp_id, clock_num, clock_port, timeout);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_announce_receipt_timeout_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_announce_receipt_timeout_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, uint32 timeout);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_announce_receipt_timeout_set,
static int (*_ptp_clock_port_announce_receipt_timeout_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 timeout) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_announce_receipt_timeout_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 timeout)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_announce_receipt_timeout_set_dispatch[dtype](unit, ptp_id, clock_num, clock_port, timeout);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_announce_receipt_timeout_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_configure( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, bcm_ptp_clock_port_info_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_configure,
static int (*_ptp_clock_port_configure_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_clock_port_info_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_configure(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_clock_port_info_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_configure_dispatch[dtype](unit, ptp_id, clock_num, clock_port, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_configure", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_dataset_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, bcm_ptp_port_dataset_t *dataset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_dataset_get,
static int (*_ptp_clock_port_dataset_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_port_dataset_t *dataset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_port_dataset_t *dataset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_dataset_get_dispatch[dtype](unit, ptp_id, clock_num, clock_port, dataset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_dataset_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_delay_mechanism_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, uint32 *delay_mechanism);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_delay_mechanism_get,
static int (*_ptp_clock_port_delay_mechanism_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 *delay_mechanism) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_delay_mechanism_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 *delay_mechanism)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_delay_mechanism_get_dispatch[dtype](unit, ptp_id, clock_num, clock_port, delay_mechanism);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_delay_mechanism_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_delay_mechanism_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, uint32 delay_mechanism);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_delay_mechanism_set,
static int (*_ptp_clock_port_delay_mechanism_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 delay_mechanism) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_delay_mechanism_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 delay_mechanism)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_delay_mechanism_set_dispatch[dtype](unit, ptp_id, clock_num, clock_port, delay_mechanism);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_delay_mechanism_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_disable( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_disable,
static int (*_ptp_clock_port_disable_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_disable(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_disable_dispatch[dtype](unit, ptp_id, clock_num, clock_port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_disable", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_enable( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_enable,
static int (*_ptp_clock_port_enable_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_enable(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_enable_dispatch[dtype](unit, ptp_id, clock_num, clock_port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_enable", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_identity_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, bcm_ptp_port_identity_t *identity);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_identity_get,
static int (*_ptp_clock_port_identity_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_port_identity_t *identity) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_identity_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_port_identity_t *identity)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_identity_get_dispatch[dtype](unit, ptp_id, clock_num, clock_port, identity);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_identity_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_info_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, bcm_ptp_clock_port_info_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_info_get,
static int (*_ptp_clock_port_info_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_clock_port_info_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_info_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_clock_port_info_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_info_get_dispatch[dtype](unit, ptp_id, clock_num, clock_port, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_info_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_latency_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, uint32 latency_in, uint32 latency_out);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_latency_set,
static int (*_ptp_clock_port_latency_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 latency_in, 
    uint32 latency_out) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_latency_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 latency_in, 
    uint32 latency_out)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_latency_set_dispatch[dtype](unit, ptp_id, clock_num, clock_port, latency_in, latency_out);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_latency_set", 6, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_log_announce_interval_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, int *interval);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_log_announce_interval_get,
static int (*_ptp_clock_port_log_announce_interval_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_log_announce_interval_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_log_announce_interval_get_dispatch[dtype](unit, ptp_id, clock_num, clock_port, interval);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_log_announce_interval_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_log_announce_interval_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, int interval);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_log_announce_interval_set,
static int (*_ptp_clock_port_log_announce_interval_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_log_announce_interval_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_log_announce_interval_set_dispatch[dtype](unit, ptp_id, clock_num, clock_port, interval);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_log_announce_interval_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_log_min_delay_req_interval_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, int *interval);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_log_min_delay_req_interval_get,
static int (*_ptp_clock_port_log_min_delay_req_interval_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_log_min_delay_req_interval_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_log_min_delay_req_interval_get_dispatch[dtype](unit, ptp_id, clock_num, clock_port, interval);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_log_min_delay_req_interval_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_log_min_delay_req_interval_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, int interval);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_log_min_delay_req_interval_set,
static int (*_ptp_clock_port_log_min_delay_req_interval_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_log_min_delay_req_interval_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_log_min_delay_req_interval_set_dispatch[dtype](unit, ptp_id, clock_num, clock_port, interval);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_log_min_delay_req_interval_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_log_min_pdelay_req_interval_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, int *interval);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_log_min_pdelay_req_interval_get,
static int (*_ptp_clock_port_log_min_pdelay_req_interval_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_log_min_pdelay_req_interval_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_log_min_pdelay_req_interval_get_dispatch[dtype](unit, ptp_id, clock_num, clock_port, interval);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_log_min_pdelay_req_interval_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_log_min_pdelay_req_interval_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, int interval);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_log_min_pdelay_req_interval_set,
static int (*_ptp_clock_port_log_min_pdelay_req_interval_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_log_min_pdelay_req_interval_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_log_min_pdelay_req_interval_set_dispatch[dtype](unit, ptp_id, clock_num, clock_port, interval);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_log_min_pdelay_req_interval_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_log_sync_interval_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, int *interval);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_log_sync_interval_get,
static int (*_ptp_clock_port_log_sync_interval_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_log_sync_interval_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_log_sync_interval_get_dispatch[dtype](unit, ptp_id, clock_num, clock_port, interval);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_log_sync_interval_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_log_sync_interval_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, int interval);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_log_sync_interval_set,
static int (*_ptp_clock_port_log_sync_interval_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_log_sync_interval_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_log_sync_interval_set_dispatch[dtype](unit, ptp_id, clock_num, clock_port, interval);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_log_sync_interval_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_mac_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, bcm_mac_t *mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_mac_get,
static int (*_ptp_clock_port_mac_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_mac_t *mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_mac_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_mac_t *mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_mac_get_dispatch[dtype](unit, ptp_id, clock_num, clock_port, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_mac_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_protocol_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, bcm_ptp_protocol_t *protocol);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_protocol_get,
static int (*_ptp_clock_port_protocol_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_protocol_t *protocol) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_protocol_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_protocol_t *protocol)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_protocol_get_dispatch[dtype](unit, ptp_id, clock_num, clock_port, protocol);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_protocol_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_type_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, bcm_ptp_port_type_t *type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_type_get,
static int (*_ptp_clock_port_type_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_port_type_t *type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_type_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_port_type_t *type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_type_get_dispatch[dtype](unit, ptp_id, clock_num, clock_port, type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_type_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_port_version_number_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 clock_port, uint32 *version);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_port_version_number_get,
static int (*_ptp_clock_port_version_number_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 *version) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_port_version_number_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 *version)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_port_version_number_get_dispatch[dtype](unit, ptp_id, clock_num, clock_port, version);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_port_version_number_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_priority1_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 *priority1);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_priority1_get,
static int (*_ptp_clock_priority1_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *priority1) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_priority1_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *priority1)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_priority1_get_dispatch[dtype](unit, ptp_id, clock_num, priority1);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_priority1_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_priority1_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 priority1);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_priority1_set,
static int (*_ptp_clock_priority1_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 priority1) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_priority1_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 priority1)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_priority1_set_dispatch[dtype](unit, ptp_id, clock_num, priority1);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_priority1_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_priority2_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 *priority2);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_priority2_get,
static int (*_ptp_clock_priority2_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *priority2) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_priority2_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *priority2)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_priority2_get_dispatch[dtype](unit, ptp_id, clock_num, priority2);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_priority2_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_priority2_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 priority2);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_priority2_set,
static int (*_ptp_clock_priority2_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 priority2) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_priority2_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 priority2)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_priority2_set_dispatch[dtype](unit, ptp_id, clock_num, priority2);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_priority2_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_slaveonly_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 *slaveonly);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_slaveonly_get,
static int (*_ptp_clock_slaveonly_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *slaveonly) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_slaveonly_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *slaveonly)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_slaveonly_get_dispatch[dtype](unit, ptp_id, clock_num, slaveonly);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_slaveonly_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_slaveonly_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint32 slaveonly);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_slaveonly_set,
static int (*_ptp_clock_slaveonly_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 slaveonly) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_slaveonly_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 slaveonly)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_slaveonly_set_dispatch[dtype](unit, ptp_id, clock_num, slaveonly);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_slaveonly_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_time_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_timestamp_t *time);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_time_get,
static int (*_ptp_clock_time_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timestamp_t *time) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_time_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timestamp_t *time)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_time_get_dispatch[dtype](unit, ptp_id, clock_num, time);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_time_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_time_properties_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_time_properties_t *data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_time_properties_get,
static int (*_ptp_clock_time_properties_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_time_properties_t *data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_time_properties_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_time_properties_t *data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_time_properties_get_dispatch[dtype](unit, ptp_id, clock_num, data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_time_properties_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_time_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_timestamp_t *time);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_time_set,
static int (*_ptp_clock_time_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timestamp_t *time) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_time_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timestamp_t *time)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_time_set_dispatch[dtype](unit, ptp_id, clock_num, time);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_time_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_timescale_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_timescale_t *timescale);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_timescale_get,
static int (*_ptp_clock_timescale_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timescale_t *timescale) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_timescale_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timescale_t *timescale)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_timescale_get_dispatch[dtype](unit, ptp_id, clock_num, timescale);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_timescale_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_timescale_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_timescale_t *timescale);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_timescale_set,
static int (*_ptp_clock_timescale_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timescale_t *timescale) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_timescale_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timescale_t *timescale)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_timescale_set_dispatch[dtype](unit, ptp_id, clock_num, timescale);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_timescale_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_traceability_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_trace_t *trace);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_traceability_get,
static int (*_ptp_clock_traceability_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_trace_t *trace) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_traceability_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_trace_t *trace)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_traceability_get_dispatch[dtype](unit, ptp_id, clock_num, trace);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_traceability_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_traceability_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_trace_t *trace);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_traceability_set,
static int (*_ptp_clock_traceability_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_trace_t *trace) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_traceability_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_trace_t *trace)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_traceability_set_dispatch[dtype](unit, ptp_id, clock_num, trace);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_traceability_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_user_description_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint8 *desc);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_user_description_set,
static int (*_ptp_clock_user_description_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 *desc) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_user_description_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 *desc)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_user_description_set_dispatch[dtype](unit, ptp_id, clock_num, desc);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_user_description_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_utc_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_utc_t *utc);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_utc_get,
static int (*_ptp_clock_utc_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_utc_t *utc) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_utc_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_utc_t *utc)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_utc_get_dispatch[dtype](unit, ptp_id, clock_num, utc);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_utc_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_clock_utc_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_utc_t *utc);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_clock_utc_set,
static int (*_ptp_clock_utc_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_utc_t *utc) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_clock_utc_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_utc_t *utc)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_clock_utc_set_dispatch[dtype](unit, ptp_id, clock_num, utc);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_clock_utc_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_ctdev_alarm_callback_register( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_ctdev_alarm_cb alarm_cb);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_ctdev_alarm_callback_register,
static int (*_ptp_ctdev_alarm_callback_register_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_ctdev_alarm_cb alarm_cb) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_ctdev_alarm_callback_register(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_ctdev_alarm_cb alarm_cb)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_ctdev_alarm_callback_register_dispatch[dtype](unit, ptp_id, clock_num, alarm_cb);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_ctdev_alarm_callback_register", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_ctdev_alarm_callback_unregister( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_ctdev_alarm_callback_unregister,
static int (*_ptp_ctdev_alarm_callback_unregister_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_ctdev_alarm_callback_unregister(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_ctdev_alarm_callback_unregister_dispatch[dtype](unit, ptp_id, clock_num);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_ctdev_alarm_callback_unregister", 3, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_ctdev_alpha_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint16 *alpha_numerator, uint16 *alpha_denominator);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_ctdev_alpha_get,
static int (*_ptp_ctdev_alpha_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 *alpha_numerator, 
    uint16 *alpha_denominator) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_ctdev_alpha_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 *alpha_numerator, 
    uint16 *alpha_denominator)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_ctdev_alpha_get_dispatch[dtype](unit, ptp_id, clock_num, alpha_numerator, alpha_denominator);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_ctdev_alpha_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_ctdev_alpha_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint16 alpha_numerator, uint16 alpha_denominator);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_ctdev_alpha_set,
static int (*_ptp_ctdev_alpha_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 alpha_numerator, 
    uint16 alpha_denominator) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_ctdev_alpha_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 alpha_numerator, 
    uint16 alpha_denominator)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_ctdev_alpha_set_dispatch[dtype](unit, ptp_id, clock_num, alpha_numerator, alpha_denominator);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_ctdev_alpha_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_ctdev_enable_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int *enable, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_ctdev_enable_get,
static int (*_ptp_ctdev_enable_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *enable, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_ctdev_enable_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *enable, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_ctdev_enable_get_dispatch[dtype](unit, ptp_id, clock_num, enable, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_ctdev_enable_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_ctdev_enable_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int enable, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_ctdev_enable_set,
static int (*_ptp_ctdev_enable_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int enable, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_ctdev_enable_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int enable, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_ctdev_enable_set_dispatch[dtype](unit, ptp_id, clock_num, enable, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_ctdev_enable_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_ctdev_verbose_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int *verbose);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_ctdev_verbose_get,
static int (*_ptp_ctdev_verbose_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *verbose) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_ctdev_verbose_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *verbose)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_ctdev_verbose_get_dispatch[dtype](unit, ptp_id, clock_num, verbose);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_ctdev_verbose_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_ctdev_verbose_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int verbose);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_ctdev_verbose_set,
static int (*_ptp_ctdev_verbose_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int verbose) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_ctdev_verbose_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int verbose)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_ctdev_verbose_set_dispatch[dtype](unit, ptp_id, clock_num, verbose);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_ctdev_verbose_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_detach,
static int (*_ptp_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_foreign_master_dataset_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, bcm_ptp_foreign_master_dataset_t *data_set);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_foreign_master_dataset_get,
static int (*_ptp_foreign_master_dataset_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_foreign_master_dataset_t *data_set) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_foreign_master_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_foreign_master_dataset_t *data_set)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_foreign_master_dataset_get_dispatch[dtype](unit, ptp_id, clock_num, port_num, data_set);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_foreign_master_dataset_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_init,
static int (*_ptp_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_input_channel_precedence_mode_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int channel_select_mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_input_channel_precedence_mode_set,
static int (*_ptp_input_channel_precedence_mode_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int channel_select_mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_input_channel_precedence_mode_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int channel_select_mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_input_channel_precedence_mode_set_dispatch[dtype](unit, ptp_id, clock_num, channel_select_mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_input_channel_precedence_mode_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_input_channel_switching_mode_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int channel_switching_mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_input_channel_switching_mode_set,
static int (*_ptp_input_channel_switching_mode_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int channel_switching_mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_input_channel_switching_mode_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int channel_switching_mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_input_channel_switching_mode_set_dispatch[dtype](unit, ptp_id, clock_num, channel_switching_mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_input_channel_switching_mode_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_input_channels_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int *num_channels, bcm_ptp_channel_t *channels);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_input_channels_get,
static int (*_ptp_input_channels_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *num_channels, 
    bcm_ptp_channel_t *channels) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_input_channels_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *num_channels, 
    bcm_ptp_channel_t *channels)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_input_channels_get_dispatch[dtype](unit, ptp_id, clock_num, num_channels, channels);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_input_channels_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_input_channels_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int num_channels, bcm_ptp_channel_t *channels);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_input_channels_set,
static int (*_ptp_input_channels_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int num_channels, 
    bcm_ptp_channel_t *channels) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_input_channels_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int num_channels, 
    bcm_ptp_channel_t *channels)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_input_channels_set_dispatch[dtype](unit, ptp_id, clock_num, num_channels, channels);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_input_channels_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_modular_enable_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int *enable, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_modular_enable_get,
static int (*_ptp_modular_enable_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *enable, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_modular_enable_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *enable, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_modular_enable_get_dispatch[dtype](unit, ptp_id, clock_num, enable, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_modular_enable_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_modular_enable_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int enable, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_modular_enable_set,
static int (*_ptp_modular_enable_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int enable, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_modular_enable_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int enable, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_modular_enable_set_dispatch[dtype](unit, ptp_id, clock_num, enable, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_modular_enable_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_modular_phyts_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int *phyts, int *framesync_pin);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_modular_phyts_get,
static int (*_ptp_modular_phyts_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *phyts, 
    int *framesync_pin) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_modular_phyts_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *phyts, 
    int *framesync_pin)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_modular_phyts_get_dispatch[dtype](unit, ptp_id, clock_num, phyts, framesync_pin);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_modular_phyts_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_modular_phyts_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int phyts, int framesync_pin);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_modular_phyts_set,
static int (*_ptp_modular_phyts_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int phyts, 
    int framesync_pin) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_modular_phyts_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int phyts, 
    int framesync_pin)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_modular_phyts_set_dispatch[dtype](unit, ptp_id, clock_num, phyts, framesync_pin);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_modular_phyts_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_modular_portbitmap_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_pbmp_t *pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_modular_portbitmap_get,
static int (*_ptp_modular_portbitmap_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_pbmp_t *pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_modular_portbitmap_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_pbmp_t *pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_modular_portbitmap_get_dispatch[dtype](unit, ptp_id, clock_num, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_modular_portbitmap_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_modular_portbitmap_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_modular_portbitmap_set,
static int (*_ptp_modular_portbitmap_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_modular_portbitmap_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_modular_portbitmap_set_dispatch[dtype](unit, ptp_id, clock_num, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_modular_portbitmap_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_modular_verbose_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int *verbose);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_modular_verbose_get,
static int (*_ptp_modular_verbose_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *verbose) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_modular_verbose_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *verbose)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_modular_verbose_get_dispatch[dtype](unit, ptp_id, clock_num, verbose);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_modular_verbose_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_modular_verbose_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int verbose);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_modular_verbose_set,
static int (*_ptp_modular_verbose_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int verbose) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_modular_verbose_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int verbose)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_modular_verbose_set_dispatch[dtype](unit, ptp_id, clock_num, verbose);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_modular_verbose_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_packet_counters_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_packet_counters_t *counters);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_packet_counters_get,
static int (*_ptp_packet_counters_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_packet_counters_t *counters) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_packet_counters_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_packet_counters_t *counters)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_packet_counters_get_dispatch[dtype](unit, ptp_id, clock_num, counters);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_packet_counters_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_peer_dataset_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, int max_num_peers, bcm_ptp_peer_entry_t *peers, int *num_peers);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_peer_dataset_get,
static int (*_ptp_peer_dataset_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_peers, 
    bcm_ptp_peer_entry_t *peers, 
    int *num_peers) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_peer_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_peers, 
    bcm_ptp_peer_entry_t *peers, 
    int *num_peers)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_peer_dataset_get_dispatch[dtype](unit, ptp_id, clock_num, port_num, max_num_peers, peers, num_peers);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_peer_dataset_get", 7, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_primary_domain_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int *primary_domain);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_primary_domain_get,
static int (*_ptp_primary_domain_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *primary_domain) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_primary_domain_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *primary_domain)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_primary_domain_get_dispatch[dtype](unit, ptp_id, clock_num, primary_domain);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_primary_domain_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_primary_domain_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int primary_domain);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_primary_domain_set,
static int (*_ptp_primary_domain_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int primary_domain) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_primary_domain_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int primary_domain)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_primary_domain_set_dispatch[dtype](unit, ptp_id, clock_num, primary_domain);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_primary_domain_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_servo_configuration_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_servo_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_servo_configuration_get,
static int (*_ptp_servo_configuration_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_servo_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_servo_configuration_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_servo_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_servo_configuration_get_dispatch[dtype](unit, ptp_id, clock_num, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_servo_configuration_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_servo_configuration_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_servo_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_servo_configuration_set,
static int (*_ptp_servo_configuration_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_servo_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_servo_configuration_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_servo_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_servo_configuration_set_dispatch[dtype](unit, ptp_id, clock_num, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_servo_configuration_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_servo_status_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_servo_status_t *status);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_servo_status_get,
static int (*_ptp_servo_status_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_servo_status_t *status) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_servo_status_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_servo_status_t *status)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_servo_status_get_dispatch[dtype](unit, ptp_id, clock_num, status);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_servo_status_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_signal_output_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int *signal_output_count, bcm_ptp_signal_output_t *signal_output_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_signal_output_get,
static int (*_ptp_signal_output_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *signal_output_count, 
    bcm_ptp_signal_output_t *signal_output_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_signal_output_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *signal_output_count, 
    bcm_ptp_signal_output_t *signal_output_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_signal_output_get_dispatch[dtype](unit, ptp_id, clock_num, signal_output_count, signal_output_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_signal_output_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_signal_output_remove( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int signal_output_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_signal_output_remove,
static int (*_ptp_signal_output_remove_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int signal_output_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_signal_output_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int signal_output_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_signal_output_remove_dispatch[dtype](unit, ptp_id, clock_num, signal_output_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_signal_output_remove", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_signal_output_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int *signal_output_id, bcm_ptp_signal_output_t *output_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_signal_output_set,
static int (*_ptp_signal_output_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *signal_output_id, 
    bcm_ptp_signal_output_t *output_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_signal_output_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *signal_output_id, 
    bcm_ptp_signal_output_t *output_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_signal_output_set_dispatch[dtype](unit, ptp_id, clock_num, signal_output_id, output_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_signal_output_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_signaled_unicast_master_add( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, bcm_ptp_clock_unicast_master_t *master_info, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_signaled_unicast_master_add,
static int (*_ptp_signaled_unicast_master_add_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_unicast_master_t *master_info, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_signaled_unicast_master_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_unicast_master_t *master_info, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_signaled_unicast_master_add_dispatch[dtype](unit, ptp_id, clock_num, port_num, master_info, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_signaled_unicast_master_add", 6, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_signaled_unicast_master_remove( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, bcm_ptp_clock_peer_address_t *master_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_signaled_unicast_master_remove,
static int (*_ptp_signaled_unicast_master_remove_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_address_t *master_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_signaled_unicast_master_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_address_t *master_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_signaled_unicast_master_remove_dispatch[dtype](unit, ptp_id, clock_num, port_num, master_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_signaled_unicast_master_remove", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_signaled_unicast_slave_list( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, int max_num_slaves, int *num_slaves, bcm_ptp_clock_peer_t *slave_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_signaled_unicast_slave_list,
static int (*_ptp_signaled_unicast_slave_list_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_slaves, 
    int *num_slaves, 
    bcm_ptp_clock_peer_t *slave_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_signaled_unicast_slave_list(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_slaves, 
    int *num_slaves, 
    bcm_ptp_clock_peer_t *slave_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_signaled_unicast_slave_list_dispatch[dtype](unit, ptp_id, clock_num, port_num, max_num_slaves, num_slaves, slave_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_signaled_unicast_slave_list", 7, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_signaled_unicast_slave_table_clear( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, int callstack);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_signaled_unicast_slave_table_clear,
static int (*_ptp_signaled_unicast_slave_table_clear_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int callstack) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_signaled_unicast_slave_table_clear(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int callstack)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_signaled_unicast_slave_table_clear_dispatch[dtype](unit, ptp_id, clock_num, port_num, callstack);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_signaled_unicast_slave_table_clear", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_stack_create( \
    int unit, bcm_ptp_stack_info_t *ptp_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_stack_create,
static int (*_ptp_stack_create_dispatch[])(
    int unit, 
    bcm_ptp_stack_info_t *ptp_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_stack_create(
    int unit, 
    bcm_ptp_stack_info_t *ptp_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_stack_create_dispatch[dtype](unit, ptp_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_stack_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_static_unicast_master_add( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, bcm_ptp_clock_unicast_master_t *master_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_static_unicast_master_add,
static int (*_ptp_static_unicast_master_add_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_unicast_master_t *master_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_static_unicast_master_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_unicast_master_t *master_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_static_unicast_master_add_dispatch[dtype](unit, ptp_id, clock_num, port_num, master_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_static_unicast_master_add", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_static_unicast_master_list( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, int max_num_masters, int *num_masters, bcm_ptp_clock_peer_address_t *master_addr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_static_unicast_master_list,
static int (*_ptp_static_unicast_master_list_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_masters, 
    int *num_masters, 
    bcm_ptp_clock_peer_address_t *master_addr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_static_unicast_master_list(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_masters, 
    int *num_masters, 
    bcm_ptp_clock_peer_address_t *master_addr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_static_unicast_master_list_dispatch[dtype](unit, ptp_id, clock_num, port_num, max_num_masters, num_masters, master_addr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_static_unicast_master_list", 7, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_static_unicast_master_remove( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, bcm_ptp_clock_peer_address_t *master_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_static_unicast_master_remove,
static int (*_ptp_static_unicast_master_remove_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_address_t *master_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_static_unicast_master_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_address_t *master_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_static_unicast_master_remove_dispatch[dtype](unit, ptp_id, clock_num, port_num, master_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_static_unicast_master_remove", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_static_unicast_master_table_clear( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_static_unicast_master_table_clear,
static int (*_ptp_static_unicast_master_table_clear_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_static_unicast_master_table_clear(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_static_unicast_master_table_clear_dispatch[dtype](unit, ptp_id, clock_num, port_num);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_static_unicast_master_table_clear", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_static_unicast_master_table_size_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, int *max_table_entries);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_static_unicast_master_table_size_get,
static int (*_ptp_static_unicast_master_table_size_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int *max_table_entries) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_static_unicast_master_table_size_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int *max_table_entries)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_static_unicast_master_table_size_get_dispatch[dtype](unit, ptp_id, clock_num, port_num, max_table_entries);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_static_unicast_master_table_size_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_static_unicast_slave_add( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, bcm_ptp_clock_peer_t *slave_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_static_unicast_slave_add,
static int (*_ptp_static_unicast_slave_add_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_t *slave_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_static_unicast_slave_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_t *slave_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_static_unicast_slave_add_dispatch[dtype](unit, ptp_id, clock_num, port_num, slave_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_static_unicast_slave_add", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_static_unicast_slave_list( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, int max_num_slaves, int *num_slaves, bcm_ptp_clock_peer_t *slave_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_static_unicast_slave_list,
static int (*_ptp_static_unicast_slave_list_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_slaves, 
    int *num_slaves, 
    bcm_ptp_clock_peer_t *slave_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_static_unicast_slave_list(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_slaves, 
    int *num_slaves, 
    bcm_ptp_clock_peer_t *slave_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_static_unicast_slave_list_dispatch[dtype](unit, ptp_id, clock_num, port_num, max_num_slaves, num_slaves, slave_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_static_unicast_slave_list", 7, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_static_unicast_slave_remove( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, bcm_ptp_clock_peer_t *slave_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_static_unicast_slave_remove,
static int (*_ptp_static_unicast_slave_remove_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_t *slave_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_static_unicast_slave_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_t *slave_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_static_unicast_slave_remove_dispatch[dtype](unit, ptp_id, clock_num, port_num, slave_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_static_unicast_slave_remove", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_static_unicast_slave_table_clear( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_static_unicast_slave_table_clear,
static int (*_ptp_static_unicast_slave_table_clear_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_static_unicast_slave_table_clear(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_static_unicast_slave_table_clear_dispatch[dtype](unit, ptp_id, clock_num, port_num);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_static_unicast_slave_table_clear", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_sync_phy( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_sync_phy_input_t sync_input);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_sync_phy,
static int (*_ptp_sync_phy_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_sync_phy_input_t sync_input) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_sync_phy(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_sync_phy_input_t sync_input)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_sync_phy_dispatch[dtype](unit, ptp_id, clock_num, sync_input);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_sync_phy", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_init( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_init,
static int (*_ptp_telecom_g8265_init_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_init(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_init_dispatch[dtype](unit, ptp_id, clock_num);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_init", 3, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_network_option_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_telecom_g8265_network_option_t *network_option);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_network_option_get,
static int (*_ptp_telecom_g8265_network_option_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_network_option_t *network_option) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_network_option_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_network_option_t *network_option)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_network_option_get_dispatch[dtype](unit, ptp_id, clock_num, network_option);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_network_option_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_network_option_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_telecom_g8265_network_option_t network_option);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_network_option_set,
static int (*_ptp_telecom_g8265_network_option_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_network_option_t network_option) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_network_option_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_network_option_t network_option)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_network_option_set_dispatch[dtype](unit, ptp_id, clock_num, network_option);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_network_option_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_packet_master_add( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, bcm_ptp_clock_port_address_t *address);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_packet_master_add,
static int (*_ptp_telecom_g8265_packet_master_add_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_port_address_t *address) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_packet_master_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_port_address_t *address)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_packet_master_add_dispatch[dtype](unit, ptp_id, clock_num, port_num, address);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_packet_master_add", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_packet_master_best_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_telecom_g8265_pktmaster_t *pktmaster);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_packet_master_best_get,
static int (*_ptp_telecom_g8265_packet_master_best_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_pktmaster_t *pktmaster) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_packet_master_best_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_pktmaster_t *pktmaster)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_packet_master_best_get_dispatch[dtype](unit, ptp_id, clock_num, pktmaster);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_packet_master_best_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_packet_master_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_clock_port_address_t *address, bcm_ptp_telecom_g8265_pktmaster_t *pktmaster);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_packet_master_get,
static int (*_ptp_telecom_g8265_packet_master_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_port_address_t *address, 
    bcm_ptp_telecom_g8265_pktmaster_t *pktmaster) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_packet_master_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_port_address_t *address, 
    bcm_ptp_telecom_g8265_pktmaster_t *pktmaster)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_packet_master_get_dispatch[dtype](unit, ptp_id, clock_num, address, pktmaster);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_packet_master_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_packet_master_list( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int max_master_count, int *num_masters, int *best_master, bcm_ptp_telecom_g8265_pktmaster_t *pktmaster);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_packet_master_list,
static int (*_ptp_telecom_g8265_packet_master_list_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int max_master_count, 
    int *num_masters, 
    int *best_master, 
    bcm_ptp_telecom_g8265_pktmaster_t *pktmaster) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_packet_master_list(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int max_master_count, 
    int *num_masters, 
    int *best_master, 
    bcm_ptp_telecom_g8265_pktmaster_t *pktmaster)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_packet_master_list_dispatch[dtype](unit, ptp_id, clock_num, max_master_count, num_masters, best_master, pktmaster);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_packet_master_list", 7, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_packet_master_lockout_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint8 lockout, bcm_ptp_clock_port_address_t *address);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_packet_master_lockout_set,
static int (*_ptp_telecom_g8265_packet_master_lockout_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 lockout, 
    bcm_ptp_clock_port_address_t *address) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_packet_master_lockout_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 lockout, 
    bcm_ptp_clock_port_address_t *address)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_packet_master_lockout_set_dispatch[dtype](unit, ptp_id, clock_num, lockout, address);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_packet_master_lockout_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_packet_master_non_reversion_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint8 nonres, bcm_ptp_clock_port_address_t *address);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_packet_master_non_reversion_set,
static int (*_ptp_telecom_g8265_packet_master_non_reversion_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 nonres, 
    bcm_ptp_clock_port_address_t *address) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_packet_master_non_reversion_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 nonres, 
    bcm_ptp_clock_port_address_t *address)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_packet_master_non_reversion_set_dispatch[dtype](unit, ptp_id, clock_num, nonres, address);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_packet_master_non_reversion_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_packet_master_priority_override( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint8 override, bcm_ptp_clock_port_address_t *address);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_packet_master_priority_override,
static int (*_ptp_telecom_g8265_packet_master_priority_override_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 override, 
    bcm_ptp_clock_port_address_t *address) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_packet_master_priority_override(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 override, 
    bcm_ptp_clock_port_address_t *address)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_packet_master_priority_override_dispatch[dtype](unit, ptp_id, clock_num, override, address);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_packet_master_priority_override", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_packet_master_priority_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint16 priority, bcm_ptp_clock_port_address_t *address);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_packet_master_priority_set,
static int (*_ptp_telecom_g8265_packet_master_priority_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 priority, 
    bcm_ptp_clock_port_address_t *address) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_packet_master_priority_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 priority, 
    bcm_ptp_clock_port_address_t *address)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_packet_master_priority_set_dispatch[dtype](unit, ptp_id, clock_num, priority, address);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_packet_master_priority_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_packet_master_remove( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, bcm_ptp_clock_port_address_t *address);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_packet_master_remove,
static int (*_ptp_telecom_g8265_packet_master_remove_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_port_address_t *address) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_packet_master_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_port_address_t *address)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_packet_master_remove_dispatch[dtype](unit, ptp_id, clock_num, port_num, address);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_packet_master_remove", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_packet_master_wait_duration_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint64 wait_sec, bcm_ptp_clock_port_address_t *address);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_packet_master_wait_duration_set,
static int (*_ptp_telecom_g8265_packet_master_wait_duration_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint64 wait_sec, 
    bcm_ptp_clock_port_address_t *address) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_packet_master_wait_duration_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint64 wait_sec, 
    bcm_ptp_clock_port_address_t *address)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_packet_master_wait_duration_set_dispatch[dtype](unit, ptp_id, clock_num, wait_sec, address);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_packet_master_wait_duration_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_pktstats_thresholds_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_telecom_g8265_pktstats_t *thresholds);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_pktstats_thresholds_get,
static int (*_ptp_telecom_g8265_pktstats_thresholds_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_pktstats_t *thresholds) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_pktstats_thresholds_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_pktstats_t *thresholds)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_pktstats_thresholds_get_dispatch[dtype](unit, ptp_id, clock_num, thresholds);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_pktstats_thresholds_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_pktstats_thresholds_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_telecom_g8265_pktstats_t thresholds);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_pktstats_thresholds_set,
static int (*_ptp_telecom_g8265_pktstats_thresholds_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_pktstats_t thresholds) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_pktstats_thresholds_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_pktstats_t thresholds)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_pktstats_thresholds_set_dispatch[dtype](unit, ptp_id, clock_num, thresholds);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_pktstats_thresholds_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_quality_level_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_telecom_g8265_quality_level_t ql);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_quality_level_set,
static int (*_ptp_telecom_g8265_quality_level_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_quality_level_t ql) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_quality_level_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_quality_level_t ql)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_quality_level_set_dispatch[dtype](unit, ptp_id, clock_num, ql);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_quality_level_set", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_receipt_timeout_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_message_type_t message_type, uint32 *receipt_timeout);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_receipt_timeout_get,
static int (*_ptp_telecom_g8265_receipt_timeout_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_message_type_t message_type, 
    uint32 *receipt_timeout) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_receipt_timeout_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_message_type_t message_type, 
    uint32 *receipt_timeout)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_receipt_timeout_get_dispatch[dtype](unit, ptp_id, clock_num, message_type, receipt_timeout);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_receipt_timeout_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_receipt_timeout_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_message_type_t message_type, uint32 receipt_timeout);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_receipt_timeout_set,
static int (*_ptp_telecom_g8265_receipt_timeout_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_message_type_t message_type, 
    uint32 receipt_timeout) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_receipt_timeout_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_message_type_t message_type, 
    uint32 receipt_timeout)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_receipt_timeout_set_dispatch[dtype](unit, ptp_id, clock_num, message_type, receipt_timeout);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_receipt_timeout_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_telecom_g8265_shutdown( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_telecom_g8265_shutdown,
static int (*_ptp_telecom_g8265_shutdown_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_telecom_g8265_shutdown(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_telecom_g8265_shutdown_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_telecom_g8265_shutdown", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_time_format_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, bcm_ptp_time_type_t type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_time_format_set,
static int (*_ptp_time_format_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    bcm_ptp_time_type_t type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_time_format_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    bcm_ptp_time_type_t type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_time_format_set_dispatch[dtype](unit, ptp_id, type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_time_format_set", 3, 3, unit, ptp_id, type, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_timesource_input_status_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_timesource_status_t *status);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_timesource_input_status_get,
static int (*_ptp_timesource_input_status_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timesource_status_t *status) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_timesource_input_status_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timesource_status_t *status)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_timesource_input_status_get_dispatch[dtype](unit, ptp_id, clock_num, status);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_timesource_input_status_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_tod_input_sources_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int *num_tod_sources, bcm_ptp_tod_input_t *tod_sources);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_tod_input_sources_get,
static int (*_ptp_tod_input_sources_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *num_tod_sources, 
    bcm_ptp_tod_input_t *tod_sources) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_tod_input_sources_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *num_tod_sources, 
    bcm_ptp_tod_input_t *tod_sources)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_tod_input_sources_get_dispatch[dtype](unit, ptp_id, clock_num, num_tod_sources, tod_sources);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_tod_input_sources_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_tod_input_sources_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int num_tod_sources, bcm_ptp_tod_input_t *tod_sources);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_tod_input_sources_set,
static int (*_ptp_tod_input_sources_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int num_tod_sources, 
    bcm_ptp_tod_input_t *tod_sources) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_tod_input_sources_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int num_tod_sources, 
    bcm_ptp_tod_input_t *tod_sources)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_tod_input_sources_set_dispatch[dtype](unit, ptp_id, clock_num, num_tod_sources, tod_sources);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_tod_input_sources_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_tod_output_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int *tod_output_count, bcm_ptp_tod_output_t *tod_output);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_tod_output_get,
static int (*_ptp_tod_output_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *tod_output_count, 
    bcm_ptp_tod_output_t *tod_output) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_tod_output_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *tod_output_count, 
    bcm_ptp_tod_output_t *tod_output)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_tod_output_get_dispatch[dtype](unit, ptp_id, clock_num, tod_output_count, tod_output);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_tod_output_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_tod_output_remove( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int tod_output_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_tod_output_remove,
static int (*_ptp_tod_output_remove_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int tod_output_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_tod_output_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int tod_output_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_tod_output_remove_dispatch[dtype](unit, ptp_id, clock_num, tod_output_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_tod_output_remove", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_tod_output_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int *tod_output_id, bcm_ptp_tod_output_t *output_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_tod_output_set,
static int (*_ptp_tod_output_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *tod_output_id, 
    bcm_ptp_tod_output_t *output_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_tod_output_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *tod_output_id, 
    bcm_ptp_tod_output_t *output_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_tod_output_set_dispatch[dtype](unit, ptp_id, clock_num, tod_output_id, output_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_tod_output_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_transparent_clock_default_dataset_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, bcm_ptp_transparent_clock_default_dataset_t *data_set);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_transparent_clock_default_dataset_get,
static int (*_ptp_transparent_clock_default_dataset_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_transparent_clock_default_dataset_t *data_set) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_transparent_clock_default_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_transparent_clock_default_dataset_t *data_set)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_transparent_clock_default_dataset_get_dispatch[dtype](unit, ptp_id, clock_num, data_set);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_transparent_clock_default_dataset_get", 4, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_transparent_clock_port_dataset_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, uint16 clock_port, bcm_ptp_transparent_clock_port_dataset_t *data_set);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_transparent_clock_port_dataset_get,
static int (*_ptp_transparent_clock_port_dataset_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 clock_port, 
    bcm_ptp_transparent_clock_port_dataset_t *data_set) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_transparent_clock_port_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 clock_port, 
    bcm_ptp_transparent_clock_port_dataset_t *data_set)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_transparent_clock_port_dataset_get_dispatch[dtype](unit, ptp_id, clock_num, clock_port, data_set);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_transparent_clock_port_dataset_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_unicast_request_duration_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, uint32 *duration);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_unicast_request_duration_get,
static int (*_ptp_unicast_request_duration_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint32 *duration) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_unicast_request_duration_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint32 *duration)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_unicast_request_duration_get_dispatch[dtype](unit, ptp_id, clock_num, port_num, duration);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_unicast_request_duration_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_unicast_request_duration_max_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, uint32 *duration_max);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_unicast_request_duration_max_get,
static int (*_ptp_unicast_request_duration_max_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint32 *duration_max) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_unicast_request_duration_max_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint32 *duration_max)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_unicast_request_duration_max_get_dispatch[dtype](unit, ptp_id, clock_num, port_num, duration_max);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_unicast_request_duration_max_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_unicast_request_duration_max_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, uint32 duration_max);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_unicast_request_duration_max_set,
static int (*_ptp_unicast_request_duration_max_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint32 duration_max) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_unicast_request_duration_max_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint32 duration_max)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_unicast_request_duration_max_set_dispatch[dtype](unit, ptp_id, clock_num, port_num, duration_max);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_unicast_request_duration_max_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_unicast_request_duration_min_get( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, uint32 *duration_min);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_unicast_request_duration_min_get,
static int (*_ptp_unicast_request_duration_min_get_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint32 *duration_min) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_unicast_request_duration_min_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint32 *duration_min)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_unicast_request_duration_min_get_dispatch[dtype](unit, ptp_id, clock_num, port_num, duration_min);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_unicast_request_duration_min_get", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_unicast_request_duration_min_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, uint32 duration_min);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_unicast_request_duration_min_set,
static int (*_ptp_unicast_request_duration_min_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint32 duration_min) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_unicast_request_duration_min_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint32 duration_min)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_unicast_request_duration_min_set_dispatch[dtype](unit, ptp_id, clock_num, port_num, duration_min);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_unicast_request_duration_min_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_ptp_unicast_request_duration_set( \
    int unit, bcm_ptp_stack_id_t ptp_id, int clock_num, int port_num, uint32 duration);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_ptp_unicast_request_duration_set,
static int (*_ptp_unicast_request_duration_set_dispatch[])(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint32 duration) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_ptp_unicast_request_duration_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint32 duration)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _ptp_unicast_request_duration_set_dispatch[dtype](unit, ptp_id, clock_num, port_num, duration);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_ptp_unicast_request_duration_set", 5, 3, unit, ptp_id, clock_num, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_qos_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_qos_detach,
static int (*_qos_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_qos_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _qos_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_qos_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_qos_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_qos_init,
static int (*_qos_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_qos_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _qos_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_qos_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_qos_map_add( \
    int unit, uint32 flags, bcm_qos_map_t *map, int map_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_qos_map_add,
static int (*_qos_map_add_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_qos_map_t *map, 
    int map_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_qos_map_add(
    int unit, 
    uint32 flags, 
    bcm_qos_map_t *map, 
    int map_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _qos_map_add_dispatch[dtype](unit, flags, map, map_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_qos_map_add", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_qos_map_create( \
    int unit, uint32 flags, int *map_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_qos_map_create,
static int (*_qos_map_create_dispatch[])(
    int unit, 
    uint32 flags, 
    int *map_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_qos_map_create(
    int unit, 
    uint32 flags, 
    int *map_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _qos_map_create_dispatch[dtype](unit, flags, map_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_qos_map_create", 3, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_qos_map_delete( \
    int unit, uint32 flags, bcm_qos_map_t *map, int map_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_qos_map_delete,
static int (*_qos_map_delete_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_qos_map_t *map, 
    int map_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_qos_map_delete(
    int unit, 
    uint32 flags, 
    bcm_qos_map_t *map, 
    int map_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _qos_map_delete_dispatch[dtype](unit, flags, map, map_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_qos_map_delete", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_qos_map_destroy( \
    int unit, int map_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_qos_map_destroy,
static int (*_qos_map_destroy_dispatch[])(
    int unit, 
    int map_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_qos_map_destroy(
    int unit, 
    int map_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _qos_map_destroy_dispatch[dtype](unit, map_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_qos_map_destroy", 2, 2, unit, map_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_qos_map_multi_get( \
    int unit, uint32 flags, int map_id, int array_size, bcm_qos_map_t *array, int *array_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_qos_map_multi_get,
static int (*_qos_map_multi_get_dispatch[])(
    int unit, 
    uint32 flags, 
    int map_id, 
    int array_size, 
    bcm_qos_map_t *array, 
    int *array_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_qos_map_multi_get(
    int unit, 
    uint32 flags, 
    int map_id, 
    int array_size, 
    bcm_qos_map_t *array, 
    int *array_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _qos_map_multi_get_dispatch[dtype](unit, flags, map_id, array_size, array, array_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_qos_map_multi_get", 6, 3, unit, flags, map_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_qos_multi_get( \
    int unit, int array_size, int *map_ids_array, int *flags_array, int *array_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_qos_multi_get,
static int (*_qos_multi_get_dispatch[])(
    int unit, 
    int array_size, 
    int *map_ids_array, 
    int *flags_array, 
    int *array_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_qos_multi_get(
    int unit, 
    int array_size, 
    int *map_ids_array, 
    int *flags_array, 
    int *array_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _qos_multi_get_dispatch[dtype](unit, array_size, map_ids_array, flags_array, array_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_qos_multi_get", 5, 2, unit, array_size, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_qos_port_map_get( \
    int unit, bcm_gport_t port, int *ing_map, int *egr_map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_qos_port_map_get,
static int (*_qos_port_map_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int *ing_map, 
    int *egr_map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_qos_port_map_get(
    int unit, 
    bcm_gport_t port, 
    int *ing_map, 
    int *egr_map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _qos_port_map_get_dispatch[dtype](unit, port, ing_map, egr_map);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_qos_port_map_get", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_qos_port_map_set( \
    int unit, bcm_gport_t port, int ing_map, int egr_map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_qos_port_map_set,
static int (*_qos_port_map_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int ing_map, 
    int egr_map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_qos_port_map_set(
    int unit, 
    bcm_gport_t port, 
    int ing_map, 
    int egr_map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _qos_port_map_set_dispatch[dtype](unit, port, ing_map, egr_map);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_qos_port_map_set", 4, 3, unit, port, ing_map, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_qos_port_map_type_get( \
    int unit, bcm_gport_t port, uint32 flags, int *map_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_qos_port_map_type_get,
static int (*_qos_port_map_type_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    int *map_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_qos_port_map_type_get(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    int *map_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _qos_port_map_type_get_dispatch[dtype](unit, port, flags, map_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_qos_port_map_type_get", 4, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_qos_port_vlan_map_get( \
    int unit, bcm_port_t port, bcm_vlan_t vid, int *ing_map, int *egr_map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_qos_port_vlan_map_get,
static int (*_qos_port_vlan_map_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vid, 
    int *ing_map, 
    int *egr_map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_qos_port_vlan_map_get(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vid, 
    int *ing_map, 
    int *egr_map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _qos_port_vlan_map_get_dispatch[dtype](unit, port, vid, ing_map, egr_map);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_qos_port_vlan_map_get", 5, 3, unit, port, vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_qos_port_vlan_map_set( \
    int unit, bcm_port_t port, bcm_vlan_t vid, int ing_map, int egr_map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_qos_port_vlan_map_set,
static int (*_qos_port_vlan_map_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vid, 
    int ing_map, 
    int egr_map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_qos_port_vlan_map_set(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vid, 
    int ing_map, 
    int egr_map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _qos_port_vlan_map_set_dispatch[dtype](unit, port, vid, ing_map, egr_map);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_qos_port_vlan_map_set", 5, 3, unit, port, vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rate_bandwidth_get( \
    int unit, bcm_port_t port, int flags, uint32 *kbits_sec, uint32 *kbits_burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rate_bandwidth_get,
static int (*_rate_bandwidth_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int flags, 
    uint32 *kbits_sec, 
    uint32 *kbits_burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rate_bandwidth_get(
    int unit, 
    bcm_port_t port, 
    int flags, 
    uint32 *kbits_sec, 
    uint32 *kbits_burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _rate_bandwidth_get_dispatch[dtype](unit, port, flags, kbits_sec, kbits_burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rate_bandwidth_get", 5, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rate_bandwidth_set( \
    int unit, bcm_port_t port, int flags, uint32 kbits_sec, uint32 kbits_burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rate_bandwidth_set,
static int (*_rate_bandwidth_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int flags, 
    uint32 kbits_sec, 
    uint32 kbits_burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rate_bandwidth_set(
    int unit, 
    bcm_port_t port, 
    int flags, 
    uint32 kbits_sec, 
    uint32 kbits_burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _rate_bandwidth_set_dispatch[dtype](unit, port, flags, kbits_sec, kbits_burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rate_bandwidth_set", 5, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rate_bcast_get( \
    int unit, int *pps, int *flags, int port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rate_bcast_get,
static int (*_rate_bcast_get_dispatch[])(
    int unit, 
    int *pps, 
    int *flags, 
    int port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rate_bcast_get(
    int unit, 
    int *pps, 
    int *flags, 
    int port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _rate_bcast_get_dispatch[dtype](unit, pps, flags, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rate_bcast_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rate_bcast_set( \
    int unit, int pps, int flags, int port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rate_bcast_set,
static int (*_rate_bcast_set_dispatch[])(
    int unit, 
    int pps, 
    int flags, 
    int port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rate_bcast_set(
    int unit, 
    int pps, 
    int flags, 
    int port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _rate_bcast_set_dispatch[dtype](unit, pps, flags, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rate_bcast_set", 4, 3, unit, pps, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rate_dlfbc_get( \
    int unit, int *pps, int *flags, int port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rate_dlfbc_get,
static int (*_rate_dlfbc_get_dispatch[])(
    int unit, 
    int *pps, 
    int *flags, 
    int port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rate_dlfbc_get(
    int unit, 
    int *pps, 
    int *flags, 
    int port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _rate_dlfbc_get_dispatch[dtype](unit, pps, flags, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rate_dlfbc_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rate_dlfbc_set( \
    int unit, int pps, int flags, int port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rate_dlfbc_set,
static int (*_rate_dlfbc_set_dispatch[])(
    int unit, 
    int pps, 
    int flags, 
    int port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rate_dlfbc_set(
    int unit, 
    int pps, 
    int flags, 
    int port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _rate_dlfbc_set_dispatch[dtype](unit, pps, flags, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rate_dlfbc_set", 4, 3, unit, pps, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rate_get( \
    int unit, int *pps, int *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rate_get,
static int (*_rate_get_dispatch[])(
    int unit, 
    int *pps, 
    int *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rate_get(
    int unit, 
    int *pps, 
    int *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rate_get_dispatch[dtype](unit, pps, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rate_get", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rate_mcast_get( \
    int unit, int *pps, int *flags, int port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rate_mcast_get,
static int (*_rate_mcast_get_dispatch[])(
    int unit, 
    int *pps, 
    int *flags, 
    int port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rate_mcast_get(
    int unit, 
    int *pps, 
    int *flags, 
    int port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _rate_mcast_get_dispatch[dtype](unit, pps, flags, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rate_mcast_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rate_mcast_set( \
    int unit, int pps, int flags, int port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rate_mcast_set,
static int (*_rate_mcast_set_dispatch[])(
    int unit, 
    int pps, 
    int flags, 
    int port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rate_mcast_set(
    int unit, 
    int pps, 
    int flags, 
    int port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _rate_mcast_set_dispatch[dtype](unit, pps, flags, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rate_mcast_set", 4, 3, unit, pps, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rate_set( \
    int unit, int pps, int flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rate_set,
static int (*_rate_set_dispatch[])(
    int unit, 
    int pps, 
    int flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rate_set(
    int unit, 
    int pps, 
    int flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rate_set_dispatch[dtype](unit, pps, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rate_set", 3, 3, unit, pps, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rate_type_get( \
    int unit, bcm_rate_limit_t *rl);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rate_type_get,
static int (*_rate_type_get_dispatch[])(
    int unit, 
    bcm_rate_limit_t *rl) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rate_type_get(
    int unit, 
    bcm_rate_limit_t *rl)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rate_type_get_dispatch[dtype](unit, rl);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rate_type_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rate_type_set( \
    int unit, bcm_rate_limit_t *rl);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rate_type_set,
static int (*_rate_type_set_dispatch[])(
    int unit, 
    bcm_rate_limit_t *rl) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rate_type_set(
    int unit, 
    bcm_rate_limit_t *rl)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rate_type_set_dispatch[dtype](unit, rl);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rate_type_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_config_get( \
    int unit, bcm_regex_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_config_get,
static int (*_regex_config_get_dispatch[])(
    int unit, 
    bcm_regex_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_config_get(
    int unit, 
    bcm_regex_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_config_get_dispatch[dtype](unit, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_config_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_config_set( \
    int unit, bcm_regex_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_config_set,
static int (*_regex_config_set_dispatch[])(
    int unit, 
    bcm_regex_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_config_set(
    int unit, 
    bcm_regex_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_config_set_dispatch[dtype](unit, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_config_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_engine_create( \
    int unit, bcm_regex_engine_config_t *config, bcm_regex_engine_t *engid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_engine_create,
static int (*_regex_engine_create_dispatch[])(
    int unit, 
    bcm_regex_engine_config_t *config, 
    bcm_regex_engine_t *engid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_engine_create(
    int unit, 
    bcm_regex_engine_config_t *config, 
    bcm_regex_engine_t *engid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_engine_create_dispatch[dtype](unit, config, engid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_engine_create", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_engine_destroy( \
    int unit, bcm_regex_engine_t engid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_engine_destroy,
static int (*_regex_engine_destroy_dispatch[])(
    int unit, 
    bcm_regex_engine_t engid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_engine_destroy(
    int unit, 
    bcm_regex_engine_t engid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_engine_destroy_dispatch[dtype](unit, engid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_engine_destroy", 2, 2, unit, engid, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_engine_get( \
    int unit, bcm_regex_engine_t engid, bcm_regex_engine_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_engine_get,
static int (*_regex_engine_get_dispatch[])(
    int unit, 
    bcm_regex_engine_t engid, 
    bcm_regex_engine_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_engine_get(
    int unit, 
    bcm_regex_engine_t engid, 
    bcm_regex_engine_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_engine_get_dispatch[dtype](unit, engid, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_engine_get", 3, 2, unit, engid, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_engine_info_get( \
    int unit, int engine_id, bcm_regex_engine_info_t *regex_engine_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_engine_info_get,
static int (*_regex_engine_info_get_dispatch[])(
    int unit, 
    int engine_id, 
    bcm_regex_engine_info_t *regex_engine_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_engine_info_get(
    int unit, 
    int engine_id, 
    bcm_regex_engine_info_t *regex_engine_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_engine_info_get_dispatch[dtype](unit, engine_id, regex_engine_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_engine_info_get", 3, 2, unit, engine_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_engine_traverse( \
    int unit, bcm_regex_engine_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_engine_traverse,
static int (*_regex_engine_traverse_dispatch[])(
    int unit, 
    bcm_regex_engine_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_engine_traverse(
    int unit, 
    bcm_regex_engine_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_engine_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_engine_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_exclude_add( \
    int unit, uint8 protocol, uint16 l4_start, uint16 l4_end);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_exclude_add,
static int (*_regex_exclude_add_dispatch[])(
    int unit, 
    uint8 protocol, 
    uint16 l4_start, 
    uint16 l4_end) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_exclude_add(
    int unit, 
    uint8 protocol, 
    uint16 l4_start, 
    uint16 l4_end)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_exclude_add_dispatch[dtype](unit, protocol, l4_start, l4_end);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_exclude_add", 4, 3, unit, protocol, l4_start, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_exclude_delete( \
    int unit, uint8 protocol, uint16 l4_start, uint16 l4_end);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_exclude_delete,
static int (*_regex_exclude_delete_dispatch[])(
    int unit, 
    uint8 protocol, 
    uint16 l4_start, 
    uint16 l4_end) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_exclude_delete(
    int unit, 
    uint8 protocol, 
    uint16 l4_start, 
    uint16 l4_end)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_exclude_delete_dispatch[dtype](unit, protocol, l4_start, l4_end);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_exclude_delete", 4, 3, unit, protocol, l4_start, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_exclude_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_exclude_delete_all,
static int (*_regex_exclude_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_exclude_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_exclude_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_exclude_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_exclude_get( \
    int unit, int array_size, uint8 *protocol, uint16 *l4low, uint16 *l4high, int *array_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_exclude_get,
static int (*_regex_exclude_get_dispatch[])(
    int unit, 
    int array_size, 
    uint8 *protocol, 
    uint16 *l4low, 
    uint16 *l4high, 
    int *array_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_exclude_get(
    int unit, 
    int array_size, 
    uint8 *protocol, 
    uint16 *l4low, 
    uint16 *l4high, 
    int *array_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_exclude_get_dispatch[dtype](unit, array_size, protocol, l4low, l4high, array_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_exclude_get", 6, 2, unit, array_size, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_get_match_id( \
    int unit, int signature_id, int *match_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_get_match_id,
static int (*_regex_get_match_id_dispatch[])(
    int unit, 
    int signature_id, 
    int *match_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_get_match_id(
    int unit, 
    int signature_id, 
    int *match_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_get_match_id_dispatch[dtype](unit, signature_id, match_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_get_match_id", 3, 2, unit, signature_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_get_sig_id( \
    int unit, int match_id, int *signature_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_get_sig_id,
static int (*_regex_get_sig_id_dispatch[])(
    int unit, 
    int match_id, 
    int *signature_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_get_sig_id(
    int unit, 
    int match_id, 
    int *signature_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_get_sig_id_dispatch[dtype](unit, match_id, signature_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_get_sig_id", 3, 2, unit, match_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_info_get( \
    int unit, bcm_regex_info_t *regex_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_info_get,
static int (*_regex_info_get_dispatch[])(
    int unit, 
    bcm_regex_info_t *regex_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_info_get(
    int unit, 
    bcm_regex_info_t *regex_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_info_get_dispatch[dtype](unit, regex_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_info_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_init,
static int (*_regex_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_match_check( \
    int unit, bcm_regex_match_t *matches, int count, int *metric);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_match_check,
static int (*_regex_match_check_dispatch[])(
    int unit, 
    bcm_regex_match_t *matches, 
    int count, 
    int *metric) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_match_check(
    int unit, 
    bcm_regex_match_t *matches, 
    int count, 
    int *metric)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_match_check_dispatch[dtype](unit, matches, count, metric);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_match_check", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_match_set( \
    int unit, bcm_regex_engine_t engid, bcm_regex_match_t *matches, int count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_match_set,
static int (*_regex_match_set_dispatch[])(
    int unit, 
    bcm_regex_engine_t engid, 
    bcm_regex_match_t *matches, 
    int count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_match_set(
    int unit, 
    bcm_regex_engine_t engid, 
    bcm_regex_match_t *matches, 
    int count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_match_set_dispatch[dtype](unit, engid, matches, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_match_set", 4, 2, unit, engid, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_action_add( \
    int unit, bcm_regex_policy_t policy, bcm_field_action_t action, uint32 param0, uint32 param1);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_action_add,
static int (*_regex_policy_action_add_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    uint32 param0, 
    uint32 param1) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_action_add(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    uint32 param0, 
    uint32 param1)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_action_add_dispatch[dtype](unit, policy, action, param0, param1);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_action_add", 5, 3, unit, policy, action, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_action_delete( \
    int unit, bcm_regex_policy_t policy, bcm_field_action_t action, uint32 param0, uint32 param1);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_action_delete,
static int (*_regex_policy_action_delete_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    uint32 param0, 
    uint32 param1) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_action_delete(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    uint32 param0, 
    uint32 param1)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_action_delete_dispatch[dtype](unit, policy, action, param0, param1);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_action_delete", 5, 3, unit, policy, action, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_action_get( \
    int unit, bcm_regex_policy_t policy, bcm_field_action_t action, uint32 *param0, uint32 *param1);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_action_get,
static int (*_regex_policy_action_get_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    uint32 *param0, 
    uint32 *param1) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_action_get(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    uint32 *param0, 
    uint32 *param1)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_action_get_dispatch[dtype](unit, policy, action, param0, param1);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_action_get", 5, 3, unit, policy, action, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_action_mac_add( \
    int unit, bcm_regex_policy_t policy, bcm_field_action_t action, bcm_mac_t mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_action_mac_add,
static int (*_regex_policy_action_mac_add_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    bcm_mac_t mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_action_mac_add(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    bcm_mac_t mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_action_mac_add_dispatch[dtype](unit, policy, action, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_action_mac_add", 4, 3, unit, policy, action, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_action_mac_get( \
    int unit, bcm_regex_policy_t policy, bcm_field_action_t action, bcm_mac_t *mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_action_mac_get,
static int (*_regex_policy_action_mac_get_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    bcm_mac_t *mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_action_mac_get(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    bcm_mac_t *mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_action_mac_get_dispatch[dtype](unit, policy, action, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_action_mac_get", 4, 3, unit, policy, action, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_action_ports_add( \
    int unit, bcm_regex_policy_t policy, bcm_field_action_t action, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_action_ports_add,
static int (*_regex_policy_action_ports_add_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_action_ports_add(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_action_ports_add_dispatch[dtype](unit, policy, action, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_action_ports_add", 4, 3, unit, policy, action, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_action_ports_get( \
    int unit, bcm_regex_policy_t policy, bcm_field_action_t action, bcm_pbmp_t *pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_action_ports_get,
static int (*_regex_policy_action_ports_get_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    bcm_pbmp_t *pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_action_ports_get(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    bcm_pbmp_t *pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_action_ports_get_dispatch[dtype](unit, policy, action, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_action_ports_get", 4, 3, unit, policy, action, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_action_remove( \
    int unit, bcm_regex_policy_t policy, bcm_field_action_t action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_action_remove,
static int (*_regex_policy_action_remove_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_action_remove(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_action_remove_dispatch[dtype](unit, policy, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_action_remove", 3, 3, unit, policy, action, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_action_remove_all( \
    int unit, bcm_regex_policy_t policy);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_action_remove_all,
static int (*_regex_policy_action_remove_all_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_action_remove_all(
    int unit, 
    bcm_regex_policy_t policy)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_action_remove_all_dispatch[dtype](unit, policy);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_action_remove_all", 2, 2, unit, policy, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_create( \
    int unit, int flags, bcm_regex_policy_t *policy);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_create,
static int (*_regex_policy_create_dispatch[])(
    int unit, 
    int flags, 
    bcm_regex_policy_t *policy) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_create(
    int unit, 
    int flags, 
    bcm_regex_policy_t *policy)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_create_dispatch[dtype](unit, flags, policy);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_create", 3, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_destroy( \
    int unit, bcm_regex_policy_t policy);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_destroy,
static int (*_regex_policy_destroy_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_destroy(
    int unit, 
    bcm_regex_policy_t policy)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_destroy_dispatch[dtype](unit, policy);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_destroy", 2, 2, unit, policy, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_destroy_all,
static int (*_regex_policy_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_install( \
    int unit, bcm_regex_policy_t policy);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_install,
static int (*_regex_policy_install_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_install(
    int unit, 
    bcm_regex_policy_t policy)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_install_dispatch[dtype](unit, policy);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_install", 2, 2, unit, policy, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_policer_attach( \
    int unit, bcm_regex_policy_t policy, int level, bcm_policer_t policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_policer_attach,
static int (*_regex_policy_policer_attach_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy, 
    int level, 
    bcm_policer_t policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_policer_attach(
    int unit, 
    bcm_regex_policy_t policy, 
    int level, 
    bcm_policer_t policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_policer_attach_dispatch[dtype](unit, policy, level, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_policer_attach", 4, 3, unit, policy, level, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_policer_detach( \
    int unit, bcm_regex_policy_t policy, int level);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_policer_detach,
static int (*_regex_policy_policer_detach_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy, 
    int level) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_policer_detach(
    int unit, 
    bcm_regex_policy_t policy, 
    int level)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_policer_detach_dispatch[dtype](unit, policy, level);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_policer_detach", 3, 3, unit, policy, level, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_policer_detach_all( \
    int unit, bcm_regex_policy_t policy);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_policer_detach_all,
static int (*_regex_policy_policer_detach_all_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_policer_detach_all(
    int unit, 
    bcm_regex_policy_t policy)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_policer_detach_all_dispatch[dtype](unit, policy);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_policer_detach_all", 2, 2, unit, policy, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_policer_get( \
    int unit, bcm_regex_policy_t policy, int level, bcm_policer_t *policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_policer_get,
static int (*_regex_policy_policer_get_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy, 
    int level, 
    bcm_policer_t *policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_policer_get(
    int unit, 
    bcm_regex_policy_t policy, 
    int level, 
    bcm_policer_t *policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_policer_get_dispatch[dtype](unit, policy, level, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_policer_get", 4, 3, unit, policy, level, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_remove( \
    int unit, bcm_regex_policy_t policy);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_remove,
static int (*_regex_policy_remove_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_remove(
    int unit, 
    bcm_regex_policy_t policy)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_remove_dispatch[dtype](unit, policy);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_remove", 2, 2, unit, policy, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_stat_attach( \
    int unit, bcm_regex_policy_t policy, int stat_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_stat_attach,
static int (*_regex_policy_stat_attach_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy, 
    int stat_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_stat_attach(
    int unit, 
    bcm_regex_policy_t policy, 
    int stat_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_stat_attach_dispatch[dtype](unit, policy, stat_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_stat_attach", 3, 3, unit, policy, stat_id, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_stat_detach( \
    int unit, bcm_regex_policy_t policy, int stat_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_stat_detach,
static int (*_regex_policy_stat_detach_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy, 
    int stat_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_stat_detach(
    int unit, 
    bcm_regex_policy_t policy, 
    int stat_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_stat_detach_dispatch[dtype](unit, policy, stat_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_stat_detach", 3, 3, unit, policy, stat_id, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_policy_stat_get( \
    int unit, bcm_regex_policy_t policy, int *stat_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_policy_stat_get,
static int (*_regex_policy_stat_get_dispatch[])(
    int unit, 
    bcm_regex_policy_t policy, 
    int *stat_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_policy_stat_get(
    int unit, 
    bcm_regex_policy_t policy, 
    int *stat_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_policy_stat_get_dispatch[dtype](unit, policy, stat_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_policy_stat_get", 3, 2, unit, policy, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_report_register( \
    int unit, uint32 reports, bcm_regex_report_cb callback, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_report_register,
static int (*_regex_report_register_dispatch[])(
    int unit, 
    uint32 reports, 
    bcm_regex_report_cb callback, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_report_register(
    int unit, 
    uint32 reports, 
    bcm_regex_report_cb callback, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_report_register_dispatch[dtype](unit, reports, callback, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_report_register", 4, 2, unit, reports, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_report_unregister( \
    int unit, uint32 reports, bcm_regex_report_cb callback, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_report_unregister,
static int (*_regex_report_unregister_dispatch[])(
    int unit, 
    uint32 reports, 
    bcm_regex_report_cb callback, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_report_unregister(
    int unit, 
    uint32 reports, 
    bcm_regex_report_cb callback, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_report_unregister_dispatch[dtype](unit, reports, callback, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_report_unregister", 4, 2, unit, reports, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_session_add( \
    int unit, int flags, bcm_regex_session_key_t *key, bcm_regex_session_t *session);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_session_add,
static int (*_regex_session_add_dispatch[])(
    int unit, 
    int flags, 
    bcm_regex_session_key_t *key, 
    bcm_regex_session_t *session) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_session_add(
    int unit, 
    int flags, 
    bcm_regex_session_key_t *key, 
    bcm_regex_session_t *session)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_session_add_dispatch[dtype](unit, flags, key, session);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_session_add", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_session_delete( \
    int unit, bcm_regex_session_key_t *key);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_session_delete,
static int (*_regex_session_delete_dispatch[])(
    int unit, 
    bcm_regex_session_key_t *key) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_session_delete(
    int unit, 
    bcm_regex_session_key_t *key)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_session_delete_dispatch[dtype](unit, key);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_session_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_session_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_session_delete_all,
static int (*_regex_session_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_session_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_session_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_session_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_session_get( \
    int unit, int flags, bcm_regex_session_key_t *key, bcm_regex_session_t *session);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_session_get,
static int (*_regex_session_get_dispatch[])(
    int unit, 
    int flags, 
    bcm_regex_session_key_t *key, 
    bcm_regex_session_t *session) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_session_get(
    int unit, 
    int flags, 
    bcm_regex_session_key_t *key, 
    bcm_regex_session_t *session)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_session_get_dispatch[dtype](unit, flags, key, session);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_session_get", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_session_policy_update( \
    int unit, int flags, int flow_index, bcm_regex_policy_t policy);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_session_policy_update,
static int (*_regex_session_policy_update_dispatch[])(
    int unit, 
    int flags, 
    int flow_index, 
    bcm_regex_policy_t policy) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_session_policy_update(
    int unit, 
    int flags, 
    int flow_index, 
    bcm_regex_policy_t policy)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_session_policy_update_dispatch[dtype](unit, flags, flow_index, policy);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_session_policy_update", 4, 3, unit, flags, flow_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_session_traverse( \
    int unit, int flags, bcm_regex_session_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_session_traverse,
static int (*_regex_session_traverse_dispatch[])(
    int unit, 
    int flags, 
    bcm_regex_session_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_session_traverse(
    int unit, 
    int flags, 
    bcm_regex_session_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_session_traverse_dispatch[dtype](unit, flags, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_session_traverse", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_stat_create( \
    int unit, int flags, int nstat, bcm_field_stat_t *stat_arr, int *stat_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_stat_create,
static int (*_regex_stat_create_dispatch[])(
    int unit, 
    int flags, 
    int nstat, 
    bcm_field_stat_t *stat_arr, 
    int *stat_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_stat_create(
    int unit, 
    int flags, 
    int nstat, 
    bcm_field_stat_t *stat_arr, 
    int *stat_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_stat_create_dispatch[dtype](unit, flags, nstat, stat_arr, stat_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_stat_create", 5, 3, unit, flags, nstat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_stat_destroy( \
    int unit, int stat_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_stat_destroy,
static int (*_regex_stat_destroy_dispatch[])(
    int unit, 
    int stat_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_stat_destroy(
    int unit, 
    int stat_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_stat_destroy_dispatch[dtype](unit, stat_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_stat_destroy", 2, 2, unit, stat_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_stat_get( \
    int unit, bcm_regex_stat_t type, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_stat_get,
static int (*_regex_stat_get_dispatch[])(
    int unit, 
    bcm_regex_stat_t type, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_stat_get(
    int unit, 
    bcm_regex_stat_t type, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_stat_get_dispatch[dtype](unit, type, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_stat_get", 3, 2, unit, type, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_REGEX)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_regex_stat_set( \
    int unit, bcm_regex_stat_t type, uint64 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_regex_stat_set,
static int (*_regex_stat_set_dispatch[])(
    int unit, 
    bcm_regex_stat_t type, 
    uint64 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_regex_stat_set(
    int unit, 
    bcm_regex_stat_t type, 
    uint64 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _regex_stat_set_dispatch[dtype](unit, type, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_regex_stat_set", 3, 2, unit, type, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_active( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_active,
static int (*_rx_active_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_active(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_active_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_active", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_alloc( \
    int unit, int pkt_size, uint32 flags, void **buf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_alloc,
static int (*_rx_alloc_dispatch[])(
    int unit, 
    int pkt_size, 
    uint32 flags, 
    void **buf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_alloc(
    int unit, 
    int pkt_size, 
    uint32 flags, 
    void **buf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_alloc_dispatch[dtype](unit, pkt_size, flags, buf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_alloc", 4, 3, unit, pkt_size, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_burst_get( \
    int unit, int *burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_burst_get,
static int (*_rx_burst_get_dispatch[])(
    int unit, 
    int *burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_burst_get(
    int unit, 
    int *burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_burst_get_dispatch[dtype](unit, burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_burst_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_burst_set( \
    int unit, int burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_burst_set,
static int (*_rx_burst_set_dispatch[])(
    int unit, 
    int burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_burst_set(
    int unit, 
    int burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_burst_set_dispatch[dtype](unit, burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_burst_set", 2, 2, unit, burst, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_cfg_get( \
    int unit, bcm_rx_cfg_t *cfg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_cfg_get,
static int (*_rx_cfg_get_dispatch[])(
    int unit, 
    bcm_rx_cfg_t *cfg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_cfg_get(
    int unit, 
    bcm_rx_cfg_t *cfg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_cfg_get_dispatch[dtype](unit, cfg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_cfg_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_cfg_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_cfg_init,
static int (*_rx_cfg_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_cfg_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_cfg_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_cfg_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_channels_running( \
    int unit, uint32 *channels);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_channels_running,
static int (*_rx_channels_running_dispatch[])(
    int unit, 
    uint32 *channels) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_channels_running(
    int unit, 
    uint32 *channels)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_channels_running_dispatch[dtype](unit, channels);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_channels_running", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_clear( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_clear,
static int (*_rx_clear_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_clear(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_clear_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_clear", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_control_get( \
    int unit, bcm_rx_control_t type, int *arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_control_get,
static int (*_rx_control_get_dispatch[])(
    int unit, 
    bcm_rx_control_t type, 
    int *arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_control_get(
    int unit, 
    bcm_rx_control_t type, 
    int *arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_control_get_dispatch[dtype](unit, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_control_get", 3, 2, unit, type, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_control_set( \
    int unit, bcm_rx_control_t type, int arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_control_set,
static int (*_rx_control_set_dispatch[])(
    int unit, 
    bcm_rx_control_t type, 
    int arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_control_set(
    int unit, 
    bcm_rx_control_t type, 
    int arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_control_set_dispatch[dtype](unit, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_control_set", 3, 3, unit, type, arg, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_cos_burst_get( \
    int unit, int cos, int *burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_cos_burst_get,
static int (*_rx_cos_burst_get_dispatch[])(
    int unit, 
    int cos, 
    int *burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_cos_burst_get(
    int unit, 
    int cos, 
    int *burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_cos_burst_get_dispatch[dtype](unit, cos, burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_cos_burst_get", 3, 2, unit, cos, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_cos_burst_set( \
    int unit, int cos, int burst);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_cos_burst_set,
static int (*_rx_cos_burst_set_dispatch[])(
    int unit, 
    int cos, 
    int burst) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_cos_burst_set(
    int unit, 
    int cos, 
    int burst)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_cos_burst_set_dispatch[dtype](unit, cos, burst);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_cos_burst_set", 3, 3, unit, cos, burst, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_cos_max_len_get( \
    int unit, int cos, int *max_q_len);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_cos_max_len_get,
static int (*_rx_cos_max_len_get_dispatch[])(
    int unit, 
    int cos, 
    int *max_q_len) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_cos_max_len_get(
    int unit, 
    int cos, 
    int *max_q_len)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_cos_max_len_get_dispatch[dtype](unit, cos, max_q_len);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_cos_max_len_get", 3, 2, unit, cos, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_cos_max_len_set( \
    int unit, int cos, int max_q_len);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_cos_max_len_set,
static int (*_rx_cos_max_len_set_dispatch[])(
    int unit, 
    int cos, 
    int max_q_len) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_cos_max_len_set(
    int unit, 
    int cos, 
    int max_q_len)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_cos_max_len_set_dispatch[dtype](unit, cos, max_q_len);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_cos_max_len_set", 3, 3, unit, cos, max_q_len, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_cos_rate_get( \
    int unit, int cos, int *pps);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_cos_rate_get,
static int (*_rx_cos_rate_get_dispatch[])(
    int unit, 
    int cos, 
    int *pps) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_cos_rate_get(
    int unit, 
    int cos, 
    int *pps)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_cos_rate_get_dispatch[dtype](unit, cos, pps);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_cos_rate_get", 3, 2, unit, cos, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_cos_rate_set( \
    int unit, int cos, int pps);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_cos_rate_set,
static int (*_rx_cos_rate_set_dispatch[])(
    int unit, 
    int cos, 
    int pps) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_cos_rate_set(
    int unit, 
    int cos, 
    int pps)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_cos_rate_set_dispatch[dtype](unit, cos, pps);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_cos_rate_set", 3, 3, unit, cos, pps, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_cosq_mapping_delete( \
    int unit, int index);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_cosq_mapping_delete,
static int (*_rx_cosq_mapping_delete_dispatch[])(
    int unit, 
    int index) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_cosq_mapping_delete(
    int unit, 
    int index)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_cosq_mapping_delete_dispatch[dtype](unit, index);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_cosq_mapping_delete", 2, 2, unit, index, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_cosq_mapping_get( \
    int unit, int index, bcm_rx_reasons_t *reasons, bcm_rx_reasons_t *reasons_mask, uint8 *int_prio, uint8 *int_prio_mask, uint32 *packet_type, uint32 *packet_type_mask, bcm_cos_queue_t *cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_cosq_mapping_get,
static int (*_rx_cosq_mapping_get_dispatch[])(
    int unit, 
    int index, 
    bcm_rx_reasons_t *reasons, 
    bcm_rx_reasons_t *reasons_mask, 
    uint8 *int_prio, 
    uint8 *int_prio_mask, 
    uint32 *packet_type, 
    uint32 *packet_type_mask, 
    bcm_cos_queue_t *cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_cosq_mapping_get(
    int unit, 
    int index, 
    bcm_rx_reasons_t *reasons, 
    bcm_rx_reasons_t *reasons_mask, 
    uint8 *int_prio, 
    uint8 *int_prio_mask, 
    uint32 *packet_type, 
    uint32 *packet_type_mask, 
    bcm_cos_queue_t *cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_cosq_mapping_get_dispatch[dtype](unit, index, reasons, reasons_mask, int_prio, int_prio_mask, packet_type, packet_type_mask, cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_cosq_mapping_get", 9, 2, unit, index, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_cosq_mapping_reasons_get( \
    int unit, bcm_rx_reasons_t *reasons);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_cosq_mapping_reasons_get,
static int (*_rx_cosq_mapping_reasons_get_dispatch[])(
    int unit, 
    bcm_rx_reasons_t *reasons) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_cosq_mapping_reasons_get(
    int unit, 
    bcm_rx_reasons_t *reasons)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_cosq_mapping_reasons_get_dispatch[dtype](unit, reasons);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_cosq_mapping_reasons_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_cosq_mapping_set( \
    int unit, int index, bcm_rx_reasons_t reasons, bcm_rx_reasons_t reasons_mask, uint8 int_prio, uint8 int_prio_mask, uint32 packet_type, uint32 packet_type_mask, bcm_cos_queue_t cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_cosq_mapping_set,
static int (*_rx_cosq_mapping_set_dispatch[])(
    int unit, 
    int index, 
    bcm_rx_reasons_t reasons, 
    bcm_rx_reasons_t reasons_mask, 
    uint8 int_prio, 
    uint8 int_prio_mask, 
    uint32 packet_type, 
    uint32 packet_type_mask, 
    bcm_cos_queue_t cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_cosq_mapping_set(
    int unit, 
    int index, 
    bcm_rx_reasons_t reasons, 
    bcm_rx_reasons_t reasons_mask, 
    uint8 int_prio, 
    uint8 int_prio_mask, 
    uint32 packet_type, 
    uint32 packet_type_mask, 
    bcm_cos_queue_t cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_cosq_mapping_set_dispatch[dtype](unit, index, reasons, reasons_mask, int_prio, int_prio_mask, packet_type, packet_type_mask, cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_cosq_mapping_set", 9, 2, unit, index, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_cosq_mapping_size_get( \
    int unit, int *size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_cosq_mapping_size_get,
static int (*_rx_cosq_mapping_size_get_dispatch[])(
    int unit, 
    int *size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_cosq_mapping_size_get(
    int unit, 
    int *size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_cosq_mapping_size_get_dispatch[dtype](unit, size);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_cosq_mapping_size_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_cpu_rate_get( \
    int unit, int *pps);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_cpu_rate_get,
static int (*_rx_cpu_rate_get_dispatch[])(
    int unit, 
    int *pps) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_cpu_rate_get(
    int unit, 
    int *pps)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_cpu_rate_get_dispatch[dtype](unit, pps);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_cpu_rate_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_cpu_rate_set( \
    int unit, int pps);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_cpu_rate_set,
static int (*_rx_cpu_rate_set_dispatch[])(
    int unit, 
    int pps) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_cpu_rate_set(
    int unit, 
    int pps)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_cpu_rate_set_dispatch[dtype](unit, pps);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_cpu_rate_set", 2, 2, unit, pps, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_free( \
    int unit, void *pkt_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_free,
static int (*_rx_free_dispatch[])(
    int unit, 
    void *pkt_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_free(
    int unit, 
    void *pkt_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_free_dispatch[dtype](unit, pkt_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_free", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_free_enqueue( \
    int unit, void *pkt_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_free_enqueue,
static int (*_rx_free_enqueue_dispatch[])(
    int unit, 
    void *pkt_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_free_enqueue(
    int unit, 
    void *pkt_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_free_enqueue_dispatch[dtype](unit, pkt_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_free_enqueue", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_init,
static int (*_rx_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_queue_channel_get( \
    int unit, bcm_cos_queue_t queue_id, bcm_rx_chan_t *chan_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_queue_channel_get,
static int (*_rx_queue_channel_get_dispatch[])(
    int unit, 
    bcm_cos_queue_t queue_id, 
    bcm_rx_chan_t *chan_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_queue_channel_get(
    int unit, 
    bcm_cos_queue_t queue_id, 
    bcm_rx_chan_t *chan_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_queue_channel_get_dispatch[dtype](unit, queue_id, chan_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_queue_channel_get", 3, 2, unit, queue_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_queue_channel_set( \
    int unit, bcm_cos_queue_t queue_id, bcm_rx_chan_t chan_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_queue_channel_set,
static int (*_rx_queue_channel_set_dispatch[])(
    int unit, 
    bcm_cos_queue_t queue_id, 
    bcm_rx_chan_t chan_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_queue_channel_set(
    int unit, 
    bcm_cos_queue_t queue_id, 
    bcm_rx_chan_t chan_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_queue_channel_set_dispatch[dtype](unit, queue_id, chan_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_queue_channel_set", 3, 3, unit, queue_id, chan_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_queue_max_get( \
    int unit, bcm_cos_queue_t *cosq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_queue_max_get,
static int (*_rx_queue_max_get_dispatch[])(
    int unit, 
    bcm_cos_queue_t *cosq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_queue_max_get(
    int unit, 
    bcm_cos_queue_t *cosq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_queue_max_get_dispatch[dtype](unit, cosq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_queue_max_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_queue_packet_count_get( \
    int unit, bcm_cos_queue_t cosq, int *packet_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_queue_packet_count_get,
static int (*_rx_queue_packet_count_get_dispatch[])(
    int unit, 
    bcm_cos_queue_t cosq, 
    int *packet_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_queue_packet_count_get(
    int unit, 
    bcm_cos_queue_t cosq, 
    int *packet_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_queue_packet_count_get_dispatch[dtype](unit, cosq, packet_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_queue_packet_count_get", 3, 2, unit, cosq, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_queue_rate_limit_status_get( \
    int unit, bcm_cos_queue_t cosq, int *packet_tokens);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_queue_rate_limit_status_get,
static int (*_rx_queue_rate_limit_status_get_dispatch[])(
    int unit, 
    bcm_cos_queue_t cosq, 
    int *packet_tokens) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_queue_rate_limit_status_get(
    int unit, 
    bcm_cos_queue_t cosq, 
    int *packet_tokens)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_queue_rate_limit_status_get_dispatch[dtype](unit, cosq, packet_tokens);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_queue_rate_limit_status_get", 3, 2, unit, cosq, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_queue_register( \
    int unit, const char *name, bcm_cos_queue_t cosq, bcm_rx_cb_f callback, uint8 priority, void *cookie, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_queue_register,
static int (*_rx_queue_register_dispatch[])(
    int unit, 
    const char *name, 
    bcm_cos_queue_t cosq, 
    bcm_rx_cb_f callback, 
    uint8 priority, 
    void *cookie, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_queue_register(
    int unit, 
    const char *name, 
    bcm_cos_queue_t cosq, 
    bcm_rx_cb_f callback, 
    uint8 priority, 
    void *cookie, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_queue_register_dispatch[dtype](unit, name, cosq, callback, priority, cookie, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_queue_register", 7, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_queue_unregister( \
    int unit, bcm_cos_queue_t cosq, bcm_rx_cb_f callback, uint8 priority);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_queue_unregister,
static int (*_rx_queue_unregister_dispatch[])(
    int unit, 
    bcm_cos_queue_t cosq, 
    bcm_rx_cb_f callback, 
    uint8 priority) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_queue_unregister(
    int unit, 
    bcm_cos_queue_t cosq, 
    bcm_rx_cb_f callback, 
    uint8 priority)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_queue_unregister_dispatch[dtype](unit, cosq, callback, priority);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_queue_unregister", 4, 2, unit, cosq, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_rate_get( \
    int unit, int *pps);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_rate_get,
static int (*_rx_rate_get_dispatch[])(
    int unit, 
    int *pps) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_rate_get(
    int unit, 
    int *pps)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_rate_get_dispatch[dtype](unit, pps);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_rate_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_rate_set( \
    int unit, int pps);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_rate_set,
static int (*_rx_rate_set_dispatch[])(
    int unit, 
    int pps) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_rate_set(
    int unit, 
    int pps)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_rate_set_dispatch[dtype](unit, pps);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_rate_set", 2, 2, unit, pps, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_reasons_get( \
    int unit, bcm_rx_reasons_t *reasons);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_reasons_get,
static int (*_rx_reasons_get_dispatch[])(
    int unit, 
    bcm_rx_reasons_t *reasons) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_reasons_get(
    int unit, 
    bcm_rx_reasons_t *reasons)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_reasons_get_dispatch[dtype](unit, reasons);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_reasons_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_reasons_policer_set( \
    int unit, bcm_rx_reasons_t rx_reasons, bcm_policer_t polid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_reasons_policer_set,
static int (*_rx_reasons_policer_set_dispatch[])(
    int unit, 
    bcm_rx_reasons_t rx_reasons, 
    bcm_policer_t polid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_reasons_policer_set(
    int unit, 
    bcm_rx_reasons_t rx_reasons, 
    bcm_policer_t polid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_reasons_policer_set_dispatch[dtype](unit, rx_reasons, polid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_reasons_policer_set", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_redirect_reasons_get( \
    int unit, bcm_rx_redirect_t mode, bcm_rx_reasons_t *reasons);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_redirect_reasons_get,
static int (*_rx_redirect_reasons_get_dispatch[])(
    int unit, 
    bcm_rx_redirect_t mode, 
    bcm_rx_reasons_t *reasons) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_redirect_reasons_get(
    int unit, 
    bcm_rx_redirect_t mode, 
    bcm_rx_reasons_t *reasons)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_redirect_reasons_get_dispatch[dtype](unit, mode, reasons);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_redirect_reasons_get", 3, 2, unit, mode, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_redirect_reasons_set( \
    int unit, bcm_rx_redirect_t mode, bcm_rx_reasons_t reasons);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_redirect_reasons_set,
static int (*_rx_redirect_reasons_set_dispatch[])(
    int unit, 
    bcm_rx_redirect_t mode, 
    bcm_rx_reasons_t reasons) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_redirect_reasons_set(
    int unit, 
    bcm_rx_redirect_t mode, 
    bcm_rx_reasons_t reasons)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_redirect_reasons_set_dispatch[dtype](unit, mode, reasons);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_redirect_reasons_set", 3, 2, unit, mode, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_register( \
    int unit, const char *name, bcm_rx_cb_f callback, uint8 priority, void *cookie, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_register,
static int (*_rx_register_dispatch[])(
    int unit, 
    const char *name, 
    bcm_rx_cb_f callback, 
    uint8 priority, 
    void *cookie, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_register(
    int unit, 
    const char *name, 
    bcm_rx_cb_f callback, 
    uint8 priority, 
    void *cookie, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_register_dispatch[dtype](unit, name, callback, priority, cookie, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_register", 6, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_remote_pkt_enqueue( \
    int unit, bcm_pkt_t *pkt);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_remote_pkt_enqueue,
static int (*_rx_remote_pkt_enqueue_dispatch[])(
    int unit, 
    bcm_pkt_t *pkt) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_remote_pkt_enqueue(
    int unit, 
    bcm_pkt_t *pkt)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_remote_pkt_enqueue_dispatch[dtype](unit, pkt);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_remote_pkt_enqueue", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_sched_register( \
    int unit, bcm_rx_sched_cb sched_cb);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_sched_register,
static int (*_rx_sched_register_dispatch[])(
    int unit, 
    bcm_rx_sched_cb sched_cb) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_sched_register(
    int unit, 
    bcm_rx_sched_cb sched_cb)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_sched_register_dispatch[dtype](unit, sched_cb);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_sched_register", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_sched_unregister( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_sched_unregister,
static int (*_rx_sched_unregister_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_sched_unregister(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_sched_unregister_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_sched_unregister", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

#if defined(BROADCOM_DEBUG)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_show( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_show,
static int (*_rx_show_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_show(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_show_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_show", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_snoop_create( \
    int unit, int flags, int *snoop_cmnd);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_snoop_create,
static int (*_rx_snoop_create_dispatch[])(
    int unit, 
    int flags, 
    int *snoop_cmnd) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_snoop_create(
    int unit, 
    int flags, 
    int *snoop_cmnd)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_snoop_create_dispatch[dtype](unit, flags, snoop_cmnd);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_snoop_create", 3, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_snoop_destroy( \
    int unit, int flags, int snoop_cmnd);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_snoop_destroy,
static int (*_rx_snoop_destroy_dispatch[])(
    int unit, 
    int flags, 
    int snoop_cmnd) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_snoop_destroy(
    int unit, 
    int flags, 
    int snoop_cmnd)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_snoop_destroy_dispatch[dtype](unit, flags, snoop_cmnd);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_snoop_destroy", 3, 3, unit, flags, snoop_cmnd, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_snoop_get( \
    int unit, int snoop_cmnd, bcm_rx_snoop_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_snoop_get,
static int (*_rx_snoop_get_dispatch[])(
    int unit, 
    int snoop_cmnd, 
    bcm_rx_snoop_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_snoop_get(
    int unit, 
    int snoop_cmnd, 
    bcm_rx_snoop_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_snoop_get_dispatch[dtype](unit, snoop_cmnd, config);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_P2A(unit,&config->dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_snoop_get", 3, 2, unit, snoop_cmnd, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_snoop_set( \
    int unit, int snoop_cmnd, bcm_rx_snoop_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_snoop_set,
static int (*_rx_snoop_set_dispatch[])(
    int unit, 
    int snoop_cmnd, 
    bcm_rx_snoop_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_snoop_set(
    int unit, 
    int snoop_cmnd, 
    bcm_rx_snoop_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(config_dest_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_SAVE(config_dest_port,config->dest_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_A2P(unit,&config->dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_snoop_set_dispatch[dtype](unit, snoop_cmnd, config);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_RESTORE(config->dest_port,config_dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_snoop_set", 3, 2, unit, snoop_cmnd, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_start( \
    int unit, bcm_rx_cfg_t *cfg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_start,
static int (*_rx_start_dispatch[])(
    int unit, 
    bcm_rx_cfg_t *cfg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_start(
    int unit, 
    bcm_rx_cfg_t *cfg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_start_dispatch[dtype](unit, cfg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_start", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_stop( \
    int unit, bcm_rx_cfg_t *cfg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_stop,
static int (*_rx_stop_dispatch[])(
    int unit, 
    bcm_rx_cfg_t *cfg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_stop(
    int unit, 
    bcm_rx_cfg_t *cfg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_stop_dispatch[dtype](unit, cfg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_stop", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_trap_get( \
    int unit, int trap_id, bcm_rx_trap_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_trap_get,
static int (*_rx_trap_get_dispatch[])(
    int unit, 
    int trap_id, 
    bcm_rx_trap_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_trap_get(
    int unit, 
    int trap_id, 
    bcm_rx_trap_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_trap_get_dispatch[dtype](unit, trap_id, config);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_P2A(unit,&config->dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_trap_get", 3, 2, unit, trap_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_trap_set( \
    int unit, int trap_id, bcm_rx_trap_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_trap_set,
static int (*_rx_trap_set_dispatch[])(
    int unit, 
    int trap_id, 
    bcm_rx_trap_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_trap_set(
    int unit, 
    int trap_id, 
    bcm_rx_trap_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(config_dest_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_SAVE(config_dest_port,config->dest_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_A2P(unit,&config->dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_trap_set_dispatch[dtype](unit, trap_id, config);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_RESTORE(config->dest_port,config_dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_trap_set", 3, 2, unit, trap_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_trap_type_create( \
    int unit, int flags, bcm_rx_trap_t type, int *trap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_trap_type_create,
static int (*_rx_trap_type_create_dispatch[])(
    int unit, 
    int flags, 
    bcm_rx_trap_t type, 
    int *trap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_trap_type_create(
    int unit, 
    int flags, 
    bcm_rx_trap_t type, 
    int *trap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_trap_type_create_dispatch[dtype](unit, flags, type, trap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_trap_type_create", 4, 3, unit, flags, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_trap_type_destroy( \
    int unit, int trap_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_trap_type_destroy,
static int (*_rx_trap_type_destroy_dispatch[])(
    int unit, 
    int trap_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_trap_type_destroy(
    int unit, 
    int trap_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_trap_type_destroy_dispatch[dtype](unit, trap_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_trap_type_destroy", 2, 2, unit, trap_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_unit_next_get( \
    int unit, int *next_unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_unit_next_get,
static int (*_rx_unit_next_get_dispatch[])(
    int unit, 
    int *next_unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_unit_next_get(
    int unit, 
    int *next_unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_unit_next_get_dispatch[dtype](unit, next_unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_unit_next_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_rx_unregister( \
    int unit, bcm_rx_cb_f callback, uint8 priority);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_rx_unregister,
static int (*_rx_unregister_dispatch[])(
    int unit, 
    bcm_rx_cb_f callback, 
    uint8 priority) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_rx_unregister(
    int unit, 
    bcm_rx_cb_f callback, 
    uint8 priority)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _rx_unregister_dispatch[dtype](unit, callback, priority);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_rx_unregister", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_sat_endpoint_create( \
    int unit, bcm_sat_endpoint_info_t *endpoint_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_sat_endpoint_create,
static int (*_sat_endpoint_create_dispatch[])(
    int unit, 
    bcm_sat_endpoint_info_t *endpoint_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_sat_endpoint_create(
    int unit, 
    bcm_sat_endpoint_info_t *endpoint_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_A2P(unit,&endpoint_info->dest_gport);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_A2P(unit,&endpoint_info->src_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _sat_endpoint_create_dispatch[dtype](unit, endpoint_info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->dest_gport);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->src_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_sat_endpoint_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_sat_endpoint_destroy( \
    int unit, bcm_sat_endpoint_t endpoint, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_sat_endpoint_destroy,
static int (*_sat_endpoint_destroy_dispatch[])(
    int unit, 
    bcm_sat_endpoint_t endpoint, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_sat_endpoint_destroy(
    int unit, 
    bcm_sat_endpoint_t endpoint, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _sat_endpoint_destroy_dispatch[dtype](unit, endpoint, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_sat_endpoint_destroy", 3, 3, unit, endpoint, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_sat_endpoint_destroy_all( \
    int unit, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_sat_endpoint_destroy_all,
static int (*_sat_endpoint_destroy_all_dispatch[])(
    int unit, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_sat_endpoint_destroy_all(
    int unit, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _sat_endpoint_destroy_all_dispatch[dtype](unit, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_sat_endpoint_destroy_all", 2, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_sat_endpoint_get( \
    int unit, bcm_sat_endpoint_t endpoint, uint32 flags, bcm_sat_endpoint_info_t *endpoint_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_sat_endpoint_get,
static int (*_sat_endpoint_get_dispatch[])(
    int unit, 
    bcm_sat_endpoint_t endpoint, 
    uint32 flags, 
    bcm_sat_endpoint_info_t *endpoint_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_sat_endpoint_get(
    int unit, 
    bcm_sat_endpoint_t endpoint, 
    uint32 flags, 
    bcm_sat_endpoint_info_t *endpoint_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _sat_endpoint_get_dispatch[dtype](unit, endpoint, flags, endpoint_info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->dest_gport);
		BCM_API_XLATE_PORT_COND(endpoint_info) BCM_API_XLATE_PORT_P2A(unit,&endpoint_info->src_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_sat_endpoint_get", 4, 3, unit, endpoint, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_sat_endpoint_traverse( \
    int unit, uint32 flags, bcm_sat_endpoint_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_sat_endpoint_traverse,
static int (*_sat_endpoint_traverse_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_sat_endpoint_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_sat_endpoint_traverse(
    int unit, 
    uint32 flags, 
    bcm_sat_endpoint_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _sat_endpoint_traverse_dispatch[dtype](unit, flags, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_sat_endpoint_traverse", 4, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_clear( \
    int unit, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_clear,
static int (*_stat_clear_dispatch[])(
    int unit, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_clear(
    int unit, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_clear_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_clear", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_custom_add( \
    int unit, bcm_port_t port, bcm_stat_val_t type, bcm_custom_stat_trigger_t trigger);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_custom_add,
static int (*_stat_custom_add_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    bcm_custom_stat_trigger_t trigger) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_custom_add(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    bcm_custom_stat_trigger_t trigger)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_custom_add_dispatch[dtype](unit, port, type, trigger);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_custom_add", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_custom_check( \
    int unit, bcm_port_t port, bcm_stat_val_t type, bcm_custom_stat_trigger_t trigger, int *result);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_custom_check,
static int (*_stat_custom_check_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    bcm_custom_stat_trigger_t trigger, 
    int *result) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_custom_check(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    bcm_custom_stat_trigger_t trigger, 
    int *result)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_custom_check_dispatch[dtype](unit, port, type, trigger, result);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_custom_check", 5, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_custom_delete( \
    int unit, bcm_port_t port, bcm_stat_val_t type, bcm_custom_stat_trigger_t trigger);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_custom_delete,
static int (*_stat_custom_delete_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    bcm_custom_stat_trigger_t trigger) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_custom_delete(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    bcm_custom_stat_trigger_t trigger)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_custom_delete_dispatch[dtype](unit, port, type, trigger);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_custom_delete", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_custom_delete_all( \
    int unit, bcm_port_t port, bcm_stat_val_t type);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_custom_delete_all,
static int (*_stat_custom_delete_all_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_custom_delete_all(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_custom_delete_all_dispatch[dtype](unit, port, type);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_custom_delete_all", 3, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_custom_get( \
    int unit, bcm_port_t port, bcm_stat_val_t type, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_custom_get,
static int (*_stat_custom_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_custom_get(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_custom_get_dispatch[dtype](unit, port, type, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_custom_get", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_custom_group_create( \
    int unit, uint32 mode_id, bcm_stat_object_t object, uint32 *stat_counter_id, uint32 *num_entries);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_custom_group_create,
static int (*_stat_custom_group_create_dispatch[])(
    int unit, 
    uint32 mode_id, 
    bcm_stat_object_t object, 
    uint32 *stat_counter_id, 
    uint32 *num_entries) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_custom_group_create(
    int unit, 
    uint32 mode_id, 
    bcm_stat_object_t object, 
    uint32 *stat_counter_id, 
    uint32 *num_entries)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_custom_group_create_dispatch[dtype](unit, mode_id, object, stat_counter_id, num_entries);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_custom_group_create", 5, 3, unit, mode_id, object, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_custom_set( \
    int unit, bcm_port_t port, bcm_stat_val_t type, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_custom_set,
static int (*_stat_custom_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_custom_set(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_custom_set_dispatch[dtype](unit, port, type, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_custom_set", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_flex_pool_info_multi_get( \
    int unit, bcm_stat_flex_direction_t direction, uint32 num_pools, uint32 *actual_num_pools, bcm_stat_flex_pool_stat_info_t *flex_pool_stat);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_flex_pool_info_multi_get,
static int (*_stat_flex_pool_info_multi_get_dispatch[])(
    int unit, 
    bcm_stat_flex_direction_t direction, 
    uint32 num_pools, 
    uint32 *actual_num_pools, 
    bcm_stat_flex_pool_stat_info_t *flex_pool_stat) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_flex_pool_info_multi_get(
    int unit, 
    bcm_stat_flex_direction_t direction, 
    uint32 num_pools, 
    uint32 *actual_num_pools, 
    bcm_stat_flex_pool_stat_info_t *flex_pool_stat)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_flex_pool_info_multi_get_dispatch[dtype](unit, direction, num_pools, actual_num_pools, flex_pool_stat);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_flex_pool_info_multi_get", 5, 3, unit, direction, num_pools, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_get( \
    int unit, bcm_port_t port, bcm_stat_val_t type, uint64 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_get,
static int (*_stat_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    uint64 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_get(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    uint64 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_get_dispatch[dtype](unit, port, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_get", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_get32( \
    int unit, bcm_port_t port, bcm_stat_val_t type, uint32 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_get32,
static int (*_stat_get32_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    uint32 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_get32(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    uint32 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_get32_dispatch[dtype](unit, port, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_get32", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_group_create( \
    int unit, bcm_stat_object_t object, bcm_stat_group_mode_t group_mode, uint32 *stat_counter_id, uint32 *num_entries);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_group_create,
static int (*_stat_group_create_dispatch[])(
    int unit, 
    bcm_stat_object_t object, 
    bcm_stat_group_mode_t group_mode, 
    uint32 *stat_counter_id, 
    uint32 *num_entries) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_group_create(
    int unit, 
    bcm_stat_object_t object, 
    bcm_stat_group_mode_t group_mode, 
    uint32 *stat_counter_id, 
    uint32 *num_entries)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_group_create_dispatch[dtype](unit, object, group_mode, stat_counter_id, num_entries);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_group_create", 5, 3, unit, object, group_mode, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_group_destroy( \
    int unit, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_group_destroy,
static int (*_stat_group_destroy_dispatch[])(
    int unit, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_group_destroy(
    int unit, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_group_destroy_dispatch[dtype](unit, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_group_destroy", 2, 2, unit, stat_counter_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_group_dump( \
    int unit, bcm_stat_object_t object, bcm_stat_group_mode_t group_mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_group_dump,
static int (*_stat_group_dump_dispatch[])(
    int unit, 
    bcm_stat_object_t object, 
    bcm_stat_group_mode_t group_mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_group_dump(
    int unit, 
    bcm_stat_object_t object, 
    bcm_stat_group_mode_t group_mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_group_dump_dispatch[dtype](unit, object, group_mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_group_dump", 3, 3, unit, object, group_mode, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_group_dump_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_group_dump_all,
static int (*_stat_group_dump_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_group_dump_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_group_dump_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_group_dump_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_group_mode_id_create( \
    int unit, uint32 flags, uint32 total_counters, uint32 num_selectors, bcm_stat_group_mode_attr_selector_t *attr_selectors, uint32 *mode_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_group_mode_id_create,
static int (*_stat_group_mode_id_create_dispatch[])(
    int unit, 
    uint32 flags, 
    uint32 total_counters, 
    uint32 num_selectors, 
    bcm_stat_group_mode_attr_selector_t *attr_selectors, 
    uint32 *mode_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_group_mode_id_create(
    int unit, 
    uint32 flags, 
    uint32 total_counters, 
    uint32 num_selectors, 
    bcm_stat_group_mode_attr_selector_t *attr_selectors, 
    uint32 *mode_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_group_mode_id_create_dispatch[dtype](unit, flags, total_counters, num_selectors, attr_selectors, mode_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_group_mode_id_create", 6, 3, unit, flags, total_counters, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_group_mode_id_destroy( \
    int unit, uint32 mode_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_group_mode_id_destroy,
static int (*_stat_group_mode_id_destroy_dispatch[])(
    int unit, 
    uint32 mode_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_group_mode_id_destroy(
    int unit, 
    uint32 mode_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_group_mode_id_destroy_dispatch[dtype](unit, mode_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_group_mode_id_destroy", 2, 2, unit, mode_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_group_mode_id_get( \
    int unit, uint32 mode_id, uint32 *flags, uint32 *total_counters, uint32 num_selectors, bcm_stat_group_mode_attr_selector_t *attr_selectors, uint32 *actual_num_selectors);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_group_mode_id_get,
static int (*_stat_group_mode_id_get_dispatch[])(
    int unit, 
    uint32 mode_id, 
    uint32 *flags, 
    uint32 *total_counters, 
    uint32 num_selectors, 
    bcm_stat_group_mode_attr_selector_t *attr_selectors, 
    uint32 *actual_num_selectors) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_group_mode_id_get(
    int unit, 
    uint32 mode_id, 
    uint32 *flags, 
    uint32 *total_counters, 
    uint32 num_selectors, 
    bcm_stat_group_mode_attr_selector_t *attr_selectors, 
    uint32 *actual_num_selectors)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_group_mode_id_get_dispatch[dtype](unit, mode_id, flags, total_counters, num_selectors, attr_selectors, actual_num_selectors);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_group_mode_id_get", 7, 2, unit, mode_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_id_get_all( \
    int unit, bcm_stat_object_t object, int stat_max, uint32 *stat_array, int *stat_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_id_get_all,
static int (*_stat_id_get_all_dispatch[])(
    int unit, 
    bcm_stat_object_t object, 
    int stat_max, 
    uint32 *stat_array, 
    int *stat_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_id_get_all(
    int unit, 
    bcm_stat_object_t object, 
    int stat_max, 
    uint32 *stat_array, 
    int *stat_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_id_get_all_dispatch[dtype](unit, object, stat_max, stat_array, stat_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_id_get_all", 5, 3, unit, object, stat_max, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_init,
static int (*_stat_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_multi_get( \
    int unit, bcm_port_t port, int nstat, bcm_stat_val_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_multi_get,
static int (*_stat_multi_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int nstat, 
    bcm_stat_val_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_multi_get(
    int unit, 
    bcm_port_t port, 
    int nstat, 
    bcm_stat_val_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_multi_get_dispatch[dtype](unit, port, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_multi_get", 5, 3, unit, port, nstat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_multi_get32( \
    int unit, bcm_port_t port, int nstat, bcm_stat_val_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_multi_get32,
static int (*_stat_multi_get32_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int nstat, 
    bcm_stat_val_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_multi_get32(
    int unit, 
    bcm_port_t port, 
    int nstat, 
    bcm_stat_val_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_multi_get32_dispatch[dtype](unit, port, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_multi_get32", 5, 3, unit, port, nstat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_sync( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_sync,
static int (*_stat_sync_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_sync(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_sync_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_sync", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_sync_get( \
    int unit, bcm_port_t port, bcm_stat_val_t type, uint64 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_sync_get,
static int (*_stat_sync_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    uint64 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_sync_get(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    uint64 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_sync_get_dispatch[dtype](unit, port, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_sync_get", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_sync_get32( \
    int unit, bcm_port_t port, bcm_stat_val_t type, uint32 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_sync_get32,
static int (*_stat_sync_get32_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    uint32 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_sync_get32(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t type, 
    uint32 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_sync_get32_dispatch[dtype](unit, port, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_sync_get32", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_sync_multi_get( \
    int unit, bcm_port_t port, int nstat, bcm_stat_val_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_sync_multi_get,
static int (*_stat_sync_multi_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int nstat, 
    bcm_stat_val_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_sync_multi_get(
    int unit, 
    bcm_port_t port, 
    int nstat, 
    bcm_stat_val_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_sync_multi_get_dispatch[dtype](unit, port, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_sync_multi_get", 5, 3, unit, port, nstat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_sync_multi_get32( \
    int unit, bcm_port_t port, int nstat, bcm_stat_val_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_sync_multi_get32,
static int (*_stat_sync_multi_get32_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int nstat, 
    bcm_stat_val_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_sync_multi_get32(
    int unit, 
    bcm_port_t port, 
    int nstat, 
    bcm_stat_val_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_sync_multi_get32_dispatch[dtype](unit, port, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_sync_multi_get32", 5, 3, unit, port, nstat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_threshold_get( \
    int unit, bcm_port_t port, bcm_stat_val_t stat, bcm_stat_threshold_t *threshold);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_threshold_get,
static int (*_stat_threshold_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t stat, 
    bcm_stat_threshold_t *threshold) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_threshold_get(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t stat, 
    bcm_stat_threshold_t *threshold)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_threshold_get_dispatch[dtype](unit, port, stat, threshold);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_threshold_get", 4, 3, unit, port, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stat_threshold_set( \
    int unit, bcm_port_t port, bcm_stat_val_t stat, bcm_stat_threshold_t *threshold);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stat_threshold_set,
static int (*_stat_threshold_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t stat, 
    bcm_stat_threshold_t *threshold) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stat_threshold_set(
    int unit, 
    bcm_port_t port, 
    bcm_stat_val_t stat, 
    bcm_stat_threshold_t *threshold)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stat_threshold_set_dispatch[dtype](unit, port, stat, threshold);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stat_threshold_set", 4, 3, unit, port, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_clear( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_clear,
static int (*_stg_clear_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_clear(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_clear_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_clear", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_count_get( \
    int unit, int *max_stg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_count_get,
static int (*_stg_count_get_dispatch[])(
    int unit, 
    int *max_stg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_count_get(
    int unit, 
    int *max_stg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_count_get_dispatch[dtype](unit, max_stg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_count_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_create( \
    int unit, bcm_stg_t *stg_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_create,
static int (*_stg_create_dispatch[])(
    int unit, 
    bcm_stg_t *stg_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_create(
    int unit, 
    bcm_stg_t *stg_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_create_dispatch[dtype](unit, stg_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_create_id( \
    int unit, bcm_stg_t stg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_create_id,
static int (*_stg_create_id_dispatch[])(
    int unit, 
    bcm_stg_t stg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_create_id(
    int unit, 
    bcm_stg_t stg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_create_id_dispatch[dtype](unit, stg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_create_id", 2, 2, unit, stg, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_default_get( \
    int unit, bcm_stg_t *stg_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_default_get,
static int (*_stg_default_get_dispatch[])(
    int unit, 
    bcm_stg_t *stg_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_default_get(
    int unit, 
    bcm_stg_t *stg_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_default_get_dispatch[dtype](unit, stg_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_default_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_default_set( \
    int unit, bcm_stg_t stg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_default_set,
static int (*_stg_default_set_dispatch[])(
    int unit, 
    bcm_stg_t stg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_default_set(
    int unit, 
    bcm_stg_t stg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_default_set_dispatch[dtype](unit, stg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_default_set", 2, 2, unit, stg, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_destroy( \
    int unit, bcm_stg_t stg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_destroy,
static int (*_stg_destroy_dispatch[])(
    int unit, 
    bcm_stg_t stg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_destroy(
    int unit, 
    bcm_stg_t stg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_destroy_dispatch[dtype](unit, stg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_destroy", 2, 2, unit, stg, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_init,
static int (*_stg_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_list( \
    int unit, bcm_stg_t **list, int *count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_list,
static int (*_stg_list_dispatch[])(
    int unit, 
    bcm_stg_t **list, 
    int *count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_list(
    int unit, 
    bcm_stg_t **list, 
    int *count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_list_dispatch[dtype](unit, list, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_list", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_list_destroy( \
    int unit, bcm_stg_t *list, int count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_list_destroy,
static int (*_stg_list_destroy_dispatch[])(
    int unit, 
    bcm_stg_t *list, 
    int count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_list_destroy(
    int unit, 
    bcm_stg_t *list, 
    int count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_list_destroy_dispatch[dtype](unit, list, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_list_destroy", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_stp_get( \
    int unit, bcm_stg_t stg, bcm_port_t port, int *stp_state);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_stp_get,
static int (*_stg_stp_get_dispatch[])(
    int unit, 
    bcm_stg_t stg, 
    bcm_port_t port, 
    int *stp_state) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_stp_get(
    int unit, 
    bcm_stg_t stg, 
    bcm_port_t port, 
    int *stp_state)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_stp_get_dispatch[dtype](unit, stg, port, stp_state);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_stp_get", 4, 3, unit, stg, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_stp_set( \
    int unit, bcm_stg_t stg, bcm_port_t port, int stp_state);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_stp_set,
static int (*_stg_stp_set_dispatch[])(
    int unit, 
    bcm_stg_t stg, 
    bcm_port_t port, 
    int stp_state) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_stp_set(
    int unit, 
    bcm_stg_t stg, 
    bcm_port_t port, 
    int stp_state)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_stp_set_dispatch[dtype](unit, stg, port, stp_state);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_stp_set", 4, 3, unit, stg, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_vlan_add( \
    int unit, bcm_stg_t stg, bcm_vlan_t vid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_vlan_add,
static int (*_stg_vlan_add_dispatch[])(
    int unit, 
    bcm_stg_t stg, 
    bcm_vlan_t vid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_vlan_add(
    int unit, 
    bcm_stg_t stg, 
    bcm_vlan_t vid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_vlan_add_dispatch[dtype](unit, stg, vid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_vlan_add", 3, 3, unit, stg, vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_vlan_list( \
    int unit, bcm_stg_t stg, bcm_vlan_t **list, int *count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_vlan_list,
static int (*_stg_vlan_list_dispatch[])(
    int unit, 
    bcm_stg_t stg, 
    bcm_vlan_t **list, 
    int *count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_vlan_list(
    int unit, 
    bcm_stg_t stg, 
    bcm_vlan_t **list, 
    int *count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_vlan_list_dispatch[dtype](unit, stg, list, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_vlan_list", 4, 2, unit, stg, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_vlan_list_destroy( \
    int unit, bcm_vlan_t *list, int count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_vlan_list_destroy,
static int (*_stg_vlan_list_destroy_dispatch[])(
    int unit, 
    bcm_vlan_t *list, 
    int count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_vlan_list_destroy(
    int unit, 
    bcm_vlan_t *list, 
    int count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_vlan_list_destroy_dispatch[dtype](unit, list, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_vlan_list_destroy", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_vlan_remove( \
    int unit, bcm_stg_t stg, bcm_vlan_t vid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_vlan_remove,
static int (*_stg_vlan_remove_dispatch[])(
    int unit, 
    bcm_stg_t stg, 
    bcm_vlan_t vid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_vlan_remove(
    int unit, 
    bcm_stg_t stg, 
    bcm_vlan_t vid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_vlan_remove_dispatch[dtype](unit, stg, vid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_vlan_remove", 3, 3, unit, stg, vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stg_vlan_remove_all( \
    int unit, bcm_stg_t stg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stg_vlan_remove_all,
static int (*_stg_vlan_remove_all_dispatch[])(
    int unit, 
    bcm_stg_t stg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stg_vlan_remove_all(
    int unit, 
    bcm_stg_t stg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stg_vlan_remove_all_dispatch[dtype](unit, stg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stg_vlan_remove_all", 2, 2, unit, stg, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_domain_stk_trunk_add( \
    int unit, int tm_domain, bcm_trunk_t stk_trunk);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_domain_stk_trunk_add,
static int (*_stk_domain_stk_trunk_add_dispatch[])(
    int unit, 
    int tm_domain, 
    bcm_trunk_t stk_trunk) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_domain_stk_trunk_add(
    int unit, 
    int tm_domain, 
    bcm_trunk_t stk_trunk)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_domain_stk_trunk_add_dispatch[dtype](unit, tm_domain, stk_trunk);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_domain_stk_trunk_add", 3, 3, unit, tm_domain, stk_trunk, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_domain_stk_trunk_delete( \
    int unit, int tm_domain, bcm_trunk_t stk_trunk);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_domain_stk_trunk_delete,
static int (*_stk_domain_stk_trunk_delete_dispatch[])(
    int unit, 
    int tm_domain, 
    bcm_trunk_t stk_trunk) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_domain_stk_trunk_delete(
    int unit, 
    int tm_domain, 
    bcm_trunk_t stk_trunk)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_domain_stk_trunk_delete_dispatch[dtype](unit, tm_domain, stk_trunk);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_domain_stk_trunk_delete", 3, 3, unit, tm_domain, stk_trunk, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_domain_stk_trunk_get( \
    int unit, bcm_trunk_t stk_trunk, int domain_max, int *domain_array, int *domain_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_domain_stk_trunk_get,
static int (*_stk_domain_stk_trunk_get_dispatch[])(
    int unit, 
    bcm_trunk_t stk_trunk, 
    int domain_max, 
    int *domain_array, 
    int *domain_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_domain_stk_trunk_get(
    int unit, 
    bcm_trunk_t stk_trunk, 
    int domain_max, 
    int *domain_array, 
    int *domain_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_domain_stk_trunk_get_dispatch[dtype](unit, stk_trunk, domain_max, domain_array, domain_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_domain_stk_trunk_get", 5, 3, unit, stk_trunk, domain_max, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_fabric_map_get( \
    int unit, bcm_gport_t switch_port, bcm_gport_t *fabric_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_fabric_map_get,
static int (*_stk_fabric_map_get_dispatch[])(
    int unit, 
    bcm_gport_t switch_port, 
    bcm_gport_t *fabric_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_fabric_map_get(
    int unit, 
    bcm_gport_t switch_port, 
    bcm_gport_t *fabric_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&switch_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_fabric_map_get_dispatch[dtype](unit, switch_port, fabric_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,fabric_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_fabric_map_get", 3, 2, unit, switch_port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_fabric_map_set( \
    int unit, bcm_gport_t switch_port, bcm_gport_t fabric_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_fabric_map_set,
static int (*_stk_fabric_map_set_dispatch[])(
    int unit, 
    bcm_gport_t switch_port, 
    bcm_gport_t fabric_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_fabric_map_set(
    int unit, 
    bcm_gport_t switch_port, 
    bcm_gport_t fabric_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&switch_port);
		BCM_API_XLATE_PORT_A2P(unit,&fabric_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_fabric_map_set_dispatch[dtype](unit, switch_port, fabric_port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_fabric_map_set", 3, 3, unit, switch_port, fabric_port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_fmod_lmod_mapping_get( \
    int unit, bcm_port_t port, bcm_module_t *fmod, bcm_module_t *lmod);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_fmod_lmod_mapping_get,
static int (*_stk_fmod_lmod_mapping_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_module_t *fmod, 
    bcm_module_t *lmod) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_fmod_lmod_mapping_get(
    int unit, 
    bcm_port_t port, 
    bcm_module_t *fmod, 
    bcm_module_t *lmod)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_fmod_lmod_mapping_get_dispatch[dtype](unit, port, fmod, lmod);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_fmod_lmod_mapping_get", 4, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_fmod_lmod_mapping_set( \
    int unit, bcm_port_t port, bcm_module_t fmod, bcm_module_t lmod);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_fmod_lmod_mapping_set,
static int (*_stk_fmod_lmod_mapping_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_module_t fmod, 
    bcm_module_t lmod) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_fmod_lmod_mapping_set(
    int unit, 
    bcm_port_t port, 
    bcm_module_t fmod, 
    bcm_module_t lmod)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_fmod_lmod_mapping_set_dispatch[dtype](unit, port, fmod, lmod);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_fmod_lmod_mapping_set", 4, 3, unit, port, fmod, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_fmod_smod_mapping_get( \
    int unit, bcm_port_t port, bcm_module_t fmod, bcm_module_t *smod, bcm_port_t *sport, uint32 *nports);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_fmod_smod_mapping_get,
static int (*_stk_fmod_smod_mapping_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_module_t fmod, 
    bcm_module_t *smod, 
    bcm_port_t *sport, 
    uint32 *nports) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_fmod_smod_mapping_get(
    int unit, 
    bcm_port_t port, 
    bcm_module_t fmod, 
    bcm_module_t *smod, 
    bcm_port_t *sport, 
    uint32 *nports)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_fmod_smod_mapping_get_dispatch[dtype](unit, port, fmod, smod, sport, nports);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_fmod_smod_mapping_get", 6, 3, unit, port, fmod, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_fmod_smod_mapping_set( \
    int unit, bcm_port_t port, bcm_module_t fmod, bcm_module_t smod, bcm_port_t sport, uint32 nports);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_fmod_smod_mapping_set,
static int (*_stk_fmod_smod_mapping_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_module_t fmod, 
    bcm_module_t smod, 
    bcm_port_t sport, 
    uint32 nports) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_fmod_smod_mapping_set(
    int unit, 
    bcm_port_t port, 
    bcm_module_t fmod, 
    bcm_module_t smod, 
    bcm_port_t sport, 
    uint32 nports)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_fmod_smod_mapping_set_dispatch[dtype](unit, port, fmod, smod, sport, nports);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_fmod_smod_mapping_set", 6, 3, unit, port, fmod, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_gport_sysport_get( \
    int unit, bcm_gport_t gport, bcm_gport_t *sysport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_gport_sysport_get,
static int (*_stk_gport_sysport_get_dispatch[])(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t *sysport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_gport_sysport_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_gport_t *sysport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_gport_sysport_get_dispatch[dtype](unit, gport, sysport);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,sysport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_gport_sysport_get", 3, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_init,
static int (*_stk_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_mode_get( \
    int unit, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_mode_get,
static int (*_stk_mode_get_dispatch[])(
    int unit, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_mode_get(
    int unit, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_mode_get_dispatch[dtype](unit, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_mode_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_mode_set( \
    int unit, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_mode_set,
static int (*_stk_mode_set_dispatch[])(
    int unit, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_mode_set(
    int unit, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_mode_set_dispatch[dtype](unit, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_mode_set", 2, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modid_config_get( \
    int unit, bcm_stk_modid_config_t *modid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modid_config_get,
static int (*_stk_modid_config_get_dispatch[])(
    int unit, 
    bcm_stk_modid_config_t *modid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modid_config_get(
    int unit, 
    bcm_stk_modid_config_t *modid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modid_config_get_dispatch[dtype](unit, modid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modid_config_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modid_config_set( \
    int unit, bcm_stk_modid_config_t *modid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modid_config_set,
static int (*_stk_modid_config_set_dispatch[])(
    int unit, 
    bcm_stk_modid_config_t *modid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modid_config_set(
    int unit, 
    bcm_stk_modid_config_t *modid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modid_config_set_dispatch[dtype](unit, modid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modid_config_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modid_count( \
    int unit, int *num_modid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modid_count,
static int (*_stk_modid_count_dispatch[])(
    int unit, 
    int *num_modid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modid_count(
    int unit, 
    int *num_modid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modid_count_dispatch[dtype](unit, num_modid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modid_count", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modid_domain_add( \
    int unit, int modid, int tm_domain);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modid_domain_add,
static int (*_stk_modid_domain_add_dispatch[])(
    int unit, 
    int modid, 
    int tm_domain) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modid_domain_add(
    int unit, 
    int modid, 
    int tm_domain)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modid_domain_add_dispatch[dtype](unit, modid, tm_domain);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modid_domain_add", 3, 3, unit, modid, tm_domain, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modid_domain_delete( \
    int unit, int modid, int tm_domain);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modid_domain_delete,
static int (*_stk_modid_domain_delete_dispatch[])(
    int unit, 
    int modid, 
    int tm_domain) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modid_domain_delete(
    int unit, 
    int modid, 
    int tm_domain)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modid_domain_delete_dispatch[dtype](unit, modid, tm_domain);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modid_domain_delete", 3, 3, unit, modid, tm_domain, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modid_domain_get( \
    int unit, int tm_domain, int mod_max, int *mod_array, int *mod_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modid_domain_get,
static int (*_stk_modid_domain_get_dispatch[])(
    int unit, 
    int tm_domain, 
    int mod_max, 
    int *mod_array, 
    int *mod_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modid_domain_get(
    int unit, 
    int tm_domain, 
    int mod_max, 
    int *mod_array, 
    int *mod_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modid_domain_get_dispatch[dtype](unit, tm_domain, mod_max, mod_array, mod_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modid_domain_get", 5, 3, unit, tm_domain, mod_max, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modid_get( \
    int unit, int *modid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modid_get,
static int (*_stk_modid_get_dispatch[])(
    int unit, 
    int *modid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modid_get(
    int unit, 
    int *modid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modid_get_dispatch[dtype](unit, modid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modid_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modid_set( \
    int unit, int modid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modid_set,
static int (*_stk_modid_set_dispatch[])(
    int unit, 
    int modid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modid_set(
    int unit, 
    int modid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modid_set_dispatch[dtype](unit, modid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modid_set", 2, 2, unit, modid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modmap_enable_get( \
    int unit, bcm_port_t port, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modmap_enable_get,
static int (*_stk_modmap_enable_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modmap_enable_get(
    int unit, 
    bcm_port_t port, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modmap_enable_get_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modmap_enable_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modmap_enable_set( \
    int unit, bcm_port_t port, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modmap_enable_set,
static int (*_stk_modmap_enable_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modmap_enable_set(
    int unit, 
    bcm_port_t port, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modmap_enable_set_dispatch[dtype](unit, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modmap_enable_set", 3, 3, unit, port, enable, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modmap_map( \
    int unit, int setget, bcm_module_t mod_in, bcm_port_t port_in, bcm_module_t *mod_out, bcm_port_t *port_out);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modmap_map,
static int (*_stk_modmap_map_dispatch[])(
    int unit, 
    int setget, 
    bcm_module_t mod_in, 
    bcm_port_t port_in, 
    bcm_module_t *mod_out, 
    bcm_port_t *port_out) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modmap_map(
    int unit, 
    int setget, 
    bcm_module_t mod_in, 
    bcm_port_t port_in, 
    bcm_module_t *mod_out, 
    bcm_port_t *port_out)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modmap_map_dispatch[dtype](unit, setget, mod_in, port_in, mod_out, port_out);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modmap_map", 6, 3, unit, setget, mod_in, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modmap_register( \
    int unit, bcm_stk_modmap_cb_t func);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modmap_register,
static int (*_stk_modmap_register_dispatch[])(
    int unit, 
    bcm_stk_modmap_cb_t func) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modmap_register(
    int unit, 
    bcm_stk_modmap_cb_t func)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modmap_register_dispatch[dtype](unit, func);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modmap_register", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modmap_unregister( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modmap_unregister,
static int (*_stk_modmap_unregister_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modmap_unregister(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modmap_unregister_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modmap_unregister", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modport_add( \
    int unit, int modid, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modport_add,
static int (*_stk_modport_add_dispatch[])(
    int unit, 
    int modid, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modport_add(
    int unit, 
    int modid, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modport_add_dispatch[dtype](unit, modid, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modport_add", 3, 3, unit, modid, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modport_clear( \
    int unit, int modid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modport_clear,
static int (*_stk_modport_clear_dispatch[])(
    int unit, 
    int modid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modport_clear(
    int unit, 
    int modid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modport_clear_dispatch[dtype](unit, modid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modport_clear", 2, 2, unit, modid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modport_clear_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modport_clear_all,
static int (*_stk_modport_clear_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modport_clear_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modport_clear_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modport_clear_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modport_delete( \
    int unit, int modid, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modport_delete,
static int (*_stk_modport_delete_dispatch[])(
    int unit, 
    int modid, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modport_delete(
    int unit, 
    int modid, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modport_delete_dispatch[dtype](unit, modid, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modport_delete", 3, 3, unit, modid, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modport_get( \
    int unit, int modid, int *port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modport_get,
static int (*_stk_modport_get_dispatch[])(
    int unit, 
    int modid, 
    int *port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modport_get(
    int unit, 
    int modid, 
    int *port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modport_get_dispatch[dtype](unit, modid, port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modport_get", 3, 2, unit, modid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modport_get_all( \
    int unit, int modid, int port_max, int *port_array, int *port_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modport_get_all,
static int (*_stk_modport_get_all_dispatch[])(
    int unit, 
    int modid, 
    int port_max, 
    int *port_array, 
    int *port_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modport_get_all(
    int unit, 
    int modid, 
    int port_max, 
    int *port_array, 
    int *port_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modport_get_all_dispatch[dtype](unit, modid, port_max, port_array, port_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modport_get_all", 5, 3, unit, modid, port_max, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modport_remote_map_get( \
    int unit, bcm_gport_t port, uint32 flags, int *remote_modid, bcm_port_t *remote_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modport_remote_map_get,
static int (*_stk_modport_remote_map_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    int *remote_modid, 
    bcm_port_t *remote_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modport_remote_map_get(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    int *remote_modid, 
    bcm_port_t *remote_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modport_remote_map_get_dispatch[dtype](unit, port, flags, remote_modid, remote_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,remote_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modport_remote_map_get", 5, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modport_remote_map_set( \
    int unit, bcm_gport_t port, uint32 flags, int remote_modid, bcm_port_t remote_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modport_remote_map_set,
static int (*_stk_modport_remote_map_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    int remote_modid, 
    bcm_port_t remote_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modport_remote_map_set(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    int remote_modid, 
    bcm_port_t remote_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_A2P(unit,&remote_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modport_remote_map_set_dispatch[dtype](unit, port, flags, remote_modid, remote_port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modport_remote_map_set", 5, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_modport_set( \
    int unit, int modid, int port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_modport_set,
static int (*_stk_modport_set_dispatch[])(
    int unit, 
    int modid, 
    int port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_modport_set(
    int unit, 
    int modid, 
    int port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_modport_set_dispatch[dtype](unit, modid, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_modport_set", 3, 3, unit, modid, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_module_control_get( \
    int unit, uint32 flags, bcm_module_t module, bcm_stk_module_control_t control, int *arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_module_control_get,
static int (*_stk_module_control_get_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_module_t module, 
    bcm_stk_module_control_t control, 
    int *arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_module_control_get(
    int unit, 
    uint32 flags, 
    bcm_module_t module, 
    bcm_stk_module_control_t control, 
    int *arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_module_control_get_dispatch[dtype](unit, flags, module, control, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_module_control_get", 5, 3, unit, flags, module, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_module_control_set( \
    int unit, uint32 flags, bcm_module_t module, bcm_stk_module_control_t control, int arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_module_control_set,
static int (*_stk_module_control_set_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_module_t module, 
    bcm_stk_module_control_t control, 
    int arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_module_control_set(
    int unit, 
    uint32 flags, 
    bcm_module_t module, 
    bcm_stk_module_control_t control, 
    int arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_module_control_set_dispatch[dtype](unit, flags, module, control, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_module_control_set", 5, 3, unit, flags, module, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_module_enable( \
    int unit, bcm_module_t modid, int nports, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_module_enable,
static int (*_stk_module_enable_dispatch[])(
    int unit, 
    bcm_module_t modid, 
    int nports, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_module_enable(
    int unit, 
    bcm_module_t modid, 
    int nports, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_module_enable_dispatch[dtype](unit, modid, nports, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_module_enable", 4, 3, unit, modid, nports, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_module_max_get( \
    int unit, uint32 flags, bcm_module_t *max_module);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_module_max_get,
static int (*_stk_module_max_get_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_module_t *max_module) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_module_max_get(
    int unit, 
    uint32 flags, 
    bcm_module_t *max_module)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_module_max_get_dispatch[dtype](unit, flags, max_module);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_module_max_get", 3, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_module_max_set( \
    int unit, uint32 flags, bcm_module_t max_module);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_module_max_set,
static int (*_stk_module_max_set_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_module_t max_module) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_module_max_set(
    int unit, 
    uint32 flags, 
    bcm_module_t max_module)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_module_max_set_dispatch[dtype](unit, flags, max_module);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_module_max_set", 3, 3, unit, flags, max_module, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_module_protocol_get( \
    int unit, bcm_module_t modid, bcm_module_protocol_t *protocol);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_module_protocol_get,
static int (*_stk_module_protocol_get_dispatch[])(
    int unit, 
    bcm_module_t modid, 
    bcm_module_protocol_t *protocol) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_module_protocol_get(
    int unit, 
    bcm_module_t modid, 
    bcm_module_protocol_t *protocol)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_module_protocol_get_dispatch[dtype](unit, modid, protocol);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_module_protocol_get", 3, 2, unit, modid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_module_protocol_set( \
    int unit, bcm_module_t modid, bcm_module_protocol_t protocol);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_module_protocol_set,
static int (*_stk_module_protocol_set_dispatch[])(
    int unit, 
    bcm_module_t modid, 
    bcm_module_protocol_t protocol) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_module_protocol_set(
    int unit, 
    bcm_module_t modid, 
    bcm_module_protocol_t protocol)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_module_protocol_set_dispatch[dtype](unit, modid, protocol);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_module_protocol_set", 3, 3, unit, modid, protocol, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_my_modid_get( \
    int unit, int *my_modid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_my_modid_get,
static int (*_stk_my_modid_get_dispatch[])(
    int unit, 
    int *my_modid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_my_modid_get(
    int unit, 
    int *my_modid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_my_modid_get_dispatch[dtype](unit, my_modid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_my_modid_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_my_modid_set( \
    int unit, int my_modid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_my_modid_set,
static int (*_stk_my_modid_set_dispatch[])(
    int unit, 
    int my_modid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_my_modid_set(
    int unit, 
    int my_modid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_my_modid_set_dispatch[dtype](unit, my_modid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_my_modid_set", 2, 2, unit, my_modid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_pbmp_get( \
    int unit, bcm_pbmp_t *cur_pbm, bcm_pbmp_t *inactive_pbm);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_pbmp_get,
static int (*_stk_pbmp_get_dispatch[])(
    int unit, 
    bcm_pbmp_t *cur_pbm, 
    bcm_pbmp_t *inactive_pbm) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_pbmp_get(
    int unit, 
    bcm_pbmp_t *cur_pbm, 
    bcm_pbmp_t *inactive_pbm)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_pbmp_get_dispatch[dtype](unit, cur_pbm, inactive_pbm);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,cur_pbm);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,inactive_pbm);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_pbmp_get", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_port_get( \
    int unit, bcm_port_t port, uint32 *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_port_get,
static int (*_stk_port_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_port_get(
    int unit, 
    bcm_port_t port, 
    uint32 *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_port_get_dispatch[dtype](unit, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_port_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_port_modmap_group_get( \
    int unit, bcm_port_t port, int *group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_port_modmap_group_get,
static int (*_stk_port_modmap_group_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int *group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_port_modmap_group_get(
    int unit, 
    bcm_port_t port, 
    int *group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_port_modmap_group_get_dispatch[dtype](unit, port, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_port_modmap_group_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_port_modmap_group_max_get( \
    int unit, int *max_group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_port_modmap_group_max_get,
static int (*_stk_port_modmap_group_max_get_dispatch[])(
    int unit, 
    int *max_group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_port_modmap_group_max_get(
    int unit, 
    int *max_group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_port_modmap_group_max_get_dispatch[dtype](unit, max_group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_port_modmap_group_max_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_port_modmap_group_set( \
    int unit, bcm_port_t port, int group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_port_modmap_group_set,
static int (*_stk_port_modmap_group_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_port_modmap_group_set(
    int unit, 
    bcm_port_t port, 
    int group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_port_modmap_group_set_dispatch[dtype](unit, port, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_port_modmap_group_set", 3, 3, unit, port, group, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_port_modport_add( \
    int unit, bcm_port_t ing_port, bcm_module_t dest_modid, bcm_port_t dest_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_port_modport_add,
static int (*_stk_port_modport_add_dispatch[])(
    int unit, 
    bcm_port_t ing_port, 
    bcm_module_t dest_modid, 
    bcm_port_t dest_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_port_modport_add(
    int unit, 
    bcm_port_t ing_port, 
    bcm_module_t dest_modid, 
    bcm_port_t dest_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&ing_port);
		BCM_API_XLATE_PORT_A2P(unit,&dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_port_modport_add_dispatch[dtype](unit, ing_port, dest_modid, dest_port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_port_modport_add", 4, 3, unit, ing_port, dest_modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_port_modport_clear( \
    int unit, bcm_port_t ing_port, bcm_module_t dest_modid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_port_modport_clear,
static int (*_stk_port_modport_clear_dispatch[])(
    int unit, 
    bcm_port_t ing_port, 
    bcm_module_t dest_modid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_port_modport_clear(
    int unit, 
    bcm_port_t ing_port, 
    bcm_module_t dest_modid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&ing_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_port_modport_clear_dispatch[dtype](unit, ing_port, dest_modid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_port_modport_clear", 3, 3, unit, ing_port, dest_modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_port_modport_clear_all( \
    int unit, bcm_port_t ing_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_port_modport_clear_all,
static int (*_stk_port_modport_clear_all_dispatch[])(
    int unit, 
    bcm_port_t ing_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_port_modport_clear_all(
    int unit, 
    bcm_port_t ing_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&ing_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_port_modport_clear_all_dispatch[dtype](unit, ing_port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_port_modport_clear_all", 2, 2, unit, ing_port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_port_modport_delete( \
    int unit, bcm_port_t ing_port, bcm_module_t dest_modid, bcm_port_t dest_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_port_modport_delete,
static int (*_stk_port_modport_delete_dispatch[])(
    int unit, 
    bcm_port_t ing_port, 
    bcm_module_t dest_modid, 
    bcm_port_t dest_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_port_modport_delete(
    int unit, 
    bcm_port_t ing_port, 
    bcm_module_t dest_modid, 
    bcm_port_t dest_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&ing_port);
		BCM_API_XLATE_PORT_A2P(unit,&dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_port_modport_delete_dispatch[dtype](unit, ing_port, dest_modid, dest_port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_port_modport_delete", 4, 3, unit, ing_port, dest_modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_port_modport_get( \
    int unit, bcm_port_t ing_port, bcm_module_t dest_modid, bcm_port_t *dest_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_port_modport_get,
static int (*_stk_port_modport_get_dispatch[])(
    int unit, 
    bcm_port_t ing_port, 
    bcm_module_t dest_modid, 
    bcm_port_t *dest_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_port_modport_get(
    int unit, 
    bcm_port_t ing_port, 
    bcm_module_t dest_modid, 
    bcm_port_t *dest_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&ing_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_port_modport_get_dispatch[dtype](unit, ing_port, dest_modid, dest_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,dest_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_port_modport_get", 4, 3, unit, ing_port, dest_modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_port_modport_get_all( \
    int unit, bcm_port_t ing_port, bcm_module_t dest_modid, int dest_port_max, bcm_port_t *dest_port_array, int *dest_port_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_port_modport_get_all,
static int (*_stk_port_modport_get_all_dispatch[])(
    int unit, 
    bcm_port_t ing_port, 
    bcm_module_t dest_modid, 
    int dest_port_max, 
    bcm_port_t *dest_port_array, 
    int *dest_port_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_port_modport_get_all(
    int unit, 
    bcm_port_t ing_port, 
    bcm_module_t dest_modid, 
    int dest_port_max, 
    bcm_port_t *dest_port_array, 
    int *dest_port_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_A2P(unit,&ing_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_port_modport_get_all_dispatch[dtype](unit, ing_port, dest_modid, dest_port_max, dest_port_array, dest_port_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(dest_port_max,idx)
				BCM_API_XLATE_PORT_COND(dest_port_array) BCM_API_XLATE_PORT_P2A(unit,&(dest_port_array)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_port_modport_get_all", 6, 3, unit, ing_port, dest_modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_port_modport_set( \
    int unit, bcm_port_t ing_port, bcm_module_t dest_modid, bcm_port_t dest_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_port_modport_set,
static int (*_stk_port_modport_set_dispatch[])(
    int unit, 
    bcm_port_t ing_port, 
    bcm_module_t dest_modid, 
    bcm_port_t dest_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_port_modport_set(
    int unit, 
    bcm_port_t ing_port, 
    bcm_module_t dest_modid, 
    bcm_port_t dest_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&ing_port);
		BCM_API_XLATE_PORT_A2P(unit,&dest_port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_port_modport_set_dispatch[dtype](unit, ing_port, dest_modid, dest_port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_port_modport_set", 4, 3, unit, ing_port, dest_modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_port_set( \
    int unit, bcm_port_t port, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_port_set,
static int (*_stk_port_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_port_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_port_set_dispatch[dtype](unit, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_port_set", 3, 3, unit, port, flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_steering_clear( \
    int unit, int steer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_steering_clear,
static int (*_stk_steering_clear_dispatch[])(
    int unit, 
    int steer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_steering_clear(
    int unit, 
    int steer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_steering_clear_dispatch[dtype](unit, steer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_steering_clear", 2, 2, unit, steer_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_steering_clear_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_steering_clear_all,
static int (*_stk_steering_clear_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_steering_clear_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_steering_clear_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_steering_clear_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_steering_multicast_set( \
    int unit, int steer_id, bcm_multicast_t mgid_lo, bcm_multicast_t mgid_hi, int num_queue_groups, bcm_gport_t *queue_group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_steering_multicast_set,
static int (*_stk_steering_multicast_set_dispatch[])(
    int unit, 
    int steer_id, 
    bcm_multicast_t mgid_lo, 
    bcm_multicast_t mgid_hi, 
    int num_queue_groups, 
    bcm_gport_t *queue_group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_steering_multicast_set(
    int unit, 
    int steer_id, 
    bcm_multicast_t mgid_lo, 
    bcm_multicast_t mgid_hi, 
    int num_queue_groups, 
    bcm_gport_t *queue_group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_ITER(num_queue_groups,idx)
			BCM_API_XLATE_PORT_COND(queue_group) BCM_API_XLATE_PORT_A2P(unit,&(queue_group)[idx]);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_steering_multicast_set_dispatch[dtype](unit, steer_id, mgid_lo, mgid_hi, num_queue_groups, queue_group);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_ITER(num_queue_groups,idx)
			BCM_API_XLATE_PORT_COND(queue_group) BCM_API_XLATE_PORT_P2A(unit,&(queue_group)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_steering_multicast_set", 6, 3, unit, steer_id, mgid_lo, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_steering_unicast_set( \
    int unit, int steer_id, bcm_module_t destmod_lo, bcm_module_t destmod_hi, int num_queue_groups, bcm_gport_t *queue_group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_steering_unicast_set,
static int (*_stk_steering_unicast_set_dispatch[])(
    int unit, 
    int steer_id, 
    bcm_module_t destmod_lo, 
    bcm_module_t destmod_hi, 
    int num_queue_groups, 
    bcm_gport_t *queue_group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_steering_unicast_set(
    int unit, 
    int steer_id, 
    bcm_module_t destmod_lo, 
    bcm_module_t destmod_hi, 
    int num_queue_groups, 
    bcm_gport_t *queue_group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_ITER(num_queue_groups,idx)
			BCM_API_XLATE_PORT_COND(queue_group) BCM_API_XLATE_PORT_A2P(unit,&(queue_group)[idx]);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_steering_unicast_set_dispatch[dtype](unit, steer_id, destmod_lo, destmod_hi, num_queue_groups, queue_group);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_ITER(num_queue_groups,idx)
			BCM_API_XLATE_PORT_COND(queue_group) BCM_API_XLATE_PORT_P2A(unit,&(queue_group)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_steering_unicast_set", 6, 3, unit, steer_id, destmod_lo, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_sysport_gport_get( \
    int unit, bcm_gport_t sysport, bcm_gport_t *gport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_sysport_gport_get,
static int (*_stk_sysport_gport_get_dispatch[])(
    int unit, 
    bcm_gport_t sysport, 
    bcm_gport_t *gport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_sysport_gport_get(
    int unit, 
    bcm_gport_t sysport, 
    bcm_gport_t *gport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&sysport);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_sysport_gport_get_dispatch[dtype](unit, sysport, gport);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_sysport_gport_get", 3, 2, unit, sysport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_sysport_gport_set( \
    int unit, bcm_gport_t sysport, bcm_gport_t gport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_sysport_gport_set,
static int (*_stk_sysport_gport_set_dispatch[])(
    int unit, 
    bcm_gport_t sysport, 
    bcm_gport_t gport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_sysport_gport_set(
    int unit, 
    bcm_gport_t sysport, 
    bcm_gport_t gport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&sysport);
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_sysport_gport_set_dispatch[dtype](unit, sysport, gport);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_sysport_gport_set", 3, 3, unit, sysport, gport, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_system_gport_map_create( \
    int unit, bcm_stk_system_gport_map_t *sys_gport_map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_system_gport_map_create,
static int (*_stk_system_gport_map_create_dispatch[])(
    int unit, 
    bcm_stk_system_gport_map_t *sys_gport_map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_system_gport_map_create(
    int unit, 
    bcm_stk_system_gport_map_t *sys_gport_map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(sys_gport_map_dest_gport);
		BCM_API_XLATE_PORT_DECL(sys_gport_map_system_gport);
		BCM_API_XLATE_PORT_COND(sys_gport_map) BCM_API_XLATE_PORT_SAVE(sys_gport_map_dest_gport,sys_gport_map->dest_gport);
		BCM_API_XLATE_PORT_COND(sys_gport_map) BCM_API_XLATE_PORT_A2P(unit,&sys_gport_map->dest_gport);
		BCM_API_XLATE_PORT_COND(sys_gport_map) BCM_API_XLATE_PORT_SAVE(sys_gport_map_system_gport,sys_gport_map->system_gport);
		BCM_API_XLATE_PORT_COND(sys_gport_map) BCM_API_XLATE_PORT_A2P(unit,&sys_gport_map->system_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_system_gport_map_create_dispatch[dtype](unit, sys_gport_map);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(sys_gport_map) BCM_API_XLATE_PORT_RESTORE(sys_gport_map->dest_gport,sys_gport_map_dest_gport);
		BCM_API_XLATE_PORT_COND(sys_gport_map) BCM_API_XLATE_PORT_RESTORE(sys_gport_map->system_gport,sys_gport_map_system_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_system_gport_map_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_system_gport_map_destroy( \
    int unit, bcm_gport_t system_gport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_system_gport_map_destroy,
static int (*_stk_system_gport_map_destroy_dispatch[])(
    int unit, 
    bcm_gport_t system_gport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_system_gport_map_destroy(
    int unit, 
    bcm_gport_t system_gport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&system_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_system_gport_map_destroy_dispatch[dtype](unit, system_gport);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_system_gport_map_destroy", 2, 2, unit, system_gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_system_gport_map_get( \
    int unit, bcm_stk_system_gport_map_t *sys_gport_map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_system_gport_map_get,
static int (*_stk_system_gport_map_get_dispatch[])(
    int unit, 
    bcm_stk_system_gport_map_t *sys_gport_map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_system_gport_map_get(
    int unit, 
    bcm_stk_system_gport_map_t *sys_gport_map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(sys_gport_map) BCM_API_XLATE_PORT_A2P(unit,&sys_gport_map->dest_gport);
		BCM_API_XLATE_PORT_COND(sys_gport_map) BCM_API_XLATE_PORT_A2P(unit,&sys_gport_map->system_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_system_gport_map_get_dispatch[dtype](unit, sys_gport_map);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(sys_gport_map) BCM_API_XLATE_PORT_P2A(unit,&sys_gport_map->dest_gport);
		BCM_API_XLATE_PORT_COND(sys_gport_map) BCM_API_XLATE_PORT_P2A(unit,&sys_gport_map->system_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_system_gport_map_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_ucbitmap_del( \
    int unit, bcm_port_t port, int modid, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_ucbitmap_del,
static int (*_stk_ucbitmap_del_dispatch[])(
    int unit, 
    bcm_port_t port, 
    int modid, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_ucbitmap_del(
    int unit, 
    bcm_port_t port, 
    int modid, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_ucbitmap_del_dispatch[dtype](unit, port, modid, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_ucbitmap_del", 4, 3, unit, port, modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_ucbitmap_get( \
    int unit, int port, int modid, bcm_pbmp_t *pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_ucbitmap_get,
static int (*_stk_ucbitmap_get_dispatch[])(
    int unit, 
    int port, 
    int modid, 
    bcm_pbmp_t *pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_ucbitmap_get(
    int unit, 
    int port, 
    int modid, 
    bcm_pbmp_t *pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_ucbitmap_get_dispatch[dtype](unit, port, modid, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_ucbitmap_get", 4, 3, unit, port, modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_ucbitmap_set( \
    int unit, int port, int modid, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_ucbitmap_set,
static int (*_stk_ucbitmap_set_dispatch[])(
    int unit, 
    int port, 
    int modid, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_ucbitmap_set(
    int unit, 
    int port, 
    int modid, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_A2P(unit,&port);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_ucbitmap_set_dispatch[dtype](unit, port, modid, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_ucbitmap_set", 4, 3, unit, port, modid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_update_callback_register( \
    int unit, bcm_stk_cb_f cb, void *cookie);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_update_callback_register,
static int (*_stk_update_callback_register_dispatch[])(
    int unit, 
    bcm_stk_cb_f cb, 
    void *cookie) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_update_callback_register(
    int unit, 
    bcm_stk_cb_f cb, 
    void *cookie)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_update_callback_register_dispatch[dtype](unit, cb, cookie);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_update_callback_register", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_stk_update_callback_unregister( \
    int unit, bcm_stk_cb_f cb, void *cookie);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_stk_update_callback_unregister,
static int (*_stk_update_callback_unregister_dispatch[])(
    int unit, 
    bcm_stk_cb_f cb, 
    void *cookie) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_stk_update_callback_unregister(
    int unit, 
    bcm_stk_cb_f cb, 
    void *cookie)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _stk_update_callback_unregister_dispatch[dtype](unit, cb, cookie);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_stk_update_callback_unregister", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_subport_cleanup( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_subport_cleanup,
static int (*_subport_cleanup_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_subport_cleanup(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _subport_cleanup_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_subport_cleanup", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_subport_group_create( \
    int unit, bcm_subport_group_config_t *config, bcm_gport_t *group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_subport_group_create,
static int (*_subport_group_create_dispatch[])(
    int unit, 
    bcm_subport_group_config_t *config, 
    bcm_gport_t *group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_subport_group_create(
    int unit, 
    bcm_subport_group_config_t *config, 
    bcm_gport_t *group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(config_port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_SAVE(config_port,config->port);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_A2P(unit,&config->port);
		BCM_API_XLATE_PORT_A2P(unit,group);
		dtype = BCM_DTYPE(unit);
		r_rv = _subport_group_create_dispatch[dtype](unit, config, group);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_RESTORE(config->port,config_port);
		BCM_API_XLATE_PORT_P2A(unit,group);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_subport_group_create", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_subport_group_destroy( \
    int unit, bcm_gport_t group);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_subport_group_destroy,
static int (*_subport_group_destroy_dispatch[])(
    int unit, 
    bcm_gport_t group) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_subport_group_destroy(
    int unit, 
    bcm_gport_t group)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&group);
		dtype = BCM_DTYPE(unit);
		r_rv = _subport_group_destroy_dispatch[dtype](unit, group);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_subport_group_destroy", 2, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_subport_group_get( \
    int unit, bcm_gport_t group, bcm_subport_group_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_subport_group_get,
static int (*_subport_group_get_dispatch[])(
    int unit, 
    bcm_gport_t group, 
    bcm_subport_group_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_subport_group_get(
    int unit, 
    bcm_gport_t group, 
    bcm_subport_group_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&group);
		dtype = BCM_DTYPE(unit);
		r_rv = _subport_group_get_dispatch[dtype](unit, group, config);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_P2A(unit,&config->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_subport_group_get", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_subport_group_linkphy_config_get( \
    int unit, bcm_gport_t port, bcm_subport_group_linkphy_config_t *linkphy_config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_subport_group_linkphy_config_get,
static int (*_subport_group_linkphy_config_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_subport_group_linkphy_config_t *linkphy_config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_subport_group_linkphy_config_get(
    int unit, 
    bcm_gport_t port, 
    bcm_subport_group_linkphy_config_t *linkphy_config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _subport_group_linkphy_config_get_dispatch[dtype](unit, port, linkphy_config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_subport_group_linkphy_config_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_subport_group_linkphy_config_set( \
    int unit, bcm_gport_t port, bcm_subport_group_linkphy_config_t *linkphy_config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_subport_group_linkphy_config_set,
static int (*_subport_group_linkphy_config_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_subport_group_linkphy_config_t *linkphy_config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_subport_group_linkphy_config_set(
    int unit, 
    bcm_gport_t port, 
    bcm_subport_group_linkphy_config_t *linkphy_config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _subport_group_linkphy_config_set_dispatch[dtype](unit, port, linkphy_config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_subport_group_linkphy_config_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_subport_group_traverse( \
    int unit, bcm_gport_t subport_group, bcm_subport_port_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_subport_group_traverse,
static int (*_subport_group_traverse_dispatch[])(
    int unit, 
    bcm_gport_t subport_group, 
    bcm_subport_port_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_subport_group_traverse(
    int unit, 
    bcm_gport_t subport_group, 
    bcm_subport_port_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&subport_group);
		dtype = BCM_DTYPE(unit);
		r_rv = _subport_group_traverse_dispatch[dtype](unit, subport_group, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_subport_group_traverse", 4, 2, unit, subport_group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_subport_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_subport_init,
static int (*_subport_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_subport_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _subport_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_subport_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_subport_port_add( \
    int unit, bcm_subport_config_t *config, bcm_gport_t *port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_subport_port_add,
static int (*_subport_port_add_dispatch[])(
    int unit, 
    bcm_subport_config_t *config, 
    bcm_gport_t *port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_subport_port_add(
    int unit, 
    bcm_subport_config_t *config, 
    bcm_gport_t *port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(config_group);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_SAVE(config_group,config->group);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_A2P(unit,&config->group);
		dtype = BCM_DTYPE(unit);
		r_rv = _subport_port_add_dispatch[dtype](unit, config, port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_RESTORE(config->group,config_group);
		BCM_API_XLATE_PORT_P2A(unit,port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_subport_port_add", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_subport_port_delete( \
    int unit, bcm_gport_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_subport_port_delete,
static int (*_subport_port_delete_dispatch[])(
    int unit, 
    bcm_gport_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_subport_port_delete(
    int unit, 
    bcm_gport_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _subport_port_delete_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_subport_port_delete", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_subport_port_get( \
    int unit, bcm_gport_t port, bcm_subport_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_subport_port_get,
static int (*_subport_port_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_subport_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_subport_port_get(
    int unit, 
    bcm_gport_t port, 
    bcm_subport_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _subport_port_get_dispatch[dtype](unit, port, config);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(config) BCM_API_XLATE_PORT_P2A(unit,&config->group);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_subport_port_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_subport_port_stat_get( \
    int unit, bcm_gport_t port, int stream_id, bcm_subport_stat_t stat_type, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_subport_port_stat_get,
static int (*_subport_port_stat_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int stream_id, 
    bcm_subport_stat_t stat_type, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_subport_port_stat_get(
    int unit, 
    bcm_gport_t port, 
    int stream_id, 
    bcm_subport_stat_t stat_type, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _subport_port_stat_get_dispatch[dtype](unit, port, stream_id, stat_type, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_subport_port_stat_get", 5, 3, unit, port, stream_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_subport_port_stat_set( \
    int unit, bcm_gport_t port, int stream_id, bcm_subport_stat_t stat_type, uint64 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_subport_port_stat_set,
static int (*_subport_port_stat_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    int stream_id, 
    bcm_subport_stat_t stat_type, 
    uint64 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_subport_port_stat_set(
    int unit, 
    bcm_gport_t port, 
    int stream_id, 
    bcm_subport_stat_t stat_type, 
    uint64 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _subport_port_stat_set_dispatch[dtype](unit, port, stream_id, stat_type, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_subport_port_stat_set", 5, 3, unit, port, stream_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_subport_port_traverse( \
    int unit, bcm_subport_port_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_subport_port_traverse,
static int (*_subport_port_traverse_dispatch[])(
    int unit, 
    bcm_subport_port_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_subport_port_traverse(
    int unit, 
    bcm_subport_port_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _subport_port_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_subport_port_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_control_get( \
    int unit, bcm_switch_control_t type, int *arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_control_get,
static int (*_switch_control_get_dispatch[])(
    int unit, 
    bcm_switch_control_t type, 
    int *arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_control_get(
    int unit, 
    bcm_switch_control_t type, 
    int *arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_control_get_dispatch[dtype](unit, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_control_get", 3, 2, unit, type, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_control_port_get( \
    int unit, bcm_port_t port, bcm_switch_control_t type, int *arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_control_port_get,
static int (*_switch_control_port_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_switch_control_t type, 
    int *arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_control_port_get(
    int unit, 
    bcm_port_t port, 
    bcm_switch_control_t type, 
    int *arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_control_port_get_dispatch[dtype](unit, port, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_control_port_get", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_control_port_set( \
    int unit, bcm_port_t port, bcm_switch_control_t type, int arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_control_port_set,
static int (*_switch_control_port_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_switch_control_t type, 
    int arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_control_port_set(
    int unit, 
    bcm_port_t port, 
    bcm_switch_control_t type, 
    int arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_control_port_set_dispatch[dtype](unit, port, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_control_port_set", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_control_set( \
    int unit, bcm_switch_control_t type, int arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_control_set,
static int (*_switch_control_set_dispatch[])(
    int unit, 
    bcm_switch_control_t type, 
    int arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_control_set(
    int unit, 
    bcm_switch_control_t type, 
    int arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_control_set_dispatch[dtype](unit, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_control_set", 3, 3, unit, type, arg, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_event_control_get( \
    int unit, bcm_switch_event_t event, bcm_switch_event_control_t type, uint32 *value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_event_control_get,
static int (*_switch_event_control_get_dispatch[])(
    int unit, 
    bcm_switch_event_t event, 
    bcm_switch_event_control_t type, 
    uint32 *value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_event_control_get(
    int unit, 
    bcm_switch_event_t event, 
    bcm_switch_event_control_t type, 
    uint32 *value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_event_control_get_dispatch[dtype](unit, event, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_event_control_get", 4, 2, unit, event, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_event_control_set( \
    int unit, bcm_switch_event_t event, bcm_switch_event_control_t type, uint32 value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_event_control_set,
static int (*_switch_event_control_set_dispatch[])(
    int unit, 
    bcm_switch_event_t event, 
    bcm_switch_event_control_t type, 
    uint32 value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_event_control_set(
    int unit, 
    bcm_switch_event_t event, 
    bcm_switch_event_control_t type, 
    uint32 value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_event_control_set_dispatch[dtype](unit, event, type, value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_event_control_set", 4, 2, unit, event, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_event_register( \
    int unit, bcm_switch_event_cb_t cb, void *userdata);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_event_register,
static int (*_switch_event_register_dispatch[])(
    int unit, 
    bcm_switch_event_cb_t cb, 
    void *userdata) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_event_register(
    int unit, 
    bcm_switch_event_cb_t cb, 
    void *userdata)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_event_register_dispatch[dtype](unit, cb, userdata);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_event_register", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_event_unregister( \
    int unit, bcm_switch_event_cb_t cb, void *userdata);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_event_unregister,
static int (*_switch_event_unregister_dispatch[])(
    int unit, 
    bcm_switch_event_cb_t cb, 
    void *userdata) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_event_unregister(
    int unit, 
    bcm_switch_event_cb_t cb, 
    void *userdata)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_event_unregister_dispatch[dtype](unit, cb, userdata);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_event_unregister", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_hash_banks_config_get( \
    int unit, bcm_switch_hash_table_t hash_table, uint32 bank_num, int *hash_type, uint32 *hash_offset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_hash_banks_config_get,
static int (*_switch_hash_banks_config_get_dispatch[])(
    int unit, 
    bcm_switch_hash_table_t hash_table, 
    uint32 bank_num, 
    int *hash_type, 
    uint32 *hash_offset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_hash_banks_config_get(
    int unit, 
    bcm_switch_hash_table_t hash_table, 
    uint32 bank_num, 
    int *hash_type, 
    uint32 *hash_offset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_hash_banks_config_get_dispatch[dtype](unit, hash_table, bank_num, hash_type, hash_offset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_hash_banks_config_get", 5, 3, unit, hash_table, bank_num, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_hash_banks_config_set( \
    int unit, bcm_switch_hash_table_t hash_table, uint32 bank_num, int hash_type, uint32 hash_offset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_hash_banks_config_set,
static int (*_switch_hash_banks_config_set_dispatch[])(
    int unit, 
    bcm_switch_hash_table_t hash_table, 
    uint32 bank_num, 
    int hash_type, 
    uint32 hash_offset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_hash_banks_config_set(
    int unit, 
    bcm_switch_hash_table_t hash_table, 
    uint32 bank_num, 
    int hash_type, 
    uint32 hash_offset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_hash_banks_config_set_dispatch[dtype](unit, hash_table, bank_num, hash_type, hash_offset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_hash_banks_config_set", 5, 3, unit, hash_table, bank_num, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_hash_banks_max_get( \
    int unit, bcm_switch_hash_table_t hash_table, uint32 *bank_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_hash_banks_max_get,
static int (*_switch_hash_banks_max_get_dispatch[])(
    int unit, 
    bcm_switch_hash_table_t hash_table, 
    uint32 *bank_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_hash_banks_max_get(
    int unit, 
    bcm_switch_hash_table_t hash_table, 
    uint32 *bank_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_hash_banks_max_get_dispatch[dtype](unit, hash_table, bank_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_hash_banks_max_get", 3, 2, unit, hash_table, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_hash_entry_create( \
    int unit, bcm_field_group_t group, bcm_hash_entry_t *entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_hash_entry_create,
static int (*_switch_hash_entry_create_dispatch[])(
    int unit, 
    bcm_field_group_t group, 
    bcm_hash_entry_t *entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_hash_entry_create(
    int unit, 
    bcm_field_group_t group, 
    bcm_hash_entry_t *entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_hash_entry_create_dispatch[dtype](unit, group, entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_hash_entry_create", 3, 2, unit, group, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_hash_entry_create_qset( \
    int unit, bcm_field_qset_t qset, bcm_hash_entry_t *entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_hash_entry_create_qset,
static int (*_switch_hash_entry_create_qset_dispatch[])(
    int unit, 
    bcm_field_qset_t qset, 
    bcm_hash_entry_t *entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_hash_entry_create_qset(
    int unit, 
    bcm_field_qset_t qset, 
    bcm_hash_entry_t *entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_hash_entry_create_qset_dispatch[dtype](unit, qset, entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_hash_entry_create_qset", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_hash_entry_destroy( \
    int unit, bcm_hash_entry_t entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_hash_entry_destroy,
static int (*_switch_hash_entry_destroy_dispatch[])(
    int unit, 
    bcm_hash_entry_t entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_hash_entry_destroy(
    int unit, 
    bcm_hash_entry_t entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_hash_entry_destroy_dispatch[dtype](unit, entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_hash_entry_destroy", 2, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_hash_entry_install( \
    int unit, bcm_hash_entry_t entry, uint32 offset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_hash_entry_install,
static int (*_switch_hash_entry_install_dispatch[])(
    int unit, 
    bcm_hash_entry_t entry, 
    uint32 offset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_hash_entry_install(
    int unit, 
    bcm_hash_entry_t entry, 
    uint32 offset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_hash_entry_install_dispatch[dtype](unit, entry, offset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_hash_entry_install", 3, 3, unit, entry, offset, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_hash_entry_reinstall( \
    int unit, bcm_hash_entry_t entry, uint32 offset);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_hash_entry_reinstall,
static int (*_switch_hash_entry_reinstall_dispatch[])(
    int unit, 
    bcm_hash_entry_t entry, 
    uint32 offset) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_hash_entry_reinstall(
    int unit, 
    bcm_hash_entry_t entry, 
    uint32 offset)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_hash_entry_reinstall_dispatch[dtype](unit, entry, offset);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_hash_entry_reinstall", 3, 3, unit, entry, offset, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_hash_entry_remove( \
    int unit, bcm_hash_entry_t entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_hash_entry_remove,
static int (*_switch_hash_entry_remove_dispatch[])(
    int unit, 
    bcm_hash_entry_t entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_hash_entry_remove(
    int unit, 
    bcm_hash_entry_t entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_hash_entry_remove_dispatch[dtype](unit, entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_hash_entry_remove", 2, 2, unit, entry, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_hash_qualify_data( \
    int unit, bcm_hash_entry_t entry, int qual_id, uint32 data, uint32 mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_hash_qualify_data,
static int (*_switch_hash_qualify_data_dispatch[])(
    int unit, 
    bcm_hash_entry_t entry, 
    int qual_id, 
    uint32 data, 
    uint32 mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_hash_qualify_data(
    int unit, 
    bcm_hash_entry_t entry, 
    int qual_id, 
    uint32 data, 
    uint32 mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_hash_qualify_data_dispatch[dtype](unit, entry, qual_id, data, mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_hash_qualify_data", 5, 3, unit, entry, qual_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_ipv6_reserved_multicast_addr_get( \
    int unit, bcm_ip6_t *ip6_addr, bcm_ip6_t *ip6_mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_ipv6_reserved_multicast_addr_get,
static int (*_switch_ipv6_reserved_multicast_addr_get_dispatch[])(
    int unit, 
    bcm_ip6_t *ip6_addr, 
    bcm_ip6_t *ip6_mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_ipv6_reserved_multicast_addr_get(
    int unit, 
    bcm_ip6_t *ip6_addr, 
    bcm_ip6_t *ip6_mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_ipv6_reserved_multicast_addr_get_dispatch[dtype](unit, ip6_addr, ip6_mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_ipv6_reserved_multicast_addr_get", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_ipv6_reserved_multicast_addr_set( \
    int unit, bcm_ip6_t ip6_addr, bcm_ip6_t ip6_mask);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_ipv6_reserved_multicast_addr_set,
static int (*_switch_ipv6_reserved_multicast_addr_set_dispatch[])(
    int unit, 
    bcm_ip6_t ip6_addr, 
    bcm_ip6_t ip6_mask) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_ipv6_reserved_multicast_addr_set(
    int unit, 
    bcm_ip6_t ip6_addr, 
    bcm_ip6_t ip6_mask)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_ipv6_reserved_multicast_addr_set_dispatch[dtype](unit, ip6_addr, ip6_mask);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_ipv6_reserved_multicast_addr_set", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_l3_protocol_group_get( \
    int unit, uint32 *group_members, bcm_l3_protocol_group_id_t *group_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_l3_protocol_group_get,
static int (*_switch_l3_protocol_group_get_dispatch[])(
    int unit, 
    uint32 *group_members, 
    bcm_l3_protocol_group_id_t *group_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_l3_protocol_group_get(
    int unit, 
    uint32 *group_members, 
    bcm_l3_protocol_group_id_t *group_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_l3_protocol_group_get_dispatch[dtype](unit, group_members, group_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_l3_protocol_group_get", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_l3_protocol_group_set( \
    int unit, uint32 group_members, bcm_l3_protocol_group_id_t group_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_l3_protocol_group_set,
static int (*_switch_l3_protocol_group_set_dispatch[])(
    int unit, 
    uint32 group_members, 
    bcm_l3_protocol_group_id_t group_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_l3_protocol_group_set(
    int unit, 
    uint32 group_members, 
    bcm_l3_protocol_group_id_t group_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_l3_protocol_group_set_dispatch[dtype](unit, group_members, group_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_l3_protocol_group_set", 3, 3, unit, group_members, group_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_network_group_config_get( \
    int unit, bcm_switch_network_group_t source_network_group_id, bcm_switch_network_group_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_network_group_config_get,
static int (*_switch_network_group_config_get_dispatch[])(
    int unit, 
    bcm_switch_network_group_t source_network_group_id, 
    bcm_switch_network_group_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_network_group_config_get(
    int unit, 
    bcm_switch_network_group_t source_network_group_id, 
    bcm_switch_network_group_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_network_group_config_get_dispatch[dtype](unit, source_network_group_id, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_network_group_config_get", 3, 2, unit, source_network_group_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_network_group_config_set( \
    int unit, bcm_switch_network_group_t source_network_group_id, bcm_switch_network_group_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_network_group_config_set,
static int (*_switch_network_group_config_set_dispatch[])(
    int unit, 
    bcm_switch_network_group_t source_network_group_id, 
    bcm_switch_network_group_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_network_group_config_set(
    int unit, 
    bcm_switch_network_group_t source_network_group_id, 
    bcm_switch_network_group_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_network_group_config_set_dispatch[dtype](unit, source_network_group_id, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_network_group_config_set", 3, 2, unit, source_network_group_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_object_count_get( \
    int unit, bcm_switch_object_t object, int *entries);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_object_count_get,
static int (*_switch_object_count_get_dispatch[])(
    int unit, 
    bcm_switch_object_t object, 
    int *entries) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_object_count_get(
    int unit, 
    bcm_switch_object_t object, 
    int *entries)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_object_count_get_dispatch[dtype](unit, object, entries);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_object_count_get", 3, 2, unit, object, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_object_count_multi_get( \
    int unit, int object_size, bcm_switch_object_t *object_array, int *entries);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_object_count_multi_get,
static int (*_switch_object_count_multi_get_dispatch[])(
    int unit, 
    int object_size, 
    bcm_switch_object_t *object_array, 
    int *entries) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_object_count_multi_get(
    int unit, 
    int object_size, 
    bcm_switch_object_t *object_array, 
    int *entries)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_object_count_multi_get_dispatch[dtype](unit, object_size, object_array, entries);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_object_count_multi_get", 4, 2, unit, object_size, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_pkt_info_hash_get( \
    int unit, bcm_switch_pkt_info_t *pkt_info, bcm_gport_t *dst_gport, bcm_if_t *dst_intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_pkt_info_hash_get,
static int (*_switch_pkt_info_hash_get_dispatch[])(
    int unit, 
    bcm_switch_pkt_info_t *pkt_info, 
    bcm_gport_t *dst_gport, 
    bcm_if_t *dst_intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_pkt_info_hash_get(
    int unit, 
    bcm_switch_pkt_info_t *pkt_info, 
    bcm_gport_t *dst_gport, 
    bcm_if_t *dst_intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(pkt_info_src_gport);
		BCM_API_XLATE_PORT_DECL(pkt_info_trunk_gport);
		BCM_API_XLATE_PORT_COND(pkt_info) BCM_API_XLATE_PORT_SAVE(pkt_info_src_gport,pkt_info->src_gport);
		BCM_API_XLATE_PORT_COND(pkt_info) BCM_API_XLATE_PORT_A2P(unit,&pkt_info->src_gport);
		BCM_API_XLATE_PORT_COND(pkt_info) BCM_API_XLATE_PORT_SAVE(pkt_info_trunk_gport,pkt_info->trunk_gport);
		BCM_API_XLATE_PORT_COND(pkt_info) BCM_API_XLATE_PORT_A2P(unit,&pkt_info->trunk_gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_pkt_info_hash_get_dispatch[dtype](unit, pkt_info, dst_gport, dst_intf);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(pkt_info) BCM_API_XLATE_PORT_RESTORE(pkt_info->src_gport,pkt_info_src_gport);
		BCM_API_XLATE_PORT_COND(pkt_info) BCM_API_XLATE_PORT_RESTORE(pkt_info->trunk_gport,pkt_info_trunk_gport);
		BCM_API_XLATE_PORT_P2A(unit,dst_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_pkt_info_hash_get", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_rcpu_decap_priority_map_get( \
    int unit, int decap_pri, int *internal_cpu_pri);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_rcpu_decap_priority_map_get,
static int (*_switch_rcpu_decap_priority_map_get_dispatch[])(
    int unit, 
    int decap_pri, 
    int *internal_cpu_pri) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_rcpu_decap_priority_map_get(
    int unit, 
    int decap_pri, 
    int *internal_cpu_pri)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_rcpu_decap_priority_map_get_dispatch[dtype](unit, decap_pri, internal_cpu_pri);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_rcpu_decap_priority_map_get", 3, 2, unit, decap_pri, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_rcpu_decap_priority_map_set( \
    int unit, int decap_pri, int internal_cpu_pri);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_rcpu_decap_priority_map_set,
static int (*_switch_rcpu_decap_priority_map_set_dispatch[])(
    int unit, 
    int decap_pri, 
    int internal_cpu_pri) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_rcpu_decap_priority_map_set(
    int unit, 
    int decap_pri, 
    int internal_cpu_pri)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_rcpu_decap_priority_map_set_dispatch[dtype](unit, decap_pri, internal_cpu_pri);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_rcpu_decap_priority_map_set", 3, 3, unit, decap_pri, internal_cpu_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_rcpu_encap_priority_map_get( \
    int unit, uint32 flags, int internal_cpu_pri, int *encap_pri);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_rcpu_encap_priority_map_get,
static int (*_switch_rcpu_encap_priority_map_get_dispatch[])(
    int unit, 
    uint32 flags, 
    int internal_cpu_pri, 
    int *encap_pri) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_rcpu_encap_priority_map_get(
    int unit, 
    uint32 flags, 
    int internal_cpu_pri, 
    int *encap_pri)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_rcpu_encap_priority_map_get_dispatch[dtype](unit, flags, internal_cpu_pri, encap_pri);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_rcpu_encap_priority_map_get", 4, 3, unit, flags, internal_cpu_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_rcpu_encap_priority_map_set( \
    int unit, uint32 flags, int internal_cpu_pri, int encap_pri);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_rcpu_encap_priority_map_set,
static int (*_switch_rcpu_encap_priority_map_set_dispatch[])(
    int unit, 
    uint32 flags, 
    int internal_cpu_pri, 
    int encap_pri) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_rcpu_encap_priority_map_set(
    int unit, 
    uint32 flags, 
    int internal_cpu_pri, 
    int encap_pri)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_rcpu_encap_priority_map_set_dispatch[dtype](unit, flags, internal_cpu_pri, encap_pri);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_rcpu_encap_priority_map_set", 4, 3, unit, flags, internal_cpu_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_service_get( \
    int unit, bcm_switch_service_t service, bcm_switch_service_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_service_get,
static int (*_switch_service_get_dispatch[])(
    int unit, 
    bcm_switch_service_t service, 
    bcm_switch_service_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_service_get(
    int unit, 
    bcm_switch_service_t service, 
    bcm_switch_service_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_service_get_dispatch[dtype](unit, service, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_service_get", 3, 2, unit, service, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_service_set( \
    int unit, bcm_switch_service_t service, bcm_switch_service_config_t *config);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_service_set,
static int (*_switch_service_set_dispatch[])(
    int unit, 
    bcm_switch_service_t service, 
    bcm_switch_service_config_t *config) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_service_set(
    int unit, 
    bcm_switch_service_t service, 
    bcm_switch_service_config_t *config)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_service_set_dispatch[dtype](unit, service, config);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_service_set", 3, 2, unit, service, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_stable_register( \
    int unit, bcm_switch_read_func_t rf, bcm_switch_write_func_t wf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_stable_register,
static int (*_switch_stable_register_dispatch[])(
    int unit, 
    bcm_switch_read_func_t rf, 
    bcm_switch_write_func_t wf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_stable_register(
    int unit, 
    bcm_switch_read_func_t rf, 
    bcm_switch_write_func_t wf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_stable_register_dispatch[dtype](unit, rf, wf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_stable_register", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_temperature_monitor_get( \
    int unit, int temperature_max, bcm_switch_temperature_monitor_t *temperature_array, int *temperature_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_temperature_monitor_get,
static int (*_switch_temperature_monitor_get_dispatch[])(
    int unit, 
    int temperature_max, 
    bcm_switch_temperature_monitor_t *temperature_array, 
    int *temperature_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_temperature_monitor_get(
    int unit, 
    int temperature_max, 
    bcm_switch_temperature_monitor_t *temperature_array, 
    int *temperature_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_temperature_monitor_get_dispatch[dtype](unit, temperature_max, temperature_array, temperature_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_temperature_monitor_get", 4, 2, unit, temperature_max, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_user_buffer_read( \
    int unit, uint32 flags, bcm_switch_user_buffer_type_t buff_type, uint8 *buf, int offset, int nbytes);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_user_buffer_read,
static int (*_switch_user_buffer_read_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_switch_user_buffer_type_t buff_type, 
    uint8 *buf, 
    int offset, 
    int nbytes) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_user_buffer_read(
    int unit, 
    uint32 flags, 
    bcm_switch_user_buffer_type_t buff_type, 
    uint8 *buf, 
    int offset, 
    int nbytes)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_user_buffer_read_dispatch[dtype](unit, flags, buff_type, buf, offset, nbytes);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_user_buffer_read", 6, 3, unit, flags, buff_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_switch_user_buffer_write( \
    int unit, uint32 flags, bcm_switch_user_buffer_type_t buff_type, uint8 *buf, int offset, int nbytes);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_switch_user_buffer_write,
static int (*_switch_user_buffer_write_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_switch_user_buffer_type_t buff_type, 
    uint8 *buf, 
    int offset, 
    int nbytes) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_switch_user_buffer_write(
    int unit, 
    uint32 flags, 
    bcm_switch_user_buffer_type_t buff_type, 
    uint8 *buf, 
    int offset, 
    int nbytes)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _switch_user_buffer_write_dispatch[dtype](unit, flags, buff_type, buf, offset, nbytes);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_switch_user_buffer_write", 6, 3, unit, flags, buff_type, r_rv);
	return r_rv;
}

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_dpll_bandwidth_get( \
    int unit, int stack_id, int dpll_index, bcm_tdpll_dpll_bandwidth_t *bandwidth);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_dpll_bandwidth_get,
static int (*_tdpll_dpll_bandwidth_get_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_bandwidth_t *bandwidth) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_dpll_bandwidth_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_bandwidth_t *bandwidth)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_dpll_bandwidth_get_dispatch[dtype](unit, stack_id, dpll_index, bandwidth);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_dpll_bandwidth_get", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_dpll_bandwidth_set( \
    int unit, int stack_id, int dpll_index, bcm_tdpll_dpll_bandwidth_t *bandwidth);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_dpll_bandwidth_set,
static int (*_tdpll_dpll_bandwidth_set_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_bandwidth_t *bandwidth) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_dpll_bandwidth_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_bandwidth_t *bandwidth)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_dpll_bandwidth_set_dispatch[dtype](unit, stack_id, dpll_index, bandwidth);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_dpll_bandwidth_set", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_dpll_bindings_get( \
    int unit, int stack_id, int dpll_index, bcm_tdpll_dpll_bindings_t *bindings);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_dpll_bindings_get,
static int (*_tdpll_dpll_bindings_get_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_bindings_t *bindings) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_dpll_bindings_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_bindings_t *bindings)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_dpll_bindings_get_dispatch[dtype](unit, stack_id, dpll_index, bindings);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_dpll_bindings_get", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_dpll_bindings_set( \
    int unit, int stack_id, int dpll_index, bcm_tdpll_dpll_bindings_t *bindings);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_dpll_bindings_set,
static int (*_tdpll_dpll_bindings_set_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_bindings_t *bindings) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_dpll_bindings_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_bindings_t *bindings)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_dpll_bindings_set_dispatch[dtype](unit, stack_id, dpll_index, bindings);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_dpll_bindings_set", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_dpll_phase_control_get( \
    int unit, int stack_id, int dpll_index, bcm_tdpll_dpll_phase_control_t *phase_control);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_dpll_phase_control_get,
static int (*_tdpll_dpll_phase_control_get_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_phase_control_t *phase_control) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_dpll_phase_control_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_phase_control_t *phase_control)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_dpll_phase_control_get_dispatch[dtype](unit, stack_id, dpll_index, phase_control);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_dpll_phase_control_get", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_dpll_phase_control_set( \
    int unit, int stack_id, int dpll_index, bcm_tdpll_dpll_phase_control_t *phase_control);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_dpll_phase_control_set,
static int (*_tdpll_dpll_phase_control_set_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_phase_control_t *phase_control) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_dpll_phase_control_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_phase_control_t *phase_control)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_dpll_phase_control_set_dispatch[dtype](unit, stack_id, dpll_index, phase_control);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_dpll_phase_control_set", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_dpll_reference_get( \
    int unit, int stack_id, int max_num_dpll, int *dpll_ref, int *num_dpll);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_dpll_reference_get,
static int (*_tdpll_dpll_reference_get_dispatch[])(
    int unit, 
    int stack_id, 
    int max_num_dpll, 
    int *dpll_ref, 
    int *num_dpll) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_dpll_reference_get(
    int unit, 
    int stack_id, 
    int max_num_dpll, 
    int *dpll_ref, 
    int *num_dpll)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_dpll_reference_get_dispatch[dtype](unit, stack_id, max_num_dpll, dpll_ref, num_dpll);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_dpll_reference_get", 5, 3, unit, stack_id, max_num_dpll, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_esmc_holdover_ql_get( \
    int unit, int stack_id, int dpll_index, bcm_esmc_quality_level_t *ql);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_esmc_holdover_ql_get,
static int (*_tdpll_esmc_holdover_ql_get_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_esmc_quality_level_t *ql) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_esmc_holdover_ql_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_esmc_quality_level_t *ql)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_esmc_holdover_ql_get_dispatch[dtype](unit, stack_id, dpll_index, ql);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_esmc_holdover_ql_get", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_esmc_holdover_ql_set( \
    int unit, int stack_id, int dpll_index, bcm_esmc_quality_level_t ql);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_esmc_holdover_ql_set,
static int (*_tdpll_esmc_holdover_ql_set_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_esmc_quality_level_t ql) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_esmc_holdover_ql_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_esmc_quality_level_t ql)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_esmc_holdover_ql_set_dispatch[dtype](unit, stack_id, dpll_index, ql);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_esmc_holdover_ql_set", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_esmc_mac_get( \
    int unit, int stack_id, int dpll_index, bcm_mac_t *mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_esmc_mac_get,
static int (*_tdpll_esmc_mac_get_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_mac_t *mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_esmc_mac_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_mac_t *mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_esmc_mac_get_dispatch[dtype](unit, stack_id, dpll_index, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_esmc_mac_get", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_esmc_mac_set( \
    int unit, int stack_id, int dpll_index, bcm_mac_t *mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_esmc_mac_set,
static int (*_tdpll_esmc_mac_set_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_mac_t *mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_esmc_mac_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_mac_t *mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_esmc_mac_set_dispatch[dtype](unit, stack_id, dpll_index, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_esmc_mac_set", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_esmc_ql_get( \
    int unit, int stack_id, int dpll_index, bcm_esmc_quality_level_t *ql);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_esmc_ql_get,
static int (*_tdpll_esmc_ql_get_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_esmc_quality_level_t *ql) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_esmc_ql_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_esmc_quality_level_t *ql)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_esmc_ql_get_dispatch[dtype](unit, stack_id, dpll_index, ql);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_esmc_ql_get", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_esmc_ql_set( \
    int unit, int stack_id, int dpll_index, bcm_esmc_quality_level_t ql);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_esmc_ql_set,
static int (*_tdpll_esmc_ql_set_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_esmc_quality_level_t ql) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_esmc_ql_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_esmc_quality_level_t ql)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_esmc_ql_set_dispatch[dtype](unit, stack_id, dpll_index, ql);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_esmc_ql_set", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_esmc_rx_enable_get( \
    int unit, int stack_id, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_esmc_rx_enable_get,
static int (*_tdpll_esmc_rx_enable_get_dispatch[])(
    int unit, 
    int stack_id, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_esmc_rx_enable_get(
    int unit, 
    int stack_id, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_esmc_rx_enable_get_dispatch[dtype](unit, stack_id, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_esmc_rx_enable_get", 3, 2, unit, stack_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_esmc_rx_enable_set( \
    int unit, int stack_id, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_esmc_rx_enable_set,
static int (*_tdpll_esmc_rx_enable_set_dispatch[])(
    int unit, 
    int stack_id, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_esmc_rx_enable_set(
    int unit, 
    int stack_id, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_esmc_rx_enable_set_dispatch[dtype](unit, stack_id, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_esmc_rx_enable_set", 3, 3, unit, stack_id, enable, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_esmc_rx_portbitmap_get( \
    int unit, int stack_id, int dpll_index, bcm_pbmp_t *pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_esmc_rx_portbitmap_get,
static int (*_tdpll_esmc_rx_portbitmap_get_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_pbmp_t *pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_esmc_rx_portbitmap_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_pbmp_t *pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_esmc_rx_portbitmap_get_dispatch[dtype](unit, stack_id, dpll_index, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_esmc_rx_portbitmap_get", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_esmc_rx_portbitmap_set( \
    int unit, int stack_id, int dpll_index, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_esmc_rx_portbitmap_set,
static int (*_tdpll_esmc_rx_portbitmap_set_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_esmc_rx_portbitmap_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_esmc_rx_portbitmap_set_dispatch[dtype](unit, stack_id, dpll_index, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_esmc_rx_portbitmap_set", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_esmc_rx_state_machine( \
    int unit, int stack_id, int ingress_port, bcm_esmc_pdu_data_t *esmc_pdu_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_esmc_rx_state_machine,
static int (*_tdpll_esmc_rx_state_machine_dispatch[])(
    int unit, 
    int stack_id, 
    int ingress_port, 
    bcm_esmc_pdu_data_t *esmc_pdu_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_esmc_rx_state_machine(
    int unit, 
    int stack_id, 
    int ingress_port, 
    bcm_esmc_pdu_data_t *esmc_pdu_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_esmc_rx_state_machine_dispatch[dtype](unit, stack_id, ingress_port, esmc_pdu_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_esmc_rx_state_machine", 4, 3, unit, stack_id, ingress_port, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_esmc_tx_enable_get( \
    int unit, int stack_id, int dpll_index, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_esmc_tx_enable_get,
static int (*_tdpll_esmc_tx_enable_get_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_esmc_tx_enable_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_esmc_tx_enable_get_dispatch[dtype](unit, stack_id, dpll_index, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_esmc_tx_enable_get", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_esmc_tx_enable_set( \
    int unit, int stack_id, int dpll_index, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_esmc_tx_enable_set,
static int (*_tdpll_esmc_tx_enable_set_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_esmc_tx_enable_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_esmc_tx_enable_set_dispatch[dtype](unit, stack_id, dpll_index, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_esmc_tx_enable_set", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_esmc_tx_portbitmap_get( \
    int unit, int stack_id, int dpll_index, bcm_pbmp_t *pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_esmc_tx_portbitmap_get,
static int (*_tdpll_esmc_tx_portbitmap_get_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_pbmp_t *pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_esmc_tx_portbitmap_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_pbmp_t *pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_esmc_tx_portbitmap_get_dispatch[dtype](unit, stack_id, dpll_index, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_esmc_tx_portbitmap_get", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_esmc_tx_portbitmap_set( \
    int unit, int stack_id, int dpll_index, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_esmc_tx_portbitmap_set,
static int (*_tdpll_esmc_tx_portbitmap_set_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_esmc_tx_portbitmap_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_esmc_tx_portbitmap_set_dispatch[dtype](unit, stack_id, dpll_index, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_esmc_tx_portbitmap_set", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_best_get( \
    int unit, int stack_id, int dpll_index, int *best_clock);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_best_get,
static int (*_tdpll_input_clock_best_get_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int *best_clock) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_best_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int *best_clock)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_best_get_dispatch[dtype](unit, stack_id, dpll_index, best_clock);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_best_get", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_control( \
    int unit, int stack_id, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_control,
static int (*_tdpll_input_clock_control_dispatch[])(
    int unit, 
    int stack_id, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_control(
    int unit, 
    int stack_id, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_control_dispatch[dtype](unit, stack_id, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_control", 3, 3, unit, stack_id, enable, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_enable_get( \
    int unit, int stack_id, int clock_index, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_enable_get,
static int (*_tdpll_input_clock_enable_get_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_enable_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_enable_get_dispatch[dtype](unit, stack_id, clock_index, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_enable_get", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_enable_set( \
    int unit, int stack_id, int clock_index, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_enable_set,
static int (*_tdpll_input_clock_enable_set_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_enable_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_enable_set_dispatch[dtype](unit, stack_id, clock_index, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_enable_set", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_frequency_error_get( \
    int unit, int stack_id, int clock_index, int *freq_error_ppb);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_frequency_error_get,
static int (*_tdpll_input_clock_frequency_error_get_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *freq_error_ppb) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_frequency_error_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *freq_error_ppb)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_frequency_error_get_dispatch[dtype](unit, stack_id, clock_index, freq_error_ppb);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_frequency_error_get", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_frequency_get( \
    int unit, int stack_id, int clock_index, uint32 *clock_frequency, uint32 *tsevent_frequency);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_frequency_get,
static int (*_tdpll_input_clock_frequency_get_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 *clock_frequency, 
    uint32 *tsevent_frequency) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_frequency_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 *clock_frequency, 
    uint32 *tsevent_frequency)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_frequency_get_dispatch[dtype](unit, stack_id, clock_index, clock_frequency, tsevent_frequency);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_frequency_get", 5, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_frequency_set( \
    int unit, int stack_id, int clock_index, uint32 clock_frequency, uint32 tsevent_frequency);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_frequency_set,
static int (*_tdpll_input_clock_frequency_set_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 clock_frequency, 
    uint32 tsevent_frequency) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_frequency_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 clock_frequency, 
    uint32 tsevent_frequency)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_frequency_set_dispatch[dtype](unit, stack_id, clock_index, clock_frequency, tsevent_frequency);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_frequency_set", 5, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_l1mux_get( \
    int unit, int stack_id, int clock_index, bcm_tdpll_input_clock_l1mux_t *l1mux);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_l1mux_get,
static int (*_tdpll_input_clock_l1mux_get_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_input_clock_l1mux_t *l1mux) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_l1mux_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_input_clock_l1mux_t *l1mux)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_l1mux_get_dispatch[dtype](unit, stack_id, clock_index, l1mux);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_l1mux_get", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_l1mux_set( \
    int unit, int stack_id, int clock_index, bcm_tdpll_input_clock_l1mux_t *l1mux);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_l1mux_set,
static int (*_tdpll_input_clock_l1mux_set_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_input_clock_l1mux_t *l1mux) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_l1mux_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_input_clock_l1mux_t *l1mux)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_l1mux_set_dispatch[dtype](unit, stack_id, clock_index, l1mux);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_l1mux_set", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_lockout_get( \
    int unit, int stack_id, int clock_index, int *lockout);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_lockout_get,
static int (*_tdpll_input_clock_lockout_get_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *lockout) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_lockout_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *lockout)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_lockout_get_dispatch[dtype](unit, stack_id, clock_index, lockout);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_lockout_get", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_lockout_set( \
    int unit, int stack_id, int clock_index, int lockout);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_lockout_set,
static int (*_tdpll_input_clock_lockout_set_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    int lockout) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_lockout_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    int lockout)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_lockout_set_dispatch[dtype](unit, stack_id, clock_index, lockout);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_lockout_set", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_mac_get( \
    int unit, int stack_id, int clock_index, bcm_mac_t *mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_mac_get,
static int (*_tdpll_input_clock_mac_get_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_mac_t *mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_mac_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_mac_t *mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_mac_get_dispatch[dtype](unit, stack_id, clock_index, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_mac_get", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_mac_set( \
    int unit, int stack_id, int clock_index, bcm_mac_t *mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_mac_set,
static int (*_tdpll_input_clock_mac_set_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_mac_t *mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_mac_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_mac_t *mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_mac_set_dispatch[dtype](unit, stack_id, clock_index, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_mac_set", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_monitor_callback_register( \
    int unit, int stack_id, bcm_tdpll_input_clock_monitor_cb monitor_cb);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_monitor_callback_register,
static int (*_tdpll_input_clock_monitor_callback_register_dispatch[])(
    int unit, 
    int stack_id, 
    bcm_tdpll_input_clock_monitor_cb monitor_cb) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_monitor_callback_register(
    int unit, 
    int stack_id, 
    bcm_tdpll_input_clock_monitor_cb monitor_cb)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_monitor_callback_register_dispatch[dtype](unit, stack_id, monitor_cb);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_monitor_callback_register", 3, 2, unit, stack_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_monitor_callback_unregister( \
    int unit, int stack_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_monitor_callback_unregister,
static int (*_tdpll_input_clock_monitor_callback_unregister_dispatch[])(
    int unit, 
    int stack_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_monitor_callback_unregister(
    int unit, 
    int stack_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_monitor_callback_unregister_dispatch[dtype](unit, stack_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_monitor_callback_unregister", 2, 2, unit, stack_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_monitor_interval_get( \
    int unit, int stack_id, uint32 *monitor_interval);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_monitor_interval_get,
static int (*_tdpll_input_clock_monitor_interval_get_dispatch[])(
    int unit, 
    int stack_id, 
    uint32 *monitor_interval) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_monitor_interval_get(
    int unit, 
    int stack_id, 
    uint32 *monitor_interval)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_monitor_interval_get_dispatch[dtype](unit, stack_id, monitor_interval);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_monitor_interval_get", 3, 2, unit, stack_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_monitor_interval_set( \
    int unit, int stack_id, uint32 monitor_interval);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_monitor_interval_set,
static int (*_tdpll_input_clock_monitor_interval_set_dispatch[])(
    int unit, 
    int stack_id, 
    uint32 monitor_interval) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_monitor_interval_set(
    int unit, 
    int stack_id, 
    uint32 monitor_interval)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_monitor_interval_set_dispatch[dtype](unit, stack_id, monitor_interval);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_monitor_interval_set", 3, 3, unit, stack_id, monitor_interval, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_monitor_threshold_get( \
    int unit, int stack_id, bcm_tdpll_input_clock_monitor_type_t threshold_type, uint32 *threshold);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_monitor_threshold_get,
static int (*_tdpll_input_clock_monitor_threshold_get_dispatch[])(
    int unit, 
    int stack_id, 
    bcm_tdpll_input_clock_monitor_type_t threshold_type, 
    uint32 *threshold) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_monitor_threshold_get(
    int unit, 
    int stack_id, 
    bcm_tdpll_input_clock_monitor_type_t threshold_type, 
    uint32 *threshold)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_monitor_threshold_get_dispatch[dtype](unit, stack_id, threshold_type, threshold);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_monitor_threshold_get", 4, 3, unit, stack_id, threshold_type, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_monitor_threshold_set( \
    int unit, int stack_id, bcm_tdpll_input_clock_monitor_type_t threshold_type, uint32 threshold);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_monitor_threshold_set,
static int (*_tdpll_input_clock_monitor_threshold_set_dispatch[])(
    int unit, 
    int stack_id, 
    bcm_tdpll_input_clock_monitor_type_t threshold_type, 
    uint32 threshold) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_monitor_threshold_set(
    int unit, 
    int stack_id, 
    bcm_tdpll_input_clock_monitor_type_t threshold_type, 
    uint32 threshold)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_monitor_threshold_set_dispatch[dtype](unit, stack_id, threshold_type, threshold);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_monitor_threshold_set", 4, 3, unit, stack_id, threshold_type, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_priority_get( \
    int unit, int stack_id, int clock_index, int *priority);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_priority_get,
static int (*_tdpll_input_clock_priority_get_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *priority) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_priority_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *priority)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_priority_get_dispatch[dtype](unit, stack_id, clock_index, priority);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_priority_get", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_priority_set( \
    int unit, int stack_id, int clock_index, int priority);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_priority_set,
static int (*_tdpll_input_clock_priority_set_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    int priority) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_priority_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    int priority)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_priority_set_dispatch[dtype](unit, stack_id, clock_index, priority);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_priority_set", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_ql_enabled_get( \
    int unit, int stack_id, int dpll_index, int *ql_enabled);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_ql_enabled_get,
static int (*_tdpll_input_clock_ql_enabled_get_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int *ql_enabled) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_ql_enabled_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int *ql_enabled)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_ql_enabled_get_dispatch[dtype](unit, stack_id, dpll_index, ql_enabled);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_ql_enabled_get", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_ql_enabled_set( \
    int unit, int stack_id, int dpll_index, int ql_enabled);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_ql_enabled_set,
static int (*_tdpll_input_clock_ql_enabled_set_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int ql_enabled) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_ql_enabled_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int ql_enabled)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_ql_enabled_set_dispatch[dtype](unit, stack_id, dpll_index, ql_enabled);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_ql_enabled_set", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_ql_get( \
    int unit, int stack_id, int clock_index, bcm_esmc_quality_level_t *ql);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_ql_get,
static int (*_tdpll_input_clock_ql_get_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_esmc_quality_level_t *ql) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_ql_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_esmc_quality_level_t *ql)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_ql_get_dispatch[dtype](unit, stack_id, clock_index, ql);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_ql_get", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_ql_set( \
    int unit, int stack_id, int clock_index, bcm_esmc_quality_level_t ql);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_ql_set,
static int (*_tdpll_input_clock_ql_set_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_esmc_quality_level_t ql) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_ql_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_esmc_quality_level_t ql)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_ql_set_dispatch[dtype](unit, stack_id, clock_index, ql);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_ql_set", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_revertive_get( \
    int unit, int stack_id, int dpll_index, int *revertive);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_revertive_get,
static int (*_tdpll_input_clock_revertive_get_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int *revertive) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_revertive_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int *revertive)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_revertive_get_dispatch[dtype](unit, stack_id, dpll_index, revertive);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_revertive_get", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_revertive_set( \
    int unit, int stack_id, int dpll_index, int revertive);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_revertive_set,
static int (*_tdpll_input_clock_revertive_set_dispatch[])(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int revertive) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_revertive_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int revertive)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_revertive_set_dispatch[dtype](unit, stack_id, dpll_index, revertive);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_revertive_set", 4, 3, unit, stack_id, dpll_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_selector_callback_register( \
    int unit, int stack_id, bcm_tdpll_input_clock_selector_cb selector_cb);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_selector_callback_register,
static int (*_tdpll_input_clock_selector_callback_register_dispatch[])(
    int unit, 
    int stack_id, 
    bcm_tdpll_input_clock_selector_cb selector_cb) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_selector_callback_register(
    int unit, 
    int stack_id, 
    bcm_tdpll_input_clock_selector_cb selector_cb)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_selector_callback_register_dispatch[dtype](unit, stack_id, selector_cb);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_selector_callback_register", 3, 2, unit, stack_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_selector_callback_unregister( \
    int unit, int stack_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_selector_callback_unregister,
static int (*_tdpll_input_clock_selector_callback_unregister_dispatch[])(
    int unit, 
    int stack_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_selector_callback_unregister(
    int unit, 
    int stack_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_selector_callback_unregister_dispatch[dtype](unit, stack_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_selector_callback_unregister", 2, 2, unit, stack_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_threshold_state_get( \
    int unit, int stack_id, int clock_index, bcm_tdpll_input_clock_monitor_type_t threshold_type, int *threshold_state);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_threshold_state_get,
static int (*_tdpll_input_clock_threshold_state_get_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_input_clock_monitor_type_t threshold_type, 
    int *threshold_state) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_threshold_state_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_input_clock_monitor_type_t threshold_type, 
    int *threshold_state)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_threshold_state_get_dispatch[dtype](unit, stack_id, clock_index, threshold_type, threshold_state);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_threshold_state_get", 5, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_valid_get( \
    int unit, int stack_id, int clock_index, int *valid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_valid_get,
static int (*_tdpll_input_clock_valid_get_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *valid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_valid_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *valid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_valid_get_dispatch[dtype](unit, stack_id, clock_index, valid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_valid_get", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_input_clock_valid_set( \
    int unit, int stack_id, int clock_index, int valid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_input_clock_valid_set,
static int (*_tdpll_input_clock_valid_set_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    int valid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_input_clock_valid_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    int valid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_input_clock_valid_set_dispatch[dtype](unit, stack_id, clock_index, valid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_input_clock_valid_set", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_output_clock_deriv_frequency_get( \
    int unit, int stack_id, int clock_index, uint32 *deriv_frequency);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_output_clock_deriv_frequency_get,
static int (*_tdpll_output_clock_deriv_frequency_get_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 *deriv_frequency) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_output_clock_deriv_frequency_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 *deriv_frequency)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_output_clock_deriv_frequency_get_dispatch[dtype](unit, stack_id, clock_index, deriv_frequency);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_output_clock_deriv_frequency_get", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_output_clock_deriv_frequency_set( \
    int unit, int stack_id, int clock_index, uint32 deriv_frequency);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_output_clock_deriv_frequency_set,
static int (*_tdpll_output_clock_deriv_frequency_set_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 deriv_frequency) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_output_clock_deriv_frequency_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 deriv_frequency)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_output_clock_deriv_frequency_set_dispatch[dtype](unit, stack_id, clock_index, deriv_frequency);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_output_clock_deriv_frequency_set", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_output_clock_enable_get( \
    int unit, int stack_id, int clock_index, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_output_clock_enable_get,
static int (*_tdpll_output_clock_enable_get_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_output_clock_enable_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_output_clock_enable_get_dispatch[dtype](unit, stack_id, clock_index, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_output_clock_enable_get", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_output_clock_enable_set( \
    int unit, int stack_id, int clock_index, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_output_clock_enable_set,
static int (*_tdpll_output_clock_enable_set_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_output_clock_enable_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_output_clock_enable_set_dispatch[dtype](unit, stack_id, clock_index, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_output_clock_enable_set", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_output_clock_holdover_data_get( \
    int unit, int stack_id, int clock_index, bcm_tdpll_holdover_data_t *hdata);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_output_clock_holdover_data_get,
static int (*_tdpll_output_clock_holdover_data_get_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_holdover_data_t *hdata) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_output_clock_holdover_data_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_holdover_data_t *hdata)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_output_clock_holdover_data_get_dispatch[dtype](unit, stack_id, clock_index, hdata);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_output_clock_holdover_data_get", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_output_clock_holdover_frequency_set( \
    int unit, int stack_id, int clock_index, bcm_tdpll_frequency_correction_t hfreq);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_output_clock_holdover_frequency_set,
static int (*_tdpll_output_clock_holdover_frequency_set_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_frequency_correction_t hfreq) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_output_clock_holdover_frequency_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_frequency_correction_t hfreq)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_output_clock_holdover_frequency_set_dispatch[dtype](unit, stack_id, clock_index, hfreq);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_output_clock_holdover_frequency_set", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_output_clock_holdover_mode_get( \
    int unit, int stack_id, int clock_index, bcm_tdpll_holdover_mode_t *hmode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_output_clock_holdover_mode_get,
static int (*_tdpll_output_clock_holdover_mode_get_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_holdover_mode_t *hmode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_output_clock_holdover_mode_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_holdover_mode_t *hmode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_output_clock_holdover_mode_get_dispatch[dtype](unit, stack_id, clock_index, hmode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_output_clock_holdover_mode_get", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_output_clock_holdover_mode_set( \
    int unit, int stack_id, int clock_index, bcm_tdpll_holdover_mode_t hmode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_output_clock_holdover_mode_set,
static int (*_tdpll_output_clock_holdover_mode_set_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_holdover_mode_t hmode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_output_clock_holdover_mode_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_holdover_mode_t hmode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_output_clock_holdover_mode_set_dispatch[dtype](unit, stack_id, clock_index, hmode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_output_clock_holdover_mode_set", 4, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_output_clock_holdover_reset( \
    int unit, int stack_id, int clock_index);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_output_clock_holdover_reset,
static int (*_tdpll_output_clock_holdover_reset_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_output_clock_holdover_reset(
    int unit, 
    int stack_id, 
    int clock_index)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_output_clock_holdover_reset_dispatch[dtype](unit, stack_id, clock_index);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_output_clock_holdover_reset", 3, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_output_clock_synth_frequency_get( \
    int unit, int stack_id, int clock_index, uint32 *synth_frequency, uint32 *tsevent_frequency);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_output_clock_synth_frequency_get,
static int (*_tdpll_output_clock_synth_frequency_get_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 *synth_frequency, 
    uint32 *tsevent_frequency) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_output_clock_synth_frequency_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 *synth_frequency, 
    uint32 *tsevent_frequency)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_output_clock_synth_frequency_get_dispatch[dtype](unit, stack_id, clock_index, synth_frequency, tsevent_frequency);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_output_clock_synth_frequency_get", 5, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_PTP)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tdpll_output_clock_synth_frequency_set( \
    int unit, int stack_id, int clock_index, uint32 synth_frequency, uint32 tsevent_frequency);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tdpll_output_clock_synth_frequency_set,
static int (*_tdpll_output_clock_synth_frequency_set_dispatch[])(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 synth_frequency, 
    uint32 tsevent_frequency) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tdpll_output_clock_synth_frequency_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 synth_frequency, 
    uint32 tsevent_frequency)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tdpll_output_clock_synth_frequency_set_dispatch[dtype](unit, stack_id, clock_index, synth_frequency, tsevent_frequency);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tdpll_output_clock_synth_frequency_set", 5, 3, unit, stack_id, clock_index, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_time_capture_get( \
    int unit, bcm_time_if_t intf_id, bcm_time_capture_t *time);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_time_capture_get,
static int (*_time_capture_get_dispatch[])(
    int unit, 
    bcm_time_if_t intf_id, 
    bcm_time_capture_t *time) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_time_capture_get(
    int unit, 
    bcm_time_if_t intf_id, 
    bcm_time_capture_t *time)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _time_capture_get_dispatch[dtype](unit, intf_id, time);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_time_capture_get", 3, 2, unit, intf_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_time_deinit( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_time_deinit,
static int (*_time_deinit_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_time_deinit(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _time_deinit_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_time_deinit", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_time_heartbeat_enable_get( \
    int unit, bcm_time_if_t id, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_time_heartbeat_enable_get,
static int (*_time_heartbeat_enable_get_dispatch[])(
    int unit, 
    bcm_time_if_t id, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_time_heartbeat_enable_get(
    int unit, 
    bcm_time_if_t id, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _time_heartbeat_enable_get_dispatch[dtype](unit, id, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_time_heartbeat_enable_get", 3, 2, unit, id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_time_heartbeat_enable_set( \
    int unit, bcm_time_if_t id, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_time_heartbeat_enable_set,
static int (*_time_heartbeat_enable_set_dispatch[])(
    int unit, 
    bcm_time_if_t id, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_time_heartbeat_enable_set(
    int unit, 
    bcm_time_if_t id, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _time_heartbeat_enable_set_dispatch[dtype](unit, id, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_time_heartbeat_enable_set", 3, 3, unit, id, enable, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_time_heartbeat_register( \
    int unit, bcm_time_if_t id, bcm_time_heartbeat_cb f, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_time_heartbeat_register,
static int (*_time_heartbeat_register_dispatch[])(
    int unit, 
    bcm_time_if_t id, 
    bcm_time_heartbeat_cb f, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_time_heartbeat_register(
    int unit, 
    bcm_time_if_t id, 
    bcm_time_heartbeat_cb f, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _time_heartbeat_register_dispatch[dtype](unit, id, f, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_time_heartbeat_register", 4, 2, unit, id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_time_heartbeat_unregister( \
    int unit, bcm_time_if_t id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_time_heartbeat_unregister,
static int (*_time_heartbeat_unregister_dispatch[])(
    int unit, 
    bcm_time_if_t id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_time_heartbeat_unregister(
    int unit, 
    bcm_time_if_t id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _time_heartbeat_unregister_dispatch[dtype](unit, id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_time_heartbeat_unregister", 2, 2, unit, id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_time_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_time_init,
static int (*_time_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_time_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _time_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_time_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_time_interface_add( \
    int unit, bcm_time_interface_t *intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_time_interface_add,
static int (*_time_interface_add_dispatch[])(
    int unit, 
    bcm_time_interface_t *intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_time_interface_add(
    int unit, 
    bcm_time_interface_t *intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _time_interface_add_dispatch[dtype](unit, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_time_interface_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_time_interface_delete( \
    int unit, bcm_time_if_t intf_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_time_interface_delete,
static int (*_time_interface_delete_dispatch[])(
    int unit, 
    bcm_time_if_t intf_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_time_interface_delete(
    int unit, 
    bcm_time_if_t intf_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _time_interface_delete_dispatch[dtype](unit, intf_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_time_interface_delete", 2, 2, unit, intf_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_time_interface_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_time_interface_delete_all,
static int (*_time_interface_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_time_interface_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _time_interface_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_time_interface_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_time_interface_get( \
    int unit, bcm_time_interface_t *intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_time_interface_get,
static int (*_time_interface_get_dispatch[])(
    int unit, 
    bcm_time_interface_t *intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_time_interface_get(
    int unit, 
    bcm_time_interface_t *intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _time_interface_get_dispatch[dtype](unit, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_time_interface_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_time_interface_traverse( \
    int unit, bcm_time_interface_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_time_interface_traverse,
static int (*_time_interface_traverse_dispatch[])(
    int unit, 
    bcm_time_interface_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_time_interface_traverse(
    int unit, 
    bcm_time_interface_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _time_interface_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_time_interface_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_time_trigger_enable_get( \
    int unit, bcm_time_if_t id, uint32 *mode_flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_time_trigger_enable_get,
static int (*_time_trigger_enable_get_dispatch[])(
    int unit, 
    bcm_time_if_t id, 
    uint32 *mode_flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_time_trigger_enable_get(
    int unit, 
    bcm_time_if_t id, 
    uint32 *mode_flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _time_trigger_enable_get_dispatch[dtype](unit, id, mode_flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_time_trigger_enable_get", 3, 2, unit, id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_time_trigger_enable_set( \
    int unit, bcm_time_if_t id, uint32 mode_flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_time_trigger_enable_set,
static int (*_time_trigger_enable_set_dispatch[])(
    int unit, 
    bcm_time_if_t id, 
    uint32 mode_flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_time_trigger_enable_set(
    int unit, 
    bcm_time_if_t id, 
    uint32 mode_flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _time_trigger_enable_set_dispatch[dtype](unit, id, mode_flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_time_trigger_enable_set", 3, 3, unit, id, mode_flags, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_topo_port_get( \
    int unit, int dest_modid, bcm_port_t *exit_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_topo_port_get,
static int (*_topo_port_get_dispatch[])(
    int unit, 
    int dest_modid, 
    bcm_port_t *exit_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_topo_port_get(
    int unit, 
    int dest_modid, 
    bcm_port_t *exit_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _topo_port_get_dispatch[dtype](unit, dest_modid, exit_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,exit_port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_topo_port_get", 3, 2, unit, dest_modid, 0, r_rv);
	return r_rv;
}

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_cleanup( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_cleanup,
static int (*_trill_cleanup_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_cleanup(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_cleanup_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_cleanup", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_init,
static int (*_trill_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_multicast_adjacency_add( \
    int unit, bcm_trill_multicast_adjacency_t *trill_multicast_adjacency);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_multicast_adjacency_add,
static int (*_trill_multicast_adjacency_add_dispatch[])(
    int unit, 
    bcm_trill_multicast_adjacency_t *trill_multicast_adjacency) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_multicast_adjacency_add(
    int unit, 
    bcm_trill_multicast_adjacency_t *trill_multicast_adjacency)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(trill_multicast_adjacency) BCM_API_XLATE_PORT_A2P(unit,&trill_multicast_adjacency->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_multicast_adjacency_add_dispatch[dtype](unit, trill_multicast_adjacency);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(trill_multicast_adjacency) BCM_API_XLATE_PORT_P2A(unit,&trill_multicast_adjacency->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_multicast_adjacency_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_multicast_adjacency_delete( \
    int unit, bcm_trill_multicast_adjacency_t *trill_multicast_adjacency);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_multicast_adjacency_delete,
static int (*_trill_multicast_adjacency_delete_dispatch[])(
    int unit, 
    bcm_trill_multicast_adjacency_t *trill_multicast_adjacency) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_multicast_adjacency_delete(
    int unit, 
    bcm_trill_multicast_adjacency_t *trill_multicast_adjacency)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(trill_multicast_adjacency) BCM_API_XLATE_PORT_A2P(unit,&trill_multicast_adjacency->port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_multicast_adjacency_delete_dispatch[dtype](unit, trill_multicast_adjacency);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(trill_multicast_adjacency) BCM_API_XLATE_PORT_P2A(unit,&trill_multicast_adjacency->port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_multicast_adjacency_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_multicast_adjacency_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_multicast_adjacency_delete_all,
static int (*_trill_multicast_adjacency_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_multicast_adjacency_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_multicast_adjacency_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_multicast_adjacency_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_multicast_adjacency_traverse( \
    int unit, bcm_trill_multicast_adjacency_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_multicast_adjacency_traverse,
static int (*_trill_multicast_adjacency_traverse_dispatch[])(
    int unit, 
    bcm_trill_multicast_adjacency_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_multicast_adjacency_traverse(
    int unit, 
    bcm_trill_multicast_adjacency_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_multicast_adjacency_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_multicast_adjacency_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_multicast_delete_all( \
    int unit, bcm_trill_name_t root_name);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_multicast_delete_all,
static int (*_trill_multicast_delete_all_dispatch[])(
    int unit, 
    bcm_trill_name_t root_name) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_multicast_delete_all(
    int unit, 
    bcm_trill_name_t root_name)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_multicast_delete_all_dispatch[dtype](unit, root_name);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_multicast_delete_all", 2, 2, unit, root_name, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_multicast_entry_add( \
    int unit, bcm_trill_multicast_entry_t *trill_mc_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_multicast_entry_add,
static int (*_trill_multicast_entry_add_dispatch[])(
    int unit, 
    bcm_trill_multicast_entry_t *trill_mc_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_multicast_entry_add(
    int unit, 
    bcm_trill_multicast_entry_t *trill_mc_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_multicast_entry_add_dispatch[dtype](unit, trill_mc_entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_multicast_entry_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_multicast_entry_delete( \
    int unit, bcm_trill_multicast_entry_t *trill_mc_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_multicast_entry_delete,
static int (*_trill_multicast_entry_delete_dispatch[])(
    int unit, 
    bcm_trill_multicast_entry_t *trill_mc_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_multicast_entry_delete(
    int unit, 
    bcm_trill_multicast_entry_t *trill_mc_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_multicast_entry_delete_dispatch[dtype](unit, trill_mc_entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_multicast_entry_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_multicast_entry_get( \
    int unit, bcm_trill_multicast_entry_t *trill_mc_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_multicast_entry_get,
static int (*_trill_multicast_entry_get_dispatch[])(
    int unit, 
    bcm_trill_multicast_entry_t *trill_mc_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_multicast_entry_get(
    int unit, 
    bcm_trill_multicast_entry_t *trill_mc_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_multicast_entry_get_dispatch[dtype](unit, trill_mc_entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_multicast_entry_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_multicast_entry_traverse( \
    int unit, bcm_trill_multicast_entry_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_multicast_entry_traverse,
static int (*_trill_multicast_entry_traverse_dispatch[])(
    int unit, 
    bcm_trill_multicast_entry_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_multicast_entry_traverse(
    int unit, 
    bcm_trill_multicast_entry_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_multicast_entry_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_multicast_entry_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_multicast_source_add( \
    int unit, bcm_trill_name_t root_name, bcm_trill_name_t source_rbridge_name, bcm_gport_t port, bcm_if_t encap_intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_multicast_source_add,
static int (*_trill_multicast_source_add_dispatch[])(
    int unit, 
    bcm_trill_name_t root_name, 
    bcm_trill_name_t source_rbridge_name, 
    bcm_gport_t port, 
    bcm_if_t encap_intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_multicast_source_add(
    int unit, 
    bcm_trill_name_t root_name, 
    bcm_trill_name_t source_rbridge_name, 
    bcm_gport_t port, 
    bcm_if_t encap_intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_multicast_source_add_dispatch[dtype](unit, root_name, source_rbridge_name, port, encap_intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_multicast_source_add", 5, 3, unit, root_name, source_rbridge_name, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_multicast_source_delete( \
    int unit, bcm_trill_name_t root_name, bcm_trill_name_t source_rbridge_name, bcm_gport_t port, bcm_if_t encap_intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_multicast_source_delete,
static int (*_trill_multicast_source_delete_dispatch[])(
    int unit, 
    bcm_trill_name_t root_name, 
    bcm_trill_name_t source_rbridge_name, 
    bcm_gport_t port, 
    bcm_if_t encap_intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_multicast_source_delete(
    int unit, 
    bcm_trill_name_t root_name, 
    bcm_trill_name_t source_rbridge_name, 
    bcm_gport_t port, 
    bcm_if_t encap_intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_multicast_source_delete_dispatch[dtype](unit, root_name, source_rbridge_name, port, encap_intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_multicast_source_delete", 5, 3, unit, root_name, source_rbridge_name, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_multicast_source_get( \
    int unit, bcm_trill_name_t root_name, bcm_trill_name_t source_rbridge_name, bcm_gport_t *port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_multicast_source_get,
static int (*_trill_multicast_source_get_dispatch[])(
    int unit, 
    bcm_trill_name_t root_name, 
    bcm_trill_name_t source_rbridge_name, 
    bcm_gport_t *port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_multicast_source_get(
    int unit, 
    bcm_trill_name_t root_name, 
    bcm_trill_name_t source_rbridge_name, 
    bcm_gport_t *port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_multicast_source_get_dispatch[dtype](unit, root_name, source_rbridge_name, port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_P2A(unit,port);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_multicast_source_get", 4, 3, unit, root_name, source_rbridge_name, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_multicast_source_traverse( \
    int unit, bcm_trill_multicast_source_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_multicast_source_traverse,
static int (*_trill_multicast_source_traverse_dispatch[])(
    int unit, 
    bcm_trill_multicast_source_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_multicast_source_traverse(
    int unit, 
    bcm_trill_multicast_source_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_multicast_source_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_multicast_source_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_port_add( \
    int unit, bcm_trill_port_t *trill_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_port_add,
static int (*_trill_port_add_dispatch[])(
    int unit, 
    bcm_trill_port_t *trill_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_port_add(
    int unit, 
    bcm_trill_port_t *trill_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(trill_port) BCM_API_XLATE_PORT_A2P(unit,&trill_port->port);
		BCM_API_XLATE_PORT_COND(trill_port) BCM_API_XLATE_PORT_A2P(unit,&trill_port->trill_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_port_add_dispatch[dtype](unit, trill_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(trill_port) BCM_API_XLATE_PORT_P2A(unit,&trill_port->port);
		BCM_API_XLATE_PORT_COND(trill_port) BCM_API_XLATE_PORT_P2A(unit,&trill_port->trill_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_port_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_port_delete( \
    int unit, bcm_gport_t trill_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_port_delete,
static int (*_trill_port_delete_dispatch[])(
    int unit, 
    bcm_gport_t trill_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_port_delete(
    int unit, 
    bcm_gport_t trill_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&trill_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_port_delete_dispatch[dtype](unit, trill_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_port_delete", 2, 2, unit, trill_port_id, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_port_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_port_delete_all,
static int (*_trill_port_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_port_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_port_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_port_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_port_get( \
    int unit, bcm_trill_port_t *trill_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_port_get,
static int (*_trill_port_get_dispatch[])(
    int unit, 
    bcm_trill_port_t *trill_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_port_get(
    int unit, 
    bcm_trill_port_t *trill_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(trill_port) BCM_API_XLATE_PORT_A2P(unit,&trill_port->port);
		BCM_API_XLATE_PORT_COND(trill_port) BCM_API_XLATE_PORT_A2P(unit,&trill_port->trill_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_port_get_dispatch[dtype](unit, trill_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(trill_port) BCM_API_XLATE_PORT_P2A(unit,&trill_port->port);
		BCM_API_XLATE_PORT_COND(trill_port) BCM_API_XLATE_PORT_P2A(unit,&trill_port->trill_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_port_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_port_get_all( \
    int unit, int port_max, bcm_trill_port_t *port_array, int *port_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_port_get_all,
static int (*_trill_port_get_all_dispatch[])(
    int unit, 
    int port_max, 
    bcm_trill_port_t *port_array, 
    int *port_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_port_get_all(
    int unit, 
    int port_max, 
    bcm_trill_port_t *port_array, 
    int *port_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_port_get_all_dispatch[dtype](unit, port_max, port_array, port_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].port);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].trill_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_port_get_all", 4, 2, unit, port_max, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_rbridge_entry_add( \
    int unit, bcm_trill_rbridge_t *trill_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_rbridge_entry_add,
static int (*_trill_rbridge_entry_add_dispatch[])(
    int unit, 
    bcm_trill_rbridge_t *trill_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_rbridge_entry_add(
    int unit, 
    bcm_trill_rbridge_t *trill_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_rbridge_entry_add_dispatch[dtype](unit, trill_entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_rbridge_entry_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_rbridge_entry_delete( \
    int unit, bcm_trill_rbridge_t *trill_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_rbridge_entry_delete,
static int (*_trill_rbridge_entry_delete_dispatch[])(
    int unit, 
    bcm_trill_rbridge_t *trill_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_rbridge_entry_delete(
    int unit, 
    bcm_trill_rbridge_t *trill_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_rbridge_entry_delete_dispatch[dtype](unit, trill_entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_rbridge_entry_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_rbridge_entry_get( \
    int unit, bcm_trill_rbridge_t *trill_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_rbridge_entry_get,
static int (*_trill_rbridge_entry_get_dispatch[])(
    int unit, 
    bcm_trill_rbridge_t *trill_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_rbridge_entry_get(
    int unit, 
    bcm_trill_rbridge_t *trill_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_rbridge_entry_get_dispatch[dtype](unit, trill_entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_rbridge_entry_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_stat_clear( \
    int unit, bcm_port_t port, bcm_trill_stat_t stat);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_stat_clear,
static int (*_trill_stat_clear_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_trill_stat_t stat) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_stat_clear(
    int unit, 
    bcm_port_t port, 
    bcm_trill_stat_t stat)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_stat_clear_dispatch[dtype](unit, port, stat);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_stat_clear", 3, 3, unit, port, stat, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_stat_get( \
    int unit, bcm_port_t port, bcm_trill_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_stat_get,
static int (*_trill_stat_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_trill_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_stat_get(
    int unit, 
    bcm_port_t port, 
    bcm_trill_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_stat_get_dispatch[dtype](unit, port, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_stat_get", 4, 3, unit, port, stat, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_stat_get32( \
    int unit, bcm_port_t port, bcm_trill_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_stat_get32,
static int (*_trill_stat_get32_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_trill_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_stat_get32(
    int unit, 
    bcm_port_t port, 
    bcm_trill_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_stat_get32_dispatch[dtype](unit, port, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_stat_get32", 4, 3, unit, port, stat, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_vpn_create( \
    int unit, bcm_trill_vpn_config_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_vpn_create,
static int (*_trill_vpn_create_dispatch[])(
    int unit, 
    bcm_trill_vpn_config_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_vpn_create(
    int unit, 
    bcm_trill_vpn_config_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_vpn_create_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_vpn_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_vpn_destroy( \
    int unit, bcm_vpn_t vpn);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_vpn_destroy,
static int (*_trill_vpn_destroy_dispatch[])(
    int unit, 
    bcm_vpn_t vpn) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_vpn_destroy(
    int unit, 
    bcm_vpn_t vpn)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_vpn_destroy_dispatch[dtype](unit, vpn);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_vpn_destroy", 2, 2, unit, vpn, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_vpn_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_vpn_destroy_all,
static int (*_trill_vpn_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_vpn_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_vpn_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_vpn_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_vpn_get( \
    int unit, bcm_vpn_t vpn, bcm_trill_vpn_config_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_vpn_get,
static int (*_trill_vpn_get_dispatch[])(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_trill_vpn_config_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_vpn_get(
    int unit, 
    bcm_vpn_t vpn, 
    bcm_trill_vpn_config_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_vpn_get_dispatch[dtype](unit, vpn, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_vpn_get", 3, 2, unit, vpn, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trill_vpn_traverse( \
    int unit, bcm_trill_vpn_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trill_vpn_traverse,
static int (*_trill_vpn_traverse_dispatch[])(
    int unit, 
    bcm_trill_vpn_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trill_vpn_traverse(
    int unit, 
    bcm_trill_vpn_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trill_vpn_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trill_vpn_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_bitmap_expand( \
    int unit, bcm_pbmp_t *pbmp_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_bitmap_expand,
static int (*_trunk_bitmap_expand_dispatch[])(
    int unit, 
    bcm_pbmp_t *pbmp_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_bitmap_expand(
    int unit, 
    bcm_pbmp_t *pbmp_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_A2P(unit,pbmp_ptr);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_bitmap_expand_dispatch[dtype](unit, pbmp_ptr);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,pbmp_ptr);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_bitmap_expand", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_chip_info_get( \
    int unit, bcm_trunk_chip_info_t *ta_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_chip_info_get,
static int (*_trunk_chip_info_get_dispatch[])(
    int unit, 
    bcm_trunk_chip_info_t *ta_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_chip_info_get(
    int unit, 
    bcm_trunk_chip_info_t *ta_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_chip_info_get_dispatch[dtype](unit, ta_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_chip_info_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_create( \
    int unit, uint32 flags, bcm_trunk_t *tid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_create,
static int (*_trunk_create_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_trunk_t *tid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_create(
    int unit, 
    uint32 flags, 
    bcm_trunk_t *tid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_create_dispatch[dtype](unit, flags, tid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_create", 3, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_destroy( \
    int unit, bcm_trunk_t tid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_destroy,
static int (*_trunk_destroy_dispatch[])(
    int unit, 
    bcm_trunk_t tid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_destroy(
    int unit, 
    bcm_trunk_t tid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_destroy_dispatch[dtype](unit, tid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_destroy", 2, 2, unit, tid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_detach,
static int (*_trunk_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_egress_get( \
    int unit, bcm_trunk_t tid, bcm_pbmp_t *pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_egress_get,
static int (*_trunk_egress_get_dispatch[])(
    int unit, 
    bcm_trunk_t tid, 
    bcm_pbmp_t *pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_egress_get(
    int unit, 
    bcm_trunk_t tid, 
    bcm_pbmp_t *pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_egress_get_dispatch[dtype](unit, tid, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_egress_get", 3, 2, unit, tid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_egress_set( \
    int unit, bcm_trunk_t tid, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_egress_set,
static int (*_trunk_egress_set_dispatch[])(
    int unit, 
    bcm_trunk_t tid, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_egress_set(
    int unit, 
    bcm_trunk_t tid, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_egress_set_dispatch[dtype](unit, tid, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_egress_set", 3, 2, unit, tid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_ethertype_get( \
    int unit, uint32 *flags, int ethertype_max, int *ethertype_array, int *ethertype_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_ethertype_get,
static int (*_trunk_ethertype_get_dispatch[])(
    int unit, 
    uint32 *flags, 
    int ethertype_max, 
    int *ethertype_array, 
    int *ethertype_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_ethertype_get(
    int unit, 
    uint32 *flags, 
    int ethertype_max, 
    int *ethertype_array, 
    int *ethertype_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_ethertype_get_dispatch[dtype](unit, flags, ethertype_max, ethertype_array, ethertype_count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_ethertype_get", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_ethertype_set( \
    int unit, uint32 flags, int ethertype_count, int *ethertype_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_ethertype_set,
static int (*_trunk_ethertype_set_dispatch[])(
    int unit, 
    uint32 flags, 
    int ethertype_count, 
    int *ethertype_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_ethertype_set(
    int unit, 
    uint32 flags, 
    int ethertype_count, 
    int *ethertype_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_ethertype_set_dispatch[dtype](unit, flags, ethertype_count, ethertype_array);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_ethertype_set", 4, 3, unit, flags, ethertype_count, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_failover_get( \
    int unit, bcm_trunk_t tid, bcm_gport_t failport, int *psc, uint32 *flags, int array_size, bcm_gport_t *fail_to_array, int *array_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_failover_get,
static int (*_trunk_failover_get_dispatch[])(
    int unit, 
    bcm_trunk_t tid, 
    bcm_gport_t failport, 
    int *psc, 
    uint32 *flags, 
    int array_size, 
    bcm_gport_t *fail_to_array, 
    int *array_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_failover_get(
    int unit, 
    bcm_trunk_t tid, 
    bcm_gport_t failport, 
    int *psc, 
    uint32 *flags, 
    int array_size, 
    bcm_gport_t *fail_to_array, 
    int *array_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_A2P(unit,&failport);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_failover_get_dispatch[dtype](unit, tid, failport, psc, flags, array_size, fail_to_array, array_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(array_size,idx)
				BCM_API_XLATE_PORT_COND(fail_to_array) BCM_API_XLATE_PORT_P2A(unit,&(fail_to_array)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_failover_get", 8, 3, unit, tid, failport, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_failover_set( \
    int unit, bcm_trunk_t tid, bcm_gport_t failport, int psc, uint32 flags, int count, bcm_gport_t *fail_to_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_failover_set,
static int (*_trunk_failover_set_dispatch[])(
    int unit, 
    bcm_trunk_t tid, 
    bcm_gport_t failport, 
    int psc, 
    uint32 flags, 
    int count, 
    bcm_gport_t *fail_to_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_failover_set(
    int unit, 
    bcm_trunk_t tid, 
    bcm_gport_t failport, 
    int psc, 
    uint32 flags, 
    int count, 
    bcm_gport_t *fail_to_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_A2P(unit,&failport);
		BCM_API_XLATE_PORT_ITER(count,idx)
			BCM_API_XLATE_PORT_COND(fail_to_array) BCM_API_XLATE_PORT_A2P(unit,&(fail_to_array)[idx]);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_failover_set_dispatch[dtype](unit, tid, failport, psc, flags, count, fail_to_array);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_ITER(count,idx)
			BCM_API_XLATE_PORT_COND(fail_to_array) BCM_API_XLATE_PORT_P2A(unit,&(fail_to_array)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_failover_set", 7, 3, unit, tid, failport, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_find( \
    int unit, bcm_module_t modid, bcm_port_t port, bcm_trunk_t *tid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_find,
static int (*_trunk_find_dispatch[])(
    int unit, 
    bcm_module_t modid, 
    bcm_port_t port, 
    bcm_trunk_t *tid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_find(
    int unit, 
    bcm_module_t modid, 
    bcm_port_t port, 
    bcm_trunk_t *tid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_find_dispatch[dtype](unit, modid, port, tid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_find", 4, 3, unit, modid, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_get( \
    int unit, bcm_trunk_t tid, bcm_trunk_info_t *t_data, int member_max, bcm_trunk_member_t *member_array, int *member_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_get,
static int (*_trunk_get_dispatch[])(
    int unit, 
    bcm_trunk_t tid, 
    bcm_trunk_info_t *t_data, 
    int member_max, 
    bcm_trunk_member_t *member_array, 
    int *member_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_get(
    int unit, 
    bcm_trunk_t tid, 
    bcm_trunk_info_t *t_data, 
    int member_max, 
    bcm_trunk_member_t *member_array, 
    int *member_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_get_dispatch[dtype](unit, tid, t_data, member_max, member_array, member_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(member_max,idx)
				BCM_API_XLATE_PORT_COND(member_array) BCM_API_XLATE_PORT_P2A(unit,&(member_array)[idx].gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_get", 6, 2, unit, tid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_init,
static int (*_trunk_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_mcast_join( \
    int unit, bcm_trunk_t tid, bcm_vlan_t vid, bcm_mac_t mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_mcast_join,
static int (*_trunk_mcast_join_dispatch[])(
    int unit, 
    bcm_trunk_t tid, 
    bcm_vlan_t vid, 
    bcm_mac_t mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_mcast_join(
    int unit, 
    bcm_trunk_t tid, 
    bcm_vlan_t vid, 
    bcm_mac_t mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_mcast_join_dispatch[dtype](unit, tid, vid, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_mcast_join", 4, 3, unit, tid, vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_member_add( \
    int unit, bcm_trunk_t tid, bcm_trunk_member_t *member);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_member_add,
static int (*_trunk_member_add_dispatch[])(
    int unit, 
    bcm_trunk_t tid, 
    bcm_trunk_member_t *member) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_member_add(
    int unit, 
    bcm_trunk_t tid, 
    bcm_trunk_member_t *member)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(member_gport);
		BCM_API_XLATE_PORT_COND(member) BCM_API_XLATE_PORT_SAVE(member_gport,member->gport);
		BCM_API_XLATE_PORT_COND(member) BCM_API_XLATE_PORT_A2P(unit,&member->gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_member_add_dispatch[dtype](unit, tid, member);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(member) BCM_API_XLATE_PORT_RESTORE(member->gport,member_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_member_add", 3, 2, unit, tid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_member_delete( \
    int unit, bcm_trunk_t tid, bcm_trunk_member_t *member);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_member_delete,
static int (*_trunk_member_delete_dispatch[])(
    int unit, 
    bcm_trunk_t tid, 
    bcm_trunk_member_t *member) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_member_delete(
    int unit, 
    bcm_trunk_t tid, 
    bcm_trunk_member_t *member)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(member_gport);
		BCM_API_XLATE_PORT_COND(member) BCM_API_XLATE_PORT_SAVE(member_gport,member->gport);
		BCM_API_XLATE_PORT_COND(member) BCM_API_XLATE_PORT_A2P(unit,&member->gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_member_delete_dispatch[dtype](unit, tid, member);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(member) BCM_API_XLATE_PORT_RESTORE(member->gport,member_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_member_delete", 3, 2, unit, tid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_member_delete_all( \
    int unit, bcm_trunk_t tid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_member_delete_all,
static int (*_trunk_member_delete_all_dispatch[])(
    int unit, 
    bcm_trunk_t tid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_member_delete_all(
    int unit, 
    bcm_trunk_t tid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_member_delete_all_dispatch[dtype](unit, tid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_member_delete_all", 2, 2, unit, tid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_member_status_get( \
    int unit, bcm_gport_t member, int *status);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_member_status_get,
static int (*_trunk_member_status_get_dispatch[])(
    int unit, 
    bcm_gport_t member, 
    int *status) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_member_status_get(
    int unit, 
    bcm_gport_t member, 
    int *status)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&member);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_member_status_get_dispatch[dtype](unit, member, status);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_member_status_get", 3, 2, unit, member, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_member_status_set( \
    int unit, bcm_gport_t member, int status);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_member_status_set,
static int (*_trunk_member_status_set_dispatch[])(
    int unit, 
    bcm_gport_t member, 
    int status) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_member_status_set(
    int unit, 
    bcm_gport_t member, 
    int status)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&member);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_member_status_set_dispatch[dtype](unit, member, status);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_member_status_set", 3, 3, unit, member, status, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_override_ipmc_get( \
    int unit, bcm_port_t port, bcm_trunk_t tid, int idx, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_override_ipmc_get,
static int (*_trunk_override_ipmc_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int idx, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_override_ipmc_get(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int idx, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_override_ipmc_get_dispatch[dtype](unit, port, tid, idx, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_override_ipmc_get", 5, 3, unit, port, tid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_override_ipmc_set( \
    int unit, bcm_port_t port, bcm_trunk_t tid, int idx, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_override_ipmc_set,
static int (*_trunk_override_ipmc_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int idx, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_override_ipmc_set(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int idx, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_override_ipmc_set_dispatch[dtype](unit, port, tid, idx, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_override_ipmc_set", 5, 3, unit, port, tid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_override_mcast_get( \
    int unit, bcm_port_t port, bcm_trunk_t tid, int idx, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_override_mcast_get,
static int (*_trunk_override_mcast_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int idx, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_override_mcast_get(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int idx, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_override_mcast_get_dispatch[dtype](unit, port, tid, idx, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_override_mcast_get", 5, 3, unit, port, tid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_override_mcast_set( \
    int unit, bcm_port_t port, bcm_trunk_t tid, int idx, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_override_mcast_set,
static int (*_trunk_override_mcast_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int idx, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_override_mcast_set(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int idx, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_override_mcast_set_dispatch[dtype](unit, port, tid, idx, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_override_mcast_set", 5, 3, unit, port, tid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_override_ucast_get( \
    int unit, bcm_port_t port, bcm_trunk_t tid, int modid, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_override_ucast_get,
static int (*_trunk_override_ucast_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int modid, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_override_ucast_get(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int modid, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_override_ucast_get_dispatch[dtype](unit, port, tid, modid, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_override_ucast_get", 5, 3, unit, port, tid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_override_ucast_set( \
    int unit, bcm_port_t port, bcm_trunk_t tid, int modid, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_override_ucast_set,
static int (*_trunk_override_ucast_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int modid, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_override_ucast_set(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int modid, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_override_ucast_set_dispatch[dtype](unit, port, tid, modid, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_override_ucast_set", 5, 3, unit, port, tid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_override_vlan_get( \
    int unit, bcm_port_t port, bcm_trunk_t tid, bcm_vlan_t vid, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_override_vlan_get,
static int (*_trunk_override_vlan_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    bcm_vlan_t vid, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_override_vlan_get(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    bcm_vlan_t vid, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_override_vlan_get_dispatch[dtype](unit, port, tid, vid, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_override_vlan_get", 5, 3, unit, port, tid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_override_vlan_set( \
    int unit, bcm_port_t port, bcm_trunk_t tid, bcm_vlan_t vid, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_override_vlan_set,
static int (*_trunk_override_vlan_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    bcm_vlan_t vid, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_override_vlan_set(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    bcm_vlan_t vid, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_override_vlan_set_dispatch[dtype](unit, port, tid, vid, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_override_vlan_set", 5, 3, unit, port, tid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_pool_get( \
    int unit, bcm_port_t port, bcm_trunk_t tid, int *size, int weights[BCM_TRUNK_MAX_PORTCNT]);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_pool_get,
static int (*_trunk_pool_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int *size, 
    int weights[BCM_TRUNK_MAX_PORTCNT]) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_pool_get(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int *size, 
    int weights[BCM_TRUNK_MAX_PORTCNT])
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_pool_get_dispatch[dtype](unit, port, tid, size, weights);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_pool_get", 5, 3, unit, port, tid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_pool_set( \
    int unit, bcm_port_t port, bcm_trunk_t tid, int size, const int weights[BCM_TRUNK_MAX_PORTCNT]);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_pool_set,
static int (*_trunk_pool_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int size, 
    const int weights[BCM_TRUNK_MAX_PORTCNT]) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_pool_set(
    int unit, 
    bcm_port_t port, 
    bcm_trunk_t tid, 
    int size, 
    const int weights[BCM_TRUNK_MAX_PORTCNT])
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_pool_set_dispatch[dtype](unit, port, tid, size, weights);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_pool_set", 5, 3, unit, port, tid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_psc_get( \
    int unit, bcm_trunk_t tid, int *psc);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_psc_get,
static int (*_trunk_psc_get_dispatch[])(
    int unit, 
    bcm_trunk_t tid, 
    int *psc) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_psc_get(
    int unit, 
    bcm_trunk_t tid, 
    int *psc)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_psc_get_dispatch[dtype](unit, tid, psc);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_psc_get", 3, 2, unit, tid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_psc_set( \
    int unit, bcm_trunk_t tid, int psc);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_psc_set,
static int (*_trunk_psc_set_dispatch[])(
    int unit, 
    bcm_trunk_t tid, 
    int psc) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_psc_set(
    int unit, 
    bcm_trunk_t tid, 
    int psc)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_psc_set_dispatch[dtype](unit, tid, psc);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_psc_set", 3, 3, unit, tid, psc, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_resilient_replace( \
    int unit, uint32 flags, bcm_trunk_resilient_entry_t *match_entry, int *num_entries, bcm_trunk_resilient_entry_t *replace_entry);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_resilient_replace,
static int (*_trunk_resilient_replace_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_trunk_resilient_entry_t *match_entry, 
    int *num_entries, 
    bcm_trunk_resilient_entry_t *replace_entry) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_resilient_replace(
    int unit, 
    uint32 flags, 
    bcm_trunk_resilient_entry_t *match_entry, 
    int *num_entries, 
    bcm_trunk_resilient_entry_t *replace_entry)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_resilient_replace_dispatch[dtype](unit, flags, match_entry, num_entries, replace_entry);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_resilient_replace", 5, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_resilient_traverse( \
    int unit, uint32 flags, bcm_trunk_resilient_entry_t *match_entry, bcm_trunk_resilient_traverse_cb trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_resilient_traverse,
static int (*_trunk_resilient_traverse_dispatch[])(
    int unit, 
    uint32 flags, 
    bcm_trunk_resilient_entry_t *match_entry, 
    bcm_trunk_resilient_traverse_cb trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_resilient_traverse(
    int unit, 
    uint32 flags, 
    bcm_trunk_resilient_entry_t *match_entry, 
    bcm_trunk_resilient_traverse_cb trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_resilient_traverse_dispatch[dtype](unit, flags, match_entry, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_resilient_traverse", 5, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_trunk_set( \
    int unit, bcm_trunk_t tid, bcm_trunk_info_t *trunk_info, int member_count, bcm_trunk_member_t *member_array);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_trunk_set,
static int (*_trunk_set_dispatch[])(
    int unit, 
    bcm_trunk_t tid, 
    bcm_trunk_info_t *trunk_info, 
    int member_count, 
    bcm_trunk_member_t *member_array) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_trunk_set(
    int unit, 
    bcm_trunk_t tid, 
    bcm_trunk_info_t *trunk_info, 
    int member_count, 
    bcm_trunk_member_t *member_array)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_ITER(member_count,idx)
			BCM_API_XLATE_PORT_COND(member_array) BCM_API_XLATE_PORT_A2P(unit,&(member_array)[idx].gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _trunk_set_dispatch[dtype](unit, tid, trunk_info, member_count, member_array);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_ITER(member_count,idx)
			BCM_API_XLATE_PORT_COND(member_array) BCM_API_XLATE_PORT_P2A(unit,&(member_array)[idx].gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_trunk_set", 5, 2, unit, tid, 0, r_rv);
	return r_rv;
}

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_config_get( \
    int unit, bcm_tunnel_config_t *tconfig);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_config_get,
static int (*_tunnel_config_get_dispatch[])(
    int unit, 
    bcm_tunnel_config_t *tconfig) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_config_get(
    int unit, 
    bcm_tunnel_config_t *tconfig)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_config_get_dispatch[dtype](unit, tconfig);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_config_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_config_set( \
    int unit, bcm_tunnel_config_t *tconfig);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_config_set,
static int (*_tunnel_config_set_dispatch[])(
    int unit, 
    bcm_tunnel_config_t *tconfig) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_config_set(
    int unit, 
    bcm_tunnel_config_t *tconfig)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_config_set_dispatch[dtype](unit, tconfig);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_config_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_dscp_map_create( \
    int unit, uint32 flags, int *dscp_map_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_dscp_map_create,
static int (*_tunnel_dscp_map_create_dispatch[])(
    int unit, 
    uint32 flags, 
    int *dscp_map_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_dscp_map_create(
    int unit, 
    uint32 flags, 
    int *dscp_map_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_dscp_map_create_dispatch[dtype](unit, flags, dscp_map_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_dscp_map_create", 3, 2, unit, flags, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_dscp_map_destroy( \
    int unit, int dscp_map_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_dscp_map_destroy,
static int (*_tunnel_dscp_map_destroy_dispatch[])(
    int unit, 
    int dscp_map_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_dscp_map_destroy(
    int unit, 
    int dscp_map_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_dscp_map_destroy_dispatch[dtype](unit, dscp_map_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_dscp_map_destroy", 2, 2, unit, dscp_map_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_dscp_map_get( \
    int unit, int dscp_map_id, bcm_tunnel_dscp_map_t *dscp_map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_dscp_map_get,
static int (*_tunnel_dscp_map_get_dispatch[])(
    int unit, 
    int dscp_map_id, 
    bcm_tunnel_dscp_map_t *dscp_map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_dscp_map_get(
    int unit, 
    int dscp_map_id, 
    bcm_tunnel_dscp_map_t *dscp_map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_dscp_map_get_dispatch[dtype](unit, dscp_map_id, dscp_map);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_dscp_map_get", 3, 2, unit, dscp_map_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_dscp_map_port_get( \
    int unit, bcm_port_t port, bcm_tunnel_dscp_map_t *dscp_map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_dscp_map_port_get,
static int (*_tunnel_dscp_map_port_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_tunnel_dscp_map_t *dscp_map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_dscp_map_port_get(
    int unit, 
    bcm_port_t port, 
    bcm_tunnel_dscp_map_t *dscp_map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_dscp_map_port_get_dispatch[dtype](unit, port, dscp_map);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_dscp_map_port_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_dscp_map_port_set( \
    int unit, bcm_port_t port, bcm_tunnel_dscp_map_t *dscp_map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_dscp_map_port_set,
static int (*_tunnel_dscp_map_port_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_tunnel_dscp_map_t *dscp_map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_dscp_map_port_set(
    int unit, 
    bcm_port_t port, 
    bcm_tunnel_dscp_map_t *dscp_map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_dscp_map_port_set_dispatch[dtype](unit, port, dscp_map);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_dscp_map_port_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_dscp_map_set( \
    int unit, int dscp_map_id, bcm_tunnel_dscp_map_t *dscp_map);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_dscp_map_set,
static int (*_tunnel_dscp_map_set_dispatch[])(
    int unit, 
    int dscp_map_id, 
    bcm_tunnel_dscp_map_t *dscp_map) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_dscp_map_set(
    int unit, 
    int dscp_map_id, 
    bcm_tunnel_dscp_map_t *dscp_map)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_dscp_map_set_dispatch[dtype](unit, dscp_map_id, dscp_map);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_dscp_map_set", 3, 2, unit, dscp_map_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_initiator_clear( \
    int unit, bcm_l3_intf_t *intf);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_initiator_clear,
static int (*_tunnel_initiator_clear_dispatch[])(
    int unit, 
    bcm_l3_intf_t *intf) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_initiator_clear(
    int unit, 
    bcm_l3_intf_t *intf)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_initiator_clear_dispatch[dtype](unit, intf);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_initiator_clear", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_initiator_create( \
    int unit, bcm_l3_intf_t *intf, bcm_tunnel_initiator_t *tunnel);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_initiator_create,
static int (*_tunnel_initiator_create_dispatch[])(
    int unit, 
    bcm_l3_intf_t *intf, 
    bcm_tunnel_initiator_t *tunnel) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_initiator_create(
    int unit, 
    bcm_l3_intf_t *intf, 
    bcm_tunnel_initiator_t *tunnel)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(tunnel) BCM_API_XLATE_PORT_A2P(unit,&tunnel->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_initiator_create_dispatch[dtype](unit, intf, tunnel);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(tunnel) BCM_API_XLATE_PORT_P2A(unit,&tunnel->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_initiator_create", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_initiator_get( \
    int unit, bcm_l3_intf_t *intf, bcm_tunnel_initiator_t *tunnel);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_initiator_get,
static int (*_tunnel_initiator_get_dispatch[])(
    int unit, 
    bcm_l3_intf_t *intf, 
    bcm_tunnel_initiator_t *tunnel) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_initiator_get(
    int unit, 
    bcm_l3_intf_t *intf, 
    bcm_tunnel_initiator_t *tunnel)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_initiator_get_dispatch[dtype](unit, intf, tunnel);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(tunnel) BCM_API_XLATE_PORT_P2A(unit,&tunnel->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_initiator_get", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_initiator_set( \
    int unit, bcm_l3_intf_t *intf, bcm_tunnel_initiator_t *tunnel);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_initiator_set,
static int (*_tunnel_initiator_set_dispatch[])(
    int unit, 
    bcm_l3_intf_t *intf, 
    bcm_tunnel_initiator_t *tunnel) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_initiator_set(
    int unit, 
    bcm_l3_intf_t *intf, 
    bcm_tunnel_initiator_t *tunnel)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(tunnel_tunnel_id);
		BCM_API_XLATE_PORT_COND(tunnel) BCM_API_XLATE_PORT_SAVE(tunnel_tunnel_id,tunnel->tunnel_id);
		BCM_API_XLATE_PORT_COND(tunnel) BCM_API_XLATE_PORT_A2P(unit,&tunnel->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_initiator_set_dispatch[dtype](unit, intf, tunnel);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(tunnel) BCM_API_XLATE_PORT_RESTORE(tunnel->tunnel_id,tunnel_tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_initiator_set", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_initiator_traverse( \
    int unit, bcm_tunnel_initiator_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_initiator_traverse,
static int (*_tunnel_initiator_traverse_dispatch[])(
    int unit, 
    bcm_tunnel_initiator_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_initiator_traverse(
    int unit, 
    bcm_tunnel_initiator_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_initiator_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_initiator_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_terminator_add( \
    int unit, bcm_tunnel_terminator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_terminator_add,
static int (*_tunnel_terminator_add_dispatch[])(
    int unit, 
    bcm_tunnel_terminator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_terminator_add(
    int unit, 
    bcm_tunnel_terminator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_failover_tunnel_id);
		BCM_API_XLATE_PORT_PBMP_DECL(info_pbmp);
		BCM_API_XLATE_PORT_DECL(info_remote_port);
		BCM_API_XLATE_PORT_DECL(info_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_failover_tunnel_id,info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_SAVE(info_pbmp,info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_A2P(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_remote_port,info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_tunnel_id,info->tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_terminator_add_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->failover_tunnel_id,info_failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_RESTORE(info->pbmp,info_pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->remote_port,info_remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->tunnel_id,info_tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_terminator_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_terminator_create( \
    int unit, bcm_tunnel_terminator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_terminator_create,
static int (*_tunnel_terminator_create_dispatch[])(
    int unit, 
    bcm_tunnel_terminator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_terminator_create(
    int unit, 
    bcm_tunnel_terminator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_A2P(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_terminator_create_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_P2A(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_terminator_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_terminator_delete( \
    int unit, bcm_tunnel_terminator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_terminator_delete,
static int (*_tunnel_terminator_delete_dispatch[])(
    int unit, 
    bcm_tunnel_terminator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_terminator_delete(
    int unit, 
    bcm_tunnel_terminator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_failover_tunnel_id);
		BCM_API_XLATE_PORT_PBMP_DECL(info_pbmp);
		BCM_API_XLATE_PORT_DECL(info_remote_port);
		BCM_API_XLATE_PORT_DECL(info_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_failover_tunnel_id,info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_SAVE(info_pbmp,info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_A2P(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_remote_port,info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_tunnel_id,info->tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_terminator_delete_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->failover_tunnel_id,info_failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_RESTORE(info->pbmp,info_pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->remote_port,info_remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->tunnel_id,info_tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_terminator_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_terminator_get( \
    int unit, bcm_tunnel_terminator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_terminator_get,
static int (*_tunnel_terminator_get_dispatch[])(
    int unit, 
    bcm_tunnel_terminator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_terminator_get(
    int unit, 
    bcm_tunnel_terminator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_A2P(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_terminator_get_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_P2A(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_terminator_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_terminator_traverse( \
    int unit, bcm_tunnel_terminator_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_terminator_traverse,
static int (*_tunnel_terminator_traverse_dispatch[])(
    int unit, 
    bcm_tunnel_terminator_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_terminator_traverse(
    int unit, 
    bcm_tunnel_terminator_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_terminator_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_terminator_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_terminator_update( \
    int unit, bcm_tunnel_terminator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_terminator_update,
static int (*_tunnel_terminator_update_dispatch[])(
    int unit, 
    bcm_tunnel_terminator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_terminator_update(
    int unit, 
    bcm_tunnel_terminator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(info_failover_tunnel_id);
		BCM_API_XLATE_PORT_PBMP_DECL(info_pbmp);
		BCM_API_XLATE_PORT_DECL(info_remote_port);
		BCM_API_XLATE_PORT_DECL(info_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_failover_tunnel_id,info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_SAVE(info_pbmp,info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_A2P(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_remote_port,info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_SAVE(info_tunnel_id,info->tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_terminator_update_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->failover_tunnel_id,info_failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_RESTORE(info->pbmp,info_pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->remote_port,info_remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_RESTORE(info->tunnel_id,info_tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_terminator_update", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_terminator_vlan_get( \
    int unit, bcm_gport_t tunnel, bcm_vlan_vector_t *vlan_vec);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_terminator_vlan_get,
static int (*_tunnel_terminator_vlan_get_dispatch[])(
    int unit, 
    bcm_gport_t tunnel, 
    bcm_vlan_vector_t *vlan_vec) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_terminator_vlan_get(
    int unit, 
    bcm_gport_t tunnel, 
    bcm_vlan_vector_t *vlan_vec)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&tunnel);
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_terminator_vlan_get_dispatch[dtype](unit, tunnel, vlan_vec);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_terminator_vlan_get", 3, 2, unit, tunnel, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tunnel_terminator_vlan_set( \
    int unit, bcm_gport_t tunnel, bcm_vlan_vector_t vlan_vec);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tunnel_terminator_vlan_set,
static int (*_tunnel_terminator_vlan_set_dispatch[])(
    int unit, 
    bcm_gport_t tunnel, 
    bcm_vlan_vector_t vlan_vec) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tunnel_terminator_vlan_set(
    int unit, 
    bcm_gport_t tunnel, 
    bcm_vlan_vector_t vlan_vec)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&tunnel);
		dtype = BCM_DTYPE(unit);
		r_rv = _tunnel_terminator_vlan_set_dispatch[dtype](unit, tunnel, vlan_vec);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tunnel_terminator_vlan_set", 3, 2, unit, tunnel, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tx( \
    int unit, bcm_pkt_t *tx_pkt, void *cookie);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tx,
static int (*_tx_dispatch[])(
    int unit, 
    bcm_pkt_t *tx_pkt, 
    void *cookie) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tx(
    int unit, 
    bcm_pkt_t *tx_pkt, 
    void *cookie)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tx_dispatch[dtype](unit, tx_pkt, cookie);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tx", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tx_array( \
    int unit, bcm_pkt_t **pkt, int count, bcm_pkt_cb_f all_done_cb, void *cookie);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tx_array,
static int (*_tx_array_dispatch[])(
    int unit, 
    bcm_pkt_t **pkt, 
    int count, 
    bcm_pkt_cb_f all_done_cb, 
    void *cookie) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tx_array(
    int unit, 
    bcm_pkt_t **pkt, 
    int count, 
    bcm_pkt_cb_f all_done_cb, 
    void *cookie)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tx_array_dispatch[dtype](unit, pkt, count, all_done_cb, cookie);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tx_array", 5, 1, unit, 0, 0, r_rv);
	return r_rv;
}

#if defined(BROADCOM_DEBUG)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tx_dv_dump( \
    int unit, void *dv_p);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tx_dv_dump,
static int (*_tx_dv_dump_dispatch[])(
    int unit, 
    void *dv_p) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tx_dv_dump(
    int unit, 
    void *dv_p)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tx_dv_dump_dispatch[dtype](unit, dv_p);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tx_dv_dump", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tx_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tx_init,
static int (*_tx_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tx_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tx_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tx_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tx_list( \
    int unit, bcm_pkt_t *pkt, bcm_pkt_cb_f all_done_cb, void *cookie);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tx_list,
static int (*_tx_list_dispatch[])(
    int unit, 
    bcm_pkt_t *pkt, 
    bcm_pkt_cb_f all_done_cb, 
    void *cookie) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tx_list(
    int unit, 
    bcm_pkt_t *pkt, 
    bcm_pkt_cb_f all_done_cb, 
    void *cookie)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tx_list_dispatch[dtype](unit, pkt, all_done_cb, cookie);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tx_list", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tx_pkt_l2_map( \
    int unit, bcm_pkt_t *pkt, bcm_mac_t dest_mac, int vid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tx_pkt_l2_map,
static int (*_tx_pkt_l2_map_dispatch[])(
    int unit, 
    bcm_pkt_t *pkt, 
    bcm_mac_t dest_mac, 
    int vid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tx_pkt_l2_map(
    int unit, 
    bcm_pkt_t *pkt, 
    bcm_mac_t dest_mac, 
    int vid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tx_pkt_l2_map_dispatch[dtype](unit, pkt, dest_mac, vid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tx_pkt_l2_map", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tx_pkt_setup( \
    int unit, bcm_pkt_t *tx_pkt);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tx_pkt_setup,
static int (*_tx_pkt_setup_dispatch[])(
    int unit, 
    bcm_pkt_t *tx_pkt) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tx_pkt_setup(
    int unit, 
    bcm_pkt_t *tx_pkt)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tx_pkt_setup_dispatch[dtype](unit, tx_pkt);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tx_pkt_setup", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

#if defined(BROADCOM_DEBUG)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_tx_show( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_tx_show,
static int (*_tx_show_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_tx_show(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _tx_show_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_tx_show", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_txbeacon_destroy( \
    int unit, bcm_txbeacon_pkt_id_t pkt_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_txbeacon_destroy,
static int (*_txbeacon_destroy_dispatch[])(
    int unit, 
    bcm_txbeacon_pkt_id_t pkt_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_txbeacon_destroy(
    int unit, 
    bcm_txbeacon_pkt_id_t pkt_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _txbeacon_destroy_dispatch[dtype](unit, pkt_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_txbeacon_destroy", 2, 2, unit, pkt_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_txbeacon_init( \
    int unit, int uC);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_txbeacon_init,
static int (*_txbeacon_init_dispatch[])(
    int unit, 
    int uC) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_txbeacon_init(
    int unit, 
    int uC)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _txbeacon_init_dispatch[dtype](unit, uC);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_txbeacon_init", 2, 2, unit, uC, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_txbeacon_pkt_get( \
    int unit, bcm_txbeacon_t *txbeacon);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_txbeacon_pkt_get,
static int (*_txbeacon_pkt_get_dispatch[])(
    int unit, 
    bcm_txbeacon_t *txbeacon) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_txbeacon_pkt_get(
    int unit, 
    bcm_txbeacon_t *txbeacon)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _txbeacon_pkt_get_dispatch[dtype](unit, txbeacon);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_txbeacon_pkt_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_txbeacon_pkt_setup( \
    int unit, bcm_txbeacon_t *txbeacon);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_txbeacon_pkt_setup,
static int (*_txbeacon_pkt_setup_dispatch[])(
    int unit, 
    bcm_txbeacon_t *txbeacon) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_txbeacon_pkt_setup(
    int unit, 
    bcm_txbeacon_t *txbeacon)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _txbeacon_pkt_setup_dispatch[dtype](unit, txbeacon);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_txbeacon_pkt_setup", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_txbeacon_start( \
    int unit, bcm_txbeacon_pkt_id_t pkt_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_txbeacon_start,
static int (*_txbeacon_start_dispatch[])(
    int unit, 
    bcm_txbeacon_pkt_id_t pkt_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_txbeacon_start(
    int unit, 
    bcm_txbeacon_pkt_id_t pkt_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _txbeacon_start_dispatch[dtype](unit, pkt_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_txbeacon_start", 2, 2, unit, pkt_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_txbeacon_stop( \
    int unit, bcm_txbeacon_pkt_id_t pkt_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_txbeacon_stop,
static int (*_txbeacon_stop_dispatch[])(
    int unit, 
    bcm_txbeacon_pkt_id_t pkt_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_txbeacon_stop(
    int unit, 
    bcm_txbeacon_pkt_id_t pkt_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _txbeacon_stop_dispatch[dtype](unit, pkt_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_txbeacon_stop", 2, 2, unit, pkt_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_txbeacon_traverse( \
    int unit, bcm_txbeacon_traverse_cb_t trav_fn, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_txbeacon_traverse,
static int (*_txbeacon_traverse_dispatch[])(
    int unit, 
    bcm_txbeacon_traverse_cb_t trav_fn, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_txbeacon_traverse(
    int unit, 
    bcm_txbeacon_traverse_cb_t trav_fn, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _txbeacon_traverse_dispatch[dtype](unit, trav_fn, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_txbeacon_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_udf_create( \
    int unit, bcm_udf_alloc_hints_t *hints, bcm_udf_t *udf_info, bcm_udf_id_t *udf_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_udf_create,
static int (*_udf_create_dispatch[])(
    int unit, 
    bcm_udf_alloc_hints_t *hints, 
    bcm_udf_t *udf_info, 
    bcm_udf_id_t *udf_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_udf_create(
    int unit, 
    bcm_udf_alloc_hints_t *hints, 
    bcm_udf_t *udf_info, 
    bcm_udf_id_t *udf_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _udf_create_dispatch[dtype](unit, hints, udf_info, udf_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_udf_create", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_udf_destroy( \
    int unit, bcm_udf_id_t udf_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_udf_destroy,
static int (*_udf_destroy_dispatch[])(
    int unit, 
    bcm_udf_id_t udf_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_udf_destroy(
    int unit, 
    bcm_udf_id_t udf_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _udf_destroy_dispatch[dtype](unit, udf_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_udf_destroy", 2, 2, unit, udf_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_udf_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_udf_detach,
static int (*_udf_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_udf_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _udf_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_udf_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_udf_get( \
    int unit, bcm_udf_id_t udf_id, bcm_udf_t *udf_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_udf_get,
static int (*_udf_get_dispatch[])(
    int unit, 
    bcm_udf_id_t udf_id, 
    bcm_udf_t *udf_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_udf_get(
    int unit, 
    bcm_udf_id_t udf_id, 
    bcm_udf_t *udf_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _udf_get_dispatch[dtype](unit, udf_id, udf_info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_udf_get", 3, 2, unit, udf_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_udf_get_all( \
    int unit, int max, bcm_udf_id_t *udf_id_list, int *actual);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_udf_get_all,
static int (*_udf_get_all_dispatch[])(
    int unit, 
    int max, 
    bcm_udf_id_t *udf_id_list, 
    int *actual) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_udf_get_all(
    int unit, 
    int max, 
    bcm_udf_id_t *udf_id_list, 
    int *actual)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _udf_get_all_dispatch[dtype](unit, max, udf_id_list, actual);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_udf_get_all", 4, 2, unit, max, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_udf_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_udf_init,
static int (*_udf_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_udf_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _udf_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_udf_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_udf_pkt_format_add( \
    int unit, bcm_udf_id_t udf_id, bcm_udf_pkt_format_id_t pkt_format_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_udf_pkt_format_add,
static int (*_udf_pkt_format_add_dispatch[])(
    int unit, 
    bcm_udf_id_t udf_id, 
    bcm_udf_pkt_format_id_t pkt_format_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_udf_pkt_format_add(
    int unit, 
    bcm_udf_id_t udf_id, 
    bcm_udf_pkt_format_id_t pkt_format_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _udf_pkt_format_add_dispatch[dtype](unit, udf_id, pkt_format_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_udf_pkt_format_add", 3, 3, unit, udf_id, pkt_format_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_udf_pkt_format_create( \
    int unit, bcm_udf_pkt_format_options_t options, bcm_udf_pkt_format_info_t *pkt_format, bcm_udf_pkt_format_id_t *pkt_format_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_udf_pkt_format_create,
static int (*_udf_pkt_format_create_dispatch[])(
    int unit, 
    bcm_udf_pkt_format_options_t options, 
    bcm_udf_pkt_format_info_t *pkt_format, 
    bcm_udf_pkt_format_id_t *pkt_format_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_udf_pkt_format_create(
    int unit, 
    bcm_udf_pkt_format_options_t options, 
    bcm_udf_pkt_format_info_t *pkt_format, 
    bcm_udf_pkt_format_id_t *pkt_format_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _udf_pkt_format_create_dispatch[dtype](unit, options, pkt_format, pkt_format_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_udf_pkt_format_create", 4, 2, unit, options, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_udf_pkt_format_delete( \
    int unit, bcm_udf_id_t udf_id, bcm_udf_pkt_format_id_t pkt_format_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_udf_pkt_format_delete,
static int (*_udf_pkt_format_delete_dispatch[])(
    int unit, 
    bcm_udf_id_t udf_id, 
    bcm_udf_pkt_format_id_t pkt_format_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_udf_pkt_format_delete(
    int unit, 
    bcm_udf_id_t udf_id, 
    bcm_udf_pkt_format_id_t pkt_format_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _udf_pkt_format_delete_dispatch[dtype](unit, udf_id, pkt_format_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_udf_pkt_format_delete", 3, 3, unit, udf_id, pkt_format_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_udf_pkt_format_delete_all( \
    int unit, bcm_udf_id_t udf_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_udf_pkt_format_delete_all,
static int (*_udf_pkt_format_delete_all_dispatch[])(
    int unit, 
    bcm_udf_id_t udf_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_udf_pkt_format_delete_all(
    int unit, 
    bcm_udf_id_t udf_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _udf_pkt_format_delete_all_dispatch[dtype](unit, udf_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_udf_pkt_format_delete_all", 2, 2, unit, udf_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_udf_pkt_format_destroy( \
    int unit, bcm_udf_pkt_format_id_t pkt_format_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_udf_pkt_format_destroy,
static int (*_udf_pkt_format_destroy_dispatch[])(
    int unit, 
    bcm_udf_pkt_format_id_t pkt_format_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_udf_pkt_format_destroy(
    int unit, 
    bcm_udf_pkt_format_id_t pkt_format_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _udf_pkt_format_destroy_dispatch[dtype](unit, pkt_format_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_udf_pkt_format_destroy", 2, 2, unit, pkt_format_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_udf_pkt_format_get( \
    int unit, bcm_udf_pkt_format_id_t pkt_format_id, int max, bcm_udf_id_t *udf_id_list, int *actual);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_udf_pkt_format_get,
static int (*_udf_pkt_format_get_dispatch[])(
    int unit, 
    bcm_udf_pkt_format_id_t pkt_format_id, 
    int max, 
    bcm_udf_id_t *udf_id_list, 
    int *actual) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_udf_pkt_format_get(
    int unit, 
    bcm_udf_pkt_format_id_t pkt_format_id, 
    int max, 
    bcm_udf_id_t *udf_id_list, 
    int *actual)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _udf_pkt_format_get_dispatch[dtype](unit, pkt_format_id, max, udf_id_list, actual);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_udf_pkt_format_get", 5, 3, unit, pkt_format_id, max, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_udf_pkt_format_get_all( \
    int unit, bcm_udf_id_t udf_id, int max, bcm_udf_pkt_format_id_t *pkt_format_id_list, int *actual);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_udf_pkt_format_get_all,
static int (*_udf_pkt_format_get_all_dispatch[])(
    int unit, 
    bcm_udf_id_t udf_id, 
    int max, 
    bcm_udf_pkt_format_id_t *pkt_format_id_list, 
    int *actual) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_udf_pkt_format_get_all(
    int unit, 
    bcm_udf_id_t udf_id, 
    int max, 
    bcm_udf_pkt_format_id_t *pkt_format_id_list, 
    int *actual)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _udf_pkt_format_get_all_dispatch[dtype](unit, udf_id, max, pkt_format_id_list, actual);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_udf_pkt_format_get_all", 5, 3, unit, udf_id, max, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_udf_pkt_format_info_get( \
    int unit, bcm_udf_pkt_format_id_t pkt_format_id, bcm_udf_pkt_format_info_t *pkt_format);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_udf_pkt_format_info_get,
static int (*_udf_pkt_format_info_get_dispatch[])(
    int unit, 
    bcm_udf_pkt_format_id_t pkt_format_id, 
    bcm_udf_pkt_format_info_t *pkt_format) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_udf_pkt_format_info_get(
    int unit, 
    bcm_udf_pkt_format_id_t pkt_format_id, 
    bcm_udf_pkt_format_info_t *pkt_format)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _udf_pkt_format_info_get_dispatch[dtype](unit, pkt_format_id, pkt_format);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_udf_pkt_format_info_get", 3, 2, unit, pkt_format_id, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_block_get( \
    int unit, bcm_vlan_t vlan, bcm_vlan_block_t *vlan_block);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_block_get,
static int (*_vlan_block_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_block_t *vlan_block) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_block_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_block_t *vlan_block)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_block_get_dispatch[dtype](unit, vlan, vlan_block);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_P2A(unit,&vlan_block->broadcast);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_P2A(unit,&vlan_block->known_multicast);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_P2A(unit,&vlan_block->unknown_multicast);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_P2A(unit,&vlan_block->unknown_unicast);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_block_get", 3, 2, unit, vlan, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_block_set( \
    int unit, bcm_vlan_t vlan, bcm_vlan_block_t *vlan_block);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_block_set,
static int (*_vlan_block_set_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_block_t *vlan_block) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_block_set(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_block_t *vlan_block)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(vlan_block_broadcast);
		BCM_API_XLATE_PORT_PBMP_DECL(vlan_block_known_multicast);
		BCM_API_XLATE_PORT_PBMP_DECL(vlan_block_unknown_multicast);
		BCM_API_XLATE_PORT_PBMP_DECL(vlan_block_unknown_unicast);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_SAVE(vlan_block_broadcast,vlan_block->broadcast);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_A2P(unit,&vlan_block->broadcast);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_SAVE(vlan_block_known_multicast,vlan_block->known_multicast);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_A2P(unit,&vlan_block->known_multicast);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_SAVE(vlan_block_unknown_multicast,vlan_block->unknown_multicast);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_A2P(unit,&vlan_block->unknown_multicast);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_SAVE(vlan_block_unknown_unicast,vlan_block->unknown_unicast);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_A2P(unit,&vlan_block->unknown_unicast);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_block_set_dispatch[dtype](unit, vlan, vlan_block);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_RESTORE(vlan_block->broadcast,vlan_block_broadcast);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_RESTORE(vlan_block->known_multicast,vlan_block_known_multicast);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_RESTORE(vlan_block->unknown_multicast,vlan_block_unknown_multicast);
		BCM_API_XLATE_PORT_COND(vlan_block) BCM_API_XLATE_PORT_PBMP_RESTORE(vlan_block->unknown_unicast,vlan_block_unknown_unicast);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_block_set", 3, 2, unit, vlan, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_control_get( \
    int unit, bcm_vlan_control_t type, int *arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_control_get,
static int (*_vlan_control_get_dispatch[])(
    int unit, 
    bcm_vlan_control_t type, 
    int *arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_control_get(
    int unit, 
    bcm_vlan_control_t type, 
    int *arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_control_get_dispatch[dtype](unit, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_control_get", 3, 2, unit, type, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_control_port_get( \
    int unit, int port, bcm_vlan_control_port_t type, int *arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_control_port_get,
static int (*_vlan_control_port_get_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_control_port_t type, 
    int *arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_control_port_get(
    int unit, 
    int port, 
    bcm_vlan_control_port_t type, 
    int *arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_control_port_get_dispatch[dtype](unit, port, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_control_port_get", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_control_port_set( \
    int unit, int port, bcm_vlan_control_port_t type, int arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_control_port_set,
static int (*_vlan_control_port_set_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_control_port_t type, 
    int arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_control_port_set(
    int unit, 
    int port, 
    bcm_vlan_control_port_t type, 
    int arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_control_port_set_dispatch[dtype](unit, port, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_control_port_set", 4, 3, unit, port, type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_control_set( \
    int unit, bcm_vlan_control_t type, int arg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_control_set,
static int (*_vlan_control_set_dispatch[])(
    int unit, 
    bcm_vlan_control_t type, 
    int arg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_control_set(
    int unit, 
    bcm_vlan_control_t type, 
    int arg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_control_set_dispatch[dtype](unit, type, arg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_control_set", 3, 3, unit, type, arg, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_control_vlan_get( \
    int unit, bcm_vlan_t vlan, bcm_vlan_control_vlan_t *control);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_control_vlan_get,
static int (*_vlan_control_vlan_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_control_vlan_t *control) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_control_vlan_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_control_vlan_t *control)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_control_vlan_get_dispatch[dtype](unit, vlan, control);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_control_vlan_get", 3, 2, unit, vlan, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_control_vlan_selective_get( \
    int unit, bcm_vlan_t vlan, uint32 valid_fields, bcm_vlan_control_vlan_t *control);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_control_vlan_selective_get,
static int (*_vlan_control_vlan_selective_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 valid_fields, 
    bcm_vlan_control_vlan_t *control) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_control_vlan_selective_get(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 valid_fields, 
    bcm_vlan_control_vlan_t *control)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_control_vlan_selective_get_dispatch[dtype](unit, vlan, valid_fields, control);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_control_vlan_selective_get", 4, 3, unit, vlan, valid_fields, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_control_vlan_selective_set( \
    int unit, bcm_vlan_t vlan, uint32 valid_fields, bcm_vlan_control_vlan_t *control);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_control_vlan_selective_set,
static int (*_vlan_control_vlan_selective_set_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 valid_fields, 
    bcm_vlan_control_vlan_t *control) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_control_vlan_selective_set(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 valid_fields, 
    bcm_vlan_control_vlan_t *control)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_control_vlan_selective_set_dispatch[dtype](unit, vlan, valid_fields, control);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_control_vlan_selective_set", 4, 3, unit, vlan, valid_fields, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_control_vlan_set( \
    int unit, bcm_vlan_t vlan, bcm_vlan_control_vlan_t control);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_control_vlan_set,
static int (*_vlan_control_vlan_set_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_control_vlan_t control) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_control_vlan_set(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_control_vlan_t control)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_control_vlan_set_dispatch[dtype](unit, vlan, control);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_control_vlan_set", 3, 2, unit, vlan, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_create( \
    int unit, bcm_vlan_t vid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_create,
static int (*_vlan_create_dispatch[])(
    int unit, 
    bcm_vlan_t vid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_create(
    int unit, 
    bcm_vlan_t vid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_create_dispatch[dtype](unit, vid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_create", 2, 2, unit, vid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_cross_connect_add( \
    int unit, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_gport_t port_1, bcm_gport_t port_2);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_cross_connect_add,
static int (*_vlan_cross_connect_add_dispatch[])(
    int unit, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_gport_t port_1, 
    bcm_gport_t port_2) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_cross_connect_add(
    int unit, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_gport_t port_1, 
    bcm_gport_t port_2)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port_1);
		BCM_API_XLATE_PORT_A2P(unit,&port_2);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_cross_connect_add_dispatch[dtype](unit, outer_vlan, inner_vlan, port_1, port_2);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_cross_connect_add", 5, 3, unit, outer_vlan, inner_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_cross_connect_delete( \
    int unit, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_cross_connect_delete,
static int (*_vlan_cross_connect_delete_dispatch[])(
    int unit, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_cross_connect_delete(
    int unit, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_cross_connect_delete_dispatch[dtype](unit, outer_vlan, inner_vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_cross_connect_delete", 3, 3, unit, outer_vlan, inner_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_cross_connect_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_cross_connect_delete_all,
static int (*_vlan_cross_connect_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_cross_connect_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_cross_connect_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_cross_connect_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_cross_connect_traverse( \
    int unit, bcm_vlan_cross_connect_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_cross_connect_traverse,
static int (*_vlan_cross_connect_traverse_dispatch[])(
    int unit, 
    bcm_vlan_cross_connect_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_cross_connect_traverse(
    int unit, 
    bcm_vlan_cross_connect_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_cross_connect_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_cross_connect_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_default_get( \
    int unit, bcm_vlan_t *vid_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_default_get,
static int (*_vlan_default_get_dispatch[])(
    int unit, 
    bcm_vlan_t *vid_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_default_get(
    int unit, 
    bcm_vlan_t *vid_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_default_get_dispatch[dtype](unit, vid_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_default_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_default_set( \
    int unit, bcm_vlan_t vid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_default_set,
static int (*_vlan_default_set_dispatch[])(
    int unit, 
    bcm_vlan_t vid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_default_set(
    int unit, 
    bcm_vlan_t vid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_default_set_dispatch[dtype](unit, vid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_default_set", 2, 2, unit, vid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_destroy( \
    int unit, bcm_vlan_t vid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_destroy,
static int (*_vlan_destroy_dispatch[])(
    int unit, 
    bcm_vlan_t vid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_destroy(
    int unit, 
    bcm_vlan_t vid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_destroy_dispatch[dtype](unit, vid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_destroy", 2, 2, unit, vid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_destroy_all,
static int (*_vlan_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_dtag_add( \
    int unit, int port, bcm_vlan_t old_vid, bcm_vlan_t new_vid, int prio);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_dtag_add,
static int (*_vlan_dtag_add_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_t old_vid, 
    bcm_vlan_t new_vid, 
    int prio) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_dtag_add(
    int unit, 
    int port, 
    bcm_vlan_t old_vid, 
    bcm_vlan_t new_vid, 
    int prio)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_dtag_add_dispatch[dtype](unit, port, old_vid, new_vid, prio);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_dtag_add", 5, 3, unit, port, old_vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_dtag_delete( \
    int unit, int port, bcm_vlan_t old_vid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_dtag_delete,
static int (*_vlan_dtag_delete_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_t old_vid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_dtag_delete(
    int unit, 
    int port, 
    bcm_vlan_t old_vid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_dtag_delete_dispatch[dtype](unit, port, old_vid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_dtag_delete", 3, 3, unit, port, old_vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_dtag_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_dtag_delete_all,
static int (*_vlan_dtag_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_dtag_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_dtag_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_dtag_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_dtag_get( \
    int unit, int port, bcm_vlan_t old_vid, bcm_vlan_t *new_vid, int *prio);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_dtag_get,
static int (*_vlan_dtag_get_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_t old_vid, 
    bcm_vlan_t *new_vid, 
    int *prio) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_dtag_get(
    int unit, 
    int port, 
    bcm_vlan_t old_vid, 
    bcm_vlan_t *new_vid, 
    int *prio)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_dtag_get_dispatch[dtype](unit, port, old_vid, new_vid, prio);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_dtag_get", 5, 3, unit, port, old_vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_dtag_range_add( \
    int unit, int port, bcm_vlan_t old_vid_low, bcm_vlan_t old_vid_high, bcm_vlan_t new_vid, int int_prio);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_dtag_range_add,
static int (*_vlan_dtag_range_add_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_t old_vid_low, 
    bcm_vlan_t old_vid_high, 
    bcm_vlan_t new_vid, 
    int int_prio) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_dtag_range_add(
    int unit, 
    int port, 
    bcm_vlan_t old_vid_low, 
    bcm_vlan_t old_vid_high, 
    bcm_vlan_t new_vid, 
    int int_prio)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_dtag_range_add_dispatch[dtype](unit, port, old_vid_low, old_vid_high, new_vid, int_prio);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_dtag_range_add", 6, 3, unit, port, old_vid_low, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_dtag_range_delete( \
    int unit, int port, bcm_vlan_t old_vid_low, bcm_vlan_t old_vid_high);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_dtag_range_delete,
static int (*_vlan_dtag_range_delete_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_t old_vid_low, 
    bcm_vlan_t old_vid_high) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_dtag_range_delete(
    int unit, 
    int port, 
    bcm_vlan_t old_vid_low, 
    bcm_vlan_t old_vid_high)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_dtag_range_delete_dispatch[dtype](unit, port, old_vid_low, old_vid_high);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_dtag_range_delete", 4, 3, unit, port, old_vid_low, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_dtag_range_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_dtag_range_delete_all,
static int (*_vlan_dtag_range_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_dtag_range_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_dtag_range_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_dtag_range_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_dtag_range_get( \
    int unit, int port, bcm_vlan_t old_vid_low, bcm_vlan_t old_vid_high, bcm_vlan_t *new_vid, int *prio);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_dtag_range_get,
static int (*_vlan_dtag_range_get_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_t old_vid_low, 
    bcm_vlan_t old_vid_high, 
    bcm_vlan_t *new_vid, 
    int *prio) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_dtag_range_get(
    int unit, 
    int port, 
    bcm_vlan_t old_vid_low, 
    bcm_vlan_t old_vid_high, 
    bcm_vlan_t *new_vid, 
    int *prio)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_dtag_range_get_dispatch[dtype](unit, port, old_vid_low, old_vid_high, new_vid, prio);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_dtag_range_get", 6, 3, unit, port, old_vid_low, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_dtag_range_traverse( \
    int unit, bcm_vlan_dtag_range_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_dtag_range_traverse,
static int (*_vlan_dtag_range_traverse_dispatch[])(
    int unit, 
    bcm_vlan_dtag_range_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_dtag_range_traverse(
    int unit, 
    bcm_vlan_dtag_range_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_dtag_range_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_dtag_range_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_dtag_traverse( \
    int unit, bcm_vlan_dtag_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_dtag_traverse,
static int (*_vlan_dtag_traverse_dispatch[])(
    int unit, 
    bcm_vlan_dtag_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_dtag_traverse(
    int unit, 
    bcm_vlan_dtag_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_dtag_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_dtag_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_egress_policer_get( \
    int unit, bcm_vlan_t vlan, bcm_policer_t *policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_egress_policer_get,
static int (*_vlan_egress_policer_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_policer_t *policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_egress_policer_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_policer_t *policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_egress_policer_get_dispatch[dtype](unit, vlan, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_egress_policer_get", 3, 2, unit, vlan, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_egress_policer_set( \
    int unit, bcm_vlan_t vlan, bcm_policer_t policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_egress_policer_set,
static int (*_vlan_egress_policer_set_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_policer_t policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_egress_policer_set(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_policer_t policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_egress_policer_set_dispatch[dtype](unit, vlan, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_egress_policer_set", 3, 3, unit, vlan, policer_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_gport_add( \
    int unit, bcm_vlan_t vlan, bcm_gport_t port, int flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_gport_add,
static int (*_vlan_gport_add_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_gport_t port, 
    int flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_gport_add(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_gport_t port, 
    int flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_gport_add_dispatch[dtype](unit, vlan, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_gport_add", 4, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_gport_delete( \
    int unit, bcm_vlan_t vlan, bcm_gport_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_gport_delete,
static int (*_vlan_gport_delete_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_gport_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_gport_delete(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_gport_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_gport_delete_dispatch[dtype](unit, vlan, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_gport_delete", 3, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_gport_delete_all( \
    int unit, bcm_vlan_t vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_gport_delete_all,
static int (*_vlan_gport_delete_all_dispatch[])(
    int unit, 
    bcm_vlan_t vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_gport_delete_all(
    int unit, 
    bcm_vlan_t vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_gport_delete_all_dispatch[dtype](unit, vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_gport_delete_all", 2, 2, unit, vlan, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_gport_get( \
    int unit, bcm_vlan_t vlan, bcm_gport_t port, int *flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_gport_get,
static int (*_vlan_gport_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_gport_t port, 
    int *flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_gport_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_gport_t port, 
    int *flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_gport_get_dispatch[dtype](unit, vlan, port, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_gport_get", 4, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_gport_get_all( \
    int unit, bcm_vlan_t vlan, int array_max, bcm_gport_t *gport_array, int *flags_array, int *array_size);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_gport_get_all,
static int (*_vlan_gport_get_all_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    int array_max, 
    bcm_gport_t *gport_array, 
    int *flags_array, 
    int *array_size) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_gport_get_all(
    int unit, 
    bcm_vlan_t vlan, 
    int array_max, 
    bcm_gport_t *gport_array, 
    int *flags_array, 
    int *array_size)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_gport_get_all_dispatch[dtype](unit, vlan, array_max, gport_array, flags_array, array_size);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(array_max,idx)
				BCM_API_XLATE_PORT_COND(gport_array) BCM_API_XLATE_PORT_P2A(unit,&(gport_array)[idx]);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_gport_get_all", 6, 3, unit, vlan, array_max, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_gport_info_get( \
    int unit, bcm_vlan_gport_info_t *vlan_gport_info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_gport_info_get,
static int (*_vlan_gport_info_get_dispatch[])(
    int unit, 
    bcm_vlan_gport_info_t *vlan_gport_info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_gport_info_get(
    int unit, 
    bcm_vlan_gport_info_t *vlan_gport_info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(vlan_gport_info) BCM_API_XLATE_PORT_A2P(unit,&vlan_gport_info->gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_gport_info_get_dispatch[dtype](unit, vlan_gport_info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(vlan_gport_info) BCM_API_XLATE_PORT_P2A(unit,&vlan_gport_info->gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_gport_info_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_init,
static int (*_vlan_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_ip_action_add( \
    int unit, bcm_vlan_ip_t *vlan_ip, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_ip_action_add,
static int (*_vlan_ip_action_add_dispatch[])(
    int unit, 
    bcm_vlan_ip_t *vlan_ip, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_ip_action_add(
    int unit, 
    bcm_vlan_ip_t *vlan_ip, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_ip_action_add_dispatch[dtype](unit, vlan_ip, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_ip_action_add", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_ip_action_delete( \
    int unit, bcm_vlan_ip_t *vlan_ip);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_ip_action_delete,
static int (*_vlan_ip_action_delete_dispatch[])(
    int unit, 
    bcm_vlan_ip_t *vlan_ip) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_ip_action_delete(
    int unit, 
    bcm_vlan_ip_t *vlan_ip)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_ip_action_delete_dispatch[dtype](unit, vlan_ip);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_ip_action_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_ip_action_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_ip_action_delete_all,
static int (*_vlan_ip_action_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_ip_action_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_ip_action_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_ip_action_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_ip_action_get( \
    int unit, bcm_vlan_ip_t *vlan_ip, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_ip_action_get,
static int (*_vlan_ip_action_get_dispatch[])(
    int unit, 
    bcm_vlan_ip_t *vlan_ip, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_ip_action_get(
    int unit, 
    bcm_vlan_ip_t *vlan_ip, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_ip_action_get_dispatch[dtype](unit, vlan_ip, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_ip_action_get", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_ip_action_traverse( \
    int unit, bcm_vlan_ip_action_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_ip_action_traverse,
static int (*_vlan_ip_action_traverse_dispatch[])(
    int unit, 
    bcm_vlan_ip_action_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_ip_action_traverse(
    int unit, 
    bcm_vlan_ip_action_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_ip_action_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_ip_action_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_ip_add( \
    int unit, bcm_vlan_ip_t *vlan_ip);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_ip_add,
static int (*_vlan_ip_add_dispatch[])(
    int unit, 
    bcm_vlan_ip_t *vlan_ip) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_ip_add(
    int unit, 
    bcm_vlan_ip_t *vlan_ip)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_ip_add_dispatch[dtype](unit, vlan_ip);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_ip_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_ip_delete( \
    int unit, bcm_vlan_ip_t *vlan_ip);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_ip_delete,
static int (*_vlan_ip_delete_dispatch[])(
    int unit, 
    bcm_vlan_ip_t *vlan_ip) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_ip_delete(
    int unit, 
    bcm_vlan_ip_t *vlan_ip)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_ip_delete_dispatch[dtype](unit, vlan_ip);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_ip_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_ip_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_ip_delete_all,
static int (*_vlan_ip_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_ip_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_ip_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_ip_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_list( \
    int unit, bcm_vlan_data_t **listp, int *countp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_list,
static int (*_vlan_list_dispatch[])(
    int unit, 
    bcm_vlan_data_t **listp, 
    int *countp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_list(
    int unit, 
    bcm_vlan_data_t **listp, 
    int *countp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_list_dispatch[dtype](unit, listp, countp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(*countp,idx)
				BCM_API_XLATE_PORT_COND(listp) BCM_API_XLATE_PORT_PBMP_P2A(unit,&(*listp)[idx].port_bitmap);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(*countp,idx)
				BCM_API_XLATE_PORT_COND(listp) BCM_API_XLATE_PORT_PBMP_P2A(unit,&(*listp)[idx].ut_port_bitmap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_list", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_list_by_pbmp( \
    int unit, bcm_pbmp_t ports, bcm_vlan_data_t **listp, int *countp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_list_by_pbmp,
static int (*_vlan_list_by_pbmp_dispatch[])(
    int unit, 
    bcm_pbmp_t ports, 
    bcm_vlan_data_t **listp, 
    int *countp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_list_by_pbmp(
    int unit, 
    bcm_pbmp_t ports, 
    bcm_vlan_data_t **listp, 
    int *countp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_ports);
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_ports,ports);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&ports);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_list_by_pbmp_dispatch[dtype](unit, ports, listp, countp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(ports,t_ports);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(*countp,idx)
				BCM_API_XLATE_PORT_COND(listp) BCM_API_XLATE_PORT_PBMP_P2A(unit,&(*listp)[idx].port_bitmap);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(*countp,idx)
				BCM_API_XLATE_PORT_COND(listp) BCM_API_XLATE_PORT_PBMP_P2A(unit,&(*listp)[idx].ut_port_bitmap);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_list_by_pbmp", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_list_destroy( \
    int unit, bcm_vlan_data_t *list, int count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_list_destroy,
static int (*_vlan_list_destroy_dispatch[])(
    int unit, 
    bcm_vlan_data_t *list, 
    int count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_list_destroy(
    int unit, 
    bcm_vlan_data_t *list, 
    int count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_list_destroy_dispatch[dtype](unit, list, count);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_list_destroy", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_mac_action_add( \
    int unit, bcm_mac_t mac, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_mac_action_add,
static int (*_vlan_mac_action_add_dispatch[])(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_mac_action_add(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_mac_action_add_dispatch[dtype](unit, mac, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_mac_action_add", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_mac_action_delete( \
    int unit, bcm_mac_t mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_mac_action_delete,
static int (*_vlan_mac_action_delete_dispatch[])(
    int unit, 
    bcm_mac_t mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_mac_action_delete(
    int unit, 
    bcm_mac_t mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_mac_action_delete_dispatch[dtype](unit, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_mac_action_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_mac_action_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_mac_action_delete_all,
static int (*_vlan_mac_action_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_mac_action_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_mac_action_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_mac_action_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_mac_action_get( \
    int unit, bcm_mac_t mac, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_mac_action_get,
static int (*_vlan_mac_action_get_dispatch[])(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_mac_action_get(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_mac_action_get_dispatch[dtype](unit, mac, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_mac_action_get", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_mac_action_traverse( \
    int unit, bcm_vlan_mac_action_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_mac_action_traverse,
static int (*_vlan_mac_action_traverse_dispatch[])(
    int unit, 
    bcm_vlan_mac_action_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_mac_action_traverse(
    int unit, 
    bcm_vlan_mac_action_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_mac_action_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_mac_action_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_mac_add( \
    int unit, bcm_mac_t mac, bcm_vlan_t vid, int prio);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_mac_add,
static int (*_vlan_mac_add_dispatch[])(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vid, 
    int prio) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_mac_add(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vid, 
    int prio)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_mac_add_dispatch[dtype](unit, mac, vid, prio);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_mac_add", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_mac_delete( \
    int unit, bcm_mac_t mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_mac_delete,
static int (*_vlan_mac_delete_dispatch[])(
    int unit, 
    bcm_mac_t mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_mac_delete(
    int unit, 
    bcm_mac_t mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_mac_delete_dispatch[dtype](unit, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_mac_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_mac_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_mac_delete_all,
static int (*_vlan_mac_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_mac_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_mac_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_mac_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_mcast_flood_get( \
    int unit, bcm_vlan_t vlan, bcm_vlan_mcast_flood_t *mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_mcast_flood_get,
static int (*_vlan_mcast_flood_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_mcast_flood_t *mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_mcast_flood_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_mcast_flood_t *mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_mcast_flood_get_dispatch[dtype](unit, vlan, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_mcast_flood_get", 3, 2, unit, vlan, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_mcast_flood_set( \
    int unit, bcm_vlan_t vlan, bcm_vlan_mcast_flood_t mode);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_mcast_flood_set,
static int (*_vlan_mcast_flood_set_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_mcast_flood_t mode) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_mcast_flood_set(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_mcast_flood_t mode)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_mcast_flood_set_dispatch[dtype](unit, vlan, mode);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_mcast_flood_set", 3, 3, unit, vlan, mode, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_policer_get( \
    int unit, bcm_vlan_t vlan, bcm_policer_t *policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_policer_get,
static int (*_vlan_policer_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_policer_t *policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_policer_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_policer_t *policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_policer_get_dispatch[dtype](unit, vlan, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_policer_get", 3, 2, unit, vlan, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_policer_set( \
    int unit, bcm_vlan_t vlan, bcm_policer_t policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_policer_set,
static int (*_vlan_policer_set_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_policer_t policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_policer_set(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_policer_t policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_policer_set_dispatch[dtype](unit, vlan, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_policer_set", 3, 3, unit, vlan, policer_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_add( \
    int unit, bcm_vlan_t vid, bcm_pbmp_t pbmp, bcm_pbmp_t ubmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_add,
static int (*_vlan_port_add_dispatch[])(
    int unit, 
    bcm_vlan_t vid, 
    bcm_pbmp_t pbmp, 
    bcm_pbmp_t ubmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_add(
    int unit, 
    bcm_vlan_t vid, 
    bcm_pbmp_t pbmp, 
    bcm_pbmp_t ubmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_DECL(t_ubmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_ubmp,ubmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&ubmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_add_dispatch[dtype](unit, vid, pbmp, ubmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
		BCM_API_XLATE_PORT_PBMP_RESTORE(ubmp,t_ubmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_add", 4, 2, unit, vid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_create( \
    int unit, bcm_vlan_port_t *vlan_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_create,
static int (*_vlan_port_create_dispatch[])(
    int unit, 
    bcm_vlan_port_t *vlan_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_create(
    int unit, 
    bcm_vlan_port_t *vlan_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_A2P(unit,&vlan_port->egress_failover_port_id);
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_A2P(unit,&vlan_port->failover_port_id);
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_A2P(unit,&vlan_port->port);
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_A2P(unit,&vlan_port->vlan_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_create_dispatch[dtype](unit, vlan_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_P2A(unit,&vlan_port->egress_failover_port_id);
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_P2A(unit,&vlan_port->failover_port_id);
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_P2A(unit,&vlan_port->port);
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_P2A(unit,&vlan_port->vlan_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_default_action_delete( \
    int unit, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_default_action_delete,
static int (*_vlan_port_default_action_delete_dispatch[])(
    int unit, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_default_action_delete(
    int unit, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_default_action_delete_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_default_action_delete", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_default_action_get( \
    int unit, bcm_port_t port, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_default_action_get,
static int (*_vlan_port_default_action_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_default_action_get(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_default_action_get_dispatch[dtype](unit, port, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_default_action_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_default_action_set( \
    int unit, bcm_port_t port, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_default_action_set,
static int (*_vlan_port_default_action_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_default_action_set(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_default_action_set_dispatch[dtype](unit, port, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_default_action_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_destroy( \
    int unit, bcm_gport_t gport);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_destroy,
static int (*_vlan_port_destroy_dispatch[])(
    int unit, 
    bcm_gport_t gport) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_destroy(
    int unit, 
    bcm_gport_t gport)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_destroy_dispatch[dtype](unit, gport);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_destroy", 2, 2, unit, gport, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_egress_default_action_delete( \
    int unit, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_egress_default_action_delete,
static int (*_vlan_port_egress_default_action_delete_dispatch[])(
    int unit, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_egress_default_action_delete(
    int unit, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_egress_default_action_delete_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_egress_default_action_delete", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_egress_default_action_get( \
    int unit, bcm_port_t port, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_egress_default_action_get,
static int (*_vlan_port_egress_default_action_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_egress_default_action_get(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_egress_default_action_get_dispatch[dtype](unit, port, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_egress_default_action_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_egress_default_action_set( \
    int unit, bcm_port_t port, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_egress_default_action_set,
static int (*_vlan_port_egress_default_action_set_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_egress_default_action_set(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_egress_default_action_set_dispatch[dtype](unit, port, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_egress_default_action_set", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_egress_policer_get( \
    int unit, bcm_vlan_t vlan, bcm_port_t port, bcm_policer_t *policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_egress_policer_get,
static int (*_vlan_port_egress_policer_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_policer_t *policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_egress_policer_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_policer_t *policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_egress_policer_get_dispatch[dtype](unit, vlan, port, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_egress_policer_get", 4, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_egress_policer_set( \
    int unit, bcm_vlan_t vlan, bcm_port_t port, bcm_policer_t policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_egress_policer_set,
static int (*_vlan_port_egress_policer_set_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_policer_t policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_egress_policer_set(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_policer_t policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_egress_policer_set_dispatch[dtype](unit, vlan, port, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_egress_policer_set", 4, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_find( \
    int unit, bcm_vlan_port_t *vlan_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_find,
static int (*_vlan_port_find_dispatch[])(
    int unit, 
    bcm_vlan_port_t *vlan_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_find(
    int unit, 
    bcm_vlan_port_t *vlan_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_A2P(unit,&vlan_port->egress_failover_port_id);
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_A2P(unit,&vlan_port->failover_port_id);
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_A2P(unit,&vlan_port->port);
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_A2P(unit,&vlan_port->vlan_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_find_dispatch[dtype](unit, vlan_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_P2A(unit,&vlan_port->egress_failover_port_id);
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_P2A(unit,&vlan_port->failover_port_id);
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_P2A(unit,&vlan_port->port);
		BCM_API_XLATE_PORT_COND(vlan_port) BCM_API_XLATE_PORT_P2A(unit,&vlan_port->vlan_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_find", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_get( \
    int unit, bcm_vlan_t vid, bcm_pbmp_t *pbmp, bcm_pbmp_t *ubmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_get,
static int (*_vlan_port_get_dispatch[])(
    int unit, 
    bcm_vlan_t vid, 
    bcm_pbmp_t *pbmp, 
    bcm_pbmp_t *ubmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_get(
    int unit, 
    bcm_vlan_t vid, 
    bcm_pbmp_t *pbmp, 
    bcm_pbmp_t *ubmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_get_dispatch[dtype](unit, vid, pbmp, ubmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,pbmp);
		BCM_API_XLATE_PORT_PBMP_P2A(unit,ubmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_get", 4, 2, unit, vid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_policer_get( \
    int unit, bcm_vlan_t vlan, bcm_port_t port, bcm_policer_t *policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_policer_get,
static int (*_vlan_port_policer_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_policer_t *policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_policer_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_policer_t *policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_policer_get_dispatch[dtype](unit, vlan, port, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_policer_get", 4, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_policer_set( \
    int unit, bcm_vlan_t vlan, bcm_port_t port, bcm_policer_t policer_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_policer_set,
static int (*_vlan_port_policer_set_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_policer_t policer_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_policer_set(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_policer_t policer_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_policer_set_dispatch[dtype](unit, vlan, port, policer_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_policer_set", 4, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_protocol_action_add( \
    int unit, bcm_port_t port, bcm_port_frametype_t frame, bcm_port_ethertype_t ether, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_protocol_action_add,
static int (*_vlan_port_protocol_action_add_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_frametype_t frame, 
    bcm_port_ethertype_t ether, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_protocol_action_add(
    int unit, 
    bcm_port_t port, 
    bcm_port_frametype_t frame, 
    bcm_port_ethertype_t ether, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_protocol_action_add_dispatch[dtype](unit, port, frame, ether, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_protocol_action_add", 5, 3, unit, port, frame, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_protocol_action_delete( \
    int unit, bcm_port_t port, bcm_port_frametype_t frame, bcm_port_ethertype_t ether);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_protocol_action_delete,
static int (*_vlan_port_protocol_action_delete_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_frametype_t frame, 
    bcm_port_ethertype_t ether) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_protocol_action_delete(
    int unit, 
    bcm_port_t port, 
    bcm_port_frametype_t frame, 
    bcm_port_ethertype_t ether)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_protocol_action_delete_dispatch[dtype](unit, port, frame, ether);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_protocol_action_delete", 4, 3, unit, port, frame, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_protocol_action_delete_all( \
    int unit, bcm_port_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_protocol_action_delete_all,
static int (*_vlan_port_protocol_action_delete_all_dispatch[])(
    int unit, 
    bcm_port_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_protocol_action_delete_all(
    int unit, 
    bcm_port_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_protocol_action_delete_all_dispatch[dtype](unit, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_protocol_action_delete_all", 2, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_protocol_action_get( \
    int unit, bcm_port_t port, bcm_port_frametype_t frame, bcm_port_ethertype_t ether, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_protocol_action_get,
static int (*_vlan_port_protocol_action_get_dispatch[])(
    int unit, 
    bcm_port_t port, 
    bcm_port_frametype_t frame, 
    bcm_port_ethertype_t ether, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_protocol_action_get(
    int unit, 
    bcm_port_t port, 
    bcm_port_frametype_t frame, 
    bcm_port_ethertype_t ether, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_protocol_action_get_dispatch[dtype](unit, port, frame, ether, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_protocol_action_get", 5, 3, unit, port, frame, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_protocol_action_traverse( \
    int unit, bcm_vlan_port_protocol_action_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_protocol_action_traverse,
static int (*_vlan_port_protocol_action_traverse_dispatch[])(
    int unit, 
    bcm_vlan_port_protocol_action_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_protocol_action_traverse(
    int unit, 
    bcm_vlan_port_protocol_action_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_protocol_action_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_protocol_action_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_remove( \
    int unit, bcm_vlan_t vid, bcm_pbmp_t pbmp);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_remove,
static int (*_vlan_port_remove_dispatch[])(
    int unit, 
    bcm_vlan_t vid, 
    bcm_pbmp_t pbmp) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_remove(
    int unit, 
    bcm_vlan_t vid, 
    bcm_pbmp_t pbmp)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_PBMP_DECL(t_pbmp);
		BCM_API_XLATE_PORT_PBMP_SAVE(t_pbmp,pbmp);
		BCM_API_XLATE_PORT_PBMP_A2P(unit,&pbmp);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_remove_dispatch[dtype](unit, vid, pbmp);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_PBMP_RESTORE(pbmp,t_pbmp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_remove", 3, 2, unit, vid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_stat_enable_get( \
    int unit, bcm_vlan_t vlan, bcm_port_t port, int *enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_stat_enable_get,
static int (*_vlan_port_stat_enable_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    int *enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_stat_enable_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    int *enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_stat_enable_get_dispatch[dtype](unit, vlan, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_stat_enable_get", 4, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_stat_enable_set( \
    int unit, bcm_vlan_t vlan, bcm_port_t port, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_stat_enable_set,
static int (*_vlan_port_stat_enable_set_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_stat_enable_set(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_stat_enable_set_dispatch[dtype](unit, vlan, port, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_stat_enable_set", 4, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_stat_get( \
    int unit, bcm_vlan_t vlan, bcm_port_t port, bcm_cos_t cos, bcm_vlan_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_stat_get,
static int (*_vlan_port_stat_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_stat_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_stat_get_dispatch[dtype](unit, vlan, port, cos, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_stat_get", 6, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_stat_get32( \
    int unit, bcm_vlan_t vlan, bcm_port_t port, bcm_cos_t cos, bcm_vlan_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_stat_get32,
static int (*_vlan_port_stat_get32_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_stat_get32(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_stat_get32_dispatch[dtype](unit, vlan, port, cos, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_stat_get32", 6, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_stat_multi_get( \
    int unit, bcm_vlan_t vlan, bcm_port_t port, bcm_cos_t cos, int nstat, bcm_vlan_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_stat_multi_get,
static int (*_vlan_port_stat_multi_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_stat_multi_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_stat_multi_get_dispatch[dtype](unit, vlan, port, cos, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_stat_multi_get", 7, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_stat_multi_get32( \
    int unit, bcm_vlan_t vlan, bcm_port_t port, bcm_cos_t cos, int nstat, bcm_vlan_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_stat_multi_get32,
static int (*_vlan_port_stat_multi_get32_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_stat_multi_get32(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_stat_multi_get32_dispatch[dtype](unit, vlan, port, cos, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_stat_multi_get32", 7, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_stat_multi_set( \
    int unit, bcm_vlan_t vlan, bcm_port_t port, bcm_cos_t cos, int nstat, bcm_vlan_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_stat_multi_set,
static int (*_vlan_port_stat_multi_set_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_stat_multi_set(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_stat_multi_set_dispatch[dtype](unit, vlan, port, cos, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_stat_multi_set", 7, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_stat_multi_set32( \
    int unit, bcm_vlan_t vlan, bcm_port_t port, bcm_cos_t cos, int nstat, bcm_vlan_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_stat_multi_set32,
static int (*_vlan_port_stat_multi_set32_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_stat_multi_set32(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_stat_multi_set32_dispatch[dtype](unit, vlan, port, cos, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_stat_multi_set32", 7, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_stat_set( \
    int unit, bcm_vlan_t vlan, bcm_port_t port, bcm_cos_t cos, bcm_vlan_stat_t stat, uint64 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_stat_set,
static int (*_vlan_port_stat_set_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint64 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_stat_set(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint64 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_stat_set_dispatch[dtype](unit, vlan, port, cos, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_stat_set", 6, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_stat_set32( \
    int unit, bcm_vlan_t vlan, bcm_port_t port, bcm_cos_t cos, bcm_vlan_stat_t stat, uint32 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_stat_set32,
static int (*_vlan_port_stat_set32_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint32 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_stat_set32(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_port_t port, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint32 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_stat_set32_dispatch[dtype](unit, vlan, port, cos, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_stat_set32", 6, 3, unit, vlan, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_translation_get( \
    int unit, bcm_vlan_port_translation_t *vlan_port_translation);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_translation_get,
static int (*_vlan_port_translation_get_dispatch[])(
    int unit, 
    bcm_vlan_port_translation_t *vlan_port_translation) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_translation_get(
    int unit, 
    bcm_vlan_port_translation_t *vlan_port_translation)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(vlan_port_translation) BCM_API_XLATE_PORT_A2P(unit,&vlan_port_translation->gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_translation_get_dispatch[dtype](unit, vlan_port_translation);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(vlan_port_translation) BCM_API_XLATE_PORT_P2A(unit,&vlan_port_translation->gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_translation_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_port_translation_set( \
    int unit, bcm_vlan_port_translation_t *vlan_port_translation);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_port_translation_set,
static int (*_vlan_port_translation_set_dispatch[])(
    int unit, 
    bcm_vlan_port_translation_t *vlan_port_translation) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_port_translation_set(
    int unit, 
    bcm_vlan_port_translation_t *vlan_port_translation)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(vlan_port_translation_gport);
		BCM_API_XLATE_PORT_COND(vlan_port_translation) BCM_API_XLATE_PORT_SAVE(vlan_port_translation_gport,vlan_port_translation->gport);
		BCM_API_XLATE_PORT_COND(vlan_port_translation) BCM_API_XLATE_PORT_A2P(unit,&vlan_port_translation->gport);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_port_translation_set_dispatch[dtype](unit, vlan_port_translation);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(vlan_port_translation) BCM_API_XLATE_PORT_RESTORE(vlan_port_translation->gport,vlan_port_translation_gport);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_port_translation_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_queue_map_attach( \
    int unit, bcm_vlan_t vlan, int qmid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_queue_map_attach,
static int (*_vlan_queue_map_attach_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    int qmid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_queue_map_attach(
    int unit, 
    bcm_vlan_t vlan, 
    int qmid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_queue_map_attach_dispatch[dtype](unit, vlan, qmid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_queue_map_attach", 3, 3, unit, vlan, qmid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_queue_map_attach_get( \
    int unit, bcm_vlan_t vlan, int *qmid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_queue_map_attach_get,
static int (*_vlan_queue_map_attach_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    int *qmid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_queue_map_attach_get(
    int unit, 
    bcm_vlan_t vlan, 
    int *qmid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_queue_map_attach_get_dispatch[dtype](unit, vlan, qmid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_queue_map_attach_get", 3, 2, unit, vlan, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_queue_map_create( \
    int unit, uint32 flags, int *qmid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_queue_map_create,
static int (*_vlan_queue_map_create_dispatch[])(
    int unit, 
    uint32 flags, 
    int *qmid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_queue_map_create(
    int unit, 
    uint32 flags, 
    int *qmid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_queue_map_create_dispatch[dtype](unit, flags, qmid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_queue_map_create", 3, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_queue_map_destroy( \
    int unit, int qmid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_queue_map_destroy,
static int (*_vlan_queue_map_destroy_dispatch[])(
    int unit, 
    int qmid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_queue_map_destroy(
    int unit, 
    int qmid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_queue_map_destroy_dispatch[dtype](unit, qmid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_queue_map_destroy", 2, 2, unit, qmid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_queue_map_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_queue_map_destroy_all,
static int (*_vlan_queue_map_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_queue_map_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_queue_map_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_queue_map_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_queue_map_detach( \
    int unit, bcm_vlan_t vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_queue_map_detach,
static int (*_vlan_queue_map_detach_dispatch[])(
    int unit, 
    bcm_vlan_t vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_queue_map_detach(
    int unit, 
    bcm_vlan_t vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_queue_map_detach_dispatch[dtype](unit, vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_queue_map_detach", 2, 2, unit, vlan, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_queue_map_detach_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_queue_map_detach_all,
static int (*_vlan_queue_map_detach_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_queue_map_detach_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_queue_map_detach_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_queue_map_detach_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_queue_map_get( \
    int unit, int qmid, int pkt_pri, int cfi, int *queue, int *color);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_queue_map_get,
static int (*_vlan_queue_map_get_dispatch[])(
    int unit, 
    int qmid, 
    int pkt_pri, 
    int cfi, 
    int *queue, 
    int *color) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_queue_map_get(
    int unit, 
    int qmid, 
    int pkt_pri, 
    int cfi, 
    int *queue, 
    int *color)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_queue_map_get_dispatch[dtype](unit, qmid, pkt_pri, cfi, queue, color);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_queue_map_get", 6, 3, unit, qmid, pkt_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_queue_map_set( \
    int unit, int qmid, int pkt_pri, int cfi, int queue, int color);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_queue_map_set,
static int (*_vlan_queue_map_set_dispatch[])(
    int unit, 
    int qmid, 
    int pkt_pri, 
    int cfi, 
    int queue, 
    int color) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_queue_map_set(
    int unit, 
    int qmid, 
    int pkt_pri, 
    int cfi, 
    int queue, 
    int color)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_queue_map_set_dispatch[dtype](unit, qmid, pkt_pri, cfi, queue, color);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_queue_map_set", 6, 3, unit, qmid, pkt_pri, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_attach( \
    int unit, bcm_vlan_t vlan, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_attach,
static int (*_vlan_stat_attach_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_attach(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_attach_dispatch[dtype](unit, vlan, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_attach", 3, 3, unit, vlan, stat_counter_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_counter_get( \
    int unit, bcm_vlan_t vlan, bcm_vlan_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_counter_get,
static int (*_vlan_stat_counter_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_counter_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_counter_get_dispatch[dtype](unit, vlan, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_counter_get", 6, 3, unit, vlan, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_counter_set( \
    int unit, bcm_vlan_t vlan, bcm_vlan_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_counter_set,
static int (*_vlan_stat_counter_set_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_counter_set(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_counter_set_dispatch[dtype](unit, vlan, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_counter_set", 6, 3, unit, vlan, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_counter_sync_get( \
    int unit, bcm_vlan_t vlan, bcm_vlan_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_counter_sync_get,
static int (*_vlan_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_counter_sync_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_counter_sync_get_dispatch[dtype](unit, vlan, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_counter_sync_get", 6, 3, unit, vlan, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_detach( \
    int unit, bcm_vlan_t vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_detach,
static int (*_vlan_stat_detach_dispatch[])(
    int unit, 
    bcm_vlan_t vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_detach(
    int unit, 
    bcm_vlan_t vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_detach_dispatch[dtype](unit, vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_detach", 2, 2, unit, vlan, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_detach_with_id( \
    int unit, bcm_vlan_t vlan, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_detach_with_id,
static int (*_vlan_stat_detach_with_id_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_detach_with_id(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_detach_with_id_dispatch[dtype](unit, vlan, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_detach_with_id", 3, 3, unit, vlan, stat_counter_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_enable_set( \
    int unit, bcm_vlan_t vlan, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_enable_set,
static int (*_vlan_stat_enable_set_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_enable_set(
    int unit, 
    bcm_vlan_t vlan, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_enable_set_dispatch[dtype](unit, vlan, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_enable_set", 3, 3, unit, vlan, enable, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_get( \
    int unit, bcm_vlan_t vlan, bcm_cos_t cos, bcm_vlan_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_get,
static int (*_vlan_stat_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_get_dispatch[dtype](unit, vlan, cos, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_get", 5, 3, unit, vlan, cos, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_get32( \
    int unit, bcm_vlan_t vlan, bcm_cos_t cos, bcm_vlan_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_get32,
static int (*_vlan_stat_get32_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_get32(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_get32_dispatch[dtype](unit, vlan, cos, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_get32", 5, 3, unit, vlan, cos, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_id_get( \
    int unit, bcm_vlan_t vlan, bcm_vlan_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_id_get,
static int (*_vlan_stat_id_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_id_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_vlan_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_id_get_dispatch[dtype](unit, vlan, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_id_get", 4, 3, unit, vlan, stat, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_multi_get( \
    int unit, bcm_vlan_t vlan, bcm_cos_t cos, int nstat, bcm_vlan_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_multi_get,
static int (*_vlan_stat_multi_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_multi_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_multi_get_dispatch[dtype](unit, vlan, cos, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_multi_get", 6, 3, unit, vlan, cos, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_multi_get32( \
    int unit, bcm_vlan_t vlan, bcm_cos_t cos, int nstat, bcm_vlan_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_multi_get32,
static int (*_vlan_stat_multi_get32_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_multi_get32(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_multi_get32_dispatch[dtype](unit, vlan, cos, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_multi_get32", 6, 3, unit, vlan, cos, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_multi_set( \
    int unit, bcm_vlan_t vlan, bcm_cos_t cos, int nstat, bcm_vlan_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_multi_set,
static int (*_vlan_stat_multi_set_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_multi_set(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_multi_set_dispatch[dtype](unit, vlan, cos, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_multi_set", 6, 3, unit, vlan, cos, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_multi_set32( \
    int unit, bcm_vlan_t vlan, bcm_cos_t cos, int nstat, bcm_vlan_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_multi_set32,
static int (*_vlan_stat_multi_set32_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_multi_set32(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_multi_set32_dispatch[dtype](unit, vlan, cos, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_multi_set32", 6, 3, unit, vlan, cos, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_set( \
    int unit, bcm_vlan_t vlan, bcm_cos_t cos, bcm_vlan_stat_t stat, uint64 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_set,
static int (*_vlan_stat_set_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint64 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_set(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint64 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_set_dispatch[dtype](unit, vlan, cos, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_set", 5, 3, unit, vlan, cos, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_set32( \
    int unit, bcm_vlan_t vlan, bcm_cos_t cos, bcm_vlan_stat_t stat, uint32 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_set32,
static int (*_vlan_stat_set32_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint32 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_set32(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint32 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_set32_dispatch[dtype](unit, vlan, cos, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_set32", 5, 3, unit, vlan, cos, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_sync_get( \
    int unit, bcm_vlan_t vlan, bcm_cos_t cos, bcm_vlan_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_sync_get,
static int (*_vlan_stat_sync_get_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_sync_get(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_sync_get_dispatch[dtype](unit, vlan, cos, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_sync_get", 5, 3, unit, vlan, cos, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stat_sync_get32( \
    int unit, bcm_vlan_t vlan, bcm_cos_t cos, bcm_vlan_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stat_sync_get32,
static int (*_vlan_stat_sync_get32_dispatch[])(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stat_sync_get32(
    int unit, 
    bcm_vlan_t vlan, 
    bcm_cos_t cos, 
    bcm_vlan_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stat_sync_get32_dispatch[dtype](unit, vlan, cos, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stat_sync_get32", 5, 3, unit, vlan, cos, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stg_get( \
    int unit, bcm_vlan_t vid, bcm_stg_t *stg_ptr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stg_get,
static int (*_vlan_stg_get_dispatch[])(
    int unit, 
    bcm_vlan_t vid, 
    bcm_stg_t *stg_ptr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stg_get(
    int unit, 
    bcm_vlan_t vid, 
    bcm_stg_t *stg_ptr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stg_get_dispatch[dtype](unit, vid, stg_ptr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stg_get", 3, 2, unit, vid, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stg_set( \
    int unit, bcm_vlan_t vid, bcm_stg_t stg);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stg_set,
static int (*_vlan_stg_set_dispatch[])(
    int unit, 
    bcm_vlan_t vid, 
    bcm_stg_t stg) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stg_set(
    int unit, 
    bcm_vlan_t vid, 
    bcm_stg_t stg)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stg_set_dispatch[dtype](unit, vid, stg);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stg_set", 3, 3, unit, vid, stg, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stp_get( \
    int unit, bcm_vlan_t vid, bcm_port_t port, int *stp_state);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stp_get,
static int (*_vlan_stp_get_dispatch[])(
    int unit, 
    bcm_vlan_t vid, 
    bcm_port_t port, 
    int *stp_state) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stp_get(
    int unit, 
    bcm_vlan_t vid, 
    bcm_port_t port, 
    int *stp_state)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stp_get_dispatch[dtype](unit, vid, port, stp_state);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stp_get", 4, 3, unit, vid, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_stp_set( \
    int unit, bcm_vlan_t vid, bcm_port_t port, int stp_state);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_stp_set,
static int (*_vlan_stp_set_dispatch[])(
    int unit, 
    bcm_vlan_t vid, 
    bcm_port_t port, 
    int stp_state) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_stp_set(
    int unit, 
    bcm_vlan_t vid, 
    bcm_port_t port, 
    int stp_state)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_stp_set_dispatch[dtype](unit, vid, port, stp_state);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_stp_set", 4, 3, unit, vid, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_add( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_add,
static int (*_vlan_translate_action_add_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_add(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_add_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_add", 6, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_class_get( \
    int unit, bcm_vlan_translate_action_class_t *action_class);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_class_get,
static int (*_vlan_translate_action_class_get_dispatch[])(
    int unit, 
    bcm_vlan_translate_action_class_t *action_class) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_class_get(
    int unit, 
    bcm_vlan_translate_action_class_t *action_class)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_class_get_dispatch[dtype](unit, action_class);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_class_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_class_set( \
    int unit, bcm_vlan_translate_action_class_t *action_class);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_class_set,
static int (*_vlan_translate_action_class_set_dispatch[])(
    int unit, 
    bcm_vlan_translate_action_class_t *action_class) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_class_set(
    int unit, 
    bcm_vlan_translate_action_class_t *action_class)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_class_set_dispatch[dtype](unit, action_class);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_class_set", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_create( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_create,
static int (*_vlan_translate_action_create_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_create(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_create_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_create", 6, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_delete( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_delete,
static int (*_vlan_translate_action_delete_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_delete(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_delete_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_delete", 5, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_get( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_get,
static int (*_vlan_translate_action_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_get_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_get", 6, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_id_create( \
    int unit, uint32 flags, int *action_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_id_create,
static int (*_vlan_translate_action_id_create_dispatch[])(
    int unit, 
    uint32 flags, 
    int *action_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_id_create(
    int unit, 
    uint32 flags, 
    int *action_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_id_create_dispatch[dtype](unit, flags, action_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_id_create", 3, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_id_destroy( \
    int unit, uint32 flags, int action_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_id_destroy,
static int (*_vlan_translate_action_id_destroy_dispatch[])(
    int unit, 
    uint32 flags, 
    int action_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_id_destroy(
    int unit, 
    uint32 flags, 
    int action_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_id_destroy_dispatch[dtype](unit, flags, action_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_id_destroy", 3, 3, unit, flags, action_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_id_destroy_all( \
    int unit, uint32 flags);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_id_destroy_all,
static int (*_vlan_translate_action_id_destroy_all_dispatch[])(
    int unit, 
    uint32 flags) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_id_destroy_all(
    int unit, 
    uint32 flags)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_id_destroy_all_dispatch[dtype](unit, flags);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_id_destroy_all", 2, 2, unit, flags, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_id_get( \
    int unit, uint32 flags, int action_id, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_id_get,
static int (*_vlan_translate_action_id_get_dispatch[])(
    int unit, 
    uint32 flags, 
    int action_id, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_id_get(
    int unit, 
    uint32 flags, 
    int action_id, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_id_get_dispatch[dtype](unit, flags, action_id, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_id_get", 4, 3, unit, flags, action_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_id_set( \
    int unit, uint32 flags, int action_id, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_id_set,
static int (*_vlan_translate_action_id_set_dispatch[])(
    int unit, 
    uint32 flags, 
    int action_id, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_id_set(
    int unit, 
    uint32 flags, 
    int action_id, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_id_set_dispatch[dtype](unit, flags, action_id, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_id_set", 4, 3, unit, flags, action_id, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_range_add( \
    int unit, bcm_gport_t port, bcm_vlan_t outer_vlan_low, bcm_vlan_t outer_vlan_high, bcm_vlan_t inner_vlan_low, bcm_vlan_t inner_vlan_high, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_range_add,
static int (*_vlan_translate_action_range_add_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_t outer_vlan_low, 
    bcm_vlan_t outer_vlan_high, 
    bcm_vlan_t inner_vlan_low, 
    bcm_vlan_t inner_vlan_high, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_range_add(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_t outer_vlan_low, 
    bcm_vlan_t outer_vlan_high, 
    bcm_vlan_t inner_vlan_low, 
    bcm_vlan_t inner_vlan_high, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_range_add_dispatch[dtype](unit, port, outer_vlan_low, outer_vlan_high, inner_vlan_low, inner_vlan_high, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_range_add", 7, 3, unit, port, outer_vlan_low, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_range_delete( \
    int unit, bcm_gport_t port, bcm_vlan_t outer_vlan_low, bcm_vlan_t outer_vlan_high, bcm_vlan_t inner_vlan_low, bcm_vlan_t inner_vlan_high);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_range_delete,
static int (*_vlan_translate_action_range_delete_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_t outer_vlan_low, 
    bcm_vlan_t outer_vlan_high, 
    bcm_vlan_t inner_vlan_low, 
    bcm_vlan_t inner_vlan_high) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_range_delete(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_t outer_vlan_low, 
    bcm_vlan_t outer_vlan_high, 
    bcm_vlan_t inner_vlan_low, 
    bcm_vlan_t inner_vlan_high)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_range_delete_dispatch[dtype](unit, port, outer_vlan_low, outer_vlan_high, inner_vlan_low, inner_vlan_high);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_range_delete", 6, 3, unit, port, outer_vlan_low, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_range_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_range_delete_all,
static int (*_vlan_translate_action_range_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_range_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_range_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_range_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_range_get( \
    int unit, bcm_gport_t port, bcm_vlan_t outer_vlan_low, bcm_vlan_t outer_vlan_high, bcm_vlan_t inner_vlan_low, bcm_vlan_t inner_vlan_high, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_range_get,
static int (*_vlan_translate_action_range_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_t outer_vlan_low, 
    bcm_vlan_t outer_vlan_high, 
    bcm_vlan_t inner_vlan_low, 
    bcm_vlan_t inner_vlan_high, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_range_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_t outer_vlan_low, 
    bcm_vlan_t outer_vlan_high, 
    bcm_vlan_t inner_vlan_low, 
    bcm_vlan_t inner_vlan_high, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_range_get_dispatch[dtype](unit, port, outer_vlan_low, outer_vlan_high, inner_vlan_low, inner_vlan_high, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_range_get", 7, 3, unit, port, outer_vlan_low, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_range_traverse( \
    int unit, bcm_vlan_translate_action_range_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_range_traverse,
static int (*_vlan_translate_action_range_traverse_dispatch[])(
    int unit, 
    bcm_vlan_translate_action_range_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_range_traverse(
    int unit, 
    bcm_vlan_translate_action_range_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_range_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_range_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_action_traverse( \
    int unit, bcm_vlan_translate_action_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_action_traverse,
static int (*_vlan_translate_action_traverse_dispatch[])(
    int unit, 
    bcm_vlan_translate_action_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_action_traverse(
    int unit, 
    bcm_vlan_translate_action_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_action_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_action_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_add( \
    int unit, int port, bcm_vlan_t old_vid, bcm_vlan_t new_vid, int prio);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_add,
static int (*_vlan_translate_add_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_t old_vid, 
    bcm_vlan_t new_vid, 
    int prio) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_add(
    int unit, 
    int port, 
    bcm_vlan_t old_vid, 
    bcm_vlan_t new_vid, 
    int prio)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_add_dispatch[dtype](unit, port, old_vid, new_vid, prio);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_add", 5, 3, unit, port, old_vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_delete( \
    int unit, int port, bcm_vlan_t old_vid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_delete,
static int (*_vlan_translate_delete_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_t old_vid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_delete(
    int unit, 
    int port, 
    bcm_vlan_t old_vid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_delete_dispatch[dtype](unit, port, old_vid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_delete", 3, 3, unit, port, old_vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_delete_all,
static int (*_vlan_translate_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_action_add( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_action_add,
static int (*_vlan_translate_egress_action_add_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_action_add(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_action_add_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_action_add", 5, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_action_delete( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_action_delete,
static int (*_vlan_translate_egress_action_delete_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_action_delete(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_action_delete_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_action_delete", 4, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_action_get( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_action_set_t *action);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_action_get,
static int (*_vlan_translate_egress_action_get_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_action_set_t *action) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_action_get(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_action_set_t *action)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_action_get_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, action);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_action_get", 5, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_action_traverse( \
    int unit, bcm_vlan_translate_egress_action_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_action_traverse,
static int (*_vlan_translate_egress_action_traverse_dispatch[])(
    int unit, 
    bcm_vlan_translate_egress_action_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_action_traverse(
    int unit, 
    bcm_vlan_translate_egress_action_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_action_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_action_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_add( \
    int unit, int port, bcm_vlan_t old_vid, bcm_vlan_t new_vid, int prio);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_add,
static int (*_vlan_translate_egress_add_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_t old_vid, 
    bcm_vlan_t new_vid, 
    int prio) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_add(
    int unit, 
    int port, 
    bcm_vlan_t old_vid, 
    bcm_vlan_t new_vid, 
    int prio)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_add_dispatch[dtype](unit, port, old_vid, new_vid, prio);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_add", 5, 3, unit, port, old_vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_delete( \
    int unit, int port, bcm_vlan_t old_vid);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_delete,
static int (*_vlan_translate_egress_delete_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_t old_vid) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_delete(
    int unit, 
    int port, 
    bcm_vlan_t old_vid)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_delete_dispatch[dtype](unit, port, old_vid);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_delete", 3, 3, unit, port, old_vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_delete_all,
static int (*_vlan_translate_egress_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_get( \
    int unit, int port, bcm_vlan_t old_vid, bcm_vlan_t *new_vid, int *prio);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_get,
static int (*_vlan_translate_egress_get_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_t old_vid, 
    bcm_vlan_t *new_vid, 
    int *prio) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_get(
    int unit, 
    int port, 
    bcm_vlan_t old_vid, 
    bcm_vlan_t *new_vid, 
    int *prio)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_get_dispatch[dtype](unit, port, old_vid, new_vid, prio);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_get", 5, 3, unit, port, old_vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_attach( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_attach,
static int (*_vlan_translate_egress_stat_attach_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_attach(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_attach_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_attach", 5, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_counter_get( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_counter_get,
static int (*_vlan_translate_egress_stat_counter_get_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_counter_get(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_counter_get_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_counter_get", 8, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_counter_set( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_counter_set,
static int (*_vlan_translate_egress_stat_counter_set_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_counter_set(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_counter_set_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_counter_set", 8, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_counter_sync_get( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_counter_sync_get,
static int (*_vlan_translate_egress_stat_counter_sync_get_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_counter_sync_get(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_counter_sync_get_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_counter_sync_get", 8, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_detach( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_detach,
static int (*_vlan_translate_egress_stat_detach_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_detach(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_detach_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_detach", 4, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_enable_set( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_enable_set,
static int (*_vlan_translate_egress_stat_enable_set_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_enable_set(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_enable_set_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_enable_set", 5, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_get( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_get,
static int (*_vlan_translate_egress_stat_get_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_get(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_get_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_get", 6, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_get32( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_get32,
static int (*_vlan_translate_egress_stat_get32_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_get32(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_get32_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_get32", 6, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_id_get( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_id_get,
static int (*_vlan_translate_egress_stat_id_get_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_id_get(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_id_get_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_id_get", 6, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_multi_get( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, int nstat, bcm_vlan_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_multi_get,
static int (*_vlan_translate_egress_stat_multi_get_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_multi_get(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_multi_get_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_multi_get", 7, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_multi_get32( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, int nstat, bcm_vlan_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_multi_get32,
static int (*_vlan_translate_egress_stat_multi_get32_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_multi_get32(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_multi_get32_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_multi_get32", 7, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_multi_set( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, int nstat, bcm_vlan_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_multi_set,
static int (*_vlan_translate_egress_stat_multi_set_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_multi_set(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_multi_set_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_multi_set", 7, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_multi_set32( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, int nstat, bcm_vlan_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_multi_set32,
static int (*_vlan_translate_egress_stat_multi_set32_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_multi_set32(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_multi_set32_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_multi_set32", 7, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_set( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint64 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_set,
static int (*_vlan_translate_egress_stat_set_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint64 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_set(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint64 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_set_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_set", 6, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_set32( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint32 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_set32,
static int (*_vlan_translate_egress_stat_set32_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_set32(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_set32_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_set32", 6, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_sync_get( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_sync_get,
static int (*_vlan_translate_egress_stat_sync_get_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_sync_get(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_sync_get_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_sync_get", 6, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_stat_sync_get32( \
    int unit, int port_class, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_stat_sync_get32,
static int (*_vlan_translate_egress_stat_sync_get32_dispatch[])(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_stat_sync_get32(
    int unit, 
    int port_class, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_stat_sync_get32_dispatch[dtype](unit, port_class, outer_vlan, inner_vlan, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_stat_sync_get32", 6, 3, unit, port_class, outer_vlan, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_egress_traverse( \
    int unit, bcm_vlan_translate_egress_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_egress_traverse,
static int (*_vlan_translate_egress_traverse_dispatch[])(
    int unit, 
    bcm_vlan_translate_egress_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_egress_traverse(
    int unit, 
    bcm_vlan_translate_egress_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_egress_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_egress_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_get( \
    int unit, int port, bcm_vlan_t old_vid, bcm_vlan_t *new_vid, int *prio);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_get,
static int (*_vlan_translate_get_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_t old_vid, 
    bcm_vlan_t *new_vid, 
    int *prio) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_get(
    int unit, 
    int port, 
    bcm_vlan_t old_vid, 
    bcm_vlan_t *new_vid, 
    int *prio)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_get_dispatch[dtype](unit, port, old_vid, new_vid, prio);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_get", 5, 3, unit, port, old_vid, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_range_add( \
    int unit, int port, bcm_vlan_t old_vid_low, bcm_vlan_t old_vid_high, bcm_vlan_t new_vid, int int_prio);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_range_add,
static int (*_vlan_translate_range_add_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_t old_vid_low, 
    bcm_vlan_t old_vid_high, 
    bcm_vlan_t new_vid, 
    int int_prio) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_range_add(
    int unit, 
    int port, 
    bcm_vlan_t old_vid_low, 
    bcm_vlan_t old_vid_high, 
    bcm_vlan_t new_vid, 
    int int_prio)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_range_add_dispatch[dtype](unit, port, old_vid_low, old_vid_high, new_vid, int_prio);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_range_add", 6, 3, unit, port, old_vid_low, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_range_delete( \
    int unit, int port, bcm_vlan_t old_vid_low, bcm_vlan_t old_vid_high);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_range_delete,
static int (*_vlan_translate_range_delete_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_t old_vid_low, 
    bcm_vlan_t old_vid_high) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_range_delete(
    int unit, 
    int port, 
    bcm_vlan_t old_vid_low, 
    bcm_vlan_t old_vid_high)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_range_delete_dispatch[dtype](unit, port, old_vid_low, old_vid_high);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_range_delete", 4, 3, unit, port, old_vid_low, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_range_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_range_delete_all,
static int (*_vlan_translate_range_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_range_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_range_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_range_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_range_get( \
    int unit, int port, bcm_vlan_t old_vid_low, bcm_vlan_t old_vid_high, bcm_vlan_t *new_vid, int *int_prio);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_range_get,
static int (*_vlan_translate_range_get_dispatch[])(
    int unit, 
    int port, 
    bcm_vlan_t old_vid_low, 
    bcm_vlan_t old_vid_high, 
    bcm_vlan_t *new_vid, 
    int *int_prio) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_range_get(
    int unit, 
    int port, 
    bcm_vlan_t old_vid_low, 
    bcm_vlan_t old_vid_high, 
    bcm_vlan_t *new_vid, 
    int *int_prio)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_range_get_dispatch[dtype](unit, port, old_vid_low, old_vid_high, new_vid, int_prio);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_range_get", 6, 3, unit, port, old_vid_low, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_range_traverse( \
    int unit, bcm_vlan_translate_range_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_range_traverse,
static int (*_vlan_translate_range_traverse_dispatch[])(
    int unit, 
    bcm_vlan_translate_range_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_range_traverse(
    int unit, 
    bcm_vlan_translate_range_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_range_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_range_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_attach( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_attach,
static int (*_vlan_translate_stat_attach_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_attach(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_attach_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_attach", 6, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_counter_get( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_counter_get,
static int (*_vlan_translate_stat_counter_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_counter_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_counter_get_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_counter_get", 9, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_counter_set( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_counter_set,
static int (*_vlan_translate_stat_counter_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_counter_set(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_counter_set_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_counter_set", 9, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_counter_sync_get( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_counter_sync_get,
static int (*_vlan_translate_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_counter_sync_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_counter_sync_get_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_counter_sync_get", 9, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_detach( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_detach,
static int (*_vlan_translate_stat_detach_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_detach(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_detach_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_detach", 5, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_enable_set( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_enable_set,
static int (*_vlan_translate_stat_enable_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_enable_set(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_enable_set_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_enable_set", 6, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_get( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_get,
static int (*_vlan_translate_stat_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_get_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_get", 7, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_get32( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_get32,
static int (*_vlan_translate_stat_get32_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_get32(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_get32_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_get32", 7, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_id_get( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_id_get,
static int (*_vlan_translate_stat_id_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_id_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_id_get_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_id_get", 7, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_multi_get( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, int nstat, bcm_vlan_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_multi_get,
static int (*_vlan_translate_stat_multi_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_multi_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_multi_get_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_multi_get", 8, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_multi_get32( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, int nstat, bcm_vlan_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_multi_get32,
static int (*_vlan_translate_stat_multi_get32_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_multi_get32(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_multi_get32_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_multi_get32", 8, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_multi_set( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, int nstat, bcm_vlan_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_multi_set,
static int (*_vlan_translate_stat_multi_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_multi_set(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_multi_set_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_multi_set", 8, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_multi_set32( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, int nstat, bcm_vlan_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_multi_set32,
static int (*_vlan_translate_stat_multi_set32_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_multi_set32(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    int nstat, 
    bcm_vlan_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_multi_set32_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_multi_set32", 8, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_set( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint64 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_set,
static int (*_vlan_translate_stat_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint64 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_set(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint64 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_set_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_set", 7, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_set32( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint32 val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_set32,
static int (*_vlan_translate_stat_set32_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_set32(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_set32_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_set32", 7, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_sync_get( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint64 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_sync_get,
static int (*_vlan_translate_stat_sync_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint64 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_sync_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint64 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_sync_get_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_sync_get", 7, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_stat_sync_get32( \
    int unit, bcm_gport_t port, bcm_vlan_translate_key_t key_type, bcm_vlan_t outer_vlan, bcm_vlan_t inner_vlan, bcm_vlan_stat_t stat, uint32 *val);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_stat_sync_get32,
static int (*_vlan_translate_stat_sync_get32_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 *val) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_stat_sync_get32(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_translate_key_t key_type, 
    bcm_vlan_t outer_vlan, 
    bcm_vlan_t inner_vlan, 
    bcm_vlan_stat_t stat, 
    uint32 *val)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_stat_sync_get32_dispatch[dtype](unit, port, key_type, outer_vlan, inner_vlan, stat, val);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_stat_sync_get32", 7, 3, unit, port, key_type, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_translate_traverse( \
    int unit, bcm_vlan_translate_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_translate_traverse,
static int (*_vlan_translate_traverse_dispatch[])(
    int unit, 
    bcm_vlan_translate_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_translate_traverse(
    int unit, 
    bcm_vlan_translate_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_translate_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_translate_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_vector_flags_set( \
    int unit, bcm_vlan_vector_t vlan_vector, uint32 flags_mask, uint32 flags_value);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_vector_flags_set,
static int (*_vlan_vector_flags_set_dispatch[])(
    int unit, 
    bcm_vlan_vector_t vlan_vector, 
    uint32 flags_mask, 
    uint32 flags_value) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_vector_flags_set(
    int unit, 
    bcm_vlan_vector_t vlan_vector, 
    uint32 flags_mask, 
    uint32 flags_value)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_vector_flags_set_dispatch[dtype](unit, vlan_vector, flags_mask, flags_value);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_vector_flags_set", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vlan_vector_stp_set( \
    int unit, bcm_vlan_vector_t vlan_vector, bcm_port_t port, int stp_state);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vlan_vector_stp_set,
static int (*_vlan_vector_stp_set_dispatch[])(
    int unit, 
    bcm_vlan_vector_t vlan_vector, 
    bcm_port_t port, 
    int stp_state) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vlan_vector_stp_set(
    int unit, 
    bcm_vlan_vector_t vlan_vector, 
    bcm_port_t port, 
    int stp_state)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vlan_vector_stp_set_dispatch[dtype](unit, vlan_vector, port, stp_state);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vlan_vector_stp_set", 4, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_create( \
    int unit, bcm_vlan_t *vsi);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_create,
static int (*_vswitch_create_dispatch[])(
    int unit, 
    bcm_vlan_t *vsi) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_create(
    int unit, 
    bcm_vlan_t *vsi)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_create_dispatch[dtype](unit, vsi);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_create_with_id( \
    int unit, bcm_vlan_t vsi);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_create_with_id,
static int (*_vswitch_create_with_id_dispatch[])(
    int unit, 
    bcm_vlan_t vsi) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_create_with_id(
    int unit, 
    bcm_vlan_t vsi)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_create_with_id_dispatch[dtype](unit, vsi);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_create_with_id", 2, 2, unit, vsi, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_cross_connect_add( \
    int unit, bcm_vswitch_cross_connect_t *gports);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_cross_connect_add,
static int (*_vswitch_cross_connect_add_dispatch[])(
    int unit, 
    bcm_vswitch_cross_connect_t *gports) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_cross_connect_add(
    int unit, 
    bcm_vswitch_cross_connect_t *gports)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(gports_port1);
		BCM_API_XLATE_PORT_DECL(gports_port2);
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_SAVE(gports_port1,gports->port1);
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_A2P(unit,&gports->port1);
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_SAVE(gports_port2,gports->port2);
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_A2P(unit,&gports->port2);
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_cross_connect_add_dispatch[dtype](unit, gports);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_RESTORE(gports->port1,gports_port1);
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_RESTORE(gports->port2,gports_port2);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_cross_connect_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_cross_connect_delete( \
    int unit, bcm_vswitch_cross_connect_t *gports);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_cross_connect_delete,
static int (*_vswitch_cross_connect_delete_dispatch[])(
    int unit, 
    bcm_vswitch_cross_connect_t *gports) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_cross_connect_delete(
    int unit, 
    bcm_vswitch_cross_connect_t *gports)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_DECL(gports_port1);
		BCM_API_XLATE_PORT_DECL(gports_port2);
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_SAVE(gports_port1,gports->port1);
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_A2P(unit,&gports->port1);
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_SAVE(gports_port2,gports->port2);
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_A2P(unit,&gports->port2);
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_cross_connect_delete_dispatch[dtype](unit, gports);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_RESTORE(gports->port1,gports_port1);
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_RESTORE(gports->port2,gports_port2);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_cross_connect_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_cross_connect_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_cross_connect_delete_all,
static int (*_vswitch_cross_connect_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_cross_connect_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_cross_connect_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_cross_connect_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_cross_connect_get( \
    int unit, bcm_vswitch_cross_connect_t *gports);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_cross_connect_get,
static int (*_vswitch_cross_connect_get_dispatch[])(
    int unit, 
    bcm_vswitch_cross_connect_t *gports) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_cross_connect_get(
    int unit, 
    bcm_vswitch_cross_connect_t *gports)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_A2P(unit,&gports->port1);
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_A2P(unit,&gports->port2);
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_cross_connect_get_dispatch[dtype](unit, gports);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_P2A(unit,&gports->port1);
		BCM_API_XLATE_PORT_COND(gports) BCM_API_XLATE_PORT_P2A(unit,&gports->port2);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_cross_connect_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_cross_connect_traverse( \
    int unit, bcm_vswitch_cross_connect_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_cross_connect_traverse,
static int (*_vswitch_cross_connect_traverse_dispatch[])(
    int unit, 
    bcm_vswitch_cross_connect_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_cross_connect_traverse(
    int unit, 
    bcm_vswitch_cross_connect_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_cross_connect_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_cross_connect_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_destroy( \
    int unit, bcm_vlan_t vsi);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_destroy,
static int (*_vswitch_destroy_dispatch[])(
    int unit, 
    bcm_vlan_t vsi) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_destroy(
    int unit, 
    bcm_vlan_t vsi)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_destroy_dispatch[dtype](unit, vsi);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_destroy", 2, 2, unit, vsi, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_destroy_all,
static int (*_vswitch_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_detach,
static int (*_vswitch_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_init,
static int (*_vswitch_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_port_add( \
    int unit, bcm_vlan_t vsi, bcm_gport_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_port_add,
static int (*_vswitch_port_add_dispatch[])(
    int unit, 
    bcm_vlan_t vsi, 
    bcm_gport_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_port_add(
    int unit, 
    bcm_vlan_t vsi, 
    bcm_gport_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_port_add_dispatch[dtype](unit, vsi, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_port_add", 3, 3, unit, vsi, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_port_delete( \
    int unit, bcm_vlan_t vsi, bcm_gport_t port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_port_delete,
static int (*_vswitch_port_delete_dispatch[])(
    int unit, 
    bcm_vlan_t vsi, 
    bcm_gport_t port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_port_delete(
    int unit, 
    bcm_vlan_t vsi, 
    bcm_gport_t port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_port_delete_dispatch[dtype](unit, vsi, port);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_port_delete", 3, 3, unit, vsi, port, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_port_delete_all( \
    int unit, bcm_vlan_t vsi);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_port_delete_all,
static int (*_vswitch_port_delete_all_dispatch[])(
    int unit, 
    bcm_vlan_t vsi) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_port_delete_all(
    int unit, 
    bcm_vlan_t vsi)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_port_delete_all_dispatch[dtype](unit, vsi);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_port_delete_all", 2, 2, unit, vsi, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_port_get( \
    int unit, bcm_gport_t port, bcm_vlan_t *vsi);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_port_get,
static int (*_vswitch_port_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_t *vsi) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_port_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vlan_t *vsi)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_port_get_dispatch[dtype](unit, port, vsi);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_port_get", 3, 2, unit, port, 0, r_rv);
	return r_rv;
}

/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vswitch_port_traverse( \
    int unit, bcm_vlan_t vsi, bcm_vswitch_port_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vswitch_port_traverse,
static int (*_vswitch_port_traverse_dispatch[])(
    int unit, 
    bcm_vlan_t vsi, 
    bcm_vswitch_port_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vswitch_port_traverse(
    int unit, 
    bcm_vlan_t vsi, 
    bcm_vswitch_port_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vswitch_port_traverse_dispatch[dtype](unit, vsi, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vswitch_port_traverse", 4, 2, unit, vsi, 0, r_rv);
	return r_rv;
}

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_cleanup( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_cleanup,
static int (*_vxlan_cleanup_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_cleanup(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_cleanup_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_cleanup", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_dip_stat_attach( \
    int unit, bcm_ip_t vxlan_dip, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_dip_stat_attach,
static int (*_vxlan_dip_stat_attach_dispatch[])(
    int unit, 
    bcm_ip_t vxlan_dip, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_dip_stat_attach(
    int unit, 
    bcm_ip_t vxlan_dip, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_dip_stat_attach_dispatch[dtype](unit, vxlan_dip, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_dip_stat_attach", 3, 3, unit, vxlan_dip, stat_counter_id, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_dip_stat_counter_get( \
    int unit, bcm_ip_t vxlan_dip, bcm_vxlan_dip_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_dip_stat_counter_get,
static int (*_vxlan_dip_stat_counter_get_dispatch[])(
    int unit, 
    bcm_ip_t vxlan_dip, 
    bcm_vxlan_dip_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_dip_stat_counter_get(
    int unit, 
    bcm_ip_t vxlan_dip, 
    bcm_vxlan_dip_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_dip_stat_counter_get_dispatch[dtype](unit, vxlan_dip, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_dip_stat_counter_get", 6, 3, unit, vxlan_dip, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_dip_stat_counter_set( \
    int unit, bcm_ip_t vxlan_dip, bcm_vxlan_dip_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_dip_stat_counter_set,
static int (*_vxlan_dip_stat_counter_set_dispatch[])(
    int unit, 
    bcm_ip_t vxlan_dip, 
    bcm_vxlan_dip_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_dip_stat_counter_set(
    int unit, 
    bcm_ip_t vxlan_dip, 
    bcm_vxlan_dip_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_dip_stat_counter_set_dispatch[dtype](unit, vxlan_dip, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_dip_stat_counter_set", 6, 3, unit, vxlan_dip, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_dip_stat_detach( \
    int unit, bcm_ip_t vxlan_dip);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_dip_stat_detach,
static int (*_vxlan_dip_stat_detach_dispatch[])(
    int unit, 
    bcm_ip_t vxlan_dip) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_dip_stat_detach(
    int unit, 
    bcm_ip_t vxlan_dip)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_dip_stat_detach_dispatch[dtype](unit, vxlan_dip);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_dip_stat_detach", 2, 2, unit, vxlan_dip, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_dip_stat_id_get( \
    int unit, bcm_ip_t vxlan_dip, bcm_vxlan_dip_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_dip_stat_id_get,
static int (*_vxlan_dip_stat_id_get_dispatch[])(
    int unit, 
    bcm_ip_t vxlan_dip, 
    bcm_vxlan_dip_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_dip_stat_id_get(
    int unit, 
    bcm_ip_t vxlan_dip, 
    bcm_vxlan_dip_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_dip_stat_id_get_dispatch[dtype](unit, vxlan_dip, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_dip_stat_id_get", 4, 3, unit, vxlan_dip, stat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_dip_stat_multi_get( \
    int unit, bcm_ip_t vxlan_dip, int nstat, bcm_vxlan_dip_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_dip_stat_multi_get,
static int (*_vxlan_dip_stat_multi_get_dispatch[])(
    int unit, 
    bcm_ip_t vxlan_dip, 
    int nstat, 
    bcm_vxlan_dip_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_dip_stat_multi_get(
    int unit, 
    bcm_ip_t vxlan_dip, 
    int nstat, 
    bcm_vxlan_dip_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_dip_stat_multi_get_dispatch[dtype](unit, vxlan_dip, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_dip_stat_multi_get", 5, 3, unit, vxlan_dip, nstat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_dip_stat_multi_get32( \
    int unit, bcm_ip_t vxlan_dip, int nstat, bcm_vxlan_dip_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_dip_stat_multi_get32,
static int (*_vxlan_dip_stat_multi_get32_dispatch[])(
    int unit, 
    bcm_ip_t vxlan_dip, 
    int nstat, 
    bcm_vxlan_dip_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_dip_stat_multi_get32(
    int unit, 
    bcm_ip_t vxlan_dip, 
    int nstat, 
    bcm_vxlan_dip_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_dip_stat_multi_get32_dispatch[dtype](unit, vxlan_dip, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_dip_stat_multi_get32", 5, 3, unit, vxlan_dip, nstat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_dip_stat_multi_set( \
    int unit, bcm_ip_t vxlan_dip, int nstat, bcm_vxlan_dip_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_dip_stat_multi_set,
static int (*_vxlan_dip_stat_multi_set_dispatch[])(
    int unit, 
    bcm_ip_t vxlan_dip, 
    int nstat, 
    bcm_vxlan_dip_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_dip_stat_multi_set(
    int unit, 
    bcm_ip_t vxlan_dip, 
    int nstat, 
    bcm_vxlan_dip_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_dip_stat_multi_set_dispatch[dtype](unit, vxlan_dip, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_dip_stat_multi_set", 5, 3, unit, vxlan_dip, nstat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_dip_stat_multi_set32( \
    int unit, bcm_ip_t vxlan_dip, int nstat, bcm_vxlan_dip_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_dip_stat_multi_set32,
static int (*_vxlan_dip_stat_multi_set32_dispatch[])(
    int unit, 
    bcm_ip_t vxlan_dip, 
    int nstat, 
    bcm_vxlan_dip_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_dip_stat_multi_set32(
    int unit, 
    bcm_ip_t vxlan_dip, 
    int nstat, 
    bcm_vxlan_dip_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_dip_stat_multi_set32_dispatch[dtype](unit, vxlan_dip, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_dip_stat_multi_set32", 5, 3, unit, vxlan_dip, nstat, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_init,
static int (*_vxlan_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_port_add( \
    int unit, bcm_vpn_t l2vpn, bcm_vxlan_port_t *vxlan_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_port_add,
static int (*_vxlan_port_add_dispatch[])(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_vxlan_port_t *vxlan_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_port_add(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_vxlan_port_t *vxlan_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_A2P(unit,&vxlan_port->egress_tunnel_id);
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_A2P(unit,&vxlan_port->match_port);
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_A2P(unit,&vxlan_port->match_tunnel_id);
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_A2P(unit,&vxlan_port->vxlan_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_port_add_dispatch[dtype](unit, l2vpn, vxlan_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_P2A(unit,&vxlan_port->egress_tunnel_id);
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_P2A(unit,&vxlan_port->match_port);
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_P2A(unit,&vxlan_port->match_tunnel_id);
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_P2A(unit,&vxlan_port->vxlan_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_port_add", 3, 2, unit, l2vpn, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_port_delete( \
    int unit, bcm_vpn_t l2vpn, bcm_gport_t vxlan_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_port_delete,
static int (*_vxlan_port_delete_dispatch[])(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_gport_t vxlan_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_port_delete(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_gport_t vxlan_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&vxlan_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_port_delete_dispatch[dtype](unit, l2vpn, vxlan_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_port_delete", 3, 3, unit, l2vpn, vxlan_port_id, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_port_delete_all( \
    int unit, bcm_vpn_t l2vpn);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_port_delete_all,
static int (*_vxlan_port_delete_all_dispatch[])(
    int unit, 
    bcm_vpn_t l2vpn) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_port_delete_all(
    int unit, 
    bcm_vpn_t l2vpn)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_port_delete_all_dispatch[dtype](unit, l2vpn);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_port_delete_all", 2, 2, unit, l2vpn, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_port_get( \
    int unit, bcm_vpn_t l2vpn, bcm_vxlan_port_t *vxlan_port);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_port_get,
static int (*_vxlan_port_get_dispatch[])(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_vxlan_port_t *vxlan_port) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_port_get(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_vxlan_port_t *vxlan_port)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_A2P(unit,&vxlan_port->egress_tunnel_id);
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_A2P(unit,&vxlan_port->match_port);
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_A2P(unit,&vxlan_port->match_tunnel_id);
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_A2P(unit,&vxlan_port->vxlan_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_port_get_dispatch[dtype](unit, l2vpn, vxlan_port);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_P2A(unit,&vxlan_port->egress_tunnel_id);
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_P2A(unit,&vxlan_port->match_port);
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_P2A(unit,&vxlan_port->match_tunnel_id);
		BCM_API_XLATE_PORT_COND(vxlan_port) BCM_API_XLATE_PORT_P2A(unit,&vxlan_port->vxlan_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_port_get", 3, 2, unit, l2vpn, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_port_get_all( \
    int unit, bcm_vpn_t l2vpn, int port_max, bcm_vxlan_port_t *port_array, int *port_count);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_port_get_all,
static int (*_vxlan_port_get_all_dispatch[])(
    int unit, 
    bcm_vpn_t l2vpn, 
    int port_max, 
    bcm_vxlan_port_t *port_array, 
    int *port_count) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_port_get_all(
    int unit, 
    bcm_vpn_t l2vpn, 
    int port_max, 
    bcm_vxlan_port_t *port_array, 
    int *port_count)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_ITER_DECL(idx);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_port_get_all_dispatch[dtype](unit, l2vpn, port_max, port_array, port_count);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].egress_tunnel_id);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].match_port);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].match_tunnel_id);
		BCM_API_XLATE_PORT_COND(r_rv >= 0)
			BCM_API_XLATE_PORT_ITER(port_max,idx)
				BCM_API_XLATE_PORT_COND(port_array) BCM_API_XLATE_PORT_P2A(unit,&(port_array)[idx].vxlan_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_port_get_all", 5, 3, unit, l2vpn, port_max, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_stat_attach( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, uint32 stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_stat_attach,
static int (*_vxlan_stat_attach_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    uint32 stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_stat_attach(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    uint32 stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_stat_attach_dispatch[dtype](unit, port, vpn, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_stat_attach", 4, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_stat_counter_get( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, bcm_vxlan_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_stat_counter_get,
static int (*_vxlan_stat_counter_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_vxlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_stat_counter_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_vxlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_stat_counter_get_dispatch[dtype](unit, port, vpn, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_stat_counter_get", 7, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_stat_counter_set( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, bcm_vxlan_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_stat_counter_set,
static int (*_vxlan_stat_counter_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_vxlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_stat_counter_set(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_vxlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_stat_counter_set_dispatch[dtype](unit, port, vpn, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_stat_counter_set", 7, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_stat_counter_sync_get( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, bcm_vxlan_stat_t stat, uint32 num_entries, uint32 *counter_indexes, bcm_stat_value_t *counter_values);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_stat_counter_sync_get,
static int (*_vxlan_stat_counter_sync_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_vxlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_stat_counter_sync_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_vxlan_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_stat_counter_sync_get_dispatch[dtype](unit, port, vpn, stat, num_entries, counter_indexes, counter_values);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_stat_counter_sync_get", 7, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_stat_detach( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_stat_detach,
static int (*_vxlan_stat_detach_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_stat_detach(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_stat_detach_dispatch[dtype](unit, port, vpn);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_stat_detach", 3, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_stat_enable_set( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, int enable);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_stat_enable_set,
static int (*_vxlan_stat_enable_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int enable) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_stat_enable_set(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int enable)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_stat_enable_set_dispatch[dtype](unit, port, vpn, enable);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_stat_enable_set", 4, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_stat_id_get( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, bcm_vxlan_stat_t stat, uint32 *stat_counter_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_stat_id_get,
static int (*_vxlan_stat_id_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_vxlan_stat_t stat, 
    uint32 *stat_counter_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_stat_id_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    bcm_vxlan_stat_t stat, 
    uint32 *stat_counter_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_stat_id_get_dispatch[dtype](unit, port, vpn, stat, stat_counter_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_stat_id_get", 5, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_stat_multi_get( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, int nstat, bcm_vxlan_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_stat_multi_get,
static int (*_vxlan_stat_multi_get_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_vxlan_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_stat_multi_get(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_vxlan_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_stat_multi_get_dispatch[dtype](unit, port, vpn, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_stat_multi_get", 6, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_stat_multi_get32( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, int nstat, bcm_vxlan_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_stat_multi_get32,
static int (*_vxlan_stat_multi_get32_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_vxlan_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_stat_multi_get32(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_vxlan_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_stat_multi_get32_dispatch[dtype](unit, port, vpn, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_stat_multi_get32", 6, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_stat_multi_set( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, int nstat, bcm_vxlan_stat_t *stat_arr, uint64 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_stat_multi_set,
static int (*_vxlan_stat_multi_set_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_vxlan_stat_t *stat_arr, 
    uint64 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_stat_multi_set(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_vxlan_stat_t *stat_arr, 
    uint64 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_stat_multi_set_dispatch[dtype](unit, port, vpn, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_stat_multi_set", 6, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_stat_multi_set32( \
    int unit, bcm_gport_t port, bcm_vpn_t vpn, int nstat, bcm_vxlan_stat_t *stat_arr, uint32 *value_arr);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_stat_multi_set32,
static int (*_vxlan_stat_multi_set32_dispatch[])(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_vxlan_stat_t *stat_arr, 
    uint32 *value_arr) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_stat_multi_set32(
    int unit, 
    bcm_gport_t port, 
    bcm_vpn_t vpn, 
    int nstat, 
    bcm_vxlan_stat_t *stat_arr, 
    uint32 *value_arr)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&port);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_stat_multi_set32_dispatch[dtype](unit, port, vpn, nstat, stat_arr, value_arr);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_stat_multi_set32", 6, 3, unit, port, vpn, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_tunnel_initiator_create( \
    int unit, bcm_tunnel_initiator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_tunnel_initiator_create,
static int (*_vxlan_tunnel_initiator_create_dispatch[])(
    int unit, 
    bcm_tunnel_initiator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_tunnel_initiator_create(
    int unit, 
    bcm_tunnel_initiator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_tunnel_initiator_create_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_tunnel_initiator_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_tunnel_initiator_destroy( \
    int unit, bcm_gport_t vxlan_tunnel_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_tunnel_initiator_destroy,
static int (*_vxlan_tunnel_initiator_destroy_dispatch[])(
    int unit, 
    bcm_gport_t vxlan_tunnel_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_tunnel_initiator_destroy(
    int unit, 
    bcm_gport_t vxlan_tunnel_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&vxlan_tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_tunnel_initiator_destroy_dispatch[dtype](unit, vxlan_tunnel_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_tunnel_initiator_destroy", 2, 2, unit, vxlan_tunnel_id, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_tunnel_initiator_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_tunnel_initiator_destroy_all,
static int (*_vxlan_tunnel_initiator_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_tunnel_initiator_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_tunnel_initiator_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_tunnel_initiator_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_tunnel_initiator_get( \
    int unit, bcm_tunnel_initiator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_tunnel_initiator_get,
static int (*_vxlan_tunnel_initiator_get_dispatch[])(
    int unit, 
    bcm_tunnel_initiator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_tunnel_initiator_get(
    int unit, 
    bcm_tunnel_initiator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_tunnel_initiator_get_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_tunnel_initiator_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_tunnel_initiator_traverse( \
    int unit, bcm_tunnel_initiator_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_tunnel_initiator_traverse,
static int (*_vxlan_tunnel_initiator_traverse_dispatch[])(
    int unit, 
    bcm_tunnel_initiator_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_tunnel_initiator_traverse(
    int unit, 
    bcm_tunnel_initiator_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_tunnel_initiator_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_tunnel_initiator_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_tunnel_terminator_create( \
    int unit, bcm_tunnel_terminator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_tunnel_terminator_create,
static int (*_vxlan_tunnel_terminator_create_dispatch[])(
    int unit, 
    bcm_tunnel_terminator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_tunnel_terminator_create(
    int unit, 
    bcm_tunnel_terminator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_A2P(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_tunnel_terminator_create_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_P2A(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_tunnel_terminator_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_tunnel_terminator_destroy( \
    int unit, bcm_gport_t vxlan_tunnel_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_tunnel_terminator_destroy,
static int (*_vxlan_tunnel_terminator_destroy_dispatch[])(
    int unit, 
    bcm_gport_t vxlan_tunnel_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_tunnel_terminator_destroy(
    int unit, 
    bcm_gport_t vxlan_tunnel_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&vxlan_tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_tunnel_terminator_destroy_dispatch[dtype](unit, vxlan_tunnel_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_tunnel_terminator_destroy", 2, 2, unit, vxlan_tunnel_id, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_tunnel_terminator_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_tunnel_terminator_destroy_all,
static int (*_vxlan_tunnel_terminator_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_tunnel_terminator_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_tunnel_terminator_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_tunnel_terminator_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_tunnel_terminator_get( \
    int unit, bcm_tunnel_terminator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_tunnel_terminator_get,
static int (*_vxlan_tunnel_terminator_get_dispatch[])(
    int unit, 
    bcm_tunnel_terminator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_tunnel_terminator_get(
    int unit, 
    bcm_tunnel_terminator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_A2P(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_tunnel_terminator_get_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_P2A(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_tunnel_terminator_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_tunnel_terminator_traverse( \
    int unit, bcm_tunnel_terminator_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_tunnel_terminator_traverse,
static int (*_vxlan_tunnel_terminator_traverse_dispatch[])(
    int unit, 
    bcm_tunnel_terminator_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_tunnel_terminator_traverse(
    int unit, 
    bcm_tunnel_terminator_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_tunnel_terminator_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_tunnel_terminator_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_tunnel_terminator_update( \
    int unit, bcm_tunnel_terminator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_tunnel_terminator_update,
static int (*_vxlan_tunnel_terminator_update_dispatch[])(
    int unit, 
    bcm_tunnel_terminator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_tunnel_terminator_update(
    int unit, 
    bcm_tunnel_terminator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_A2P(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_tunnel_terminator_update_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->failover_tunnel_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_PBMP_P2A(unit,&info->pbmp);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->remote_port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_tunnel_terminator_update", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_vpn_create( \
    int unit, bcm_vxlan_vpn_config_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_vpn_create,
static int (*_vxlan_vpn_create_dispatch[])(
    int unit, 
    bcm_vxlan_vpn_config_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_vpn_create(
    int unit, 
    bcm_vxlan_vpn_config_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_vpn_create_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_vpn_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_vpn_destroy( \
    int unit, bcm_vpn_t l2vpn);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_vpn_destroy,
static int (*_vxlan_vpn_destroy_dispatch[])(
    int unit, 
    bcm_vpn_t l2vpn) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_vpn_destroy(
    int unit, 
    bcm_vpn_t l2vpn)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_vpn_destroy_dispatch[dtype](unit, l2vpn);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_vpn_destroy", 2, 2, unit, l2vpn, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_vpn_destroy_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_vpn_destroy_all,
static int (*_vxlan_vpn_destroy_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_vpn_destroy_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_vpn_destroy_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_vpn_destroy_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_vpn_get( \
    int unit, bcm_vpn_t l2vpn, bcm_vxlan_vpn_config_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_vpn_get,
static int (*_vxlan_vpn_get_dispatch[])(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_vxlan_vpn_config_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_vpn_get(
    int unit, 
    bcm_vpn_t l2vpn, 
    bcm_vxlan_vpn_config_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_vpn_get_dispatch[dtype](unit, l2vpn, info);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_vpn_get", 3, 2, unit, l2vpn, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_vxlan_vpn_traverse( \
    int unit, bcm_vxlan_vpn_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_vxlan_vpn_traverse,
static int (*_vxlan_vpn_traverse_dispatch[])(
    int unit, 
    bcm_vxlan_vpn_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_vxlan_vpn_traverse(
    int unit, 
    bcm_vxlan_vpn_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _vxlan_vpn_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_vxlan_vpn_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_wlan_client_add( \
    int unit, bcm_wlan_client_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_wlan_client_add,
static int (*_wlan_client_add_dispatch[])(
    int unit, 
    bcm_wlan_client_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_wlan_client_add(
    int unit, 
    bcm_wlan_client_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->home_agent);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->wlan_port_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->wtp);
		dtype = BCM_DTYPE(unit);
		r_rv = _wlan_client_add_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->home_agent);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->wlan_port_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->wtp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_wlan_client_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_wlan_client_delete( \
    int unit, bcm_mac_t mac);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_wlan_client_delete,
static int (*_wlan_client_delete_dispatch[])(
    int unit, 
    bcm_mac_t mac) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_wlan_client_delete(
    int unit, 
    bcm_mac_t mac)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _wlan_client_delete_dispatch[dtype](unit, mac);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_wlan_client_delete", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_wlan_client_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_wlan_client_delete_all,
static int (*_wlan_client_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_wlan_client_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _wlan_client_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_wlan_client_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_wlan_client_get( \
    int unit, bcm_mac_t mac, bcm_wlan_client_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_wlan_client_get,
static int (*_wlan_client_get_dispatch[])(
    int unit, 
    bcm_mac_t mac, 
    bcm_wlan_client_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_wlan_client_get(
    int unit, 
    bcm_mac_t mac, 
    bcm_wlan_client_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->home_agent);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->wlan_port_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->wtp);
		dtype = BCM_DTYPE(unit);
		r_rv = _wlan_client_get_dispatch[dtype](unit, mac, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->home_agent);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->wlan_port_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->wtp);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_wlan_client_get", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_wlan_client_traverse( \
    int unit, bcm_wlan_client_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_wlan_client_traverse,
static int (*_wlan_client_traverse_dispatch[])(
    int unit, 
    bcm_wlan_client_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_wlan_client_traverse(
    int unit, 
    bcm_wlan_client_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _wlan_client_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_wlan_client_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_wlan_detach( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_wlan_detach,
static int (*_wlan_detach_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_wlan_detach(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _wlan_detach_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_wlan_detach", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_wlan_init( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_wlan_init,
static int (*_wlan_init_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_wlan_init(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _wlan_init_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_wlan_init", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_wlan_port_add( \
    int unit, bcm_wlan_port_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_wlan_port_add,
static int (*_wlan_port_add_dispatch[])(
    int unit, 
    bcm_wlan_port_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_wlan_port_add(
    int unit, 
    bcm_wlan_port_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->egress_tunnel);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->match_tunnel);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->wlan_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _wlan_port_add_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->egress_tunnel);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->match_tunnel);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->wlan_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_wlan_port_add", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_wlan_port_delete( \
    int unit, bcm_gport_t wlan_port_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_wlan_port_delete,
static int (*_wlan_port_delete_dispatch[])(
    int unit, 
    bcm_gport_t wlan_port_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_wlan_port_delete(
    int unit, 
    bcm_gport_t wlan_port_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&wlan_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _wlan_port_delete_dispatch[dtype](unit, wlan_port_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_wlan_port_delete", 2, 2, unit, wlan_port_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_wlan_port_delete_all( \
    int unit);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_wlan_port_delete_all,
static int (*_wlan_port_delete_all_dispatch[])(
    int unit) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_wlan_port_delete_all(
    int unit)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _wlan_port_delete_all_dispatch[dtype](unit);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_wlan_port_delete_all", 1, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_wlan_port_get( \
    int unit, bcm_gport_t wlan_port_id, bcm_wlan_port_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_wlan_port_get,
static int (*_wlan_port_get_dispatch[])(
    int unit, 
    bcm_gport_t wlan_port_id, 
    bcm_wlan_port_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_wlan_port_get(
    int unit, 
    bcm_gport_t wlan_port_id, 
    bcm_wlan_port_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&wlan_port_id);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->egress_tunnel);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->match_tunnel);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->wlan_port_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _wlan_port_get_dispatch[dtype](unit, wlan_port_id, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->egress_tunnel);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->match_tunnel);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->port);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->wlan_port_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_wlan_port_get", 3, 2, unit, wlan_port_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_wlan_port_traverse( \
    int unit, bcm_wlan_port_traverse_cb cb, void *user_data);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_wlan_port_traverse,
static int (*_wlan_port_traverse_dispatch[])(
    int unit, 
    bcm_wlan_port_traverse_cb cb, 
    void *user_data) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_wlan_port_traverse(
    int unit, 
    bcm_wlan_port_traverse_cb cb, 
    void *user_data)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		dtype = BCM_DTYPE(unit);
		r_rv = _wlan_port_traverse_dispatch[dtype](unit, cb, user_data);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_wlan_port_traverse", 3, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_wlan_tunnel_initiator_create( \
    int unit, bcm_tunnel_initiator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_wlan_tunnel_initiator_create,
static int (*_wlan_tunnel_initiator_create_dispatch[])(
    int unit, 
    bcm_tunnel_initiator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_wlan_tunnel_initiator_create(
    int unit, 
    bcm_tunnel_initiator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _wlan_tunnel_initiator_create_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_wlan_tunnel_initiator_create", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_wlan_tunnel_initiator_destroy( \
    int unit, bcm_gport_t wlan_tunnel_id);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_wlan_tunnel_initiator_destroy,
static int (*_wlan_tunnel_initiator_destroy_dispatch[])(
    int unit, 
    bcm_gport_t wlan_tunnel_id) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_wlan_tunnel_initiator_destroy(
    int unit, 
    bcm_gport_t wlan_tunnel_id)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_A2P(unit,&wlan_tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _wlan_tunnel_initiator_destroy_dispatch[dtype](unit, wlan_tunnel_id);
		BCM_STATE_SYNC(unit);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_wlan_tunnel_initiator_destroy", 2, 2, unit, wlan_tunnel_id, 0, r_rv);
	return r_rv;
}
#endif

#if defined(INCLUDE_L3)
/* BCM Devlist macros for generating the dispatch table for this function */

/* Externs for the required functions */
#define BCM_DLIST_ENTRY(_dtype) \
extern int bcm_##_dtype##_wlan_tunnel_initiator_get( \
    int unit, bcm_tunnel_initiator_t *info);
#include <bcm_int/bcm_dlist.h>

/* Dispatch table for this function, which uses the externs above */
#define BCM_DLIST_ENTRY(_dtype)\
bcm_##_dtype##_wlan_tunnel_initiator_get,
static int (*_wlan_tunnel_initiator_get_dispatch[])(
    int unit, 
    bcm_tunnel_initiator_t *info) =
{
#include <bcm_int/bcm_dlist.h>
0
};


int 
bcm_wlan_tunnel_initiator_get(
    int unit, 
    bcm_tunnel_initiator_t *info)
{
	int	r_rv;
	bcm_dtype_t	dtype;

	if (!BCM_UNIT_CHECK(unit)) {
		r_rv = BCM_E_UNIT;
	} else {
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_A2P(unit,&info->tunnel_id);
		dtype = BCM_DTYPE(unit);
		r_rv = _wlan_tunnel_initiator_get_dispatch[dtype](unit, info);
		BCM_STATE_SYNC(unit);
		BCM_API_XLATE_PORT_COND(info) BCM_API_XLATE_PORT_P2A(unit,&info->tunnel_id);
	}
	BCM_UNIT_IDLE(unit);
	BCM_API("bcm_wlan_tunnel_initiator_get", 2, 1, unit, 0, 0, r_rv);
	return r_rv;
}
#endif

