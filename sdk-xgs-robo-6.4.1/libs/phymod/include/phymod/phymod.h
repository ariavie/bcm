/*
 *         
 * $Id: phymod.xml,v 1.1.2.5 Broadcom SDK $
 * 
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *         
 *     
 * DO NOT EDIT THIS FILE!
 *
 */

#ifndef _PHYMOD_H__H_
#define _PHYMOD_H__H_

#include <phymod/phymod_definitions.h>

/*!
 * @enum phymod_dispatch_type_e
 * @brief Supported Drivers 
 */ 
typedef enum phymod_dispatch_type_e {
#ifdef PHYMOD_EAGLE_SUPPORT
    phymodDispatchTypeEagle,
#endif /*PHYMOD_EAGLE_SUPPORT  */
#ifdef PHYMOD_FALCON_SUPPORT
    phymodDispatchTypeFalcon,
#endif /*PHYMOD_FALCON_SUPPORT  */
#ifdef PHYMOD_QSGMIIE_SUPPORT
    phymodDispatchTypeQsgmiie,
#endif /*PHYMOD_QSGMIIE_SUPPORT  */
#ifdef PHYMOD_TSCE_SUPPORT
    phymodDispatchTypeTsce,
#endif /*PHYMOD_TSCE_SUPPORT  */
#ifdef PHYMOD_TSCF_SUPPORT
    phymodDispatchTypeTscf,
#endif /*PHYMOD_TSCF_SUPPORT  */
    phymodDispatchTypeCount
} phymod_dispatch_type_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_dispatch_type_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_dispatch_type_t validation */
int phymod_dispatch_type_t_validate(phymod_dispatch_type_t phymod_dispatch_type);
#define PHYMOD_MAX_LANES_PER_CORE PHYMOD_CONFIG_MAX_LANES_PER_CORE

/*! 
 * phymod_bus_read_f
 *
 * @brief function definition for register read operations 
 *
 * @param [inout] user_acc        - Optional application data
 * @param [in]  core_addr       - Core address
 * @param [in]  reg_addr        - address to read
 * @param [out]  val             - read value
 */
typedef int (*phymod_bus_read_f)(void* user_acc, uint32_t core_addr, uint32_t reg_addr, uint32_t* val);

/*! 
 * phymod_bus_write_f
 *
 * @brief function definition for register write operations 
 *
 * @param [inout] user_acc        - Optional application data
 * @param [in]  core_addr       - Core address
 * @param [in]  reg_addr        - address to write
 * @param [in]  val             - write value
 */
typedef int (*phymod_bus_write_f)(void* user_acc, uint32_t core_addr, uint32_t reg_addr, uint32_t val);

/*! 
 * phymod_bus_mutex_take_f
 *
 * @brief function definition for take bus mutex 
 *
 * @param [inout] user_acc        - Optional application data
 */
typedef int (*phymod_bus_mutex_take_f)(void* user_acc);

/*! 
 * phymod_bus_mutex_give_f
 *
 * @brief function definition for give bus mutex 
 *
 * @param [inout] user_acc        - Optional application data
 */
typedef int (*phymod_bus_mutex_give_f)(void* user_acc);

/*! 
 * @brief Bus capabilities 
 */ 
#define PHYMOD_BUS_CA_WR_MODIFY 0x1 /**< The bus support modify functionality */
#define PHYMOD_BUS_CA_LANE_CTRL 0x2 /**< The bus support direct lane configuration */

#define PHYMOD_BUS_CA_WR_MODIFY_SET(bus) ((bus)->bus_capabilities |= PHYMOD_BUS_CA_WR_MODIFY)
#define PHYMOD_BUS_CA_LANE_CTRL_SET(bus) ((bus)->bus_capabilities |= PHYMOD_BUS_CA_LANE_CTRL)

#define PHYMOD_BUS_CA_IS_WR_MODIFY(bus) ((bus)->bus_capabilities & PHYMOD_BUS_CA_WR_MODIFY ? 1 : 0)
#define PHYMOD_BUS_CA_IS_LANE_CTRL(bus) ((bus)->bus_capabilities & PHYMOD_BUS_CA_LANE_CTRL ? 1 : 0)

typedef struct phymod_bus_s {
    char* bus_name;
    phymod_bus_read_f read;
    phymod_bus_write_f write;
    phymod_bus_mutex_take_f mutex_take;
    phymod_bus_mutex_give_f mutex_give;
    uint32_t bus_capabilities;
} phymod_bus_t;

/* phymod_bus_t initialization and validation */
int phymod_bus_t_validate(const phymod_bus_t* phymod_bus);
int phymod_bus_t_init(phymod_bus_t* phymod_bus);

/*! 
 * @brief Phymod access flags 
 */ 
#define PHYMOD_PHYMOD_ACC_F_CLAUSE45 0x1 /**< Use CL45 to access */

#define PHYMOD_PHYMOD_ACC_F_CLAUSE45_SET(access) ((access)->flags |= PHYMOD_PHYMOD_ACC_F_CLAUSE45)

#define PHYMOD_PHYMOD_ACC_F_IS_CLAUSE45(access) ((access)->flags & PHYMOD_PHYMOD_ACC_F_CLAUSE45 ? 1 : 0)

typedef struct phymod_access_s {
    void* user_acc; /**< Optional application data - not used by PHY driver */
    phymod_bus_t* bus; /**< PHY bus driver */
    uint32_t flags; /**< PHYMOD_ACC_F_xxx flags */
    uint32_t lane; /**< specific lane */
    uint32_t addr; /**< PHY address (PHYAD) used by this PHY */
    uint32_t devad; /**< Default clause 45 DEVAD if none are specified */
} phymod_access_t;

/* phymod_access_t initialization and validation */
int phymod_access_t_validate(const phymod_access_t* phymod_access);
int phymod_access_t_init(phymod_access_t* phymod_access);

#define PHYMOD_ACC_USER_ACC(access_) ((access_)->user_acc)
#define PHYMOD_ACC_BUS(access_) ((access_)->bus)
#define PHYMOD_ACC_FLAGS(access_) ((access_)->flags)
#define PHYMOD_ACC_LANE(access_) ((access_)->lane)
#define PHYMOD_ACC_ADDR(access_) ((access_)->addr)
#define PHYMOD_ACC_DEVAD(access_) ((access_)->devad)

typedef struct phymod_core_access_s {
    phymod_access_t access;
    phymod_dispatch_type_t type; /**< Driver Type */
} phymod_core_access_t;

/* phymod_core_access_t initialization and validation */
int phymod_core_access_t_validate(const phymod_core_access_t* phymod_core_access);
int phymod_core_access_t_init(phymod_core_access_t* phymod_core_access);

typedef struct phymod_phy_access_s {
    phymod_access_t access;
    phymod_dispatch_type_t type; /**< Driver Type */
} phymod_phy_access_t;

/* phymod_phy_access_t initialization and validation */
int phymod_phy_access_t_validate(const phymod_phy_access_t* phymod_phy_access);
int phymod_phy_access_t_init(phymod_phy_access_t* phymod_phy_access);

/*! 
 * phymod_firmware_loader_f
 *
 * @brief function definition for firmware loading 
 *
 * @param [in]  core            - core access information
 * @param [in]  length          - Firmware length
 * @param [in]  data            - Frimware data
 */
typedef int (*phymod_firmware_loader_f)(const phymod_core_access_t* core, uint32_t length, const uint8_t* data);


/*!
 * @struct phymod_value_override_s
 * @brief The value_override structure is used for values which can be auto-set (enable=0) or override (enable=1 + value) 
 */ 
typedef struct phymod_value_override_s {
    uint32_t enable;
    uint32_t value;
} phymod_value_override_t;

/* phymod_value_override_t initialization and validation */
int phymod_value_override_t_validate(const phymod_value_override_t* phymod_value_override);
int phymod_value_override_t_init(phymod_value_override_t* phymod_value_override);

/*! 
 * phymod_core_probe
 *
 * @brief Probe Core 
 *
 * @param [in]  access          - Access information
 * @param [out]  type            - Driver type
 */
int phymod_core_probe(const phymod_access_t* access, phymod_dispatch_type_t* type);

/*! 
 * phymod_core_identify
 *
 * @brief Initialize phymod module 
 *
 * @param [in]  core            - core access information
 * @param [in]  core_id         - If 0 read the id from the hardware and compare to the driver id. Else compare this parameter to the driver id.
 * @param [out]  is_identified   - 1 if indentification IDs match type, 0 otherwise
 */
int phymod_core_identify(const phymod_core_access_t* core, uint32_t core_id, uint32_t* is_identified);


/*!
 * @enum phymod_core_version_e
 * @brief core version 
 */ 
typedef enum phymod_core_version_e {
    phymodCoreVersionFalconA0 = 0,
    phymodCoreVersionEagleA0,
    phymodCoreVersionQsgmiieA0,
    phymodCoreVersionTsce4A0,
    phymodCoreVersionTsce12A0,
    phymodCoreVersionTscfA0,
    phymodCoreVersionCount
} phymod_core_version_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_core_version_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_core_version_t validation */
int phymod_core_version_t_validate(phymod_core_version_t phymod_core_version);

/*!
 * @struct phymod_core_info_s
 * @brief Core information 
 */ 
typedef struct phymod_core_info_s {
    phymod_core_version_t core_version; /**< core version */
    uint32_t serdes_id; /**< serdes_id */
} phymod_core_info_t;

/* phymod_core_info_t initialization and validation */
int phymod_core_info_t_validate(const phymod_core_info_t* phymod_core_info);
int phymod_core_info_t_init(phymod_core_info_t* phymod_core_info);

/*! 
 * phymod_core_info_get
 *
 * @brief Retrive core information 
 *
 * @param [in]  core            - core access information
 * @param [out]  info            - core information
 */
int phymod_core_info_get(const phymod_core_access_t* core, phymod_core_info_t* info);


/*!
 * @struct phymod_lane_map_s
 * @brief Core information 
 */ 
typedef struct phymod_lane_map_s {
    uint32_t num_of_lanes; /**< Number of elements in lane_map_rx/tx arrays */
    uint32_t lane_map_rx[PHYMOD_MAX_LANES_PER_CORE]; /**< lane_map_rx[x]=y means that rx lane x is mapped to rx lane y */
    uint32_t lane_map_tx[PHYMOD_MAX_LANES_PER_CORE]; /**< lane_map_tx[x]=y means that tx lane x is mapped to tx lane y */
} phymod_lane_map_t;

/* phymod_lane_map_t initialization and validation */
int phymod_lane_map_t_validate(const phymod_lane_map_t* phymod_lane_map);
int phymod_lane_map_t_init(phymod_lane_map_t* phymod_lane_map);

/*! 
 * phymod_core_lane_map_set
 *
 * @brief Set/get lane mapping 
 *
 * @param [in]  core            - core access information
 * @param [in]  lane_map        - core information
 */
int phymod_core_lane_map_set(const phymod_core_access_t* core, const phymod_lane_map_t* lane_map);
/*! 
 * phymod_core_lane_map_get
 *
 * @brief Set/get lane mapping 
 *
 * @param [in]  core            - core access information
 * @param [out]  lane_map        - core information
 */
int phymod_core_lane_map_get(const phymod_core_access_t* core, phymod_lane_map_t* lane_map);


/*!
 * @enum phymod_reset_mode_e
 * @brief Reset modes 
 */ 
typedef enum phymod_reset_mode_e {
    phymodResetModeHard = 0, /**< Hard Reset */
    phymodResetModeSoft, /**< Soft Reset */
    phymodResetModeCount
} phymod_reset_mode_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_reset_mode_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_reset_mode_t validation */
int phymod_reset_mode_t_validate(phymod_reset_mode_t phymod_reset_mode);

/*!
 * @enum phymod_reset_direction_e
 * @brief Reset modes 
 */ 
typedef enum phymod_reset_direction_e {
    phymodResetDirectionIn = 0, /**< In Reset */
    phymodResetDirectionOut, /**< Out of Reset */
    phymodResetDirectionInOut, /**< Toggle Reset */
    phymodResetDirectionCount
} phymod_reset_direction_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_reset_direction_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_reset_direction_t validation */
int phymod_reset_direction_t_validate(phymod_reset_direction_t phymod_reset_direction);
/*! 
 * phymod_core_reset_set
 *
 * @brief Reset Core 
 *
 * @param [in]  core            - core access information
 * @param [in]  reset_mode      - reset mode
 * @param [in]  direction       - reset direction
 */
int phymod_core_reset_set(const phymod_core_access_t* core, phymod_reset_mode_t reset_mode, phymod_reset_direction_t direction);
/*! 
 * phymod_core_reset_get
 *
 * @brief Reset Core 
 *
 * @param [in]  core            - core access information
 * @param [in]  reset_mode      - reset mode
 * @param [out]  direction       - reset state
 */
int phymod_core_reset_get(const phymod_core_access_t* core, phymod_reset_mode_t reset_mode, phymod_reset_direction_t* direction);


/*!
 * @struct phymod_core_firmware_info_s
 * @brief Firmware information 
 */ 
typedef struct phymod_core_firmware_info_s {
    uint32_t fw_version;
    uint32_t fw_crc;
} phymod_core_firmware_info_t;

/* phymod_core_firmware_info_t initialization and validation */
int phymod_core_firmware_info_t_validate(const phymod_core_firmware_info_t* phymod_core_firmware_info);
int phymod_core_firmware_info_t_init(phymod_core_firmware_info_t* phymod_core_firmware_info);

/*! 
 * phymod_core_firmware_info_get
 *
 * @brief Retrive firmware information 
 *
 * @param [in]  core            - core access information
 * @param [out]  fw_info         - 
 */
int phymod_core_firmware_info_get(const phymod_core_access_t* core, phymod_core_firmware_info_t* fw_info);


/*!
 * @enum phymod_firmware_media_type_e
 * @brief media_type for firmware 
 */ 
typedef enum phymod_firmware_media_type_e {
    phymodFirmwareMediaTypePcbTraceBackPlane = 0, /**< back plane */
    phymodFirmwareMediaTypeCopperCable, /**< copper cable */
    phymodFirmwareMediaTypeOptics, /**< optical */
    phymodFirmwareMediaTypeCount
} phymod_firmware_media_type_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_firmware_media_type_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_firmware_media_type_t validation */
int phymod_firmware_media_type_t_validate(phymod_firmware_media_type_t phymod_firmware_media_type);

/*!
 * @struct phymod_firmware_core_config_s
 * @brief Firmware core config 
 */ 
typedef struct phymod_firmware_core_config_s {
    uint32_t CoreConfigFromPCS;
    uint32_t VcoRate; /**< vco rate */
} phymod_firmware_core_config_t;

/* phymod_firmware_core_config_t initialization and validation */
int phymod_firmware_core_config_t_validate(const phymod_firmware_core_config_t* phymod_firmware_core_config);
int phymod_firmware_core_config_t_init(phymod_firmware_core_config_t* phymod_firmware_core_config);

/*! 
 * phymod_phy_firmware_core_config_set
 *
 * @brief Set/get firmware operation mode 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  fw_core_config   - firmware core config
 */
int phymod_phy_firmware_core_config_set(const phymod_phy_access_t* phy, phymod_firmware_core_config_t fw_core_config);
/*! 
 * phymod_phy_firmware_core_config_get
 *
 * @brief Set/get firmware operation mode 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  fw_core_config   - firmware core config
 */
int phymod_phy_firmware_core_config_get(const phymod_phy_access_t* phy, phymod_firmware_core_config_t* fw_core_config);


/*!
 * @struct phymod_firmware_lane_config_s
 * @brief Firmware lane config 
 */ 
typedef struct phymod_firmware_lane_config_s {
    uint32_t LaneConfigFromPCS;
    uint32_t AnEnabled; /**< Autoneg */
    uint32_t DfeOn; /**< Enable DFE */
    uint32_t ForceBrDfe; /**< Force Baud rate DFE */
    phymod_firmware_media_type_t MediaType; /**< Media Type */
    uint32_t UnreliableLos; /**< For optical use */
    uint32_t ScramblingDisable; /**< disable scrambling */
    uint32_t Cl72Enable; /**< Forced CL72 */
} phymod_firmware_lane_config_t;

/* phymod_firmware_lane_config_t initialization and validation */
int phymod_firmware_lane_config_t_validate(const phymod_firmware_lane_config_t* phymod_firmware_lane_config);
int phymod_firmware_lane_config_t_init(phymod_firmware_lane_config_t* phymod_firmware_lane_config);

/*! 
 * phymod_phy_firmware_lane_config_set
 *
 * @brief Set/get firmware operation mode 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  fw_lane_config   - firmware lane config
 */
int phymod_phy_firmware_lane_config_set(const phymod_phy_access_t* phy, phymod_firmware_lane_config_t fw_lane_config);
/*! 
 * phymod_phy_firmware_lane_config_get
 *
 * @brief Set/get firmware operation mode 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  fw_lane_config   - firmware lane config
 */
int phymod_phy_firmware_lane_config_get(const phymod_phy_access_t* phy, phymod_firmware_lane_config_t* fw_lane_config);


/*!
 * @enum phymod_sequencer_operation_e
 * @brief Sequencer operations 
 */ 
typedef enum phymod_sequencer_operation_e {
    phymodSeqOpStop = 0, /**< Stop Sequencer */
    phymodSeqOpStart, /**< Start Sequencer */
    phymodSeqOpRestart, /**< Toggle Sequencer */
    phymodSeqOpCount
} phymod_sequencer_operation_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_sequencer_operation_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_sequencer_operation_t validation */
int phymod_sequencer_operation_t_validate(phymod_sequencer_operation_t phymod_sequencer_operation);
/*! 
 * phymod_core_pll_sequencer_restart
 *
 * @brief Start/Stop the sequencer 
 *
 * @param [in]  core            - core access information
 * @param [in]  flags           - 
 * @param [in]  operation       - 
 */
int phymod_core_pll_sequencer_restart(const phymod_core_access_t* core, uint32_t flags, phymod_sequencer_operation_t operation);

#define PHYMOD_SEQ_FLAGS_WAIT_UNTIL_DONE 0x1 /**< Use this flag to wait for PLL lock when starting the sequencer */

typedef enum phymod_core_event_e {
    phymodCoreEventPllLock = 0, /**< PLL locked */
    phymodCoreEventCount
} phymod_core_event_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_core_event_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_core_event_t validation */
int phymod_core_event_t_validate(phymod_core_event_t phymod_core_event);
#define PHYMOD_TIMEOUT_DEFAULT 0xFFFFFFFF /**< Use default timeout */

/*! 
 * phymod_core_wait_event
 *
 * @brief Wait for core event 
 *
 * @param [in]  core            - core access information
 * @param [in]  event           - event to wait for
 * @param [in]  timeout         - 
 */
int phymod_core_wait_event(const phymod_core_access_t* core, phymod_core_event_t event, uint32_t timeout);

/*! 
 * phymod_phy_rx_restart
 *
 * @brief  re-tune rx path 
 *
 * @param [in]  phy             - phy access information
 */
int phymod_phy_rx_restart(const phymod_phy_access_t* phy);

typedef struct phymod_polarity_s {
    uint32_t rx_polarity;
    uint32_t tx_polarity;
} phymod_polarity_t;

/* phymod_polarity_t initialization and validation */
int phymod_polarity_t_validate(const phymod_polarity_t* phymod_polarity);
int phymod_polarity_t_init(phymod_polarity_t* phymod_polarity);

/*! 
 * phymod_phy_polarity_set
 *
 * @brief Set phy polarity 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  polarity        - 
 */
int phymod_phy_polarity_set(const phymod_phy_access_t* phy, const phymod_polarity_t* polarity);
/*! 
 * phymod_phy_polarity_get
 *
 * @brief Set phy polarity 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  polarity        - 
 */
int phymod_phy_polarity_get(const phymod_phy_access_t* phy, phymod_polarity_t* polarity);

/*! 
 * @brief when field of phymod_tx_t struct set to this val. the phymod_tx_set API will not change the specified member value in the HW 
 */ 
#define PHYMOD_TX_DO_NOT_CHANGE_VAL 0xFFFFFFFF


/*!
 * @struct phymod_tx_s
 * @brief TX Parameters 
 */ 
typedef struct phymod_tx_s {
    int8_t pre;
    int8_t main;
    int8_t post;
    int8_t post2;
    int8_t post3;
    int8_t amp;
} phymod_tx_t;

/* phymod_tx_t initialization and validation */
int phymod_tx_t_validate(const phymod_tx_t* phymod_tx);
int phymod_tx_t_init(phymod_tx_t* phymod_tx);

/*! 
 * phymod_phy_tx_set
 *
 * @brief Set/Get TX Parameters 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  tx              - 
 */
int phymod_phy_tx_set(const phymod_phy_access_t* phy, const phymod_tx_t* tx);
/*! 
 * phymod_phy_tx_get
 *
 * @brief Set/Get TX Parameters 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  tx              - 
 */
int phymod_phy_tx_get(const phymod_phy_access_t* phy, phymod_tx_t* tx);

typedef enum phymod_media_typed_e {
    phymodMediaTypeChipToChip = 0,
    phymodMediaTypeShort,
    phymodMediaTypeMid,
    phymodMediaTypeLong,
    phymodMediaTypeCount
} phymod_media_typed_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_media_typed_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_media_typed_t validation */
int phymod_media_typed_t_validate(phymod_media_typed_t phymod_media_typed);
/*! 
 * phymod_phy_media_type_tx_get
 *
 * @brief Request for default TX parameters configuration per media type 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  media           - 
 * @param [out]  tx              - 
 */
int phymod_phy_media_type_tx_get(const phymod_phy_access_t* phy, phymod_media_typed_t media, phymod_tx_t* tx);


/*!
 * @struct phymod_tx_override_s
 * @brief TX parameters which can be auto-set or override 
 */ 
typedef struct phymod_tx_override_s {
    phymod_value_override_t phase_interpolator;
} phymod_tx_override_t;

/* phymod_tx_override_t initialization and validation */
int phymod_tx_override_t_validate(const phymod_tx_override_t* phymod_tx_override);
int phymod_tx_override_t_init(phymod_tx_override_t* phymod_tx_override);

/*! 
 * phymod_phy_tx_override_set
 *
 * @brief Set/Get TX override Parameters 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  tx_override     - 
 */
int phymod_phy_tx_override_set(const phymod_phy_access_t* phy, const phymod_tx_override_t* tx_override);
/*! 
 * phymod_phy_tx_override_get
 *
 * @brief Set/Get TX override Parameters 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  tx_override     - 
 */
int phymod_phy_tx_override_get(const phymod_phy_access_t* phy, phymod_tx_override_t* tx_override);

#define PHYMOD_NUM_DFE_TAPS 5 /**< MAX num of DFE TAPS */


/*!
 * @struct phymod_rx_s
 * @brief RX Parameters 
 */ 
typedef struct phymod_rx_s {
    phymod_value_override_t vga;
    uint32_t num_of_dfe_taps; /**< number of elements in DFE array */
    phymod_value_override_t dfe[PHYMOD_NUM_DFE_TAPS];
    phymod_value_override_t peaking_filter;
    phymod_value_override_t low_freq_peaking_filter;
} phymod_rx_t;

/* phymod_rx_t initialization and validation */
int phymod_rx_t_validate(const phymod_rx_t* phymod_rx);
int phymod_rx_t_init(phymod_rx_t* phymod_rx);

/*! 
 * phymod_phy_rx_set
 *
 * @brief Set/Get RX Parameters 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  rx              - 
 */
int phymod_phy_rx_set(const phymod_phy_access_t* phy, const phymod_rx_t* rx);
/*! 
 * phymod_phy_rx_get
 *
 * @brief Set/Get RX Parameters 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  rx              - 
 */
int phymod_phy_rx_get(const phymod_phy_access_t* phy, phymod_rx_t* rx);


/*!
 * @struct phymod_phy_reset_s
 * @brief Direction (In,Out,inOut) for RX/TX to reset 
 */ 
typedef struct phymod_phy_reset_s {
    phymod_reset_direction_t rx;
    phymod_reset_direction_t tx;
} phymod_phy_reset_t;

/* phymod_phy_reset_t initialization and validation */
int phymod_phy_reset_t_validate(const phymod_phy_reset_t* phymod_phy_reset);
int phymod_phy_reset_t_init(phymod_phy_reset_t* phymod_phy_reset);

/*! 
 * phymod_phy_reset_set
 *
 * @brief Reset phy 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  reset           - 
 */
int phymod_phy_reset_set(const phymod_phy_access_t* phy, const phymod_phy_reset_t* reset);
/*! 
 * phymod_phy_reset_get
 *
 * @brief Reset phy 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  reset           - 
 */
int phymod_phy_reset_get(const phymod_phy_access_t* phy, phymod_phy_reset_t* reset);

typedef enum phymod_power_e {
    phymodPowerOff = 0, /**< turn off power */
    phymodPowerOn, /**< turn on power */
    phymodPowerOffOn, /**< toggle power */
    phymodPowerNoChange, /**< stay where you are */
    phymodPowerCount
} phymod_power_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_power_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_power_t validation */
int phymod_power_t_validate(phymod_power_t phymod_power);

/*!
 * @struct phymod_phy_power_s
 * @brief Power operation (On,Off,Off and On) for RX/TX 
 */ 
typedef struct phymod_phy_power_s {
    phymod_power_t rx;
    phymod_power_t tx;
} phymod_phy_power_t;

/* phymod_phy_power_t initialization and validation */
int phymod_phy_power_t_validate(const phymod_phy_power_t* phymod_phy_power);
int phymod_phy_power_t_init(phymod_phy_power_t* phymod_phy_power);

/*! 
 * phymod_phy_power_set
 *
 * @brief Control phy power 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  power           - 
 */
int phymod_phy_power_set(const phymod_phy_access_t* phy, const phymod_phy_power_t* power);
/*! 
 * phymod_phy_power_get
 *
 * @brief Control phy power 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  power           - 
 */
int phymod_phy_power_get(const phymod_phy_access_t* phy, phymod_phy_power_t* power);

/*! 
 * phymod_phy_tx_lane_control_set
 *
 * @brief TX transmission control 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  enable          - 
 */
int phymod_phy_tx_lane_control_set(const phymod_phy_access_t* phy, uint32_t enable);
/*! 
 * phymod_phy_tx_lane_control_get
 *
 * @brief TX transmission control 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  enable          - 
 */
int phymod_phy_tx_lane_control_get(const phymod_phy_access_t* phy, uint32_t* enable);

/*! 
 * phymod_phy_rx_lane_control_set
 *
 * @brief Rx control 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  enable          - 
 */
int phymod_phy_rx_lane_control_set(const phymod_phy_access_t* phy, uint32_t enable);
/*! 
 * phymod_phy_rx_lane_control_get
 *
 * @brief Rx control 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  enable          - 
 */
int phymod_phy_rx_lane_control_get(const phymod_phy_access_t* phy, uint32_t* enable);

/*! 
 * phymod_phy_fec_enable_set
 *
 * @brief forced speed FEC control 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  enable          - 
 */
int phymod_phy_fec_enable_set(const phymod_phy_access_t* phy, uint32_t enable);
/*! 
 * phymod_phy_fec_enable_get
 *
 * @brief forced speed FEC control 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  enable          - 
 */
int phymod_phy_fec_enable_get(const phymod_phy_access_t* phy, uint32_t* enable);

typedef enum phymod_interface_e {
    phymodInterfaceBypass = 0,
    phymodInterfaceSR,
    phymodInterfaceKX,
    phymodInterfaceKX4,
    phymodInterfaceKR,
    phymodInterfaceKR2,
    phymodInterfaceKR4,
    phymodInterfaceCX,
    phymodInterfaceCX2,
    phymodInterfaceCX4,
    phymodInterfaceCR,
    phymodInterfaceCR2,
    phymodInterfaceCR4,
    phymodInterfaceCR10,
    phymodInterfaceXFI,
    phymodInterfaceSFI,
    phymodInterfaceXGMII,
    phymodInterface1000X,
    phymodInterfaceSGMII,
    phymodInterfaceRXAUI,
    phymodInterfaceX2,
    phymodInterfaceXLAUI,
    phymodInterfaceCount
} phymod_interface_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_interface_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_interface_t validation */
int phymod_interface_t_validate(phymod_interface_t phymod_interface);

/*!
 * @enum phymod_ref_clk_e
 * @brief Reference Clock 
 */ 
typedef enum phymod_ref_clk_e {
    phymodRefClk156Mhz = 0, /**< 156.25MHz */
    phymodRefClk125Mhz, /**< 125MHz */
    phymodRefClkCount
} phymod_ref_clk_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_ref_clk_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_ref_clk_t validation */
int phymod_ref_clk_t_validate(phymod_ref_clk_t phymod_ref_clk);
typedef struct phymod_phy_inf_config_s {
    phymod_interface_t interface_type;
    uint32_t data_rate;
    uint32_t interface_modes;
    phymod_ref_clk_t ref_clock; /**< Core reference clock. */
    uint16_t pll_divider_req; /**< Core pll divider request. */
    void * device_aux_modes; /**< Device auxiliary modes. */
} phymod_phy_inf_config_t;

/* phymod_phy_inf_config_t initialization and validation */
int phymod_phy_inf_config_t_validate(const phymod_phy_inf_config_t* phymod_phy_inf_config);
int phymod_phy_inf_config_t_init(phymod_phy_inf_config_t* phymod_phy_inf_config);

#define PHYMOD_DEFAULT_RATE 0xFFFFFFFF /**< Use data_rate=PHYMOD_DEFAULT_RATE to set interface default */

/*! 
 * phymod_phy_interface_config_set
 *
 * @brief TX transmission disable 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  flags           - See PHYMOD_IF_FLAGS_
 * @param [in]  config          - 
 */
int phymod_phy_interface_config_set(const phymod_phy_access_t* phy, uint32_t flags, const phymod_phy_inf_config_t* config);
/*! 
 * phymod_phy_interface_config_get
 *
 * @brief TX transmission disable 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  flags           - See PHYMOD_IF_FLAGS_
 * @param [out]  config          - 
 */
int phymod_phy_interface_config_get(const phymod_phy_access_t* phy, uint32_t flags, phymod_phy_inf_config_t* config);

/*! 
 * @brief Interface properties 
 */ 
#define PHYMOD_INTERFACE_MODES_HIGIG 0x1 /**< Interface is Higig */
#define PHYMOD_INTERFACE_MODES_OS2 0x2 /**< Force working in OS 2 */
#define PHYMOD_INTERFACE_MODES_SCR 0x4 /**< enable scrambler */
#define PHYMOD_INTERFACE_MODES_HALF_DUPLEX 0x8 /**< Interface is half-duplex */
#define PHYMOD_INTERFACE_MODES_FIBER 0x10 /**< Interface is connected to fiber */

#define PHYMOD_INTERFACE_MODES_HIGIG_SET(config) ((config)->interface_modes |= PHYMOD_INTERFACE_MODES_HIGIG)
#define PHYMOD_INTERFACE_MODES_OS2_SET(config) ((config)->interface_modes |= PHYMOD_INTERFACE_MODES_OS2)
#define PHYMOD_INTERFACE_MODES_SCR_SET(config) ((config)->interface_modes |= PHYMOD_INTERFACE_MODES_SCR)
#define PHYMOD_INTERFACE_MODES_HALF_DUPLEX_SET(config) ((config)->interface_modes |= PHYMOD_INTERFACE_MODES_HALF_DUPLEX)
#define PHYMOD_INTERFACE_MODES_FIBER_SET(config) ((config)->interface_modes |= PHYMOD_INTERFACE_MODES_FIBER)

#define PHYMOD_INTERFACE_MODES_IS_HIGIG(config) ((config)->interface_modes & PHYMOD_INTERFACE_MODES_HIGIG ? 1 : 0)
#define PHYMOD_INTERFACE_MODES_IS_OS2(config) ((config)->interface_modes & PHYMOD_INTERFACE_MODES_OS2 ? 1 : 0)
#define PHYMOD_INTERFACE_MODES_IS_SCR(config) ((config)->interface_modes & PHYMOD_INTERFACE_MODES_SCR ? 1 : 0)
#define PHYMOD_INTERFACE_MODES_IS_HALF_DUPLEX(config) ((config)->interface_modes & PHYMOD_INTERFACE_MODES_HALF_DUPLEX ? 1 : 0)
#define PHYMOD_INTERFACE_MODES_IS_FIBER(config) ((config)->interface_modes & PHYMOD_INTERFACE_MODES_FIBER ? 1 : 0)

/*! 
 * @brief Flags for phymod_phy_interface_config_set API 
 */ 
#define PHYMOD_IF_FLAGS_DONT_TURN_OFF_PLL 0x1 /**< Dont turn off PLL when switching the speed */
#define PHYMOD_IF_FLAGS_DONT_OVERIDE_FW_MODE 0x2 /**< Dont change  fw mode settings during interface_config */
#define PHYMOD_IF_FLAGS_DONT_OVERIDE_TX_PARAMS 0x4 /**< Dont change tx parameters during interface_config */
#define PHYMOD_IF_FLAGS_PLL_DIVIDER_OVERRIDE 0x8 /**< Change pll div parameters during interface_config */
#define PHYMOD_IF_FLAGS_PCS_TABLE_OVERRIDE 0x10 /**< Change pcs parameter table during interface_config */

/*! 
 * phymod_phy_cl72_set
 *
 * @brief Set/Get CL72 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  cl72_en         - 
 */
int phymod_phy_cl72_set(const phymod_phy_access_t* phy, uint32_t cl72_en);
/*! 
 * phymod_phy_cl72_get
 *
 * @brief Set/Get CL72 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  cl72_en         - 
 */
int phymod_phy_cl72_get(const phymod_phy_access_t* phy, uint32_t* cl72_en);

typedef struct phymod_cl72_status_s {
    uint32_t enabled;
    uint32_t locked;
} phymod_cl72_status_t;

/* phymod_cl72_status_t initialization and validation */
int phymod_cl72_status_t_validate(const phymod_cl72_status_t* phymod_cl72_status);
int phymod_cl72_status_t_init(phymod_cl72_status_t* phymod_cl72_status);

/*! 
 * phymod_phy_cl72_status_get
 *
 * @brief Get CL72 status 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  status          - 
 */
int phymod_phy_cl72_status_get(const phymod_phy_access_t* phy, phymod_cl72_status_t* status);

/*! 
 * @brief Capabilities for CL73 
 */ 
#define PHYMOD_AN_TECH_ABILITY_1G_KX 0x1
#define PHYMOD_AN_TECH_ABILITY_10G_KX4 0x2
#define PHYMOD_AN_TECH_ABILITY_10G_KR 0x4
#define PHYMOD_AN_TECH_ABILITY_40G_KR4 0x8
#define PHYMOD_AN_TECH_ABILITY_40G_CR4 0x10
#define PHYMOD_AN_TECH_ABILITY_100G_CR10 0x20
#define PHYMOD_AN_TECH_ABILITY_100G_CR4 0x40
#define PHYMOD_AN_TECH_ABILITY_100G_KR4 0x80

#define PHYMOD_AN_TECH_ABILITY_1G_KX_SET(tech_ability) (tech_ability |= PHYMOD_AN_TECH_ABILITY_1G_KX)
#define PHYMOD_AN_TECH_ABILITY_10G_KX4_SET(tech_ability) (tech_ability |= PHYMOD_AN_TECH_ABILITY_10G_KX4)
#define PHYMOD_AN_TECH_ABILITY_10G_KR_SET(tech_ability) (tech_ability |= PHYMOD_AN_TECH_ABILITY_10G_KR)
#define PHYMOD_AN_TECH_ABILITY_40G_KR4_SET(tech_ability) (tech_ability |= PHYMOD_AN_TECH_ABILITY_40G_KR4)
#define PHYMOD_AN_TECH_ABILITY_40G_CR4_SET(tech_ability) (tech_ability |= PHYMOD_AN_TECH_ABILITY_40G_CR4)
#define PHYMOD_AN_TECH_ABILITY_100G_CR10_SET(tech_ability) (tech_ability |= PHYMOD_AN_TECH_ABILITY_100G_CR10)
#define PHYMOD_AN_TECH_ABILITY_100G_CR4_SET(tech_ability) (tech_ability |= PHYMOD_AN_TECH_ABILITY_100G_CR4)
#define PHYMOD_AN_TECH_ABILITY_100G_KR4_SET(tech_ability) (tech_ability |= PHYMOD_AN_TECH_ABILITY_100G_KR4)

#define PHYMOD_AN_TECH_ABILITY_IS_1G_KX(tech_ability) (tech_ability & PHYMOD_AN_TECH_ABILITY_1G_KX ? 1 : 0)
#define PHYMOD_AN_TECH_ABILITY_IS_10G_KX4(tech_ability) (tech_ability & PHYMOD_AN_TECH_ABILITY_10G_KX4 ? 1 : 0)
#define PHYMOD_AN_TECH_ABILITY_IS_10G_KR(tech_ability) (tech_ability & PHYMOD_AN_TECH_ABILITY_10G_KR ? 1 : 0)
#define PHYMOD_AN_TECH_ABILITY_IS_40G_KR4(tech_ability) (tech_ability & PHYMOD_AN_TECH_ABILITY_40G_KR4 ? 1 : 0)
#define PHYMOD_AN_TECH_ABILITY_IS_40G_CR4(tech_ability) (tech_ability & PHYMOD_AN_TECH_ABILITY_40G_CR4 ? 1 : 0)
#define PHYMOD_AN_TECH_ABILITY_IS_100G_CR10(tech_ability) (tech_ability & PHYMOD_AN_TECH_ABILITY_100G_CR10 ? 1 : 0)
#define PHYMOD_AN_TECH_ABILITY_IS_100G_CR4(tech_ability) (tech_ability & PHYMOD_AN_TECH_ABILITY_100G_CR4 ? 1 : 0)
#define PHYMOD_AN_TECH_ABILITY_IS_100G_KR4(tech_ability) (tech_ability & PHYMOD_AN_TECH_ABILITY_100G_KR4 ? 1 : 0)

/*! 
 * @brief Capabilities for CL73_BAM 
 */ 
#define PHYMOD_BAM_CL73_ABL_20G_KR2 0x1
#define PHYMOD_BAM_CL73_ABL_20G_CR2 0x2
#define PHYMOD_BAM_CL73_ABL_40G_KR2 0x4
#define PHYMOD_BAM_CL73_ABL_40G_CR2 0x8
#define PHYMOD_BAM_CL73_ABL_50G_KR2 0x10
#define PHYMOD_BAM_CL73_ABL_50G_CR2 0x20
#define PHYMOD_BAM_CL73_ABL_50G_KR4 0x40
#define PHYMOD_BAM_CL73_ABL_50G_CR4 0x80
#define PHYMOD_BAM_CL73_ABL_20G_KR1 0x100
#define PHYMOD_BAM_CL73_ABL_20G_CR1 0x200
#define PHYMOD_BAM_CL73_ABL_25G_KR1 0x400
#define PHYMOD_BAM_CL73_ABL_25G_CR1 0x800

#define PHYMOD_BAM_CL73_ABL_20G_KR2_SET(bam73_ability) (bam73_ability |= PHYMOD_BAM_CL73_ABL_20G_KR2)
#define PHYMOD_BAM_CL73_ABL_20G_CR2_SET(bam73_ability) (bam73_ability |= PHYMOD_BAM_CL73_ABL_20G_CR2)
#define PHYMOD_BAM_CL73_ABL_40G_KR2_SET(bam73_ability) (bam73_ability |= PHYMOD_BAM_CL73_ABL_40G_KR2)
#define PHYMOD_BAM_CL73_ABL_40G_CR2_SET(bam73_ability) (bam73_ability |= PHYMOD_BAM_CL73_ABL_40G_CR2)
#define PHYMOD_BAM_CL73_ABL_50G_KR2_SET(bam73_ability) (bam73_ability |= PHYMOD_BAM_CL73_ABL_50G_KR2)
#define PHYMOD_BAM_CL73_ABL_50G_CR2_SET(bam73_ability) (bam73_ability |= PHYMOD_BAM_CL73_ABL_50G_CR2)
#define PHYMOD_BAM_CL73_ABL_50G_KR4_SET(bam73_ability) (bam73_ability |= PHYMOD_BAM_CL73_ABL_50G_KR4)
#define PHYMOD_BAM_CL73_ABL_50G_CR4_SET(bam73_ability) (bam73_ability |= PHYMOD_BAM_CL73_ABL_50G_CR4)
#define PHYMOD_BAM_CL73_ABL_20G_KR1_SET(bam73_ability) (bam73_ability |= PHYMOD_BAM_CL73_ABL_20G_KR1)
#define PHYMOD_BAM_CL73_ABL_20G_CR1_SET(bam73_ability) (bam73_ability |= PHYMOD_BAM_CL73_ABL_20G_CR1)
#define PHYMOD_BAM_CL73_ABL_25G_KR1_SET(bam73_ability) (bam73_ability |= PHYMOD_BAM_CL73_ABL_25G_KR1)
#define PHYMOD_BAM_CL73_ABL_25G_CR1_SET(bam73_ability) (bam73_ability |= PHYMOD_BAM_CL73_ABL_25G_CR1)

#define PHYMOD_BAM_CL73_ABL_IS_20G_KR2(bam73_ability) (bam73_ability & PHYMOD_BAM_CL73_ABL_20G_KR2 ? 1 : 0)
#define PHYMOD_BAM_CL73_ABL_IS_20G_CR2(bam73_ability) (bam73_ability & PHYMOD_BAM_CL73_ABL_20G_CR2 ? 1 : 0)
#define PHYMOD_BAM_CL73_ABL_IS_40G_KR2(bam73_ability) (bam73_ability & PHYMOD_BAM_CL73_ABL_40G_KR2 ? 1 : 0)
#define PHYMOD_BAM_CL73_ABL_IS_40G_CR2(bam73_ability) (bam73_ability & PHYMOD_BAM_CL73_ABL_40G_CR2 ? 1 : 0)
#define PHYMOD_BAM_CL73_ABL_IS_50G_KR2(bam73_ability) (bam73_ability & PHYMOD_BAM_CL73_ABL_50G_KR2 ? 1 : 0)
#define PHYMOD_BAM_CL73_ABL_IS_50G_CR2(bam73_ability) (bam73_ability & PHYMOD_BAM_CL73_ABL_50G_CR2 ? 1 : 0)
#define PHYMOD_BAM_CL73_ABL_IS_50G_KR4(bam73_ability) (bam73_ability & PHYMOD_BAM_CL73_ABL_50G_KR4 ? 1 : 0)
#define PHYMOD_BAM_CL73_ABL_IS_50G_CR4(bam73_ability) (bam73_ability & PHYMOD_BAM_CL73_ABL_50G_CR4 ? 1 : 0)
#define PHYMOD_BAM_CL73_ABL_IS_20G_KR1(bam73_ability) (bam73_ability & PHYMOD_BAM_CL73_ABL_20G_KR1 ? 1 : 0)
#define PHYMOD_BAM_CL73_ABL_IS_20G_CR1(bam73_ability) (bam73_ability & PHYMOD_BAM_CL73_ABL_20G_CR1 ? 1 : 0)
#define PHYMOD_BAM_CL73_ABL_IS_25G_KR1(bam73_ability) (bam73_ability & PHYMOD_BAM_CL73_ABL_25G_KR1 ? 1 : 0)
#define PHYMOD_BAM_CL73_ABL_IS_25G_CR1(bam73_ability) (bam73_ability & PHYMOD_BAM_CL73_ABL_25G_CR1 ? 1 : 0)

/*! 
 * @brief Capabilities for CL37BAM 
 */ 
#define PHYMOD_BAM_CL37_ABL_2P5G 0x1
#define PHYMOD_BAM_CL37_ABL_5G_X4 0x2
#define PHYMOD_BAM_CL37_ABL_6G_X4 0x4
#define PHYMOD_BAM_CL37_ABL_10G_HIGIG 0x8
#define PHYMOD_BAM_CL37_ABL_10G_CX4 0x10
#define PHYMOD_BAM_CL37_ABL_12G_X4 0x20
#define PHYMOD_BAM_CL37_ABL_12P5_X4 0x40
#define PHYMOD_BAM_CL37_ABL_13G_X4 0x80
#define PHYMOD_BAM_CL37_ABL_15G_X4 0x100
#define PHYMOD_BAM_CL37_ABL_16G_X4 0x200
#define PHYMOD_BAM_CL37_ABL_20G_X4_CX4 0x400
#define PHYMOD_BAM_CL37_ABL_20G_X4 0x800
#define PHYMOD_BAM_CL37_ABL_21G_X4 0x1000
#define PHYMOD_BAM_CL37_ABL_25P455G 0x2000
#define PHYMOD_BAM_CL37_ABL_31P5G 0x4000
#define PHYMOD_BAM_CL37_ABL_32P7G 0x8000
#define PHYMOD_BAM_CL37_ABL_40G 0x10000
#define PHYMOD_BAM_CL37_ABL_10G_X2_CX4 0x20000
#define PHYMOD_BAM_CL37_ABL_10G_DXGXS 0x40000
#define PHYMOD_BAM_CL37_ABL_10P5G_DXGXS 0x80000
#define PHYMOD_BAM_CL37_ABL_12P7_DXGXS 0x100000
#define PHYMOD_BAM_CL37_ABL_15P75G_R2 0x200000
#define PHYMOD_BAM_CL37_ABL_20G_X2_CX4 0x400000
#define PHYMOD_BAM_CL37_ABL_20G_X2 0x800000

#define PHYMOD_BAM_CL37_ABL_2P5G_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_2P5G)
#define PHYMOD_BAM_CL37_ABL_5G_X4_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_5G_X4)
#define PHYMOD_BAM_CL37_ABL_6G_X4_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_6G_X4)
#define PHYMOD_BAM_CL37_ABL_10G_HIGIG_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_10G_HIGIG)
#define PHYMOD_BAM_CL37_ABL_10G_CX4_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_10G_CX4)
#define PHYMOD_BAM_CL37_ABL_12G_X4_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_12G_X4)
#define PHYMOD_BAM_CL37_ABL_12P5_X4_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_12P5_X4)
#define PHYMOD_BAM_CL37_ABL_13G_X4_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_13G_X4)
#define PHYMOD_BAM_CL37_ABL_15G_X4_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_15G_X4)
#define PHYMOD_BAM_CL37_ABL_16G_X4_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_16G_X4)
#define PHYMOD_BAM_CL37_ABL_20G_X4_CX4_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_20G_X4_CX4)
#define PHYMOD_BAM_CL37_ABL_20G_X4_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_20G_X4)
#define PHYMOD_BAM_CL37_ABL_21G_X4_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_21G_X4)
#define PHYMOD_BAM_CL37_ABL_25P455G_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_25P455G)
#define PHYMOD_BAM_CL37_ABL_31P5G_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_31P5G)
#define PHYMOD_BAM_CL37_ABL_32P7G_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_32P7G)
#define PHYMOD_BAM_CL37_ABL_40G_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_40G)
#define PHYMOD_BAM_CL37_ABL_10G_X2_CX4_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_10G_X2_CX4)
#define PHYMOD_BAM_CL37_ABL_10G_DXGXS_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_10G_DXGXS)
#define PHYMOD_BAM_CL37_ABL_10P5G_DXGXS_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_10P5G_DXGXS)
#define PHYMOD_BAM_CL37_ABL_12P7_DXGXS_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_12P7_DXGXS)
#define PHYMOD_BAM_CL37_ABL_15P75G_R2_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_15P75G_R2)
#define PHYMOD_BAM_CL37_ABL_20G_X2_CX4_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_20G_X2_CX4)
#define PHYMOD_BAM_CL37_ABL_20G_X2_SET(bam37_ability) (bam37_ability |= PHYMOD_BAM_CL37_ABL_20G_X2)

#define PHYMOD_BAM_CL37_ABL_IS_2P5G(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_2P5G ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_5G_X4(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_5G_X4 ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_6G_X4(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_6G_X4 ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_10G_HIGIG(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_10G_HIGIG ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_10G_CX4(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_10G_CX4 ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_12G_X4(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_12G_X4 ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_12P5_X4(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_12P5_X4 ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_13G_X4(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_13G_X4 ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_15G_X4(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_15G_X4 ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_16G_X4(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_16G_X4 ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_20G_X4_CX4(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_20G_X4_CX4 ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_20G_X4(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_20G_X4 ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_21G_X4(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_21G_X4 ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_25P455G(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_25P455G ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_31P5G(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_31P5G ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_32P7G(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_32P7G ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_40G(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_40G ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_10G_X2_CX4(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_10G_X2_CX4 ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_10G_DXGXS(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_10G_DXGXS ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_10P5G_DXGXS(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_10P5G_DXGXS ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_12P7_DXGXS(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_12P7_DXGXS ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_15P75G_R2(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_15P75G_R2 ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_20G_X2_CX4(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_20G_X2_CX4 ? 1 : 0)
#define PHYMOD_BAM_CL37_ABL_IS_20G_X2(bam37_ability) (bam37_ability & PHYMOD_BAM_CL37_ABL_20G_X2 ? 1 : 0)


/*!
 * @enum phymod_an_mode_type_e
 * @brief an mode type 
 */ 
typedef enum phymod_an_mode_type_e {
    phymod_AN_MODE_CL73 = 0,
    phymod_AN_MODE_CL37,
    phymod_AN_MODE_CL73BAM,
    phymod_AN_MODE_CL37BAM,
    phymod_AN_MODE_HPAM,
    phymod_AN_MODE_SGMII,
    phymod_AN_MODE_NONE,
    phymod_AN_MODE_Count
} phymod_an_mode_type_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_an_mode_type_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_an_mode_type_t validation */
int phymod_an_mode_type_t_validate(phymod_an_mode_type_t phymod_an_mode_type);

/*!
 * @enum phymod_cl37_sgmii_speed_e
 * @brief cl37 sgmii speed type 
 */ 
typedef enum phymod_cl37_sgmii_speed_e {
    phymod_CL37_SGMII_10M = 0,
    phymod_CL37_SGMII_100M,
    phymod_CL37_SGMII_1000M,
    phymod_CL37_SGMII_Count
} phymod_cl37_sgmii_speed_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_cl37_sgmii_speed_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_cl37_sgmii_speed_t validation */
int phymod_cl37_sgmii_speed_t_validate(phymod_cl37_sgmii_speed_t phymod_cl37_sgmii_speed);

/*!
 * @struct phymod_autoneg_ability_s
 * @brief autoneg_ability 
 */ 
typedef struct phymod_autoneg_ability_s {
    uint32_t an_tech_ability;
    uint32_t cl73bam_ability;
    uint32_t cl37bam_ability;
    uint32_t an_fec;
    uint32_t an_cl72;
    uint32_t an_hg2;
    uint32_t capabilities;
    phymod_cl37_sgmii_speed_t sgmii_speed;
} phymod_autoneg_ability_t;

/* phymod_autoneg_ability_t initialization and validation */
int phymod_autoneg_ability_t_validate(const phymod_autoneg_ability_t* phymod_autoneg_ability);
int phymod_autoneg_ability_t_init(phymod_autoneg_ability_t* phymod_autoneg_ability);

/*! 
 * @brief Capabilities for phymod_phy_autoneg_set API 
 */ 
#define PHYMOD_AN_CAPABILITIES_CL37 0x1
#define PHYMOD_AN_CAPABILITIES_CL73 0x2
#define PHYMOD_AN_CAPABILITIES_CL37BAM 0x4
#define PHYMOD_AN_CAPABILITIES_CL73BAM 0x8
#define PHYMOD_AN_CAPABILITIES_HPAM 0x10
#define PHYMOD_AN_CAPABILITIES_SGMII 0x20
#define PHYMOD_AN_CAPABILITIES_SYMM_PAUSE 0x40
#define PHYMOD_AN_CAPABILITIES_ASYM_PAUSE 0x80

#define PHYMOD_AN_CAPABILITIES_CL37_SET(an) ((an)->capabilities |= PHYMOD_AN_CAPABILITIES_CL37)
#define PHYMOD_AN_CAPABILITIES_CL73_SET(an) ((an)->capabilities |= PHYMOD_AN_CAPABILITIES_CL73)
#define PHYMOD_AN_CAPABILITIES_CL37BAM_SET(an) ((an)->capabilities |= PHYMOD_AN_CAPABILITIES_CL37BAM)
#define PHYMOD_AN_CAPABILITIES_CL73BAM_SET(an) ((an)->capabilities |= PHYMOD_AN_CAPABILITIES_CL73BAM)
#define PHYMOD_AN_CAPABILITIES_HPAM_SET(an) ((an)->capabilities |= PHYMOD_AN_CAPABILITIES_HPAM)
#define PHYMOD_AN_CAPABILITIES_SGMII_SET(an) ((an)->capabilities |= PHYMOD_AN_CAPABILITIES_SGMII)
#define PHYMOD_AN_CAPABILITIES_SYMM_PAUSE_SET(an) ((an)->capabilities |= PHYMOD_AN_CAPABILITIES_SYMM_PAUSE)
#define PHYMOD_AN_CAPABILITIES_ASYM_PAUSE_SET(an) ((an)->capabilities |= PHYMOD_AN_CAPABILITIES_ASYM_PAUSE)

#define PHYMOD_AN_CAPABILITIES_IS_CL37(an) ((an)->capabilities & PHYMOD_AN_CAPABILITIES_CL37 ? 1 : 0)
#define PHYMOD_AN_CAPABILITIES_IS_CL73(an) ((an)->capabilities & PHYMOD_AN_CAPABILITIES_CL73 ? 1 : 0)
#define PHYMOD_AN_CAPABILITIES_IS_CL37BAM(an) ((an)->capabilities & PHYMOD_AN_CAPABILITIES_CL37BAM ? 1 : 0)
#define PHYMOD_AN_CAPABILITIES_IS_CL73BAM(an) ((an)->capabilities & PHYMOD_AN_CAPABILITIES_CL73BAM ? 1 : 0)
#define PHYMOD_AN_CAPABILITIES_IS_HPAM(an) ((an)->capabilities & PHYMOD_AN_CAPABILITIES_HPAM ? 1 : 0)
#define PHYMOD_AN_CAPABILITIES_IS_SGMII(an) ((an)->capabilities & PHYMOD_AN_CAPABILITIES_SGMII ? 1 : 0)
#define PHYMOD_AN_CAPABILITIES_IS_SYMM_PAUSE(an) ((an)->capabilities & PHYMOD_AN_CAPABILITIES_SYMM_PAUSE ? 1 : 0)
#define PHYMOD_AN_CAPABILITIES_IS_ASYM_PAUSE(an) ((an)->capabilities & PHYMOD_AN_CAPABILITIES_ASYM_PAUSE ? 1 : 0)

/*! 
 * @brief Flags for autoneg_set API 
 */ 
#define PHYMOD_AN_FLAGS_ALLOW_PLL_CHANGE 0x1

#define PHYMOD_AN_FLAGS_ALLOW_PLL_CHANGE_SET(an) ((an)->flags |= PHYMOD_AN_FLAGS_ALLOW_PLL_CHANGE)

#define PHYMOD_AN_FLAGS_IS_ALLOW_PLL_CHANGE(an) ((an)->flags & PHYMOD_AN_FLAGS_ALLOW_PLL_CHANGE ? 1 : 0)

/*! 
 * phymod_phy_autoneg_ability_set
 *
 * @brief Set/Get autoneg 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  an_ability_set_type   - 
 */
int phymod_phy_autoneg_ability_set(const phymod_phy_access_t* phy, const phymod_autoneg_ability_t* an_ability_set_type);
/*! 
 * phymod_phy_autoneg_ability_get
 *
 * @brief Set/Get autoneg 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  an_ability_get_type   - 
 */
int phymod_phy_autoneg_ability_get(const phymod_phy_access_t* phy, phymod_autoneg_ability_t* an_ability_get_type);

/*! 
 * phymod_phy_autoneg_remote_ability_get
 *
 * @brief Get  remote link autoneg 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  an_ability_get_type   - 
 */
int phymod_phy_autoneg_remote_ability_get(const phymod_phy_access_t* phy, phymod_autoneg_ability_t* an_ability_get_type);

typedef struct phymod_autoneg_control_s {
    phymod_an_mode_type_t an_mode;
    uint32_t num_lane_adv; /**< The number of lanes the autoneg advert */
    uint32_t flags; /**< see AN_FLAGS */
    uint32_t enable;
} phymod_autoneg_control_t;

/* phymod_autoneg_control_t initialization and validation */
int phymod_autoneg_control_t_validate(const phymod_autoneg_control_t* phymod_autoneg_control);
int phymod_autoneg_control_t_init(phymod_autoneg_control_t* phymod_autoneg_control);

/*! 
 * phymod_phy_autoneg_set
 *
 * @brief Set/Get autoneg 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  an              - 
 */
int phymod_phy_autoneg_set(const phymod_phy_access_t* phy, const phymod_autoneg_control_t* an);
/*! 
 * phymod_phy_autoneg_get
 *
 * @brief Set/Get autoneg 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  an              - 
 * @param [out]  an_done         - 
 */
int phymod_phy_autoneg_get(const phymod_phy_access_t* phy, phymod_autoneg_control_t* an, uint32_t* an_done);

typedef struct phymod_autoneg_status_s {
    uint32_t enabled;
    uint32_t locked;
    uint32_t data_rate;
    phymod_interface_t interface;
} phymod_autoneg_status_t;

/* phymod_autoneg_status_t initialization and validation */
int phymod_autoneg_status_t_validate(const phymod_autoneg_status_t* phymod_autoneg_status);
int phymod_autoneg_status_t_init(phymod_autoneg_status_t* phymod_autoneg_status);

/*! 
 * phymod_phy_autoneg_status_get
 *
 * @brief Get Autoneg status 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  status          - 
 */
int phymod_phy_autoneg_status_get(const phymod_phy_access_t* phy, phymod_autoneg_status_t* status);


/*!
 * @enum phymod_firmware_load_method_e
 * @brief Firmware load method 
 */ 
typedef enum phymod_firmware_load_method_e {
    phymodFirmwareLoadMethodNone = 0, /**< Don't load FW */
    phymodFirmwareLoadMethodInternal, /**< Load FW internaly */
    phymodFirmwareLoadMethodExternal, /**< Load FW by a given function */
    phymodFirmwareLoadMethodCount
} phymod_firmware_load_method_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_firmware_load_method_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_firmware_load_method_t validation */
int phymod_firmware_load_method_t_validate(phymod_firmware_load_method_t phymod_firmware_load_method);
typedef struct phymod_core_init_config_s {
    phymod_lane_map_t lane_map;
    phymod_firmware_load_method_t firmware_load_method;
    phymod_firmware_loader_f firmware_loader;
    phymod_firmware_core_config_t firmware_core_config;
    phymod_phy_inf_config_t interface; /**< init values for all lanes */
} phymod_core_init_config_t;

/* phymod_core_init_config_t initialization and validation */
int phymod_core_init_config_t_validate(const phymod_core_init_config_t* phymod_core_init_config);
int phymod_core_init_config_t_init(phymod_core_init_config_t* phymod_core_init_config);

typedef struct phymod_core_status_s {
    uint32_t pmd_active;
} phymod_core_status_t;

/* phymod_core_status_t initialization and validation */
int phymod_core_status_t_validate(const phymod_core_status_t* phymod_core_status);
int phymod_core_status_t_init(phymod_core_status_t* phymod_core_status);

/*! 
 * phymod_core_init
 *
 * @brief Core Initialization 
 *
 * @param [in]  core            - core access information
 * @param [in]  init_config     - 
 * @param [in]  core_status     - 
 */
int phymod_core_init(const phymod_core_access_t* core, const phymod_core_init_config_t* init_config, const phymod_core_status_t* core_status);

typedef struct phymod_phy_init_config_s {
    phymod_polarity_t polarity;
    phymod_tx_t tx[PHYMOD_MAX_LANES_PER_CORE];
    uint32_t cl72_en;
    uint32_t an_en;
} phymod_phy_init_config_t;

/* phymod_phy_init_config_t initialization and validation */
int phymod_phy_init_config_t_validate(const phymod_phy_init_config_t* phymod_phy_init_config);
int phymod_phy_init_config_t_init(phymod_phy_init_config_t* phymod_phy_init_config);

/*! 
 * phymod_phy_init
 *
 * @brief Phy Initialization 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  init_config     - 
 */
int phymod_phy_init(const phymod_phy_access_t* phy, const phymod_phy_init_config_t* init_config);


/*!
 * @enum phymod_loopback_mode_e
 * @brief Loopback modes 
 */ 
typedef enum phymod_loopback_mode_e {
    phymodLoopbackGlobal = 0,
    phymodLoopbackGlobalPMD,
    phymodLoopbackRemotePMD,
    phymodLoopbackRemotePCS,
    phymodLoopbackCount
} phymod_loopback_mode_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_loopback_mode_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_loopback_mode_t validation */
int phymod_loopback_mode_t_validate(phymod_loopback_mode_t phymod_loopback_mode);
/*! 
 * phymod_phy_loopback_set
 *
 * @brief Set/get loopback mode 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  loopback        - loopback mode
 * @param [in]  enable          - is loopback set
 */
int phymod_phy_loopback_set(const phymod_phy_access_t* phy, phymod_loopback_mode_t loopback, uint32_t enable);
/*! 
 * phymod_phy_loopback_get
 *
 * @brief Set/get loopback mode 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  loopback        - loopback mode
 * @param [out]  enable          - is loopback set
 */
int phymod_phy_loopback_get(const phymod_phy_access_t* phy, phymod_loopback_mode_t loopback, uint32_t* enable);

/*! 
 * phymod_phy_rx_pmd_locked_get
 *
 * @brief Get rx pmd locked indication 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  rx_pmd_locked   - bmap of rx pmd locked indications
 */
int phymod_phy_rx_pmd_locked_get(const phymod_phy_access_t* phy, uint32_t* rx_pmd_locked);

/*! 
 * phymod_phy_link_status_get
 *
 * @brief Get link up status indication 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  link_status     - 
 */
int phymod_phy_link_status_get(const phymod_phy_access_t* phy, uint32_t* link_status);

/*! 
 * phymod_phy_status_dump
 *
 * @brief Get the serdes status 
 *
 * @param [in]  phy             - phy access information
 */
int phymod_phy_status_dump(const phymod_phy_access_t* phy);


/*!
 * @enum phymod_pcs_userspeed_mode_e
 * @brief modes for phymod_phy_pcs_userspeed API 
 */ 
typedef enum phymod_pcs_userspeed_mode_e {
    phymodPcsUserSpeedModeST = 0, /**< PCS Sw Table */
    phymodPcsUserSpeedModeHTO, /**< PCS Hw Table Override */
    phymodPcsUserSpeedModeCount
} phymod_pcs_userspeed_mode_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_pcs_userspeed_mode_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_pcs_userspeed_mode_t validation */
int phymod_pcs_userspeed_mode_t_validate(phymod_pcs_userspeed_mode_t phymod_pcs_userspeed_mode);

/*!
 * @enum phymod_pcs_userspeed_param_e
 * @brief parameters for phymod_phy_pcs_userspeed API 
 */ 
typedef enum phymod_pcs_userspeed_param_e {
    phymodPcsUserSpeedParamEntry = 0, /**< ST current entry */
    phymodPcsUserSpeedParamHCD, /**< ST HCD */
    phymodPcsUserSpeedParamClear, /**< HTO Clear */
    phymodPcsUserSpeedParamPllDiv, /**< ST/HTO PLL DIV */
    phymodPcsUserSpeedParamPmaOS, /**< ST/HTO PMA OS */
    phymodPcsUserSpeedParamScramble, /**< Scramble mode */
    phymodPcsUserSpeedParamEncode, /**< Encode mode */
    phymodPcsUserSpeedParamCl48CheckEnd, /**< CL48 Check end */
    phymodPcsUserSpeedParamBlkSync, /**< Block sync mode */
    phymodPcsUserSpeedParamReorder, /**< Reorder mode */
    phymodPcsUserSpeedParamCl36Enable, /**< CL36 enable */
    phymodPcsUserSpeedParamDescr1, /**< Descramble1 mode */
    phymodPcsUserSpeedParamDecode1, /**< Decode1 mode */
    phymodPcsUserSpeedParamDeskew, /**< Deskew mode */
    phymodPcsUserSpeedParamDescr2, /**< Descramble2 mode */
    phymodPcsUserSpeedParamDescr2ByteDel,
    phymodPcsUserSpeedParamBrcm64B66, /**< Drcm64/66 descramble */
    phymodPcsUserSpeedParamSgmii, /**< SGMII mode */
    phymodPcsUserSpeedParamClkcnt0, /**< clock count0 */
    phymodPcsUserSpeedParamClkcnt1, /**< clock count1 */
    phymodPcsUserSpeedParamLpcnt0, /**< Loop count0 */
    phymodPcsUserSpeedParamLpcnt1, /**< Loop count1 */
    phymodPcsUserSpeedParamMacCGC, /**< Mac CGC */
    phymodPcsUserSpeedParamRepcnt, /**< Repeat Count */
    phymodPcsUserSpeedParamCrdtEn, /**< Credit Enable */
    phymodPcsUserSpeedParamPcsClkcnt, /**< PCS clock count */
    phymodPcsUserSpeedParamPcsCGC, /**< PCS CGC */
    phymodPcsUserSpeedParamCl72En, /**< Cl72 enable */
    phymodPcsUserSpeedParamNumOfLanes, /**< Num of lanes */
    phymodPcsUserSpeedParamCount
} phymod_pcs_userspeed_param_t;

#ifdef PHYMOD_DIAG
extern enum_mapping_t phymod_pcs_userspeed_param_t_mapping[];
#endif /*PHYMOD_DIAG*/

/* phymod_pcs_userspeed_param_t validation */
int phymod_pcs_userspeed_param_t_validate(phymod_pcs_userspeed_param_t phymod_pcs_userspeed_param);
typedef struct phymod_pcs_userspeed_config_s {
    phymod_pcs_userspeed_mode_t mode;
    phymod_pcs_userspeed_param_t param;
    uint32_t value;
    uint16_t current_entry;
} phymod_pcs_userspeed_config_t;

/* phymod_pcs_userspeed_config_t initialization and validation */
int phymod_pcs_userspeed_config_t_validate(const phymod_pcs_userspeed_config_t* phymod_pcs_userspeed_config);
int phymod_pcs_userspeed_config_t_init(phymod_pcs_userspeed_config_t* phymod_pcs_userspeed_config);

/*! 
 * phymod_phy_pcs_userspeed_set
 *
 * @brief Set/Get User Speed Paramateres 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  config          - 
 */
int phymod_phy_pcs_userspeed_set(const phymod_phy_access_t* phy, const phymod_pcs_userspeed_config_t* config);
/*! 
 * phymod_phy_pcs_userspeed_get
 *
 * @brief Set/Get User Speed Paramateres 
 *
 * @param [in]  phy             - phy access information
 * @param [out]  config          - 
 */
int phymod_phy_pcs_userspeed_get(const phymod_phy_access_t* phy, phymod_pcs_userspeed_config_t* config);

/*! 
 * phymod_phy_reg_read
 *
 * @brief Read phymod register 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  reg_addr        - Register address
 * @param [out]  val             - read value
 */
int phymod_phy_reg_read(const phymod_phy_access_t* phy, uint32_t reg_addr, uint32_t* val);

/*! 
 * phymod_phy_reg_write
 *
 * @brief Write phymod register 
 *
 * @param [in]  phy             - phy access information
 * @param [in]  reg_addr        - Register address
 * @param [in]  val             - write value
 */
int phymod_phy_reg_write(const phymod_phy_access_t* phy, uint32_t reg_addr, uint32_t val);

#endif /*_PHYMOD_H_*/
