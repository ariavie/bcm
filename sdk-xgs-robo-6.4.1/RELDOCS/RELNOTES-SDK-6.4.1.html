<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
        <title>SDK 6.4.1 Release Notes</title>
        
  <style type="text/css"><!--
BODY {
	font-family: "verdana", "arial", "helvetica", "sans-serif";
}
  --></style>
</head>

<body bgcolor="#FFFFFF">

<h2>SDK 6.4.1 Release Notes</h2>
<h3>Section Reference</h3>
<table cellpadding=0 cellspacing=2 border=0 summary="reference" >
<tr><td><a href="#section_about">Section 1: </a></td>
<td>&nbsp;&nbsp;</td><td> About This Document
</td>
<tr><td><a href="#section_docs">Section 2: </a></td>
<td>&nbsp;&nbsp;</td><td> Product Documentation
</td>
<tr><td><a href="#section_new">Section 3: </a></td>
<td>&nbsp;&nbsp;</td><td> New in this Release
</td>
<tr><td>&nbsp;&nbsp;<a href="#new-features-by-device">Section 3.1: </a></td>
<td>&nbsp;&nbsp;</td><td> Summary of New Features
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Greyhound">Section 3.1.1: </a></td>
<td>&nbsp;&nbsp;</td><td> Greyhound
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Ranger2">Section 3.1.2: </a></td>
<td>&nbsp;&nbsp;</td><td> Ranger2 
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FE3200">Section 3.1.3: </a></td>
<td>&nbsp;&nbsp;</td><td> BCM88950 (FE3200) Preview Release
 </td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#JERICHO">Section 3.1.4: </a></td>
<td>&nbsp;&nbsp;</td><td> BCM88670 (Jericho) Preview Release
 </td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ARAD">Section 3.1.5: </a></td>
<td>&nbsp;&nbsp;</td><td> BCM88650 (ARAD) and BCM88660 (ARAD+) Release
 </td>
<tr><td>&nbsp;&nbsp;<a href="#Watch-out-for-this">Section 3.2: </a></td>
<td>&nbsp;&nbsp;</td><td> Things to note
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#bcmx_deprecation">Section 3.2.1: </a></td>
<td>&nbsp;&nbsp;</td><td> BCMX API deprecation
 </td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#phy_issue2">Section 3.2.2: </a></td>
<td>&nbsp;&nbsp;</td><td> BCM8483X PHY Firmware
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#phy_issue3">Section 3.2.3: </a></td>
<td>&nbsp;&nbsp;</td><td> BCM8484X PHY Firmware
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#phy_issue4">Section 3.2.4: </a></td>
<td>&nbsp;&nbsp;</td><td> spn_PHY_PORT_PRIMARY_AND_OFFSET
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#56850_module_64ports">Section 3.2.5: </a></td>
<td>&nbsp;&nbsp;</td><td> BCM56850 handling of module_64ports
 </td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#stack_attach_failure">Section 3.2.6: </a></td>
<td>&nbsp;&nbsp;</td><td> Occasional stack attach failures
 </td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mutex_warning_issue3">Section 3.2.7: </a></td>
<td>&nbsp;&nbsp;</td><td> Unbalanced Mutex warning
 </td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ip_route_lookup">Section 3.2.8: </a></td>
<td>&nbsp;&nbsp;</td><td> IP Route Lookup
 </td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#bcm_field_TunnelType_t">Section 3.2.9: </a></td>
<td>&nbsp;&nbsp;</td><td> BCM Field Qualifier Tunnel Type
 </td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#warmboot">Section 3.2.10: </a></td>
<td>&nbsp;&nbsp;</td><td> WarmBoot: Validated warmboot upgrades.
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#spinlock">Section 3.2.11: </a></td>
<td>&nbsp;&nbsp;</td><td> New Spinlock APIs
 </td>
<tr><td>&nbsp;&nbsp;<a href="#new-hardware">Section 3.3: </a></td>
<td>&nbsp;&nbsp;</td><td> New Devices and Systems
</td>
<tr><td>&nbsp;&nbsp;<a href="#api-changes">Section 3.4: </a></td>
<td>&nbsp;&nbsp;</td><td> Summary of BCM changes
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#debugsubsystem">Section 3.4.1: </a></td>
<td>&nbsp;&nbsp;</td><td> Debug subsystem
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#fund">Section 3.4.2: </a></td>
<td>&nbsp;&nbsp;</td><td> BCM Fundamentals
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#fund_bcm_modules">Section 3.4.2.1: </a></td>
<td>&nbsp;&nbsp;</td><td> BCM Modules
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#bfd">Section 3.4.3: </a></td>
<td>&nbsp;&nbsp;</td><td> Bidirectional Forwarding Detection
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#regex">Section 3.4.4: </a></td>
<td>&nbsp;&nbsp;</td><td> Regex API
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#cosq">Section 3.4.5: </a></td>
<td>&nbsp;&nbsp;</td><td> Class of Service Queue Configuration
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#extender">Section 3.4.6: </a></td>
<td>&nbsp;&nbsp;</td><td> Port Extension Management
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#fabric">Section 3.4.7: </a></td>
<td>&nbsp;&nbsp;</td><td> Fabric
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#failover">Section 3.4.8: </a></td>
<td>&nbsp;&nbsp;</td><td> Forwarding Failover Protection
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#fcmap">Section 3.4.9: </a></td>
<td>&nbsp;&nbsp;</td><td> FCMAP API
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#fcoe">Section 3.4.10: </a></td>
<td>&nbsp;&nbsp;</td><td> Fiber Channel Over Ethernet
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#field">Section 3.4.11: </a></td>
<td>&nbsp;&nbsp;</td><td> Field Processor
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#fp_vlantranslationhit">Section 3.4.11.1: </a></td>
<td>&nbsp;&nbsp;</td><td> Field Qualify VlanTranslationHit
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#fp_ingress_policer_pools_mode">Section 3.4.11.2: </a></td>
<td>&nbsp;&nbsp;</td><td> Ingress Policer Pool Modes
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ipmc">Section 3.4.12: </a></td>
<td>&nbsp;&nbsp;</td><td> IP Multicast
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#l2">Section 3.4.13: </a></td>
<td>&nbsp;&nbsp;</td><td> Layer 2 Address Management
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#L2GRE">Section 3.4.14: </a></td>
<td>&nbsp;&nbsp;</td><td> L2GRE Management
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#l3">Section 3.4.15: </a></td>
<td>&nbsp;&nbsp;</td><td> Layer 3 Management
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mim">Section 3.4.16: </a></td>
<td>&nbsp;&nbsp;</td><td> MAC-in-MAC Management
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mirroring">Section 3.4.17: </a></td>
<td>&nbsp;&nbsp;</td><td> Mirroring
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#mpls">Section 3.4.18: </a></td>
<td>&nbsp;&nbsp;</td><td> MPLS Management
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#multicast">Section 3.4.19: </a></td>
<td>&nbsp;&nbsp;</td><td> Multicast Configuration
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#niv">Section 3.4.20: </a></td>
<td>&nbsp;&nbsp;</td><td> Network Interface Virtualization Management
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#oam">Section 3.4.21: </a></td>
<td>&nbsp;&nbsp;</td><td> Operations, Administration, And Maintenance
 </td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#txrx">Section 3.4.22: </a></td>
<td>&nbsp;&nbsp;</td><td> Packet Transmit and Receive
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#policer">Section 3.4.23: </a></td>
<td>&nbsp;&nbsp;</td><td> Policer Configuration
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#port">Section 3.4.24: </a></td>
<td>&nbsp;&nbsp;</td><td> Port Configuration
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ptp">Section 3.4.25: </a></td>
<td>&nbsp;&nbsp;</td><td> Precision Time Protocol
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rate">Section 3.4.26: </a></td>
<td>&nbsp;&nbsp;</td><td> Rate Limiting
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sat">Section 3.4.27: </a></td>
<td>&nbsp;&nbsp;</td><td> Service Activation Test (SAT) is new to this release
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sat_overview">Section 3.4.27.1: </a></td>
<td>&nbsp;&nbsp;</td><td> SAT Overview
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sat_data_types">Section 3.4.27.2: </a></td>
<td>&nbsp;&nbsp;</td><td> SAT Data Types
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sat_endpoint_info">Section 3.4.27.3: </a></td>
<td>&nbsp;&nbsp;</td><td> SAT Endpoint Info
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sat_actions">Section 3.4.27.4: </a></td>
<td>&nbsp;&nbsp;</td><td> SAT endpoint action 
 </td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sat_apis">Section 3.4.27.5: </a></td>
<td>&nbsp;&nbsp;</td><td> SAT APIs
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#stack">Section 3.4.28: </a></td>
<td>&nbsp;&nbsp;</td><td> Multi-device Stack Control
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#stat">Section 3.4.29: </a></td>
<td>&nbsp;&nbsp;</td><td> Statistics
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#switch">Section 3.4.30: </a></td>
<td>&nbsp;&nbsp;</td><td> Switch Control
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#trill">Section 3.4.31: </a></td>
<td>&nbsp;&nbsp;</td><td> TRILL Management
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#trunk">Section 3.4.32: </a></td>
<td>&nbsp;&nbsp;</td><td> Trunking (Link Aggregation)
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#vlan">Section 3.4.33: </a></td>
<td>&nbsp;&nbsp;</td><td> VLAN Management
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#VXLAN">Section 3.4.34: </a></td>
<td>&nbsp;&nbsp;</td><td> VXLAN Management
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#udf">Section 3.4.35: </a></td>
<td>&nbsp;&nbsp;</td><td> UDF Resources Management is new to this release 
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#udf_overview">Section 3.4.35.1: </a></td>
<td>&nbsp;&nbsp;</td><td> UDF Resources
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#udf_data_structures">Section 3.4.35.2: </a></td>
<td>&nbsp;&nbsp;</td><td> UDF Data Structures
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#udf_apis">Section 3.4.35.3: </a></td>
<td>&nbsp;&nbsp;</td><td> APIs to manage the UDF resources
</td>
<tr><td><a href="#section_testStats">Section 4: </a></td>
<td>&nbsp;&nbsp;</td><td> Test Statistics
</td>
<tr><td>&nbsp;&nbsp;<a href="#How-to-read-the-data">Section 4.1: </a></td>
<td>&nbsp;&nbsp;</td><td> How to read the Data
</td>
<tr><td>&nbsp;&nbsp;<a href="#Overview">Section 4.2: </a></td>
<td>&nbsp;&nbsp;</td><td> Overview
</td>
<tr><td>&nbsp;&nbsp;<a href="#Note">Section 4.3: </a></td>
<td>&nbsp;&nbsp;</td><td> Note
</td>
<tr><td>&nbsp;&nbsp;<a href="#Total-Tests">Section 4.4: </a></td>
<td>&nbsp;&nbsp;</td><td> Total Tests
</td>
<tr><td>&nbsp;&nbsp;<a href="#Test-Results">Section 4.5: </a></td>
<td>&nbsp;&nbsp;</td><td> Test Results
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#All-Results">Section 4.5.1: </a></td>
<td>&nbsp;&nbsp;</td><td> All Devices
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#trident2-results">Section 4.5.2: </a></td>
<td>&nbsp;&nbsp;</td><td> Trident2
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#triumph3-results">Section 4.5.3: </a></td>
<td>&nbsp;&nbsp;</td><td> Triumph3
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Hurricane2-results">Section 4.5.4: </a></td>
<td>&nbsp;&nbsp;</td><td> Hurricane2
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Helix4-results">Section 4.5.5: </a></td>
<td>&nbsp;&nbsp;</td><td> Helix4
</td>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Katana2-results">Section 4.5.6: </a></td>
<td>&nbsp;&nbsp;</td><td> Katana2
</td>
<tr><td>&nbsp;&nbsp;<a href="#code-quality-analysis">Section 4.6: </a></td>
<td>&nbsp;&nbsp;</td><td> Static Code quality analysis
</td>
<tr><td><a href="#section_resolved6.4.1">Section 5: </a></td>
<td>&nbsp;&nbsp;</td><td> Resolved Issues for 6.4.1
</td>
<tr><td><a href="#section_unresolved6.4.1">Section 6: </a></td>
<td>&nbsp;&nbsp;</td><td> Unresolved Issues for 6.4.1
</td>
<tr><td><a href="#section_platforms">Section 7: </a></td>
<td>&nbsp;&nbsp;</td><td> Device and Platform Support
</td>
<tr><td>&nbsp;&nbsp;<a href="#devices">Section 7.1: </a></td>
<td>&nbsp;&nbsp;</td><td> Switch Devices
</td>
<tr><td>&nbsp;&nbsp;<a href="#phys">Section 7.2: </a></td>
<td>&nbsp;&nbsp;</td><td> PHYs
</td>
<tr><td>&nbsp;&nbsp;<a href="#os">Section 7.3: </a></td>
<td>&nbsp;&nbsp;</td><td> Operating Systems
</td>
<tr><td>&nbsp;&nbsp;<a href="#cpu">Section 7.4: </a></td>
<td>&nbsp;&nbsp;</td><td> CPU Subsystems
</td>
<tr><td>&nbsp;&nbsp;<a href="#combinations">Section 7.5: </a></td>
<td>&nbsp;&nbsp;</td><td> CPU and Operating System Combinations
</td>
<tr><td><a href="#section_media">Section 8: </a></td>
<td>&nbsp;&nbsp;</td><td> Release Media
</td>
<tr><td><a href="#section_support">Section 9: </a></td>
<td>&nbsp;&nbsp;</td><td> Support
</td>
<tr><td><a href="#section_compatibility">Section 10: </a></td>
<td>&nbsp;&nbsp;</td><td> Firmware Compatibility Matrix
 </td>
<tr><td>&nbsp;&nbsp;<a href="#bcm56440_fcm">Section 10.1: </a></td>
<td>&nbsp;&nbsp;</td><td> BCM56440 Firmware Compatibility Matrix
 </td>
<tr><td>&nbsp;&nbsp;<a href="#bcm56640_fcm">Section 10.2: </a></td>
<td>&nbsp;&nbsp;</td><td> BCM56640 Firmware Compatibility Matrix
 </td>
<tr><td>&nbsp;&nbsp;<a href="#bcm88650_fcm">Section 10.3: </a></td>
<td>&nbsp;&nbsp;</td><td> BCM88650 Firmware Compatibility Matrix
 </td>
<tr><td>&nbsp;&nbsp;<a href="#bcm56850_fcm">Section 10.4: </a></td>
<td>&nbsp;&nbsp;</td><td> BCM56850 Firmware Compatibility Matrix
 </td>
<tr><td>&nbsp;&nbsp;<a href="#bcm88030_fcm">Section 10.5: </a></td>
<td>&nbsp;&nbsp;</td><td> BCM88030 Firmware Compatibility Matrix
 </td>
<tr><td>&nbsp;&nbsp;<a href="#bcm56450_fcm">Section 10.6: </a></td>
<td>&nbsp;&nbsp;</td><td> BCM56450 Firmware Compatibility Matrix
 </td>
<tr><td>&nbsp;&nbsp;<a href="#bmacsec_cm">Section 10.7: </a></td>
<td>&nbsp;&nbsp;</td><td> BMACSEC SDK Compatibility Matrix
 </td>
<tr><td><a href="#section_Appendix_A">Section 11: </a></td>
<td>&nbsp;&nbsp;</td><td> SDK Externally Licensed Software Components
</td>
<tr><td>&nbsp;&nbsp;<a href="#EDITLINE_license_terms_and_conditions">Section 11.1: </a></td>
<td>&nbsp;&nbsp;</td><td> EDITLINE License terms and conditions
</td>
<tr><td>&nbsp;&nbsp;<a href="#ED_editor_license_terms_and_conditions">Section 11.2: </a></td>
<td>&nbsp;&nbsp;</td><td> ED Editor License terms and conditions
</td>
<tr><td>&nbsp;&nbsp;<a href="#CINT_license_terms_and_conditions">Section 11.3: </a></td>
<td>&nbsp;&nbsp;</td><td> CINT parser license terms and conditions
</td>
<tr><td>&nbsp;&nbsp;<a href="#CES_Driver_license_terms_and_conditions">Section 11.4: </a></td>
<td>&nbsp;&nbsp;</td><td> Circuit Emulation Service (CES) Driver terms and conditions
</td>
<tr><td>&nbsp;&nbsp;<a href="#BIGDIGITS_license_terms_and_conditions">Section 11.5: </a></td>
<td>&nbsp;&nbsp;</td><td> BIGDIGITS license terms and conditions
</td>
<tr><td>&nbsp;&nbsp;<a href="#APIMODE_license_terms_and_conditions">Section 11.6: </a></td>
<td>&nbsp;&nbsp;</td><td> APIMODE parser license terms and conditions
</td>
<tr><td>&nbsp;&nbsp;<a href="#WRS_license_terms_and_conditions">Section 11.7: </a></td>
<td>&nbsp;&nbsp;</td><td> Wind River Systems license terms and conditions
</td>
<tr><td><a href="#section_resolved6.4.0">Section 12: </a></td>
<td>&nbsp;&nbsp;</td><td> Resolved Issues for 6.4.0
</td>
</table>
<hr noshade>
<h2>Alphabetical list of all APIs new in this release</h2>
<table cellpadding=0 cellspacing=2 border=0 summary="api" >
<tr><td><a href=#bcm_cosq_bst_profile_t_init><tt>bcm_cosq_bst_profile_t_init</tt></a></td>
<td>&nbsp;</td><td>        Initialize a CoSQ BST profile structure.
</td></tr><tr><td><a href=#bcm_cosq_bst_stat_get32><tt>bcm_cosq_bst_stat_get32</tt></a></td>
<td>&nbsp;</td><td> Get the current statistic/count of specified BST profile
</td></tr><tr><td><a href=#bcm_cosq_bst_stat_multi_get32><tt>bcm_cosq_bst_stat_multi_get32</tt></a></td>
<td>&nbsp;</td><td> Get the current statistic/count of multiple specified BST profile
</td></tr><tr><td><a href=#bcm_cosq_gport_dynamic_sched_set><tt>bcm_cosq_gport_dynamic_sched_set</tt></a></td>
<td>&nbsp;</td><td>	set/get weights dynamic or regular weights
</td></tr><tr><td><a href=#bcm_cosq_gport_dynamic_sched_get><tt>bcm_cosq_gport_dynamic_sched_get</tt></a></td>
<td>&nbsp;</td><td>	set/get weights dynamic or regular weights
</td></tr><tr><td><a href=#bcm_cosq_gport_handle_core_get><tt>bcm_cosq_gport_handle_core_get</tt></a></td>
<td>&nbsp;</td><td> Getting a gport handle
</td></tr><tr><td><a href=#bcm_cosq_gport_reattach><tt>bcm_cosq_gport_reattach</tt></a></td>
<td>&nbsp;</td><td> Reattach the output of a GPORT to the input of a scheduler GPORT.
</td></tr><tr><td><a href=#bcm_cosq_gport_stat_sync_get><tt>bcm_cosq_gport_stat_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve statistics.
</td></tr><tr><td><a href=#bcm_cosq_profile_mapping_set><tt>bcm_cosq_profile_mapping_set</tt></a></td>
<td>&nbsp;</td><td> Maps a gport to a profile
</td></tr><tr><td><a href=#bcm_cosq_service_pool_set><tt>bcm_cosq_service_pool_set</tt></a></td>
<td>&nbsp;</td><td>        To set/get enable or disable status of service pool for a given pool id
</td></tr><tr><td><a href=#bcm_cosq_service_pool_get><tt>bcm_cosq_service_pool_get</tt></a></td>
<td>&nbsp;</td><td>        To set/get enable or disable status of service pool for a given pool id
</td></tr><tr><td><a href=#bcm_cosq_threshold_t_init><tt>bcm_cosq_threshold_t_init</tt></a></td>
<td>&nbsp;</td><td>        Initialize a COSQ threshold structure.
</td></tr><tr><td><a href=#bcm_esmc_g781_option_get><tt>bcm_esmc_g781_option_get</tt></a></td>
<td>&nbsp;</td><td>	Get ITU-T G.781 networking option for SyncE.
</td></tr><tr><td><a href=#bcm_esmc_g781_option_set><tt>bcm_esmc_g781_option_set</tt></a></td>
<td>&nbsp;</td><td>	Set ITU-T G.781 networking option for SyncE.
</td></tr><tr><td><a href=#bcm_esmc_QL_SSM_map>bcm_esmc_QL_SSM_map</a></td>
<td>&nbsp;</td><td>	Get synchronization status message (SSM) code corresponding to ITU-T
	G.781 quality level (QL).
</td></tr><tr><td><a href=#bcm_esmc_rx_callback_register><tt>bcm_esmc_rx_callback_register</tt></a></td>
<td>&nbsp;</td><td>	Register ESMC PDU Rx callback.
</td></tr><tr><td><a href=#bcm_esmc_rx_callback_unregister><tt>bcm_esmc_rx_callback_unregister</tt></a></td>
<td>&nbsp;</td><td>	Unregister ESMC PDU Rx callback.
</td></tr><tr><td><a href=#bcm_esmc_SSM_QL_map>bcm_esmc_SSM_QL_map</a></td>
<td>&nbsp;</td><td>	Get ITU-T G.781 quality level (QL) corresponding to synchronization
	status message (SSM) code.
</td></tr><tr><td><a href=#bcm_esmc_tunnel_get><tt>bcm_esmc_tunnel_get</tt></a></td>
<td>&nbsp;</td><td>	Get ESMC PDU tunneling-enabled Boolean.
</td></tr><tr><td><a href=#bcm_esmc_tunnel_set><tt>bcm_esmc_tunnel_set</tt></a></td>
<td>&nbsp;</td><td>	Set ESMC PDU tunneling-enabled Boolean.
</td></tr><tr><td><a href=#bcm_esmc_tx><tt>bcm_esmc_tx</tt></a></td>
<td>&nbsp;</td><td>	ESMC PDU transmit (Tx).
</td></tr><tr><td><a href=#bcm_fabric_link_remote_pipe_mapping_set><tt>bcm_fabric_link_remote_pipe_mapping_set</tt></a></td>
<td>&nbsp;</td><td>	Set/get per link the mapping between the local pipe to the remote pipe.
</td></tr><tr><td><a href=#bcm_fabric_link_remote_pipe_mapping_get><tt>bcm_fabric_link_remote_pipe_mapping_get</tt></a></td>
<td>&nbsp;</td><td>	Set/get per link the mapping between the local pipe to the remote pipe.
</td></tr><tr><td><a href=#bcm_fabric_link_remote_pipe_mapping_t_init><tt>bcm_fabric_link_remote_pipe_mapping_t_init</tt></a></td>
<td>&nbsp;</td><td>	Initialize a <tt>bcm_fabric_link_remote_pipe_mapping_t</tt> to a 'safe' default value.
</td></tr><tr><td><a href=#bcm_fabric_link_thresholds_pipe_set><tt>bcm_fabric_link_thresholds_pipe_set</tt></a></td>
<td>&nbsp;</td><td>        Set\Get <tt>fifo_type</tt> thresholds per pipe
</td></tr><tr><td><a href=#bcm_fabric_link_thresholds_pipe_get><tt>bcm_fabric_link_thresholds_pipe_get</tt></a></td>
<td>&nbsp;</td><td>        Set\Get <tt>fifo_type</tt> thresholds per pipe
</td></tr><tr><td><a href=#bcm_fabric_pcp_dest_mode_config_set><tt>bcm_fabric_pcp_dest_mode_config_set</tt></a></td>
<td>&nbsp;</td><td>	Set/Get PCP mode per VOQ/destination device.
</td></tr><tr><td><a href=#bcm_fabric_pcp_dest_mode_config_get><tt>bcm_fabric_pcp_dest_mode_config_get</tt></a></td>
<td>&nbsp;</td><td>	Set/Get PCP mode per VOQ/destination device.
</td></tr><tr><td><a href=#bcm_fabric_route_rx><tt>bcm_fabric_route_rx</tt></a></td>
<td>&nbsp;</td><td>        Receive fabric route cells
</td></tr><tr><td><a href=#bcm_fabric_route_t_init><tt>bcm_fabric_route_t_init</tt></a></td>
<td>&nbsp;</td><td>        Initialize a <tt>bcm_fabric_route_t</tt> to a 'safe' default value.
</td></tr><tr><td><a href=#bcm_fabric_route_tx><tt>bcm_fabric_route_tx</tt></a></td>
<td>&nbsp;</td><td>        Send fabric route cells
</td></tr><tr><td><a href=#bcm_fcmap_diag_get><tt>bcm_fcmap_diag_get</tt></a></td>
<td>&nbsp;</td><td>       Returns the current diagnostic code from the specified FC port.
 </td></tr><tr><td><a href=#bcm_fcmap_linkfault_trigger_rc_get><tt>bcm_fcmap_linkfault_trigger_rc_get</tt></a></td>
<td>&nbsp;</td><td>       Returns the linkfault trigger code and reason code from the specified FC port.
 </td></tr><tr><td><a href=#bcm_fcoe_route_stat_counter_sync_get><tt>bcm_fcoe_route_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve flex counter 
	value for FCOE route.
</td></tr><tr><td><a href=#bcm_fcoe_vsan_stat_counter_sync_get><tt>bcm_fcoe_vsan_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve flex counter 
	value for FCOE VSAN ID.
</td></tr><tr><td><a href=#bcm_field_qset_id_multi_delete><tt>bcm_field_qset_id_multi_delete</tt></a></td>
<td>&nbsp;</td><td>	Delete qualifier objects to field group qset.
</td></tr><tr><td><a href=#bcm_field_qset_id_multi_get><tt>bcm_field_qset_id_multi_get</tt></a></td>
<td>&nbsp;</td><td>	Get qualifier objects added to the field group qset.
</td></tr><tr><td><a href=#bcm_field_qset_id_multi_set><tt>bcm_field_qset_id_multi_set</tt></a></td>
<td>&nbsp;</td><td>	Add qualifier objects to field group qset.
</td></tr><tr><td><a href=#bcm_field_qualify_DstGport>bcm_field_qualify_DstGport</a></td>
<td>&nbsp;</td><td>       Add DstGport qualification to a field entry
</td></tr><tr><td><a href=#bcm_field_qualify_DstGport_get>bcm_field_qualify_DstGport_get</a></td>
<td>&nbsp;</td><td>       Get the DstGport qualification match criteria from a field entry
</td></tr><tr><td><a href=#bcm_field_qualify_DstNivGport>bcm_field_qualify_DstNivGport</a></td>
<td>&nbsp;</td><td>       Add DstNivGport qualification to a field entry
</td></tr><tr><td><a href=#bcm_field_qualify_DstNivGport_get>bcm_field_qualify_DstNivGport_get</a></td>
<td>&nbsp;</td><td>       Get the DstNivGport qualification match criteria from a field entry
</td></tr><tr><td><a href=#bcm_field_qualify_SrcNivGport>bcm_field_qualify_SrcNivGport</a></td>
<td>&nbsp;</td><td>       Add SrcNivGport qualification to a field entry
</td></tr><tr><td><a href=#bcm_field_qualify_SrcNivGport_get>bcm_field_qualify_SrcNivGport_get</a></td>
<td>&nbsp;</td><td>       Get the SrcNivGport qualification match criteria from a field entry
</td></tr><tr><td><a href=#bcm_field_qualify_XXX>bcm_field_qualify_XXX</a></td>
<td>&nbsp;</td><td>       Add a qualification to a field entry
</td></tr><tr><td><a href=#bcm_field_qualify_XXX_get>bcm_field_qualify_XXX_get</a></td>
<td>&nbsp;</td><td>       Get a qualification match criteria from a field entry
</td></tr><tr><td><a href=#bcm_field_stage_info_get><tt>bcm_field_stage_info_get</tt></a></td>
<td>&nbsp;</td><td>	Get per-stage field information
 </td></tr><tr><td><a href=#bcm_field_stat_counter_sync_get><tt>bcm_field_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve statistics value for a field entity
</td></tr><tr><td><a href=#bcm_field_stat_sync_get><tt>bcm_field_stat_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve specific statistic type.
</td></tr><tr><td><a href=#bcm_field_stat_sync_get32><tt>bcm_field_stat_sync_get32</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve specific statistic type.
	Get 32-bit counter value for specific statistic type.
</td></tr><tr><td><a href=#bcm_ipmc_stat_counter_sync_get><tt>bcm_ipmc_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve counter statistic values 
	for an IPMC group.
</td></tr><tr><td><a href=#bcm_l2gre_stat_counter_sync_get><tt>bcm_l2gre_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve counter statistic values for 
	a l2gre vp/vpn index.
</td></tr><tr><td><a href=#bcm_l3_egress_stat_counter_sync_get><tt>bcm_l3_egress_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve the specified counter 
	statistic for a L3 egress interface.
</td></tr><tr><td><a href=#bcm_l3_host_stat_counter_sync_get><tt>bcm_l3_host_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve the specified counter 
	statistic for a L3 host entry.
</td></tr><tr><td><a href=#bcm_l3_ingress_stat_counter_sync_get><tt>bcm_l3_ingress_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Get counter statistic values for a l3 interface object.
</td></tr><tr><td><a href=#bcm_l3_nat_egress_stat_counter_sync_get><tt>bcm_l3_nat_egress_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve counter statistic values for a Egress NAT Index.
</td></tr><tr><td><a href=#bcm_l3_route_find><tt>bcm_l3_route_find</tt></a></td>
<td>&nbsp;</td><td>	Find a longest prefix matched route given an IP address.
</td></tr><tr><td><a href=#bcm_l3_route_stat_counter_sync_get><tt>bcm_l3_route_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve counter statistic values for a l3 route index.
</td></tr><tr><td><a href=#bcm_l3_vrf_stat_counter_sync_get><tt>bcm_l3_vrf_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve L3 VRF counter value for 
	specified VRF statistic type
</td></tr><tr><td><a href=#bcm_l3_vrf_stat_sync_get><tt>bcm_l3_vrf_stat_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve L3 VRF counter value for 
	specified VRF statistic type.
</td></tr><tr><td><a href=#bcm_l3_vrf_stat_sync_get32><tt>bcm_l3_vrf_stat_sync_get32</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve L3 VRF counter value for 
	specified VRF statistic type.
</td></tr><tr><td><a href=#bcm_mim_lookup_id_stat_counter_sync_get><tt>bcm_mim_lookup_id_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve counter statistic values 
	for specific MiM I-SID entry.
</td></tr><tr><td><a href=#bcm_mim_vpn_stat_counter_sync_get><tt>bcm_mim_vpn_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve counter statistic values for 
	specific MiM VPN entry
</td></tr><tr><td><a href=#bcm_mirror_options_t_init><tt>bcm_mirror_options_t_init</tt></a></td>
<td>&nbsp;</td><td>	extended versions of existing <tt>_dest_</tt> APIs using a <tt>bcm_mirror_options_t</tt> argument 
</td></tr><tr><td><a href=#bcm_mirror_port_destination_add><tt>bcm_mirror_port_destination_add</tt></a></td>
<td>&nbsp;</td><td>	extended versions of existing <tt>_dest_</tt> APIs using a <tt>bcm_mirror_options_t</tt> argument 
</td></tr><tr><td><a href=#bcm_mirror_port_destination_get><tt>bcm_mirror_port_destination_get</tt></a></td>
<td>&nbsp;</td><td>	extended versions of existing <tt>_dest_</tt> APIs using a <tt>bcm_mirror_options_t</tt> argument 
</td></tr><tr><td><a href=#bcm_mirror_port_vlan_destination_add><tt>bcm_mirror_port_vlan_destination_add</tt></a></td>
<td>&nbsp;</td><td>	extended versions of existing <tt>_dest_</tt> APIs using a <tt>bcm_mirror_options_t</tt> argument 
</td></tr><tr><td><a href=#bcm_mirror_port_vlan_destination_get><tt>bcm_mirror_port_vlan_destination_get</tt></a></td>
<td>&nbsp;</td><td>	extended versions of existing <tt>_dest_</tt> APIs using a <tt>bcm_mirror_options_t</tt> argument 
</td></tr><tr><td><a href=#bcm_mirror_pkt_header_updates_t_init><tt>bcm_mirror_pkt_header_updates_t_init</tt></a></td>
<td>&nbsp;</td><td>	Initialized <tt>bcm_mirror_pkt_header_updates_t</tt> struct
</td></tr><tr><td><a href=#bcm_mpls_label_stat_counter_sync_get><tt>bcm_mpls_label_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve counter statistic values for 
	specific MPLS label and gport
</td></tr><tr><td><a href=#bcm_mpls_label_stat_sync_get><tt>bcm_mpls_label_stat_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve MPLS Stats.
</td></tr><tr><td><a href=#bcm_mpls_label_stat_sync_get32><tt>bcm_mpls_label_stat_sync_get32</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve MPLS Stats.
</td></tr><tr><td><a href=#bcm_mpls_port_stat_counter_sync_get><tt>bcm_mpls_port_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve get counter statistic 
	values for specific vpn and gport
</td></tr><tr><td><a href=#bcm_multicast_delete><tt>bcm_multicast_delete</tt></a></td>
<td>&nbsp;</td><td>	Delete or add replications of a multicast group.
</td></tr><tr><td><a href=#bcm_multicast_add><tt>bcm_multicast_add</tt></a></td>
<td>&nbsp;</td><td>	Delete or add replications of a multicast group.
</td></tr><tr><td><a href=#bcm_multicast_set><tt>bcm_multicast_set</tt></a></td>
<td>&nbsp;</td><td>	Set or Get all the replicataions of a multicast group.
</td></tr><tr><td><a href=#bcm_multicast_get><tt>bcm_multicast_get</tt></a></td>
<td>&nbsp;</td><td>	Set or Get all the replicataions of a multicast group.
</td></tr><tr><td><a href=#bcm_port_encap_map_get><tt>bcm_port_encap_map_get</tt></a></td>
<td>&nbsp;</td><td>	Get the encapsulation to port mapping from <tt>encap_id</tt>.
</td></tr><tr><td><a href=#bcm_port_encap_map_set><tt>bcm_port_encap_map_set</tt></a></td>
<td>&nbsp;</td><td>	Set the encapsulation to port mapping from <tt>encap_id</tt> to port.
</td></tr><tr><td><a href=#bcm_port_stat_counter_sync_get><tt>bcm_port_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve counter values for 
	specified gport based on port statistic type. 
</td></tr><tr><td><a href=#bcm_port_stat_sync_get><tt>bcm_port_stat_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve port counter value for 
	specified port statistic type.
</td></tr><tr><td><a href=#bcm_port_stat_sync_get32><tt>bcm_port_stat_sync_get32</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve port counter value for 
	specified port statistic type.
</td></tr><tr><td><a href=#bcm_regex_session_delete_all><tt>bcm_regex_session_delete_all</tt></a></td>
<td>&nbsp;</td><td>	Deletes all the entries from the regex session table.
</td></tr><tr><td><a href=#bcm_sat_endpoint_create><tt>bcm_sat_endpoint_create</tt></a></td>
<td>&nbsp;</td><td>	Create or replace an SAT endpoint object.
</td></tr><tr><td><a href=#bcm_sat_endpoint_destroy><tt>bcm_sat_endpoint_destroy</tt></a></td>
<td>&nbsp;</td><td>	Destroy an SAT endpoint object.
</td></tr><tr><td><a href=#bcm_sat_endpoint_destroy_all><tt>bcm_sat_endpoint_destroy_all</tt></a></td>
<td>&nbsp;</td><td>	Destroy all SAT endpoint objects.
</td></tr><tr><td><a href=#bcm_sat_endpoint_get><tt>bcm_sat_endpoint_get</tt></a></td>
<td>&nbsp;</td><td>	Get an SAT endpoint object.
</td></tr><tr><td><a href=#bcm_sat_endpoint_traverse><tt>bcm_sat_endpoint_traverse</tt></a></td>
<td>&nbsp;</td><td>	Traverse the set of SAT endpoints.
</td></tr><tr><td><a href=#bcm_stat_flex_pool_info_multi_get><tt>bcm_stat_flex_pool_info_multi_get</tt></a></td>
<td>&nbsp;</td><td>	Retrieves the flex counter details for a given direction
 </td></tr><tr><td><a href=#bcm_stat_value_t_init><tt>bcm_stat_value_t_init</tt></a></td>
<td>&nbsp;</td><td>	Initialize a <tt>bcm_stat_value_t</tt> data structure
 </td></tr><tr><td><a href=#bcm_stk_module_control_set><tt>bcm_stk_module_control_set</tt></a></td>
<td>&nbsp;</td><td>	Set/get control value.
</td></tr><tr><td><a href=#bcm_stk_module_control_get><tt>bcm_stk_module_control_get</tt></a></td>
<td>&nbsp;</td><td>	Set/get control value.
</td></tr><tr><td><a href=#bcm_stk_module_max_set><tt>bcm_stk_module_max_set</tt></a></td>
<td>&nbsp;</td><td>	Maximum group ID set/get
</td></tr><tr><td><a href=#bcm_stk_module_max_get><tt>bcm_stk_module_max_get</tt></a></td>
<td>&nbsp;</td><td>	Maximum group ID set/get
</td></tr><tr><td><a href=#bcm_switch_hash_entry_create_qset><tt>bcm_switch_hash_entry_create_qset</tt></a></td>
<td>&nbsp;</td><td>	Create a blank flex hash entry.
</td></tr><tr><td><a href=#bcm_switch_l3_protocol_group_set><tt>bcm_switch_l3_protocol_group_set</tt></a></td>
<td>&nbsp;</td><td>	Assign/get protocol groups for multiple mymac termination
</td></tr><tr><td><a href=#bcm_switch_l3_protocol_group_get><tt>bcm_switch_l3_protocol_group_get</tt></a></td>
<td>&nbsp;</td><td>	Assign/get protocol groups for multiple mymac termination
</td></tr><tr><td><a href=#bcm_switch_profile_mapping_t_init><tt>bcm_switch_profile_mapping_t_init</tt></a></td>
<td>&nbsp;</td><td>	Initialize a <tt>bcm_switch_profile_mapping_t</tt> structure
</td></tr><tr><td><a href=#bcm_tdpll_dpll_bandwidth_get><tt>bcm_tdpll_dpll_bandwidth_get</tt></a></td>
<td>&nbsp;</td><td>	Get DPLL bandwidth.
</td></tr><tr><td><a href=#bcm_tdpll_dpll_bandwidth_set><tt>bcm_tdpll_dpll_bandwidth_set</tt></a></td>
<td>&nbsp;</td><td>	Set DPLL bandwidth.
</td></tr><tr><td><a href=#bcm_tdpll_dpll_bindings_get><tt>bcm_tdpll_dpll_bindings_get</tt></a></td>
<td>&nbsp;</td><td>	Get logical DPLL instance input/output bindings.
</td></tr><tr><td><a href=#bcm_tdpll_dpll_bindings_set><tt>bcm_tdpll_dpll_bindings_set</tt></a></td>
<td>&nbsp;</td><td>	Set logical DPLL instance input/output bindings.
</td></tr><tr><td><a href=#bcm_tdpll_dpll_phase_control_get><tt>bcm_tdpll_dpll_phase_control_get</tt></a></td>
<td>&nbsp;</td><td>	Get DPLL instance's phase control configuration.
</td></tr><tr><td><a href=#bcm_tdpll_dpll_phase_control_set><tt>bcm_tdpll_dpll_phase_control_set</tt></a></td>
<td>&nbsp;</td><td>	Set DPLL instance's phase control configuration.
</td></tr><tr><td><a href=#bcm_tdpll_dpll_reference_get><tt>bcm_tdpll_dpll_reference_get</tt></a></td>
<td>&nbsp;</td><td>	Get reference clocks for DPLL instances.
</td></tr><tr><td><a href=#bcm_tdpll_esmc_holdover_ql_get><tt>bcm_tdpll_esmc_holdover_ql_get</tt></a></td>
<td>&nbsp;</td><td>	Get quality level (QL) for ESMC during holdover.
</td></tr><tr><td><a href=#bcm_tdpll_esmc_holdover_ql_set><tt>bcm_tdpll_esmc_holdover_ql_set</tt></a></td>
<td>&nbsp;</td><td>	Set quality level (QL) for ESMC during holdover.
</td></tr><tr><td><a href=#bcm_tdpll_esmc_mac_get><tt>bcm_tdpll_esmc_mac_get</tt></a></td>
<td>&nbsp;</td><td>	Get MAC address for ESMC.
</td></tr><tr><td><a href=#bcm_tdpll_esmc_mac_set><tt>bcm_tdpll_esmc_mac_set</tt></a></td>
<td>&nbsp;</td><td>	Set MAC address for ESMC.
</td></tr><tr><td><a href=#bcm_tdpll_esmc_ql_get><tt>bcm_tdpll_esmc_ql_get</tt></a></td>
<td>&nbsp;</td><td>	Get quality level (QL) for ESMC.
</td></tr><tr><td><a href=#bcm_tdpll_esmc_ql_set><tt>bcm_tdpll_esmc_ql_set</tt></a></td>
<td>&nbsp;</td><td>	Set quality level (QL) for ESMC.
</td></tr><tr><td><a href=#bcm_tdpll_esmc_rx_enable_get><tt>bcm_tdpll_esmc_rx_enable_get</tt></a></td>
<td>&nbsp;</td><td>	Get ESMC PDU receive (Rx) enable state.
</td></tr><tr><td><a href=#bcm_tdpll_esmc_rx_enable_set><tt>bcm_tdpll_esmc_rx_enable_set</tt></a></td>
<td>&nbsp;</td><td>	Set ESMC PDU receive (Rx) enable state.
</td></tr><tr><td><a href=#bcm_tdpll_esmc_rx_portbitmap_get><tt>bcm_tdpll_esmc_rx_portbitmap_get</tt></a></td>
<td>&nbsp;</td><td>	Get port bitmap for ESMC Rx.
</td></tr><tr><td><a href=#bcm_tdpll_esmc_rx_portbitmap_set><tt>bcm_tdpll_esmc_rx_portbitmap_set</tt></a></td>
<td>&nbsp;</td><td>	Set port bitmap for ESMC Rx.
</td></tr><tr><td><a href=#bcm_tdpll_esmc_rx_state_machine><tt>bcm_tdpll_esmc_rx_state_machine</tt></a></td>
<td>&nbsp;</td><td>	Execute state machine for Rx ESMC PDU.
</td></tr><tr><td><a href=#bcm_tdpll_esmc_tx_enable_get><tt>bcm_tdpll_esmc_tx_enable_get</tt></a></td>
<td>&nbsp;</td><td>	Get ESMC PDU transmit (Tx) enable state.
</td></tr><tr><td><a href=#bcm_tdpll_esmc_tx_enable_set><tt>bcm_tdpll_esmc_tx_enable_set</tt></a></td>
<td>&nbsp;</td><td>	Set ESMC PDU transmit (Tx) enable state.
</td></tr><tr><td><a href=#bcm_tdpll_esmc_tx_portbitmap_get><tt>bcm_tdpll_esmc_tx_portbitmap_get</tt></a></td>
<td>&nbsp;</td><td>	Get port bitmap for ESMC Tx.
</td></tr><tr><td><a href=#bcm_tdpll_esmc_tx_portbitmap_set><tt>bcm_tdpll_esmc_tx_portbitmap_set</tt></a></td>
<td>&nbsp;</td><td>	Set port bitmap for ESMC Tx.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_best_get><tt>bcm_tdpll_input_clock_best_get</tt></a></td>
<td>&nbsp;</td><td>	Get best (i.e. selected) reference for a DPLL instance.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_control><tt>bcm_tdpll_input_clock_control</tt></a></td>
<td>&nbsp;</td><td>	Start/stop T-DPLL input clock monitoring, reference selection, and
	switching state machine
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_enable_get><tt>bcm_tdpll_input_clock_enable_get</tt></a></td>
<td>&nbsp;</td><td>	Get input clock enable Boolean.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_enable_set><tt>bcm_tdpll_input_clock_enable_set</tt></a></td>
<td>&nbsp;</td><td>	Set input-clock enable Boolean.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_frequency_error_get><tt>bcm_tdpll_input_clock_frequency_error_get</tt></a></td>
<td>&nbsp;</td><td>	Get fractional frequency error of an input clock from input-clock
	monitoring process.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_frequency_get><tt>bcm_tdpll_input_clock_frequency_get</tt></a></td>
<td>&nbsp;</td><td>	Get input clock frequency.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_frequency_set><tt>bcm_tdpll_input_clock_frequency_set</tt></a></td>
<td>&nbsp;</td><td>	Set input clock frequency.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_l1mux_get><tt>bcm_tdpll_input_clock_l1mux_get</tt></a></td>
<td>&nbsp;</td><td>	Get L1 mux mapping (mux index and port number) of input clock.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_l1mux_set><tt>bcm_tdpll_input_clock_l1mux_set</tt></a></td>
<td>&nbsp;</td><td>	Set L1 mux mapping (mux index and port number) of input clock.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_lockout_get><tt>bcm_tdpll_input_clock_lockout_get</tt></a></td>
<td>&nbsp;</td><td>	Get input clock lockout Boolean for reference selection.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_lockout_set><tt>bcm_tdpll_input_clock_lockout_set</tt></a></td>
<td>&nbsp;</td><td>	Set input clock lockout Boolean for reference selection.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_mac_get><tt>bcm_tdpll_input_clock_mac_get</tt></a></td>
<td>&nbsp;</td><td>	Get MAC address of input clock.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_mac_set><tt>bcm_tdpll_input_clock_mac_set</tt></a></td>
<td>&nbsp;</td><td>	Set MAC address of input clock.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_monitor_callback_register><tt>bcm_tdpll_input_clock_monitor_callback_register</tt></a></td>
<td>&nbsp;</td><td>	Register input clock monitoring callback.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_monitor_callback_unregister><tt>bcm_tdpll_input_clock_monitor_callback_unregister</tt></a></td>
<td>&nbsp;</td><td>	Unregister input clock monitoring callback.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_monitor_interval_get><tt>bcm_tdpll_input_clock_monitor_interval_get</tt></a></td>
<td>&nbsp;</td><td>	Get input clock monitoring interval.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_monitor_interval_set><tt>bcm_tdpll_input_clock_monitor_interval_set</tt></a></td>
<td>&nbsp;</td><td>	Set input clock monitoring interval.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_monitor_threshold_get><tt>bcm_tdpll_input_clock_monitor_threshold_get</tt></a></td>
<td>&nbsp;</td><td>	Get monitor threshold for input-clock valid classification required in
	reference selection.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_monitor_threshold_set><tt>bcm_tdpll_input_clock_monitor_threshold_set</tt></a></td>
<td>&nbsp;</td><td>	Set monitor threshold for input-clock valid classification required in
	reference selection.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_priority_get><tt>bcm_tdpll_input_clock_priority_get</tt></a></td>
<td>&nbsp;</td><td>	Get input clock priority for reference selection.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_priority_set><tt>bcm_tdpll_input_clock_priority_set</tt></a></td>
<td>&nbsp;</td><td>	Set input clock priority for reference selection.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_ql_enabled_get><tt>bcm_tdpll_input_clock_ql_enabled_get</tt></a></td>
<td>&nbsp;</td><td>	Get QL-enabled Boolean for reference selection.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_ql_enabled_set><tt>bcm_tdpll_input_clock_ql_enabled_set</tt></a></td>
<td>&nbsp;</td><td>	Set QL-enabled Boolean for reference selection.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_ql_get><tt>bcm_tdpll_input_clock_ql_get</tt></a></td>
<td>&nbsp;</td><td>	Get input clock quality level (QL).
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_ql_set><tt>bcm_tdpll_input_clock_ql_set</tt></a></td>
<td>&nbsp;</td><td>	Set input clock quality level (QL).
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_revertive_get><tt>bcm_tdpll_input_clock_revertive_get</tt></a></td>
<td>&nbsp;</td><td>	Get revertive mode Boolean for reference selection and switching.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_revertive_set><tt>bcm_tdpll_input_clock_revertive_set</tt></a></td>
<td>&nbsp;</td><td>	Set revertive mode Boolean for reference selection and switching.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_selector_callback_register><tt>bcm_tdpll_input_clock_selector_callback_register</tt></a></td>
<td>&nbsp;</td><td>	Register input clock reference selection callback.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_selector_callback_unregister><tt>bcm_tdpll_input_clock_selector_callback_unregister</tt></a></td>
<td>&nbsp;</td><td>	Unregister input clock reference selection callback.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_threshold_state_get><tt>bcm_tdpll_input_clock_threshold_state_get</tt></a></td>
<td>&nbsp;</td><td>	Get monitor threshold state of an input clock from input-clock
	monitoring process.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_valid_get><tt>bcm_tdpll_input_clock_valid_get</tt></a></td>
<td>&nbsp;</td><td>	Get valid Boolean of an input clock from input-clock monitoring
	process.
</td></tr><tr><td><a href=#bcm_tdpll_input_clock_valid_set><tt>bcm_tdpll_input_clock_valid_set</tt></a></td>
<td>&nbsp;</td><td>	Set input-clock valid Boolean from monitoring process.
</td></tr><tr><td><a href=#bcm_tdpll_output_clock_deriv_frequency_get><tt>bcm_tdpll_output_clock_deriv_frequency_get</tt></a></td>
<td>&nbsp;</td><td>	Get synthesizer derivative-clock frequency.
</td></tr><tr><td><a href=#bcm_tdpll_output_clock_deriv_frequency_set><tt>bcm_tdpll_output_clock_deriv_frequency_set</tt></a></td>
<td>&nbsp;</td><td>	Set synthesizer derivative clock frequency.
</td></tr><tr><td><a href=#bcm_tdpll_output_clock_enable_get><tt>bcm_tdpll_output_clock_enable_get</tt></a></td>
<td>&nbsp;</td><td>	Get output clock enable Boolean.
</td></tr><tr><td><a href=#bcm_tdpll_output_clock_enable_set><tt>bcm_tdpll_output_clock_enable_set</tt></a></td>
<td>&nbsp;</td><td>	Set output clock enable Boolean.
</td></tr><tr><td><a href=#bcm_tdpll_output_clock_holdover_data_get><tt>bcm_tdpll_output_clock_holdover_data_get</tt></a></td>
<td>&nbsp;</td><td>	Get holdover configuration data.
</td></tr><tr><td><a href=#bcm_tdpll_output_clock_holdover_frequency_set><tt>bcm_tdpll_output_clock_holdover_frequency_set</tt></a></td>
<td>&nbsp;</td><td>	Set manual holdover frequency correction.
</td></tr><tr><td><a href=#bcm_tdpll_output_clock_holdover_mode_get><tt>bcm_tdpll_output_clock_holdover_mode_get</tt></a></td>
<td>&nbsp;</td><td>	Get holdover mode.
</td></tr><tr><td><a href=#bcm_tdpll_output_clock_holdover_mode_set><tt>bcm_tdpll_output_clock_holdover_mode_set</tt></a></td>
<td>&nbsp;</td><td>	Set holdover mode.
</td></tr><tr><td><a href=#bcm_tdpll_output_clock_holdover_reset><tt>bcm_tdpll_output_clock_holdover_reset</tt></a></td>
<td>&nbsp;</td><td>	Reset holdover frequency calculations.
</td></tr><tr><td><a href=#bcm_tdpll_output_clock_synth_frequency_get><tt>bcm_tdpll_output_clock_synth_frequency_get</tt></a></td>
<td>&nbsp;</td><td>	Get output-clock (synthesizer) frequency.
</td></tr><tr><td><a href=#bcm_tdpll_output_clock_synth_frequency_set><tt>bcm_tdpll_output_clock_synth_frequency_set</tt></a></td>
<td>&nbsp;</td><td>	Set output-clock (synthesizer) frequency.
</td></tr><tr><td><a href=#bcm_trill_multicast_adjacency_add><tt>bcm_trill_multicast_adjacency_add</tt></a></td>
<td>&nbsp;</td><td>	Add Multicast adjacency entry
</td></tr><tr><td><a href=#bcm_trill_multicast_adjacency_delete><tt>bcm_trill_multicast_adjacency_delete</tt></a></td>
<td>&nbsp;</td><td>	Delete Multicast adjacency entry
</td></tr><tr><td><a href=#bcm_trill_multicast_adjacency_delete_all><tt>bcm_trill_multicast_adjacency_delete_all</tt></a></td>
<td>&nbsp;</td><td>	Delete all Multicast adjacency entry
</td></tr><tr><td><a href=#bcm_trill_multicast_adjacency_traverse><tt>bcm_trill_multicast_adjacency_traverse</tt></a></td>
<td>&nbsp;</td><td>	Traverse all valid TRILL Multicast adjacency entries and call supplied callback routine.
</td></tr><tr><td><a href=#bcm_trill_rbridge_entry_add><tt>bcm_trill_rbridge_entry_add</tt></a></td>
<td>&nbsp;</td><td>	<tt>bcm_trill_rbridge_entry_add</tt> Add TRILL Rbridge entry.
</td></tr><tr><td><a href=#bcm_trill_rbridge_entry_delete><tt>bcm_trill_rbridge_entry_delete</tt></a></td>
<td>&nbsp;</td><td>	<tt>bcm_trill_rbridge_entry_delete</tt> Add TRILL Rbridge entry.
</td></tr><tr><td><a href=#bcm_trill_rbridge_entry_get><tt>bcm_trill_rbridge_entry_get</tt></a></td>
<td>&nbsp;</td><td>	<tt>bcm_trill_rbridge_entry_get</tt> Add TRILL Rbridge entry.
</td></tr><tr><td><a href=#bcm_udf_alloc_hints_t_init><tt>bcm_udf_alloc_hints_t_init</tt></a></td>
<td>&nbsp;</td><td>	Initializes the UDF alloc hints structure
</td></tr><tr><td><a href=#bcm_udf_create><tt>bcm_udf_create</tt></a></td>
<td>&nbsp;</td><td>	Creates a UDF object
</td></tr><tr><td><a href=#bcm_udf_destroy><tt>bcm_udf_destroy</tt></a></td>
<td>&nbsp;</td><td>	Destroys the UDF object
</td></tr><tr><td><a href=#bcm_udf_detach><tt>bcm_udf_detach</tt></a></td>
<td>&nbsp;</td><td>	Detach UDF module
</td></tr><tr><td><a href=#bcm_udf_get><tt>bcm_udf_get</tt></a></td>
<td>&nbsp;</td><td>	Fetches the UDF object created in the system
</td></tr><tr><td><a href=#bcm_udf_get_all><tt>bcm_udf_get_all</tt></a></td>
<td>&nbsp;</td><td>	Fetches all existing UDF ids
</td></tr><tr><td><a href=#bcm_udf_init><tt>bcm_udf_init</tt></a></td>
<td>&nbsp;</td><td>	Initialize UDF module
</td></tr><tr><td><a href=#bcm_udf_pkt_format_add><tt>bcm_udf_pkt_format_add</tt></a></td>
<td>&nbsp;</td><td>	Adds packet format entry to UDF object
</td></tr><tr><td><a href=#bcm_udf_pkt_format_create><tt>bcm_udf_pkt_format_create</tt></a></td>
<td>&nbsp;</td><td>	Create a packet format entry
</td></tr><tr><td><a href=#bcm_udf_pkt_format_delete><tt>bcm_udf_pkt_format_delete</tt></a></td>
<td>&nbsp;</td><td>	Deletes packet format spec associated with the UDF
</td></tr><tr><td><a href=#bcm_udf_pkt_format_delete_all><tt>bcm_udf_pkt_format_delete_all</tt></a></td>
<td>&nbsp;</td><td>	Deletes all packet format specs associated with the UDF
</td></tr><tr><td><a href=#bcm_udf_pkt_format_destroy><tt>bcm_udf_pkt_format_destroy</tt></a></td>
<td>&nbsp;</td><td>	Destroy existing packet format entry
</td></tr><tr><td><a href=#bcm_udf_pkt_format_get><tt>bcm_udf_pkt_format_get</tt></a></td>
<td>&nbsp;</td><td>	Deletes packet format spec associated with the UDF
</td></tr><tr><td><a href=#bcm_udf_pkt_format_get_all><tt>bcm_udf_pkt_format_get_all</tt></a></td>
<td>&nbsp;</td><td>	Retrieves the user defined format specification configuration from UDF
</td></tr><tr><td><a href=#bcm_udf_pkt_format_info_get><tt>bcm_udf_pkt_format_info_get</tt></a></td>
<td>&nbsp;</td><td>	Retrieve packet format info given the packet format Id
</td></tr><tr><td><a href=#bcm_udf_pkt_format_info_t_init><tt>bcm_udf_pkt_format_info_t_init</tt></a></td>
<td>&nbsp;</td><td>	Initialize the UDF packet format structure
</td></tr><tr><td><a href=#bcm_udf_t_init><tt>bcm_udf_t_init</tt></a></td>
<td>&nbsp;</td><td>	Initializes the UDF structure
</td></tr><tr><td><a href=#bcm_vlan_stat_counter_sync_get><tt>bcm_vlan_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve the specified statistic to 
	the indicated value for the specified VLAN.
</td></tr><tr><td><a href=#bcm_vlan_stat_sync_get><tt>bcm_vlan_stat_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve per-VLAN statistics from 
	the chip.
</td></tr><tr><td><a href=#bcm_vlan_stat_sync_get32><tt>bcm_vlan_stat_sync_get32</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve per-VLAN statistics from 
	the chip.
</td></tr><tr><td><a href=#bcm_vlan_translate_egress_stat_counter_sync_get><tt>bcm_vlan_translate_egress_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve counter values from egress 
	VLAN translation table.
</td></tr><tr><td><a href=#bcm_vlan_translate_egress_stat_sync_get><tt>bcm_vlan_translate_egress_stat_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve egress VLAN 
	translation statistics from the chip.
</td></tr><tr><td><a href=#bcm_vlan_translate_egress_stat_sync_get32><tt>bcm_vlan_translate_egress_stat_sync_get32</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve egress VLAN 
	translation statistics from the chip.
</td></tr><tr><td><a href=#bcm_vlan_translate_stat_counter_sync_get><tt>bcm_vlan_translate_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve counter values from ingress 
	VLAN translation table.
</td></tr><tr><td><a href=#bcm_vlan_translate_stat_sync_get><tt>bcm_vlan_translate_stat_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve ingress VLAN 
	translation statistics from the chip.
</td></tr><tr><td><a href=#bcm_vlan_translate_stat_sync_get32><tt>bcm_vlan_translate_stat_sync_get32</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve ingress VLAN 
	translation statistics from the chip.
</td></tr><tr><td><a href=#bcm_vxlan_dip_stat_attach><tt>bcm_vxlan_dip_stat_attach</tt></a></td>
<td>&nbsp;</td><td>	Attach counters entries to a given VXLAN DIP.
</td></tr><tr><td><a href=#bcm_vxlan_dip_stat_counter_get><tt>bcm_vxlan_dip_stat_counter_get</tt></a></td>
<td>&nbsp;</td><td>	Get the specified counter statistic for a given VXLAN DIP.
</td></tr><tr><td><a href=#bcm_vxlan_dip_stat_counter_set><tt>bcm_vxlan_dip_stat_counter_set</tt></a></td>
<td>&nbsp;</td><td>	Set the specified counter statistic for a given VXLAN DIP.
</td></tr><tr><td><a href=#bcm_vxlan_dip_stat_detach><tt>bcm_vxlan_dip_stat_detach</tt></a></td>
<td>&nbsp;</td><td>	Detach counters entries to a given VXLAN DIP.
</td></tr><tr><td><a href=#bcm_vxlan_dip_stat_id_get><tt>bcm_vxlan_dip_stat_id_get</tt></a></td>
<td>&nbsp;</td><td>	Retrieve associated stat counter for a given VXLAN DIP.
</td></tr><tr><td><a href=#bcm_vxlan_dip_stat_multi_get><tt>bcm_vxlan_dip_stat_multi_get</tt></a></td>
<td>&nbsp;</td><td>	Get 64-bit counter value for multiple VXLAN DIP statistic types.
</td></tr><tr><td><a href=#bcm_vxlan_dip_stat_multi_get32><tt>bcm_vxlan_dip_stat_multi_get32</tt></a></td>
<td>&nbsp;</td><td>	Get 32-bit counter value for multiple VXLAN DIP statistic types.
</td></tr><tr><td><a href=#bcm_vxlan_dip_stat_multi_set><tt>bcm_vxlan_dip_stat_multi_set</tt></a></td>
<td>&nbsp;</td><td>	set 64-bit counter value for multiple VXLAN DIP statistic types.
</td></tr><tr><td><a href=#bcm_vxlan_dip_stat_multi_set32><tt>bcm_vxlan_dip_stat_multi_set32</tt></a></td>
<td>&nbsp;</td><td>	set 32-bit counter value for multiple VXLAN DIP statistic types.
</td></tr><tr><td><a href=#bcm_vxlan_stat_counter_sync_get><tt>bcm_vxlan_stat_counter_sync_get</tt></a></td>
<td>&nbsp;</td><td>	Force an immediate counter update and retrieve counter statistic values for 
	a vxlan vp/vpn index.
</td></tr><tr><td><a href=#bcm_vxlan_stat_enable_set><tt>bcm_vxlan_stat_enable_set</tt></a></td>
<td>&nbsp;</td><td>	Enable/Disable collection of statistics on the indicated port and vpn
</td></tr><tr><td><a href=#l3_subnet_route_find><tt>l3_subnet_route_find</tt></a></td>
<td>&nbsp;</td><td>	Find a longest prefix matched route given the ip and netmask.
</td></tr><tr><td><a href=#multicast_replication_t_init><tt>multicast_replication_t_init</tt></a></td>
<td>&nbsp;</td><td>	Init the <tt>multicast_replication_t</tt> structure.
</td></tr></table>
<br><br><hr noshade><br><br>
    <a name=section_about>
    <h3>Section 1:  About This Document
</h3>
<p>These are the Release Notes for the Broadcom Network Switching
Software Development Kit, Release 6.4.1.
<p>This document provides a general description of the release and its new features. It also describes the chips supported by the release, BCM API additions or changes, resolved issues, and any relevant open issues.  
<br><br><hr noshade><br><br>
    <a name=section_docs>
    <h3>Section 2:  Product Documentation
</h3>
<p>The following documents are available through Broadcom's
Customer Support Portal, http://support.broadcom.com. They are
the primary source of information and should be referenced 
when using this release:
<p><h3>Table 1:   Product Documentation
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Document</b></td><td><b> Description
 </b></td></tr><tr><td>  56XX-PG641-R</td><td> BCM API Reference Guide.
 <p>    This manual describes the theory of operations of the API and all existing BCM 
    APIs for this release. 
</td></tr><tr><td>  56XX-PG707-R</td><td> Stacking Software Guide
 <p>    This guide describes how to use the discovery and stacking applications 
    provided in this release. 
</td></tr><tr><td>  56XX-PG818-R</td><td> Platform Guide
 <p>    This guide describes the SDK source and Makefile structure, abstraction and 
    porting layers, device specific interactions, and the platform/operating
    system specific features of the SDK. If this is your first time
    working with the SDK, start with this document. 
</td></tr></tbody></table><br><br><hr noshade><br><br>
    <a name=section_new>
    <h3>Section 3:  New in this Release
</h3>
<p>This section describes feature and device support that is introduced in this release. 
<br><hr noshade><a name="new-features-by-device"></a>
<h3>Section 3.1:   Summary of New Features
</h3>
<br><hr noshade><a name="Greyhound"></a>
<h3>Section 3.1.1:   Greyhound
</h3>
<p>    BCM534XX family with switch and embedded processor SOC chips offers industry-leading integration and
    performance in a small footprint. Up to 16 10GbE ports are supported with KX, KR, XAUI, RXAUI, and
    SGMII modes. This release contains Early Access support for BCM534XX A0 device in external and
    internal host modes. For internal host mode, the SDK for BCM5341X series family shall be
    compatible with LDK version 3.5.x or later
<p>    The supported devices with respective port configurations are as listed: (x denotes as 0/1)
<ul><li> BCM534x2: 8 x 1G/2.5G/5G/10G
 </li><li> BCM534x8: 24 x 1G/2.5G
 </li><li> BCM534x1 option1: 4 x QSGMII, 8 x 1GbE, 4 x 10GbE
 </li><li> BCM534x1 option2: 4 x QSGMII, 8 x 1GbE, 2 x 10Gbe, 2 x HiGigDuo[13]
 </li><li> BCM534x5: 16 x 1G/2.5G/5G/10G
 </li><li> BCM534x6: 12 x 10GbE, 8 x 2.5GbE, 4 x 5GbE/2.5GbE
 </li></ul><p>    Each device has passed in-house diagnostic and traffic tests with loopback modes of MAC, internal PHY
    and external PHY, including
 <ul><li> Register/Memory access test
 </li><li> Table DMA test
 </li><li> Linkscan MDIO test
 </li><li> Traffic Test with MAC, internal and external PHY loopback
 </li><li> Counter/MIB test
 </li><li> L2/L3 Table operation test
 </li><li> VLAN Table operation test
 </li><li> COSQ test
 </li><li> L3 test
 </li><li> SER test
 </li><li> PCI Compliance and S-Channel test
 </li></ul><p>    The PHY microcode delivered in this release is only meant for bringup purposes. It is not
    guaranteed to withstand stress testing (such as overnight runs on every port). It is partially
    regressed to be reasonably stable for typical process and temperatures. It's adaptation may vary
    slightly between ports depending channel variations
<p><br><hr noshade><a name="Ranger2"></a>
<h3>Section 3.1.2:   Ranger2 
</h3>
<p>    BCM5606X family with switch and embedded processor SOC chips offers industry-leading integration and
    performance in a small footprint. Up to 16 10GbE ports are supported with KX, KR, XAUI, RXAUI, and
    SGMII modes. This release contains Early Access support for BCM5606X A0 device in external and
    internal host modes. For internal host mode, the SDK for BCM5606X series family shall be
    compatible with LDK version 3.5.x or later
<p>    The supported devices with respective port configurations are as listed:
<ul><li> BCM56060: 16 x 1G/2.5G/5G/10G
 </li><li> BCM56063: 4 x QSGMII, 4 x 10GbE (XFI)
 </li><li> BCM56064 option1: 4 x QSGMII, 8 x 1GbE, 4 x 10GbE
 </li><li> BCM56064 option2: 4 x QSGMII, 8 x 1GbE, 2 x 10Gbe, 2 x HiGigDuo[13]
 </li></ul><p>    Each device has passed in-house diagnostic and traffic tests with loopback modes of MAC, internal PHY
    and external PHY, including
 <ul><li> Register/Memory access test
 </li><li> Table DMA test
 </li><li> Linkscan MDIO test
 </li><li> Traffic Test with MAC, internal and external PHY loopback
 </li><li> Counter/MIB test
 </li><li> L2/L3 Table operation test
 </li><li> VLAN Table operation test
 </li><li> COSQ test
 </li><li> L3 test
 </li><li> SER test
 </li><li> PCI Compliance and S-Channel test
 </li></ul><p>    The PHY microcode delivered in this release is only meant for bringup purposes. It is not
    guaranteed to withstand stress testing (such as overnight runs on every port). It is partially
    regressed to be reasonably stable for typical process and temperatures. It's adaptation may vary
    slightly between ports depending channel variations
 <p><br><hr noshade><a name="FE3200"></a>
<h3>Section 3.1.3:   BCM88950 (FE3200) Preview Release
 </h3>
<p>    The Broadcom BCM88950 is the fourth generation in the Dune product line of
    Fabric Element (FE) devices - following BCM88750 (FE1600)
<p>    BCM88950 is a self-routing cell-based switching element and enables BCM88670
    switch-based systems to build flexible networking platforms providing user
    bandwidth over 960 Tbps.
<p>    This is a  preview release of BCM88950 driver. It is provided for reference, and
    allows an early integration of the customer's application with the SDK APIs that are currently supported.
    The list of APIs which will be supported for BCM88950, and the ones that are already implemented,
    can be found at the SDK-6.4.1 support matrix document.
<p>    The following BCM88950 exclusive features were added compared to the 6.4.1 EA2 version
 <ul><li> BCM88950 Multistage exclusive features: Asymmetrical FE13, FE13 local routing
 </li></ul><p><br><hr noshade><a name="JERICHO"></a>
<h3>Section 3.1.4:   BCM88670 (Jericho) Preview Release
 </h3>
<p>    The Broadcom BCM88X7X product line is the sixth generation of the 
    Dune product line devices. Together with the BCM88950 fabric element (FE) device,
    it is used to build a variety of network switch solutions, enabling switching platforms of up to
    12,000 100G Ethernet ports. The BCM88X7X device processes up to 720 Gbps traffic at wirespeed with 
    various port rate combinations, supporting up to six 100G full-duplex ports at Layer 2 through 
    Layer 4, with integrated deep-buffer traffic management capabilities and a fabric interface. 
<p>    This is a  preview release of BCM88670 driver. It is provided for reference, and
    allows an early integration of the customer application with the SDK APIs that are currently supported.
    The list of APIs which will be supported for BCM88670, and the ones that are already implemented,
    can be found at the SDK-6.4.1 support matrix document.
<p>    For differences in the BCM SDK SW interface between BCM88660 and BCM88670 devices,
    please refer to BCM88670 and BCM88660 SW compatibility document.
<p>    BCM88670 preview driver supports the following features:
 <ul><li> Registers access
 </li><li> PCID simulation
 </li><li> Access TR tests
 </li><li> Initialization sequence
 </li><li> API definition and initial implementation of UC and MC data plane
 </li><li> Link statistics
 </li></ul><p>    Arad+ features implementation, including
 <ul><li> L2
 </li><li> STG
 </li><li> VLAN
 </li><li> Consistent hashing
 </li><li> Field Processor
 </li><li> MIM
 </li></ul><p><br><hr noshade><a name="ARAD"></a>
<h3>Section 3.1.5:   BCM88650 (ARAD) and BCM88660 (ARAD+) Release
 </h3>
<p>    Several enhancements and changes were done on existed features between 
    SDK SW between 6.4.X releases and 6.3.X release. Those changes require application level
    changes in order to move existed application from 6.3.X release to 6.4.X release. 
    For all important changes and clarifications, please refer to BCM88660 SW Compatiblity 
    between 6.4.X and 6.3.X BCM SDK document.
<p><p><br><hr noshade><a name="Watch-out-for-this"></a>
<h3>Section 3.2:   Things to note
</h3>
<p>This section lists items that require special attention. 
<br><hr noshade><a name="bcmx_deprecation"></a>
<h3>Section 3.2.1:   BCMX API deprecation
 </h3>
<p>   BCMX APIs have not been enhanced or supported for newer devices
   since SDK-5.10.2.  Legacy BCMX APIs, supported in SDK-5.10.2
   will be deprecated starting with SDK-6.3.5 release.
   Customers are encouraged to transition from BCMX APIs to their equivalent
   BCM APIs.
 <p>   Please contact Broadcom application support for any help in the transition. 
 <p><br><hr noshade><a name="phy_issue2"></a>
<h3>Section 3.2.2:   BCM8483X PHY Firmware
</h3>
<p>        Status of F/W version 1.67 released with SDK is preview. 
        Check support.broadcom.com for latest available validated firmware for the BCM8483X  family devices. 
        Consult F/W release notes for known issues.
<p><br><hr noshade><a name="phy_issue3"></a>
<h3>Section 3.2.3:   BCM8484X PHY Firmware
</h3>
<p>        Status of F/W version 1.06 released with SDK is preview. 
        Check support.broadcom.com for latest available validated firmware for the BCM8484X  family devices. 
        Consult F/W release notes for known issues.
<p><br><hr noshade><a name="phy_issue4"></a>
<h3>Section 3.2.4:   spn_PHY_PORT_PRIMARY_AND_OFFSET
</h3>
<p>        Setting of the config property spn_PHY_PORT_PRIMARY_AND_OFFSET is absolutely required for the following PHYs.
 <p>        BCM54880E
        BCM54680E
        BCM54682E
        BCM54685E
        BCM54640E
        BCM542XX
 <p><br><hr noshade><a name="56850_module_64ports"></a>
<h3>Section 3.2.5:   BCM56850 handling of <tt>module_64ports</tt>
 </h3>
<p>   Setting <tt>module_64ports</tt>=1 config variable indicates that one module ID covers 64 ports.
   Please, note that while on the earlier devices this effectively meant choosing a single-modid
   mode for the device due to the fact that the total number of ports was less than 64, on devices
   that have more than 64 ports, such as BCM56850 (what about 56840?) it means choosing dual-modid
   mode instead. Please, always use <tt>bcm_stk_modid_count</tt>() to get the actual number of modids
   required by a given device. Also, note that the API <tt>bcm_port_gport_get</tt>() is the only correct
   way to translate the physical port number into a <tt>MODPORT_GPORT</tt> and it works correctly regardless
   of the number of modids assigned to the device
 <p><br><hr noshade><a name="stack_attach_failure"></a>
<h3>Section 3.2.6:   Occasional stack attach failures
 </h3>
<p>   There may be occasional stack attach failures due to the stack master
   attaching a slave device before slave programming is complete. Use
   the stk.soc config variable stktopomasterdelay to increase the length of
   time the stack master will wait before attaching a slave.
 <p><br><hr noshade><a name="mutex_warning_issue3"></a>
<h3>Section 3.2.7:   Unbalanced Mutex warning
 </h3>
<p>   A potential issue with unbalanced mutexes has been uncovered in previous releases of SDK and special code
   has been added to automatically detect that condition. While we believe that we've identified all these
   issues in our regression testing, there is a slight probability that you can see the following message
   on the console:
<p>   WARNING: Mutex "<tt>mutex_name</tt>" has not been unlocked before being destroyed.
<p>         Current owner is "<tt>thread_name</tt>".
<p>         Should you see such a warning, please, copy it verbatim and contact Broadcom Support. 
<p><br><hr noshade><a name="ip_route_lookup"></a>
<h3>Section 3.2.8:   IP Route Lookup
 </h3>
<p>   If a packet destination IP lookup falls in between 2 route prefixes having a common 
   prefix part and differing lengths, then the lower route prefix, which is the correct 
   match, may not always be returned correctly.
 <p><br><hr noshade><a name="bcm_field_TunnelType_t"></a>
<h3>Section 3.2.9:   BCM Field Qualifier Tunnel Type
 </h3>
<p>   The enumeration type bcm_field_TunnelType_t has changed its values
   between SDK-6.2.x, SDK-6.3.0 and SDK-6.3.1.
 <p>   The implication is that legacy field qualifier support for
   bcm_field_qualify_TunnelType in XGS devices running SDK-6.3.1 and later
   has been broken.
 <p>   Features such as RPC between systems running SDK-6.2.x or
   SDK-6.3.0 on one and SDK-6.3.1 (or later) on another will not
   work properly for the BCM field qualifier tunnel type.
 <p>   This issue is being addressed in SDK-6.3.5, SDK-6.4.0, and later releases.
 <p><br><hr noshade><a name="warmboot"></a>
<h3>Section 3.2.10:   WarmBoot: Validated warmboot upgrades.
</h3>
<p>       Following warmboot upgrades have been validated in this release.

<a name=ssu></a>
<h3>Table 2:   Validated Warmboot upgrades
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Software upgrade</b></td><td><b> Supported
 </b></td></tr><tr><td>  6.4.0 to 6.4.1</td><td> Yes
 </td></tr><tr><td>  6.3.7 to 6.4.1</td><td> Yes
 </td></tr></tbody></table><p>       Warmboot testing and issue resolution has focused on the following family of devices:
 <ul><li> Trident2
 </li><li> Trident+
 </li><li> Triumph3
 </li><li> Katana2
 </li><li> Helix4
 </li><li> Hurrican2
 </li><li> Katana
 </li><li> Raven
 </li></ul><p><br><hr noshade><a name="spinlock"></a>
<h3>Section 3.2.11:   New Spinlock APIs
 </h3>
<p>   In the SDK release v6.3.8/SDK 6.4.1 a new lock mechanism -- spinlock was introduced to satisfy some requirements 
   for protecting small critical sections more efficiently. The spinlock mechanism is applicable to the scenario 
   in which the critical section to be protected only contains simple operations, such as inserting or removing nodes 
   from a linked list, increasing or decreasing shared data. The data structure and interfaces of the spinlock are 
   defined at SAL layer in SDK as follows,
<blockquote><pre>   typedef struct <tt>sal_spinlock_s</tt> {
       char <tt>spinlock_opaque_type</tt>;
   } *<tt>sal_spinlock_t</tt>;

   <tt>sal_spinlock_t</tt> <tt>sal_spinlock_create</tt>(char *desc);
   int <tt>sal_spinlock_destroy</tt>(<tt>sal_spinlock_t</tt> lock);
   int <tt>sal_spinlock_lock</tt>(<tt>sal_spinlock_t</tt> lock);
   int <tt>sal_spinlock_unlock</tt>(<tt>sal_spinlock_t</tt> lock);
</pre></blockquote>   These primitives have been implemented for vxWorks and Linux. The changes are available in src/sal/core/linux/sync.c 
   for Linux kernel mode, src/sal/core/unix/sync.c for Linux user mode and src/sal/core/vxworks/sync.c for vxWorks. 
   Customers who use different OSes will need to make similar implementation in their OS specific SAL layer source files. 
   If additional information is needed, please refer to the field alert document "Spinlock Application Note" or contact 
   your Field Support staff.
 <p><p><br><hr noshade><a name="new-hardware"></a>
<h3>Section 3.3:   New Devices and Systems
</h3>
<p>For any given SDK release, support for certain devices may be provided in Preview or Supported status. Devices in preview status are provided to allow early integration of the customer's application with the SDK APIs that support that device. This software has not been tested on the physical target device and should not be expected to fully function. 
<p>Devices in "Supported" status have completed the full QA process and are intended for use in production systems.  It is expected that customers would integrate the version of the SDK which provides "Supported" status for their use on actual development or production systems.

<a name=ssd></a>
<h3>Table 3:   Supported Switch Devices
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Family</b></td><td><b>  Devices</b></td><td><b> Description
</b></td></tr><tr><td> BCM53400
</td><td> BCM53401 A0
</td><td> 24-port GbE plus 4-port 10GbE Multilayer Ethernet Switch with HiGi Uplinks
</td></tr><tr><td></td><td> BCM53402 A0
</td><td> 8-port 10GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM53405 A0
</td><td> 16-port 10GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM53406 A0
</td><td> 12-port 10GbE plus 8-port 2.5GbE and 4-port 5GbE/2.5GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM53408 A0
</td><td> 24-port 1GbE/2.5GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM53411 A0
</td><td> 24-port GbE plus 4-port 10GbE Multilayer Ethernet Switch with HiGi Uplinks and integrated CPU
</td></tr><tr><td></td><td> BCM53412 A0
</td><td> 8-port 10GbE Multilayer Ethernet Switch with integrated CPU
</td></tr><tr><td></td><td> BCM53415 A0
</td><td> 16-port 10GbE Multilayer Ethernet Switch with integrated CPU
</td></tr><tr><td></td><td> BCM53416 A0
</td><td> 12-port 10GbE plus 8-port 2.5GbE and 4-port 5GbE/2.5GbE Ethernet Switch with integrated CPU
</td></tr><tr><td></td><td> BCM53418 A0
</td><td> 24-port 1GbE/2.5GbE Multilayer Ethernet Switch with integrated CPU
</td></tr><tr><td> BCM56060
</td><td> BCM56060 A0
</td><td> 16-port 10GbE Multilayer Ethernet Switch with integrated CPU
</td></tr><tr><td></td><td> BCM56063 A0
</td><td> 16-port 1GbE plus 4-port 10GbE (XFI) Multilayer Switch with integrated CPU
</td></tr><tr><td></td><td> BCM56064 A0
</td><td> 24-port GbE plus 4-port 10GbE Multilayer Managed Switch with HiGi Uplinks and integrated CPU
</td></tr><tr><td> BCM56450
</td><td> BCM56248L B0
</td><td> 11xGE + 8x2.5G
</td></tr><tr><td> BCM56846
</td><td> BCM56831 A1
</td><td> Trident+ SKU - 24-port 10GE switch with 40GE support for embedded applications
</td></tr></tbody></table>
<a name=psd></a>
<h3>Table 4:   Preview Switch Devices
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Family</b></td><td><b>  Devices</b></td><td><b> Description
</b></td></tr><tr><td> BCM56450
</td><td> BCM56455
</td><td> Katana2 Access 1 x XAUI + 8 x GE without L3 routing and MPLS features
</td></tr><tr><td> BCM56450
</td><td> BCM56248L w/10G Upgrade
</td><td> 8xGE+8x10G with reduced table sizes
</td></tr><tr><td> DNX
</td><td> <tt>BCM88670_A0</tt>
</td><td> 720 Integrated Packet Processor, Traffic Manager, and Fabric Interface Single-Chip Device
</td></tr><tr><td> DNX
</td><td> <tt>BCM88950_A0</tt>
</td><td> 3.2 Tbps self-routing switching element
</td></tr><tr><td> BCM56450
</td><td> BCM55450 B0
</td><td> KT2 Access-8 FX + 2 F-HG
</td></tr><tr><td> BCM56450 
</td><td> BCM56452 B0
</td><td> 24xGE + 4xF.XAUI
</td></tr><tr><td> BCM56450
</td><td> BCM56454 B0
</td><td> 8xGE + 2 x F.XAUI
</td></tr><tr><td> BCM56455
</td><td> BCM55455 B0
</td><td> KT2 Access - 8 FX + 2 F-HG
</td></tr><tr><td> BCM56456 
</td><td> BCM56457 B0
</td><td> 24xGE + 4xF.XAUI
</td></tr><tr><td> BCM56456 
</td><td> BCM56458 B0
</td><td> 8xGE + 2xF.XAUI
</td></tr><tr><td> BCM56850 
</td><td> BCM56838 A2
</td><td> Trident2 SKU - Ready for Bringup - 72/320G Devices with 1.25/3.125/6.25G Serdes and 4 SFIs
</td></tr><tr><td> BCM56846
</td><td> BCM56835C A1
</td><td> Trident+ SKU - (64 x 10 GbE) + (4 x 1 GbE)
</td></tr><tr><td> BCM56846 
</td><td> BCM56849 A1
</td><td> Trident+ SKU - (56 x 1GbE/2.5GbE) + (8 x 10GbE)
</td></tr><tr><td> BCM56850 
</td><td> BCM56834 A2
</td><td> Trident2 SKU - High density 10G and 40G switch for embedded applications
</td></tr><tr><td> BCM56640 
</td><td> BCM56044 B0
</td><td> Ranger+ SKU - 100G + 3xF.HG[42] + 1GE
</td></tr><tr><td> BCM56846 
</td><td> BCM56847 A1
</td><td> Trident+ SKU - (64 x 10 GbE) + (4 x 1 GbE)
</td></tr><tr><td> BCM56640 
</td><td> BCM56545K
</td><td> Triumph 3 SKU - Device recognition only- 48-port GE switch + 4x10GE + 4xHG[42] / 40GE
</td></tr><tr><td> BCM56640 
</td><td> BCM56546K
</td><td> Triumph 3 SKU - Device recognition only- 28-port GE switch + 4x10GE + 4xHG[42] / 40GE
</td></tr><tr><td> BCM56240
</td><td> BCM56245
</td><td> Saber SKU -2x (10GbE/4x 1GbE/4x 2.5GbE) + 2x 10GbE/12GbE/13GbE, IEEE 1588 enable
</td></tr><tr><td> BCM56242
</td><td> BCM56246
</td><td> Saber SKU -10x 1GbE/2.5GbE, IEEE 1588 enabled
</td></tr><tr><td> BCM56150
</td><td> BCM53347
</td><td> Wolfhound SKU - 24-port GbE Multilayer WebSmart Switch with 6xQSGMII + 4x1/10G
</td></tr></tbody></table>
<a name=newphys></a>
<h3>Table 5:   PHYs
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Device</b></td><td><b>  Driver Family</b></td><td><b> Description
</b></td></tr><tr><td> <tt>BCM54618_A0</tt>
</td><td> 54616
</td><td> Single-Chip 10/100/1000BASE-T Gigabit Ethernet Transceiver (IEEE 1588 features are not supported by SDK driver)
</td></tr></tbody></table>
<a name=preview_phys></a>
<h3>Table 6:   Preview PHYS
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Device</b></td><td><b>  Driver Family</b></td><td><b> Description
</b></td></tr><tr><td> <tt>BCM82328_B0</tt>
</td><td> 82328
</td><td> Dual 40 GbE/Octal 10 GbE QSFP+ XLPPI-to-XLAUI PHY. Firmware version 7 "(Preview)
</td></tr><tr><td> BCM54220SE
</td><td> 54220
</td><td> Dual Copper/Fiber Gigabit Ethernet Transceiver (Bringup) EEE , SyncE and 1588 not yet supported
</td></tr><tr><td> <tt>BCM82322_B0</tt>
</td><td> 82328
</td><td> 12port Gallardo28 supporting 12x10G, 3x40G, 1x100G;
</td></tr></tbody></table>
<a name=preview_cpus></a>
<h3>Table 7:   Preview CPU Subsystems
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  CPU Subsystem</b></td><td><b> Description
</b></td></tr><tr><td> <tt>BCM9XLP2_XMC_A1</tt>
</td><td> XMC with Broadcom XLP II 200 series multicore processor (MIPS64 Release-II ISA-compliant) with eight NXCPU. processing units, each operating at up to 2.0 GHz
</td></tr></tbody></table><p><br><hr noshade><a name="api-changes"></a>
<h3>Section 3.4:   Summary of BCM changes
</h3>
<p>This section summarizes BCM API changes in this release.
Complete documentation is available in the Network Switching Software
Programmer's Guide 56XX-PG641-R.  (See section 2 earlier 
in this document for availability). 
<br><hr noshade><a name="debugsubsystem"></a>
<h3>Section 3.4.1:   Debug subsystem
</h3>
<p>        This version of the SDK uses a new logging framework called Broadcom System Logging (BSL)
        which is independent of the Configuration Manager (CM.) This change affects the system
        initialization, and SDK-based applications will require the following changes in the SDK system
        interface:
<ul><li> The function <tt>soc_cm_init</tt>() no longer takes any parameters.
 </li><li> A new function <tt>bsl_init</tt>() must be called to initialize the BSL framework.
 </li></ul><p>        The SDK source code contains new files which demonstrates how application-provided BSL hooks
        can be implemented. Please see the SDK Platform Guide for updated documentation on the CM and
        the BSL framework.
<p><br><hr noshade><a name="fund"></a>
<h3>Section 3.4.2:   BCM Fundamentals
</h3>
<br><hr noshade><a name="fund_bcm_modules"></a>
<h3>Section 3.4.2.1:   BCM Modules
</h3>
<p>	A new module <tt>BCM_MODULE_UDF</tt> has been added in this release.
<p>	The BCM APIs are classified into API groups called 'modules'.
	The following table lists all the BCM modules and their string equivalents.

<a name=BCM_MODULES_table></a>
<h3>Table 8:   BCM Module IDs
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  BCM Module ID</b></td><td><b> String Equivalent
 </b></td></tr><tr><td>  <tt>BCM_MODULE_PORT</tt></td><td> port
 </td></tr><tr><td>  <tt>BCM_MODULE_L2</tt></td><td> l2
 </td></tr><tr><td>  <tt>BCM_MODULE_VLAN</tt></td><td> vlan
 </td></tr><tr><td>  <tt>BCM_MODULE_TRUNK</tt></td><td> trunk
 </td></tr><tr><td>  <tt>BCM_MODULE_COSQ</tt></td><td> cosq
 </td></tr><tr><td>  <tt>BCM_MODULE_MCAST</tt></td><td> mcast
 </td></tr><tr><td>  <tt>BCM_MODULE_LINKSCAN</tt></td><td> linkscan
 </td></tr><tr><td>  <tt>BCM_MODULE_STAT</tt></td><td> stat
 </td></tr><tr><td>  <tt>BCM_MODULE_VIRTUAL</tt></td><td> virtual
 </td></tr><tr><td>  <tt>BCM_MODULE_COMMON</tt></td><td> common
 </td></tr><tr><td>  <tt>BCM_MODULE_MIRROR</tt></td><td> mirror
 </td></tr><tr><td>  <tt>BCM_MODULE_L3</tt></td><td> l3
 </td></tr><tr><td>  <tt>BCM_MODULE_STACK</tt></td><td> stack
 </td></tr><tr><td>  <tt>BCM_MODULE_IPMC</tt></td><td> ipmc
 </td></tr><tr><td>  <tt>BCM_MODULE_STG</tt></td><td> stg
 </td></tr><tr><td>  <tt>BCM_MODULE_TX</tt></td><td> tx
 </td></tr><tr><td>  <tt>BCM_MODULE_L2GRE</tt></td><td> l2gre
 </td></tr><tr><td>  <tt>BCM_MODULE_AUTH</tt></td><td> auth
 </td></tr><tr><td>  <tt>BCM_MODULE_RX</tt></td><td> rx
 </td></tr><tr><td>  <tt>BCM_MODULE_FIELD</tt></td><td> field
 </td></tr><tr><td>  <tt>BCM_MODULE_TIME</tt></td><td> time
 </td></tr><tr><td>  <tt>BCM_MODULE_SUBPORT</tt></td><td> subport
 </td></tr><tr><td>  <tt>BCM_MODULE_MPLS</tt></td><td> mpls
 </td></tr><tr><td>  <tt>BCM_MODULE_FABRIC</tt></td><td> fabric
 </td></tr><tr><td>  <tt>BCM_MODULE_MIM</tt></td><td> mim
 </td></tr><tr><td>  <tt>BCM_MODULE_POLICER</tt></td><td> policer
 </td></tr><tr><td>  <tt>BCM_MODULE_OAM</tt></td><td> oam
 </td></tr><tr><td>  <tt>BCM_MODULE_FAILOVER</tt></td><td> failover
 </td></tr><tr><td>  <tt>BCM_MODULE_VSWITCH</tt></td><td> vswitch
 </td></tr><tr><td>  <tt>BCM_MODULE_WLAN</tt></td><td> wlan
 </td></tr><tr><td>  <tt>BCM_MODULE_QOS</tt></td><td> qos
 </td></tr><tr><td>  <tt>BCM_MODULE_MULTICAST</tt></td><td> multicast
 </td></tr><tr><td>  <tt>BCM_MODULE_TRILL</tt></td><td> trill
 </td></tr><tr><td>  <tt>BCM_MODULE_IPFIX</tt></td><td> ipfix
 </td></tr><tr><td>  <tt>BCM_MODULE_NIV</tt></td><td> niv
 </td></tr><tr><td>  <tt>BCM_MODULE_CES</tt></td><td> ces
 </td></tr><tr><td>  <tt>BCM_MODULE_PTP</tt></td><td> ptp
 </td></tr><tr><td>  <tt>BCM_MODULE_BFD</tt></td><td> bfd
 </td></tr><tr><td>  <tt>BCM_MODULE_REGEX</tt></td><td> regex
 </td></tr><tr><td>  <tt>BCM_MODULE_VXLAN</tt></td><td> vxlan
 </td></tr><tr><td>  <tt>BCM_MODULE_EXTENDER</tt></td><td> extender
 </td></tr><tr><td>  <tt>BCM_MODULE_FCOE</tt></td><td> fcoe
 </td></tr><tr><td>  <tt>BCM_MODULE_UDF</tt></td><td> udf
 </td></tr></tbody></table><p><p><br><hr noshade><a name="bfd"></a>
<h3>Section 3.4.3:   Bidirectional Forwarding Detection
</h3>
<p>        A new BFD Tunnel type, defining the encapsulation type for the session, has been added.
 <h3>Table 9:   BFD Tunnel Types
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Flag</b></td><td><b> Description
 </b></td></tr><tr><td>  bcmBFDTunnelTypePweGal</td><td> MPLS PWE with GAL, GACH
 </td></tr></tbody></table><p>        A new BFD Endpoint flag has been added.
 <h3>Table 10:   BFD Endpoint Info Structure Flag Definitions
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Flag</b></td><td><b> Description
 </b></td></tr><tr><td>  <tt>BCM_BFD_ENDPOINT_REMOTE_UPDATE_STATE_DISABLE</tt></td><td> Disable updating RMEP DB.
 </td></tr></tbody></table><p>        The new <tt>sampling_ratio</tt>, <tt>loc_clear_threshold</tt> and <tt>ip_subnet_length</tt> fields in data structure
        <tt>bcm_bfd_endpoint_info_t</tt> have been added.
<blockquote><pre>/* BFD endpoint object. */
typedef struct <tt>bcm_bfd_endpoint_info_s</tt> {
    ...
    int <tt>sampling_ratio</tt>;        /* percentage of packets sampled to the
                                * CPU
                                */
    uint8 <tt>loc_clear_threshold</tt>; /* Number of packets required to reset
			        * the Loss-of-Continuity status per
				* endpoint.
                                */ 
    uint32 <tt>ip_subnet_length</tt>;   /* The subnet length for incoming packet
			        * validity check. Value 0 indicates no
				* check is performed, positive values
				* indicate the amount of MSBs to be
				* compared.
                                */
} <tt>bcm_bfd_endpoint_info_t</tt>;
</pre></blockquote><p><br><hr noshade><a name="regex"></a>
<h3>Section 3.4.4:   Regex API
</h3>
<p>        A new API <tt>bcm_regex_session_delete_all</tt>() has been added in this release.
<p><hr noshade>
<h3>APIs for Section 3.4.4:  Regex API
</h3>
<a name=bcm_regex_session_delete_all></a>
<hr noshade>
<h2 class="api">
<tt>bcm_regex_session_delete_all</tt><br>
</h2>

<blockquote>
	Deletes all the entries from the regex session table.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/bregex.h&gt;
	int bcm_regex_session_delete_all(int unit);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Deletes all the entries (IPv4 and IPv6) from the regex session table.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<br><hr noshade><a name="cosq"></a>
<h3>Section 3.4.5:   Class of Service Queue Configuration
</h3>
<p>        New CoSQ Control Types have been added.
 
<a name=BCM_COSQ_CONTROL_table></a>
<h3>Table 11:   CoSQ Control Type Values
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> Value
 </b></td><td><b> Description
 </b></td><td><b> Arg value
 </b></td></tr><tr><td><tt>bcmCosqControlEgressPortPoolYellowLimitBytes</tt></td><td> Egress port service pool limit setting for yellow packets.
 </td><td><tt>Shared</tt> port service pool size for yellow packets.
 </td></tr><tr><td><tt>bcmCosqControlEgressPortPoolRedLimitBytes</tt></td><td> Egress port service pool limit setting for red packets.
 </td><td><tt>Shared</tt> port service pool size for red packets.
 </td></tr></tbody></table><p>        New cosq gport types have been added for <tt>bcm_cosq_gport_handle_get</tt>() API.
 
<a name=BCM_COSQ_GPORT_type></a>
<h3>Table 12:   gport types
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td>  bcmCosqGportTypeFabricPipe</td><td> Fabric all pipes gport
 </td></tr><tr><td>  bcmCosqGportTypeFabricPipeEgress</td><td> Fabric egress pipes gport
 </td></tr><tr><td>  bcmCosqGportTypeFabricPipeIngress</td><td> Fabric ingress pipes gport
 </td></tr><tr><td>  bcmCosqGportTypeFabricPipeMiddle</td><td> Fabric middle pipes gport
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshCommonLocal0</td><td> mesh common local 0
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshCommonLocal1</td><td> mesh common local 1
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshCommonDev1</td><td> mesh common device 1
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshCommonDev2</td><td> mesh common device 2
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshCommonDev3</td><td> mesh common device 3
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshCommonMc</td><td> mesh common multicast
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosCommonLocal0</td><td> clos common local 0
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosCommonLocal1</td><td> clos common local 1
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosCommonFabric</td><td> clos common fabric
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosCommonUnicastFabric</td><td> clos common unicast fabric
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosCommonMulticastFabric</td><td> clos common multicast fabric
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshLocal0OcbHigh</td><td> mesh local 0 ocb high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshLocal0OcbLow</td><td> mesh local 0 ocb low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshLocal0MixHigh</td><td> mesh local 0 mix high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshLocal0MixLow</td><td> mesh local 0 mix low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshLocal1OcbHigh</td><td> mesh local 1 ocb high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshLocal1OcbLow</td><td> mesh local 1 ocb low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshLocal1MixHigh</td><td> mesh local 1 mix high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshLocal1MixLow</td><td> mesh local 1 mix low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshDevlOcbHigh</td><td> mesh device 1 ocb high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshDev1OcbLow</td><td> mesh device 1 ocb low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshDev1MixHigh</td><td> mesh device 1 mix high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshDev1MixLow</td><td> mesh device 1 mix low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshDev2OcbHigh</td><td> mesh device 2 ocb high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshDev2OcbLow</td><td> mesh device 2 ocb low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshDev2MixHigh</td><td> mesh device 2 mix high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshDev2MixLow</td><td> mesh device 2 mix low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshDev3OcbHigh</td><td> mesh device 3 ocb high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshDev3OcbLow</td><td> mesh device 3 ocb low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshDev3MixHigh</td><td> mesh device 3 mix high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshDev3MixLow</td><td> mesh device 3 mix low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshMcOcbHigh</td><td> mesh multicast ocb high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshMcOcbLow</td><td> mesh multicast ocb low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshMcMixHigh</td><td> mesh multicast mix high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshMcMixLow</td><td> mesh multicast mix low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshLocal0</td><td> mesh local 0
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshLocal1</td><td> mesh local 1
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMeshMc</td><td> mesh multicast
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricMesh</td><td> mesh
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosLocal0OcbHigh</td><td> clos local 0 ocb high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosLocal0OcbLow</td><td> clos local 0 ocb low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosLocal0MixHigh</td><td> clos local 0 mix high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosLocal0MixLow</td><td> clos local 0 mix low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosLocal1OcbHigh</td><td> clos local 1 ocb high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosLocal1OcbLow</td><td> clos local 1 ocb low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosLocal1MixHigh</td><td> clos local 1 mix high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosLocal1MixLow</td><td> clos local 1 mix low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosUnicastFabricOcbHigh</td><td> clos fabric unicast ocb high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosUnicastFabricOcbLow</td><td> clos fabric unicast mix high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosUnicastFabricMixHigh</td><td> clos fabric unicast ocb low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosUnicastFabricMixLow</td><td> clos fabric unicast mix low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosFmqGuaranteedOcb</td><td> clos fabric multicast guaranteed ocb
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosFmqBestEffortOcb</td><td> clos fabric multicast best effort ocb
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosFmqGuaranteedMix</td><td> clos fabric multicast guaranteed mix
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosFmqBestEffortMix</td><td> clos fabric multicast best effort mix
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosLocal0</td><td> clos local 0
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosLocal1</td><td> clos local 1
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosLocal0High</td><td> clos local 0 high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosLocal0Low</td><td> clos local 0 low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosLocal1High</td><td> clos local 1 high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosLocal1Low</td><td> clos local 1 low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosOcbHigh</td><td> clos ocb high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosMixHigh</td><td> clos mix high
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosOcbLow</td><td> clos ocb low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClosMixLow</td><td> clos mix low
 </td></tr><tr><td>  bcmCosqGportTypeGlobalFabricClos</td><td> clos
 </td></tr></tbody></table><p>        New flags for new BCM CoSQ gport have been added.
 
<a name=BCM_COSQ_GPORT_FLAGS_table></a>
<h3>Table 13:   BCM CoSQ gport flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td>  Flags</td><td> Notes
 </td></tr><tr><td>  <tt>BCM_COSQ_GPORT_SCHEDULER_WFQ</tt></td><td> For scheduler resources
 </td></tr><tr><td>  <tt>BCM_COSQ_GPORT_ADD_COS</tt></td><td></td></tr><tr><td>  <tt>BCM_COSQ_GPORT_CONF_SCOPE_CORE0</tt></td><td></td></tr><tr><td>  <tt>BCM_COSQ_GPORT_CONF_SCOPE_CORE1</tt></td><td></td></tr></tbody></table><p>        A new flag for <tt>bcm_cosq_delay_tolerance_t</tt> has been added.
 
<a name=BCM_COSQ_DELAY_TOLERANCE_flags></a>
<h3>Table 14:   flags supported by the flags field of bcm_cosq_delay_tolerance_t
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Flag</b></td><td><b> Description
 </b></td></tr><tr><td> <tt>BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY</tt>
 </td><td> Specifies if the delay tolerance is low latency (multiple packet dequeue is enabled).
 </td></tr></tbody></table><p>        A new threshold type bcmCosqThresholdDynamicWeight has been added in this release.
 
<a name=BCM_COSQ_GPORT_THRESHOLD_types></a>
<h3>Table 15:   Threshold types
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td>  bcmCosqThresholdDynamicWeight</td><td> Dynamic scheduling threshold.
 </td></tr></tbody></table><p>        Threshold Valid Bitmaps have been defined along with the three new fields of <tt>bcm_cosq_threshold_t</tt>
        and COSQ threshold initialization function.
 
<a name=BCM_COSQ_THRESHOLD_VALID_flags></a>
<h3>Table 16:   Threshold Valid Bitmamp
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td>  <tt>BCM_COSQ_THRESHOLD_VALID_DP</tt></td><td> dp field should be be used
 </td></tr><tr><td>  <tt>BCM_COSQ_THRESHOLD_VALID_VALUE</tt></td><td> value field should be be used
 </td></tr><tr><td>  <tt>BCM_COSQ_THRESHOLD_VALID_TC</tt></td><td> tc field should be be used
 </td></tr><tr><td>  <tt>BCM_COSQ_THRESHOLD_VALID_VSQ_CATEGORY</tt></td><td> vsq category field should be be used
 </td></tr></tbody></table><blockquote><pre>/* flow control / admission settings */
typedef struct <tt>bcm_cosq_threshold_s</tt> {
    uint32 flags;                   /* <tt>BCM_COSQ_THRESHOLD_</tt>* flag values */
    <tt>bcm_color_t</tt> dp;                 /* drop precedence. relevant for
	                             * <tt>BCM_COSQ_THRESHOLD_PER_DP</tt> flag value
                                     */
    <tt>bcm_cosq_threshold_type_t</tt> type; /* threshold type */
    int value;                      /* threshold value for drop/flow control */
    int tc;                         /* traffic class for which the thresholds are
	                             * to be configured
                                     */
    int <tt>vsq_category</tt>;               /* VSQ category for which the thresholds are
	                             * to be configured
                                     */
    uint32 valid;                   /* a bitmap representing enabled fields in
	                               the struct. */
} <tt>bcm_cosq_threshold_t</tt>;
</pre></blockquote><p>        In addition, some other new COSQ APIs have been added.
<p>        Two dynamic scheduling APIs with dynamic weights types have been added in this release
<p><hr noshade>
<h3>APIs for Section 3.4.5:  Class of Service Queue Configuration
</h3>
<a name=bcm_cosq_threshold_t_init></a>
<hr noshade>
<h2 class="api">
<tt>bcm_cosq_threshold_t_init</tt><br>
</h2>

<blockquote>
        Initialize a COSQ threshold structure.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>        #include &lt;bcm/cosq.h&gt;
        void bcm_cosq_threshold_t_init(bcm_cosq_threshold_t *threshold);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>profile</tt></td><td>&nbsp;&nbsp;</td><td>
  Pointer to threshold structure to initialize.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
        Initialize a COSQ threshold structure.
</blockquote><h3>RETURNS</h3><blockquote>
        None.
</blockquote>
<a name=bcm_cosq_gport_handle_core_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_cosq_gport_handle_core_get</tt><br>
</h2>

<blockquote>
 Getting a gport handle
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>        #include &lt;bcm/cosq.h&gt;

        int bcm_cosq_gport_handle_core_get(
            int unit,
            int core,
            bcm_cosq_gport_info_core_t *gport_info,
            bcm_gport_t *out_gport);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>core</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) core number. For all cores use <tt>BCM_CORE_ALL</tt>
 </td></tr>
<tr><td class="arg" valign="top"><tt>gport_info</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) gport info.
  see table  <a href="#BCM_COSQ_GPORT_INFO_CORE_table">Table 17:  <tt>bcm_cosq_gport_info_core_t</tt> information for getting handle per core 
 </a> <tt>in_gport</tt> parameter
                                 is an input parameter
 </td></tr>
<tr><td class="arg" valign="top"><tt>out_gport</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) out gport.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
        Getting a gport handle per core. This could be either a global gport (single
        instance on a device) or converting a gport to the desired type

<a name=BCM_COSQ_GPORT_INFO_CORE_table></a>
<h3>Table 17:   bcm_cosq_gport_info_core_t information for getting handle per core 
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Parameter</b></td><td><b> Description
 </b></td></tr><tr><td>  <tt>gport_type</tt></td><td> the gport type.
 </td></tr><tr><td>  <tt>in_gport</tt></td><td> gport to be converted. <tt>NULL</tt> for global gports (that is single instance on a device)
 </td></tr><tr><td>  cosq</td><td> Num of cosq levels
 </td></tr><tr><td>  flags</td><td> additional flags
 </td></tr></tbody></table></blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_cosq_bst_profile_t_init></a>
<hr noshade>
<h2 class="api">
<tt>bcm_cosq_bst_profile_t_init</tt><br>
</h2>

<blockquote>
        Initialize a CoSQ BST profile structure.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>        #include &lt;bcm/cosq.h&gt;
        void bcm_cosq_bst_profile_t_init(bcm_cosq_bst_profile_t *profile);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>profile</tt></td><td>&nbsp;&nbsp;</td><td>
  Pointer to BST profile configuration structure to initialize.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
        Initialize a CoSQ BST profile structure.
</blockquote><h3>RETURNS</h3><blockquote>
        None.
</blockquote>
<a name=bcm_cosq_bst_stat_get32></a>
<hr noshade>
<h2 class="api">
<tt>bcm_cosq_bst_stat_get32</tt><br>
</h2>

<blockquote>
 Get the current statistic/count of specified BST profile
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>        #include &lt;bcm/cosq.h&gt;
        int bcm_cosq_bst_stat_get32(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq,
                            bcm_bst_stat_id_t bid, uint32 options, uint32 *pvalue);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
     BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 Device or logical port or GPORT ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>cosq</tt></td><td>&nbsp;&nbsp;</td><td>
 Cosq object offset identifier
 </td></tr>
<tr><td class="arg" valign="top"><tt>bid</tt></td><td>&nbsp;&nbsp;</td><td>
 BST stat ID to identify the COSQ resource/object
 </td></tr>
<tr><td class="arg" valign="top"><tt>options</tt></td><td>&nbsp;&nbsp;</td><td>
 options to perform clear-on-read
 </td></tr>
<tr><td class="arg" valign="top"><tt>pvalue</tt></td><td>&nbsp;&nbsp;</td><td>
 stat value to return.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
        Retrieve the BST (buffer statistics tracking) statistic for the
        specified MMU resource. MMU resource is identified by the combination of port, cosq
        and bid parameters. port parameter can be port gport, queue gport. bid parameter
        identifies the MMU resource, for instance the flag bcmBstStatIdEgrPool
        identifies the egress service pool resource. cosq parameter identifies the object
        withing the various instances of resources within the identified resource. if option
        <tt>BCM_COSQ_STAT_CLEAR</tt> is present, a memory/register clear will be performed after stat reading.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_cosq_bst_stat_multi_get32></a>
<hr noshade>
<h2 class="api">
<tt>bcm_cosq_bst_stat_multi_get32</tt><br>
</h2>

<blockquote>
 Get the current statistic/count of multiple specified BST profile
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>        #include &lt;bcm/cosq.h&gt;
        int bcm_cosq_bst_stat_multi_get32(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq,
                            uint32 options, int max_values, bcm_bst_stat_id_t *id_list, uint32 *values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
     BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>gport</tt></td><td>&nbsp;&nbsp;</td><td>
 Device or logical port or GPORT ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>cosq</tt></td><td>&nbsp;&nbsp;</td><td>
 Cosq object offset identifier
 </td></tr>
<tr><td class="arg" valign="top"><tt>options</tt></td><td>&nbsp;&nbsp;</td><td>
 options to perform clear-on-read
 </td></tr>
<tr><td class="arg" valign="top"><tt>max_values</tt></td><td>&nbsp;&nbsp;</td><td>
 Number of elements in <tt>id_list</tt> and pvalue
 </td></tr>
<tr><td class="arg" valign="top"><tt>id_list</tt></td><td>&nbsp;&nbsp;</td><td>
 Array of BST stat ID list to identify the COSQ resource/object
 </td></tr>
<tr><td class="arg" valign="top"><tt>pvalue</tt></td><td>&nbsp;&nbsp;</td><td>
 Array of stat value to return.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
        Retrieve the BST (buffer statistics tracking) statistic for multiple
        specified MMU resource. MMU resource is identified by the combination of port, cosq
        and bid parameters. port parameter can be port gport, queue gport. bid parameter
        identifies the MMU resource, for instance the flag bcmBstStatIdEgrPool
        identifies the egress service pool resource. cosq parameter identifies the object
        withing the various instances of resources within the identified resource. if option
        <tt>BCM_COSQ_STAT_CLEAR</tt> is present, a memory/register clear will be performed after stat reading.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_cosq_service_pool_set></a>
<a name=bcm_cosq_service_pool_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_cosq_service_pool_set</tt><br>
<tt>bcm_cosq_service_pool_get</tt><br>
</h2>

<blockquote>
        To set/get enable or disable status of service pool for a given pool id
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>        #include &lt;bcm/cosq.h&gt;
        int bcm_cosq_service_pool_set(
            int unit,
            bcm_service_pool_id_t id,
            bcm_cosq_service_pool_t cosq_service_pool);
        int bcm_cosq_service_pool_get(
            int unit,
            bcm_service_pool_id_t id,
            bcm_cosq_service_pool_t *cosq_service_pool);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
                  (IN) BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Service pool id
 </td></tr>
<tr><td class="arg" valign="top"><tt>cosq_service_pool</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) (for "<tt>_set</tt>") Enable/Disable given type service pool
 </td></tr>
<tr><td class="arg" valign="top"><tt>cosq_service_pool</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) (for "<tt>_get</tt>") Get enable or disable status on given
                                                type service pool
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
        To set/get enable or disable status on service pool on the specified pool id.
<blockquote><pre>typedef struct <tt>bcm_cosq_service_pool_s</tt> {
    <tt>bcm_cosq_service_pool_type_t</tt> type;  /* Service pool type. */
    int enabled;                        /* Enable or disable. */
} <tt>bcm_cosq_service_pool_t</tt>;
</pre></blockquote>
<a name=bcm_cosq_service_pool_type_t></a>
<h3>Table 18:   bcm_cosq_service_pool_type_t Service pool types
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Parameter</b></td><td><b> Description
 </b></td></tr><tr><td>  bcmCosqServicePoolPortColorAware</td><td> Port service pool level color aware
 </td></tr><tr><td>  bcmCosqServicePoolColorAware</td><td> Pool level color aware
 </td></tr><tr><td>  bcmCosqServicePoolQueueCongestionAware</td><td> Pool level queue congeston status aware
 </td></tr></tbody></table></blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_cosq_gport_reattach></a>
<hr noshade>
<h2 class="api">
<tt>bcm_cosq_gport_reattach</tt><br>
</h2>

<blockquote>
 Reattach the output of a GPORT to the input of a scheduler GPORT.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>        #include &lt;bcm/cosq.h&gt;
        int bcm_cosq_gport_reattach(int unit, bcm_gport_t sched_port,
                          bcm_gport_t input_port, bcm_cos_queue_t cosq);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
           (IN) BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>sched_port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Scheduler GPORT ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>input_port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) GPORT ID that will attach to scheduler gport
 </td></tr>
<tr><td class="arg" valign="top"><tt>cosq</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) CoS queue to attach to
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
        This API can be used to reattach the output of a GPORT to the 
        input of a scheduler GPORT to form a queuing hierarchy. The connect is
        done at the specified CoS queue of the Scheduler GPORT. A <tt>cosq</tt> value
        of -1 will attach the input GPORT to the first unused CoS queue of the
        Scheduler GPORT (going from higher to lower CoS queue priority).
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_cosq_profile_mapping_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_cosq_profile_mapping_set</tt><br>
</h2>

<blockquote>
 Maps a gport to a profile
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>        #include &lt;bcm/cosq.h&gt;
        int bcm_cosq_profile_mapping_set(
            int unit, 
            bcm_gport_t gport_to_map,
            bcm_cos_queue_t cosq,
            uint32 flags,
            bcm_switch_profile_mapping_t* profile_mapping);
        int bcm_cosq_profile_mapping_get(
            int unit, 
            bcm_gport_t gport_to_map,
            bcm_cos_queue_t cosq,
            uint32 flags,
            bcm_switch_profile_mapping_t* profile_mapping);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
             (IN) BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>gport_to_map</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Gport to map
 </td></tr>
<tr><td class="arg" valign="top"><tt>cosq</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) CoS queue to attach to
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Flags
 </td></tr>
<tr><td class="arg" valign="top"><tt>profile_mapping</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) (for "<tt>_set</tt>") Map gport into profile
 </td></tr>
<tr><td class="arg" valign="top"><tt>profile_mapping</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) (for "<tt>_get</tt>") The profile that the gport is mapped into
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
        Mapping of a gport to a profile.
        Where <tt>gport_to_map</tt> is a handle of some object in the CosQ pipe 
        that is being profiled be an entity defined by <tt>profile_mapping</tt>-&gt;<tt>mapped_profile</tt>.
<blockquote><pre>/* profile mapping type. */
typedef enum <tt>bcm_switch_profile_mapping_type_e</tt> {
    bcmbcmCosqIngressQueueToRateClass = 0 /* ingress queue to rate class
                                           * mapping
                                           */
} <tt>bcm_switch_profile_mapping_type_t</tt>;

/* profile mapping struct. */
typedef struct <tt>bcm_switch_profile_mapping_s</tt> {
    /* The type of profile to be mapped to. */
    <tt>bcm_switch_profile_mapping_type_t</tt> <tt>profile_type</tt>;
    <tt>bcm_gport_t</tt> <tt>mapped_profile</tt>;            /* mapped profile handle */
} <tt>bcm_switch_profile_mapping_t</tt>;
</pre></blockquote></blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_cosq_gport_dynamic_sched_set></a>
<a name=bcm_cosq_gport_dynamic_sched_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_cosq_gport_dynamic_sched_set</tt><br>
<tt>bcm_cosq_gport_dynamic_sched_get</tt><br>
</h2>

<blockquote>
	set/get weights dynamic or regular weights
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/cosq.h&gt;
	bcm_cosq_gport_dynamic_sched_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, 
					 bcm_cosq_dynamic_state_t state, int weight);

	#include &lt;bcm/cosq.h&gt;
	bcm_cosq_gport_dynamic_sched_get(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, 
					 bcm_cosq_dynamic_state_t state, int *weight); 
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
	        BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>gport</tt></td><td>&nbsp;&nbsp;</td><td>
  gport type, see table  <a href="#BCM_COSQ_GPORT_type">Table 12:  gport types
 </a>  </td></tr>
<tr><td class="arg" valign="top"><tt>cosq</tt></td><td>&nbsp;&nbsp;</td><td>
 cosq num
 </td></tr>
<tr><td class="arg" valign="top"><tt>state</tt></td><td>&nbsp;&nbsp;</td><td>
 type of weight to set set according to congestion state
  (see table  <a href="#BCM_COSQ_DYNAMIC_STATE_type">Table 19:  dynamic weights types
 </a> ) 
 </td></tr>
<tr><td class="arg" valign="top"><tt>weigth</tt></td><td>&nbsp;&nbsp;</td><td>
 corresponding weight.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	get/set dynamic weights. The type of the weight is determined by "state" 

<a name=BCM_COSQ_DYNAMIC_STATE_type></a>
<h3>Table 19:   dynamic weights types
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td>  bcmCosqDynamicStateNormal</td><td> regular state
 </td></tr><tr><td>  bcmCosqDynamicStateQueue0Congested</td><td> pipe 0 is congested, pipe 1 not congested
 </td></tr><tr><td>  bcmCosqDynamicStateQueue1Congested</td><td> pipe 1 is congested, pipe 0 not congested
 </td></tr></tbody></table></blockquote><a name=bcm_cosq_gport_stat_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_cosq_gport_stat_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve statistics.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/cosq.h&gt;
	int 
	bcm_cosq_gport_stat_sync_get(int unit, bcm_gport_t gport, 
				     bcm_cos_queue_t cosq, 
				     bcm_cosq_gport_stats_t stat, 
				     uint64 *value);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>gport</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) GPORT ID for a queue group
 </td></tr>
<tr><td class="arg" valign="top"><tt>cosq</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) CoS Queue
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) statistic to be retrieved.
 </td></tr>
<tr><td class="arg" valign="top"><tt>value</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) (for "<tt>_get</tt>") statistic value
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_cosq_gport_stat_get</tt>(), value returned is software accumulated 
	counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<br><hr noshade><a name="extender"></a>
<h3>Section 3.4.6:   Port Extension Management
</h3>
<p>        A new <tt>qos_map_id</tt> filed of <tt>bcm_extender_port_t</tt> has been introduced for the egress etag mapping.
        The <tt>bcm_extender_port_t</tt> structure describes a Port Extender port logically attached to
        a Controlling Bridge.
 <blockquote><pre>typedef struct <tt>bcm_extender_port_s</tt> {
    ...
    int <tt>qos_map_id</tt>;    /* Qos map id for egress etag mapping profile. */
    ...
} <tt>bcm_extender_port_t</tt>;
</pre></blockquote><p><br><hr noshade><a name="fabric"></a>
<h3>Section 3.4.7:   Fabric
</h3>
<p>        A new fabric control type bcmFabricForceTdmBypassTrafficToFabric has been added
        for <tt>bcm_fabric_control_get</tt>/set() functions.
 
<a name=bcm_fabrics></a>
<h3>Table 20:   Fabric Type Values
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Value</b></td><td><b>  Description</b></td><td><b> Arg Value
 </b></td></tr><tr><td> bcmFabricForceTdmBypassTrafficToFabric
 </td><td> Enable/Disable Forcing of TDM bypass traffic to fabric
 </td><td><tt>1/0</tt></td></tr></tbody></table><p>        A new fabric link control type has been added for <tt>bcm_fabric_link_control_set</tt>() and
        <tt>bcm_fabric_link_control_get</tt>() APIs.

<a name=bcm_fabric_link_control_t></a>
<h3>Table 21:   bcm_fabric_link_control_t
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> Control Type
 </b></td><td><b> Description
 </b></td><td><b> Arg Expected Values
 </b></td></tr><tr><td> bcmFabricLinkPcpEnable
 </td><td> Enable/Disable Packet Cell Packing
 </td><td> 1: the remote device support PCP 0: otherwise
 </td></tr></tbody></table><p>        Several fabric link threshold control types have been added for <tt>bcm_fabric_link_thresholds_get</tt>/set
        functions.

<a name=bcm_fabric_link_threshold_type_t></a>
<h3>Table 22:   bcm_fabric_link_threshold_type_t
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> enum
 </b></td><td><b> Description
 </b></td></tr><tr><td> bcmFabricLinkRxRciLvl1FC
 </td><td> The RX FIFO threshold that initiates the Route Congestion Indication level 1 flow control
 </td></tr><tr><td> bcmFabricLinkRxRciLvl2FC
 </td><td> The RX FIFO threshold that initiates the Route Congestion Indication level 2 flow control
 </td></tr><tr><td> bcmFabricLinkRxRciLvl3FC
 </td><td> The RX FIFO threshold that initiates the Route Congestion Indication level 3 flow control
 </td></tr><tr><td> bcmFabricLinkRxFull
 </td><td> Configure threshold for max fifo size, beyond this threshold, packets will be dropped.
 </td></tr><tr><td> bcmFabricLinkRxFifoSize
 </td><td> Configure the FIFO size, this is a static configuration.
 </td></tr><tr><td> bcmFabricLinkRxMcLowPrioDrop
 </td><td> Configure the multicast low priority cells drop thresholds.
 </td></tr><tr><td> bcmFabricLinkMidGciLvl1FC
 </td><td> Configure the Mid GCI threshold for level 1 flow control.
 </td></tr><tr><td> bcmFabricLinkMidGciLvl2FC
 </td><td> Configure the Mid GCI threshold for level 2 flow control.
 </td></tr><tr><td> bcmFabricLinkMidGciLvl3FC
 </td><td> Configure the Mid GCI threshold for level 3 flow control.
 </td></tr><tr><td> bcmFabricLinkMidRciLvl1FC
 </td><td> Configure the Mid RCI threshold for level 1 flow control.
 </td></tr><tr><td> bcmFabricLinkMidRciLvl2FC
 </td><td> Configure the Mid RCI threshold for level 2 flow control.
 </td></tr><tr><td> bcmFabricLinkMidRciLvl3FC
 </td><td> Configure the Mid RCI threshold for level 3 flow control.
 </td></tr><tr><td> bcmFabricLinkMidPrio0Drop
 </td><td> Configure the maximum threshold for DCM priorty 0 drops, above this threshold the dcm will drop cells recieved from DCH.
 </td></tr><tr><td> bcmFabricLinkMidPrio1Drop
 </td><td> Configure the maximum threshold for DCM priorty 1 drops, above this threshold the dcm will drop cells recieved from DCH.
 </td></tr><tr><td> bcmFabricLinkMidPrio2Drop
 </td><td> Configure the maximum threshold for DCM priorty 2 drops, above this threshold the dcm will drop cells recieved from DCH.
 </td></tr><tr><td> bcmFabricLinkMidPrio3Drop
 </td><td> Configure the maximum threshold for DCM priorty 3 drops, above this threshold the dcm will drop cells recieved from DCH.
 </td></tr><tr><td> bcmFabricLinkMidAlmostFull
 </td><td> Configure threshold for almost full, beyond this threshold, flow control will be sent back to the DCH.
 </td></tr><tr><td> bcmFabricLinkMidFifoSize
 </td><td> Configure the FIFO depth (size).
 </td></tr><tr><td> bcmFabricLinkTxRciLvl1FC
 </td><td> The TX FIFO threshold that initiates the Route Congestion Indication level 1 Flow Control
 </td></tr><tr><td> bcmFabricLinkTxRciLvl2FC
 </td><td> The TX FIFO threshold that initiates the Route Congestion Indication level 2 Flow Control
 </td></tr><tr><td> bcmFabricLinkTxRciLvl3FC
 </td><td> The TX FIFO threshold that initiates the Route Congestion Indication level 3 Flow Control
 </td></tr><tr><td> bcmFabricLinkTxAlmostFull
 </td><td> Configure threshold for almost full, beyond this threshold, flow control will be sent back to the DCM.
 </td></tr><tr><td> bcmFabricLinkTxFifoSize
 </td><td> Configure DCL FIFO depth (size).
</td></tr></tbody></table><p>        The new functions to get/set the <tt>fifo_type</tt> thresholds per pipe have been added
        as well as three fabric route functions have been added with required data structure.
<p>        Fabric Pipe Mapping has been introduced with the required data types in this release.
<p>        New APIs of PCP mode config get and set functions for PCP mode per VOQ/destination device are added
        with the data types.
<p><hr noshade>
<h3>APIs for Section 3.4.7:  Fabric
</h3>
<a name=bcm_fabric_link_thresholds_pipe_set></a>
<a name=bcm_fabric_link_thresholds_pipe_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_fabric_link_thresholds_pipe_set</tt><br>
<tt>bcm_fabric_link_thresholds_pipe_get</tt><br>
</h2>

<blockquote>
        Set\Get <tt>fifo_type</tt> thresholds per pipe
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>        #include &lt;bcm/fabric.h&gt;
        int
        bcm_fabric_link_thresholds_pipe_set(
            int unit,
            int fifo_type,
            bcm_fabric_pipe_t pipe,
            uint32 flags,
            uint32 count,
            bcm_fabric_link_threshold_type_t *type,
            int *value)

        int
        bcm_fabric_link_thresholds_pipe_get(
            int unit,
            int fifo_type,
            bcm_fabric_pipe_t pipe,
            uint32 flags,
            uint32 count,
            bcm_fabric_link_threshold_type_t *type,
            int *value)
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN)  Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>fifo_type</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) <tt>fifo_type</tt> you would like to update (0 or 1)
 </td></tr>
<tr><td class="arg" valign="top"><tt>pipe</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) which pipe you would like to update
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) relevant flags: (<tt>BCM_FABRIC_LINK_TH_FE1_LINKS_ONLY</tt>/<tt>BCM_FABRIC_LINK_TH_FE3_LINKS_ONLY</tt>/none)
 </td></tr>
<tr><td class="arg" valign="top"><tt>count</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Size of the array
 </td></tr>
<tr><td class="arg" valign="top"><tt>type</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Array of <tt>bcm_fabric_link_threshold_type_t</tt> to get or set
 </td></tr>
<tr><td class="arg" valign="top"><tt>value</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) (for "<tt>_set</tt>") value[i] is the threshold to be assigned with type[i]
 </td></tr>
<tr><td class="arg" valign="top"><tt>value</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) (for "<tt>_get</tt>") value[i] is the threshold assigned with type[i]
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
  For <tt>fifo_type</tt> 0 or 1 , set the relevant set of thresholds. See  <a href="#bcm_fabric_link_threshold_type_t">Table 22:  <tt>bcm_fabric_link_threshold_type_t</tt>
 </a> <br>
        Use a relevant pipe with:
        <br>
<a name=bcm_fabric_pipe_t></a>
<h3>Table 23:   bcm_fabric_pipe_t
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> enum
 </b></td><td><b> Description
 </b></td></tr><tr><td> bcmFabricPipe0
 </td><td> Pipe 0
 </td></tr><tr><td> bcmFabricPipe1
 </td><td> Pipe 1
 </td></tr><tr><td> bcmFabricPipe2
 </td><td> Pipe 2
 </td></tr><tr><td> bcmFabricPipeAll
 </td><td> All pipes
 </td></tr></tbody></table></blockquote><h3>RETURNS</h3><blockquote>
        BCM_E_xxx
</blockquote>
<a name=bcm_fabric_route_t_init></a>
<hr noshade>
<h2 class="api">
<tt>bcm_fabric_route_t_init</tt><br>
</h2>

<blockquote>
        Initialize a <tt>bcm_fabric_route_t</tt> to a 'safe' default value.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>        #include &lt;bcm/fabric.h&gt;

        void
        bcm_fabric_route_t_init(bcm_fabric_route_t *fabric_route)
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>fabric_route</tt></td><td>&nbsp;&nbsp;</td><td>
    (OUT) Pointer to information struct to initialize
<blockquote><pre>typedef struct <tt>bcm_fabric_route_s</tt> {
    uint32 <tt>pipe_id</tt>;     /* Origin fabric pipe */
    int <tt>number_of_hops</tt>; /* corresponds to the number of routing
                         * hops (number traversed links) */
    int *<tt>hop_ids</tt>;       /* traversed links */
} <tt>bcm_fabric_route_t</tt>;
</pre></blockquote></td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
        Sets a 'safe' default state for a <tt>bcm_fabric_route_t</tt>.
</blockquote><h3>RETURNS</h3><blockquote>
            None.
</blockquote>
<a name=bcm_fabric_route_tx></a>
<hr noshade>
<h2 class="api">
<tt>bcm_fabric_route_tx</tt><br>
</h2>

<blockquote>
        Send fabric route cells
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>        #include &lt;bcm/fabric.h&gt;
        int
        bcm_fabric_route_tx(int unit,
                            uint32 flags,
                            bcm_fabric_route_t *route,
                            uint32 data_in_size,
                            uint32 *data_in)
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) flags
 </td></tr>
<tr><td class="arg" valign="top"><tt>route</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Specify the path for the route cells.
 </td></tr>
<tr><td class="arg" valign="top"><tt>data_in_size</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) "<tt>data_in</tt>" size (uint32 units)
 </td></tr>
<tr><td class="arg" valign="top"><tt>data_in</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) The data to send.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
        Fabric route cells, generated by CPU, can be transmitted and received (over fabric interface).
        These cells are routed according to the specific path information they carry.
        These messages are used mainly for debug and diagnostics purposes, but can be also used for CPU-to-CPU messaging.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_fabric_route_rx></a>
<hr noshade>
<h2 class="api">
<tt>bcm_fabric_route_rx</tt><br>
</h2>

<blockquote>
        Receive fabric route cells
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>        #include &lt;bcm/fabric.h&gt;

        int
        bcm_fabric_route_rx(int unit,
                            uint32 flags,
                            uint32 data_out_max_size,
                            uint32 *data_out,
                            uint32 *data_out_size)
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
                (IN) Unit number
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) flags
 </td></tr>
<tr><td class="arg" valign="top"><tt>data_out_max_size</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) max "<tt>data_out</tt>" size (uint32 units)
 </td></tr>
<tr><td class="arg" valign="top"><tt>data_out</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) the received data
 </td></tr>
<tr><td class="arg" valign="top"><tt>data_out_size</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) "<tt>data_out</tt>" actual size (uint32 units)
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
        Fabric route cells, generated by CPU, can be transmitted and received (over fabric interface).
        These cells are routed according to the specific path information they carry.
        These messages are used mainly for debug and diagnostics purposes, but can be also used for CPU-to-CPU messaging.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_fabric_link_remote_pipe_mapping_set></a>
<a name=bcm_fabric_link_remote_pipe_mapping_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_fabric_link_remote_pipe_mapping_set</tt><br>
<tt>bcm_fabric_link_remote_pipe_mapping_get</tt><br>
</h2>

<blockquote>
	Set/get per link the mapping between the local pipe to the remote pipe.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/fabric.h&gt;
	int bcm_fabric_link_remote_pipe_mapping_set(
	    int unit, 
	    bcm_port_t port, 
	    bcm_fabric_link_remote_pipe_mapping_t *mapping_config);

	int bcm_fabric_link_remote_pipe_mapping_get(
	    int unit, 
	    bcm_port_t port, 
	    bcm_fabric_link_remote_pipe_mapping_t *mapping_config);
<blockquote><pre>typedef struct bcm_fabric_link_remote_pipe_mapping_s {
    uint32 num_of_remote_pipes;    /* Number of pipes supported by the
				    * remote device */
    bcm_fabric_pipe_t remote_pipe_mapping;
                                   /* The mapping from remote pipe
				    * (represented by the index) to the
				    * local pipe (represented by the value
				    * stored in this index)
                                    */
    uint32 remote_pipe_mapping_max_size;
                                   /* Max size of remote_pipe_mapping */
} bcm_fabric_link_remote_pipe_mapping_t;
</pre></blockquote></pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
               (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Port number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>mapping_config</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Specify\reterive the mapping between the remote pipe to local pipe
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set/get per link the mapping between the local pipe to the remote pipe.
	Should be used in a case the remote pipe configuration is a sub set of local pipe configuration.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_fabric_link_remote_pipe_mapping_t_init></a>
<hr noshade>
<h2 class="api">
<tt>bcm_fabric_link_remote_pipe_mapping_t_init</tt><br>
</h2>

<blockquote>
	Initialize a <tt>bcm_fabric_link_remote_pipe_mapping_t</tt> to a 'safe' default value.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/fabric.h&gt;

	void
	bcm_fabric_link_remote_pipe_mapping_t_init(bcm_fabric_link_remote_pipe_mapping_t *pipe_mapping)
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>pipe_mapping</tt></td><td>&nbsp;&nbsp;</td><td>
    (OUT) Pointer to information struct to initialize
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Initialize a <tt>bcm_fabric_link_remote_pipe_mapping_t</tt> to a 'safe' default value.
</blockquote><h3>RETURNS</h3><blockquote>
	void
</blockquote>
<a name=bcm_fabric_pcp_dest_mode_config_set></a>
<a name=bcm_fabric_pcp_dest_mode_config_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_fabric_pcp_dest_mode_config_set</tt><br>
<tt>bcm_fabric_pcp_dest_mode_config_get</tt><br>
</h2>

<blockquote>
	Set/Get PCP mode per VOQ/destination device.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/fabric.h&gt;

	int 
	bcm_fabric_pcp_dest_mode_config_set(
	    int unit, 
	    uint32 flags, 
	    bcm_module_t modid, 
	    bcm_fabric_pcp_mode_config_t *pcp_config)

	int 
	bcm_fabric_pcp_dest_mode_config_get(
	    int unit, 
	    uint32 flags, 
	    bcm_module_t modid, 
	    bcm_fabric_pcp_mode_config_t *pcp_config)

	use this struct in order to configure which fabric_pcp mode 
	is used for a certain destination device. 
 <blockquote><pre>/* Fabric pcp mode configuration */
typedef struct bcm_fabric_pcp_mode_config_s {
    bcm_fabric_pcp_mode_t pcp_mode; /* Mode of Packet Cell Packing (PCP) */
} bcm_fabric_pcp_mode_config_t;
</pre></blockquote>
<a name=bcm_fabric_pcp_mode></a>
<h3>Table 24:   Packet Cell Packing (pcp) mode
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Field-Name</b></td><td><b> Value
 </b></td></tr><tr><td>  bcmFabricPcpModeNoPacking</td><td> 0
 </td></tr><tr><td>  bcmFabricPcpModeSimple</td><td> 1
 </td></tr><tr><td>  bcmFabricPcpModeContinuous</td><td> 2
 </td></tr></tbody></table></pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
 			(IN) Unit number
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Additional flags
 </td></tr>
<tr><td class="arg" valign="top"><tt>modid</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Id of destination device
 </td></tr>
<tr><td class="arg" valign="top"><tt>pcp_config</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN/OUT) Pointer to configuration struct which the fabric-PCP mode is set from/ reterived to.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set/Get the Packet Cell Packing mode for a specific destination device.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<br><hr noshade><a name="failover"></a>
<h3>Section 3.4.8:   Forwarding Failover Protection
</h3>
<p>        Below new Failover Create flags are added in this release.
<h3>Table 25:   Failover Create Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  FLAG</b></td><td><b> Meaning
 </b></td></tr><tr><td>  <tt>BCM_FAILOVER_PAIRED</tt></td><td> flag to allocate a pair of adjoining failover objects
 </td></tr><tr><td>  <tt>BCM_FAILOVER_FEC</tt></td><td> flag to create a FEC failover object for 1:1 UC Protection
 </td></tr><tr><td>  <tt>BCM_FAILOVER_INGRESS</tt></td><td> flag to create an Ingress failover object for 1+1 Protection
 </td></tr><tr><td>  <tt>BCM_FAILOVER_ENCAP</tt></td><td> flag to create an encapsulation failover object for 1:1 MC Protection
 </td></tr></tbody></table><p><br><hr noshade><a name="fcmap"></a>
<h3>Section 3.4.9:   FCMAP API
</h3>
<p>        New APIs <tt>bcm_fcmap_linkfault_trigger_rc_get</tt>() and <tt>bcm_fcmap_diag_get</tt>() have been added
        with the associated data structures.
<p><hr noshade>
<h3>APIs for Section 3.4.9:  FCMAP API
</h3>
<a name=bcm_fcmap_linkfault_trigger_rc_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_fcmap_linkfault_trigger_rc_get</tt><br>
</h2>

<blockquote>
       Returns the linkfault trigger code and reason code from the specified FC port.
 </blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>       #include &lt;bcm/fcmap.h&gt;

       int bcm_fcmap_linkfault_trigger_rc_get(int unit,
					      bcm_port_t port,
					      bcm_fcmap_lf_tr_t *trigger,
					      bcm_fcmap_lf_rc_t *rc);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) BCM unit
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Port identifier
 </td></tr>
<tr><td class="arg" valign="top"><tt>trigger</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to the to be returned linfault trigger code
 </td></tr>
<tr><td class="arg" valign="top"><tt>rc</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to the to be returned linkfault reason code
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
       This API returns the linkfault trigger code and reason code from the specified FC port.
<blockquote><pre>/* link fault trigger. */
#define <tt>BCM_FCMAP_LF_TR_NONE</tt>                        0x0
#define <tt>BCM_FCMAP_LF_TR_PORT_INIT</tt>                   0x1
#define <tt>BCM_FCMAP_LF_TR_OPEN_LINK</tt>                   0x2
#define <tt>BCM_FCMAP_LF_TR_LINK_FAILURE</tt>                0x3
#define <tt>BCM_FCMAP_LF_TR_OLS_RCVD</tt>                    0x4
#define <tt>BCM_FCMAP_LF_TR_NOS_RCVD</tt>                    0x5
#define <tt>BCM_FCMAP_LF_TR_SYNC_LOSS</tt>                   0x6
#define <tt>BCM_FCMAP_LF_TR_BOUCELINK_FROM_ADMIN</tt>        0x7
#define <tt>BCM_FCMAP_LF_TR_CHGSPEED_FROM_ADMIN</tt>         0x8
#define <tt>BCM_FCMAP_LF_TR_DISABLE_FROM_ADMIN</tt>          0x9
#define <tt>BCM_FCMAP_LF_TR_RESET_FROM_ADMIN</tt>            0xA
#define <tt>BCM_FCMAP_LF_TR_LR_RCVD</tt>                     0xB
#define <tt>BCM_FCMAP_LF_TR_LRR_RCVD</tt>                    0xC
#define <tt>BCM_FCMAP_LF_TR_ED_TOV</tt>                      0xD

/* link fault reason code. */
#define <tt>BCM_FCMAP_LF_RC_NONE</tt>                       0x0
#define <tt>BCM_FCMAP_LF_RC_PORT_INIT</tt>                  0x1
#define <tt>BCM_FCMAP_LF_RC_OPEN_LINK</tt>                  0x2
#define <tt>BCM_FCMAP_LF_RC_LINK_FAILURE</tt>               0x3
#define <tt>BCM_FCMAP_LF_RC_OLS_RCVD</tt>                   0x4
#define <tt>BCM_FCMAP_LF_RC_NOS_RCVD</tt>                   0x5
#define <tt>BCM_FCMAP_LF_RC_SYNC_LOSS</tt>                  0x6
#define <tt>BCM_FCMAP_LF_RC_BOUCELINK_FROM_ADMIN</tt>       0x7
#define <tt>BCM_FCMAP_LF_RC_CHGSPEED_FROM_ADMIN</tt>        0x8
#define <tt>BCM_FCMAP_LF_RC_DISABLE_FROM_ADMIN</tt>         0x9
#define <tt>BCM_FCMAP_LF_RC_RESET_FAILURE</tt>              0xA
</pre></blockquote></blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
        <tt>bcm_error_t</tt> type
</td></tr>
</table></blockquote>
<a name=bcm_fcmap_diag_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_fcmap_diag_get</tt><br>
</h2>

<blockquote>
       Returns the current diagnostic code from the specified FC port.
 </blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>       #include &lt;bcm/fcmap.h&gt;

       int bcm_fcmap_diag_get(int unit, bcm_port_t port,
			      bcm_fcmap_diag_code_t *diag);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) BCM unit
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Port identifier
 </td></tr>
<tr><td class="arg" valign="top"><tt>diag</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to the to be returned diagnostic code
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
       This API returns the current diagnostic code from the specified FC port. The
       diagnostic code is returned in the user-supplied diag variable.
<blockquote><pre>#define <tt>BCM_FCMAP_DIAG_OK</tt>                                0x0
#define <tt>BCM_FCMAP_PORT_INIT</tt>                              0x1
#define <tt>BCM_FCMAP_OPEN_LINK</tt>                              0x2
#define <tt>BCM_FCMAP_LINK_FAILURE</tt>                           0x3
#define <tt>BCM_FCMAP_OLS_RCVD</tt>                               0x4
#define <tt>BCM_FCMAP_NOS_RCVD</tt>                               0x5
#define <tt>BCM_FCMAP_SYNC_LOSS</tt>                              0x6
#define <tt>BCM_FCMAP_BOUCELINK_FROM_ADMIN</tt>                   0x7
#define <tt>BCM_FCMAP_CHGSPEED_FROM_ADMIN</tt>                    0x8
#define <tt>BCM_FCMAP_DISABLE_FROM_ADMIN</tt>                     0x9
#define <tt>BCM_FCMAP_AN_NO_SIGNAL</tt>                           0xA
#define <tt>BCM_FCMAP_AN_TIMEOUT</tt>                             0xB
#define <tt>BCM_FCMAP_PROTO_TIMEOUT</tt>                          0xC
</pre></blockquote></blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
        <tt>bcm_error_t</tt> type
</td></tr>
</table></blockquote>
<br><hr noshade><a name="fcoe"></a>
<h3>Section 3.4.10:   Fiber Channel Over Ethernet
</h3>
<p>        New APIs <tt>bcm_fcoe_vsan_stat_counter_sync_get</tt>() and <tt>bcm_fcoe_route_stat_counter_sync_get</tt>()
        have been added.
<p><hr noshade>
<h3>APIs for Section 3.4.10:  Fiber Channel Over Ethernet
</h3>
<a name=bcm_fcoe_vsan_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_fcoe_vsan_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve flex counter 
	value for FCOE VSAN ID.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/fcoe.h&gt; 
	int
	bcm_fcoe_vsan_stat_counter_sync_get(int                  unit,
					    bcm_fcoe_vsan_id_t   vsan,
					    bcm_fcoe_vsan_stat_t stat,
					    uint32               num_entries,
					    uint32               *counter_indexes,
					    bcm_stat_value_t     *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
             BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>vsan</tt></td><td>&nbsp;&nbsp;</td><td>
 VSAN ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 packet or byte count selector
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 number of entries to get
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 pointer to indexes
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 pointer to return value structures
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_fcoe_vsan_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_fcoe_route_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_fcoe_route_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve flex counter 
	value for FCOE route.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/fcoe.h&gt; 
	int
	bcm_fcoe_route_stat_counter_sync_get(int                   unit,
					     bcm_fcoe_route_t      *route,
					     bcm_fcoe_route_stat_t stat,
					     uint32                num_entries,
					     uint32                *counter_indexes,
					     bcm_stat_value_t      *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
             BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>route</tt></td><td>&nbsp;&nbsp;</td><td>
 FCOE route
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 packet or byte count selector
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 number of entries to get
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 pointer to indexes
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 pointer to return value structures
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_fcoe_route_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<br><hr noshade><a name="field"></a>
<h3>Section 3.4.11:   Field Processor
</h3>
<p>        Several flags regarding packet content (data) qualification have been added along with the new
        field flags in <tt>bcm_field_data_packet_format_t</tt>.

<a name=Flags></a>
<h3>Table 26:   New flags of packet content (data) qualification
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Misc Flags</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_FIELD_DATA_FORMAT_F_NO_ENCAP_STACK</tt></td><td> Indicates incoming packet is not a Higig Packet.
 </td></tr><tr><td>  <tt>BCM_FIELD_DATA_FORMAT_F_VNTAG</tt></td><td> Indicates incoming packet is a Vntag Packet.
 </td></tr><tr><td>  <tt>BCM_FIELD_DATA_FORMAT_F_NO_VNTAG</tt></td><td> Indicates incoming packet is not a Vntag Packet.
 </td></tr><tr><td>  <tt>BCM_FIELD_DATA_FORMAT_F_CNTAG</tt></td><td> Indicates incoming packet is a Ctag Packet.
 </td></tr><tr><td>  <tt>BCM_FIELD_DATA_FORMAT_F_NO_CNTAG</tt></td><td> Indicates incoming packet is not a Ctag Packet.
 </td></tr><tr><td>  <tt>BCM_FIELD_DATA_FORMAT_F_ETAG</tt></td><td> Indicates incoming packet is a Etag Packet.
 </td></tr><tr><td>  <tt>BCM_FIELD_DATA_FORMAT_F_NO_ETAG</tt></td><td> Indicates incoming packet is not a Etag Packet.
 </td></tr><tr><td>  <tt>BCM_FIELD_DATA_FORMAT_F_ICNM</tt></td><td> Indicates incoming packet is a Icnm Packet.
 </td></tr><tr><td>  <tt>BCM_FIELD_DATA_FORMAT_F_NO_ICNM</tt></td><td> Indicates incoming packet is not a Icnm Packet.
 </td></tr></tbody></table><blockquote><pre>/* Packet format based DATA qualifier specification structure. */
typedef struct <tt>bcm_field_data_packet_format_s</tt> {
   ...
   uint32 flags;            /* Flags. (<tt>FIELD_DATA_FORMAT_F_XXX</tt>) */
} <tt>bcm_field_data_packet_format_t</tt>;
</pre></blockquote><p>       New BCM Field Qualifier has been added while the flag bcmFieldQualifySrcGport of
       <tt>bcm_field_qualify_t</tt> is now applied for NiV port.

<a name=bcm_field_qualify_t></a>
 
<a name=fp_qualifiers_table></a>
<h3>Table 27:   Field Qualifiers
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> Qualifier
 </b></td><td><b> Purpose
</b></td></tr><tr><td> bcmFieldQualifySrcNivGport
 </td><td> Source Niv gport.
 </td></tr><tr><td> bcmFieldQualifyDstNivGport
 </td><td> Destination Niv gport.
 </td></tr><tr><td> bcmFieldQualifyDstGport
 </td><td> Destination module/port gport or MPLS/MiM/WLAN/Niv gport.
 </td></tr><tr><td> bcmFieldQualifyMirrorEgressDisabled
 </td><td> Egress Mirroring disabled.
 </td></tr><tr><td> bcmFieldQualifyBypassSrcMacFilter
 </td><td> Qualify packets bypassing Source MAC Address filtering.
 </td></tr><tr><td> bcmFieldQualifyRxTrapCodeForSnoop
 </td><td> Rx Trap code ID used for snoop.
 </td></tr><tr><td> bcmFieldQualifyIpmcStarGroupValue
 </td><td> L3 Multicast lookup (Star,Group) Value.
 </td></tr><tr><td> bcmFieldQualifyNativeVSwitch
 </td><td> Native-VSwitch (for Routing-over-overlay packets).
 </td></tr><tr><td> bcmFieldQualifyNativeVSwitchValid
 </td><td> Valid native-VSwitch (for Routing-over-overlay packets).
 </td></tr><tr><td> bcmFieldQualifyTrillIVersion
 </td><td> TRILL version field.
 </td></tr><tr><td> bcmFieldQualifyTrillIngressRbridge
 </td><td> Ingress Rbridge Nickname.
 </td></tr><tr><td> bcmFieldQualifyTrillMultiDestination
 </td><td> TRILL Multi-destination field.
 </td></tr><tr><td> bcmFieldQualifyTrillOpLength
 </td><td> TRILL Options length field.
 </td></tr><tr><td> bcmFieldQualifyTrillHopCount
 </td><td> TRILL Hop count field.
 </td></tr><tr><td> bcmFieldQualifyTrillPayload
 </td><td> Payload of TRILL header.
 </td></tr><tr><td> bcmFieldQualifyMplsForwardingLabelPayload
 </td><td> Payload of MPLS forwarding label.
 </td></tr><tr><td> bcmFieldQualifyIncomingIpIfClass
 </td><td> Incoming IP interface Class ID.
 </td></tr><tr><td> bcmFieldQualifyL2GreProtocolType
 </td><td> L2GRE Protocol type field.
 </td></tr><tr><td> bcmFieldQualifyL2GreVsid
 </td><td> L2GRE Virtual Subnet ID field.
 </td></tr><tr><td> bcmFieldQualifyL2GreFlowId
 </td><td> L2GRE Flow ID field.
 </td></tr><tr><td> bcmFieldQualifyMimVlanPri
 </td><td> MAC-in-MAC VLAN Priority field.
 </td></tr><tr><td> bcmFieldQualifyMimVlanCfi
 </td><td> MAC-in-MAC VLAN Cfi field.
 </td></tr><tr><td> bcmFieldQualifyFhei
 </td><td> DNX FHEI header field.
 </td></tr><tr><td> bcmFieldQualifyFheiSize
 </td><td> DNX FHEI header size in bytes.
 </td></tr><tr><td> bcmFieldQualifyEthernetOamHeaderBits0_31
 </td><td> Ethernet OAM Header First 4 Bytes.
 </td></tr><tr><td> bcmFieldQualifyEthernetOamHeaderBits32_63
 </td><td> Ethernet OAM Header Second 4 Bytes.
 </td></tr><tr><td> bcmFieldQualifyEthernetOamDstClassL2
 </td><td> Ethernet OAM Destination Class based on L2 lookup result.
 </td></tr><tr><td> bcmFieldQualifyEthernetOamTxPktUPMEP
 </td><td> Ethernet OAM UP-MEP Tx Packet.
 </td></tr><tr><td> bcmFieldQualifyEthernetOamSrcPortLmStatPoolId
 </td><td> Ethernet OAM LM Stat PoolId based on SrcPort.
 </td></tr><tr><td> bcmFieldQualifyEthernetOamVxlt1LmStatPoolId
 </td><td> Ethernet OAM LM Stat PoolId based on 1st Lookup in Vlan_Xlate table.
 </td></tr><tr><td> bcmFieldQualifyEthernetOamVxlt2LmStatPoolId
 </td><td> Ethernet OAM LM Stat PoolId based on 2nd Lookup in Vlan_Xlate table
 </td></tr><tr><td> bcmFieldQualifyEthernetOamSourceVPLmStatPoolId
 </td><td> Ethernet OAM LM Stat PoolId based on Source VP table.
 </td></tr><tr><td> bcmFieldQualifyEthernetOamInterfaceClassPort
 </td><td> Ethernet OAM Class Id assigned for packet based on Ingress Port.
 </td></tr><tr><td> bcmFieldQualifyEthernetOamClassVxlt1
 </td><td> Ethernet OAM Class Id assigned for packet based on 1st Lookup in Vlan_Xlate table.
 </td></tr><tr><td> bcmFieldQualifyEthernetOamClassVxlt2
 </td><td> Ethernet OAM Class Id assigned for packet based on 2nd Lookup in Vlan_Xlate table.
 </td></tr><tr><td> bcmFieldQualifyEthernetOamClassSourceVP
 </td><td> Ethernet OAM Class Id assigned for packet based on Source VP table.
 </td></tr><tr><td> bcmFieldQualifyEthernetOamClassVFI
 </td><td> Ethernet OAM Class Id assigned for packet based on VFI table.
 </td></tr><tr><td> bcmFieldQualifyMplsOamHeaderBits0_31
 </td><td> Mpls OAM Header First 4 Bytes.
 </td></tr><tr><td> bcmFieldQualifyMplsOamHeaderBits32_63
 </td><td> Mpls OAM Header Second 4 Bytes.
 </td></tr><tr><td> bcmFieldQualifyMplsOamGALLabelOnly
 </td><td> MPLS OAM packets having GAL Label Only.
 </td></tr><tr><td> bcmFieldQualifyMplsOamLmStatPoolId
 </td><td> MPLS OAM LM Stat PoolId based on <tt>MPLS_ENTRY</tt> table.
 </td></tr><tr><td> bcmFieldQualifyMplsOamGALExposed
 </td><td> MPLS OAM packets having GAL exposed.
 </td></tr><tr><td> bcmFieldQualifyMplsOamACH MPLS OAM ACH Header.
 </td></tr><tr><td> bcmFieldQualifyMplsOamControlPktType
 </td><td> MPLS OAM control packets based on Packet Type.
 </td></tr><tr><td> bcmFieldQualifyMplsOamClassMpls
 </td><td> MPLS OAM Class Id assigned for packet based on MPLS table.
 </td></tr><tr><td> bcmFieldQualifyOamHeaderBits0_31
 </td><td> OAM Header First 4 Bytes.
 </td></tr><tr><td> bcmFieldQualifyOamHeaderBits32_63
 </td><td> OAM Header Second 4 Bytes.
 </td></tr><tr><td> bcmFieldQualifyOamEgressClassVxlt
 </td><td> OAM Class Id assigned for packet based on <tt>EGR_VXLT</tt> table.
 </td></tr><tr><td> bcmFieldQualifyOamEgressClassPort
 </td><td> OAM Class Id assigned for packet based on Port table.
 </td></tr><tr><td> bcmFieldQualifyUdf
 </td><td> Qualify UDF selected data
 </td></tr><tr><td> bcmFieldQualifyOuterVlanActionRange
 </td><td> Compressed outer vlan tag
 </td></tr><tr><td> bcmFieldQualifyInnerVlanActionRange
 </td><td> Compressed inner vlan tag
 </td></tr></tbody></table><p>       The new field actions have been added for <tt>bcm_field_action_t</tt>
 
<a name=fp_action_table></a>
<h3>Table 28:   Field Actions
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td>  Action</td><td>  Description</td><td>  param0</td><td> param1
 </td></tr><tr><td> bcmFieldActionRedirDropPrecedence
 </td><td> Set the redirect drop precedence.
 </td><td>  BCM_FIELD_COLOR_xxx</td><td> n/a
 </td></tr><tr><td> bcmFieldActionRpRedirDropPrecedence
 </td><td> Set the redirect drop precedence for Red packets.
 </td><td>  BCM_FIELD_COLOR_xxx</td><td> n/a
 </td></tr><tr><td> bcmFieldActionYpRedirDropPrecedence
 </td><td> Set the redirect drop precedence for Yellow packets.
 </td><td>  BCM_FIELD_COLOR_xxx</td><td> n/a
 </td></tr><tr><td> bcmFieldActionGpRedirDropPrecedence
 </td><td> Set the redirect drop precedence for Green packets.
 </td><td>  BCM_FIELD_COLOR_xxx</td><td> n/a
 </td></tr><tr><td> bcmFieldActionHiGigDstModuleGportNew
 </td><td> Replace the value of <tt>DST_MODID</tt> field in Higig header.
 </td><td>  New Destination Module Id.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionHiGigDstPortGportNew
 </td><td> Replace the value of <tt>DST_PORT</tt> field in Higig header.
 </td><td>  New Destination Port Id.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionHiGigDstGportNew
 </td><td> Replace the value of <tt>DST_MODID</tt> and <tt>DST_PORT</tt> fields in Higig header
 </td><td>  New Destination Gport.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionGpHiGigDropPrecedenceNew
 </td><td> Replace the value of Drop Precedence field in Higig header for Green Packets.
 </td><td>  BCM_FIELD_COLOR_xxx.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionYpHiGigDropPrecedenceNew
 </td><td> Replace the value of Drop Precedence field in Higig header for Yellow packets
 </td><td>  BCM_FIELD_COLOR_xxx.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionRpHiGigDropPrecedenceNew
 </td><td> Replace the value of Drop Precedence field in Higig header for Red packets
 </td><td>  param0: BCM_FIELD_COLOR_xxx.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionHiGigDropPrecedenceNew
 </td><td> Replace the value of Drop Precedence field in Higig header for any(Green/Yellow/Red) packets
 </td><td>  param0: BCM_FIELD_COLOR_xxx.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionGpHiGigIntPriNew
 </td><td> Replace the value of Traffic Class field in Higig header for Green packets
 </td></tr><tr><td>  param0: New Internal Priority.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionYpHiGigIntPriNew
 </td><td> Replace the value of Traffic Class field in Higig header for Yellow packets
 </td><td>  param0: New Internal Priority.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionRpHiGigIntPriNew
 </td><td> Replace the value of Traffic Class field in Higig header for Red packets
 </td><td>  param0: New Internal Priority.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionHiGigIntPriNew
 </td><td> Replace the value of Traffic Class field in Higig header for any(green/Yellow/Red) packet
 </td><td>  param0: New Internal Priority.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionLoopbackSrcModuleGportNew
 </td><td> Replace the value of Sourece ModId field in Loopback header
 </td><td>  param0: New Source Module Id.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionLoopbackSrcPortGportNew
 </td><td> Replace the value of Source PortId field in Loopback header
 </td><td>  param0: New Source Port Id.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionLoopbackSrcGportNew
 </td><td> Replace the value of Source ModId and Source PortId fields in Loopback header
 </td><td>  param0: New Source Gport.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionLoopbackCpuMasqueradePktProfileNew
 </td><td> Replace the value of Packet Profile field in Loopback header
 </td><td>  param0: New Packet Profile.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionLoopbackPacketProcessingPortNew
 </td><td> Replace the value of Packet Processing port field in Loopback header
 </td><td>  param0: New Packet Processing Port.</td><td> n/a
 </td></tr><tr><td> bcmFieldActionLoopBackTypeNew
 </td><td> Replace the value of Loopback Type field in Loopback header
 </td><td>  param0: Loopback Type (bcmFieldLoopbackTypeXXX).</td><td> n/a
 </td></tr><tr><td> bcmFieldActionRecoverableDropCancel
 </td><td> Override drop decision taken by Protection switching logic
 </td><td></td><td></td></tr></tbody></table><p>       A new field control type has been added in <tt>bcm_field_control_t</tt>.
 
<a name=fp_control_values></a>
<h3>Table 29:   Field Control Values
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  bcmFieldControlIngressLogicalPolicerPoolsMode</td><td> Configure Logical Policer pool mode.
 </td></tr></tbody></table><br><hr noshade><a name="fp_vlantranslationhit"></a>
<h3>Section 3.4.11.1:   Field Qualify VlanTranslationHit
</h3>
<p>       Matching on vlan translation hit status is done with the qualifier
       bcmFieldQualifyVlanTranslationHit.The possible values for the parameters
       of bcm_field_qualify_VlanTranslationHit() are defined as below.

<a name=fp_BCM_FIELD_VXLT_LOOKUP_STATUS_xxx></a>
<h3>Table 30:   Vlan Translation Hit Status Values (for bcm_field_qualify_VlanTranslationHit)
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  BCM_FIELD_VXLT_LOOKUP_STATUS_xxx</b></td><td><b> Purpose
 </b></td></tr><tr><td> <tt>BCM_FIELD_VXLT_LOOKUP_STATUS_NO_HIT</tt>
 </td><td> No Hit on First/Second lookup of Vlan Translation Table
 </td></tr><tr><td> <tt>BCM_FIELD_VXLT_LOOKUP_STATUS_HIT</tt>
 </td><td> Hit on First/Second lookup of Vlan Translation Table
 </td></tr><tr><td> <tt>BCM_FIELD_VXLT_LOOKUP_STATUS_FIRST_HIT</tt>
 </td><td> Hit on First lookup of Vlan Translation Table
 </td></tr><tr><td> <tt>BCM_FIELD_VXLT_LOOKUP_STATUS_SECOND_HIT</tt>
 </td><td> Hit on Second lookup of Vlan Translation Table
 </td></tr></tbody></table><p>       One of the above mentioned constants has to be passed as data argument to
       bcm_field_qualify_VlanTranslationHit() API.
       But mask argument passed to the API will be ignored as BCM_FIELD_VXLT_LOOKUP_STATUS_xxx
       constants covers all
       possible combinations. bcm_field_qualify_VlanTranslationHit_get() API retrieves actual
       data value configured by the
       set API, mask has no significance and is populated with all 1's.
<p><br><hr noshade><a name="fp_ingress_policer_pools_mode"></a>
<h3>Section 3.4.11.2:   Ingress Policer Pool Modes
</h3>
<p>	Triumph3 has 16 Slices in Ingress Field Processor, with each slice having 512 entries.
	So the total number of entries comes to 8K. It has same number of meters (8K) which are
	spread across 8 global pools, with each pool having 1K meters (512 meter pairs).
	Triumph3 allows only 8 TCAM slices to update meters in the 8 meter pools for a matching packet.
	SDK assigns one meter pool for one group (i.e. one slice) and also restricts assigning
	meter pools to only 8 groups (8 slices).
	When ACL is configured in ways where some groups are mutually exclusive, those groups can
	share the same meter pool since a packet will be matching in only one of those groups.
	In such cases bcmFieldControlIngressLogicalPolicerPoolsMode can be used to divide each
	physical meter pools into two logical meter pools.

<a name=bcm_field_ingress_policer_pools_t></a>
 
<a name=fp_ingress_policer_pools_mode_t></a>
<h3>Table 31:   Ingress Policer Pool Modes
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Mode</b></td><td><b> Purpose
 </b></td></tr><tr><td> bcmFieldIngressLogicalPolicerPools8x1024
 </td><td> 8 Meter pools with 1024 entries in each pool (default).
 </td></tr><tr><td> bcmFieldIngressLogicalPolicerPools16x512Contiguous
 </td><td> 16 Meter pools with 512 entries in each pool in Contiguous mode.
 </td></tr><tr><td> bcmFieldIngressLogicalPolicerPools16x512Split
 </td><td> 16 Meter pools with 512 entries in each pool in Split mode.
 </td></tr><tr><td> bcmFieldIngressPolicerPoolsCount
 </td><td> Internal use only
 </td></tr></tbody></table><p><p>        New Field APIs in this release have been added as following.
<p><hr noshade>
<h3>APIs for Section 3.4.11:  Field Processor
</h3>
<a name=bcm_field_qset_id_multi_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_field_qset_id_multi_set</tt><br>
</h2>

<blockquote>
	Add qualifier objects to field group qset.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/field.h&gt;
	int
	bcm_field_qset_id_multi_set(
	    int unit,
	    bcm_field_qualify_t qualifier,
	    int num_objects,
	    int *object_list,
	    bcm_field_qset_t *qset);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>qualifier</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Qualifier enum bcmFieldQualifyXXX
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_objects</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of objects to set in the qset
 </td></tr>
<tr><td class="arg" valign="top"><tt>object_list</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) List of objects to set in the qset
 </td></tr>
<tr><td class="arg" valign="top"><tt>qset</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN/OUT) Field qualifier set - Qset
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Add qualifier objects to field group qset.
	The APIs <tt>bcm_field_qset_data_qualifier_add</tt>() and
   <a href="#bcm_field_qset_id_multi_set"><tt>bcm_field_qset_id_multi_set</tt></a>  should not be intermixed.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_field_qset_id_multi_delete></a>
<hr noshade>
<h2 class="api">
<tt>bcm_field_qset_id_multi_delete</tt><br>
</h2>

<blockquote>
	Delete qualifier objects to field group qset.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/field.h&gt;
	int
	bcm_field_qset_id_multi_delete(
	    int unit,
	    bcm_field_qualify_t qualifier,
	    int num_objects,
	    int *object_list,
	    bcm_field_qset_t *qset);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>qualifier</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Qualifier enum bcmFieldQualifyXXX
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_objects</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of objects to be removed from the qset
 </td></tr>
<tr><td class="arg" valign="top"><tt>object_list</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) List of objects to be removed from the qset
 </td></tr>
<tr><td class="arg" valign="top"><tt>qset</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN/OUT) Field qualifier set - Qset
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Delete qualifier objects to field group qset.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_field_qset_id_multi_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_field_qset_id_multi_get</tt><br>
</h2>

<blockquote>
	Get qualifier objects added to the field group qset.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/field.h&gt;
	int
	bcm_field_qset_id_multi_get(
	    int unit,
	    bcm_field_qset_t qset,
	    bcm_field_qualify_t qualifier,
	    int max_objects,
	    int *object_list,
	    int *count_objects);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>qset</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Field qualifier set - Qset
 </td></tr>
<tr><td class="arg" valign="top"><tt>qualifier</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Qualifier enum bcmFieldQualifyXXX
 </td></tr>
<tr><td class="arg" valign="top"><tt>max_objects</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of objects to be fetched from the qset
 </td></tr>
<tr><td class="arg" valign="top"><tt>object_list</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) List of objects be fetched from the qset
 </td></tr>
<tr><td class="arg" valign="top"><tt>count_objects(OUT)</tt></td><td>&nbsp;&nbsp;</td><td>
 Number of objects actually fetched from the qset
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get qualifier objects added to the field group qset.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_field_qualify_XXX></a>
<hr noshade>
<h2 class="api">
bcm_field_qualify_XXX<br>
</h2>

<blockquote>
       Add a qualification to a field entry
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>       #include &lt;bcm/field.h&gt;

       int bcm_field_qualify_IsEqualValue(
               int unit,
               bcm_field_entry_t entry,
               uint8 data,
               uint8 mask);
       int bcm_field_qualify_MirrorEgressDisabled(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 data,
	       uint8 mask);
       int bcm_field_qualify_BypassSrcMacFilter(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 data,
	       uint8 mask);
       int bcm_field_qualify_RxTrapCodeForSnoop(
	       int unit,
	       bcm_field_entry_t entry,
	       uint32 data,
	       uint32 mask);
       int bcm_field_qualify_IpmcStarGroupValue(
               int unit,
               bcm_field_entry_t entry,
               uint64 data,
               uint64 mask);
       int bcm_field_qualify_NativeVSwitch(
	       int unit,
	       bcm_field_entry_t entry,
	       bcm_vlan_t data,
	       bcm_vlan_t mask);
       int bcm_field_qualify_NativeVSwitchValid(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 data,
	       uint8 mask);
       int bcm_field_qualify_TrillIVersion(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 data,
	       uint8 mask);
       int bcm_field_qualify_TrillIngressRbridge(
	       int unit,
	       bcm_field_entry_t entry,
	       uint16 data,
	       uint16 mask);
       int bcm_field_qualify_TrillMultiDestination(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 data,
	       uint8 mask);
       int bcm_field_qualify_TrillOpLength(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 data,
	       uint8 mask);
       int bcm_field_qualify_TrillHopCount(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 data,
	       uint8 mask);
       int bcm_field_qualify_TrillPayload(
	       int unit,
	       bcm_field_entry_t entry,
	       uint64 data,
	       uint64 mask);
       int bcm_field_qualify_MplsForwardingLabelPayload(
	       int unit,
	       bcm_field_entry_t entry,
	       uint64 data,
	       uint64 mask);
       int bcm_field_qualify_IncomingIpIfClass(
	       int unit,
	       bcm_field_entry_t entry,
	       uint32 data,
	       uint32 mask);
       int bcm_field_qualify_L2GreProtocolType(
	       int unit,
	       bcm_field_entry_t entry,
	       uint16 data,
	       uint16 mask);
       int bcm_field_qualify_L2GreVsid(
	       int unit,
	       bcm_field_entry_t entry,
	       uint32 data,
	       uint32 mask);
       int bcm_field_qualify_L2GreFlowId(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 data,
	       uint8 mask);
       int bcm_field_qualify_MimVlanPri(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 data,
	       uint8 mask);
       int bcm_field_qualify_MimVlanCfi(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 data,
	       uint8 mask);
       int bcm_field_qualify_Fhei(
               int unit,
               bcm_field_entry_t entry,
               uint64 data,
               uint64 mask);
       int bcm_field_qualify_FheiSize(
               int unit,
               bcm_field_entry_t entry,
               uint32 data,
               uint32 mask);
       int bcm_field_qualify_udf(
               int unit,
               bcm_field_entry_t eid,
               bcm_udf_id_t udf_id,
               int length,
               uint8 *data,
               uint8 *mask);
	int bcm_field_qualify_OuterVlanActionRange(
  	       int unit, 
	       bcm_field_entry_t entry, 
	       bcm_vlan_t data, 
	       bcm_vlan_t mask);
	int bcm_field_qualify_InnerVlanActionRange(
	       int unit, 
	       bcm_field_entry_t entry, 
	       bcm_vlan_t data, 
	       bcm_vlan_t mask);
	int bcm_field_qualify_ClassId(
	       int unit, 
	       bcm_field_entry_t entry, 
	       uint8 data, 
	       uint8 mask);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
    BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>entry</tt></td><td>&nbsp;&nbsp;</td><td>
 Field entry ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>data</tt></td><td>&nbsp;&nbsp;</td><td>
 Data to match against
 </td></tr>
<tr><td class="arg" valign="top"><tt>mask</tt></td><td>&nbsp;&nbsp;</td><td>
 Mask to choose which bits of data to match against
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
       Adds a qualification to a filter entry.
       Each qualification added makes the entry more specific and match
       fewer possible packets.
</blockquote><h3>RETURNS</h3><blockquote>
       BCM_E_xxx
</blockquote>
<a name=bcm_field_qualify_SrcNivGport></a>
<hr noshade>
<h2 class="api">
bcm_field_qualify_SrcNivGport<br>
</h2>

<blockquote>
       Add SrcNivGport qualification to a field entry
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>       int bcm_field_qualify_SrcNivGport(
               int unit,
               bcm_field_entry_t entry,
               bcm_gport_t niv_port_id);
 </pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
 BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>entry</tt></td><td>&nbsp;&nbsp;</td><td>
 Field entry ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>niv_port_id</tt></td><td>&nbsp;&nbsp;</td><td>
 Data to match against
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
       Set match criteria for SrcNivGport qualifier
</blockquote><h3>RETURNS</h3><blockquote>
       BCM_E_xxx
</blockquote>
<a name=bcm_field_qualify_DstNivGport></a>
<hr noshade>
<h2 class="api">
bcm_field_qualify_DstNivGport<br>
</h2>

<blockquote>
       Add DstNivGport qualification to a field entry
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>       int bcm_field_qualify_DstNivGport(
               int unit,
               bcm_field_entry_t entry,
               bcm_gport_t niv_port_id);
 </pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
 BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>entry</tt></td><td>&nbsp;&nbsp;</td><td>
 Field entry ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>niv_port_id</tt></td><td>&nbsp;&nbsp;</td><td>
 Data to match against
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
       Set match criteria for DstNivGport qualifier
</blockquote><h3>RETURNS</h3><blockquote>
       BCM_E_xxx
</blockquote>
<a name=bcm_field_qualify_DstGport></a>
<hr noshade>
<h2 class="api">
bcm_field_qualify_DstGport<br>
</h2>

<blockquote>
       Add DstGport qualification to a field entry
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>       int bcm_field_qualify_DstGport(
               int unit,
               bcm_field_entry_t entry,
               bcm_gport_t port_id);
 </pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
 BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>entry</tt></td><td>&nbsp;&nbsp;</td><td>
 Field entry ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>port_id</tt></td><td>&nbsp;&nbsp;</td><td>
 Data to match against
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
       Set match criteria for DstGport qualifier
</blockquote><h3>RETURNS</h3><blockquote>
       BCM_E_xxx
</blockquote>
<a name=bcm_field_qualify_XXX_get></a>
<hr noshade>
<h2 class="api">
bcm_field_qualify_XXX_get<br>
</h2>

<blockquote>
       Get a qualification match criteria from a field entry
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>       #include &lt;bcm/field.h&gt;

       int bcm_field_qualify_IsEqualValue_get(
               int unit,
               bcm_field_entry_t entry,
               uint8 *data,
               uint8 *mask);
       int bcm_field_qualify_MirrorEgressDisabled_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 *data,
	       uint8 *mask);
       int bcm_field_qualify_BypassSrcMacFilter_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 *data,
	       uint8 *mask);
       int bcm_field_qualify_RxTrapCodeForSnoop_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint32 *data,
	       uint32 *mask);
       int bcm_field_qualify_IpmcStarGroupValue_get(
               int unit,
               bcm_field_entry_t entry,
               uint64 *data,
               uint64 *mask);
       int bcm_field_qualify_NativeVSwitch_get(
	       int unit,
	       bcm_field_entry_t entry,
	       bcm_vlan_t *data,
	       bcm_vlan_t *mask);
       int bcm_field_qualify_NativeVSwitchValid_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 *data,
	       uint8 *mask);
       int bcm_field_qualify_TrillIVersion_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 *data,
	       uint8 *mask);
       int bcm_field_qualify_TrillIngressRbridge_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint16 *data,
	       uint16 *mask);
       int bcm_field_qualify_TrillMultiDestination_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 *data,
	       uint8 *mask);
       int bcm_field_qualify_TrillOpLength_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 *data,
	       uint8 *mask);
       int bcm_field_qualify_TrillHopCount_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 *data,
	       uint8 *mask);
       int bcm_field_qualify_TrillPayload_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint64 *data,
	       uint64 *mask);
       int bcm_field_qualify_MplsForwardingLabelPayload_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint64 *data,
	       uint64 *mask);
       int bcm_field_qualify_IncomingIpIfClass_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint32 *data,
	       uint32 *mask);
       int bcm_field_qualify_L2GreProtocolType_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint16 *data,
	       uint16 *mask);
       int bcm_field_qualify_L2GreVsid_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint32 *data,
	       uint32 *mask);
       int bcm_field_qualify_L2GreFlowId_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 *data,
	       uint8 *mask);
       int bcm_field_qualify_MimVlanPri_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 *data,
	       uint8 *mask);
       int bcm_field_qualify_MimVlanCfi_get(
	       int unit,
	       bcm_field_entry_t entry,
	       uint8 *data,
	       uint8 *mask);
       int bcm_field_qualify_Fhei_get(
               int unit,
               bcm_field_entry_t entry,
               uint64 *data,
               uint64 *mask);
       int bcm_field_qualify_FheiSize_get(
               int unit,
               bcm_field_entry_t entry,
               uint32 *data,
               uint32 *mask);
       int bcm_field_qualify_udf_get(
               int unit,
               bcm_field_entry_t eid,
               bcm_udf_id_t udf_id,
               int max_length,
               uint8 *data,
               uint8 *mask,
               int *actual_length);
	int bcm_field_qualify_OuterVlanActionRange_get(
   	       int unit, 
	       bcm_field_entry_t entry, 
	       bcm_vlan_t *data, 
	       bcm_vlan_t *mask);
	int bcm_field_qualify_InnerVlanActionRange_get(
	       int unit, 
	       bcm_field_entry_t entry, 
	       bcm_vlan_t *data, 
	       bcm_vlan_t *mask);
	int bcm_field_qualify_ClassId_get(
	       int unit, 
	       bcm_field_entry_t entry, 
	       uint8 *data, 
	       uint8 *mask);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
    BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>entry</tt></td><td>&nbsp;&nbsp;</td><td>
 Field entry ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>data</tt></td><td>&nbsp;&nbsp;</td><td>
 Data to match against
 </td></tr>
<tr><td class="arg" valign="top"><tt>mask</tt></td><td>&nbsp;&nbsp;</td><td>
 Mask to choose which bits of data to match against
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
       Get a match criteria for a specific qualifier from a field entry.
</blockquote><h3>RETURNS</h3><blockquote>
       BCM_E_xxx
</blockquote>
<a name=bcm_field_qualify_SrcNivGport_get></a>
<hr noshade>
<h2 class="api">
bcm_field_qualify_SrcNivGport_get<br>
</h2>

<blockquote>
       Get the SrcNivGport qualification match criteria from a field entry
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>       int bcm_field_qualify_SrcNivGport_get(
               int unit,
               bcm_field_entry_t entry,
               bcm_gport_t *niv_port_id);
 </pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
 BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>entry</tt></td><td>&nbsp;&nbsp;</td><td>
 Field entry ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>niv_port_id</tt></td><td>&nbsp;&nbsp;</td><td>
 Data to match against
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
       Get match criteria for SrcNivGport qualifier from a field entry.
</blockquote><h3>RETURNS</h3><blockquote>
       BCM_E_xxx
</blockquote>
<a name=bcm_field_qualify_DstNivGport_get></a>
<hr noshade>
<h2 class="api">
bcm_field_qualify_DstNivGport_get<br>
</h2>

<blockquote>
       Get the DstNivGport qualification match criteria from a field entry
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>       int bcm_field_qualify_DstNivGport_get(
               int unit,
               bcm_field_entry_t entry,
               bcm_gport_t *niv_port_id);
 </pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
 BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>entry</tt></td><td>&nbsp;&nbsp;</td><td>
 Field entry ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>niv_port_id</tt></td><td>&nbsp;&nbsp;</td><td>
 Data to match against
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
       Get match criteria for DstNivGport qualifier from a field entry.
</blockquote><h3>RETURNS</h3><blockquote>
       BCM_E_xxx
</blockquote>
<a name=bcm_field_qualify_DstGport_get></a>
<hr noshade>
<h2 class="api">
bcm_field_qualify_DstGport_get<br>
</h2>

<blockquote>
       Get the DstGport qualification match criteria from a field entry
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>       int bcm_field_qualify_DstGport_get(
               int unit,
               bcm_field_entry_t entry,
               bcm_gport_t *port_id);
 </pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
 BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>entry</tt></td><td>&nbsp;&nbsp;</td><td>
 Field entry ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>port_id</tt></td><td>&nbsp;&nbsp;</td><td>
 Data to match against
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
       Get match criteria for DstGport qualifier from a field entry.
</blockquote><h3>RETURNS</h3><blockquote>
       BCM_E_xxx
</blockquote>
<a name=bcm_field_stage_info_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_field_stage_info_get</tt><br>
</h2>

<blockquote>
	Get per-stage field information
 </blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/field.h&gt;
	int bcm_field_stage_info_get(
	    int unit, 
	    bcm_field_stage_t stage, 
	    bcm_field_stage_info_t *info);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
  (IN)   Unit number
 </td></tr>
<tr><td class="arg" valign="top"><tt>stage</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) field stage
 </td></tr>
<tr><td class="arg" valign="top"><tt>stage</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) stage info
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	    per stage information, such as preselectors managemnt advanced mode,
            maximum preselecrots ID etc.
</blockquote><h3>RETURNS</h3><blockquote>
        BCM_E_xxx
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
   Field module not initialized
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Other error code
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Success
</td></tr>
</table></blockquote>
<a name=bcm_field_stat_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_field_stat_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve specific statistic type.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/field.h&gt;
	int bcm_field_stat_sync_get(int unit, int stat_id, 
				    bcm_field_stat_t  stat, uint64 *value);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
      (IN) BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Statistics entity ID.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Specific statistics type.
 </td></tr>
<tr><td class="arg" valign="top"><tt>value</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Counter value for statistics type.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_field_stat_get</tt>(), value returned is software accumulated 
	counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_field_stat_sync_get32></a>
<hr noshade>
<h2 class="api">
<tt>bcm_field_stat_sync_get32</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve specific statistic type.
	Get 32-bit counter value for specific statistic type.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/field.h&gt;
	int bcm_field_stat_sync_get32(int unit, int stat_id, 
				      bcm_field_stat_t  stat, uint32 *value);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
      (IN) BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Statistics entity ID.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Specific statistics type.
 </td></tr>
<tr><td class="arg" valign="top"><tt>value</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Counter value for statistics type.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_field_stat_get32</tt>(), value returned is software accumulated 
	counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_field_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_field_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve statistics value for a field entity
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/field.h&gt;
	int 
	bcm_field_stat_counter_sync_get(
	    int              unit,
	    uint32           stat_id,
	    bcm_field_stat_t stat,
	    uint32           num_entries,
	    uint32           *counter_indexes,
	    bcm_stat_value_t *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Statistics entity ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve that is, ingress/egress byte/packet
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_field_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<br><hr noshade><a name="ipmc"></a>
<h3>Section 3.4.12:   IP Multicast
</h3>
<p>        New APIs <tt>bcm_ipmc_stat_counter_sync_get</tt>() is added in this release.
<p><hr noshade>
<h3>APIs for Section 3.4.12:  IP Multicast
</h3>
<a name=bcm_ipmc_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_ipmc_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve counter statistic values 
	for an IPMC group.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ipmc.h&gt;
	int
	bcm_ipmc_stat_counter_sync_get(
	    int              unit,
	    bcm_ipmc_addr_t  *info,
	    bcm_ipmc_stat_t  stat,
	    uint32           num_entries,
	    uint32           *counter_indexes,
	    bcm_stat_value_t *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number
 </td></tr>
<tr><td class="arg" valign="top"><tt>info</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) IPMC entry information
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve( I.e. ingress/egress byte/packet)
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_ipmc_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<br><hr noshade><a name="l2"></a>
<h3>Section 3.4.13:   Layer 2 Address Management
</h3>
<p>        New control flag <tt>BCM_L2_EGRESS_VLAN_QOS_MAP_REPLACE</tt> has been added for <tt>bcm_l2_egress_t</tt> data 
        structure.
<h3>Table 32:   BCM L2 Egress Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_L2_EGRESS_VLAN_QOS_MAP_REPLACE</tt></td><td> Replace VLAN PCP-DEI QOS settings
 </td></tr></tbody></table><p>        New flag field <tt>BCM_L2_CACHE_PROTO_PKT</tt> has been added for <tt>bcm_l2_cache_addr_t</tt>.
<h3>Table 33:   BCM L2 Cache Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_L2_CACHE_PROTO_PKT</tt></td><td> Mark the frame as protocol packet.
 </td></tr></tbody></table><p>        New replace flag <tt>BCM_L2_REPLACE_MATCH_UC</tt> and <tt>BCM_L2_REPLACE_MATCH_MC</tt> have been added
        for <tt>bcm_l2_replace</tt>() API.
<h3>Table 34:   L2 Replace Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_L2_REPLACE_MATCH_UC</tt></td><td> L2 replace will be performed on Unicast entries
 </td></tr><tr><td>  <tt>BCM_L2_REPLACE_MATCH_MC</tt></td><td> L2 replace will be performed on Multicast entries
 </td></tr></tbody></table><p>        The field name of L2 multicast group index has been changed from <tt>l2mc_index</tt> to <tt>l2mc_group</tt>.
 <blockquote><pre>typedef struct <tt>bcm_l2_addr_s</tt> {
    ...
    <tt>bcm_cos_t</tt>           <tt>cos_src</tt>;        /* CoS based on src addr */
    <tt>bcm_multicast_t</tt>     <tt>l2mc_group</tt>;     /* XGS: index in L2MC table */
    <tt>bcm_pbmp_t</tt>          <tt>block_bitmap</tt>;   /* XGS: blocked egress bitmap */
    ...
} <tt>bcm_l2_addr_t</tt>;
</pre></blockquote><p>        New fields of <tt>bcm_l2_egress_t</tt> data structure have been added.
<blockquote><pre>/* Device-independent L2 egress structure. */
typedef struct <tt>bcm_l2_egress_s</tt> {
    ...
    uint16 <tt>inner_tpid</tt>;          /* inner vlan tag TPID */
    <tt>bcm_if_t</tt> <tt>l3_intf</tt>;           /* L3 interface (tunnel). Used only in
	                           Native Routing overlay protocols. */
    int <tt>vlan_qos_map_id</tt>;        /* VLAN PCP-DEI QoS settings. Used only
	                           in Native Routing overlay protocols. */
} <tt>bcm_l2_egress_t</tt>;
</pre></blockquote><p><br><hr noshade><a name="L2GRE"></a>
<h3>Section 3.4.14:   L2GRE Management
</h3>
<p>        <tt>BCM_L2GRE_PORT_DEFAULT</tt> was incorrectly added in the enumeration <tt>bcm_l2gre_port_match_t</tt> for
        MPLS Port Match Criteria. This has now been corrected.
<h3>Table 35:   L2GRE port flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_L2GRE_PORT_DEFAULT</tt></td><td> Create Multicast-only L2GRE Tunnel
 </td></tr></tbody></table><p>        New API <tt>bcm_l2gre_stat_counter_sync_get</tt>() has been added in this release.
<p><hr noshade>
<h3>APIs for Section 3.4.14:  L2GRE Management
</h3>
<a name=bcm_l2gre_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_l2gre_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve counter statistic values for 
	a l2gre vp/vpn index.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/l2gre.h&gt;
	int
	bcm_l2gre_stat_counter_sync_get(
	    int              unit,
	    bcm_gport_t     port,
	    bcm_vpn_t       vpn,
	    bcm_l2gre_stat_t    stat,
	    uint32           num_entries,
	    uint32           *counter_indexes,
	    bcm_stat_value_t *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) l2gre vp index
 </td></tr>
<tr><td class="arg" valign="top"><tt>vpn</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) l2gre vpn index
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) l2gre counter stat types.
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_l2gre_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<br><hr noshade><a name="l3"></a>
<h3>Section 3.4.15:   Layer 3 Management
</h3>
<p>        A new field <tt>native_routing_vlan_tags</tt> of <tt>bcm_l3_intf_t</tt> for L3 interface structure
        has been added in this release.
<blockquote><pre>typedef struct <tt>bcm_l3_intf_s</tt> {
    ...
    uint8 <tt>native_routing_vlan_tags</tt>; /* Set number of VLAN tags expected
                                     * when interface is used for native
                                     * routing
                                     */
	                              
} <tt>bcm_l3_intf_t</tt>;
</pre></blockquote><p>        A new flag <tt>BCM_L3_ECMP_PATH_NO_SORTING</tt> for L3 ECMP flags has been added.
<h3>Table 36:   BCM L3 ECMP Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_L3_ECMP_PATH_NO_SORTING</tt></td><td> If set, the members of the ECMP group won't be resorted.
 </td></tr></tbody></table><p>        A new flag <tt>BCM_L3_SOURCE_BIND_USE_MASK</tt> for L3 Source Binding flags as well as the 
        new IPv4 and IPv6 subnet masks for <tt>bcm_l3_source_bind_t</tt> data structure have been added
        in this release.
<h3>Table 37:   BCM Source Binding Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_L3_SOURCE_BIND_USE_MASK</tt></td><td> Indicate mask fields are to be used
 </td></tr></tbody></table><blockquote><pre>typedef struct <tt>bcm_l3_source_bind_s</tt> {
    ...
    <tt>bcm_ip_t</tt> <tt>ip_mask</tt>;               /* IP subnet mask (IPv4). */
    <tt>bcm_ip6_t</tt> <tt>ip6_mask</tt>;             /* IP subnet mask (IPv6). */
} <tt>bcm_l3_source_bind_t</tt>;

typedef <tt>bcm_l3_source_bind_t</tt> <tt>bcmx_l3_source_bind_t</tt>;
</pre></blockquote><p>        A new flag <tt>BCM_TUNNEL_WITH_ID</tt> has been added in this release
<h3>Table 38:   BCM Tunnel Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_TUNNEL_WITH_ID</tt></td><td> Add using the specified ID.
 </td></tr></tbody></table><p>        New L3 APIs <tt>bcm_l3_xxx_stat_sync_get</tt>/get32() and <tt>bcm_l3_xxx_stat_counter_sync_get</tt>/get32() APIs
        as well as the <tt>bcm_l3_route_find</tt>() and <tt>bcm_l3_subnet_route_find</tt>() have been added in this release.
<p><hr noshade>
<h3>APIs for Section 3.4.15:  Layer 3 Management
</h3>
<a name=bcm_l3_nat_egress_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_l3_nat_egress_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve counter statistic values for a Egress NAT Index.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/nat.h&gt;
	int
	bcm_l3_nat_egress_stat_counter_sync_get(
	    int              unit,
	    bcm_l3_nat_egress_t   *info,
	    bcm_l3_nat_egress_stat_t    stat,
	    uint32           num_entries,
	    uint32           *counter_indexes,
	    bcm_stat_value_t *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>info</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Egress NAT Index
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Egress Nat Counter stat types.
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_l3_nat_egress_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_l3_vrf_stat_sync_get></a>
<a name=bcm_l3_vrf_stat_sync_get32></a>
<hr noshade>
<h2 class="api">
<tt>bcm_l3_vrf_stat_sync_get</tt><br>
<tt>bcm_l3_vrf_stat_sync_get32</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve L3 VRF counter value for 
	specified VRF statistic type.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/l3.h&gt;
	int 
	bcm_l3_vrf_stat_sync_get(int unit, bcm_vrf_t vrf, bcm_l3_vrf_stat_t stat, 
			    uint64 *val);

	int 
	bcm_l3_vrf_stat_sync_get32(int unit, bcm_vrf_t vrf, bcm_l3_vrf_stat_t stat, 
			      uint32 *val);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>vrf</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Virtual router instance.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve.
 </td></tr>
<tr><td class="arg" valign="top"><tt>val</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to a counter value.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_l3_vrf_stat_get</tt>(), value returned is software accumulated 
	counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	<tt>BCM_E_XXX</tt>
</blockquote>
<a name=bcm_l3_vrf_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_l3_vrf_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve L3 VRF counter value for 
	specified VRF statistic type
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/l3.h&gt;
	int
	bcm_l3_vrf_stat_counter_sync_get(
	    int               unit,
	    bcm_vrf_t         vrf,
	    bcm_l3_vrf_stat_t stat,
	    uint32            num_entries,
	    uint32            *counter_indexes,
	    bcm_stat_value_t  *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>vrf</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Virtual router instance
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve that is, ingress/egress byte/packet
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_l3_vrf_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_l3_egress_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_l3_egress_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve the specified counter 
	statistic for a L3 egress interface.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/l3.h&gt;
	int
	bcm_l3_egress_stat_counter_sync_get(
	    int              unit,
	    bcm_if_t         intf_id,
	    bcm_l3_stat_t    stat,
	    uint32           num_entries,
	    uint32           *counter_indexes,
	    bcm_stat_value_t *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>intf_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Interface ID of a egress L3 object.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve that is, ingress/egress byte/packet
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_l3_egress_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_l3_ingress_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_l3_ingress_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Get counter statistic values for a l3 interface object.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/l3.h&gt;
	int
	bcm_l3_ingress_stat_counter_sync_get(
	    int              unit,
	    bcm_if_t         intf_id,
	    bcm_l3_stat_t    stat,
	    uint32           num_entries,
	    uint32           *counter_indexes,
	    bcm_stat_value_t *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>intf_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Interface ID of a L3 ingress object
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve that is, ingress/egress byte/packet
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_l3_ingress_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_l3_host_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_l3_host_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve the specified counter 
	statistic for a L3 host entry.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/l3.h&gt;
	int bcm_l3_host_stat_counter_sync_get(
	    int unit,
	    bcm_l3_host_t *info,
	    bcm_l3_stat_t stat,
	    uint32 num_entries,
	    uint32 *counter_indexes,
	    bcm_stat_value_t *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
              (IN) unit number
 </td></tr>
<tr><td class="arg" valign="top"><tt>info</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) L3 host description
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve
				      i.e. ingress/egress byte/packet)
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_l3_host_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	<tt>BCM_E_XXX</tt>
</blockquote>
<a name=bcm_l3_route_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_l3_route_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve counter statistic values for a l3 route index.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/l3.h&gt;
	int
	bcm_l3_route_stat_counter_sync_get(
	    int              unit,
	    bcm_l3_route_t   *info,
	    bcm_l3_route_stat_t    stat,
	    uint32           num_entries,
	    uint32           *counter_indexes,
	    bcm_stat_value_t *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>info</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) L3 Route Index
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) L3 route counter stat types.
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_l3_route_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_l3_route_find></a>
<hr noshade>
<h2 class="api">
<tt>bcm_l3_route_find</tt><br>
</h2>

<blockquote>
	Find a longest prefix matched route given an IP address.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/l3.h&gt;
	int bcm_l3_route_find(int unit, bcm_l3_host_t *host, bcm_l3_route_t *route);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
  BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>host</tt></td><td>&nbsp;&nbsp;</td><td>
 Pointer to <tt>bcm_l3_host_t</tt> specifying the IP address.
 </td></tr>
<tr><td class="arg" valign="top"><tt>route</tt></td><td>&nbsp;&nbsp;</td><td>
  Pointer to <tt>bcm_l3_route_t</tt> specifying the network number.  <a href="#L3_ROUTE_FIND_FIELDS_table">Table 39:  L3 Route Find Fields
 </a>  </td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Gets longest prefix matched route for a host from the route table(Support for ALPM mode only).
	Match conditions: for each entry in the route tables, 
	compare input IP address &amp; entry mask with entry subnet &amp; entry mask, if they are
	equal, than pickup the longest prefix from the matched entries. 
	The return only indicates the result of route table process, not represent the 
	result of the chip process.
<p>	The valid flags are as follows:
 <ul><li> <tt>BCM_L3_MULTIPATH</tt> - Set to designate the route is ECMP route.
	In this case, only the information for the first path is returned.
 </li><li> <tt>BCM_L3_IP6</tt> - Address is IPv6.
 </li><li> <tt>BCM_L3_HIT_CLEAR</tt> - Clear HIT bit if set
 </li></ul>
<a name=L3_ROUTE_FIND_FIELDS_table></a>
<h3>Table 39:   L3 Route Find Fields
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td>  Fields</td><td> Description
 </td></tr><tr><td>  <tt>l3a_flags</tt></td><td> Operation control flags
 </td></tr><tr><td>  <tt>l3a_vrf</tt></td><td> Virtual router instance, if applicable
 </td></tr><tr><td>  <tt>l3a_net</tt></td><td> Network IP address
 </td></tr><tr><td>  <tt>l3a_ipmask</tt></td><td> Network IP mask
 </td></tr><tr><td>  <tt>l3a_intf</tt></td><td> (OUT) L3 interface
 </td></tr><tr><td>  <tt>l3a_nexthopip</tt></td><td> (OUT) Next hop IP address (gateway) - StrataXGS I/II only
 </td></tr><tr><td>  <tt>l3a_nexthop_mac</tt></td><td> (OUT) Next hop MAC address
 </td></tr><tr><td>  <tt>l3a_port_tgid</tt></td><td> (OUT) Port or trunk group ID
 </td></tr><tr><td>  <tt>l3a_modid</tt></td><td> (OUT) Module ID
 </td></tr><tr><td>  <tt>l3a_tunnel_option</tt></td><td> (OUT) reused for memory table index
 </td></tr><tr><td>  <tt>l3a_vid</tt></td><td> (OUT) VLAN ID for per-VLAN default route (BCM5695 only)
 </td></tr></tbody></table></blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NOT_FOUND</tt></td><td>&nbsp;&nbsp;</td><td>
 - Routes not found
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 - Found a matched route
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 - Other error code
 </td></tr>
</table></blockquote>
<a name=l3_subnet_route_find></a>
<hr noshade>
<h2 class="api">
<tt>l3_subnet_route_find</tt><br>
</h2>

<blockquote>
	Find a longest prefix matched route given the ip and netmask.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/l3.h&gt;
	int bcm_l3_subnet_route_find(int unit, bcm_l3_route_t *input, bcm_l3_route_t *route);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
  BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>input</tt></td><td>&nbsp;&nbsp;</td><td>
 Pointer to <tt>bcm_l3_route_t</tt> specifying the subnet.
 </td></tr>
<tr><td class="arg" valign="top"><tt>route</tt></td><td>&nbsp;&nbsp;</td><td>
  Pointer to <tt>bcm_l3_route_t</tt> specifying the network number.  <a href="#L3_SUBNET_ROUTE_FIND_FIELDS_table">Table 40:  L3 Subnet Route Find Fields
 </a>  </td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Gets information for an IP route from the route table(Support for ALPM mode only).
	Match conditions: for each entry in the route tables, entry prefix length &lt;= input prefix length, 
	compare input subnet &amp; entry mask with entry subnet &amp; entry mask, if they are
	equal, than pickup the longest prefix from the matched entries. 
	The return only indicates the result of route table process, not represent the 
	result of the chip process.
<p>	The valid flags are as follows:
 <ul><li> <tt>BCM_L3_MULTIPATH</tt> - Set to designate the route is ECMP route.
	In this case, only the information for the first path is returned.
 </li><li> <tt>BCM_L3_IP6</tt> - Address is IPv6.
 </li><li> <tt>BCM_L3_HIT_CLEAR</tt> - Clear HIT bit if set
 </li></ul>
<a name=L3_SUBNET_ROUTE_FIND_FIELDS_table></a>
<h3>Table 40:   L3 Subnet Route Find Fields
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td>  Fields</td><td> Description
 </td></tr><tr><td>  <tt>l3a_flags</tt></td><td> Operation control flags
 </td></tr><tr><td>  <tt>l3a_vrf</tt></td><td> Virtual router instance, if applicable
 </td></tr><tr><td>  <tt>l3a_net</tt></td><td> Network IP address
 </td></tr><tr><td>  <tt>l3a_ipmask</tt></td><td> Network IP mask
 </td></tr><tr><td>  <tt>l3a_intf</tt></td><td> (OUT) L3 interface
 </td></tr><tr><td>  <tt>l3a_nexthopip</tt></td><td> (OUT) Next hop IP address (gateway) - StrataXGS I/II only
 </td></tr><tr><td>  <tt>l3a_nexthop_mac</tt></td><td> (OUT) Next hop MAC address
 </td></tr><tr><td>  <tt>l3a_port_tgid</tt></td><td> (OUT) Port or trunk group ID
 </td></tr><tr><td>  <tt>l3a_modid</tt></td><td> (OUT) Module ID
 </td></tr><tr><td>  <tt>l3a_tunnel_option</tt></td><td> (OUT) reused for memory table index
 </td></tr><tr><td>  <tt>l3a_vid</tt></td><td> (OUT) VLAN ID for per-VLAN default route (BCM5695 only)
 </td></tr></tbody></table></blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NOT_FOUND</tt></td><td>&nbsp;&nbsp;</td><td>
 - Routes not found
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 - Found a matched route
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 - Other error code
 </td></tr>
</table></blockquote>
<br><hr noshade><a name="mim"></a>
<h3>Section 3.4.16:   MAC-in-MAC Management
</h3>
<p>        <tt>BCM_MIM_VPN_ELINE</tt> is newly defined for Point-to-Point VPN service for MAC-in-MAC VPN Flags.
<h3>Table 41:   MAC-in-MAC VPN Config Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td> <tt>BCM_MIM_VPN_ELINE</tt>
 </td><td> Must be set to specify that the VPN type is Point-to-Point(E-Line) MAC-in-MAC.
 </td></tr></tbody></table><p>        New APIs <tt>bcm_mim_lookup_id_stat_counter_sync_get</tt>() and <tt>bcm_mim_vpn_stat_counter_sync_get</tt>() are
        added in this release.
<p><hr noshade>
<h3>APIs for Section 3.4.16:  MAC-in-MAC Management
</h3>
<a name=bcm_mim_lookup_id_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_mim_lookup_id_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve counter statistic values 
	for specific MiM I-SID entry.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/mim.h&gt;
	int bcm_mim_lookup_id_stat_counter_sync_get(
	    int unit,
	    int lookup_id,
	    bcm_mim_stat_t stat,
	    uint32 num_entries,
	    uint32 *counter_indexes,
	    bcm_stat_value_t *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
              (IN) unit number
 </td></tr>
<tr><td class="arg" valign="top"><tt>lookup_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) I-SID value
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve
				      i.e. ingress/egress byte/packet)
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_mim_lookup_id_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_mim_vpn_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_mim_vpn_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve counter statistic values for 
	specific MiM VPN entry
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/mim.h&gt;
	int bcm_mim_vpn_stat_counter_sync_get( 
	    int unit,  
	    bcm_mim_vpn_t vpn,  
	    bcm_mim_stat_t stat,  
	    uint32 num_entries,  
	    uint32 *counter_indexes,  
	    bcm_stat_value_t *counter_values); 
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
              (IN) unit number
 </td></tr>
<tr><td class="arg" valign="top"><tt>vpn</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) MiM VPN
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve
				      i.e. ingress/egress byte/packet)
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_mim_vpn_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<br><hr noshade><a name="mirroring"></a>
<h3>Section 3.4.17:   Mirroring
</h3>
<p>        A new flag <tt>BCM_MIRROR_DEST_TUNNEL_ETAG</tt> for mirror destination flags as well as 
        the required fields of <tt>bcm_mirror_destination_t</tt> data structure has been added.

<a name=mirrorDestinationflags></a>
<h3>Table 42:   BCM Mirror Destination Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Description
 </b></td></tr><tr><td> <tt>BCM_MIRROR_DEST_TUNNEL_ETAG</tt>
 </td><td> Mirrored packet should be ETAG(Port Extender VLAN Tag) tunneled.
              May be combined with L2 or L3 GRE tunnels.
 </td></tr></tbody></table><blockquote><pre>struct <tt>bcm_mirror_destination_s</tt> {
    ...
    uint16 <tt>etag_src_vid</tt>;                /* Extended (source) port vlan id */
    uint16 <tt>etag_dst_vid</tt>;                /* Extended (destination) port vlan id */
    uint32 <tt>egress_sample_rate_dividend</tt>; /* The probability of outbound mirroring
					   a packet from the destination is
					   <tt>sample_rate_dividend</tt> &gt;=
					   <tt>sample_rate_divisor</tt> ? 1 :
					   <tt>sample_rate_dividend</tt> /
					   <tt>sample_rate_divisor</tt> */
    uint32 <tt>egress_sample_rate_divisor</tt>; 
    uint8 <tt>recycle_context</tt>;              /* recycle context of egress originating
					   packets */
    uint16 <tt>packet_copy_size</tt>;            /*  If non zero, the copied packet will
					   be truncated to the first
					   <tt>packet_copy_size</tt> . Current supported
					   values for DNX are 0, 64, 128, 192 */
    uint16 <tt>egress_packet_copy_size</tt>;     /* If non zero and the packet is copied
					   from the egress, the packet will be
					   truncated to the first
					   <tt>packet_copy_size</tt> . Current supported
					   values for DNX are 0, 256. */
    <tt>bcm_mirror_pkt_header_updates_t</tt> <tt>packet_control_updates</tt>; 
} <tt>bcm_mirror_destination_t</tt>;

typedef <tt>bcm_mirror_destination_t</tt> <tt>bcmx_mirror_destination_t</tt>;
</pre></blockquote><p>        New mirroring APIs have been added with the corresponding data types.
 <blockquote><pre>/*  represents the options for the mirroring of packets */
typedef struct <tt>bcm_mirror_options_s</tt> {
    uint32 flags;
    uint8 <tt>forward_strength</tt>;
    uint8 <tt>copy_strength</tt>;
} <tt>bcm_mirror_options_t</tt>;

/*   represents header updates of mirrored packets */
typedef struct <tt>bcm_mirror_pkt_header_updates_s</tt> {
   uint32 valid;                   /* Used to specify which fields to use for
				      header changes. Possible values will be
				      named <tt>BCM_MIRROR_PKT_HEADER_UPDATE_</tt>* */
   <tt>bcm_color_t</tt> color;              /* drop precedence */
   uint8 prio;                     /* the internal packet priority (traffic
				      class before ingress mapping to cosq) */
   uint8 <tt>ecn_value</tt>;                /* ECN capable and congestion encoding */
   uint8 <tt>cnm_cancel</tt>;               /* Ignore Congestion Point (CNM) */
   uint32 <tt>trunk_hash_result</tt>;       /* LAG load balancing key */
   <tt>bcm_gport_t</tt> <tt>in_port</tt>;            /* 8b should be exposed? */
   uint16 vsq;                     /* selects STF (statistics flow) VSQ */
   uint16 <tt>fabric_header_editing</tt>;   /* changes to the fabric headers */
} <tt>bcm_mirror_pkt_header_updates_t</tt>;

</pre></blockquote><p><hr noshade>
<h3>APIs for Section 3.4.17:  Mirroring
</h3>
<a name=bcm_mirror_pkt_header_updates_t_init></a>
<hr noshade>
<h2 class="api">
<tt>bcm_mirror_pkt_header_updates_t_init</tt><br>
</h2>

<blockquote>
	Initialized <tt>bcm_mirror_pkt_header_updates_t</tt> struct
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/mirror.h&gt;
	void bcm_mirror_pkt_header_updates_t_init(bcm_mirror_pkt_header_updates_t *updates);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>updates</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT)  mirror pkt <tt>header_updates</tt> to initialized.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Initialize a mirror pkt <tt>header_updates</tt>  structure.
</blockquote><h3>RETURNS</h3><blockquote>
	None.
</blockquote>
<a name=bcm_mirror_options_t_init></a>
<a name=bcm_mirror_port_destination_add></a>
<a name=bcm_mirror_port_destination_get></a>
<a name=bcm_mirror_port_vlan_destination_add></a>
<a name=bcm_mirror_port_vlan_destination_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_mirror_options_t_init</tt><br>
<tt>bcm_mirror_port_destination_add</tt><br>
<tt>bcm_mirror_port_destination_get</tt><br>
<tt>bcm_mirror_port_vlan_destination_add</tt><br>
<tt>bcm_mirror_port_vlan_destination_get</tt><br>
</h2>

<blockquote>
	extended versions of existing <tt>_dest_</tt> APIs using a <tt>bcm_mirror_options_t</tt> argument 
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/mirror.h&gt;
        void bcm_mirror_options_t_init(bcm_mirror_options_t *options);
	int bcm_mirror_port_destination_add(int unit, bcm_port_t port,
				     uint32 flags, bcm_gport_t mirror_dest,bcm_mirror_options_t options);

	int bcm_mirror_port_destination_get(int unit, bcm_port_t port, uint32 flags,
				     int mirror_dest_size, bcm_gport_t *mirror_dest,
				     int *mirror_dest_count,bcm_mirror_options_t *options);

	int bcm_mirror_port_vlan_dest_add(int unit, bcm_port_t port, bcm_vlan_t vlan, uint32 flags, bcm_gport_t destid, bcm_mirror_options_t options);

	int bcm_mirror_port_vlan_dest_get(int unit, bcm_port_t port, bcm_vlan_t vlan, uint32 flags,unsigned int mirror_dest_size, bcm_gport_t *destid,unsigned int *destcount,bcm_mirror_options_t *options);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>options</tt></td><td>&nbsp;&nbsp;</td><td>
        (IN|OUT) The options for the mirroring of packets(input for *<tt>_add</tt> api's,output for *<tt>_get</tt> api's) 
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	extended versions of existing <tt>_dest_</tt> APIs using a <tt>bcm_mirror_options_t</tt> argument 
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<br><hr noshade><a name="mpls"></a>
<h3>Section 3.4.18:   MPLS Management
</h3>
<p>        A new MPLS port flag, <tt>BCM_MPLS_PORT_FORWARD_GROUP</tt>, has been added as well as the extension of
        MPLS port flags.
<h3>Table 43:   MPLS Port Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td> <tt>BCM_MPLS_PORT_FORWARD_GROUP</tt>
 </td><td> Enable VLAN-Port property <tt>FORWARD_GROUP</tt> to MPLS-Port.
 </td></tr></tbody></table><h3>Table 44:   MPLS Port Flags(2)
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td> <tt>BCM_MPLS_PORT2_INGRESS_ONLY</tt>
 </td><td> Indicates ingress settings
 </td></tr><tr><td> <tt>BCM_MPLS_PORT2_EGRESS_ONLY</tt>
 </td><td> Indicates egress settings
 </td></tr><tr><td> <tt>BCM_MPLS_PORT2_EGRESS_PROTECTION</tt>
 </td><td> Egress protection object
 </td></tr></tbody></table><p>        Two new fields of MPLS port type <tt>bcm_mpls_port_t</tt> have been added regarding failover stuff.
<blockquote><pre>/* MPLS port type. */
typedef struct <tt>bcm_mpls_port_s</tt> {
    ...
    <tt>bcm_failover_t</tt> <tt>egress_failover_id</tt>;  /* Failover object index for
					   Egress Protection */
    <tt>bcm_gport_t</tt> <tt>egress_failover_port_id</tt>;/* Failover MPLS Port identifier
                                           for Egress Protection */
} <tt>bcm_mpls_port_t</tt>;
</pre></blockquote><p>        New APIs <tt>bcm_mpls_port_stat_counter_sync_get</tt>() and <tt>bcm_mpls_label_stat_counter_sync_get</tt>()
        as well as <tt>bcm_mpls_label_stat_sync_get</tt>/get32() APIs are added in this release.
<p><hr noshade>
<h3>APIs for Section 3.4.18:  MPLS Management
</h3>
<a name=bcm_mpls_port_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_mpls_port_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve get counter statistic 
	values for specific vpn and gport
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/mpls.h&gt;
	int
	bcm_mpls_port_stat_counter_sync_get(
	    int                  unit,
	    bcm_vpn_t            vpn,
	    bcm_gport_t          port,
	    bcm_mpls_port_stat_t stat,
	    uint32               num_entries,
	    uint32               *counter_indexes,
	    bcm_stat_value_t     *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>vpn</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) VPN ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) MPLS Gport
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve that is, ingress/egress byte/packet
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_mpls_port_stat_counter_sync_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_mpls_label_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_mpls_label_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve counter statistic values for 
	specific MPLS label and gport
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/mpls.h&gt;
	int
	bcm_mpls_label_stat_counter_sync_get(
	    int                  unit,
	    bcm_mpls_label_t     label,
	    bcm_gport_t          port,
	    bcm_mpls_port_stat_t stat,
	    uint32               num_entries,
	    uint32               *counter_indexes,
	    bcm_stat_value_t     *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>label</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) MPLS Label
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) MPLS Gport
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve that is, ingress/egress byte/packet
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_mpls_label_stat_counter_get</tt>(), value returned is software
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_mpls_label_stat_sync_get></a>
<a name=bcm_mpls_label_stat_sync_get32></a>
<hr noshade>
<h2 class="api">
<tt>bcm_mpls_label_stat_sync_get</tt><br>
<tt>bcm_mpls_label_stat_sync_get32</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve MPLS Stats.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/mpls.h&gt;
	int bcm_mpls_label_stat_sync_get(int unit, bcm_mpls_label_t label,
					 bcm_gport_t port, bcm_mpls_stat_t stat,
					 uint64 *val);

	int bcm_mpls_label_stat_sync_get32(int unit, bcm_mpls_label_t label,
					   bcm_gport_t port, bcm_mpls_stat_t stat,
					   uint32 *val);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
     (IN) BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>label</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) MPLS Label
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Gport
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Specify the Stat Type
 </td></tr>
<tr><td class="arg" valign="top"><tt>val</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to stats value
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_mpls_label_stat_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<br><hr noshade><a name="multicast"></a>
<h3>Section 3.4.19:   Multicast Configuration
</h3>
<p>    New mulaticast APIs have been added for this release.
<p><hr noshade>
<h3>APIs for Section 3.4.19:  Multicast Configuration
</h3>
<a name=bcm_multicast_set></a>
<a name=bcm_multicast_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_multicast_set</tt><br>
<tt>bcm_multicast_get</tt><br>
</h2>

<blockquote>
	Set or Get all the replicataions of a multicast group.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/multicast.h&gt;
	int bcm_multicast_set(
	    int unit, 
	    bcm_multicast_t group, 
	    uint32 flags, 
	    int nof_replications, 
	    bcm_multicast_replication_t *rep_array);
	int bcm_multicast_get(
	    int unit, 
	    bcm_multicast_t group, 
	    uint32 flags, 
	    int replication_max, 
	    bcm_multicast_replication_t *out_rep_array, 
	    int *rep_count);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
                    (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>group</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Multicast group ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) flags for the API
</td></tr>
<tr><td class="arg" valign="top"><tt>nof_replications</tt></td><td>&nbsp;&nbsp;</td><td>
        (IN) number of replications to be set in the group
 </td></tr>
<tr><td class="arg" valign="top"><tt>rep_array</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) the replications to be set in the group
</td></tr>
<tr><td class="arg" valign="top"><tt>replication_max</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) max number of replications to be returned (size of <tt>rep_array</tt>)
 </td></tr>
<tr><td class="arg" valign="top"><tt>out_rep_array</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Array of replications to hold the output replications
 </td></tr>
<tr><td class="arg" valign="top"><tt>rep_count</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Actual number of replications returned in the array
                                             (if replication max is zero, no replications are returned and
                                             this parameter will return the number of replications
                                             in the group)
 </td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set/Get the replications of the given multicast group.
	Set will disregard any existing replications.
<h3>Table 45:   values for the flag parameter of the new api family  bcm_multicast_get/set/add/delete  
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td> <tt>BCM_MULTICAST_INGRESS</tt>
 </td><td> Determines if the operation is on an ingress multicast group.
              If not specified an egress multicast group is assumed. 
 </td></tr></tbody></table>	The purpuse of <tt>bcm_multicast_replication_t</tt>  is to hold all the information of one replication.
 <blockquote><pre>typedef struct { 
    uint32 flags;     /* information on the replication */ 
    <tt>bcm_gport_t</tt> port; /* replication destination */ 
    <tt>bcm_if_t</tt> encap1;  /* first encapsulation */ 
    <tt>bcm_if_t</tt> encap2;  /* second encapsulation */ 
} <tt>bcm_mullticast_replication_t</tt>;  /* represents a multicast replication */
</pre></blockquote><h3>Table 46:   bcm_mullticast_replication_t Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td> <tt>BCM_MUTICAST_REPLICATION_ENCAP2_VALID</tt>
 </td><td> determines if encap2 is used
 </td></tr><tr><td> <tt>BCM_MUTICAST_REPLICATION_ENCAP1_L3_INTF</tt>
 </td><td> when encap2 is used, determines if encap1 is a routing interface or not
 </td></tr></tbody></table></blockquote><h3>RETURNS</h3><blockquote>
	<tt>BCM_E_XXX</tt>
</blockquote>
<a name=bcm_multicast_delete></a>
<a name=bcm_multicast_add></a>
<hr noshade>
<h2 class="api">
<tt>bcm_multicast_delete</tt><br>
<tt>bcm_multicast_add</tt><br>
</h2>

<blockquote>
	Delete or add replications of a multicast group.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/multicast.h&gt;

	int bcm_multicast_delete(
	    int unit, 
	    bcm_multicast_t group, 
	    uint32 flags, 
	    int nof_replications, 
	    bcm_multicast_replication_t *rep_array);
	int bcm_multicast_add(
	    int unit, 
	    bcm_multicast_t group, 
	    uint32 flags, 
	    int nof_replications, 
	    bcm_multicast_replication_t *rep_array);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
                    (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>group</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Multicast group ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) flags for the API
 </td></tr>
<tr><td class="arg" valign="top"><tt>nof_replications</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) number of replications to delete/add
 </td></tr>
<tr><td class="arg" valign="top"><tt>rep_array</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) the replications to be deleted/added
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	delete or add replications from/to a given multicast group.
</blockquote><h3>RETURNS</h3><blockquote>
	<tt>BCM_E_XXX</tt>
</blockquote>
<a name=multicast_replication_t_init></a>
<hr noshade>
<h2 class="api">
<tt>multicast_replication_t_init</tt><br>
</h2>

<blockquote>
	Init the <tt>multicast_replication_t</tt> structure.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/multicast.h&gt;
	 bcm_multicast_replication_t_init(
	    bcm_multicast_replication_t *replication_structure);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>replication_structure</tt></td><td>&nbsp;&nbsp;</td><td>
              (OUT) replication structure for initialization
 </td></tr>
</table></blockquote><br><hr noshade><a name="niv"></a>
<h3>Section 3.4.20:   Network Interface Virtualization Management
</h3>
<p>	A new NIV port flag has been added for the flags field of <tt>bcm_niv_port_t</tt> structure
        that describes a NIV virtual port used in VIS.
<blockquote><pre>typedef struct <tt>bcm_niv_port_s</tt> {
    uint32 flags;                   /* BCM_NIV_PORT_xxx */
    <tt>bcm_gport_t</tt> <tt>niv_port_id</tt>;        /* <tt>BCM_GPORT_NIV_PORT</tt> type object */
    <tt>bcm_gport_t</tt> port;               /* Physical port / trunk */
    uint16 <tt>virtual_interface_id</tt>;    /* Virtual interface identifier */
    <tt>bcm_vlan_t</tt> <tt>match_vlan</tt>;          /* Optional outer VLAN ID to match. */
    uint16 <tt>match_service_tpid</tt>;      /* Ingress SD-tag TPID. */
    uint32 <tt>if_class</tt>;                /* Interface class ID. */
} <tt>bcm_niv_port_t</tt>;
</pre></blockquote><h3>Table 47:   NIV port flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_NIV_VNTAG_L_BIT_FORCE_1</tt></td><td> Allow frames head back
 </td></tr></tbody></table><p>        New fields intf and <tt>multicast_flags</tt> of <tt>bcm_niv_egress_t</tt> data structure have been added
        along with their NIV egress type of <tt>BCM_NIV_EGRESS_L3</tt>.
<blockquote><pre>/* NIV egress type. */
typedef struct <tt>bcm_niv_egress_s</tt> {
    ...
    <tt>bcm_if_t</tt> intf;          /* L3 interface */
    uint32 <tt>multicast_flags</tt>; /* <tt>BCM_L3_MULTICAST</tt> flag definitions */
} <tt>bcm_niv_egress_t</tt>;
</pre></blockquote><p><br><hr noshade><a name="oam"></a>
<h3>Section 3.4.21:   Operations, Administration, And Maintenance
 </h3>
<p>        A new OAM Loss Measurement flag has been added in this release. 
<h3>Table 48:   OAM Loss Measurement Flag Definitions
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Flag</b></td><td><b> Description
 </b></td></tr><tr><td>  <tt>BCM_OAM_LOSS_SLM</tt></td><td> Transmit SLM/Rs (as opposed to LMM/Rs)
 </td></tr></tbody></table><p>        A new OAM control format has been added with its data type.
<h3>Table 49:   OAM Control Formats
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Control Format Type</b></td><td><b> Description
 </b></td></tr><tr><td>  bcmOamControlReportMode</td><td> Accepts one of the <tt>bcm_oam_report_mode_type_t</tt> as the arg
 </td></tr></tbody></table><blockquote><pre>/*
 * OAM report mode types. To be used as the arg parameter when calling
 * <tt>bcm_oam_control_set</tt>/get() with the type parameter set to
 * bcmOamControlReportMode.
 */
typedef enum <tt>bcm_oam_report_mode_type_e</tt> {
    bcmOamReportModeTypeNormal = 0,  /* Default report mode. */
    bcmOamReportModeTypeCompact = 1,
    bcmOamReportModeTypeRaw = 2,     /* Report mode events will be disabled
				      * when report mode is set to raw. */
    bcmOamReportModeTypeCount = 3
} <tt>bcm_oam_report_mode_type_t</tt>;
</pre></blockquote><p><br><hr noshade><a name="txrx"></a>
<h3>Section 3.4.22:   Packet Transmit and Receive
</h3>
<p>        Some packet stacking forwarding options have been added as listed below for
        egress device operations which may be specified in a HiGig2 header.

<a name=pkt_stk_forward_table></a>
<h3>Table 50:   Packet Stacking Forward Descriptions
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td> Description
 </td></tr><tr><td> <tt>BCM_PKT_STK_FORWARD_MPLS</tt>
 </td><td> Stacking header packet forwarding option:MPLS.
 </td></tr><tr><td> <tt>BCM_PKT_STK_FORWARD_TRILL</tt>
 </td><td> Stacking header packet forwarding option:TRILL.
 </td></tr><tr><td> <tt>BCM_PKT_STK_FORWARD_FCOE</tt>
 </td><td> Stacking header packet forwarding option:FCoE.
 </td></tr><tr><td> <tt>BCM_PKT_STK_FORWARD_SNOOP</tt>
 </td><td> Stacking header packet forwarding option:SNOOP.
 </td></tr><tr><td> <tt>BCM_PKT_STK_FORWARD_TRAFFIC_MANAGEMENT</tt>
 </td><td> Stacking header packet forwarding option:Traffic Management.
 </td></tr></tbody></table><p>        Following are the new Rx Decap Tunnel types added in this release.

<a name=bcm_rx_decap_tunnel_type></a>
<h3>Table 51:   Rx Decap Tunnel Types 
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  RX Decap Tunnel Type</b></td><td><b> Description
 </b></td></tr><tr><td>  bcmRxDecapNone</td><td> No tunnel Decap
 </td></tr><tr><td>  bcmRxDecapAccessSVP</td><td> Packet ingress on Access SVP (No decap)
 </td></tr><tr><td>  bcmRxDecapMIM</td><td> Decap MIM Tunnel
 </td></tr><tr><td>  bcmRxDecapL2GRE</td><td> Decap L2GRE Tunnel
 </td></tr><tr><td>  bcmRxDecapVXLAN</td><td> Decap VXLAN Tunnel
 </td></tr><tr><td>  bcmRxDecapAMT</td><td> Decap AMT Tunnel
 </td></tr><tr><td>  bcmRxDecapIP</td><td> Decap IP Tunnel
 </td></tr><tr><td>  bcmRxDecapTRILL</td><td> Decap TRILL Tunnel
 </td></tr><tr><td>  bcmRxDecapL2MPLS1LABEL</td><td> Decap MPLS 1 Label, L2 payload, no Control Word present
 </td></tr><tr><td>  bcmRxDecapL2MPLS2LABEL</td><td> Decap MPLS 2 Label, L2 payload, no Control Word present
 </td></tr><tr><td>  bcmRxDecapL2MPLS1LABELCW</td><td> Decap MPLS 1 Label, L2 payload, Control Word present
 </td></tr><tr><td>  bcmRxDecapL2MPLS2LABELCW</td><td> Decap MPLS 2 Label, L2 payload, Control Word present
 </td></tr><tr><td>  bcmRxDecapL3MPLS1LABEL</td><td> Decap MPLS 1 Label, L3 payload, no Control Word present
 </td></tr><tr><td>  bcmRxDecapL3MPLS2LABEL</td><td> Decap MPLS 2 Label, L3 payload, no Control Word present
 </td></tr><tr><td>  bcmRxDecapL3MPLS1LABELCW</td><td> Decap MPLS 1 Label, L3 payload, Control Word present
 </td></tr><tr><td>  bcmRxDecapL3MPLS2LABELCW</td><td> Decap MPLS 2 Label, L3 payload, Control Word present
 </td></tr><tr><td>  bcmRxDecapWTP2AC</td><td> Decap WTP2AC Tunnel
 </td></tr><tr><td>  bcmRxDecapAC2AC</td><td> Decap AC2AC Tunnel
 </td></tr></tbody></table><p>        The following new elements of <tt>bcm_pkt_t</tt> structure have been added in this release
        with the new packet flags in flags2 field.

<a name=bcm_pkt_t></a>
<h3>Table 52:   bcm_pkt_t Structure Description
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> Field
 </b></td><td><b> Type
 </b></td><td><b> Description
 </b></td></tr><tr><td> <tt>rx_decap_tunnel</tt>
 </td><td><tt>bcm_rx_decap_tunnel_t</tt></td><td>  For receive only, type of outer tunnel decapped. See  <a href="#bcm_rx_decap_tunnel_type">Table 51:  Rx Decap Tunnel Types 
 </a>  </td></tr><tr><td> <tt>src_vport</tt>
 </td><td><tt>bcm_gport_t</tt></td><td> PPH.In-LIF-or-In-RIF field
 </td></tr><tr><td> <tt>dst_vport</tt>
 </td><td><tt>bcm_gport_t</tt></td><td> FTMH.<tt>OUTLIF_MCID</tt> field.If <tt>dest_port</tt> != -1 then outlif, otherwise MCID
 </td></tr><tr><td> <tt>fwd_hdr_offset</tt>
 </td><td><tt>uint32</tt></td><td> the Forwarding-Header-Offset (in bytes) from start of packet, i.e. PPH.<tt>FWD_HEADER_OFFSET</tt>
 </td></tr><tr><td> <tt>snoop_cmnd</tt>
 </td><td><tt>int</tt></td><td> indicates the two msb bits in Snoop-Command (PPH.<tt>SNOOP_CPU_CODE</tt>)
 </td></tr><tr><td> <tt>stk_dst_gport</tt>
 </td><td><tt>bcm_gport_t</tt></td><td> Stacking destination port (FMTH.DSP-Ext).
 </td></tr><tr><td> <tt>stk_route_tm_domains</tt>
 </td><td><tt>uint32</tt></td><td> Bitmap of the traversed TM domains (FMTH.Stacking_Route-History)
 </td></tr><tr><td> <tt>oam_hdr_offset</tt>
 </td><td><tt>uint32</tt></td><td> Distance (in bytes) to OAM header from start of packet
 </td></tr></tbody></table>
<a name=pkt_flags2_table></a>
<h3>Table 53:          Packet flags2 Flags Descriptions
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Flag</b></td><td> Description
 </td></tr><tr><td> <tt>BCM_PKT_F2_SNOOPED</tt>
 </td><td> This flag indicates the Packet was snooped.
 </td></tr><tr><td> <tt>BCM_PKT_F2_UNKNOWN_DEST</tt>
 </td><td> packet has unknown destination.
 </td></tr></tbody></table><p><br><hr noshade><a name="policer"></a>
<h3>Section 3.4.23:   Policer Configuration
</h3>
<p>        New policer group modes of bcmPolicerGroupModeIntPriCascade and
        bcmPolicerGroupModeIntPriCascadeWithCoupling with the policer flags
        <tt>BCM_POLICER_BW_SHARING_GROUP_START</tt> and <tt>BCM_POLICER_BW_SHARING_GROUP_END</tt>
        have been added in this release.
<h3>Table 54:   Policer Group Modes
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Mode</b></td><td><b> Description
 </b></td></tr><tr><td> bcmPolicerGroupModeIntPriCascade
 </td><td> A set of policers(max 8) selected based on internal priority,
              wherein excess bandwidth can overflow from
              high priority bucket to low priority bucket
</td></tr><tr><td> bcmPolicerGroupModeIntPriCascadeWithCoupling
 </td><td> A set of policers(max 4) selected based on internal priority,
              wherein excess bandwidth can overflow from high priority bucket to low priority bucket,
              and from low priority green bucket to high priority yellow
 </td></tr></tbody></table><h3>Table 55:   Policer Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td> <tt>BCM_POLICER_BW_SHARING_GROUP_START</tt>
 </td><td> Policer corresponds to the start of bandwidth sharing group(cascade chain).
 </td></tr><tr><td> <tt>BCM_POLICER_BW_SHARING_GROUP_END</tt>
 </td><td> Policer corresponds to the end of bandwidth sharing group(cascade chain).
 </td></tr></tbody></table><p><br><hr noshade><a name="port"></a>
<h3>Section 3.4.24:   Port Configuration
</h3>
<p>        Two PCS controls have been added as below.

<a name=BCMPortControlPCS_table></a>
<h3>Table 56:   bcm_port_pcs_t
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td>  Value</td><td> Description
 </td></tr><tr><td>  bcmPortPCS64b66bRsFec</td><td> 64b66bRsFec
 </td></tr><tr><td>  bcmPortPCS64b66bLowLatencyRsFec</td><td> 64b66bLowLatencyRsFec
 </td></tr></tbody></table><p>        Three PRBS Polynomial types have been added as below in this release.

<a name=BCM_PORT_PRBS_table></a>
<h3>Table 57:   PRBS Values
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td>  <tt>BCM_PORT_PRBS_POLYNOMIAL_X9_X5_1</tt></td><td> polynomial = x^9 + x^5 + 1
 </td></tr><tr><td>  <tt>BCM_PORT_PRBS_POLYNOMIAL_X11_X9_1</tt></td><td> polynomial = x^11 + x^9 + 1
 </td></tr><tr><td>  <tt>BCM_PORT_PRBS_POLYNOMIAL_X58_X31_1</tt></td><td> polynomial = x^58 + x^31 + 1
 </td></tr></tbody></table><p>        Below class types have been added for <tt>bcm_port_class_set</tt>() and <tt>bcm_port_class_get</tt>() functions.

<a name=PORT_CLASS_v></a>
<h3>Table 58:   bcm_port_class_t
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td>  bcmPortClassFieldIngressVlanTranslation</td><td> Class for field stage Ingress Vlan Translation
 </td></tr><tr><td>  bcmPortClassFieldIngressTunnelTerminated</td><td> Class for field stage Ingress Tunnel Terminated
 </td></tr></tbody></table><p>        Below port control types has been added for <tt>bcm_port_control_set</tt>() and
        <tt>bcm_port_control_get</tt>() functions.

<a name=PORT_CONTROL_v></a>
<h3>Table 59:   bcm_port_control_t
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td>  bcmPortControlBridge</td><td> Enable/Disable local port bridging
 </td></tr><tr><td> bcmPortControlLlfcCellsCongestionIndEnable
 </td><td> EnableDisable extracting cells congestion indication from LLFC cells
 </td></tr></tbody></table><p>        Several BCM_PORT_PHY_CONTROL_xxx configuration types have been added.

<a name=PORT_PHY_v></a>
<h3>Table 60:   bcm_port_phy_control_t
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td> <tt>BCM_PORT_PHY_CONTROL_DIGITAL_TEMP</tt>
 </td><td> Returns the internally derived temperature (celcius degree) of the die
              for the digital section
 </td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_ANALOG_TEMP</tt>
 </td><td> Returns the internally derived temperature (celcius degree) of the die
              for the analog section
 </td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_TX_FIR_PRE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_TX_FIR_MAIN</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_TX_FIR_POST</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_TX_FIR_POST2</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_TX_FIR_POST3</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_PMA_OS</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_SCR_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_ENCODE_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_CL48_CHECK_END</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_BLK_SYNC_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_REORDER_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_CL36_EN</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_DESCR1_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_DEC1_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_DESKEW_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_DESC2_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_DESC2_BYTE_DEL</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_BRCM64B66_DESCR</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_SGMII_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_CLKCNT0</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_CLKCNT1</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_LPCNT0</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_LPCNT1</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_MAC_CGC</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_PCS_REPCNT</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_PCS_CRDTEN</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_PCS_CLKCNT</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_PCS_CGC</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_HTO_CL72_EN</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_ENTRY</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_HCD</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_PMA_OS</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_SCR_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_ENCODE_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_CL48_CHECK_END</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_BLK_SYNC_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_REORDER_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_CL36_EN</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_DESCR1_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_DEC1_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_DESKEW_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_DESC2_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_DESC2_BYTE_DEL</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_BRCM64B66_DESCR</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_SGMII_MODE</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_CLKCNT0</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_CLKCNT1</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_LPCNT0</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_LPCNT1</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_MAC_CGC</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_PCS_REPCNT</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_PCS_CRDTEN</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_PCS_CLKCNT</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_PCS_CGC</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_PCS_SPEED_ST_CL72_EN</tt>
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_LOOPBACK_PMD</tt> 
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_TX_PATTERN_GEN_ENABLE</tt> 
 </td><td></td></tr><tr><td> <tt>BCM_PORT_PHY_CONTROL_TX_PATTERN_LENGTH</tt> 
 </td><td></td></tr></tbody></table><p>        Two Internal Port flags as below have been added for <tt>bcm_port_internal_get</tt>() function.
<h3>Table 61:   Internal Port Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Flag</b></td><td><b> Meaning
 </b></td></tr><tr><td>  <tt>BCM_PORT_INTERNAL_CONF_SCOPE_CORE0</tt></td><td> core 0 indication
 </td></tr><tr><td>  <tt>BCM_PORT_INTERNAL_CONF_SCOPE_CORE1</tt></td><td> core 1 indication
 </td></tr></tbody></table><p>        The flag that allows remapping an encapsulation to a port on a different core has been added
        for API <tt>bcm_port_encap_map_set</tt>() and <tt>bcm_port_encap_map_get</tt>().
<p>        New <tt>bcm_port_stat_sync_get</tt>/get32() and <tt>bcm_port_stat_counter_sync_get</tt>() are added in this release.
<p><hr noshade>
<h3>APIs for Section 3.4.24:  Port Configuration
</h3>
<a name=bcm_port_encap_map_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_port_encap_map_set</tt><br>
</h2>

<blockquote>
	Set the encapsulation to port mapping from <tt>encap_id</tt> to port.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/port.h&gt;
	int 
	bcm_port_encap_map_set(
	    int unit, 
	    uint32 flags, 
	    bcm_if_t encap_id, 
	    bcm_gport_t port);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
     (IN) Unit number
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) API flags, Supported flags: <tt>BCM_PORT_ENCAP_MAP_ALLOW_CORE_CHANGE</tt>
 </td></tr>
<tr><td class="arg" valign="top"><tt>encap_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) encapsulation ID to map from
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) port to map to
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set the encapsulation to port mapping from <tt>encap_id</tt> to port.
	Currently used only for egress multicast mapping of outlif to local port.
	By default the API will not allow remapping an encapsulation to a port on a different core,
        due to hardware limitations. 
	If using the <tt>BCM_PORT_ENCAP_MAP_ALLOW_CORE_CHANGE</tt> flag this will be allowed, and it would be
        the user's responsibility to make sure this outlif is not used in any outlif-only replication
        of any (egress) multicast group.
	Not adhering will result in wrong behavior by the hardware.
</blockquote><h3>RETURNS</h3><blockquote>
	<tt>BCM_E_XXX</tt>
</blockquote>
<a name=bcm_port_encap_map_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_port_encap_map_get</tt><br>
</h2>

<blockquote>
	Get the encapsulation to port mapping from <tt>encap_id</tt>.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/port.h&gt;
	int 
	bcm_port_encap_map_get(
	    int unit, 
	    uint32 flags, 
	    bcm_if_t encap_id, 
	    bcm_gport_t *port);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
     (IN) Unit number
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) API flags, currently unused
 </td></tr>
<tr><td class="arg" valign="top"><tt>encap_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) encapsulation ID mapped from
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) port mapped to
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get the encapsulation to port mapping from <tt>encap_id</tt>.
	Currently used only for egress multicast mapping of outlif to local port.
</blockquote><h3>RETURNS</h3><blockquote>
	<tt>BCM_E_XXX</tt>
</blockquote>
<a name=bcm_port_stat_sync_get></a>
<a name=bcm_port_stat_sync_get32></a>
<hr noshade>
<h2 class="api">
<tt>bcm_port_stat_sync_get</tt><br>
<tt>bcm_port_stat_sync_get32</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve port counter value for 
	specified port statistic type.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/port.h&gt;
	int 
	bcm_port_stat_sync_get(
	    int unit, 
	    bcm_gport_t port, 
	    bcm_port_stat_t stat, 
	    uint64 *val);

	int 
	bcm_port_stat_sync_get32(
	    int unit, 
	    bcm_gport_t port, 
	    bcm_port_stat_t stat, 
	    uint32 *val);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) GPORT ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve.
 </td></tr>
<tr><td class="arg" valign="top"><tt>val</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to a counter value.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_port_stat_get</tt>(), value returned is software accumulated 
	counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	<tt>BCM_E_XXX</tt>
</blockquote>
<a name=bcm_port_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_port_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve counter values for 
	specified gport based on port statistic type. 
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/port.h&gt;
	int 
	bcm_port_stat_counter_sync_get(
	    int              unit,
	    bcm_gport_t      port,
	    bcm_port_stat_t  stat,
	    uint32           num_entries,
	    uint32           *counter_indexes,
	    bcm_stat_value_t *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) GPORT ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve that is, ingress/egress byte/packet
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_port_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<br><hr noshade><a name="ptp"></a>
<h3>Section 3.4.25:   Precision Time Protocol
</h3>
<p>        The resolution of the Bridge Time is corrected to seconds. It was nanoseconds as show in API guide.
 <blockquote><pre>/* PTP Servo Configuration Data Type */
typedef struct <tt>bcm_ptp_servo_config_s</tt> {
    ...
    uint32 <tt>bridge_time</tt>;                 /* Bridge time in seconds */
    ...
} <tt>bcm_ptp_servo_config_t</tt>;
</pre></blockquote><p>        Three new fields of data type <tt>bcm_ptp_foreign_master_entry_t</tt> have been added in this release.
 <blockquote><pre>typedef struct <tt>bcm_ptp_foreign_master_entry_s</tt> {
    ...
    uint16 <tt>offset_scaled_log_variance</tt>;       /* log variance field of announce msg. */
    <tt>bcm_ptp_clock_accuracy_t</tt> <tt>clock_accuracy</tt>; /* Clock Accuracy */
    uint16 <tt>steps_removed</tt>;                    /* steps removed field of announce msg. */
} <tt>bcm_ptp_foreign_master_entry_t</tt>;
</pre></blockquote><p>	New APIs have been added as following with the required data types and defines:
<blockquote><pre>/* ESMC definitions and data types. */
typedef enum <tt>bcm_esmc_network_option_e</tt> {
    bcm_esmc_network_option_g781_I = 1, 
    bcm_esmc_network_option_g781_II = 2, 
    bcm_esmc_network_option_g781_III = 3 
} <tt>bcm_esmc_network_option_t</tt>;

typedef enum <tt>bcm_esmc_quality_level_e</tt> {
    bcm_esmc_g781_I_ql_prc = 0x0100, 
    bcm_esmc_g781_I_ql_ssua = 0x0101, 
    bcm_esmc_g781_I_ql_ssub = 0x0102, 
    bcm_esmc_g781_I_ql_sec = 0x0103, 
    bcm_esmc_g781_I_ql_dnu = 0x0104, 
    bcm_esmc_g781_I_ql_inv0 = 0x010f, 
    bcm_esmc_g781_I_ql_inv1 = 0x011f, 
    bcm_esmc_g781_I_ql_inv3 = 0x013f, 
    bcm_esmc_g781_I_ql_inv5 = 0x015f, 
    bcm_esmc_g781_I_ql_inv6 = 0x016f, 
    bcm_esmc_g781_I_ql_inv7 = 0x017f, 
    bcm_esmc_g781_I_ql_inv9 = 0x019f, 
    bcm_esmc_g781_I_ql_inv10 = 0x01af, 
    bcm_esmc_g781_I_ql_inv12 = 0x01cf, 
    bcm_esmc_g781_I_ql_inv13 = 0x01df, 
    bcm_esmc_g781_I_ql_inv14 = 0x01ef, 
    bcm_esmc_g781_I_ql_failed = 0x01ff, 
    bcm_esmc_g781_I_ql_nsupp = 0x01ff, 
    bcm_esmc_g781_I_ql_unc = 0x01ff, 
    bcm_esmc_g781_II_ql_prs = 0x0200, 
    bcm_esmc_g781_II_ql_stu = 0x0201, 
    bcm_esmc_g781_II_ql_st2 = 0x0202, 
    bcm_esmc_g781_II_ql_tnc = 0x0203, 
    bcm_esmc_g781_II_ql_st3e = 0x0204, 
    bcm_esmc_g781_II_ql_st3 = 0x0205, 
    bcm_esmc_g781_II_ql_smc = 0x0206, 
    bcm_esmc_g781_II_ql_prov = 0x0207, 
    bcm_esmc_g781_II_ql_dus = 0x0208, 
    bcm_esmc_g781_II_ql_inv2 = 0x022f, 
    bcm_esmc_g781_II_ql_inv3 = 0x023f, 
    bcm_esmc_g781_II_ql_inv5 = 0x025f, 
    bcm_esmc_g781_II_ql_inv6 = 0x026f, 
    bcm_esmc_g781_II_ql_inv8 = 0x028f, 
    bcm_esmc_g781_II_ql_inv9 = 0x029f, 
    bcm_esmc_g781_II_ql_inv11 = 0x02bf, 
    bcm_esmc_g781_II_ql_failed = 0x02ff, 
    bcm_esmc_g781_II_ql_nsupp = 0x02ff, 
    bcm_esmc_g781_II_ql_unc = 0x02ff, 
    bcm_esmc_g781_III_ql_unk = 0x0300, 
    bcm_esmc_g781_III_ql_sec = 0x0301, 
    bcm_esmc_g781_III_ql_inv1 = 0x031f, 
    bcm_esmc_g781_III_ql_inv2 = 0x032f, 
    bcm_esmc_g781_III_ql_inv3 = 0x033f, 
    bcm_esmc_g781_III_ql_inv4 = 0x034f, 
    bcm_esmc_g781_III_ql_inv5 = 0x035f, 
    bcm_esmc_g781_III_ql_inv6 = 0x036f, 
    bcm_esmc_g781_III_ql_inv7 = 0x037f, 
    bcm_esmc_g781_III_ql_inv8 = 0x038f, 
    bcm_esmc_g781_III_ql_inv9 = 0x039f, 
    bcm_esmc_g781_III_ql_inv10 = 0x03af, 
    bcm_esmc_g781_III_ql_inv12 = 0x03cf, 
    bcm_esmc_g781_III_ql_inv13 = 0x03df, 
    bcm_esmc_g781_III_ql_inv14 = 0x03ef, 
    bcm_esmc_g781_III_ql_inv15 = 0x03ff, 
    bcm_esmc_g781_III_ql_failed = 0x03ff, 
    bcm_esmc_g781_III_ql_nsupp = 0x03ff, 
    bcm_esmc_g781_III_ql_unc = 0x03ff, 
    <tt>bcm_esmc_ql_unresolvable</tt> = 0xffff 
} <tt>bcm_esmc_quality_level_t</tt>;

typedef enum <tt>bcm_esmc_pdu_type_e</tt> {
    <tt>bcm_esmc_pdu_type_info</tt>, 
    <tt>bcm_esmc_pdu_type_event</tt> 
} <tt>bcm_esmc_pdu_type_t</tt>;

typedef struct <tt>bcm_esmc_pdu_data_s</tt> {
    <tt>bcm_mac_t</tt> <tt>source_mac</tt>; 
    <tt>bcm_esmc_pdu_type_t</tt> <tt>pdu_type</tt>; 
    <tt>bcm_esmc_quality_level_t</tt> ql; 
    uint8 <tt>ssm_code</tt>; 
} <tt>bcm_esmc_pdu_data_t</tt>;

typedef int (*<tt>bcm_esmc_rx_cb</tt>)(
    int unit, 
    int <tt>stack_id</tt>, 
    int <tt>ingress_port</tt>, 
    <tt>bcm_esmc_pdu_data_t</tt> *<tt>pdu_data</tt>);

/* T-DPLL definitions and data types. */
#define <tt>BCM_TDPLL_INPUT_CLOCK_NUM_GPIO</tt>  (6)        
#define <tt>BCM_TDPLL_INPUT_CLOCK_NUM_SYNCE</tt> (2)        
#define <tt>BCM_TDPLL_INPUT_CLOCK_NUM_1588</tt>  (2)        
#define <tt>BCM_TDPLL_INPUT_CLOCK_NUM_MAX</tt>   (<tt>BCM_TDPLL_INPUT_CLOCK_NUM_GPIO</tt> +  \
			   <tt>BCM_TDPLL_INPUT_CLOCK_NUM_SYNCE</tt> + \
			   <tt>BCM_TDPLL_INPUT_CLOCK_NUM_1588</tt>) 

#define <tt>BCM_TDPLL_OUTPUT_CLOCK_NUM_BROADSYNC</tt> (2)        
#define <tt>BCM_TDPLL_OUTPUT_CLOCK_NUM_SYNCE</tt>    (2)        
#define <tt>BCM_TDPLL_OUTPUT_CLOCK_NUM_1588</tt>     (1)        
#define <tt>BCM_TDPLL_OUTPUT_CLOCK_NUM_GPIO</tt>     (6)        
#define <tt>BCM_TDPLL_OUTPUT_CLOCK_NUM_MAX</tt>      (<tt>BCM_TDPLL_OUTPUT_CLOCK_NUM_BROADSYNC</tt> + \
			   <tt>BCM_TDPLL_OUTPUT_CLOCK_NUM_SYNCE</tt> + \
			   <tt>BCM_TDPLL_OUTPUT_CLOCK_NUM_1588</tt> + \
			   <tt>BCM_TDPLL_OUTPUT_CLOCK_NUM_GPIO</tt>) 

#define <tt>BCM_TDPLL_DPLL_INSTANCE_NUM_MAX</tt> (<tt>BCM_TDPLL_OUTPUT_CLOCK_NUM_MAX</tt> - \
			   <tt>BCM_TDPLL_OUTPUT_CLOCK_NUM_GPIO</tt>) 

typedef enum <tt>bcm_tdpll_dpll_bandwidth_units_e</tt> {
    bcm_tdpll_dpll_bandwidth_mHz, 
    bcm_tdpll_dpll_bandwidth_Hz, 
    bcm_tdpll_dpll_bandwidth_kHz 
} <tt>bcm_tdpll_dpll_bandwidth_units_t</tt>;

typedef struct <tt>bcm_tdpll_dpll_bandwidth_s</tt> {
    uint32 value; 
    <tt>bcm_tdpll_dpll_bandwidth_units_t</tt> units; 
} <tt>bcm_tdpll_dpll_bandwidth_t</tt>;

typedef enum <tt>bcm_tdpll_dpll_phase_mode_e</tt> {
    <tt>bcm_tdpll_dpll_phase_mode_none</tt>, 
    <tt>bcm_tdpll_dpll_phase_mode_pbo</tt>, 
    <tt>bcm_tdpll_dpll_phase_mode_pboslew</tt> 
} <tt>bcm_tdpll_dpll_phase_mode_t</tt>;

typedef struct <tt>bcm_tdpll_dpll_phase_control_s</tt> {
    <tt>bcm_tdpll_dpll_phase_mode_t</tt> mode; 
    int <tt>offset_ns</tt>; 
} <tt>bcm_tdpll_dpll_phase_control_t</tt>;

typedef struct <tt>bcm_tdpll_dpll_properties_s</tt> {
    <tt>bcm_tdpll_dpll_bandwidth_t</tt> bandwidth; 
    <tt>bcm_tdpll_dpll_phase_control_t</tt> <tt>phase_control</tt>; 
} <tt>bcm_tdpll_dpll_properties_t</tt>;

typedef struct <tt>bcm_tdpll_dpll_bindings_s</tt> {
    <tt>SHR_BITDCL</tt> <tt>input_clocks</tt>[<tt><tt>_SHR_BITDCLSIZE</tt></tt>(<tt>BCM_TDPLL_INPUT_CLOCK_NUM_MAX</tt>)]; 
    <tt>SHR_BITDCL</tt> <tt>output_clocks</tt>[<tt><tt>_SHR_BITDCLSIZE</tt></tt>(<tt>BCM_TDPLL_OUTPUT_CLOCK_NUM_MAX</tt>)]; 
} <tt>bcm_tdpll_dpll_bindings_t</tt>;

typedef struct <tt>bcm_tdpll_dpll_instance_s</tt> {
    int index; 
    <tt>bcm_tdpll_dpll_bindings_t</tt> bindings; 
    <tt>bcm_tdpll_dpll_properties_t</tt> properties; 
    int reference; 
} <tt>bcm_tdpll_dpll_instance_t</tt>;

typedef struct <tt>bcm_tdpll_input_clock_l1mux_s</tt> {
    int index; 
    int port; 
} <tt>bcm_tdpll_input_clock_l1mux_t</tt>;

typedef struct <tt>bcm_tdpll_input_clock_frequency_s</tt> {
    uint32 clock; 
    uint32 tsevent; 
    int <tt>tsevent_quotient</tt>; 
} <tt>bcm_tdpll_input_clock_frequency_t</tt>;

typedef enum <tt>bcm_tdpll_input_clock_monitor_type_e</tt> {
    <tt>bcm_tdpll_input_clock_monitor_type_soft_warn</tt>, 
    <tt>bcm_tdpll_input_clock_monitor_type_hard_accept</tt>, 
    <tt>bcm_tdpll_input_clock_monitor_type_hard_reject</tt> 
} <tt>bcm_tdpll_input_clock_monitor_type_t</tt>;

typedef struct <tt>bcm_tdpll_input_clock_monitor_s</tt> {
    uint64 <tt>tsevent_dt</tt>; 
    uint64 <tt>tsevent_time</tt>; 
    uint64 <tt>tsevent_num</tt>; 
    uint64 <tt>dt_ns</tt>; 
    uint64 <tt>dtref_ns</tt>; 
    uint64 <tt>dt_sum_ns</tt>; 
    uint64 <tt>dtref_sum_ns</tt>; 
    uint64 <tt>prior_evnum</tt>; 
    uint32 <tt>numev_sum</tt>; 
    int <tt>freq_error_ppb</tt>; 
    int <tt>over_soft_warn_threshold</tt>; 
    int <tt>under_hard_accept_threshold</tt>; 
    int <tt>over_hard_reject_threshold</tt>; 
    uint32 <tt>num_missing_tsevent</tt>; 
} <tt>bcm_tdpll_input_clock_monitor_t</tt>;

typedef struct <tt>bcm_tdpll_input_clock_select_s</tt> {
    <tt>bcm_esmc_quality_level_t</tt> ql; 
    int priority; 
    int lockout; 
} <tt>bcm_tdpll_input_clock_select_t</tt>;

typedef struct <tt>bcm_tdpll_input_clock_s</tt> {
    int index; 
    <tt>bcm_tdpll_input_clock_l1mux_t</tt> l1mux; 
    <tt>bcm_mac_t</tt> mac; 
    uint32 state; 
    <tt>bcm_tdpll_input_clock_frequency_t</tt> frequency; 
    <tt>bcm_tdpll_input_clock_monitor_t</tt> monitor; 
    <tt>bcm_tdpll_input_clock_select_t</tt> select; 
    int <tt>dpll_use</tt>[<tt>BCM_TDPLL_DPLL_INSTANCE_NUM_MAX</tt>]; 
} <tt>bcm_tdpll_input_clock_t</tt>;

typedef struct <tt>bcm_tdpll_input_clock_monitor_cb_data_s</tt> {
    int index; 
    <tt>bcm_tdpll_input_clock_monitor_type_t</tt> <tt>monitor_type</tt>; 
    int <tt>monitor_value</tt>; 
} <tt>bcm_tdpll_input_clock_monitor_cb_data_t</tt>;

typedef int (*<tt>bcm_tdpll_input_clock_monitor_cb</tt>)(
    int unit, 
    int <tt>stack_id</tt>, 
    <tt>bcm_tdpll_input_clock_monitor_cb_data_t</tt> *<tt>cb_data</tt>);

typedef struct <tt>bcm_tdpll_input_clock_selector_cb_data_s</tt> {
    int <tt>dpll_index</tt>; 
    int <tt>prior_selected_clock</tt>; 
    int <tt>selected_clock</tt>; 
} <tt>bcm_tdpll_input_clock_selector_cb_data_t</tt>;

typedef int (*<tt>bcm_tdpll_input_clock_selector_cb</tt>)(
    int unit, 
    int <tt>stack_id</tt>, 
    <tt>bcm_tdpll_input_clock_selector_cb_data_t</tt> *<tt>cb_data</tt>);

typedef struct <tt>bcm_tdpll_output_clock_frequency_s</tt> {
    uint32 synth; 
    uint32 tsevent; 
    int <tt>tsevent_quotient</tt>; 
    uint32 deriv; 
    int <tt>deriv_quotient</tt>; 
} <tt>bcm_tdpll_output_clock_frequency_t</tt>;

typedef struct <tt>bcm_tdpll_output_clock_s</tt> {
    int index; 
    uint32 state; 
    <tt>bcm_tdpll_output_clock_frequency_t</tt> frequency; 
} <tt>bcm_tdpll_output_clock_t</tt>;

typedef enum <tt>bcm_tdpll_holdover_mode_e</tt> {
    <tt>bcm_tdpll_holdover_mode_instantaneous</tt>, 
    <tt>bcm_tdpll_holdover_mode_avg1s</tt>, 
    <tt>bcm_tdpll_holdover_mode_manual</tt>, 
    <tt>bcm_tdpll_holdover_mode_fast_average</tt>, 
    <tt>bcm_tdpll_holdover_mode_slow_average</tt> 
} <tt>bcm_tdpll_holdover_mode_t</tt>;

/* Frequency correction */
typedef int32 <tt>bcm_tdpll_frequency_correction_t</tt>;

typedef struct <tt>bcm_tdpll_holdover_data_s</tt> {
    <tt>bcm_tdpll_frequency_correction_t</tt> <tt>freq_instantaneous</tt>; 
    <tt>bcm_tdpll_frequency_correction_t</tt> <tt>freq_avg1s</tt>; 
    <tt>bcm_tdpll_frequency_correction_t</tt> <tt>freq_manual</tt>; 
    <tt>bcm_tdpll_frequency_correction_t</tt> <tt>freq_fast_average</tt>; 
    <tt>bcm_tdpll_frequency_correction_t</tt> <tt>freq_slow_average</tt>; 
    int <tt>freq_fast_average_valid</tt>; 
    int <tt>freq_slow_average_valid</tt>; 
    <tt>bcm_tdpll_holdover_mode_t</tt> mode; 
} <tt>bcm_tdpll_holdover_data_t</tt>;
</pre></blockquote><p><hr noshade>
<h3>APIs for Section 3.4.25:  Precision Time Protocol
</h3>
<a name=bcm_esmc_tx></a>
<hr noshade>
<h2 class="api">
<tt>bcm_esmc_tx</tt><br>
</h2>

<blockquote>
	ESMC PDU transmit (Tx).
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_esmc_tx(
	    int unit, 
	    int stack_id, 
	    bcm_pbmp_t pbmp, 
	    bcm_esmc_pdu_data_t *esmc_pdu_data);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>pbmp</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Tx port bitmap.
 </td></tr>
<tr><td class="arg" valign="top"><tt>esmc_pdu_data(IN)</tt></td><td>&nbsp;&nbsp;</td><td>
 ESMC PDU data.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	ESMC PDU transmit (Tx).
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_esmc_rx_callback_register></a>
<hr noshade>
<h2 class="api">
<tt>bcm_esmc_rx_callback_register</tt><br>
</h2>

<blockquote>
	Register ESMC PDU Rx callback.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_esmc_rx_callback_register(
	    int unit, 
	    int stack_id, 
	    bcm_esmc_rx_cb rx_cb);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>rx_cb</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) ESMC PDU Rx callback function pointer.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Register ESMC PDU Rx callback.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_esmc_rx_callback_unregister></a>
<hr noshade>
<h2 class="api">
<tt>bcm_esmc_rx_callback_unregister</tt><br>
</h2>

<blockquote>
	Unregister ESMC PDU Rx callback.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_esmc_rx_callback_unregister(
	    int unit, 
	    int stack_id);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Unregister ESMC PDU Rx callback.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_esmc_tunnel_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_esmc_tunnel_get</tt><br>
</h2>

<blockquote>
	Get ESMC PDU tunneling-enabled Boolean.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_esmc_tunnel_get(
	    int unit, 
	    int stack_id, 
	    int *enable);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>enable</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Enable Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get ESMC PDU tunneling-enabled Boolean.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_esmc_tunnel_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_esmc_tunnel_set</tt><br>
</h2>

<blockquote>
	Set ESMC PDU tunneling-enabled Boolean.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_esmc_tunnel_set(
	    int unit, 
	    int stack_id, 
	    int enable);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>enable</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Enable Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set ESMC PDU tunneling-enabled Boolean.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_esmc_g781_option_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_esmc_g781_option_get</tt><br>
</h2>

<blockquote>
	Get ITU-T G.781 networking option for SyncE.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_esmc_g781_option_get(
	    int unit, 
	    int stack_id, 
	    bcm_esmc_network_option_t *g781_option);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>g781_option</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) ITU-T G.781 networking option.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get ITU-T G.781 networking option for SyncE.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_esmc_g781_option_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_esmc_g781_option_set</tt><br>
</h2>

<blockquote>
	Set ITU-T G.781 networking option for SyncE.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_esmc_g781_option_set(
	    int unit, 
	    int stack_id, 
	    bcm_esmc_network_option_t g781_option);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>g781_option</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) ITU-T G.781 networking option.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set ITU-T G.781 networking option for SyncE.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_esmc_QL_SSM_map></a>
<hr noshade>
<h2 class="api">
bcm_esmc_QL_SSM_map<br>
</h2>

<blockquote>
	Get synchronization status message (SSM) code corresponding to ITU-T
	G.781 quality level (QL).
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_esmc_QL_SSM_map(
	    int unit, 
	    bcm_esmc_network_option_t opt, 
	    bcm_esmc_quality_level_t ql, 
	    uint8 *ssm_code);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>opt</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) ITU-T G.781 networking option.
 </td></tr>
<tr><td class="arg" valign="top"><tt>ql</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) ITU-T G.781 quality level.
 </td></tr>
<tr><td class="arg" valign="top"><tt>ssm_code</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) SSM code.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get synchronization status message (SSM) code corresponding to ITU-T
	G.781 quality level (QL).
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_esmc_SSM_QL_map></a>
<hr noshade>
<h2 class="api">
bcm_esmc_SSM_QL_map<br>
</h2>

<blockquote>
	Get ITU-T G.781 quality level (QL) corresponding to synchronization
	status message (SSM) code.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_esmc_SSM_QL_map(
	    int unit, 
	    bcm_esmc_network_option_t opt, 
	    uint8 ssm_code, 
	    bcm_esmc_quality_level_t *ql);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>opt</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) ITU-T G.781 networking option.
 </td></tr>
<tr><td class="arg" valign="top"><tt>ssm_code</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) SSM code.
 </td></tr>
<tr><td class="arg" valign="top"><tt>ql</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) ITU-T G.781 quality level.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get ITU-T G.781 quality level (QL) corresponding to synchronization
	status message (SSM) code.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_dpll_bindings_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_dpll_bindings_get</tt><br>
</h2>

<blockquote>
	Get logical DPLL instance input/output bindings.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_dpll_bindings_get(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_tdpll_dpll_bindings_t *bindings);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>bindings</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) DPLL instance bindings.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get logical DPLL instance input/output bindings.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_dpll_bindings_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_dpll_bindings_set</tt><br>
</h2>

<blockquote>
	Set logical DPLL instance input/output bindings.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_dpll_bindings_set(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_tdpll_dpll_bindings_t *bindings);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>bindings</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance bindings.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set logical DPLL instance input/output bindings.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_dpll_reference_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_dpll_reference_get</tt><br>
</h2>

<blockquote>
	Get reference clocks for DPLL instances.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_dpll_reference_get(
	    int unit, 
	    int stack_id, 
	    int max_num_dpll, 
	    int *dpll_ref, 
	    int *num_dpll);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>max_num_dpll</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Maximum number of DPLL instances.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_ref</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) DPLL instance reference clocks.
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_dpll</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Number of DPLL instances.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get reference clocks for DPLL instances.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_dpll_bandwidth_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_dpll_bandwidth_get</tt><br>
</h2>

<blockquote>
	Get DPLL bandwidth.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_dpll_bandwidth_get(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_tdpll_dpll_bandwidth_t *bandwidth);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>bandwidth</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) DPLL bandwidth.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get DPLL bandwidth.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_dpll_bandwidth_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_dpll_bandwidth_set</tt><br>
</h2>

<blockquote>
	Set DPLL bandwidth.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_dpll_bandwidth_set(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_tdpll_dpll_bandwidth_t *bandwidth);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>bandwidth</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL bandwidth.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set DPLL bandwidth.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_dpll_phase_control_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_dpll_phase_control_get</tt><br>
</h2>

<blockquote>
	Get DPLL instance's phase control configuration.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_dpll_phase_control_get(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_tdpll_dpll_phase_control_t *phase_control);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>phase_control(OUT)</tt></td><td>&nbsp;&nbsp;</td><td>
 Phase control configuration.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get DPLL instance's phase control configuration.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_dpll_phase_control_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_dpll_phase_control_set</tt><br>
</h2>

<blockquote>
	Set DPLL instance's phase control configuration.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_dpll_phase_control_set(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_tdpll_dpll_phase_control_t *phase_control);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>phase_control(IN)</tt></td><td>&nbsp;&nbsp;</td><td>
 Phase control configuration.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set DPLL instance's phase control configuration.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_control></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_control</tt><br>
</h2>

<blockquote>
	Start/stop T-DPLL input clock monitoring, reference selection, and
	switching state machine
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_control(
	    int unit, 
	    int stack_id, 
	    int enable);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>enable</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Enable Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Start/stop T-DPLL input clock monitoring, reference selection, and
	switching state machine
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_mac_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_mac_get</tt><br>
</h2>

<blockquote>
	Get MAC address of input clock.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_mac_get(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    bcm_mac_t *mac);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>mac</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Input clock MAC address.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get MAC address of input clock.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_mac_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_mac_set</tt><br>
</h2>

<blockquote>
	Set MAC address of input clock.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_mac_set(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    bcm_mac_t *mac);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>mac</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock MAC address.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set MAC address of input clock.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_frequency_error_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_frequency_error_get</tt><br>
</h2>

<blockquote>
	Get fractional frequency error of an input clock from input-clock
	monitoring process.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_frequency_error_get(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    int *freq_error_ppb);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>freq_error_ppb(OUT)</tt></td><td>&nbsp;&nbsp;</td><td>
 Input clock fractional frequency error (ppb).
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get fractional frequency error of an input clock from input-clock
	monitoring process.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_threshold_state_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_threshold_state_get</tt><br>
</h2>

<blockquote>
	Get monitor threshold state of an input clock from input-clock
	monitoring process.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_threshold_state_get(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    bcm_tdpll_input_clock_monitor_type_t threshold_type, 
	    int *threshold_state);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>threshold_type(IN)</tt></td><td>&nbsp;&nbsp;</td><td>
 Input-clock monitoring threshold type.
 </td></tr>
<tr><td class="arg" valign="top"><tt>threshold_state(OUT)</tt></td><td>&nbsp;&nbsp;</td><td>
 Input-clock monitoring threshold state Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get monitor threshold state of an input clock from input-clock
	monitoring process.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_enable_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_enable_get</tt><br>
</h2>

<blockquote>
	Get input clock enable Boolean.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_enable_get(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    int *enable);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>enable</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Input clock enable Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get input clock enable Boolean.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_enable_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_enable_set</tt><br>
</h2>

<blockquote>
	Set input-clock enable Boolean.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_enable_set(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    int enable);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>enable</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock enable Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set input-clock enable Boolean.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_l1mux_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_l1mux_get</tt><br>
</h2>

<blockquote>
	Get L1 mux mapping (mux index and port number) of input clock.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_l1mux_get(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    bcm_tdpll_input_clock_l1mux_t *l1mux);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>l1mux</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) L1 mux mapping.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get L1 mux mapping (mux index and port number) of input clock.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_l1mux_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_l1mux_set</tt><br>
</h2>

<blockquote>
	Set L1 mux mapping (mux index and port number) of input clock.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_l1mux_set(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    bcm_tdpll_input_clock_l1mux_t *l1mux);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>l1mux</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) L1 mux mapping.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set L1 mux mapping (mux index and port number) of input clock.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_valid_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_valid_get</tt><br>
</h2>

<blockquote>
	Get valid Boolean of an input clock from input-clock monitoring
	process.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_valid_get(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    int *valid);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>valid</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Input clock valid Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get valid Boolean of an input clock from input-clock monitoring
	process.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_valid_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_valid_set</tt><br>
</h2>

<blockquote>
	Set input-clock valid Boolean from monitoring process.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_valid_set(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    int valid);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>valid</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock valid Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set input-clock valid Boolean from monitoring process.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_frequency_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_frequency_get</tt><br>
</h2>

<blockquote>
	Get input clock frequency.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_frequency_get(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    uint32 *clock_frequency, 
	    uint32 *tsevent_frequency);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_frequency(OUT)</tt></td><td>&nbsp;&nbsp;</td><td>
 Frequency (Hz).
 </td></tr>
<tr><td class="arg" valign="top"><tt>tsevent_frequency(OUT)</tt></td><td>&nbsp;&nbsp;</td><td>
 TS event frequency (Hz).
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get input clock frequency.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_frequency_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_frequency_set</tt><br>
</h2>

<blockquote>
	Set input clock frequency.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_frequency_set(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    uint32 clock_frequency, 
	    uint32 tsevent_frequency);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_frequency(IN)</tt></td><td>&nbsp;&nbsp;</td><td>
 Frequency (Hz).
 </td></tr>
<tr><td class="arg" valign="top"><tt>tsevent_frequency(IN)</tt></td><td>&nbsp;&nbsp;</td><td>
 TS event frequency (Hz).
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set input clock frequency.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_ql_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_ql_get</tt><br>
</h2>

<blockquote>
	Get input clock quality level (QL).
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_ql_get(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    bcm_esmc_quality_level_t *ql);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>ql</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) QL.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get input clock quality level (QL).
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_ql_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_ql_set</tt><br>
</h2>

<blockquote>
	Set input clock quality level (QL).
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_ql_set(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    bcm_esmc_quality_level_t ql);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>ql</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) QL.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set input clock quality level (QL).
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_priority_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_priority_get</tt><br>
</h2>

<blockquote>
	Get input clock priority for reference selection.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_priority_get(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    int *priority);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>priority</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Input clock priority.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get input clock priority for reference selection.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_priority_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_priority_set</tt><br>
</h2>

<blockquote>
	Set input clock priority for reference selection.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_priority_set(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    int priority);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>priority</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock priority.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set input clock priority for reference selection.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_lockout_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_lockout_get</tt><br>
</h2>

<blockquote>
	Get input clock lockout Boolean for reference selection.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_lockout_get(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    int *lockout);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>lockout</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Input clock lockout Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get input clock lockout Boolean for reference selection.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_lockout_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_lockout_set</tt><br>
</h2>

<blockquote>
	Set input clock lockout Boolean for reference selection.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_lockout_set(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    int lockout);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>lockout</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock lockout Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set input clock lockout Boolean for reference selection.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_monitor_interval_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_monitor_interval_get</tt><br>
</h2>

<blockquote>
	Get input clock monitoring interval.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_monitor_interval_get(
	    int unit, 
	    int stack_id, 
	    uint32 *monitor_interval);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>monitor_interval(OUT)</tt></td><td>&nbsp;&nbsp;</td><td>
 Input clock monitoring interval (sec).
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get input clock monitoring interval.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_monitor_interval_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_monitor_interval_set</tt><br>
</h2>

<blockquote>
	Set input clock monitoring interval.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_monitor_interval_set(
	    int unit, 
	    int stack_id, 
	    uint32 monitor_interval);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>monitor_interval(IN)</tt></td><td>&nbsp;&nbsp;</td><td>
 Input clock monitoring interval (sec).
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set input clock monitoring interval.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_monitor_threshold_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_monitor_threshold_get</tt><br>
</h2>

<blockquote>
	Get monitor threshold for input-clock valid classification required in
	reference selection.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_monitor_threshold_get(
	    int unit, 
	    int stack_id, 
	    bcm_tdpll_input_clock_monitor_type_t threshold_type, 
	    uint32 *threshold);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>threshold_type(IN)</tt></td><td>&nbsp;&nbsp;</td><td>
 Input clock monitoring threshold type.
 </td></tr>
<tr><td class="arg" valign="top"><tt>threshold</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Input clock monitoring threshold (ppb).
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get monitor threshold for input-clock valid classification required in
	reference selection.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_monitor_threshold_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_monitor_threshold_set</tt><br>
</h2>

<blockquote>
	Set monitor threshold for input-clock valid classification required in
	reference selection.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_monitor_threshold_set(
	    int unit, 
	    int stack_id, 
	    bcm_tdpll_input_clock_monitor_type_t threshold_type, 
	    uint32 threshold);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>threshold_type(IN)</tt></td><td>&nbsp;&nbsp;</td><td>
 Input-clock monitoring threshold type.
 </td></tr>
<tr><td class="arg" valign="top"><tt>threshold</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input-clock monitoring threshold (ppb).
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set monitor threshold for input-clock valid classification required in
	reference selection.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_ql_enabled_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_ql_enabled_get</tt><br>
</h2>

<blockquote>
	Get QL-enabled Boolean for reference selection.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_ql_enabled_get(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    int *ql_enabled);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>ql_enabled</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) QL-enabled Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get QL-enabled Boolean for reference selection.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_ql_enabled_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_ql_enabled_set</tt><br>
</h2>

<blockquote>
	Set QL-enabled Boolean for reference selection.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_ql_enabled_set(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    int ql_enabled);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>ql_enabled</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) QL-enabled Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set QL-enabled Boolean for reference selection.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_revertive_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_revertive_get</tt><br>
</h2>

<blockquote>
	Get revertive mode Boolean for reference selection and switching.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_revertive_get(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    int *revertive);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>revertive</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Revertive mode Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get revertive mode Boolean for reference selection and switching.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_revertive_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_revertive_set</tt><br>
</h2>

<blockquote>
	Set revertive mode Boolean for reference selection and switching.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_revertive_set(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    int revertive);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>revertive</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Revertive mode Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set revertive mode Boolean for reference selection and switching.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_best_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_best_get</tt><br>
</h2>

<blockquote>
	Get best (i.e. selected) reference for a DPLL instance.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_best_get(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    int *best_clock);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>best_clock</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Best / preferred input clock index.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get best (i.e. selected) reference for a DPLL instance.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_monitor_callback_register></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_monitor_callback_register</tt><br>
</h2>

<blockquote>
	Register input clock monitoring callback.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_monitor_callback_register(
	    int unit, 
	    int stack_id, 
	    bcm_tdpll_input_clock_monitor_cb monitor_cb);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>monitor_cb</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock monitoring callback function pointer.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Register input clock monitoring callback.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_monitor_callback_unregister></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_monitor_callback_unregister</tt><br>
</h2>

<blockquote>
	Unregister input clock monitoring callback.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_monitor_callback_unregister(
	    int unit, 
	    int stack_id);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Unregister input clock monitoring callback.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_selector_callback_register></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_selector_callback_register</tt><br>
</h2>

<blockquote>
	Register input clock reference selection callback.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_selector_callback_register(
	    int unit, 
	    int stack_id, 
	    bcm_tdpll_input_clock_selector_cb selector_cb);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>selector_cb</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Input clock selection callback function pointer
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Register input clock reference selection callback.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_input_clock_selector_callback_unregister></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_input_clock_selector_callback_unregister</tt><br>
</h2>

<blockquote>
	Unregister input clock reference selection callback.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_input_clock_selector_callback_unregister(
	    int unit, 
	    int stack_id);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Unregister input clock reference selection callback.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_output_clock_enable_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_output_clock_enable_get</tt><br>
</h2>

<blockquote>
	Get output clock enable Boolean.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_output_clock_enable_get(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    int *enable);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Output clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>enable</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Output clock enable Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get output clock enable Boolean.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_output_clock_enable_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_output_clock_enable_set</tt><br>
</h2>

<blockquote>
	Set output clock enable Boolean.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_output_clock_enable_set(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    int enable);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Output clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>enable</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Output clock enable Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set output clock enable Boolean.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_output_clock_synth_frequency_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_output_clock_synth_frequency_get</tt><br>
</h2>

<blockquote>
	Get output-clock (synthesizer) frequency.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_output_clock_synth_frequency_get(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    uint32 *synth_frequency, 
	    uint32 *tsevent_frequency);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Output clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>synth_frequency(OUT)</tt></td><td>&nbsp;&nbsp;</td><td>
 Synthesizer frequency (Hz).
 </td></tr>
<tr><td class="arg" valign="top"><tt>tsevent_frequency(OUT)</tt></td><td>&nbsp;&nbsp;</td><td>
 TS event frequency (Hz).
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get output-clock (synthesizer) frequency.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_output_clock_synth_frequency_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_output_clock_synth_frequency_set</tt><br>
</h2>

<blockquote>
	Set output-clock (synthesizer) frequency.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_output_clock_synth_frequency_set(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    uint32 synth_frequency, 
	    uint32 tsevent_frequency);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Output clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>synth_frequency(IN)</tt></td><td>&nbsp;&nbsp;</td><td>
 Synthesizer frequency (Hz).
 </td></tr>
<tr><td class="arg" valign="top"><tt>tsevent_frequency(IN)</tt></td><td>&nbsp;&nbsp;</td><td>
 TS event frequency (Hz).
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set output-clock (synthesizer) frequency.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_output_clock_deriv_frequency_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_output_clock_deriv_frequency_get</tt><br>
</h2>

<blockquote>
	Get synthesizer derivative-clock frequency.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_output_clock_deriv_frequency_get(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    uint32 *deriv_frequency);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Output clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>deriv_frequency(OUT)</tt></td><td>&nbsp;&nbsp;</td><td>
 Derivative clock frequency (Hz).
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get synthesizer derivative-clock frequency.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_output_clock_deriv_frequency_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_output_clock_deriv_frequency_set</tt><br>
</h2>

<blockquote>
	Set synthesizer derivative clock frequency.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_output_clock_deriv_frequency_set(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    uint32 deriv_frequency);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Output clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>deriv_frequency(OUT)</tt></td><td>&nbsp;&nbsp;</td><td>
 Derivative clock frequency (Hz).
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set synthesizer derivative clock frequency.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_output_clock_holdover_data_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_output_clock_holdover_data_get</tt><br>
</h2>

<blockquote>
	Get holdover configuration data.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_output_clock_holdover_data_get(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    bcm_tdpll_holdover_data_t *hdata);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Output clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>hdata</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Holdover configuration data.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get holdover configuration data.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_output_clock_holdover_frequency_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_output_clock_holdover_frequency_set</tt><br>
</h2>

<blockquote>
	Set manual holdover frequency correction.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_output_clock_holdover_frequency_set(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    bcm_tdpll_frequency_correction_t hfreq);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Output clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>hfreq</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Holdover frequency correction (ppt).
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set manual holdover frequency correction.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_output_clock_holdover_mode_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_output_clock_holdover_mode_get</tt><br>
</h2>

<blockquote>
	Get holdover mode.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_output_clock_holdover_mode_get(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    bcm_tdpll_holdover_mode_t *hmode);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Output clock index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>hmode</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Holdover mode.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get holdover mode.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_output_clock_holdover_mode_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_output_clock_holdover_mode_set</tt><br>
</h2>

<blockquote>
	Set holdover mode.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_output_clock_holdover_mode_set(
	    int unit, 
	    int stack_id, 
	    int clock_index, 
	    bcm_tdpll_holdover_mode_t hmode);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Output clock index
 </td></tr>
<tr><td class="arg" valign="top"><tt>hmode</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Holdover mode.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set holdover mode.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_output_clock_holdover_reset></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_output_clock_holdover_reset</tt><br>
</h2>

<blockquote>
	Reset holdover frequency calculations.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_output_clock_holdover_reset(
	    int unit, 
	    int stack_id, 
	    int clock_index);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>clock_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Output clock index.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Reset holdover frequency calculations.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_esmc_rx_state_machine></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_esmc_rx_state_machine</tt><br>
</h2>

<blockquote>
	Execute state machine for Rx ESMC PDU.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_esmc_rx_state_machine(
	    int unit, 
	    int stack_id, 
	    int ingress_port, 
	    bcm_esmc_pdu_data_t *esmc_pdu_data);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>ingress_port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Ingress port.
 </td></tr>
<tr><td class="arg" valign="top"><tt>esmc_pdu_data(IN)</tt></td><td>&nbsp;&nbsp;</td><td>
 ESMC PDU.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Execute state machine for Rx ESMC PDU.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_esmc_ql_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_esmc_ql_get</tt><br>
</h2>

<blockquote>
	Get quality level (QL) for ESMC.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_esmc_ql_get(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_esmc_quality_level_t *ql);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>ql</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) QL.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get quality level (QL) for ESMC.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_esmc_ql_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_esmc_ql_set</tt><br>
</h2>

<blockquote>
	Set quality level (QL) for ESMC.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_esmc_ql_set(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_esmc_quality_level_t ql);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>ql</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) QL.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set quality level (QL) for ESMC.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_esmc_holdover_ql_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_esmc_holdover_ql_get</tt><br>
</h2>

<blockquote>
	Get quality level (QL) for ESMC during holdover.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_esmc_holdover_ql_get(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_esmc_quality_level_t *ql);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>ql</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) QL.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get quality level (QL) for ESMC during holdover.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_esmc_holdover_ql_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_esmc_holdover_ql_set</tt><br>
</h2>

<blockquote>
	Set quality level (QL) for ESMC during holdover.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_esmc_holdover_ql_set(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_esmc_quality_level_t ql);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>ql</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) QL.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set quality level (QL) for ESMC during holdover.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_esmc_mac_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_esmc_mac_get</tt><br>
</h2>

<blockquote>
	Get MAC address for ESMC.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_esmc_mac_get(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_mac_t *mac);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>mac</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Local port MAC address.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get MAC address for ESMC.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_esmc_mac_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_esmc_mac_set</tt><br>
</h2>

<blockquote>
	Set MAC address for ESMC.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_esmc_mac_set(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_mac_t *mac);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>mac</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Local port MAC address.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set MAC address for ESMC.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_esmc_rx_enable_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_esmc_rx_enable_get</tt><br>
</h2>

<blockquote>
	Get ESMC PDU receive (Rx) enable state.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_esmc_rx_enable_get(
	    int unit, 
	    int stack_id, 
	    int *enable);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>enable</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) ESMC PDU receive enable Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get ESMC PDU receive (Rx) enable state.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_esmc_rx_enable_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_esmc_rx_enable_set</tt><br>
</h2>

<blockquote>
	Set ESMC PDU receive (Rx) enable state.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_esmc_rx_enable_set(
	    int unit, 
	    int stack_id, 
	    int enable);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>enable</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) ESMC PDU receive enable Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set ESMC PDU receive (Rx) enable state.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_esmc_tx_enable_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_esmc_tx_enable_get</tt><br>
</h2>

<blockquote>
	Get ESMC PDU transmit (Tx) enable state.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_esmc_tx_enable_get(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    int *enable);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>enable</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) ESMC PDU transmit enable Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get ESMC PDU transmit (Tx) enable state.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_esmc_tx_enable_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_esmc_tx_enable_set</tt><br>
</h2>

<blockquote>
	Set ESMC PDU transmit (Tx) enable state.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_esmc_tx_enable_set(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    int enable);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>enable</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) ESMC PDU transmit enable Boolean.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set ESMC PDU transmit (Tx) enable state.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_esmc_rx_portbitmap_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_esmc_rx_portbitmap_get</tt><br>
</h2>

<blockquote>
	Get port bitmap for ESMC Rx.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_esmc_rx_portbitmap_get(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_pbmp_t *pbmp);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>pbmp</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Rx port bitmap.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get port bitmap for ESMC Rx.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_esmc_rx_portbitmap_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_esmc_rx_portbitmap_set</tt><br>
</h2>

<blockquote>
	Set port bitmap for ESMC Rx.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_esmc_rx_portbitmap_set(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_pbmp_t pbmp);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>pbmp</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Rx port bitmap.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set port bitmap for ESMC Rx.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_esmc_tx_portbitmap_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_esmc_tx_portbitmap_get</tt><br>
</h2>

<blockquote>
	Get port bitmap for ESMC Tx.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_esmc_tx_portbitmap_get(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_pbmp_t *pbmp);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>pbmp</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Tx port bitmap.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get port bitmap for ESMC Tx.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<a name=bcm_tdpll_esmc_tx_portbitmap_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_tdpll_esmc_tx_portbitmap_set</tt><br>
</h2>

<blockquote>
	Set port bitmap for ESMC Tx.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/ptp.h&gt;
	int 
	bcm_tdpll_esmc_tx_portbitmap_set(
	    int unit, 
	    int stack_id, 
	    int dpll_index, 
	    bcm_pbmp_t pbmp);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stack_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stack identifier index.
 </td></tr>
<tr><td class="arg" valign="top"><tt>dpll_index</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) DPLL instance number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>pbmp</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Tx port bitmap.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set port bitmap for ESMC Tx.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_xxx</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation failed
</td></tr>
</table></blockquote>
<br><hr noshade><a name="rate"></a>
<h3>Section 3.4.26:   Rate Limiting
</h3>
<p>        One new Rate Control flag has been added for the rate-limiting functions.

<a name=RateLimitFlags></a>
<h3>Table 62:   Rate Control Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_RATE_COLOR_BLIND</tt></td><td> Rate limiting is color blind
 </td></tr></tbody></table><p><br><hr noshade><a name="sat"></a>
<h3>Section 3.4.27:   Service Activation Test (SAT) is new to this release
</h3>
<br><hr noshade><a name="sat_overview"></a>
<h3>Section 3.4.27.1:   SAT Overview
</h3>
<p>	Service Activation Test (SAT) feature is basically a validation of an Ethernet
	Service for a customer by a service provider operator before activating the
	service. The customer may be another operator, upstream or downstream, or an
	end-point customer. It is usually done with an Ethernet Test Equipment and
	involves a Truck Roll to the premises where the network endpoint or the
	intermediate point resides. The industry is moving towards the use of embedded
	test application within the network switch element.
<p>	The SAT implementation borrows concept of MEP points from Ethernet OAM. Each 
	SAT MEP has an Rx and Tx point. These SAT MEP Tx/Rx points in SAT context are
	defined as Service Activation Measurement Points (SAMP). SAT MEP Rx point is 
	where a SAT packet coming from wire is trapped and sent to OLP. SAT MEP Tx point 
	is where a SAT packet is injected from OLP before going out on wire.
<p>	A SAT MEP (SAMP) can perform one or all of the functions defined below:
 <ul><li> Generator Function (GTF):  SAT logic that injects test frames for OVC/EVC
	at specified rate and Test frames processed like customer service frames.
 </li><li> Collector Function (CTF): SAT Test frames are processed like customer
	service frames and logic has instrumentation counters for SAT.
 </li><li> Reflector Function (Latching Loopback Function): Loops back customer
	service frames at remote end for two-way measurement with GTF and CTF at the
	same end.
 </li></ul>	SAT GTF, CTF and Loopback Latch functions defined above are implemented in SAT 
	Engine that is part of the OMAP engine. Switch that implements OAMP engine 
	supports processing of SAT packets inside the switch.Alternatively users can 
	interface external SAT Engines to switch as Offload Processor (OLP) connected
	to one of the front panel ports on the switch to process SAT packets.
<p>	To support seamless transfer of SAT packets to/from internal/external SAT
	engine  switch implements "trap" and "inject" points to perform proxy CTF
	and proxy GTF functions on behalf of SAT engines. The "trap" point performs 
	proxy CTF function and is used to receive/terminate SAT packets and redirect
	them to SAT engine where actual CTF function is implemented. The "inject" 
	point performs the proxy GTF function and is used for transmitting of 
	SAT packets generated by GTF available in SAT engine.
<p>	For devices which support SAT the APIs provide control of the following features:
<ul><li> Proxy CTF Function to receive/terminate SAT packets and redirect them to OLP.
 </li><li> Proxy GTF Function for initiating/transmitting SAT packets generated
	from OLP.
 </li><li> Latching loop back Function to identify and trap all packets matching the
	latching loopback session to OLP/CPU with OLP header.
 </li></ul><p><br><hr noshade><a name="sat_data_types"></a>
<h3>Section 3.4.27.2:   SAT Data Types
</h3>
<ul><li> <tt>bcm_sat_endpoint_t</tt> is an identifier used to refer to an SAT endpoint.
</li><li> <tt>bcm_sat_timestamp_format_t</tt> is an enumeration of SAT timestamp format
</li></ul>	The following types are used for supplying function pointers to callbacks
	for endpoint traversal handling.
<blockquote><pre>typedef int (*<tt>bcm_sat_endpoint_traverse_cb</tt>)(
        int unit, 
        <tt>bcm_sat_endpoint_info_t</tt> *<tt>endpoint_info</tt>, 
        void *<tt>user_data</tt>);
</pre></blockquote><p><br><hr noshade><a name="sat_endpoint_info"></a>
<h3>Section 3.4.27.3:   SAT Endpoint Info
</h3>
<p>	SAT endpoint info structure.  This is equivalent to an 802.1ag Maintenance
	Endpoint (MEP):
 <blockquote><pre>typedef struct <tt>bcm_sat_endpoint_info_s</tt> {
    <tt>bcm_sat_endpoint_t</tt> <tt>ep_id</tt>;           /* The ID associated with this 
					   endpoint */
    uint32 flags;                       /* The flags associated with this
					   endpoint */
    <tt>bcm_gport_t</tt> <tt>src_gport</tt>;              /* The source gport associated with this
					   endpoint */
    <tt>bcm_vlan_t</tt> <tt>outer_vlan</tt>;              /* Outer-most VLAN tag (vlanID+ 3bits
					   dot1p +CFI) associated with this
					   endpoint */
    <tt>bcm_vlan_t</tt> <tt>inner_vlan</tt>;              /* Configure with CVLAN tag (vlanID+
					   3bits dot1p +CFI) for two-tag
					   operation or set to 0 for one-tag */
    <tt>bcm_mac_t</tt> <tt>dst_mac_address</tt>;          /* The destination MAC address
					   associated with this endpoint */
    <tt>bcm_mac_t</tt> <tt>src_mac_address</tt>;          /* The source MAC address associated
					   with this endpoint */
    uint16 <tt>ether_type</tt>;                  /* Ether type of the packet */
    uint32 <tt>action_flags</tt>;                /* SAT action flags */
    uint8 <tt>pkt_pri</tt>;                      /* Egress priority marking for packet
					   redirected to DGPP */
    <tt>bcm_gport_t</tt> <tt>dest_gport</tt>;             /* Local endpoint SAT PDUs are forwarded
					   to this OLP destination port for
					   processing */
    <tt>bcm_sat_timestamp_format_t</tt> <tt>timestamp_format</tt>; /* SAT timestamp format */
    uint16 <tt>session_id</tt>;                  /* SAT session ID to identify the test
					   among the MEPs */
				    
} <tt>bcm_sat_endpoint_info_t</tt>;
</pre></blockquote><h3>Table 63:   SAT Endpoint Structure Flag Definitions
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Flag</b></td><td><b> Description
 </b></td></tr><tr><td>  <tt>BCM_SAT_ENDPOINT_WITH_ID</tt></td><td> Use the specified endpoint ID when creating
	a new endpoint
 </td></tr><tr><td>  <tt>BCM_SAT_ENDPOINT_REPLACE</tt></td><td> Replace an existing SAT endpoint
 </td></tr><tr><td>  <tt>BCM_SAT_ENDPOINT_UPMEP</tt></td><td> Endpoint associated with SAT UP-MEP
 </td></tr><tr><td>  <tt>BCM_SAT_ENDPOINT_DOWNMEP</tt></td><td> Endpoint associated with SAT DOWN-MEP
 </td></tr><tr><td>  <tt>BCM_SAT_ENDPOINT_MATCH_INNER_VLAN</tt></td><td> Selection of SAT MEP based on
	C VLAN.
 </td></tr><tr><td>  <tt>BCM_SAT_ENDPOINT_MATCH_OUTER_VLAN</tt></td><td> Selection of SAT MEP based on
	S VLAN.
 </td></tr></tbody></table><h3>Table 64:   SAT Timestamp Formats
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Timestamp Format Type</b></td><td><b> Description
 </b></td></tr><tr><td>  bcmSATTimestampFormatIEEE1588v1</td><td> Low-order 64 bits of the IEEE 1588-2008 (1588v2) Precision Time Protocol timestamp format [IEEE1588]
 </td></tr><tr><td>  bcmSATTimestampFormatNTP</td><td> Network Time Protocol version 4 64-bit timestamp format [RFC5905]
 </td></tr></tbody></table><p><br><hr noshade><a name="sat_actions"></a>
<h3>Section 3.4.27.4:   SAT endpoint action 
 </h3>
<h3>Table 65:   SAT Endpoint Action Formats
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Acion Format Type</b></td><td><b> Description
 </b></td></tr><tr><td>  <tt>BCM_SAT_ACTION_FWD_ACTION_DROP</tt></td><td> Drop the SAT packet.
 </td></tr><tr><td>  <tt>BCM_SAT_ACTION_FWD_ACTION_REDIRECT</tt></td><td> Forward SAT packet to specified destination port.
 </td></tr><tr><td>  <tt>BCM_SAT_ACTION_FWD_ACTION_LLF</tt></td><td> Perform latching loop back function (LLF) and redirect SAT packet back to source port on which the SAT packet has been received.
 </td></tr><tr><td>  <tt>BCM_SAT_ACTION_COPY_TO_CPU</tt></td><td> Copy SAT packet to CPU.
 </td></tr><tr><td>  <tt>BCM_SAT_ACTION_SAMPLE_TIMESTAMP</tt></td><td> Sample time stamp into the OLP header.
 </td></tr></tbody></table><table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td></tbody></table><p><br><hr noshade><a name="sat_apis"></a>
<h3>Section 3.4.27.5:   SAT APIs
</h3>
<p><hr noshade>
<h3>APIs for Section 3.4.27.5:  SAT APIs
</h3>
<a name=bcm_sat_endpoint_create></a>
<hr noshade>
<h2 class="api">
<tt>bcm_sat_endpoint_create</tt><br>
</h2>

<blockquote>
	Create or replace an SAT endpoint object.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/sat.h&gt;
	int bcm_sat_endpoint_create(int unit, bcm_sat_endpoint_info_t *endpoint_info);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>endpoint_info</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN/OUT) Pointer to SAT endpoint info structure
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	If <tt>BCM_SAT_ENDPOINT_REPLACE</tt> is not set, a new SAT endpoint is created.  If
	<tt>BCM_SAT_ENDPOINT_WITH_ID</tt> is not set, an ID is created for the endpoint.
	Otherwise, the specified ID is used.
<p>	If <tt>BCM_SAT_ENDPOINT_REPLACE</tt> is set, the endpoint with the specified ID is
	updated with the information in the structure.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_TIMEOUT</tt></td><td>&nbsp;&nbsp;</td><td>
 Unable to obtain resource lock
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Module not initialized
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NOT_FOUND</tt></td><td>&nbsp;&nbsp;</td><td>
 Attempt to replace an endpoint which does not exist
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_EXISTS</tt></td><td>&nbsp;&nbsp;</td><td>
 Attempt to create an endpoint with a specified ID which is already in use
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_PARAM</tt></td><td>&nbsp;&nbsp;</td><td>
 Attempt to replace an endpoint with no ID specified / Specified endpoint ID is out of range / An unsupported gport type was specified
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNAVAIL</tt></td><td>&nbsp;&nbsp;</td><td>
 A specified endpoint type or flag is not supported on the specified unit
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_FULL</tt></td><td>&nbsp;&nbsp;</td><td>
 Endpoint table is full
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INTERNAL</tt></td><td>&nbsp;&nbsp;</td><td>
 Unable to release resource lock / Failed to write memory
</td></tr>
</table></blockquote>
<a name=bcm_sat_endpoint_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_sat_endpoint_get</tt><br>
</h2>

<blockquote>
	Get an SAT endpoint object.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/sat.h&gt;
	int bcm_sat_endpoint_get(int unit, bcm_sat_endpoint_t endpoint,
		uint32 flags, bcm_sat_endpoint_info_t *endpoint_info);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
               (IN) BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>endpoint</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) ID of the endpoint to get
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Endpoint type(UP/Down MEP) to get
 </td></tr>
<tr><td class="arg" valign="top"><tt>endpoint_info</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to SAT endpoint info structure
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Retrieves the information for the endpoint with the specified ID.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_TIMEOUT</tt></td><td>&nbsp;&nbsp;</td><td>
 Unable to obtain resource lock
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Module not initialized
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NOT_FOUND</tt></td><td>&nbsp;&nbsp;</td><td>
 Attempt to get an endpoint which does not exist
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_PARAM</tt></td><td>&nbsp;&nbsp;</td><td>
 Specified endpoint ID is out of range
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INTERNAL</tt></td><td>&nbsp;&nbsp;</td><td>
 Unable to release resource lock / Failed to read memory or read or write register
</td></tr>
</table></blockquote>
<a name=bcm_sat_endpoint_destroy></a>
<hr noshade>
<h2 class="api">
<tt>bcm_sat_endpoint_destroy</tt><br>
</h2>

<blockquote>
	Destroy an SAT endpoint object.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/sat.h&gt;
	int bcm_sat_endpoint_destroy(int unit, bcm_sat_endpoint_t endpoint,
				     uint32 flags);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>endpoint</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) ID of the endpoint to destroy
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Endpoint type (UP/Down MEP) to destroy
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Destroys the endpoint with the specified ID.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_TIMEOUT</tt></td><td>&nbsp;&nbsp;</td><td>
 Unable to obtain resource lock
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Module not initialized
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NOT_FOUND</tt></td><td>&nbsp;&nbsp;</td><td>
 Attempt to destroy an endpoint which does not exist
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_PARAM</tt></td><td>&nbsp;&nbsp;</td><td>
 Specified endpoint ID is out of range
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INTERNAL</tt></td><td>&nbsp;&nbsp;</td><td>
 Unable to release resource lock / Failed to read or write memory or register
</td></tr>
</table></blockquote>
<a name=bcm_sat_endpoint_destroy_all></a>
<hr noshade>
<h2 class="api">
<tt>bcm_sat_endpoint_destroy_all</tt><br>
</h2>

<blockquote>
	Destroy all SAT endpoint objects.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/sat.h&gt;
	int bcm_sat_endpoint_destroy_all(int unit, uint32 flags);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Destory all objects associated with this endpoint
	type (UP/Down MEP)
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Destroys all SAT endpoint objects associated with the given endpoint type and free all its allocated resources.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_TIMEOUT</tt></td><td>&nbsp;&nbsp;</td><td>
 Unable to obtain resource lock
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Module not initialized
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NOT_FOUND</tt></td><td>&nbsp;&nbsp;</td><td>
 Attempt to destroy an endpoint which does not exist
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_PARAM</tt></td><td>&nbsp;&nbsp;</td><td>
 Specified endpoint ID is out of range
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INTERNAL</tt></td><td>&nbsp;&nbsp;</td><td>
 Unable to release resource lock / Failed to read or write memory or register
</td></tr>
</table></blockquote>
<a name=bcm_sat_endpoint_traverse></a>
<hr noshade>
<h2 class="api">
<tt>bcm_sat_endpoint_traverse</tt><br>
</h2>

<blockquote>
	Traverse the set of SAT endpoints.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/sat.h&gt;
	int bcm_sat_endpoint_traverse(int unit, uint32 flags, 
				      bcm_sat_endpoint_traverse_cb cb,
				      void *user_data);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) BCM device number
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Endpoint type(UP/Down MEP) to traverse
 </td></tr>
<tr><td class="arg" valign="top"><tt>cb</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to the callback function
 </td></tr>
<tr><td class="arg" valign="top"><tt>user_data</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to arbitrary user data to be passed back to the callback
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Traverse the set of SAT endpoints associated with the specified endpoint type,
	calling a specified callback for each one
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
 Operation completed successfully
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_TIMEOUT</tt></td><td>&nbsp;&nbsp;</td><td>
 Unable to obtain resource lock
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Module not initialized
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_PARAM</tt></td><td>&nbsp;&nbsp;</td><td>
 No user callback specified / Specified endpoint ID is out of range
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INTERNAL</tt></td><td>&nbsp;&nbsp;</td><td>
 Unable to release resource lock
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Other codes can be returned by the user callback
</td></tr>
</table></blockquote>
<p><br><hr noshade><a name="stack"></a>
<h3>Section 3.4.28:   Multi-device Stack Control
</h3>
<p>        New stack APIs have been added as following in this release.
<p><hr noshade>
<h3>APIs for Section 3.4.28:  Multi-device Stack Control
</h3>
<a name=bcm_stk_module_max_set></a>
<a name=bcm_stk_module_max_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_stk_module_max_set</tt><br>
<tt>bcm_stk_module_max_get</tt><br>
</h2>

<blockquote>
	Maximum group ID set/get
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/stack.h&gt;
	int bcm_stk_module_max_set(int unit, uint32 flags, bcm_module_t max_module)
	int bcm_stk_module_max_get(int unit, uint32 flags, bcm_module_t *max_module)
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Relevant flags
 </td></tr>
<tr><td class="arg" valign="top"><tt>max_module</tt></td><td>&nbsp;&nbsp;</td><td>
 (for "<tt>_set</tt>", IN) Max module id to be configured
 </td></tr>
<tr><td class="arg" valign="top"><tt>max_module</tt></td><td>&nbsp;&nbsp;</td><td>
 (for "<tt>_get</tt>", OUT) Max module id configured
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set/Get a maximum module id to improve response time/exclude module id 
	from all reachable calcualtion.
<h3>Table 67:   Stack Module Max Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Flag</b></td><td><b> Description
 </b></td></tr><tr><td> <tt>BCM_STK_MODULE_MAX_ALL_REACHABLE</tt>
 </td><td> Use this flag in order to configure max module id for all reachable vector calculation
 </td></tr></tbody></table></blockquote><h3>RETURNS</h3><blockquote>
	<tt>BCM_E_XXX</tt>
</blockquote>
<a name=bcm_stk_module_control_set></a>
<a name=bcm_stk_module_control_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_stk_module_control_set</tt><br>
<tt>bcm_stk_module_control_get</tt><br>
</h2>

<blockquote>
	Set/get control value.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/stack.h&gt;
	int bcm_stk_module_max_set(int unit, uint32 flags, bcm_module_t module, bcm_stk_module_control_t control, int arg)
	int bcm_stk_module_max_set(int unit, uint32 flags, bcm_module_t module, bcm_stk_module_control_t control, int *arg)
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Relevant flags
 </td></tr>
<tr><td class="arg" valign="top"><tt>module</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Module ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>control</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Relevant control
 </td></tr>
<tr><td class="arg" valign="top"><tt>arg</tt></td><td>&nbsp;&nbsp;</td><td>
 (for "<tt>_set</tt>", IN) value to be configured
 </td></tr>
<tr><td class="arg" valign="top"><tt>max_module</tt></td><td>&nbsp;&nbsp;</td><td>
 (for "<tt>_get</tt>", OUT) value configured
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Set/get relevant control value per module id

<a name=bcm_stk_module_control_t></a>
<h3>Table 68:   bcm_stk_module_control_t
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> enum
 </b></td><td><b> Description
 </b></td></tr><tr><td> bcmStkModuleAllReachableIgnore
 </td><td> Ignore module ID in all reachable vector calculation
</td></tr></tbody></table></blockquote><h3>RETURNS</h3><blockquote>
	<tt>BCM_E_XXX</tt>
</blockquote>
<br><hr noshade><a name="stat"></a>
<h3>Section 3.4.29:   Statistics
</h3>
<p>        A new object has been added in the enumeration of Ingress and Egress Statistic Accounting Objects
        with a new packets64 field of <tt>bcm_stat_value_t</tt> data structure for 64-bit accumulated packets value.
<blockquote><pre>/* Ingress and Egress Statistics Accounting Objects */
typedef enum <tt>bcm_stat_object_e</tt> {
    ...
    bcmStatObjectIngVxlanDip = 33       /* Ingress Vxlan Dip Object */
} <tt>bcm_stat_object_t</tt>;

/* Counter Statistics Values */
typedef struct <tt>bcm_stat_value_s</tt> {
    ...
    uint64 packets64;   /* 64-bit accumulated packets value */
} <tt>bcm_stat_value_t</tt>;
</pre></blockquote><p>        New statistics APIs have been added as following along with the required data types.
<p><hr noshade>
<h3>APIs for Section 3.4.29:  Statistics
</h3>
<a name=bcm_stat_flex_pool_info_multi_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_stat_flex_pool_info_multi_get</tt><br>
</h2>

<blockquote>
	Retrieves the flex counter details for a given direction
 </blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/stat.h&gt;
	int 
	bcm_stat_flex_pool_info_multi_get( 
	    int unit,
	    bcm_stat_flex_direction_t direction,
	    uint32 num_pools,
	    uint32 *actual_num_pools,
	    bcm_stat_flex_pool_stat_info_t *flex_pool_stat)
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
              (IN) Unit number
 </td></tr>
<tr><td class="arg" valign="top"><tt>direction</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Direction
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_pools</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Passing a 0, then <tt>actual_num_pools</tt> will return
				      the number of pools that are available. 
				      Passing n will return up to n 
				      pools in the return array
 </td></tr>
<tr><td class="arg" valign="top"><tt>actual_num_pools</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Returns actual no of pools
				       available for a given direction
 </td></tr>
<tr><td class="arg" valign="top"><tt>flex_pool_stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (INOUT) array that provides the pool info
<blockquote><pre>/* Flex stat pool direction */
typedef enum <tt>bcm_stat_flex_direction_e</tt> {
    bcmStatFlexDirectionIngress = 0,    /* Ingress direction */
    bcmStatFlexDirectionEgress = 1      /* Egress direction */
} <tt>bcm_stat_flex_direction_t</tt>;

/* Flex pool statistics information */
typedef struct <tt>bcm_stat_flex_pool_stat_info_s</tt> {
    uint32 <tt>pool_id</tt>;                     /* Pool ID */
    uint32 <tt>total_entries</tt>;               /* The size of this pool */
    uint32 <tt>used_entries</tt>;                /* Entries that are allocated (but not
					   necessarily assigned) */
    uint32 <tt>attached_entries</tt>;            /* The number of <tt>used_entries</tt> that are
					   actually assigned to an object */
    uint32 <tt>free_entries</tt>;                /* The result of deducting <tt>used_entries</tt>
					   from <tt>total_entries</tt> */
    <tt>SHR_BITDCL</tt> <tt>used_by_objects</tt>[<tt><tt>_SHR_BITDCLSIZE</tt></tt>(bcmStatObjectMaxValue)]; 
} <tt>bcm_stat_flex_pool_stat_info_t</tt>;
</pre></blockquote></td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	This API retrieves the flex counter details for a given direction
 </blockquote><h3>RETURNS</h3><blockquote>
	<tt>BCM_E_XXX</tt>
</blockquote>
<a name=bcm_stat_value_t_init></a>
<hr noshade>
<h2 class="api">
<tt>bcm_stat_value_t_init</tt><br>
</h2>

<blockquote>
	Initialize a <tt>bcm_stat_value_t</tt> data structure
 </blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/stat.h&gt;
	void
	bcm_stat_value_t_init(
	    bcm_stat_value_t *stat_value);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>stat_value</tt></td><td>&nbsp;&nbsp;</td><td>
    (INOUT) pointer to the <tt>bcm_stat_value_t</tt> data to be initialized.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	This API initializes the <tt>bcm_stat_value_t</tt> data structure.
 </blockquote><h3>RETURNS</h3><blockquote>
	NONE
</blockquote>
<br><hr noshade><a name="switch"></a>
<h3>Section 3.4.30:   Switch Control
</h3>
<p>        Two new switch control types have been added for <tt>bcm_switch_control_xxx</tt>() functions.

<a name=bcm_switchs></a>
<h3>Table 69:   Switch Type Values
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> Value
 </b></td><td><b> Description
 </b></td><td><b> Arg Value
 </b></td></tr><tr><td><tt>bcmSwitchControlPortConfigInstall</tt></td><td> Install new port configuration. For XCore/Caladan3 device only.
 </td><td><tt>0x0-0x1fff</tt></td></tr><tr><td><tt>bcmSwitchMplsPipeTunnelLabelExpSet</tt></td><td> If set, MPLS pipe modes is supported with EXP field set.<br>
              In this case exp is taken from the exp field in <tt>bcm_mpls_egress_label_s</tt> struct
              in the <tt>bcm_mpls_port_add</tt> api.<br>
              Otherwise EXP field will be copied from previous label. Default is 0.
 </td><td><tt>0/1</tt></td></tr><tr><td><tt>bcmSwitchLoopbackMtuSize</tt></td><td> MTU size in bytes check for packets ingressed on loopback port.
 </td><td><tt>1-0x3fff</tt></td></tr><tr><td><tt>bcmSwitchHashVxlanPayloadSelect0</tt></td><td> Set hash control to select VXLAN payload L2/L3 fields for Hash Block A.
 </td><td><ul><li> <tt>BCM_HASH_SELECT_INNER_L2</tt>: Inner L2 fields
 </li><li> <tt>BCM_HASH_SELECT_INNER_L3</tt>: Inner L3 fields
 </li></ul></td></tr><tr><td><tt>bcmSwitchHashVxlanPayloadSelect1</tt></td><td> Set hash control to select VXLAN payload L2/L3 fields for Hash Block B.
 </td><td><ul><li> <tt>BCM_HASH_SELECT_INNER_L2</tt>: Inner L2 fields
 </li><li> <tt>BCM_HASH_SELECT_INNER_L3</tt>: Inner L3 fields
 </li></ul></td></tr><tr><td><tt>bcmSwitchCongestionCnmSrcMacNonOui</tt></td><td> Source MAC address in Congestion Notification Message Lower 3 bytes of MAC address to match
 </td><td></td></tr><tr><td><tt>bcmSwitchCongestionCnmSrcMacOui</tt></td><td> Source MAC address in Congestion Notification Message Upper 3 bytes of MAC address to match
 </td><td></td></tr></tbody></table><p>        A new field <tt>fwd_reason</tt> of <tt>bcm_switch_pkt_info_t</tt> has been added for <tt>bcm_switch_pkt_info_hash_get</tt>()
        function with the newly defined <tt>bcm_switch_pkt_hash_info_fwd_reason_t</tt> while a new flag of switch
        packet information has been defined for the flags field of <tt>bcm_switch_pkt_info_t</tt>.
<blockquote><pre>typedef struct <tt>bcm_switch_pkt_info_s</tt> {
    ...
    <tt>bcm_switch_pkt_hash_info_fwd_reason_t</tt> <tt>fwd_reason</tt>; /* Packet forward reason. */
} <tt>bcm_switch_pkt_info_t</tt>;

typedef enum <tt>bcm_switch_pkt_hash_info_fwd_reason_e</tt> {
    bcmSwitchPktHashInfoFwdReasonUnicast = 0, /* Known unicast packet */
    bcmSwitchPktHashInfoFwdReasonIpmc = 1, /* L3 multicast packet */
    bcmSwitchPktHashInfoFwdReasonL2mc = 2, /* L2 multicast packet */
    bcmSwitchPktHashInfoFwdReasonBcast = 3, /* Broadcast packet */
    bcmSwitchPktHashInfoFwdReasonDlf = 4 /* Destination lookup failed packet */
} <tt>bcm_switch_pkt_hash_info_fwd_reason_t</tt>;

</pre></blockquote><h3>Table 70:   BCM Switch packet information flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_SWITCH_PKT_INFO_HASH_UDP_SOURCE_PORT</tt></td><td> Retrieve Entropy Value of VxLan packet.
 </td></tr></tbody></table><p>        Several statistics objects as below have been added for <tt>bcm_switch_object_count_get</tt>() and
        <tt>bcm_switch_object_count_multi_get</tt>() functions.
<blockquote><pre>typedef enum <tt>bcm_switch_object_e</tt> {
    ...
    bcmSwitchObjectL3RouteV4RoutesMax,      /* Maximum number of v4 routes possible */
    bcmSwitchObjectL3RouteV4RoutesFree,     /* Maximum number of v4 routes that can
	                                       be added in current state */
    bcmSwitchObjectL3RouteV4RoutesUsed,     /* Used count of v4 routes */
    bcmSwitchObjectL3RouteV6Routes64bMax,   /* Maximum number of 64bv6 routes
	                                       possible */
    bcmSwitchObjectL3RouteV6Routes64bFree,  /* Maximum number of 64bV6 routes that
	                                       can be added in current state */
    bcmSwitchObjectL3RouteV6Routes64bUsed,  /* Used count of 64bv6 routes */
    bcmSwitchObjectL3RouteV6Routes128bMax,  /* Maximum number of 128bV6 routes
	                                       possible */
    bcmSwitchObjectL3RouteV6Routes128bFree, /* Maximum number of 128bV6 routes that
	                                       can be added in current state */
    bcmSwitchObjectL3RouteV6Routes128bUsed, /* Used count of 128bv6 routes */
    bcmSwitchObjectL3RouteTotalUsedRoutes,  /* Sum of v4 + 64bv6 + 128bv6 routes */
    bcmSwitchObjectIpmcHeadTableFree,       /* Number of free entries in the replication head
	                                       table */
} <tt>bcm_switch_object_t</tt>;
</pre></blockquote><p>        New switch control APIs added in this release are listed as following:
<p><hr noshade>
<h3>APIs for Section 3.4.30:  Switch Control
</h3>
<a name=bcm_switch_l3_protocol_group_set></a>
<a name=bcm_switch_l3_protocol_group_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_switch_l3_protocol_group_set</tt><br>
<tt>bcm_switch_l3_protocol_group_get</tt><br>
</h2>

<blockquote>
	Assign/get protocol groups for multiple mymac termination
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/switch.h&gt;

	typedef uint32 bcm_l3_protocol_group_id_t;

	extern int bcm_switch_l3_protocol_group_set(
	    int unit, 
	    uint32 group_members, 
	    bcm_l3_protocol_group_id_t group_id);

	extern int bcm_switch_l3_protocol_group_get(
	    int unit, 
	    uint32 *group_members, 
	    bcm_l3_protocol_group_id_t *group_id);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
             (IN)              Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>group_members</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) (for set) The protocols to be assigned to the group.
 </td></tr>
<tr><td class="arg" valign="top"><tt>group_members</tt></td><td>&nbsp;&nbsp;</td><td>
 (INOUT) (for get) The protocols assigned to the group.
 </td></tr>
<tr><td class="arg" valign="top"><tt>group_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) (for set) The group to which the l3 protocols are to be assigned.
 </td></tr>
<tr><td class="arg" valign="top"><tt>group_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (INOUT) (for get) The group to which the l3 protocols are assigned.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	When using multiple mymac termination feature, L3 protocols can be divided into different groups.
        The group is part of the key used
	to decide whether the packet will be l2 terminated. Use this api to assign the different
        l3 protocols into groups. The default group 
	for all protocols is 0, and protocls in re-set groups that weren't reassigned would be
        automatically reassigned to group 0.
<p>	For the get api, the input can be either the group members, and the group number will be
        returned, or the input can be the group number, 
	and all members assigned to it will be returned. Either way, the other one must be -1
        (<tt>MAX_UINT32</tt> for flags and <tt>MAX_UINT8</tt> for <tt>group_id</tt>). 
<p>	The protocol are given in the form of flags. The flags are:

<a name=bcm_switch_l3_protocol_group_flags></a>
<h3>Table 71:   BCM_SWITCH_L3_PROTOCOL_GROUP_* flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> Name
 </b></td><td><b> Description
 </b></td><td><b> Value
 </b></td></tr><tr><td>  <tt>BCM_SWITCH_L3_PROTOCOL_GROUP_NONE</tt></td><td>  No protocols in this group.</td><td> 0x0000
 </td></tr><tr><td>  <tt>BCM_SWITCH_L3_PROTOCOL_GROUP_IPV4</tt></td><td>  Add IPv4 to the group.</td><td> 0x0001
 </td></tr><tr><td>  <tt>BCM_SWITCH_L3_PROTOCOL_GROUP_IPV6</tt></td><td>  Add IPv6 to the group.</td><td> 0x0002
 </td></tr><tr><td>  <tt>BCM_SWITCH_L3_PROTOCOL_GROUP_ARP</tt></td><td>  Add ARP to the group.</td><td> 0x0004
 </td></tr><tr><td>  <tt>BCM_SWITCH_L3_PROTOCOL_GROUP_MPLS</tt></td><td>  Add MPLS to the group.</td><td> 0x0008
 </td></tr><tr><td>  <tt>BCM_SWITCH_L3_PROTOCOL_GROUP_MIM</tt></td><td>  Add MiM to the group.</td><td> 0x0010
 </td></tr><tr><td>  <tt>BCM_SWITCH_L3_PROTOCOL_GROUP_TRILL</tt></td><td>  Add trill to the group.</td><td> 0x0020
 </td></tr><tr><td>  <tt>BCM_SWITCH_L3_PROTOCOL_GROUP_FCOE</tt></td><td>  Add FCOE to the group.</td><td> 0x0040
 </td></tr></tbody></table></blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_switch_profile_mapping_t_init></a>
<hr noshade>
<h2 class="api">
<tt>bcm_switch_profile_mapping_t_init</tt><br>
</h2>

<blockquote>
	Initialize a <tt>bcm_switch_profile_mapping_t</tt> structure
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/switch.h&gt;
	void 
	bcm_switch_profile_mapping_t_init(bcm_switch_profile_mapping_t *profile_mapping);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>profile_mapping</tt></td><td>&nbsp;&nbsp;</td><td>
             (IN/OUT)             profile mapping structure.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Initialize a profile mapping structure to default values.
	This structure is used for creating profile to gport mapping.
</blockquote><h3>RETURNS</h3><blockquote>
	void
</blockquote>
<a name=bcm_switch_hash_entry_create_qset></a>
<hr noshade>
<h2 class="api">
<tt>bcm_switch_hash_entry_create_qset</tt><br>
</h2>

<blockquote>
	Create a blank flex hash entry.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/switch.h&gt;
	int
	bcm_switch_hash_entry_create_qset(
	    int unit,
	    bcm_field_qset_t qset,
	    bcm_hash_entry_t *entry);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>qset</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) &lt;UNDEF&gt;
 </td></tr>
<tr><td class="arg" valign="top"><tt>entry</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) &lt;UNDEF&gt;
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	This API, unlike , takes a <tt>bcm_field_qset_t</tt> INPUT instead
        of a <tt>bcm_field_group_t</tt> INPUT.
  The qset should be filled with the UDF APIs defined in  <a href="#udf">Section 3.4.35:  UDF Resources Management is new to this release 
</a>  </blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<br><hr noshade><a name="trill"></a>
<h3>Section 3.4.31:   TRILL Management
</h3>
<p>        New trill port flags for <tt>bcm_trill_port_t</tt> have been defined along with the applicable data
        structure <tt>bcm_trill_rbridge_t</tt> and corresponding APIs.
<h3>Table 72:   TRILL port flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_TRILL_PORT_TUNNEL</tt></td><td> Create unicast Rbridge without transit
 </td></tr><tr><td>  <tt>BCM_TRILL_PORT_INGRESS</tt></td><td> Create Ingress Rbridge
 </td></tr><tr><td>  <tt>BCM_TRILL_PORT_EGRESS</tt></td><td> Create Egress Rbridge
 </td></tr></tbody></table><blockquote><pre>typedef struct <tt>bcm_trill_rbridge_s</tt> {
    uint32 flags;           /* BCM_TRILL_RBRIDGE_xxx. */
    <tt>bcm_trill_name_t</tt> name;  /* RBridge Nickname. */
    <tt>bcm_if_t</tt> <tt>egress_if</tt>;     /* TRILL egress object. */
    int mtu;                /* TRILL port MTU. */
    int hopcount;           /* Hopcount for TRILL. */
} <tt>bcm_trill_rbridge_t</tt>;
</pre></blockquote><p>        New APIs of trill management have been added in this release with the data types.
<ul><li>	The <tt>bcm_trill_multicast_adjacency_t</tt> structure describes a TRILL multicast adjacency entry used for
	performing trill adjacency check 
 </li></ul><blockquote><pre>typedef struct <tt>bcm_trill_multicast_adjacency_s</tt> {
    <tt>bcm_gport_t</tt> port;       /* Match Trill network port. */
    uint32 flags;           /* BCM_TRILL_MULTICAST_ADJACENCY_xxx. */
    <tt>bcm_if_t</tt> <tt>encap_intf</tt>;    /* Neighbor interface. */
} <tt>bcm_trill_multicast_adjacency_t</tt>;
</pre></blockquote><p><hr noshade>
<h3>APIs for Section 3.4.31:  TRILL Management
</h3>
<a name=bcm_trill_multicast_adjacency_add></a>
<hr noshade>
<h2 class="api">
<tt>bcm_trill_multicast_adjacency_add</tt><br>
</h2>

<blockquote>
	Add Multicast adjacency entry
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/trill.h&gt;
	int bcm_trill_multicast_adjacency_add(int unit, 
					       bcm_trill_multicast_adjacency_t *trill_multicast_adjacency);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
                      (IN)  BCM unit
 </td></tr>
<tr><td class="arg" valign="top"><tt>trill_multicast_adjacency</tt></td><td>&nbsp;&nbsp;</td><td>
 (INOUT) Trill multicast adjacency entry
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Add Trill Multicast adjacency entry
</blockquote><a name=bcm_trill_multicast_adjacency_delete></a>
<hr noshade>
<h2 class="api">
<tt>bcm_trill_multicast_adjacency_delete</tt><br>
</h2>

<blockquote>
	Delete Multicast adjacency entry
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/trill.h&gt;
	int bcm_trill_multicast_adjacency_delete(int unit, 
						 bcm_trill_multicast_adjacency_t *trill_multicast_adjacency);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
                      (IN)  BCM unit
 </td></tr>
<tr><td class="arg" valign="top"><tt>trill_multicast_adjacency</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Trill multicast adjacency entry
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Delete Trill Multicast adjacency entry
</blockquote><a name=bcm_trill_multicast_adjacency_delete_all></a>
<hr noshade>
<h2 class="api">
<tt>bcm_trill_multicast_adjacency_delete_all</tt><br>
</h2>

<blockquote>
	Delete all Multicast adjacency entry
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/trill.h&gt;
	int bcm_trill_multicast_adjacency_delete_all(int unit);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
                      (IN)  BCM unit
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Delete all Trill Multicast adjacency entry
</blockquote><a name=bcm_trill_multicast_adjacency_traverse></a>
<hr noshade>
<h2 class="api">
<tt>bcm_trill_multicast_adjacency_traverse</tt><br>
</h2>

<blockquote>
	Traverse all valid TRILL Multicast adjacency entries and call supplied callback routine.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/trill.h&gt;
	int bcm_trill_multicast_adjacency_traverse(int unit, 
						    bcm_trill_multicast_adjacency_traverse_cb cb, 
						    void *user_data);
 </pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) BCM unit
 </td></tr>
<tr><td class="arg" valign="top"><tt>flags</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) User callback function, called once per TRILL entry
 </td></tr>
<tr><td class="arg" valign="top"><tt>user_data</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Cookie
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Traverse all valid TRILL Multicast adjacency entries and call supplied callback routine.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_trill_rbridge_entry_add></a>
<hr noshade>
<h2 class="api">
<tt>bcm_trill_rbridge_entry_add</tt><br>
</h2>

<blockquote>
	<tt>bcm_trill_rbridge_entry_add</tt> Add TRILL Rbridge entry.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/trill.h&gt;
	int bcm_trill_rbridge_entry_add(int unit, 
					bcm_trill_rbridge_t *trill_entry);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
          (IN) BCM unit
 </td></tr>
<tr><td class="arg" valign="top"><tt>trill_entry</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN/OUT) TRILL Rbridge entry
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Add TRILL Rbridge entry.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_trill_rbridge_entry_delete></a>
<hr noshade>
<h2 class="api">
<tt>bcm_trill_rbridge_entry_delete</tt><br>
</h2>

<blockquote>
	<tt>bcm_trill_rbridge_entry_delete</tt> Add TRILL Rbridge entry.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/trill.h&gt;
	int bcm_trill_rbridge_entry_delete(int unit, 
					bcm_trill_rbridge_t *trill_entry);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
          (IN) BCM unit
 </td></tr>
<tr><td class="arg" valign="top"><tt>trill_entry</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) TRILL Rbridge entry
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Delete TRILL Rbridge entry.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<a name=bcm_trill_rbridge_entry_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_trill_rbridge_entry_get</tt><br>
</h2>

<blockquote>
	<tt>bcm_trill_rbridge_entry_get</tt> Add TRILL Rbridge entry.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/trill.h&gt;
	int bcm_trill_rbridge_entry_get(int unit, 
					bcm_trill_rbridge_t *trill_entry);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
          (IN) BCM unit
 </td></tr>
<tr><td class="arg" valign="top"><tt>trill_entry</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN/OUT) TRILL Rbridge entry
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Get TRILL Rbridge entry.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
</td></tr>
</table></blockquote>
<br><hr noshade><a name="trunk"></a>
<h3>Section 3.4.32:   Trunking (Link Aggregation)
</h3>
<p>	A new trunk flag has been added in this release as below.
<h3>Table 73:   BCM Trunk Flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_TRUNK_FLAG_MEMBER_SORT</tt></td><td> If set, set or add trunk members to hardware in the sorted way.
 </td></tr></tbody></table><p><br><hr noshade><a name="vlan"></a>
<h3>Section 3.4.33:   VLAN Management
</h3>
<p>	A new field <tt>vp_mc_ctrl</tt> of <tt>bcm_vlan_control_vlan_t</tt> data structure has been added as well as its
        data type of <tt>bcm_vlan_vp_mc_ctrl_t</tt> and <tt>BCM_VLAN_CONTROL_VLAN_VP_MCAST_MASK</tt> of VLAN Control Valid
        Field Mask to control VP replication of the VLAN.

<a name=BCM_VLAN_CONTROL_VLAN_MASK_table></a>
<h3>Table 74:   VLAN Control Valid Field Mask
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  VLAN Control Valid Field Mask</b></td><td><b> Meaning
 </b></td></tr><tr><td>  <tt>BCM_VLAN_CONTROL_VLAN_VP_MCAST_MASK</tt></td><td> Enable .<tt>vp_mc_ctrl</tt> field.
 </td></tr></tbody></table><blockquote><pre>typedef struct {
    ...
    <tt>bcm_vlan_vp_mc_ctrl_t</tt>   <tt>vp_mc_ctrl</tt>;   /* VP replication control, Auto, Enable, Disable */
} <tt>bcm_vlan_control_vlan_t</tt>;

typedef enum <tt>bcm_vlan_vp_mc_ctrl_e</tt> {
    bcmVlanVPMcControlAuto = 0,     /* VP Multicast replication auto control */
    bcmVlanVPMcControlEnable = 1,   /* Enable VP Multicast replication */
    bcmVlanVPMcControlDisable = 2   /* Disable VP Multicast replication */
} <tt>bcm_vlan_vp_mc_ctrl_t</tt>;
</pre></blockquote><p>	Two new fields <tt>egress_failover_id</tt> and <tt>egress_failover_port_id</tt> of <tt>bcm_vlan_port_t</tt> data structure
        have been added.
 <blockquote><pre>typedef struct <tt>bcm_vlan_port_s</tt> {
    ... 
    <tt>bcm_failover_t</tt> <tt>egress_failover_id</tt>;   /* Failover object index for Egress Protection */
    <tt>bcm_gport_t</tt> <tt>egress_failover_port_id</tt>; /* Failover VLAN Port Identifier for Egress Protection */
} <tt>bcm_vlan_port_t</tt>;
</pre></blockquote><p>	New VLAN stat sync get APIs and stat counter sync get APIs are listed below.
<p><hr noshade>
<h3>APIs for Section 3.4.33:  VLAN Management
</h3>
<a name=bcm_vlan_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vlan_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve the specified statistic to 
	the indicated value for the specified VLAN.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vlan.h&gt;
	int 
	bcm_vlan_stat_counter_sync_get(
	    int              unit,
	    bcm_vlan_t       vlan,
	    bcm_vlan_stat_t  stat,
	    uint32           num_entries,
	    uint32           *counter_indexes,
	    bcm_stat_value_t *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>vlan</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) VLAN ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_vlan_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_vlan_stat_sync_get></a>
<a name=bcm_vlan_stat_sync_get32></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vlan_stat_sync_get</tt><br>
<tt>bcm_vlan_stat_sync_get32</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve per-VLAN statistics from 
	the chip.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vlan.h&gt;
	int 
	bcm_vlan_stat_sync_get(
	    int unit, 
	    bcm_vlan_t vlan, 
	    bcm_cos_t cos,
	    bcm_vlan_stat_t stat, 
	    uint64 *val);

	int 
	bcm_vlan_stat_sync_get32(
	    int unit, 
	    bcm_vlan_t vlan,
	    bcm_cos_t cos, 
	    bcm_vlan_stat_t stat, 
	    uint32 *val);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>vlan</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) VLAN ID.
 </td></tr>
<tr><td class="arg" valign="top"><tt>cos</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) CoS or priority
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve.
 </td></tr>
<tr><td class="arg" valign="top"><tt>val</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to a counter value.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_vlan_stat_get</tt>(), value returned is software accumulated 
	counter synced with the hardware counter
</blockquote><h3>RETURNS</h3><blockquote>
	<tt>BCM_E_XXX</tt>
</blockquote>
<a name=bcm_vlan_translate_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vlan_translate_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve counter values from ingress 
	VLAN translation table.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vlan.h&gt;
	int
	bcm_vlan_translate_stat_counter_sync_get(
	    int                      unit,
	    bcm_gport_t              port,
	    bcm_vlan_translate_key_t key_type,
	    bcm_vlan_t               outer_vlan,
	    bcm_vlan_t               inner_vlan,
	    bcm_vlan_stat_t          stat,
	    uint32                   num_entries,
	    uint32                   *counter_indexes,
	    bcm_stat_value_t         *counter_values)
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) GPORT (global port) identifier
 </td></tr>
<tr><td class="arg" valign="top"><tt>key_type</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) VLAN translation key type
 </td></tr>
<tr><td class="arg" valign="top"><tt>outer_vlan</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Outer VLAN ID or tag
 </td></tr>
<tr><td class="arg" valign="top"><tt>inner_vlan</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Inner VLAN ID or tag
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve that is, ingress/egress byte/packet
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_vlan_translate_stat_counter_get</tt>(), value returned is 
	software accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_vlan_translate_stat_sync_get></a>
<a name=bcm_vlan_translate_stat_sync_get32></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vlan_translate_stat_sync_get</tt><br>
<tt>bcm_vlan_translate_stat_sync_get32</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve ingress VLAN 
	translation statistics from the chip.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vlan.h&gt;
	int bcm_vlan_translate_stat_sync_get(int unit, bcm_gport_t port, 
					     bcm_vlan_translate_key_t key_type, 
					     bcm_vlan_t outer_vlan, 
					     bcm_vlan_t inner_vlan, 
					     bcm_vlan_stat_t stat, 
					     uint64 *val);

	int bcm_vlan_translate_stat_sync_get32(int unit, bcm_gport_t port, 
					       bcm_vlan_translate_key_t key_type, 
					       bcm_vlan_t outer_vlan, 
					       bcm_vlan_t inner_vlan, 
					       bcm_vlan_stat_t stat, 
					       uint32 *val);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Generic port
 </td></tr>
<tr><td class="arg" valign="top"><tt>key_type</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Key Type : bcmVlanTranslateKey*
 </td></tr>
<tr><td class="arg" valign="top"><tt>outer_vlan</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Packet outer VLAN ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>inner_vlan</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Packet inner VLAN ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve.
 </td></tr>
<tr><td class="arg" valign="top"><tt>val</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to a counter value.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_vlan_translate_stat_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_vlan_translate_egress_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vlan_translate_egress_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve counter values from egress 
	VLAN translation table.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vlan.h&gt;
	int
	bcm_vlan_translate_egress_stat_counter_sync_get(
	    int              unit,
	    int              port_class,
	    bcm_vlan_t       outer_vlan,
	    bcm_vlan_t       inner_vlan,
	    bcm_vlan_stat_t  stat,
	    uint32           num_entries,
	    uint32           *counter_indexes,
	    bcm_stat_value_t *counter_values)
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>port_class</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) <tt>port_class</tt>
 </td></tr>
<tr><td class="arg" valign="top"><tt>outer_vlan</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Outer VLAN ID or tag
 </td></tr>
<tr><td class="arg" valign="top"><tt>inner_vlan</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Inner VLAN ID or tag
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve that is, ingress/egress byte/packet
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_vlan_translate_egress_stat_counter_get</tt>(), value returned 
	is software accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_vlan_translate_egress_stat_sync_get></a>
<a name=bcm_vlan_translate_egress_stat_sync_get32></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vlan_translate_egress_stat_sync_get</tt><br>
<tt>bcm_vlan_translate_egress_stat_sync_get32</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve egress VLAN 
	translation statistics from the chip.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vlan.h&gt;
	int bcm_vlan_translate_egress_stat_sync_get(int unit, int port_class, 
						    bcm_vlan_t outer_vlan, 
						    bcm_vlan_t inner_vlan, 
						    bcm_vlan_stat_t stat, 
						    uint64 *val);

	int bcm_vlan_translate_egress_stat_sync_get32(int unit, int port_class, 
						      bcm_vlan_t outer_vlan, 
						      bcm_vlan_t inner_vlan, 
						      bcm_vlan_stat_t stat, 
						      uint32 *val);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>port_class</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Group ID of ingress port
 </td></tr>
<tr><td class="arg" valign="top"><tt>outer_vlan</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Packet outer VLAN ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>inner_vlan</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Packet inner VLAN ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve.
 </td></tr>
<tr><td class="arg" valign="top"><tt>val</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to a counter value.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_vlan_translate_egress_stat_get</tt>(), value returned is 
	software accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<br><hr noshade><a name="VXLAN"></a>
<h3>Section 3.4.34:   VXLAN Management
</h3>
<p>        A new flag has been added for <tt>bcm_vxlan_tunnel_terminator_update</tt>() API while
        <tt>BCM_VXLAN_PORT_MATCH_VN_ID</tt> has been deprecated from VXLAN Port Match Criteria in this release.
<h3>Table 75:   VXLAN Port Match Criteria
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_VXLAN_PORT_MATCH_VN_ID</tt></td><td> VXLAN <tt>VN_ID</tt>
 </td></tr></tbody></table><ul><li>	<tt>bcm_vxlan_tunnel_terminator_update</tt> API provides a trigger mechanism to update multicast BUD state
	per VXLAN Tunnel terminator.
 </li></ul><h3>Table 76:   VXLAN Tunnel terminator Multicast flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  name</b></td><td> heading Purpose
 </td></tr><tr><td>  <tt>BCM_TUNNEL_TERM_TUNNEL_DEACTIVATE</tt></td><td> Deactivate Tunnel Terminator
 </td></tr></tbody></table><p>        A new flag <tt>BCM_VXLAN_PORT_ENABLE_VLAN_CHECKS</tt> that Enable VLAN checks for VXLAN port has
        been added for data type <tt>bcm_vxlan_port_t</tt>.
<ul><li>	The <tt>bcm_vxlan_port_t</tt> structure describes a VXLAN virtual port used for
	creating VXLAN Network endpoints.
 </li></ul><h3>Table 77:   VXLAN port flags
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_VXLAN_PORT_ENABLE_VLAN_CHECKS</tt></td><td> Enable VLAN Checks for VXLAN Port
 </td></tr></tbody></table><p>	A new field <tt>protocol_pkt</tt> of <tt>bcm_vxlan_vpn_config_t</tt> data structure has been added for
        the configuring of VXLAN vpn in this release.
<blockquote><pre>typedef struct <tt>bcm_vxlan_vpn_config_s</tt> {
    ...
    <tt>bcm_vlan_protocol_packet_ctrl_t</tt> <tt>protocol_pkt</tt>;
} <tt>bcm_vxlan_vpn_config_t</tt>;
</pre></blockquote><h3>Table 78:   VXLAN Port Match Criteria
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Name</b></td><td><b> Purpose
 </b></td></tr><tr><td>  <tt>BCM_VXLAN_PORT_DEFAULT</tt></td><td> VXLAN Default Network Port
 </td></tr></tbody></table><p>        The new APIs with regard to VXLAN Management are listed as following as well as the data type
        <tt>bcm_vxlan_dip_stat_t</tt>:
<blockquote><pre>/* Ingress statistics maintained per Vxlan Dip. */
typedef enum <tt>bcm_vxlan_dip_stat_e</tt> {
    bcmVxlanDipInPackets = 0,   /* Packets that ingress on the Vxlan Dip . */
    bcmVxlanDipInBytes = 1      /* Bytes that ingress on the Vxlan Dip . */
} <tt>bcm_vxlan_dip_stat_t</tt>;
</pre></blockquote><p><hr noshade>
<h3>APIs for Section 3.4.34:  VXLAN Management
</h3>
<a name=bcm_vxlan_stat_enable_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vxlan_stat_enable_set</tt><br>
</h2>

<blockquote>
	Enable/Disable collection of statistics on the indicated port and vpn
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vxlan.h&gt;
	int 
	bcm_esw_vxlan_stat_enable_set(
	    int              unit, 
	    bcm_gport_t      port, 
	    bcm_vpn_t        vpn, 
	    int              enable);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) vxlan vp index
 </td></tr>
<tr><td class="arg" valign="top"><tt>vpn</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) vxlan vpn index
 </td></tr>
<tr><td class="arg" valign="top"><tt>enable</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Non-zero to enable counter collection, zero to disable.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	This API will initialize statistic collection for the given vp/vpn (enable=TRUE) 
	or release the HW resources used for the tracking the statistics (enable=FALSE).
	The below table mentions the flex stat actions for the input vxlan parameters.
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td></td><td><b>  VxlanPort</b></td><td><b>  Vpn</b></td><td><b> flex stat Action
 </b></td></tr><tr><td>  1.</td><td>  ValidPort</td><td>  -1</td><td> Port stat Enable/Disable
 </td></tr><tr><td>  2.</td><td>  -1</td><td>  Validvpn</td><td> Vpn stat Enable/Disable
 </td></tr><tr><td>  3.</td><td>  ValidPort</td><td>  ValidVpn</td><td> Port+Vpn Enable/Disable
 </td></tr><tr><td>  4.</td><td>  InvalidPort</td><td>  InvalidVpn</td><td> return <tt>BCM_E_PARAM</tt>
 </td></tr></tbody></table></blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_vxlan_dip_stat_attach></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vxlan_dip_stat_attach</tt><br>
</h2>

<blockquote>
	Attach counters entries to a given VXLAN DIP.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vxlan.h&gt;
	int
	bcm_vxlan_dip_stat_attach (
	    int          unit,
	    bcm_ip_t     vxlan_dip;
	    uint32       stat_counter_id);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
                 (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>vxlan_dip</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Vxlan DIP
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat_counter_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stat Counter ID
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	This API will attach counters entries to a given VXLAN DIP.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_vxlan_dip_stat_detach></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vxlan_dip_stat_detach</tt><br>
</h2>

<blockquote>
	Detach counters entries to a given VXLAN DIP.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vxlan.h&gt;
	int
	bcm_vxlan_dip_stat_detach (
	    int         unit,
	    bcm_ip_t    vxlan_dip;);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
                 (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>vxlan_dip</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Vxlan DIP
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	This API will detach counters entries to a given VXLAN DIP.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_vxlan_dip_stat_counter_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vxlan_dip_stat_counter_get</tt><br>
</h2>

<blockquote>
	Get the specified counter statistic for a given VXLAN DIP.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vxlan.h&gt;
	int
	bcm_vxlan_dip_stat_counter_get(
	    int                    unit, 
	    bcm_ip_t               vxlan_dip;
	    bcm_vxlan_dip_stat_t   stat, 
	    uint32                 num_entries, 
	    uint32                 *counter_indexes, 
	    bcm_stat_value_t       *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
                 (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>vxlan_dip</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Vxlan DIP.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve.
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries.
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries.
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	This API will get the specified counter statistic for a given VXLAN DIP.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_vxlan_dip_stat_counter_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vxlan_dip_stat_counter_set</tt><br>
</h2>

<blockquote>
	Set the specified counter statistic for a given VXLAN DIP.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vxlan.h&gt;
	int
	bcm_vxlan_dip_stat_counter_set(
	    int                    unit, 
	    bcm_ip_t               vxlan_dip;
	    bcm_vxlan_dip_stat_t   stat, 
	    uint32                 num_entries, 
	    uint32                 *counter_indexes, 
	    bcm_stat_value_t       *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
                 (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>vxlan_dip</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Vxlan DIP.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve.
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries.
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries.
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to counter values.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	This API will set the specified counter statistic for a given VXLAN DIP.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_vxlan_dip_stat_multi_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vxlan_dip_stat_multi_get</tt><br>
</h2>

<blockquote>
	Get 64-bit counter value for multiple VXLAN DIP statistic types.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vxlan.h&gt;
	int
	bcm_vxlan_dip_stat_multi_get(
	    int                    unit, 
	    bcm_ip_t               vxlan_dip,
	    int                    nstat, 
	    bcm_vxlan_dip_stat_t   *stat_arr,
	    uint64                 *value_arr);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
           (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>vxlan_dip</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Vxlan DIP.
 </td></tr>
<tr><td class="arg" valign="top"><tt>nstat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of elements in stat array.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat_arr</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Collected statistics descriptors array.
 </td></tr>
<tr><td class="arg" valign="top"><tt>value_arr</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Collected counters values.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	This API will get 64-bit counter value for multiple VXLAN DIP statistic types.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_vxlan_dip_stat_multi_get32></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vxlan_dip_stat_multi_get32</tt><br>
</h2>

<blockquote>
	Get 32-bit counter value for multiple VXLAN DIP statistic types.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vxlan.h&gt;
	int
	bcm_vxlan_dip_stat_multi_get32(
	    int                    unit, 
	    bcm_ip_t               vxlan_dip,
	    int                    nstat, 
	    bcm_vxlan_dip_stat_t   *stat_arr,
	    uint32                 *value_arr);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
           (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>vxlan_dip</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Vxlan DIP.
 </td></tr>
<tr><td class="arg" valign="top"><tt>nstat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of elements in stat array.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat_arr</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Collected statistics descriptors array.
 </td></tr>
<tr><td class="arg" valign="top"><tt>value_arr</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Collected counters values.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	This API will get 32-bit counter value for multiple VXLAN DIP statistic types.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_vxlan_dip_stat_multi_set></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vxlan_dip_stat_multi_set</tt><br>
</h2>

<blockquote>
	set 64-bit counter value for multiple VXLAN DIP statistic types.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vxlan.h&gt;
	int
	bcm_vxlan_dip_stat_multi_set(
	    int                    unit, 
	    bcm_ip_t               vxlan_dip,
	    int                    nstat, 
	    bcm_vxlan_dip_stat_t   *stat_arr,
	    uint64                 *value_arr);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
           (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>vxlan_dip</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Vxlan DIP.
 </td></tr>
<tr><td class="arg" valign="top"><tt>nstat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of elements in stat array.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat_arr</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Collected statistics descriptors array.
 </td></tr>
<tr><td class="arg" valign="top"><tt>value_arr</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Collected counters values.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	This API will set 64-bit counter value for multiple VXLAN DIP statistic types.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_vxlan_dip_stat_multi_set32></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vxlan_dip_stat_multi_set32</tt><br>
</h2>

<blockquote>
	set 32-bit counter value for multiple VXLAN DIP statistic types.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vxlan.h&gt;
	int
	bcm_vxlan_dip_stat_multi_set32(
	    int                    unit, 
	    bcm_ip_t               vxlan_dip,
	    int                    nstat, 
	    bcm_vxlan_dip_stat_t   *stat_arr,
	    uint64                 *value_arr);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
           (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>vxlan_dip</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Vxlan DIP.
 </td></tr>
<tr><td class="arg" valign="top"><tt>nstat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of elements in stat array.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat_arr</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Collected statistics descriptors array.
 </td></tr>
<tr><td class="arg" valign="top"><tt>value_arr</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Collected counters values.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	This API will set 32-bit counter value for multiple VXLAN DIP statistic types.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_vxlan_dip_stat_id_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vxlan_dip_stat_id_get</tt><br>
</h2>

<blockquote>
	Retrieve associated stat counter for a given VXLAN DIP.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vxlan.h&gt;
	int
	bcm_vxlan_dip_stat_id_get(
	    int                    unit,
	    bcm_ip_t               vxlan_dip,
	    bcm_vxlan_dip_stat_t   stat, 
	    uint32                 *stat_counter_id);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
              (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>vxlan_dip</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Vxlan DIP.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Type of the counter to retrieve.
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat_counter_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Stat Counter ID.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	This API will retrieve associated stat counter for a given VXLAN DIP.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_vxlan_stat_counter_sync_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_vxlan_stat_counter_sync_get</tt><br>
</h2>

<blockquote>
	Force an immediate counter update and retrieve counter statistic values for 
	a vxlan vp/vpn index.
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/vxlan.h&gt;
	int
	bcm_vxlan_stat_counter_sync_get(
	    int              unit,
	    bcm_gport_t     port,
	    bcm_vpn_t       vpn,
	    bcm_vxlan_stat_t    stat,
	    uint32           num_entries,
	    uint32           *counter_indexes,
	    bcm_stat_value_t *counter_values);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
            (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>port</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) vxlan vp index
 </td></tr>
<tr><td class="arg" valign="top"><tt>vpn</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) vxlan vpn index
 </td></tr>
<tr><td class="arg" valign="top"><tt>stat</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Vxlan counter stat types.
 </td></tr>
<tr><td class="arg" valign="top"><tt>num_entries</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Number of counter Entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_indexes</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Pointer to Counter indexes entries
 </td></tr>
<tr><td class="arg" valign="top"><tt>counter_values</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Pointer to counter values
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Similar to <tt>bcm_vxlan_stat_counter_get</tt>(), value returned is software 
	accumulated counter synced with the hardware counter.
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<br><hr noshade><a name="udf"></a>
<h3>Section 3.4.35:   UDF Resources Management is new to this release 
</h3>
<p>	The new BCM UDF APIs allow application developers to manage the UDF resources
	in StrataXGS devices.
<br><hr noshade><a name="udf_overview"></a>
<h3>Section 3.4.35.1:   UDF Resources
</h3>
<p>	Historically, in StrataXGS devices the UDF resources were exclusively used by 
	the Field Processor for flexible classification of user defined patterns in
	the incoming packets. The APIs for managing these resources were hence
	defined within FIELD module.
<p>	The UDF selection logic is now being used by many other applications apart from
	the ContentAware Engine. For example, BCM56850 uses the UDF selected chunks
	for flexible hashing using layer 4 payload data.
<p>	For the purpose of centralized management of these shared resources,
	these new set of APIs are defined. These APIs will supersede the existing
	field data qualifier management APIs. 
	These APIs will control the management of the UDF resources and 
	the applications (like field, hashing etc..) will have APIs that use 
	these objects for programming the switch for the desired functionality.
<p>	API <tt>bcm_udf_create</tt> takes "layer" (base offset), "start" (relative offset) 
	and "width" (window of udf) inputs through <tt>bcm_udf_t</tt> input and allocates an 
	opaque <tt>bcm_udf_id_t</tt> handle to the UDF object thus created. 
	This API can optionally take "hints" from the user through <tt>bcm_udf_alloc_hints_t</tt>
	to reserve the hardware offset chunks in a manner that is best suitable for 
	other applications in the pipeline - Vlan Stage Field Processor,
	 Ingress Stage Field Processor, Flexible hashing entries etc...
<p>	A udf object will only be functional when it is associated with a packet format entry.
	A single udf object can be associated with multiple packet format entries and similarly
	a sinlge packet format entry can be associated with multiple udf objects.
	And when the udf is dissociated from all the packet format entries, the entry will
	be removed from hardware but the object would be removed from software only 
	when it is destroyed using <tt>bcm_udf_destroy</tt> API.
<p>	API <tt>bcm_udf_pkt_format_create</tt> creates a packet format matching entry to qualify
	the packets for UDF selection logic. This API returns a <tt>bcm_udf_pkt_format_entry_t</tt>
	handle to refer to the packet format entry thus created. 
<p>	In case of ambiguous packet format matching entries, the entry with the higher
	priority will take precedence and the udf selection will happen according to the 
	associated udf objects.
<p>	Since the number of udf objects are limited by the hardware, users can create
	shared objects that would use the same hardware offsets as the other udf but they
	need to be associated with different packet format entries.
<p>	These APIs supercede the <tt>bcm_field_data_qualifier_</tt>* APIs defined here:
	The intermixed usage is not supported.
<p><br><hr noshade><a name="udf_data_structures"></a>
<h3>Section 3.4.35.2:   UDF Data Structures
</h3>
<ul><li> The UDF.
 
<a name=bcm_udf_t></a>
 <blockquote><pre>typedef struct <tt>bcm_udf_s</tt> {
    uint32 flags;           /* See <tt>BCM_UDF_F_XXX</tt> */
    <tt>bcm_udf_layer_t</tt> layer;  /* UDF base offset. bcmUdfLayerXxx */
    int start;              /* Relative offset in bits (from the 'layer') in the
			       packet */
    uint32 width;           /* width of data in bits to extract */
} <tt>bcm_udf_t</tt>;
</pre></blockquote></li><li> UDF allocation hints.
 
<a name=bcm_udf_alloc_hints_t></a>
 <blockquote><pre>typedef struct <tt>bcm_udf_alloc_hints_s</tt> {
    uint32 flags;               /* See BCM_UDF_CREATE_O_xxx */
    <tt>bcm_udf_id_t</tt> <tt>shared_udf</tt>;    /* Used when <tt>BCM_UDF_CREATE_O_SHARED_HWID</tt> is set */
    <tt>bcm_field_qset_t</tt> qset;      /* Field group qset for optimal H/W resource
				   allocation */
} <tt>bcm_udf_alloc_hints_t</tt>;
</pre></blockquote></li><li> Packet format based UDF specification structure.
 
<a name=bcm_udf_pkt_format_info_t></a>
 <blockquote><pre>typedef struct <tt>bcm_udf_pkt_format_info_s</tt> {
    int prio;                       /* Priority of the UDF */
    <tt>bcm_ethertype_t</tt> ethertype;      /* Ethertype in the packet */
    <tt>bcm_ethertype_t</tt> <tt>ethertype_mask</tt>; /* Ethertype Mask */
    uint8 <tt>ip_protocol</tt>;              /* IP protocol field in the packet */
    uint8 <tt>ip_protocol_mask</tt>;         /* IP protocol Mask */
    uint16 l2;                      /* L2 packet format. (<tt>BCM_PKT_FORMAT_L2_XXX</tt>) */
    uint16 <tt>vlan_tag</tt>;                /* Vlan tag format.
				       (<tt>BCM_PKT_FORMAT_VLAN_XXX</tt>) */
    uint16 <tt>outer_ip</tt>;                /* Outer IP header type.
				       (<tt>BCM_PKT_FORMAT_IP_XXX</tt>) */
    uint16 <tt>inner_ip</tt>;                /* Inner IP header type.
				       (<tt>BCM_PKT_FORMAT_IP_XXX</tt>) */
    uint16 tunnel;                  /* Tunnel type. (<tt>BCM_PKT_FORMAT_TUNNEL_XXX</tt>) */
    uint16 mpls;                    /* Mpls labels. (<tt>BCM_PKT_FORMAT_MPLS_XXX</tt>) */
    uint16 <tt>fibre_chan_outer</tt>;        /* Fibre Channel outer header type.
				       (<tt>BCM_PKT_FORMAT_FIBRE_CHAN_XXX</tt>) */
    uint16 <tt>fibre_chan_inner</tt>;        /* Fibre Channel inner header
				       type.(<tt>BCM_PKT_FORMAT_FIBRE_CHAN_XXX</tt>) */
    uint16 higig;                   /* HIGIG packet
				       format.(<tt>BCM_PKT_FORMAT_HIGIG_XXX</tt>) */
    uint16 vntag;                   /* NIV packet
				       format.(<tt>BCM_PKT_FORMAT_VNTAG_XXX</tt>) */
    uint16 etag;                    /* Extender tag packet
				       format.(<tt>BCM_PKT_FORMAT_ETAG_XXX</tt>) */
    uint16 cntag;                   /* CNTAG packet
				       format.(<tt>BCM_PKT_FORMAT_CNTAG_XXX</tt>) */
    uint16 icnm;                    /* ICNM packet
				       format.(<tt>BCM_PKT_FORMAT_ICNM_XXX</tt>) */
} <tt>bcm_udf_pkt_format_info_t</tt>;
</pre></blockquote></li></ul>
<a name=udf_offset_flags></a>
<h3>Table 80:   Flags to control UDF extraction
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  flags</b></td><td><b> Description
 </b></td></tr><tr><td>  <tt>BCM_UDF_F_ADJUST_IP4_OPTIONS</tt></td><td> Adjust the UDF selection to ignore IPv4 options.
 </td></tr><tr><td>  <tt>BCM_UDF_F_ADJUST_IP6_OPTIONS</tt></td><td> Adjust the UDF selection to ignore IPv6 options.
 </td></tr></tbody></table>
<a name=udf_create_options></a>
<h3>Table 81:   Options to bcm_udf_create
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  flags</b></td><td><b> Description
 </b></td></tr><tr><td>  <tt>BCM_UDF_CREATE_O_NONE</tt></td><td> Default.
 </td></tr><tr><td>  <tt>BCM_UDF_CREATE_O_WITHID</tt></td><td> UDF Id from user will be used.
 </td></tr><tr><td>  <tt>BCM_UDF_CREATE_O_REPLACE</tt></td><td> Replace UDF.
 </td></tr><tr><td>  <tt>BCM_UDF_CREATE_O_FLEXHASH</tt></td><td> Hint to the API so the udf allocation is adjusted to be used by the flexible hashing entries.
 </td></tr><tr><td>  <tt>BCM_UDF_CREATE_O_FIELD_INGRESS</tt></td><td> Hint to the API so the udf allocation is adjusted to be used by Ingress Stage FP groups.
 </td></tr><tr><td>  <tt>BCM_UDF_CREATE_O_FIELD_LOOKUP</tt></td><td> Hint to the API so the udf allocation is adjusted to be used by Lookup Stage FP groups.
 </td></tr><tr><td>  <tt>BCM_UDF_CREATE_O_SHARED_HWID</tt></td><td> Use same hardware chunk position as the "<tt>shared_udf</tt>".
 </td></tr></tbody></table>
<a name=udf_pkt_format_options></a>
<h3>Table 82:   Options to bcm_udf_pkt_format_create
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  flags</b></td><td><b> Description
 </b></td></tr><tr><td>  <tt>BCM_UDF_PKT_FORMAT_CREATE_O_NONE</tt></td><td> Default.
 </td></tr><tr><td>  <tt>BCM_UDF_PKT_FORMAT_CREATE_O_WITHID</tt></td><td> Packet format Id from the user will be used.
 </td></tr><tr><td>  <tt>BCM_UDF_PKT_FORMAT_CREATE_O_REPLACE</tt></td><td> Replace packet format entry.
 </td></tr></tbody></table><p><br><hr noshade><a name="udf_apis"></a>
<h3>Section 3.4.35.3:   APIs to manage the UDF resources
</h3>
<p>	During <tt>bcm_init</tt>, The udf module will be initialized (or reinitialized, if warm-booting)
	before the field module is initialized. This is required, at least in case of
	warm reloading because the udf objects which are recovered in UDF module are 
	needed for appropriate object recovery while recovering field groups/entries.
<p><hr noshade>
<h3>APIs for Section 3.4.35.3:  APIs to manage the UDF resources
</h3>
<a name=bcm_udf_t_init></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_t_init</tt><br>
</h2>

<blockquote>
	Initializes the UDF structure
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	void 
	bcm_udf_t_init(
	    bcm_udf_t *udf_info);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>udf_info</tt></td><td>&nbsp;&nbsp;</td><td>
  (IN/OUT) Pointer to  <a href="#bcm_udf_t">Cross-Reference 283 (<tt>bcm_udf_t</tt>)</a>  structure
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Initializes the UDF structure
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_udf_alloc_hints_t_init></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_alloc_hints_t_init</tt><br>
</h2>

<blockquote>
	Initializes the UDF alloc hints structure
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	void 
	bcm_udf_alloc_hints_t_init(
	    bcm_udf_alloc_hints_t *udf_hints);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>udf_hints</tt></td><td>&nbsp;&nbsp;</td><td>
  (IN/OUT) Pointer to  <a href="#bcm_udf_alloc_hints_t">Cross-Reference 284 (<tt>bcm_udf_alloc_hints_t</tt>)</a>  structure
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Initializes the UDF alloc hints structure
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_udf_pkt_format_info_t_init></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_pkt_format_info_t_init</tt><br>
</h2>

<blockquote>
	Initialize the UDF packet format structure
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	void 
	bcm_udf_pkt_format_info_t_init(
	    bcm_udf_pkt_format_info_t *pkt_format);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>pkt_format</tt></td><td>&nbsp;&nbsp;</td><td>
  (IN/OUT) Pointer to  <a href="#bcm_udf_pkt_format_info_t">Cross-Reference 285 (<tt>bcm_udf_pkt_format_info_t</tt>)</a>  structure
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Initialize the UDF packet format structure
</blockquote><h3>RETURNS</h3><blockquote>
	BCM_E_xxx
</blockquote>
<a name=bcm_udf_init></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_init</tt><br>
</h2>

<blockquote>
	Initialize UDF module
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	int 
	bcm_udf_init(
	    int unit);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Initialize UDF module
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
      UDF module initialized successfully.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Invalid BCM Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNAVAIL</tt></td><td>&nbsp;&nbsp;</td><td>
 Feature not supported.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Standard error code.
</td></tr>
</table></blockquote>
<a name=bcm_udf_detach></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_detach</tt><br>
</h2>

<blockquote>
	Detach UDF module
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	int 
	bcm_udf_detach(
	    int unit);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Detach UDF module
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
      UDF module detached successfully.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Invalid BCM Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF module not initialized.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNAVAIL</tt></td><td>&nbsp;&nbsp;</td><td>
 Feature not supported.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Standard error code.
</td></tr>
</table></blockquote>
<a name=bcm_udf_create></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_create</tt><br>
</h2>

<blockquote>
	Creates a UDF object
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	int 
	bcm_udf_create(
	    int unit, 
	    bcm_udf_alloc_hints_t *hints, 
	    bcm_udf_t *udf_info, 
	    bcm_udf_id_t *udf_id);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>hints</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Hints to UDF allocator
 </td></tr>
<tr><td class="arg" valign="top"><tt>udf_info</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) UDF structure
 </td></tr>
<tr><td class="arg" valign="top"><tt>udf_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN/OUT) UDF ID
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
      UDF created successfully.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_EXISTS</tt></td><td>&nbsp;&nbsp;</td><td>
 Entry already exists.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_FULL</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF table full.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Invalid BCM Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF module not initialized.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNAVAIL</tt></td><td>&nbsp;&nbsp;</td><td>
 Feature not supported.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Standard error code.
</td></tr>
</table></blockquote>
<a name=bcm_udf_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_get</tt><br>
</h2>

<blockquote>
	Fetches the UDF object created in the system
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	int 
	bcm_udf_get(
	    int unit, 
	    bcm_udf_id_t udf_id, 
	    bcm_udf_t *udf_info);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>udf_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) UDF Object ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>udf_info</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) UDF info structure
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Fetches the UDF object created in the system
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
      UDF get successful.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NOT_FOUND</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF does not exist.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Invalid BCM Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF module not initialized.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNAVAIL</tt></td><td>&nbsp;&nbsp;</td><td>
 Feature not supported.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Standard error code.
</td></tr>
</table></blockquote>
<a name=bcm_udf_get_all></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_get_all</tt><br>
</h2>

<blockquote>
	Fetches all existing UDF ids
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	int 
	bcm_udf_get_all(
	    int unit, 
	    int max, 
	    bcm_udf_id_t *udf_id_list, 
	    int *actual);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>max</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Max number of UDF IDs
 </td></tr>
<tr><td class="arg" valign="top"><tt>udf_id_list</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) List of UDF IDs
 </td></tr>
<tr><td class="arg" valign="top"><tt>actual</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Actual udfs retrieved
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Fetches all existing UDF ids
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
      UDF get successful.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Invalid BCM Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF module not initialized.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNAVAIL</tt></td><td>&nbsp;&nbsp;</td><td>
 Feature not supported.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Standard error code.
</td></tr>
</table></blockquote>
<a name=bcm_udf_destroy></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_destroy</tt><br>
</h2>

<blockquote>
	Destroys the UDF object
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	int 
	bcm_udf_destroy(
	    int unit, 
	    bcm_udf_id_t udf_id);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>udf_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) UDF Object ID
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Destroys the UDF object
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
      UDF deleted successfully.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NOT_FOUND</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF does not exist.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Invalid BCM Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF module not initialized.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNAVAIL</tt></td><td>&nbsp;&nbsp;</td><td>
 Feature not supported.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Standard error code.
</td></tr>
</table></blockquote>
<a name=bcm_udf_pkt_format_create></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_pkt_format_create</tt><br>
</h2>

<blockquote>
	Create a packet format entry
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	int 
	bcm_udf_pkt_format_create(
	    int unit, 
	    bcm_udf_pkt_format_options_t options, 
	    bcm_udf_pkt_format_info_t *pkt_format, 
	    bcm_udf_pkt_format_id_t *pkt_format_id);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>options</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) API Options.
 </td></tr>
<tr><td class="arg" valign="top"><tt>pkt_format</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) UDF packet format info structure
 </td></tr>
<tr><td class="arg" valign="top"><tt>pkt_format_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN/OUT) Packet format ID
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Create a packet format entry in the software. The entry will be installed only when the packet format entry is added to the udf.
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
      UDF packet format entry created successfully.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Invalid BCM Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF module not initialized.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNAVAIL</tt></td><td>&nbsp;&nbsp;</td><td>
 Feature not supported.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Standard error code.
</td></tr>
</table></blockquote>
<a name=bcm_udf_pkt_format_info_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_pkt_format_info_get</tt><br>
</h2>

<blockquote>
	Retrieve packet format info given the packet format Id
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	int 
	bcm_udf_pkt_format_info_get(
	    int unit, 
	    bcm_udf_pkt_format_id_t pkt_format_id, 
	    bcm_udf_pkt_format_info_t *pkt_format);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
          (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>pkt_format_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Packet format ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>pkt_format</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) UDF packet format info structure
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Retrieve packet format info given the packet format Id
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
      Packet format get successful.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NOT_FOUND</tt></td><td>&nbsp;&nbsp;</td><td>
 Packet format entry does not exist.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Invalid BCM Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF module not initialized.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNAVAIL</tt></td><td>&nbsp;&nbsp;</td><td>
 Feature not supported.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Standard error code.
</td></tr>
</table></blockquote>
<a name=bcm_udf_pkt_format_destroy></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_pkt_format_destroy</tt><br>
</h2>

<blockquote>
	Destroy existing packet format entry
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	int 
	bcm_udf_pkt_format_destroy(
	    int unit, 
	    bcm_udf_pkt_format_id_t pkt_format_id);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
          (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>pkt_format_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Packet format ID
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Destroy existing packet format entry
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
      Destroy packet format entry.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NOT_FOUND</tt></td><td>&nbsp;&nbsp;</td><td>
 Packet format ID does not exist.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Invalid BCM Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF module not initialized.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNAVAIL</tt></td><td>&nbsp;&nbsp;</td><td>
 Feature not supported.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Standard error code.
</td></tr>
</table></blockquote>
<a name=bcm_udf_pkt_format_add></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_pkt_format_add</tt><br>
</h2>

<blockquote>
	Adds packet format entry to UDF object
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	int 
	bcm_udf_pkt_format_add(
	    int unit, 
	    bcm_udf_id_t udf_id, 
	    bcm_udf_pkt_format_id_t pkt_format_id);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
          (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>udf_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) UDF ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>pkt_format_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Packet format ID
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Adds packet format entry to UDF object
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
      Packet format entry added to UDF successfully.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NOT_FOUND</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF Id or packet format entry does not exist.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Invalid BCM Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF module not initialized.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNAVAIL</tt></td><td>&nbsp;&nbsp;</td><td>
 Feature not supported.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Standard error code.
</td></tr>
</table></blockquote>
<a name=bcm_udf_pkt_format_get></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_pkt_format_get</tt><br>
</h2>

<blockquote>
	Deletes packet format spec associated with the UDF
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	int 
	bcm_udf_pkt_format_get(
	    int unit, 
	    bcm_udf_pkt_format_id_t pkt_format_id, 
	    int max, 
	    bcm_udf_id_t *udf_id_list, 
	    int *actual);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
          (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>pkt_format_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) UDF Packet format ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>max</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Max number of UDF IDs
 </td></tr>
<tr><td class="arg" valign="top"><tt>udf_id_list</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) List of UDF IDs
 </td></tr>
<tr><td class="arg" valign="top"><tt>actual</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Actual udfs retrieved
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Deletes packet format spec associated with the UDF
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
      Success.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NOT_FOUND</tt></td><td>&nbsp;&nbsp;</td><td>
 Packet format not found.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Invalid BCM Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF module not initialized.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNAVAIL</tt></td><td>&nbsp;&nbsp;</td><td>
 Feature not supported.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Standard error code.
</td></tr>
</table></blockquote>
<a name=bcm_udf_pkt_format_delete></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_pkt_format_delete</tt><br>
</h2>

<blockquote>
	Deletes packet format spec associated with the UDF
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	int 
	bcm_udf_pkt_format_delete(
	    int unit, 
	    bcm_udf_id_t udf_id, 
	    bcm_udf_pkt_format_id_t pkt_format_id);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
          (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>udf_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) UDF ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>pkt_format_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Packet format ID
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Deletes packet format spec associated with the UDF
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
      Packet format configuration successfully deleted from UDF.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NOT_FOUND</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF Id or packet format entry does not exist.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Invalid BCM Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF module not initialized.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNAVAIL</tt></td><td>&nbsp;&nbsp;</td><td>
 Feature not supported.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Standard error code.
</td></tr>
</table></blockquote>
<a name=bcm_udf_pkt_format_get_all></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_pkt_format_get_all</tt><br>
</h2>

<blockquote>
	Retrieves the user defined format specification configuration from UDF
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	int 
	bcm_udf_pkt_format_get_all(
	    int unit, 
	    bcm_udf_id_t udf_id, 
	    int max, 
	    bcm_udf_pkt_format_id_t *pkt_format_id_list, 
	    int *actual);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>udf_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) UDF ID
 </td></tr>
<tr><td class="arg" valign="top"><tt>max</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) Max Packet formats attached to a UDF object
 </td></tr>
<tr><td class="arg" valign="top"><tt>pkt_format_id_list</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) List of packet format entries added to the udf id
 </td></tr>
<tr><td class="arg" valign="top"><tt>actual</tt></td><td>&nbsp;&nbsp;</td><td>
 (OUT) Actual number of Packet formats retrieved
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Retrieves the user defined format specification configuration from UDF
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
      Success.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NOT_FOUND</tt></td><td>&nbsp;&nbsp;</td><td>
 Either the UDF or packet format entry does not exist.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Invalid BCM Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF module not initialized.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNAVAIL</tt></td><td>&nbsp;&nbsp;</td><td>
 Feature not supported.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Standard error code.
</td></tr>
</table></blockquote>
<a name=bcm_udf_pkt_format_delete_all></a>
<hr noshade>
<h2 class="api">
<tt>bcm_udf_pkt_format_delete_all</tt><br>
</h2>

<blockquote>
	Deletes all packet format specs associated with the UDF
</blockquote><h3>SYNOPSIS</h3>
<blockquote><pre>	#include &lt;bcm/udf.h&gt;
	int 
	bcm_udf_pkt_format_delete_all(
	    int unit, 
	    bcm_udf_id_t udf_id);
</pre></blockquote><h3>PARAMETERS</h3>
<blockquote><table cellpadding=2 summary="parameters"><tr><td class="arg" valign="top"><tt>unit</tt></td><td>&nbsp;&nbsp;</td><td>
         (IN) Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>udf_id</tt></td><td>&nbsp;&nbsp;</td><td>
 (IN) UDF ID
</td></tr>
</table></blockquote><h3>DESCRIPTION</h3><blockquote>
	Deletes all packet format specs associated with the UDF
</blockquote><h3>RETURNS</h3><blockquote>
<table summary="return" cellpadding=2><tr><td class="arg" valign="top"><tt>BCM_E_NONE</tt></td><td>&nbsp;&nbsp;</td><td>
      Deletes all packet formats associated with the UDF.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_NOT_FOUND</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF Id does not exist.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNIT</tt></td><td>&nbsp;&nbsp;</td><td>
 Invalid BCM Unit number.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_INIT</tt></td><td>&nbsp;&nbsp;</td><td>
 UDF module not initialized.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_UNAVAIL</tt></td><td>&nbsp;&nbsp;</td><td>
 Feature not supported.
 </td></tr>
<tr><td class="arg" valign="top"><tt>BCM_E_XXX</tt></td><td>&nbsp;&nbsp;</td><td>
 Standard error code.
</td></tr>
</table></blockquote>
<p><p><br><br><hr noshade><br><br>
    <a name=section_testStats>
    <h3>Section 4:  Test Statistics
</h3>
<p> <br><hr noshade><a name="How-to-read-the-data"></a>
<h3>Section 4.1:   How to read the Data
</h3>
<p>        The below tables represent a spread of data gathered per-device, 
        per-suite, per-release. The percentages represent the aggregate 
        rate of failure for that suite when run against all variants of 
        the family of devices. 
 <p><br><hr noshade><a name="Overview"></a>
<h3>Section 4.2:   Overview
</h3>
<p>        Each suite listed below is indicative of a specific module. 
        Golden refers to a suite of tests that takes representation 
        across multiple modules and serves as a sanity regression.
        Each suite contains tests of various types, loosely categorized 
        as follows:
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td>  Test Categories</td><td> Description
 </td></tr><tr><td> Configuration Tests  
 </td><td> Tests that verify that each API functions appropriately and
               can configure the device as expected.
 </td></tr><tr><td> Functionality Tests  
 </td><td> Tests that further validate each of the API through functional
               use  often requiring traffic to be run through the system.
 </td></tr><tr><td> Semantic Tests  
 </td><td> Tests that ensure that the proper error handling mechanisms
               are working and users cannot crash the device through the API.
 </td></tr></tbody></table><p><br><hr noshade><a name="Note"></a>
<h3>Section 4.3:   Note
</h3>
<p>        The below data is not meant to be a precise indication of quality but
        instead serves as a guideline for improvements release-over-release.
        Additionally, although some cells show 0% failures, this does not
        necessarily mean the feature is supported in the device - tests are
        run to validate the appropriate SDK support even for unsupported
        features on older devices to ensure graceful handling of all API.
<p>        Finally, some devices have fewer columns listed if they were
        introduced recently.
<p>	Note on the suite titled "DVAPI": As of 6.3.6, the test suite labeled "DVAPI" has been split up into many sub-modules. This was done as a means to provide much clearer visibility both internally and externally for the quality of each device going forward. Because this change is not retroactive for past release data, data for previous releases will still contain the "DVAPI" suite. Level of quality can still be discerned via the other modules as well as the aggregate level (and it should be noted that even more tests have been added in 6.3.6, so there was no reduction in coverage). Future releases will continue to use the higher-granularity format.
<p><br><hr noshade><a name="Total-Tests"></a>
<h3>Section 4.4:   Total Tests
</h3>
<p>        The below data represents the number of unique cases for each release.
<p>        Note that although a particular test case will execute for each and
        every chip, it's only counted once.
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b></b></td><td><b> sdk-6.4.1
</b></td><td><b> sdk-6.4.0
</b></td><td><b> sdk-6.3.7
</b></td><td><b> sdk-6.2.9
</b></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td> golden
</td><td> 154
</td><td> 154
</td><td> 154
</td><td> 154
</td></tr><tr><td> warmboot
</td><td> 288
</td><td> 278
</td><td> 284
</td><td> 254
</td></tr><tr><td> auth
</td><td> 17
</td><td> N/A
</td><td> 17
</td><td> N/A
</td></tr><tr><td> bfd
</td><td> 37
</td><td> 16
</td><td> 37
</td><td> 16
</td></tr><tr><td> bhh
</td><td> 15
</td><td> 15
</td><td> 15
</td><td> 15
</td></tr><tr><td> chip
</td><td> 9
</td><td> N/A
</td><td> 10
</td><td> N/A
</td></tr><tr><td> cint
</td><td> 55
</td><td> N/A
</td><td> 55
</td><td> 52
</td></tr><tr><td> coe
</td><td> 510
</td><td> N/A
</td><td> 511
</td><td> N/A
</td></tr><tr><td> cosq
</td><td> 306
</td><td> 294
</td><td> 296
</td><td> 289
</td></tr><tr><td> custom
</td><td> 7
</td><td> N/A
</td><td> 7
</td><td> N/A
</td></tr><tr><td> dvapi*
</td><td> N/A
</td><td> 1003
</td><td> N/A
</td><td> 985
</td></tr><tr><td> ea
</td><td> 108
</td><td> N/A
</td><td> 108
</td><td> 108
</td></tr><tr><td> eav
</td><td> 19
</td><td> N/A
</td><td> 19
</td><td> N/A
</td></tr><tr><td> extender
</td><td> 12
</td><td> N/A
</td><td> 12
</td><td> N/A
</td></tr><tr><td> fabric
</td><td> 7
</td><td> N/A
</td><td> 7
</td><td> N/A
</td></tr><tr><td> failover
</td><td> 8
</td><td> N/A
</td><td> 8
</td><td> N/A
</td></tr><tr><td> fcoe
</td><td> 37
</td><td> 33
</td><td> 37
</td><td> N/A
</td></tr><tr><td> field
</td><td> 734
</td><td> 711
</td><td> 719
</td><td> 704
</td></tr><tr><td> higigproxy
</td><td> 129
</td><td> 129
</td><td> 129
</td><td> N/A
</td></tr><tr><td> infra
</td><td> 114
</td><td> N/A
</td><td> 114
</td><td> 114
</td></tr><tr><td> ipfix
</td><td> 17
</td><td> N/A
</td><td> 17
</td><td> N/A
</td></tr><tr><td> ipmc
</td><td> 56
</td><td> N/A
</td><td> 54
</td><td> N/A
</td></tr><tr><td> l2
</td><td> 230
</td><td> 229
</td><td> 230
</td><td> 222
</td></tr><tr><td> l2gre
</td><td> 13
</td><td> N/A
</td><td> 13
</td><td> N/A
</td></tr><tr><td> l3
</td><td> 241
</td><td> 219
</td><td> 239
</td><td> 211
</td></tr><tr><td> l3.alpm.combined
</td><td> 63
</td><td> 63
</td><td> 63
</td><td> N/A
</td></tr><tr><td> l3.alpm.combined.64
</td><td> 51
</td><td> 51
</td><td> 51
</td><td> N/A
</td></tr><tr><td> l3.alpm.parallel
</td><td> 63
</td><td> 63
</td><td> 63
</td><td> N/A
</td></tr><tr><td> l3.alpm.parallel.64
</td><td> 51
</td><td> 43
</td><td> 51
</td><td> N/A
</td></tr><tr><td> link
</td><td> 26
</td><td> N/A
</td><td> 26
</td><td> N/A
</td></tr><tr><td> mim
</td><td> 19
</td><td> N/A
</td><td> 19
</td><td> N/A
</td></tr><tr><td> mirror
</td><td> 146
</td><td> N/A
</td><td> 146
</td><td> N/A
</td></tr><tr><td> misc
</td><td> 16
</td><td> N/A
</td><td> 14
</td><td> N/A
</td></tr><tr><td> mpls
</td><td> 128
</td><td> 81
</td><td> 81
</td><td> 80
</td></tr><tr><td> multicast
</td><td> 17
</td><td> N/A
</td><td> 17
</td><td> N/A
</td></tr><tr><td> niv
</td><td> 13
</td><td> N/A
</td><td> 13
</td><td> N/A
</td></tr><tr><td> oam
</td><td> 133
</td><td> N/A
</td><td> N/A
</td><td> N/A
</td></tr><tr><td> pkt
</td><td> 44
</td><td> N/A
</td><td> 44
</td><td> N/A
</td></tr><tr><td> port
</td><td> 261
</td><td> N/A
</td><td> 260
</td><td> N/A
</td></tr><tr><td> proxy
</td><td> 23
</td><td> N/A
</td><td> 23
</td><td> N/A
</td></tr><tr><td> ptp
</td><td> 115
</td><td> 115
</td><td> 115
</td><td> 1
</td></tr><tr><td> qos
</td><td> 12
</td><td> N/A
</td><td> 12
</td><td> N/A
</td></tr><tr><td> rate
</td><td> 21
</td><td> N/A
</td><td> 21
</td><td> N/A
</td></tr><tr><td> rtag7
</td><td> 24
</td><td> 13
</td><td> 22
</td><td> 6
</td></tr><tr><td> rx
</td><td> 21
</td><td> N/A
</td><td> 21
</td><td> N/A
</td></tr><tr><td> ser
</td><td> 52
</td><td> 52
</td><td> 52
</td><td> N/A
</td></tr><tr><td> stack
</td><td> 49
</td><td> 49
</td><td> 49
</td><td> 49
</td></tr><tr><td> stat
</td><td> 203
</td><td> 98
</td><td> 200
</td><td> 65
</td></tr><tr><td> stg
</td><td> 42
</td><td> N/A
</td><td> 42
</td><td> N/A
</td></tr><tr><td> switch
</td><td> 130
</td><td> N/A
</td><td> 127
</td><td> N/A
</td></tr><tr><td> time
</td><td> 16
</td><td> N/A
</td><td> 16
</td><td> N/A
</td></tr><tr><td> tlvMsg
</td><td> 13
</td><td> 13
</td><td> 13
</td><td> 13
</td></tr><tr><td> trill
</td><td> 40
</td><td> 40
</td><td> 40
</td><td> 36
</td></tr><tr><td> trunk
</td><td> 173
</td><td> 173
</td><td> 173
</td><td> 139
</td></tr><tr><td> tunnel
</td><td> 65
</td><td> 65
</td><td> 65
</td><td> 65
</td></tr><tr><td> subport
</td><td> 33
</td><td> 12
</td><td> 12
</td><td> 12
</td></tr><tr><td> vlan
</td><td> 207
</td><td> 199
</td><td> 199
</td><td> 186
</td></tr><tr><td> vxlan
</td><td> 69
</td><td> 42
</td><td> 58
</td><td> 41
</td></tr><tr><td> wlan
</td><td> 17
</td><td> N/A
</td><td> 17
</td><td> N/A
</td></tr><tr><td> Test Suite Total
</td><td> 5479
</td><td> 4253
</td><td> 5209
</td><td> 3817
</td></tr></tbody></table>*Note on DVAPI: The DVAPI test suite has been split into many sub-module for higher visibility. Please see the "Note on the suite titled "DVAPI" in the Notes section above for more information.
<p><br><hr noshade><a name="Test-Results"></a>
<h3>Section 4.5:   Test Results
</h3>
<p>Below tables show percentages of failures for corresponding test suites per SDK release.
<br><hr noshade><a name="All-Results"></a>
<h3>Section 4.5.1:   All Devices
</h3>
<p>Note: This section represents aggregate results for all devices in the release. 
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b></b></td><td><b> sdk-6.4.1
</b></td><td><b> sdk-6.4.0
</b></td><td><b> sdk-6.3.7
</b></td><td><b> sdk-6.2.9
</b></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td> golden
</td><td> 1.5 %
</td><td> 2.4 %
</td><td> 1.8 %
</td><td> 5.1 %
</td></tr><tr><td> warmboot
</td><td> 1.5 %
</td><td> 3.2 %
</td><td> 1.5 %
</td><td> 8.2 %
</td></tr><tr><td> bcm.auth
</td><td> 0.2 %
</td><td> N/A
</td><td> 5.1 %
</td><td> N/A
</td></tr><tr><td> bcm.bfd
</td><td> 0.9 %
</td><td> 0.2 %
</td><td> 0.7 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.bhh
</td><td> 2.0 %
</td><td> 2.1 %
</td><td> 2.2 %
</td><td> 5.5 %
</td></tr><tr><td> bcm.chip
</td><td> 1.7 %
</td><td> N/A
</td><td> 10.8 %
</td><td> N/A
</td></tr><tr><td> bcm.cint
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> 13.0 %
</td></tr><tr><td> bcm.coe
</td><td> 0.4 %
</td><td> N/A
</td><td> 0.1 %
</td><td> N/A
</td></tr><tr><td> bcm.cosq
</td><td> 1.9 %
</td><td> 1.7 %
</td><td> 1.9 %
</td><td> 3.2 %
</td></tr><tr><td> bcm.custom
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.dvapi
</td><td> N/A
</td><td> 2.6 %
</td><td> N/A
</td><td> 3.4 %
</td></tr><tr><td> bcm.ea
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> 0.2 %
</td></tr><tr><td> bcm.eav
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.extender
</td><td> 0.1 %
</td><td> N/A
</td><td> 0.1 %
</td><td> N/A
</td></tr><tr><td> bcm.fabric
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.failover
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.fcoe
</td><td> 0.1 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.field
</td><td> 1.6 %
</td><td> 2.0 %
</td><td> 1.2 %
</td><td> 2.2 %
</td></tr><tr><td> bcm.higigproxy
</td><td> 0.9 %
</td><td> 1.6 %
</td><td> 0.9 %
</td><td> N/A
</td></tr><tr><td> bcm.infra
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.ipfix
</td><td> 0.7 %
</td><td> N/A
</td><td> 0.7 %
</td><td> N/A
</td></tr><tr><td> bcm.ipmc
</td><td> 0.8 %
</td><td> N/A
</td><td> 0.5 %
</td><td> N/A
</td></tr><tr><td> bcm.l2
</td><td> 1.5 %
</td><td> 3.1 %
</td><td> 2.1 %
</td><td> 1.8 %
</td></tr><tr><td> bcm.l2gre
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.l3
</td><td> 1.0 %
</td><td> 2.6 %
</td><td> 1.4 %
</td><td> 3.1 %
</td></tr><tr><td> bcm.l3.alpm.combined
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 10.4 %
</td></tr><tr><td> bcm.l3.alpm.combined.64
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.l3.alpm.parallel
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 10.2 %
</td></tr><tr><td> bcm.l3.alpm.parallel.64
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.link
</td><td> 0.1 %
</td><td> N/A
</td><td> 0.1 %
</td><td> N/A
</td></tr><tr><td> bcm.mim
</td><td> 0.1 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.mirror
</td><td> 2.8 %
</td><td> N/A
</td><td> 3.0 %
</td><td> N/A
</td></tr><tr><td> bcm.misc
</td><td> 0.8 %
</td><td> N/A
</td><td> 0.7 %
</td><td> N/A
</td></tr><tr><td> bcm.mpls
</td><td> 0.6 %
</td><td> 1.6 %
</td><td> 0.5 %
</td><td> 1.3 %
</td></tr><tr><td> bcm.multicast
</td><td> 2.6 %
</td><td> N/A
</td><td> 0.6 %
</td><td> N/A
</td></tr><tr><td> bcm.niv
</td><td> 0.1 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.oam
</td><td> 1.1 %
</td><td> N/A
</td><td> 0.3 %
</td><td> N/A
</td></tr><tr><td> bcm.perf
</td><td> N/A
</td><td> N/A
</td><td> N/A
</td><td> N/A
</td></tr><tr><td> bcm.pkt
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.port
</td><td> 1.5 %
</td><td> N/A
</td><td> 1.6 %
</td><td> N/A
</td></tr><tr><td> bcm.proxy
</td><td> 0.7 %
</td><td> N/A
</td><td> 0.7 %
</td><td> N/A
</td></tr><tr><td> bcm.ptp
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.qos
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.rate
</td><td> 0.9 %
</td><td> N/A
</td><td> 0.9 %
</td><td> N/A
</td></tr><tr><td> bcm.rtag7
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.2 %
</td><td> 0.2 %
</td></tr><tr><td> bcm.rx
</td><td> 0.9 %
</td><td> N/A
</td><td> 0.3 %
</td><td> N/A
</td></tr><tr><td> bcm.ser
</td><td> 0.5 %
</td><td> 0.3 %
</td><td> 1.7 %
</td><td> N/A
</td></tr><tr><td> bcm.stack
</td><td> 0.2 %
</td><td> 0.1 %
</td><td> 0.3 %
</td><td> 1.0 %
</td></tr><tr><td> bcm.stat
</td><td> 1.0 %
</td><td> 1.9 %
</td><td> 1.0 %
</td><td> 4.5 %
</td></tr><tr><td> bcm.stg
</td><td> 0.3 %
</td><td> N/A
</td><td> 0.2 %
</td><td> N/A
</td></tr><tr><td> bcm.switch
</td><td> 1.0 %
</td><td> N/A
</td><td> 2.7 %
</td><td> N/A
</td></tr><tr><td> bcm.time
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.tlvMsg
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.trill
</td><td> 1.1 %
</td><td> 2.9 %
</td><td> 0.4 %
</td><td> 10.5 %
</td></tr><tr><td> bcm.trunk
</td><td> 2.0 %
</td><td> 2.1 %
</td><td> 1.6 %
</td><td> 1.4 %
</td></tr><tr><td> bcm.tunnel
</td><td> 0.0 %
</td><td> 0.3 %
</td><td> 0.0 %
</td><td> 0.2 %
</td></tr><tr><td> bcm.subport
</td><td> 1.7 %
</td><td> 6.8 %
</td><td> 3.2 %
</td><td> 36.5 %
</td></tr><tr><td> bcm.vlan
</td><td> 1.2 %
</td><td> 2.0 %
</td><td> 1.1 %
</td><td> 1.4 %
</td></tr><tr><td> bcm.vxlan
</td><td> 0.1 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 2.2 %
</td></tr><tr><td> bcm.wlan
</td><td> 1.8 %
</td><td> N/A
</td><td> 1.1 %
</td><td> N/A
</td></tr><tr><td> Test Suite Total
</td><td> 1.1 %
</td><td> 1.9 %
</td><td> 1.2 %
</td><td> 2.8 %
</td></tr></tbody></table>*Note on DVAPI: The DVAPI test suite has been split into many sub-module for higher visibility. Please see the "Note on the suite titled "DVAPI" in the Notes section above for more information.
<p><br><hr noshade><a name="trident2-results"></a>
<h3>Section 4.5.2:   Trident2
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b></b></td><td><b> sdk-6.4.1
</b></td><td><b> sdk-6.4.0
</b></td><td><b> sdk-6.3.7
</b></td><td><b> sdk-6.2.9
</b></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td> golden
</td><td> 0.1 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 6.5 %
</td></tr><tr><td> warmboot
</td><td> 1.2 %
</td><td> 2.3 %
</td><td> 1.2 %
</td><td> 11.3 %
</td></tr><tr><td> bcm.auth
</td><td> 0.0 %
</td><td> N/A
</td><td> 5.9 %
</td><td> N/A
</td></tr><tr><td> bcm.bfd
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.bhh
</td><td> N/A
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.chip
</td><td> 0.0 %
</td><td> N/A
</td><td> 10.0 %
</td><td> N/A
</td></tr><tr><td> bcm.cint
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> 13.5 %
</td></tr><tr><td> bcm.coe
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.cosq
</td><td> 0.7 %
</td><td> 0.3 %
</td><td> 0.7 %
</td><td> 3.1 %
</td></tr><tr><td> bcm.custom
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.dvapi
</td><td> N/A
</td><td> 1.2 %
</td><td> N/A
</td><td> 2.7 %
</td></tr><tr><td> bcm.ea
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.eav
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.extender
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.fabric
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.failover
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.fcoe
</td><td> 2.7 %
</td><td> 3.6 %
</td><td> 2.7 %
</td><td> N/A
</td></tr><tr><td> bcm.field
</td><td> 0.9 %
</td><td> 0.8 %
</td><td> 0.4 %
</td><td> 1.1 %
</td></tr><tr><td> bcm.higigproxy
</td><td> 0.6 %
</td><td> 0.8 %
</td><td> 0.8 %
</td><td> N/A
</td></tr><tr><td> bcm.infra
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.ipfix
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.ipmc
</td><td> 3.1 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.l2
</td><td> 0.8 %
</td><td> 1.3 %
</td><td> 1.3 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.l2gre
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.l3
</td><td> 0.6 %
</td><td> 0.9 %
</td><td> 0.4 %
</td><td> 0.5 %
</td></tr><tr><td> bcm.l3.alpm.combined
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.l3.alpm.combined.64
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.l3.alpm.parallel
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.l3.alpm.parallel.64
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.link
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.mim
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.mirror
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.misc
</td><td> 1.8 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.mpls
</td><td> 0.8 %
</td><td> 1.7 %
</td><td> 1.2 %
</td><td> 1.3 %
</td></tr><tr><td> bcm.multicast
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.niv
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.oam
</td><td> 0.8 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.pkt
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.port
</td><td> 1.3 %
</td><td> N/A
</td><td> 0.8 %
</td><td> N/A
</td></tr><tr><td> bcm.proxy
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.ptp
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.qos
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.rate
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.rtag7
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.rx
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.ser
</td><td> 3.8 %
</td><td> 1.9 %
</td><td> 3.8 %
</td><td> N/A
</td></tr><tr><td> bcm.stack
</td><td> 0.3 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.stat
</td><td> 0.5 %
</td><td> 0.0 %
</td><td> N/A
</td><td> 3.1 %
</td></tr><tr><td> bcm.stg
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.switch
</td><td> 1.1 %
</td><td> N/A
</td><td> 4.7 %
</td><td> N/A
</td></tr><tr><td> bcm.time
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.tlvMsg
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.trill
</td><td> 0.0 %
</td><td> 5.0 %
</td><td> 0.0 %
</td><td> 25.0 %
</td></tr><tr><td> bcm.trunk
</td><td> 2.0 %
</td><td> 2.3 %
</td><td> 2.9 %
</td><td> 1.4 %
</td></tr><tr><td> bcm.tunnel
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.subport
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 50.0 %
</td></tr><tr><td> bcm.vlan
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.5 %
</td><td> 1.1 %
</td></tr><tr><td> bcm.vxlan
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 24.4 %
</td></tr><tr><td> bcm.wlan
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> Test Suite Total
</td><td> 0.7 %
</td><td> 0.9 %
</td><td> 0.7 %
</td><td> 2.5 %
</td></tr></tbody></table>*Note on DVAPI: The DVAPI test suite has been split into many sub-module for higher visibility. Please see the "Note on the suite titled "DVAPI" in the Notes section above for more information.
<p><br><hr noshade><a name="triumph3-results"></a>
<h3>Section 4.5.3:   Triumph3
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b></b></td><td><b> sdk-6.4.1
</b></td><td><b> sdk-6.4.0
</b></td><td><b> sdk-6.3.7
</b></td><td><b> sdk-6.2.9
</b></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td> golden
</td><td> 0.2 %
</td><td> 0.0 %
</td><td> 1.0 %
</td><td> 8.9 %
</td></tr><tr><td> warmboot
</td><td> 1.4 %
</td><td> 2.5 %
</td><td> 1.0 %
</td><td> 8.4 %
</td></tr><tr><td> bcm.auth
</td><td> 0.0 %
</td><td> N/A
</td><td> 5.3 %
</td><td> N/A
</td></tr><tr><td> bcm.bfd
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.bhh
</td><td> 2.2 %
</td><td> 0.0 %
</td><td> 5.8 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.chip
</td><td> 0.0 %
</td><td> N/A
</td><td> 11.0 %
</td><td> N/A
</td></tr><tr><td> bcm.cint
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 13.5 %
</td></tr><tr><td> bcm.coe
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.cosq
</td><td> 1.0 %
</td><td> 0.0 %
</td><td> 0.8 %
</td><td> 3.3 %
</td></tr><tr><td> bcm.custom
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.dvapi
</td><td> N/A
</td><td> 1.8 %
</td><td> N/A
</td><td> 3.8 %
</td></tr><tr><td> bcm.ea
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.eav
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.extender
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.9 %
</td><td> N/A
</td></tr><tr><td> bcm.fabric
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.failover
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.fcoe
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.field
</td><td> 3.6 %
</td><td> 8.0 %
</td><td> 3.5 %
</td><td> 4.6 %
</td></tr><tr><td> bcm.higigproxy
</td><td> 0.8 %
</td><td> 2.3 %
</td><td> 0.8 %
</td><td> N/A
</td></tr><tr><td> bcm.infra
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.ipfix
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.6 %
</td><td> N/A
</td></tr><tr><td> bcm.ipmc
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.5 %
</td><td> N/A
</td></tr><tr><td> bcm.l2
</td><td> 1.3 %
</td><td> 2.6 %
</td><td> 2.6 %
</td><td> 2.3 %
</td></tr><tr><td> bcm.l2gre
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.l3
</td><td> 0.4 %
</td><td> 2.3 %
</td><td> 0.8 %
</td><td> 4.8 %
</td></tr><tr><td> bcm.link
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.mim
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.mirror
</td><td> 0.0 %
</td><td> N/A
</td><td> 1.4 %
</td><td> N/A
</td></tr><tr><td> bcm.misc
</td><td> 2.3 %
</td><td> N/A
</td><td> 2.1 %
</td><td> N/A
</td></tr><tr><td> bcm.mpls
</td><td> 1.4 %
</td><td> 1.7 %
</td><td> 0.0 %
</td><td> 0.3 %
</td></tr><tr><td> bcm.multicast
</td><td> 5.9 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.niv
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.oam
</td><td> 0.8 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.pkt
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.port
</td><td> 2.4 %
</td><td> N/A
</td><td> 3.3 %
</td><td> N/A
</td></tr><tr><td> bcm.proxy
</td><td> 0.5 %
</td><td> N/A
</td><td> 0.9 %
</td><td> N/A
</td></tr><tr><td> bcm.ptp
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.qos
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.rate
</td><td> 3.3 %
</td><td> N/A
</td><td> 3.3 %
</td><td> N/A
</td></tr><tr><td> bcm.rtag7
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.rx
</td><td> 0.9 %
</td><td> N/A
</td><td> 0.6 %
</td><td> N/A
</td></tr><tr><td> bcm.ser
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.stack
</td><td> 0.7 %
</td><td> 0.0 %
</td><td> 1.0 %
</td><td> 4.8 %
</td></tr><tr><td> bcm.stat
</td><td> 0.5 %
</td><td> 0.0 %
</td><td> 2.5 %
</td><td> 17.6 %
</td></tr><tr><td> bcm.stg
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.switch
</td><td> 1.1 %
</td><td> N/A
</td><td> 3.7 %
</td><td> N/A
</td></tr><tr><td> bcm.time
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.tlvMsg
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.trill
</td><td> 3.1 %
</td><td> 5.0 %
</td><td> 3.3 %
</td><td> 27.8 %
</td></tr><tr><td> bcm.trunk
</td><td> 0.8 %
</td><td> 1.2 %
</td><td> 0.6 %
</td><td> 1.9 %
</td></tr><tr><td> bcm.tunnel
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.8 %
</td></tr><tr><td> bcm.subport
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 42.4 %
</td></tr><tr><td> bcm.vlan
</td><td> 0.0 %
</td><td> 2.0 %
</td><td> 1.0 %
</td><td> 2.6 %
</td></tr><tr><td> bcm.vxlan
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.wlan
</td><td> 3.2 %
</td><td> N/A
</td><td> 3.5 %
</td><td> N/A
</td></tr><tr><td> Test Suite Total
</td><td> 1.5 %
</td><td> 2.5 %
</td><td> 1.7 %
</td><td> 4.1 %
</td></tr></tbody></table>*Note on DVAPI: The DVAPI test suite has been split into many sub-module for higher visibility. Please see the "Note on the suite titled "DVAPI" in the Notes section above for more information.
<p><br><hr noshade><a name="Hurricane2-results"></a>
<h3>Section 4.5.4:   Hurricane2
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b></b></td><td><b> sdk-6.4.1
</b></td><td><b> sdk-6.4.0
</b></td><td><b> sdk-6.3.7
</b></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td> golden
</td><td> 0.2 %
</td><td> 3.2 %
</td><td> 0.1 %
</td></tr><tr><td> warmboot
</td><td> 2.1 %
</td><td> 4.1 %
</td><td> 0.4 %
</td></tr><tr><td> bcm.auth
</td><td> 0.0 %
</td><td> N/A
</td><td> 5.9 %
</td></tr><tr><td> bcm.bfd
</td><td> N/A
</td><td> N/A
</td><td> N/A
</td></tr><tr><td> bcm.bhh
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.chip
</td><td> 0.0 %
</td><td> N/A
</td><td> 21.4 %
</td></tr><tr><td> bcm.cint
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.coe
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.cosq
</td><td> 0.0 %
</td><td> 0.3 %
</td><td> 0.3 %
</td></tr><tr><td> bcm.custom
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.dvapi
</td><td> N/A
</td><td> 1.4 %
</td><td> N/A
</td></tr><tr><td> bcm.ea
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.eav
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.extender
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.fabric
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.failover
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.fcoe
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.field
</td><td> 0.7 %
</td><td> 1.7 %
</td><td> 0.8 %
</td></tr><tr><td> bcm.higigproxy
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.infra
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.ipfix
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.ipmc
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.l2
</td><td> 0.3 %
</td><td> 1.3 %
</td><td> 1.1 %
</td></tr><tr><td> bcm.l2gre
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.l3
</td><td> 0.4 %
</td><td> 0.9 %
</td><td> 0.8 %
</td></tr><tr><td> bcm.link
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.mim
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.mirror
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.misc
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.mpls
</td><td> 0.0 %
</td><td> 0.9 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.multicast
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.niv
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.pkt
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.port
</td><td> 1.7 %
</td><td> N/A
</td><td> 1.7 %
</td></tr><tr><td> bcm.proxy
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.ptp
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.qos
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.rate
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.rtag7
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.rx
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.ser
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.stack
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.stat
</td><td> 0.1 %
</td><td> 0.0 %
</td><td> 0.1 %
</td></tr><tr><td> bcm.stg
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.switch
</td><td> 1.5 %
</td><td> N/A
</td><td> 2.4 %
</td></tr><tr><td> bcm.time
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.tlvMsg
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.trill
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.trunk
</td><td> 0.5 %
</td><td> 1.2 %
</td><td> 0.4 %
</td></tr><tr><td> bcm.tunnel
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.subport
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.vlan
</td><td> 1.5 %
</td><td> 2.9 %
</td><td> 1.4 %
</td></tr><tr><td> bcm.vxlan
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.wlan
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> Test Suite Total
</td><td> 0.4 %
</td><td> 1.1 %
</td><td> 0.6 %
</td></tr></tbody></table>*Note on DVAPI: The DVAPI test suite has been split into many sub-module for higher visibility. Please see the "Note on the suite titled "DVAPI" in the Notes section above for more information.
<p><br><hr noshade><a name="Helix4-results"></a>
<h3>Section 4.5.5:   Helix4
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b></b></td><td><b> sdk-6.4.1
</b></td><td><b> sdk-6.4.0
</b></td><td><b> sdk-6.3.7
</b></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td> golden
</td><td> 0.3 %
</td><td> 1.3 %
</td><td> 0.0 %
</td></tr><tr><td> warmboot
</td><td> 2.4 %
</td><td> 3.6 %
</td><td> 3.2 %
</td></tr><tr><td> bcm.auth
</td><td> 0.0 %
</td><td> N/A
</td><td> 5.9 %
</td></tr><tr><td> bcm.bfd
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.bhh
</td><td> N/A
</td><td> 0.0 %
</td><td> N/A
</td></tr><tr><td> bcm.cfd
</td><td> N/A
</td><td> N/A
</td><td> 7.1 %
</td></tr><tr><td> bcm.chip
</td><td> 0.0 %
</td><td> N/A
</td><td> 10.0 %
</td></tr><tr><td> bcm.cint
</td><td> 0.0 %
</td><td> N/A
</td><td> 1.8 %
</td></tr><tr><td> bcm.coe
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.cosq
</td><td> 0.7 %
</td><td> 0.0 %
</td><td> 0.7 %
</td></tr><tr><td> bcm.custom
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.dvapi
</td><td> N/A
</td><td> 1.8 %
</td><td> N/A
</td></tr><tr><td> bcm.ea
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.eav
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.extender
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.fabric
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.failover
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.fcoe
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.field
</td><td> 1.5 %
</td><td> 1.1 %
</td><td> 1.0 %
</td></tr><tr><td> bcm.higigproxy
</td><td> 0.8 %
</td><td> 2.3 %
</td><td> 0.8 %
</td></tr><tr><td> bcm.infra
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.ipfix
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.ipmc
</td><td> 0.4 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.l2
</td><td> 0.4 %
</td><td> 3.9 %
</td><td> 1.7 %
</td></tr><tr><td> bcm.l2gre
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.l3
</td><td> 0.1 %
</td><td> 2.7 %
</td><td> 0.8 %
</td></tr><tr><td> bcm.link
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.mim
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.mirror
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.misc
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.mpls
</td><td> 0.0 %
</td><td> 0.9 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.multicast
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.niv
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.pkt
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.port
</td><td> 1.3 %
</td><td> N/A
</td><td> 1.9 %
</td></tr><tr><td> bcm.proxy
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.ptp
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.qos
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.rate
</td><td> 4.8 %
</td><td> N/A
</td><td> 4.8 %
</td></tr><tr><td> bcm.rtag7
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.rx
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.ser
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.stack
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.stat
</td><td> 0.5 %
</td><td> 1.0 %
</td><td> 0.5 %
</td></tr><tr><td> bcm.stg
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.switch
</td><td> 0.0 %
</td><td> N/A
</td><td> 1.6 %
</td></tr><tr><td> bcm.time
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.tlvMsg
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.trill
</td><td> 0.0 %
</td><td> 5.0 %
</td><td> 2.5 %
</td></tr><tr><td> bcm.trunk
</td><td> 0.6 %
</td><td> 0.6 %
</td><td> 0.6 %
</td></tr><tr><td> bcm.tunnel
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.subport
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.vlan
</td><td> 0.6 %
</td><td> 2.0 %
</td><td> 2.0 %
</td></tr><tr><td> bcm.vxlan
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.wlan
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> Test Suite Total
</td><td> 0.6 %
</td><td> 1.4 %
</td><td> 0.8 %
</td></tr></tbody></table>*Note on DVAPI: The DVAPI test suite has been split into many sub-module for higher visibility. Please see the "Note on the suite titled "DVAPI" in the Notes section above for more information.
<p><br><hr noshade><a name="Katana2-results"></a>
<h3>Section 4.5.6:   Katana2
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b></b></td><td><b> sdk-6.4.1
</b></td><td><b> sdk-6.4.0
</b></td><td><b> sdk-6.3.7
</b></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td> golden
</td><td> 1.1 %
</td><td> 2.6 %
</td><td> 1.2 %
</td></tr><tr><td> warmboot
</td><td> 1.4 %
</td><td> 5.5 %
</td><td> 2.4 %
</td></tr><tr><td> bcm.auth
</td><td> 0.0 %
</td><td> N/A
</td><td> 5.9 %
</td></tr><tr><td> bcm.bfd
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.bhh
</td><td> 5.4 %
</td><td> 0.0 %
</td><td> 6.7 %
</td></tr><tr><td> bcm.chip
</td><td> 0.0 %
</td><td> N/A
</td><td> 10.0 %
</td></tr><tr><td> bcm.cint
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.coe
</td><td> 1.7 %
</td><td> N/A
</td><td> 1.7 %
</td></tr><tr><td> bcm.cosq
</td><td> 1.9 %
</td><td> 1.4 %
</td><td> 2.0 %
</td></tr><tr><td> bcm.custom
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.dvapi
</td><td> N/A
</td><td> 1.8 %
</td><td> N/A
</td></tr><tr><td> bcm.ea
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.eav
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.extender
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.fabric
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.failover
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.fcoe
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.field
</td><td> 0.9 %
</td><td> 1.5 %
</td><td> 0.9 %
</td></tr><tr><td> bcm.higigproxy
</td><td> 0.4 %
</td><td> 0.8 %
</td><td> 0.5 %
</td></tr><tr><td> bcm.infra
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.ipfix
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.ipmc
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.l2
</td><td> 1.0 %
</td><td> 3.1 %
</td><td> 2.1 %
</td></tr><tr><td> bcm.l2gre
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.l3
</td><td> 1.5 %
</td><td> 3.2 %
</td><td> 3.0 %
</td></tr><tr><td> bcm.link
</td><td> 1.1 %
</td><td> N/A
</td><td> 1.3 %
</td></tr><tr><td> bcm.mim
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.mirror
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.misc
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.mpls
</td><td> 2.6 %
</td><td> 2.6 %
</td><td> 1.2 %
</td></tr><tr><td> bcm.multicast
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.niv
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.pkt
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.port
</td><td> 2.8 %
</td><td> N/A
</td><td> 2.9 %
</td></tr><tr><td> bcm.proxy
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.ptp
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.qos
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.rate
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.rtag7
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.rx
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.ser
</td><td> 2.9 %
</td><td> 0.0 %
</td><td> 11.5 %
</td></tr><tr><td> bcm.stack
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.stat
</td><td> 0.5 %
</td><td> 0.0 %
</td><td> 0.3 %
</td></tr><tr><td> bcm.stg
</td><td> 0.3 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.switch
</td><td> 0.0 %
</td><td> N/A
</td><td> 1.6 %
</td></tr><tr><td> bcm.time
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.tlvMsg
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> bcm.trill
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.trunk
</td><td> 0.4 %
</td><td> 1.2 %
</td><td> 0.4 %
</td></tr><tr><td> bcm.tunnel
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.subport
</td><td> 12.1 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.vlan
</td><td> 0.3 %
</td><td> 2.9 %
</td><td> 2.0 %
</td></tr><tr><td> bcm.vxlan
</td><td> 0.0 %
</td><td> 0.0 %
</td><td> 0.0 %
</td></tr><tr><td> bcm.wlan
</td><td> 0.0 %
</td><td> N/A
</td><td> 0.0 %
</td></tr><tr><td> Test Suite Total
</td><td> 1.6 %
</td><td> 1.5 %
</td><td> 1.3 %
</td></tr></tbody></table>*Note on DVAPI: The DVAPI test suite has been split into many sub-module for higher visibility. Please see the "Note on the suite titled "DVAPI" in the Notes section above for more information.
<p><p><br><hr noshade><a name="code-quality-analysis"></a>
<h3>Section 4.6:   Static Code quality analysis
</h3>
<p>      Continued progress in whittling down static analysis defects per plan.  
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td></td><td> Initial Reported Issues
 </td><td> Reported Issues SDK 6.3.3
 </td><td> Reported Issues SDK 6.3.4
 </td><td> Reported Issues SDK 6.3.5
 </td><td> Reported Issues SDK 6.3.6
 </td><td> Reported Issues SDK 6.3.7
 </td><td> Reported Issues SDK 6.4.1
</td></tr><tr><td> DNX
 </td><td> 664
 </td><td> 688
 </td><td> 628
 </td><td> 125
 </td><td> 125
 </td><td> 129
 </td><td> 131
</td></tr><tr><td> XGS
 </td><td> 271
 </td><td> 292
 </td><td> 327
 </td><td> 155
 </td><td> 135
 </td><td> 131
 </td><td> 123
</td></tr><tr><td> SBX
 </td><td> 600
 </td><td> 421
 </td><td> 323
 </td><td> 281
 </td><td> 140
 </td><td> 0
 </td><td> 0
</td></tr><tr><td> SerDes
 </td><td> 147
 </td><td> 147
 </td><td> 133
 </td><td> 101
 </td><td> 91
 </td><td> 76
 </td><td> 74
</td></tr><tr><td> Common
 </td><td> 2827
 </td><td> 408
 </td><td> 188
 </td><td> 360
 </td><td> 244
 </td><td> 245
 </td><td> 200
</td></tr><tr><td> Total
 </td><td> 4509
 </td><td> 1956
 </td><td> 1599
 </td><td> 1022
 </td><td> 735
 </td><td> 571
 </td><td> 528
</td></tr></tbody></table><p><br><br><hr noshade><br><br>
    <a name=section_resolved6.4.1>
    <h3>Section 5:  Resolved Issues for 6.4.1
</h3>
<p>The following issues are resolved in version 6.4.1 of the SDK.
<p><table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> Number
 </b></td><td><b> CSP #
 </b></td><td><b> Chips
 </b></td><td><b> Release Notes For 6.4.1
</b></td></tr><tr><td> SDK-32461 
 </td><td></td><td> 56846_A0
56845_B0
56845_A2
56844_A0
56842_A0
56840_A0
56746_A0
56745_A0
56744_A0
56743_A0
 </td><td> Problem: WRED thresholds were not taking effect because of hardware issue.
<p>Solution: Implemented workaround in software to get WRED memories into stable state.
<p>This workaround does below thinks to put WRED memories in stable state.
<p>1. Selects 4 Ethernet ports (one 
extended queue port from X,Y pipeline 
and one regular port from X, Y 
pipeline.
2. Configures all 4 ports in MAC 
loopback.
3. Disables CRC re-calculation on all 4 
egress ports.
4. Enables CRC checks and configures 
<tt>ING_PRI_CNG_MAP</tt> table to mark 
incoming traffic with red color.
5. Add's l2 mac address in l2 table to 
switch the packets to all 4 ports.
6. Prepares 8 multi cell unicast SOBMH 
packets, configured DMA descriptor's 
and starts DMA engine.
<p>These SOBMH packets will be loopbacked with bad CRC since we disabled CRC re-calculation on egress ports and switches to all 4 egress ports. Since these packets have CRC errors MMU will drop the packets after receiving EOP and stabilizes the WRED memories.
</td></tr><tr><td> SDK-34523 
 </td><td></td><td> 56820_A0
56820_B0
 </td><td> In previous SDK, customer found a crash on 56820 when the SDK was handling a MMU parity error.
The root cause of this crash was the SDK visited an unavailable memory.
Now this issue has been resolved.
</td></tr><tr><td> SDK-36232 
 </td><td> 460304
 </td><td> All
56850_A0
 </td><td> In previous release, A L2 multicast with flag <tt>BCM_MULTICAST_WITH_ID</tt> and Group_ID was created by <tt>bcm_multicast_create</tt>, but the HW index in Group_ID was already occupied by other multicast group, than the existing entry could be overwrote and return <tt>BCM_E_NONE</tt>. In this release, it will return <tt>BCM_E_EXISTS</tt> and won't overwrite the existing entry.
</td></tr><tr><td> SDK-38881 
 </td><td></td><td> All
 </td><td> <tt>bcm_port_priority_color_set</tt> is modified to set color as none when color param to API is bcmColorPreserve.
</td></tr><tr><td> SDK-41357 
 </td><td> 469082
 </td><td> 56842_A0
 </td><td> There is an issue with the h/w logic related to the parity generation and checking for the <tt>PORT_CBL_TABLE</tt> memory. In this release occasional spurious reports of a parity error in <tt>PORT_CBL_TABLE</tt> has been fixed.
</td></tr><tr><td> SDK-42031 
 </td><td></td><td> 88650_A0
 </td><td> Error indication was added to prevent AC P2P to PWE or to Mac-In-Mac inner vlan editing (VID-2 in LIF table) which is not supported by HW.
</td></tr><tr><td> SDK-42289 
 </td><td> 565794
 </td><td> 88650_A0
 </td><td> Static forwarding (i.e. <tt>bcm_port_force_forward_set</tt> API) can be used both in TM and PP modes.
Some fixes are done to enable it also in TM mode.
</td></tr><tr><td> SDK-42527 
 </td><td></td><td> 88650_A0
 </td><td> SDK-42527: Support TR 90 and TR91 for the ARAD.
</td></tr><tr><td> SDK-42957 
 </td><td> 580600
 </td><td> 88025_A0
 </td><td> Support for Down MEP on VPWS/VPLS attachment circuits is fixed.
</td></tr><tr><td> SDK-42987 
 </td><td> 580192
 </td><td> 56850_A0
 </td><td> Legacy method to add route entries to LPM table may trigger re-shuffling logic which could lead to massive HW entry movement. In the worst case, the memory read operation times of LPM tables could be very high and eventually cause bad route convergence time. A request was received to reduce the totaled time costs for bulk route add operation. This was achieved by enabling soc memory cache for route add/delete operation to reduce memory read time costs. Can be turned on/off by switch control bcmSwitchL3RouteCache. Read HIT* bits could be wrong during caching time.
</td></tr><tr><td> SDK-44506 
 </td><td> 593957
 </td><td> 56842_A0
 </td><td> Added a new soc property (<tt>L3_DISABLE_ADD_TO_ARL</tt>) to restrict applications to create L2 interface entry and L3 interface entry separately. SDK uses this property to recover the association between L2 entries and L3 entries during warmboot. Currently, during warmboot, SDK associates L3 entries with L2 entries assuming that they were created with <tt>BCM_L3_ADD_TO_ARL</tt> flag during <tt>l3_intf_create</tt>. Later, when L3 interface is deleted, SDK deletes the L2 entry also.
</td></tr><tr><td> SDK-44591 
 </td><td></td><td> 56840_A0
56640_A0
56640_A1
56640_B0
 </td><td> Current implementation is not in-line with the issue.
Function: <tt>wcmod_esm_serdes_control_get</tt>(int unit, int lane, <tt>soc_phy_control_t</tt> type, uint32 *value)
<p> case <tt>SOC_PHY_CONTROL_DUMP</tt>:
           rv = <tt>wcmod_uc_status_dump</tt> (unit, port, <tt>NULL</tt>);
           break;
<p>'value' variable is not being used in this call.
</td></tr><tr><td> SDK-44736 
 </td><td></td><td> 56850_A1
 </td><td> The 3-lane TSC configuration is now transcribed properly to TSC 31.
</td></tr><tr><td> SDK-44989 
 </td><td></td><td> 88660_A0
 </td><td> Supporting OAMP protection packets in 88660. To enable this feature, call <tt>bcm_rx_trap_type_create</tt>() with the flag <tt>WITH_ID</tt>, <tt>trap_type</tt> bcmRxTrapOampProtection and a trap id in the range 0x400  0x4ff, followed by <tt>bcm_rx_trap_set</tt>() with the trap id created in the above API, and a <tt>bcm_rx_trap_config_t</tt> with the field <tt>dest_port</tt> set to the destination of the protection packets. All other fields should remain blank (an example of this is found in <tt>cint_oam</tt>.c). Whenever an OAM event occurs, a protection packet of size 71 bytes will be sent to the destination selected above. The format of the Protection packet at the CPU will be FTMHoPPHoFHEI. The FHEI.CPU-TRAP-CODE field will be set to the LSB of the trap id selected in <tt>bcm_rx_trap_type_create</tt>(). The size of the protection packet will always be 71 bytes where the OAM events will be on the bottommost part of the packet.
</td></tr><tr><td> SDK-45246 
 </td><td></td><td> 56840_A0
 </td><td> Implemented "bcmFieldActionL3ChangeMacDa" and "bcmFieldActionL3ChangeVlan" actions for TD2 device,TR3 and KATANAx devices. The actions expect the egress-object (l3 next hop index) which should be already created by L3 module and the ID should not be associated with any other modules. The actions are to replace the destination MAC and VLAN on the matched incoming packet with the MAC and VLAN associated with the given next hop index.
</td></tr><tr><td> SDK-45535 
 </td><td></td><td> 88650_B0
 </td><td> OAM endpoint: It is now possible to create an OAM endpoint over LAG.
This is done by adding the endpoint on the LAG port and separately configuring the mac address of the endpoint on each one of the LAG ports using <tt>bcm_l2_station_add</tt>.
An example can be found in <tt>cint_oam_over_endpoint</tt>.c
In addition CINT includes a cleanup function, and an option to set VLAN-Ports lifs over lag without defining an OAM endpoint.
</td></tr><tr><td> SDK-46635 
 </td><td> 625709
 </td><td> 56640_A0
56640_A1
56640_B0
 </td><td> Added a new SOC property "<tt>ext_tcam_request_response_latency</tt>" and a new "tcam latency" bcm shell command for TR3 with external TCAM. Customers can execute the bcm command to calculate the latency and then specify the SOC property using the latency value in config file.
</td></tr><tr><td> SDK-46641 
 </td><td> 633505
 </td><td> 88650_A0
88650_B0
 </td><td> When running 802.3 llc packets, the ethertype field is used as length.
There was a bug that if the length was set to 0, the packet would have been parsed as a trill packet.
</td></tr><tr><td> SDK-46757 
 </td><td> 636270
 </td><td> 56643_A0
 </td><td> Triumph_3 has a Unified Forwarding Table and hash selection for L2/L3/Vlan/Mpls tables has to be programmed differently.
<tt>HASH_CONTROL</tt> register does not have a <tt>L3_HASH_SELECT</tt> field.
The command "l3 l3table hash" is trying to access this non-existent field resulting in an assertion failure.
<p>Support for "l3 l3table hash" and "l3 l3table ip6hash" commands have been implemented.
</td></tr><tr><td> SDK-46833 
 </td><td></td><td> 56440_B0
 </td><td> The fix for this issue checks the PLL's current divider setting in register 0x8050, and then use this as the forced value instead of always forcing the PLL to the same frequency for PRBS test.
Additionally, the asymmetric mode for the 40nm B0 core has been disabled for the PRBS function to work. 
</td></tr><tr><td> SDK-47665 
 </td><td> 650917
 </td><td> 56854_A2
56854_B0
56854_A0
 </td><td> 1G configs should be supported in latest release.
</td></tr><tr><td> SDK-47824 
 </td><td> 636400
 </td><td> 56846_A0
56845_B0
56845_A2
56844_A0
56842_A0
 </td><td> In previous releases, the updating on <tt>NONUCAST_TRUNK_BLOCK_MASK</tt> table took a fair amount of time to complete on Trident+ which has more <tt>NONUCAST_TRUNK_BLOCK_MASK</tt> table entries with the plain read API <tt>soc_read_mem</tt>(). In this release the performance has been improved by changing the update method such that it now uses a single DMA operation <tt>soc_read_mem_range</tt>() which gives a good amount of speedup to applicable trunk APIs.
</td></tr><tr><td> SDK-47983 
 </td><td> 661534
 </td><td> 56850_A0
56855_A0
56854_B0
56854_A0
56850_A1
56851P_A1
56851_A1
56850_A2
56851_A2
56851P_A2
56854_A2
56853_A2
56852_A2
56855_A2
 </td><td> New cosq type bcmCosqControlEgressPortPoolYellowLimitBytes / bcmCosqControlEgressPortPoolRedLimitBytes have been added for configuring yellow/red limits. Added one service pool type bcmCosqServicePoolPortColorAware and <tt>bcm_cosq_service_pool_set</tt>/get APIs for per port per service pool color aware enable.
</td></tr><tr><td> SDK-48016 
 </td><td> 661903
 </td><td> 56840_A0
 </td><td> In the previous release,static multicast L2 entries were getting flushed with <tt>bcm_l2_addr_delete_by_port</tt>() API.This has been resolved.
</td></tr><tr><td> SDK-48101 
 </td><td> 689094
 </td><td> 56845_B0
56845_A2
84740_A0
84784_A0
 </td><td> Support for 40G repeater mode PRBS for the system side was missing for BCM84740. Support for the same is added and tested in this release.
</td></tr><tr><td> SDK-48140 
 </td><td></td><td> 88650_A0
 </td><td> TRILL BEHAVIOR CHANGE.
According to trill fgl rfc, at ingress trill fgl, native outer and inner tpids must have value 0x893b. 
So far in Trill application, native Ethernet tpids set outer tpid = 0x8100 and native inner tpid = 0x893b. 
New implementation is now aligned to trill fgl rfc. At ingress trill fgl, both native inner and outer tpids have value 0x893b. Settings are done using VLAN-editing and work for both normal vlan translation and Advanced modes. 
</td></tr><tr><td> SDK-48296 
 </td><td></td><td> 88650_A0
 </td><td> When working with external TCAM, a master-key is sent from BCM886XX to KBP device with all the necessary fields for the forwarding and external ACL lookups.
A diagnostic has been built to show the order of the fields in the master-key and master-result:
BCM&gt; kbp print master
</td></tr><tr><td> SDK-48404 
 </td><td> 654018
 </td><td> 56845_B0
 </td><td> For BCM56845m <tt>phy_wc40_ability_remote_get</tt> was unable to get the correct ability when the link partner did not enable CL73.
Corrected the ability to  obtain remote ability when the link partner doesn't enable CL73 on TD+/WC40.
</td></tr><tr><td> SDK-48577 
 </td><td></td><td> 56640_A0
56643_A0
56340_A0
56640_A1
56643_A1
56640_B0
56643_B0
56540_B0
56045_B0
56040_A0
56547_A0
 </td><td> Added cpu based UFT mem sweep to detect and fix parity errors.
Fixed issues found with graceful lookup error handling.
</td></tr><tr><td> SDK-48774 SDK-56539
 </td><td> 672146
 </td><td> 88650_A0
88650_B1
88660_A0
 </td><td> IMPORTANT CHANGE (MIRROR SEQUENCE):
RSPAN Mirroring: ingress and egress settings have been decoupled. Mirroring into RSPAN is now done in the following way:
1.	Create L3 interface (this has not been changed).
2.	Set a <tt>bcm_tunnel_initiator_t</tt> object with type=bcm_TunnelTypeRspan, vlan, tpid, <tt>pkt_pri</tt> configured as desired and call <tt>bcm_tunnel_initiator_create</tt>(). This allocates entries in the EEDB.
3.	Set a <tt>bcm_mirror_destination_t</tt> with the flag <tt>BCM_MIRROR_DEST_TUNNEL_WITH_ENCAP_ID</tt> set and with the <tt>encap_id</tt> field set to the <tt>tunnel_id</tt> returned from <tt>bcm_tunnel_initiator_create</tt>() using the macro <tt>BCM_GPORT_TUNNEL_ID_GET</tt>().
<p>Getting information on the RSPAN tunnel may be done by setting a <tt>bcm_l3_intf_t</tt> object with the field <tt>l3a_tunnel_idx</tt> set to the <tt>tunnel_id</tt> returned from <tt>bcm_tunnel_initiator_create</tt>(), via the macro <tt>BCM_GPORT_TUNNEL_ID_GET</tt>().
<p>Destroying the tunnel (freeing the EEDB entries) may be done with the API <tt>bcm_tunnel_initiator_clear</tt>(), with the <tt>l3a_tunnel_idx</tt> field set as in the get() API.
Destroying the mirror not been changed.
For an example see <tt>mirror_with_rspan_example</tt>() in <tt>cint_mirror_erspan</tt>.c
</td></tr><tr><td> SDK-49047 
 </td><td></td><td> 88650_B0
88650_B1
88660_A0
 </td><td> 1588 packets were stamped while received/send from/to ports in which 1588 was disabled. This is fixed.
<p>ISSU perspective:
The fix supports ISSU if all the ports supporting 1588 are disabled before ISSU, and enabled after ISSU.
</td></tr><tr><td> SDK-49202 
 </td><td></td><td> 56640_A0
56640_A1
56640_B0
 </td><td> SOC properties <tt>ext_tcam_tx_driver_current</tt>, <tt>ext_tcam_tx_postcursor_tap</tt>, <tt>ext_tcam_tx_main_tap</tt> have been added to describe <tt>driver_current</tt>, postcursor tap and main tap for NL11K serdes TX direction parameters, and SOC property <tt>ext_tcam_rx_gain</tt> has been added to describe RX gain for Serdes RX direction parameter.
</td></tr><tr><td> SDK-49205 
 </td><td></td><td> 56640_A0
56640_A1
56640_B0
 </td><td> Support for ESM interrupt was added in CMIC level interrupt handler. Once the ESM fatal errors are detected, the new-implemented "esm recovery" thread will be woken to restore ESM.
</td></tr><tr><td> SDK-49249 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> DPOE application: Added an application example to show how to classify L2/L3/L4 header field and mapping frames to PON LIFs.
More information is provided in <tt>cint_pon_dml_fec_app</tt>.c.
</td></tr><tr><td> SDK-49543 
 </td><td> 663298
 </td><td> 88650_A0
88650_B0
88660_A0
 </td><td> Fixed ARAD ports Leds in Negev chassis (updated the Led microprocessor program to match recent changes in $SDK software)
</td></tr><tr><td> SDK-49694 
 </td><td></td><td> 56640_B0
56850_A1
56850_A2
 </td><td> Please use <tt>lpm_scaling_enable</tt>=1 in config to have the ability to add 64bv6 entries in paired tcam.
<p>When this config is enabled, V4,64B V6 entries can be added in the unreserved paired tcam.
If <tt>lpm_ipv6_128b_reserved</tt>=0, then no tcam space is reserved for 128B V6 entries and complete paired TCAM can be used for 128BV6, V4, and 64B V6 entries.
<p>Please note that each entry of 64B V6 entry in the paired TCAM uses 2 indexes of <tt>L3_DEFIP</tt> view where as in unpaired TCAM ,it uses only 1 entry
</td></tr><tr><td> SDK-50216 
 </td><td> 693383
 </td><td> 56850_A0
 </td><td> In previous release, per VLAN VP replication was automatically enabled when a Gport adds to the VLAN. In this release, support has been added to control VP replication by <tt>bcm_vlan_control_vlan_set</tt>.
</td></tr><tr><td> SDK-50389 
 </td><td> 695476
 </td><td> 2000_A1
 </td><td> QE2000 fix when updating QOS parameters for a given multicast queue. The unicast queue configuration was incorrectly being updated when egress independent flow control is enabled.
</td></tr><tr><td> SDK-50431 
 </td><td></td><td> 88660_A0
 </td><td> ERSPAN on XGS MAC extender system is now supported
</td></tr><tr><td> SDK-50591 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> TRILL: For TRILL UC and MC egress RBridges, trill packets are classified to inLIFs whose IDs are always 0 by PORT VLAN Domain X Outer VLAN.
A problem occurs when doing same interface filter. The inLIF ID and outLIF ID of trill packets of UC and MC egress RBridges are all 0. Packets are all dropped even in case it shouldn't be.
A new program is added to classified trill packets into valid inLIF IDs. It's enabled by adding a soc property "<tt>custom_feature_trill_designated_vlan_inlif_</tt>&lt;port&gt;=&lt;<tt>lif_id</tt>&gt;". Once feature is enabled, soc properties should be enabled for all TRILL ports.
</td></tr><tr><td> SDK-50755 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Diag: "diag cosq qpair e2e ps=x" can be used to display e2e port scheduler model.
Improvement in 1) adding new diagnose "diag cosq qpair e2e ps=x"
2) using "diag cosq qpair egq" instead of "diag cosq egq"
</td></tr><tr><td> SDK-50760 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Diag: "diag cosq <tt>print_flow_and_up</tt>" can be used to display scheduler model with given voq.
Improvement in 1) adding port scheduler level between HR level and Port level
2) using "voq connector" in the diag command instead of "flow"
</td></tr><tr><td> SDK-50899 
 </td><td> 634474
 </td><td> 56845_B0
 </td><td> Updated Documentation for WRED Flags
</td></tr><tr><td> SDK-51038 
 </td><td> 683239
 </td><td> 88640_A0
 </td><td> Petra-B 88640 Ingress mirroring : Ingress mirror can't mirror the original packet for the Petra hardware limitation, the workaround for it is to configure the mirror port as RAW in config.bcm as <tt>tm_port_header_type_2</tt>.BCM88640 = RAW. See <tt>cint_petra_mirror_tests</tt>.c for more information.
</td></tr><tr><td> SDK-51292 
 </td><td> 708102
 </td><td> 56640_A0
 </td><td> The HG capable dynamic ports Indexing offset was not accounted for on the SC/QM queues which led to wrong indexing for the dynamic ports.This has been fixed in the offset.
</td></tr><tr><td> SDK-51352 
 </td><td> 708790
 </td><td> 56846_A0
56840_A0
56846_A1
 </td><td> In previous versions, the routine <tt>_soc_trident_mem_parity_control</tt>() returned directly after configuring parity control for X-pipe and left Y-pipe parity control register un-configured for dual pipe IPIPE/EPIPE memories. In this version, <tt>_soc_trident_mem_parity_control</tt>() has been modified to configure both X-pipe and Y-pipe parity control.
</td></tr><tr><td> SDK-51353 
 </td><td></td><td> 56643_B0
 </td><td> The new support for the below port configuration has been implemented.
<p>Device =56643
Frequency (MHz)= 450
Option = 4
GbE Port Group (XC[12:0]) = 36 x GbE+1 x GbE
High Speed Port Gr 1 (WC[2:0])= 4 x XFI
High Speed Port Gr 2 (WC[6:3])= 2 x HG[42] + x F.H [42]"
AXP Port Guaranteed Bandwidth = 5G 
</td></tr><tr><td> SDK-51360 
 </td><td> 692893
 </td><td> 56840_A0
 </td><td> When any module in SDK uses new stat APIs, the running STAT version changes from LEGACY to NEW.
Currently VLAN Field Processor implementation works only with old stat APIs for older devices where advanced flex counters are not available.
Hence, required support is added in VLAN Field Processor implementation to use new stat APIs for older devices that switched to NEW stat version.
</td></tr><tr><td> SDK-51380 
 </td><td></td><td> 56440_A0
56440_A1
56440_B0
 </td><td> Enabled proper debug prints when API <tt>bcm_policer_group_create</tt>() fails.
</td></tr><tr><td> SDK-51392 SDK-51964
 </td><td> 710405
 </td><td> All
 </td><td> The BSL improvement has fixed this issue.
</td></tr><tr><td> SDK-51464 
 </td><td></td><td> 88650_A0
88750_B0
88660_A0
88750_A0
88650_B0
88650_B1
 </td><td> Source-routed data cells, generated by CPU, can be transmitted and received by Fabric Element (FE) and FAP devices (over fabric interface).
These cells are routed according to the specific path information they carry, while disregarding the fabric reachability information. 
These messages are used mainly for debug and diagnostics purposes, but can be also used for CPU-to-CPU messaging.
<p>The previous SDK versions supported this features using SoC APIs.
Instead, new BCM APIs created:
<p>typedef struct <tt>bcm_fabric_route_s</tt>{
    uint32  <tt>pipe_id</tt>;                     /* Origin fabric pipe */
    uint32  <tt>number_of_hops</tt>; /* corresponds to the number of routing hops (number traversed links) */
    int*    <tt>hop_ids</tt>;                       /* traversed links */
} <tt>bcm_fabric_route_t</tt>; 
<p>int
<tt>bcm_fabric_route_tx</tt>(
                            int unit, 
                            uint32 flags,
                            <tt>bcm_fabric_route_t</tt> * route,
                            uint32 <tt>data_in_size</tt>,   /* input payload size */
                            uint32 *<tt>data_in</tt>           /* input payload buffer */
);
<p>int
<tt>bcm_fabric_route_rx</tt>(
                            int unit, 
                            uint32 flags,
                            uint32  <tt>data_out_max_size</tt>, /* maximal size of the payload buffer */
                            uint32 *<tt>data_out</tt>,	  /* output payload buffer */
                            uint32 *<tt>data_out_size</tt>         /* actual output payload size */
);
</td></tr><tr><td> SDK-51494 
 </td><td></td><td> 88650_B0
 </td><td> Fix <tt>cint_mpls_lsr</tt>.c function <tt>mpls_add_php_entry</tt>. next protocol flag was overwritten by <tt>BCM_MPLS_SWITCH_TTL_DECREMENT</tt> flag.
</td></tr><tr><td> SDK-51525 
 </td><td> 677768
 </td><td> 88030_A0
 </td><td> There was a bug in the C3 model and the XML based test framework wherein any changes to the configuration files (files of the type g3p1_&lt;xyz&gt;<tt>_cfg</tt>.lrp) did not take effect until the second run of the tests. This is because the models read in the existing configuration files first and the assembler updated them later.
<p>As of this release of the MDE, this has been fixed.
</td></tr><tr><td> SDK-51570 
 </td><td></td><td> 56850_A0
56850_A1
 </td><td> In previous release, NIV VP class-id setting was not supported by <tt>bcm_port_class_set</tt>/get API. In this release, support was added for setting NIV VP class-id by <tt>bcm_port_class_set</tt>/get API.
</td></tr><tr><td> SDK-51601 
 </td><td> 708490
 </td><td> 88030_B0
88030_A0
 </td><td> Egress filter issue
</td></tr><tr><td> SDK-51617 
 </td><td> 710438
 </td><td> 56450_A0
 </td><td> Issue was happening due to incorrect buffer length calculation.
Function <tt>_soc_mem_array_sbusdma_write</tt>() is modified to use <tt>chunk_entries</tt> to write buffer with correct length.
</td></tr><tr><td> SDK-51625 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> For debug reasons, an HW register is used to store the SW version used at init, and during ISSU.
</td></tr><tr><td> SDK-51648 
 </td><td> 713425
 </td><td> 56340M_A0
56640_A0
56340_A0
56640_A1
56640_B0
 </td><td> Added in the support for different freq. <tt>QG_PLL</tt> and <tt>WC_PLL</tt> for chipsets which have the H/W capability.
</td></tr><tr><td> SDK-51658 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Support the following APIs to replace properties without replacing Out-LIF discard indication:
1. <tt>bcm_l3_egress_create</tt>
2. <tt>bcm_mirror_destination_tunnel_create</tt>.
3  <tt>bcm_mpls_tunnel_initiator_create</tt>.
4. <tt>bcm_tunnel_initiator_create</tt>.
</td></tr><tr><td> SDK-51707 
 </td><td> 715469
 </td><td> All
 </td><td> Optimized the ipmc performance if change 32K ipmc group from one ipmc index to another.
</td></tr><tr><td> SDK-51725 
 </td><td></td><td> 56624_B0
 </td><td> SER support has been added for the following memories as part of this fix:
<tt>MMU_WRED_CFG_CELL</tt>
<tt>MMU_WRED_THD_0_CELL</tt>
<tt>MMU_WRED_THD_1_CELL</tt>
<tt>MMU_WRED_CFG_PACKET</tt>
<tt>MMU_WRED_THD_0_PACKET</tt>
<tt>MMU_WRED_THD_1_PACKET</tt>
<tt>MMU_WRED_PORT_CFG_CELL</tt>
<tt>MMU_WRED_PORT_THD_0_CELL</tt>
<tt>MMU_WRED_PORT_THD_1_CELL</tt>
<tt>MMU_WRED_PORT_CFG_PACKET</tt>
<tt>MMU_WRED_PORT_THD_0_PACKET</tt>
<tt>MMU_WRED_PORT_THD_1_PACKET</tt>
</td></tr><tr><td> SDK-51810 
 </td><td></td><td> 88650_B1
88660_A0
 </td><td> Fixed three errors related to <tt>bcm_vlan_port_find</tt>:
1. When calling the API on an unprotected port, the <tt>failover_port_id</tt> field will be 1 instead of 0.
2. Any information related to 1+1 protection (<tt>ingress_failover_id</tt>, <tt>failover_port_id</tt>) was not filled when calling the API.
    <tt>ingress_failvoer_id</tt> and <tt>failover_port_id</tt> will now be filled when calling the API.
3. Added missing validations to function parameters.
</td></tr><tr><td> SDK-51828 
 </td><td> 716994
 </td><td> 56440_A0
56850_A0
 </td><td> Added new API <tt>bcm_stat_flex_pool_info_multi_get</tt> to retrieve the usage of flex counters in a pool
</td></tr><tr><td> SDK-51906 
 </td><td> 699612
 </td><td> 56450_A0
 </td><td> Due to flex operation issue on Cfg#12 with TDM-A2, used TDM-A3. Also corrected total slots required for TDM-A3 and removed one warning wrong comment.
</td></tr><tr><td> SDK-51936 
 </td><td></td><td> 56850_A2
 </td><td> For cl36 PRBS bus width must be set to 80 bits instead of 66 bits.
</td></tr><tr><td> SDK-51997 
 </td><td></td><td> 88660_A0
 </td><td> In BCM88660, in Field Processor, a new feature for field comparison is added.
<p>In HW, the comparison is performed on Key D in the second cycle of the PMF. It compares the two halves of the key (80 LSB bits and 80 MSB bits) and writes the result to the 5 MSB bits of the key (bits 159:155). Each bit of the result indicates a match of 20 bits, such that the 4 LSB bits correspond to 20 bits of the key, and the 5th MSB bit indicates match of the full key (80 bits).
<p>HW limitation: In order to act upon match the field group in the MSB must be Direct Extraction, and the 32 bit key is taken from the MSB bits (159:128). Direct extraction can filter up to 4 bits, thus only the 4 LSB bits of the compare result are used (it covers the full key).
<p>In SW, the sequence to enable the new compare feature is as follows:
1. Add a field group (max 80 bits each) with <tt>bcm_field_group_config_create</tt>() and set  <tt>BCM_FIELD_GROUP_CREATE_IS_EQUAL</tt> flag in group. 
This field group will use 80 LSB bits of the key.
2. Add another field group (mode = Direct Extraction) using <tt>bcm_field_group_config_create</tt>() and set  <tt>BCM_FIELD_GROUP_CREATE_IS_EQUAL</tt> flag in group.  This Field Group must also add the qualifier bcmFieldQualifyIsEqualValue to its QSET. This field group will use 80 MSB bits of the key.
* bcmFieldQualifyIsEqualValue qualifier is not properly part of the key (no HW instructions are allocated for it). It indicates that this key is written with the compare result.
* The max size of this Field Group is 80 bits (although it is a Direct Extraction Field group, limited to 32 bits in general). The comparison is performed on the entire 80 bits and the Direct Extraction key is taken from the 32 MSB bits. 
* Note: the 5 MSB bits are overridden by compare result.
<p>The compare can be used in parallel to bcmFieldQualifyCascadedKeyValue qualifier.
<p>A new cint is added for example: <tt>cint_field_dir_ext_compare_result</tt>.c
</td></tr><tr><td> SDK-52072 
 </td><td> 716983
 </td><td> 88660_A0
 </td><td> ERSPAN: Fixing a bug in <tt>bcm_tunnel_initiator_clear</tt>(). When a ERSPAN tunnel is created through <tt>bcm_tunnel_initiator_create</tt>(), two EEDB entries were allocated but in <tt>bcm_tunnel_initiator_clear</tt>() only one was freed.
</td></tr><tr><td> SDK-52087 
 </td><td> 719039
 </td><td> 56850_A0
 </td><td> A customer reported an issue with EPMC Egress_set performance. <tt>egress_set</tt> on 1000 IPMC index taking 20 seconds on 3 instances, That was happening because bcm_XXX_ipmc_egress_intf_set used the total interface number(max to 48K in some chips) to calculate the hash value for each port and cause the performance problem.
In this release IPMC Egresss_set performance has been improved to take approximately half the time originally reported by reducing the total interface number to calculate and using accelerated method for <tt>MY_STATION_TCAM</tt> memory field access. 
</td></tr><tr><td> SDK-52242 
 </td><td></td><td> 56640_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56640_A1
56643_A1
56644_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
 </td><td> HW works with a single granularity value for both CIR and EIR, once the granularity value is fixed(CIR), the maximum value for EIR becomes limited. Hence the issue. On high rates (EIR &gt; CIR) the granularity value is fixed to EIR.
</td></tr><tr><td> SDK-52246 
 </td><td> 720771
 </td><td> 56450_A0
 </td><td> The subtag packet can be multicasted/broadcasted to multiple CoE subports at a time from CPU by using switch logic (pkt-&gt;<tt>tx_pbmp</tt> along with flag pkt-&gt;flags=<tt>BCM_TX_ETHER</tt> ). For this the user needs to create L2MC entry or a VLAN with the destination CoE subports as members. The packet would go through the IP-EP pipeline where the packet may be dropped by IP or EP depending on configuration.
<p>The suggestion is to send SOBMH packets from CPU, one by one to the CoE subports  instead of using pkt-&gt;<tt>tx_pbmp</tt>.
</td></tr><tr><td> SDK-52287 
 </td><td> 713097
 </td><td> 88030_A0
 </td><td> Bit hash ID numbering now starts from 0.
</td></tr><tr><td> SDK-52325 SDK-51797
 </td><td> 721812
 </td><td> All
 </td><td> There is requirement from customer to perform a loopback test on a port, while making sure it looked like totally "down" from the outside, i.e. the link is down, no traffic leakage, etc. The modification of this JIRA is to add the support of MAC loopback on disabled port.
</td></tr><tr><td> SDK-52339 
 </td><td> 722376
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Two data error event flags were added. If a parity error is uncorrectable, the flag <tt>SOC_SWITCH_EVENT_DATA_ERROR_UNCORRECTABLE</tt> will be set when SDK reporting <tt>SOC_SWITCH_EVENT_PARITY_ERROR</tt> event to application. If a parity error is correctable, but the error correction fails, the flag <tt>SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT</tt> will be set when SDK reporting <tt>SOC_SWITCH_EVENT_PARITY_ERROR</tt> event to application.
</td></tr><tr><td> SDK-52355 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Support has been added for retry in mem insert and delete for hash tables. Inline hash memory recovery was implemented for insert and delete operations.When an insert/delete operation encounters a parity error, the inline recovery routine will be invoked. The inline recovery routine will calculate different hash buckets in different hash memory banks based on the entry that will be inserted/deleted, then restore the each bucket in these banks.
For new-added hash key types in Trident2 hash tables, support for these key types in hash entry comparing routine has also been added.   
</td></tr><tr><td> SDK-52385 
 </td><td> 721101
 </td><td> 88030_B0
88030_A0
 </td><td> Byte order changed in diags mem commands as requestd.
</td></tr><tr><td> SDK-52386 
 </td><td> 722002
 </td><td> 88030_A0
 </td><td> Retry 10 times if error happen, many location for <tt>post_cmd</tt>/<tt>get_response</tt> pair.
</td></tr><tr><td> SDK-52389 
 </td><td> 721614
 </td><td> 56850_A0
 </td><td> API has been added for populating egress etag qos mapping.
</td></tr><tr><td> SDK-52412 
 </td><td> 678409
 </td><td> 56340_A0
84756_A0
 </td><td> Issue:
------
When a 1G fiber SFP is installed into a BCM-84756 10G port with no fiber attached, the hardware linkscan declares the port link state as up.
<p>Rootcause:
----------
Hardware link scan can only probe a single bit in a single external phy or internal SerDes based link register on a per port basis.
For PHYs such as 84756 which needs to probe more than 1 bit on more than 1 register to conclude per port based link up/down status,
these PHYs must support a "squelch" function. When the squelching function is enabled/configured,
the PHY will bring system side link status up when the line side link status is up and vice versa.
Then the hardware link scan can probe the internal SerDes to conclude link status.
The squelching function is not supported in 84756 driver (<tt>phy84756_fcmap</tt>.c) yet.
<p>Fix:
----
Implemented Squelch function in <tt>py84756_fcmap</tt>.c which is the root cause for the issue mentioned in this JIRA.
Tested the squelch function implementation with 1G, 10G ports for the system side and the line side link as follows.
i) Enabled system side squelch, could observe system side link goes down when Tx is disabled on the line side.
ii) Enabled line side squelch, could observe line side link goes down when Tx is disabled on the system side. 
Squelch function is not invoked from the init function of PHY84756 fcmap driver.
So user/customer needs to call squelch function explicitly using <tt>SOC_PHY_CONTROL_TX_LANE_SQUELCH</tt> whenever they wish to enable squelch on either line side
Or system side.
</td></tr><tr><td> SDK-52442 
 </td><td> 696223
 </td><td> 56850_A2
 </td><td> In previous releases, an issue was reported in the parallel vertical scan operation, When attempting a 1-D slice vertical scan, the results would not come out if <tt>horizontal_min</tt>=0 and <tt>horizontal_max</tt>=0.In this release the TSC diagnostics interface has been modified to return the proper H right max and left max values.
</td></tr><tr><td> SDK-52454 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Basic bridging Egress multicast: We assume over VLAN APIs that egress multicast exist.
Now no error is returned when egress multicast does not exist
</td></tr><tr><td> SDK-52458 
 </td><td></td><td> 88650_B0
88660_A0
 </td><td> In L3 forwarding, when using external TCAM for forwarding tables, they were actually defined as ACL tables, resulting in a large software state and reduced efficiency in configuration.
The forwarding tables in the external TCAM are now defined as LPM tables, reducing memory consumption and enhancing configuration periods.
The API calling sequence remains identical.
</td></tr><tr><td> SDK-52459 
 </td><td></td><td> 88660_A0
 </td><td> DEFAULT BEHAVIOR CHANGE (ARAD+ only).
When using external TCAM for forwarding, RPF and forwarding searches were performed on duplicated databases.
RPF and forwarding searches are now performed on a single database, using SIP and DIP respectively in search keys and resulting in increased (doubled) routing table capacity.
Note that in case of IPv4/6 + RPF forwarding query, external ACL databases IDs are changed to 1 and 3.
The actions sizes for ACL databases have also changed accordingly:
The action size for ACL database 0 is 64 bits.
The action size for ACL database 1 is 32 bits.
The action size for ACL database 2 is 16 bits.
The action size for ACL database 3 is 24 bits.
All of the changes above apply only to ARAD+ devices. ARAD devices behavior remains unchanged.
</td></tr><tr><td> SDK-52564 
 </td><td></td><td> 56850_A1
 </td><td> Fixed traffic drops observed with ingress-traffic after creation of L2GRE access port with match criteria as <tt>MATCH_PORT_VLAN</tt>.
</td></tr><tr><td> SDK-52591 
 </td><td> 725728
 </td><td> 56450_A0
 </td><td> Added support to enhance the number of child nodes per scheduler node in BCM56450. The restriction of maximum of 64 child nodes has been removed in cosq APIs.
</td></tr><tr><td> SDK-52636 
 </td><td></td><td> 88030_A0
 </td><td> Added support for 4x10G_20x1G_1xHG TDM with specific assignment of Warp Core to CLPORT &amp; XTPORT
</td></tr><tr><td> SDK-52650 
 </td><td></td><td> 56960_A0
 </td><td> Added new Port Prbs Polynomial type <tt>BCM_PORT_PRBS_POLYNOMIAL_X58_X31_1</tt>.
</td></tr><tr><td> SDK-52734 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> Indication if the Warmboot is supported by the device added to avoid Warmboot errors in regression for a version where Warmboot mode is not compiled.
</td></tr><tr><td> SDK-52751 
 </td><td> 726121
 </td><td> 56545_A0
56545_A1
56545_B0
 </td><td> In the previous release <tt>bcm_l2_cache_set</tt>() did not allow setting priority &gt; 7 on Firebolt4. In this release the API to add an entry <tt>L2_USER_ENTRY</tt> table now supports 4bits of PRIORITY on those devices where the priority field is 4 bits.
</td></tr><tr><td> SDK-52789 
 </td><td> 728470
 </td><td> 56450_A0
 </td><td> In the previous release an assert was raised when running TR53 on KT2. TR 53(DDR Memory Fill/Verify)is not valid for KT2. This issue has now been addressed by changing the TR rule for TR53 to exclude KATANA2. Instead of TR53 customer shall use TR140 for KT2.
</td></tr><tr><td> SDK-52805 
 </td><td> 728606
 </td><td> 88750_A0
 </td><td> FE1600: added a extra sleep after soft init and before un-isoalte
</td></tr><tr><td> SDK-52837 
 </td><td> 729120
 </td><td> 56840_A0
56640_A0
56440_A0
56450_A0
56850_A2
 </td><td> Added new field <tt>rx_decap_tunnel</tt> to <tt>bcm_pkt_t</tt> structure.
This field determines the type of outer tunnel decapsulation, if any, on the received packet.
</td></tr><tr><td> SDK-52842 
 </td><td></td><td> 56640_B0
 </td><td> Added external field entry move support on TR3 to manage the field entry priorities appropriately.
</td></tr><tr><td> SDK-52871 SDK-54669
 </td><td> 729527
 </td><td> 56850_A0
56855_A0
56854_B0
56854_A0
56850_A1
56851P_A1
56851_A1
56850_A2
56851_A2
56851P_A2
56854_A2
56853_A2
56852_A2
56855_A2
56851_A0
56852_A0
56852_A1
56853_A0
56853_A1
 </td><td> An issue was reported with <tt>MY_STATION_TCAM</tt> not being correctly programmed for the trunk-based TRILL ports . To address this, trunk relevant fields in <tt>MY_STATION_TCAM</tt> are now correctly programmed for the termination of TRILL packets.
</td></tr><tr><td> SDK-52892 
 </td><td> 622534
 </td><td> 56846_A0
 </td><td> In the previous release, <tt>bcm_port_fault_get</tt>() failed on 1G SFP. This has been resolved.
</td></tr><tr><td> SDK-52896 
 </td><td> 716978
 </td><td> 56840_A0
 </td><td> Support calculating non-unicast trunk hash destination for TD/TD+/TR3/TD2.
</td></tr><tr><td> SDK-52921 
 </td><td> 730103
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> Add entries using <tt>bcm_trill_multicast_entry_add</tt> with <tt>c_vlan</tt>=0 is now supported in the following Trill mode:
Trill VL (<tt>trill_mode</tt>=1)
Multicast prune mode does not include VSI (<tt>trill_mc_prune_mode</tt>=0)
</td></tr><tr><td> SDK-52942 
 </td><td> 727724
 </td><td> 56334_B0
56334_A0
 </td><td> Bcm56334 10G ports has 2 different macs and both of them show counters increasing when receiving packets. In this release, a fix was introduced to address the issue where incorrect values were being retrieved. Fixed the issue to get 10G statistics only from 10G mac while speed set to 10G. And while speed set to 1G, only get statistics from 1G mac counter.
</td></tr><tr><td> SDK-52965 
 </td><td> 730480
 </td><td> 56634_A0
 </td><td> In the previous release there was no support for bcmCosqStatOutBytes and bcmCosqStatOutPackets stats in <tt>bcm_cosq_stat_set</tt> and <tt>bcm_cosq_stat_get</tt> for Triumph.This issue has now been addressed by adding the support for Triumph.
</td></tr><tr><td> SDK-53025 
 </td><td> 729729
 </td><td> 88030_B0
 </td><td> fix the issue of interlaken port disabled by linkscan thread on bcm88030 device
</td></tr><tr><td> SDK-53028 
 </td><td></td><td> 56340_A0
 </td><td> Added code to find valid port block in the given list of port blocks.
Previously used macro was checking only the first block in the list. The fix iterates through the entire set of valid port blocks to find the corresponding port block.
</td></tr><tr><td> SDK-53044 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> When processing ser fifo, if the block is IPIPE block, we will only set mask upon the pipe, and take the lock of accessing <tt>sbs_control</tt>. And unlock it before returning in this function.
</td></tr><tr><td> SDK-53046 
 </td><td></td><td> 88650_A0
 </td><td> In Rx thread, when parsing the packet header, the parsing was supported only for little endian.
Now big endianness is also supported.
</td></tr><tr><td> SDK-53059 
 </td><td> 730593
 </td><td> 88650_A0
 </td><td> VPLS: Add support in PWE2PWE.
Example in <tt>cint_vswitch_cross_connect_p2p_multi_device</tt>.c: function "run" should be called with two PWE ports and type1=type2=2.
</td></tr><tr><td> SDK-53067 
 </td><td> 730463
 </td><td> All
 </td><td> "rtag" field removed from <tt>bcm_l2_addr</tt> .
</td></tr><tr><td> SDK-53104 
 </td><td> 720590
 </td><td> 56840_A0
56640_A0
56843_B0
 </td><td> Added support for the API's <tt>bcm_cosq_stat_sync_get</tt>, <tt>bcm_cosq_stat_sync_get32</tt> on Trident, Triumph Family, Valkyrie.
<p>Similar to <tt>bcm_cosq_stat_get</tt>(), value returned is software accumulated 
counter synced with the hardware counter.
</td></tr><tr><td> SDK-53157 
 </td><td> 732567
 </td><td> All
 </td><td> Updated API documentation that FP action DoNotCheckVlan cannot be set along with action IncomingMplsPortSet as DoNotCheckVlan is set by default whenever IncomingMplsPortSet action is set
</td></tr><tr><td> SDK-53203 
 </td><td> 722629
 </td><td> 88650_B0
88660_A0
88670_A0
 </td><td> In 6.4.1 we introduce an optimized way to decapsulate overlay headers (L2GRE and VXLAN) for the case of multicast.
So far 2-pass solution was introduced where on the second pass IPMC addresses added to the Tunnel termination database in order to terimnate the IP header in the second pass. Using SOC property: <tt>DEFAULT_LOGICAL_INTERFACE_IP_TUNNEL_OVERLAY_MC</tt> user can set one global LIF ID for all IPMC termination on the second pass. see <tt>cint_l2gre</tt>.c for more details.
</td></tr><tr><td> SDK-53248 
 </td><td></td><td> 88650_A0
 </td><td> We exhibit the various ipmc flows via two main functions in <tt>cint_ipmc_flows</tt>.c:
<tt>ipmc_flows_rif_ipmc_enabled</tt>() and <tt>ipmc_flows_rif_ipmc_disabled</tt>().
</td></tr><tr><td> SDK-53253 
 </td><td> 731741
 </td><td> 56334_B0
 </td><td> In the previous release, SDK read back whole mpls label action table to reuse existing entries when invoking the function <tt>_bcm_tr_mpls_get_vc_and_swap_table_index</tt>. In this release, SDK adds an option not to reuse entries to address performance concern.
</td></tr><tr><td> SDK-53264 
 </td><td> 733415
 </td><td> 88650_A0
 </td><td> Allow egress snooping for MIPs with out-LIF on system headers. By default, Arad does not provide any out-LIF information when snooping OAM packets at the egress. To allow this behavior set the soc property <tt>custom_feature_egress_snooping_advanced</tt> to 1. When MIP packets are snooped at the egress, the snooped copy will be prepended with an FTMH and a DSP extension. FTMH.<tt>DSP_EXT_PRESENT</tt> will be set to 1 and the DSP extension will include the out-LIF.
The snoop command for egress snooping (up-MIP) will always be 2 and for ingress (down-MIP) always 1.  Thus, when changing the snooping behavior by calling <tt>bcm_rx_snoop_set</tt>() with 2 or 1 in the <tt>snoop_cmnd</tt> field, the snooping will be updated for all MIPs in the system. Likewise when OAM frames will be snoop by a MIP at the egress, the snooped copy will always have FTMH.<tt>MCID_OR_OUTLIF</tt>==2.
By default only multicast LTM packets are snooped to the CPU. The default behavior may be changed with <tt>bcm_oam_action_set</tt>().  Calling this function allows setting a new snoop destination or snooping other types of frames. The calling sequence is as following:
1. Configure a <tt>bcm_rx_snoop_config_t</tt> with the desired behavior (i.e. probability, size,  <tt>dest_port</tt>, etc.)
2. Call <tt>bcm_rx_snoop_set</tt>() with the <tt>bcm_rx_snoop_config_t</tt> configured above and the <tt>snoop_cmnd</tt> field set to 1 (ingress). 
3. Set a new trap with <tt>bcm_rx_trap_create</tt>() and <tt>bcm_rx_trap_set</tt>(). For the latter call, the <tt>snoop_cmnd</tt> field in the <tt>bcm_rx_trap_config_t</tt> struct should be set to 1 (ingress snoop command).
4. Call <tt>bcm_oam_action_set</tt>() with the desired configurations. The destination field in the <tt>bcm_oam_endpoint_action</tt> struct should be set to the trap code from step 3 using the macro <tt>BCM_GPORT_TRAP_SET</tt>().
The function <tt>bcm_oam_action_set</tt>() will update the egress snooping configurations to match those configured above for the ingress snooping.
An example of this can be seen in the function <tt>mip_egress_snooping_advanced</tt>() in examples/dpp/<tt>cint_oam</tt>.c.
<p>Notes: 
1. In this configuration only MIP snoop is allowed (snooping MEP packets is not supported).
2.Since there are 2 snoop commands used by all MIPs in the system (one each for the ingress and egress), changing the snoop behavior for one MIP will affect all other MIPs in the system.
2. When the packet gets snoop, the forwarded copy uses forwarding strength 3. If soc property <tt>block_trap_strength_pmf_0</tt>/1 is set to lower strength then the packet will not get forwarded.
3. To get the described behavior JIRAs SDK-54865, SDK-54726 should be used as well.
</td></tr><tr><td> SDK-53292 
 </td><td></td><td> 88650_A0
88650_B0
 </td><td> new soc property - <tt>scheduler_fabric_links_adaptation_enable</tt>
when enabled , the scheduler will take current links' states into consideration when generating credits.
(mostly useful in multi stage systems)
</td></tr><tr><td> SDK-53293 
 </td><td></td><td> 88650_A0
 </td><td> When trying to use the System RED Cint to configure DP discard for multiple VOQs.
An error occurs after configuring the first 64 VOQs. This error was due to alloc manager miss configuration.
The fix is to Change alloc manager system, red max entities (<tt><tt>_DPP_AM_TEMPLATE_SYS_RED_DP_PR_MAX_ENTITIES</tt></tt>) from 64 to Multiple NOF Queues by 2. We are multiplying since we have 2 pointer per Queue.
</td></tr><tr><td> SDK-53319 
 </td><td> 733446
 </td><td> All
56850_A0
56850_A1
56850_A2
 </td><td> Fixed <tt>bcm_vxlan_vpn_create</tt>, <tt>bcm_l2gre_vpn_create</tt> API to replace UUC/MC/BC IPMC index using <tt>BCM_VXLAN_VPN_REPLACE</tt>, <tt>BCM_L2GRE_VPN_REPLACE</tt>.
</td></tr><tr><td> SDK-53323 
 </td><td> 734007
 </td><td> 88030_A0
 </td><td> Instead calculate total good packet using the register RUCA..
</td></tr><tr><td> SDK-53376 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> An issue was reported where l3 ip6route show was displaying NEGATIVE free entry values.
In this release, the way to calculate the free number and the total number of  IPv6 entries has been adjusted to address this issue and also to cover the number of IPv6/64 entries. It depends on <tt>bcm_switch_object_count_get</tt> to get the following objects: 
bcmSwitchObjectL3RouteV6Routes64bMax
bcmSwitchObjectL3RouteV6Routes128bMax
<tt>defip_64_free</tt>
<tt>defip_128_free</tt>
</td></tr><tr><td> SDK-53380 
 </td><td></td><td> 88750_A0
88650_A0
 </td><td> The previous issue is that deinit can only be exercised after successfully init, it is not acceptable in case a single CPU controls multiple devices, if one device fails in init, we have to reset the CPU which affect other devices.
The current fix is that we support the partial deinit which will dealloc the resource that was alloced in previous init failure, then it can do the normal init which means one device init failure don't need to reset the CPU.
</td></tr><tr><td> SDK-53405 
 </td><td> 721824
 </td><td> 88650_A0
 </td><td> Scheduling elements prints were added to the gport command.
Additionally, "gport count" or "gport c" will print a summary of all gport types count.
<p>NOTE: <tt>bcm_cosq_gport_traverse</tt> was extended to include SEs of all types!!!
</td></tr><tr><td> SDK-53433 
 </td><td> 731111
 </td><td> All
 </td><td> In TDM bypass mode, in the FDT - the IRE TDM mask mode is configured by default for not reading from RTP link-integrity, but rather using the RTP reachable bitmap.
When calling <tt>bcm_fabric_tdm_direct_routing_set</tt>() the usage of RTP link-integrity is enabled, without the ability to go back.
So static link configuration will not be ignored, and the user can configure active links for TDM bypass mode.
</td></tr><tr><td> SDK-53444 
 </td><td> 725754
 </td><td> 56840_A0
 </td><td> While rebooting the system an additional flap was seen on port during the BCM INIT. This has been resolved In phy init code, by disabling it first in case the attached phy is not an external phy and is not in warmboot procedure.
</td></tr><tr><td> SDK-53451 
 </td><td> 735769
 </td><td> 56640_A0
56640_A1
56640_B0
 </td><td> On link up, the pause and MTU max values were not retrieved from config, resulting in all the config values becoming obsolete and default values being programmed. Fix is retrieval of the data from the config and override the default values so that the port values reflect the configured parameters.
</td></tr><tr><td> SDK-53452 SDK-52881 SDK-48849
 </td><td> 722247
 </td><td> 56548_A0
56546_A0
56545_A0
56544_A0
56542_A0
56541_A0
56540_A0
56545_A1
56540_B0
56541_B0
56546_B0
56544_B0
56547_A0
56545_B0
56542_B0
 </td><td>For Apollo2 device, the <tt>L3_DEFIP</tt> memory was partitioned into fixed size giving 2K indexes for v4/64V6 and 2K for 128V6. The change is to partition the <tt>L3_DEFIP</tt> table with the user defined values. User can give any number to change the max number of 128V6 entries and V4/64V6 entries. This user defined partition scheme is already supported for TR3/TD2.
<p>user needs to set these soc properties .
<p><tt>ipv6_lpm_128b_enable</tt>=1   ======&gt; This sets the new scheme active.
<p><tt>num_ipv6_lpm_128b_entries</tt> = XXXX    =====&gt; Number of 128V6 routes 
<p>Without this configuration, the SDK will set the table with default route tables.
<p>128v6=2048 and v4/64V6=2048
</td></tr><tr><td> SDK-53482 
 </td><td></td><td> 88650_A0
 </td><td> Valgrind is a tool that reports cases where code uses uninitialized data.
<p>Currently when Valgrind is run and warmboot is done, some warnings are emitted for usage of uninitialized data. The source of these warnings are uninitialized data that are written to a file.
<p>In one case, there was a problem with 64 bit systems that would read bad data -- this was fixed.
In the other cases, unused and uninitialized data was always written to the warmboot file. This data written to the warmboot file is now initialized without any implication on code logic.
</td></tr><tr><td> SDK-53487 
 </td><td> 736250
 </td><td> 56850_A0
56850_A1
56830_A1
56850_A2
56830_A0
56830_A2
 </td><td> In the previous release, the restriction that the queues in strict priority mode must be in consecutive order on Trident2 family was not documented. In this release, this issue has been addressed by documenting the restriction.
</td></tr><tr><td> SDK-53506 
 </td><td> 716783
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In the previous release, when the first strict priority member was a unicast queue, the function <tt>_bcm_td2_sched_check_constraints</tt>() returned *ucmap=1 which was not correct. In this release, this issue has been addressed by setting *ucmap=0.
</td></tr><tr><td> SDK-53507 
 </td><td> 736772
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> This JIRA is a duplicate of SDK-53600. In which the API bcmPortControlMmuDrain is improved to check the empty state of each nodes and queues after the cells are drained.
</td></tr><tr><td> SDK-53508 
 </td><td> 736774
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In the previous version, in TD2, when the weights of queues were changed dynamically leaving the schedule mode unchanged, the traffic would be disrupted. In this release, the API <tt>bcm_cosq_port_sched_set</tt>() and <tt>bcm_cosq_gport_sched_set</tt>() have been improved to allow weights to be changed dynamically when the schedule mode is not changed.
</td></tr><tr><td> SDK-53517 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Added ability to support three ALPM profiles to provision different Pivot reservations.
</td></tr><tr><td> SDK-53556 
 </td><td> 735811
 </td><td> 56640_A0
56641_A0
56850_A0
56640_B0
56644_B0
56850_A1
56850_A2
 </td><td> Index for <tt>COS_MAP_SEL</tt> table was being incorrectly set for CPU as ingress port (0). The higig packets ended up in a wrong queue due to wrong index for CMIC ports the index is retrieved from the soc layer and programmed. Corrected the index appropriately in TD2 and TR3 devices.
</td></tr><tr><td> SDK-53561 
 </td><td></td><td> 56846_A0
56850_A0
 </td><td> TD+ <tt>L2_ENTRY</tt> table is shared between the two pipelines. Only X-pipe has SBUS access to the shared <tt>L2_ENTRY</tt> table. TD2 has independent L2_ENTRY_x and L2_ENTRY_y tables, but only access type 4 is supported in memory write operation for these two tables.
The combination of <tt>L2_ENTRY</tt> table and access type 2 for Y-pipe has been added into skipped memory list.
</td></tr><tr><td> SDK-53574 
 </td><td> 737396
 </td><td> All
 </td><td> Fixed buffer overrun in fall-back implementation of <tt>sal_strncpy</tt>. Note that this implementation is not used in any of the primary system environments such as Linux and VxWorks.
</td></tr><tr><td> SDK-53584 
 </td><td></td><td> 56850_A0
 </td><td> L2X table is read via DMA manner by default. If DMA fails, the table entries will be read via PIO manner again. If there is a parity error in L2X table, both DMA read and PIO read will trigger parity error reporting.
The SER logging feature has been implemented to detect and filter the duplicate parity errors for the customer application.
</td></tr><tr><td> SDK-53600 
 </td><td> 737427
 </td><td> 56850_A2
 </td><td> The API bcmPortControlMmuDrain has been improved to check the empty state of each node and queue after the cells are drained.
</td></tr><tr><td> SDK-53602 
 </td><td></td><td> 88650_A0
88650_B1
88660_A0
 </td><td> TDM bypass traffic whose destination is the same FAP usually does not go through the fabric.
Forcing of TDM bypass traffic to the fabric can be enabled/disabled using:
<tt>bcm_fabric_control_set</tt>(unit, bcmFabricForceTdmBypassTrafficToFabric, 1/0);
The current state can be retrieved using:
<tt>bcm_fabric_control_get</tt>(unit, bcmFabricForceTdmBypassTrafficToFabric, &amp;enabled);
</td></tr><tr><td> SDK-53611 
 </td><td> 737404
 </td><td> 56634_B0
 </td><td> CPU can send ethernet packet and higig packet. For local switch disable feature, the register <tt>ILOCAL_SW_DISABLE_DEFAULT_PBM_64</tt> should be configured for CPU port when CPU is sending higig packet,but that is missed in SDK.
This issue has been fixed.
</td></tr><tr><td> SDK-53628 
 </td><td></td><td> 88660_A0
 </td><td> Trill: Internal implementation was changed to remove my nickname duplication in <tt>SOC_PPC_MYMAC_TRILL_INFO</tt>. Fix does not change Trill multi-homing application
</td></tr><tr><td> SDK-53630 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Tunnel APIs replace:
1.Support <tt>bcm_tunnel_initiator_create</tt> to replace dip, vlan, dscp, ttl, sip and type of IPv4 tunnel with <tt>tunnel_id</tt> of tunnel or <tt>l3a_intf_id</tt> or <tt>l3a_tunnel_idx</tt> of intf. In case of IPv6 tunnel, dip6 sip6, ttl and type can be replaced. In case of ERSPAN tunnel on ARAD+, <tt>span_id</tt> and <tt>l3_intf_id</tt> can be replaced.
2.Support <tt>bcm_tunnel_terminator_create</tt> to replace <tt>tunnel_if</tt>, <tt>if_class</tt> and flags (<tt>BCM_TUNNEL_TERM_USE_OUTER_DSCP</tt> or <tt>BCM_TUNNEL_TERM_USE_OUTER_TTL</tt>) with <tt>tunnel_id</tt>.
</td></tr><tr><td> SDK-53636 
 </td><td> 737820
 </td><td> All
 </td><td> Added Level 2 warmboot recovery support for the following switch controls:
bcmSwitchUseGport
bcmSwitchL2PortBlocking
bcmSwitchCallbackAbortOnError
</td></tr><tr><td> SDK-53656 
 </td><td> 738788
 </td><td> 88650_A0
 </td><td> In Ingress Field Processor, validation of ISQ range in <tt>bcm_field_action_add</tt>() is incorrect, and as a result does not allow usage of the full range. This is fixed.
</td></tr><tr><td> SDK-53657 
 </td><td> 737782
 </td><td> 56846_A0
 </td><td> When upgrading from sdk-6.2.5 to sdk-6.3.5 scache space for the differential state was not allocated for few modules. Fixed scache reallocation for RX, NIV, VXLAN modules during warm upgrades.
</td></tr><tr><td> SDK-53661 
 </td><td> 737925
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> TD2 TDM Oversubscription Issue, tx failure with mixed 10G/40G configuration was failing. This has been addressed by updates to the oversub group sorting algorithm.
</td></tr><tr><td> SDK-53672 
 </td><td> 739010
 </td><td> All
 </td><td> The validation logic which is valid for SQ/MC was preventing the creation of dynamic queues when the indexes were more than 8 (0 -15). Fixed the code to support dynamic queue indexing as well. The SQ/MC index validation is done for non dynamic ports only.
</td></tr><tr><td> SDK-53673 
 </td><td> 738994
 </td><td> 56850_A2
 </td><td> Corrected the value of macro definition (<tt>BCM_IPMC_RANGE_IP6</tt> and <tt>BCM_IPMC_RANGE_PIM_BIDIR</tt>).
</td></tr><tr><td> SDK-53674 
 </td><td> 739094
 </td><td> 56450_B0
56450_A0
 </td><td> <tt>bcm_cosq_gport_attach</tt> API was not able to allocate non-contiguous queues to support more WRR queues/nodes. A new flag <tt>BCM_COSQ_GPORT_SCHEDULER_WFQ</tt> has been introduced to support this option.
</td></tr><tr><td> SDK-53684 
 </td><td></td><td> 88660_A0
 </td><td> DEFAULT BEHAVIOR CHANGE.
In Field Processor, when using external TCAM, valid entry priorities values are now limited to the range of 0 to 4194303 (2^22). 
Additionally, when creating an ACL group in the external TCAM, the user may specify the max entries priorities they intend to use in this group by setting the <tt>max_entry_priorities</tt> parameter in <tt>bcm_field_group_config_t</tt>.
Indicating the max entry priorities will result in improved control performance of the external TCAM driver.
Note that if the <tt>max_entry_priorities</tt> parameter is set, the valid entry priorities values for the configured group are limited to the range of 0 to <tt>max_entry_priorities</tt>.
Also note that <tt>max_entry_priorities</tt> parameter is only supported for external TCAM.
</td></tr><tr><td> SDK-53732 
 </td><td> 732324
 </td><td> 88650_A0
 </td><td> In Field Processor, the user can qualify packets according to the trap-code (bcmFieldQualifyRxTrapCode).
The bcm_field_qualify_RxTrapCode expects only a <tt>bcm_rx_trap_t</tt> parameter, indicating which trap.
Thus, it does not support User-Defined traps (since no ID can be specified). Besides, for bcmRxTrapL2Cache Trap-code, two possible set of traps can be qualified:
1. By default, the programmable traps are qualified. Due to their HW value (not divisible by 4), only the 2 first programmable traps are qualified.
2. If the SOC property <tt>custom_feature_trap_l2_cache_field_reserve_mc_hit</tt> is set, then the 8 Reserve-Multicast traps are qualified instead
</td></tr><tr><td> SDK-53741 
 </td><td> 738835
 </td><td> 88650_A0
88650_B0
88660_A0
 </td><td> In BCM886XX, the L2 traverse HW allows the definition of flexible rules to traverse and modify the MAC Table entries, including a flexible mask (both on entry key and payload).
The <tt>bcm_l2_match_masked_traverse</tt> is implemented, and examples of L2 traverse can be found in $SDK/src/examples/dpp/<tt>cint_l2_traverse</tt>.c.
</td></tr><tr><td> SDK-53757 
 </td><td> 733995
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> Clear ipv6 tunnel using <tt>bcm_tunnel_initiator_clear</tt>() is now supported.
</td></tr><tr><td> SDK-53763 
 </td><td></td><td> 88660_A0
 </td><td> 1. Add support of enable/disable learn functionality in <tt>bcm_port_learn_set</tt> function for Trill port.
2. Add cint with learning disable for virtual RBridge that receive packet with ingress nickname equal to own virtual nickname.
</td></tr><tr><td> SDK-53770 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Advanced VLAN Edit: Added an example functions for QoS mapping configuration in <tt>cint_advanced_vlan_translation_mode</tt>.c:
<tt>qos_default_settings</tt>(), <tt>add_qos_mapping</tt>() and <tt>set_qos_mapping</tt>().
</td></tr><tr><td> SDK-53776 
 </td><td> 739518
 </td><td> 88030_B0
 </td><td> Support 4Gbits DDR part, allow row sharing and provide a "TmuAllocDump" to show detailed DRAM usage for bcm88030
</td></tr><tr><td> SDK-53794 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> Replace functionality in L3:
Added support to replace intf, <tt>mac_addr</tt>, vlan, port, <tt>qos_map_id</tt> and <tt>encap_id</tt> by <tt>bcm_l3_egress_create</tt> with <tt>BCM_L3_REPLACE</tt> flags.
Added support to replace  <tt>intf_array</tt> by <tt>bcm_l3_egress_ecmp_create</tt> with <tt>BCM_L3_REPLACE</tt> flags. 
</td></tr><tr><td> SDK-53800 
 </td><td> 739936
 </td><td> All
56450_A0
 </td><td> When <tt>bcm_mpls_port_add</tt>() was called with new label and <tt>BCM_MPLS_PORT_REPLACE</tt> flag, a new mpls entry was being added without deleting the old mpls enrtry with old label. This has been fixed.
</td></tr><tr><td> SDK-53802 
 </td><td> 740202
 </td><td> 56850_A0
56855_A0
56854_B0
56854_A0
56850_A1
56851P_A1
56851_A1
56850_A2
56851_A2
56851P_A2
56854_A2
56853_A2
56852_A2
56855_A2
56851_A0
56852_A0
56852_A1
56853_A0
56853_A1
 </td><td> Updated TSC transcription algorithm to resolve incorrect TDM programming for partial TSC configuration
</td></tr><tr><td> SDK-53810 
 </td><td> 739299
 </td><td> All
 </td><td> Background:
=========
Whenever SDK performs MDIO write/read operation, the linkscan event has been stopped before the operation and restarted after the operation. The reason behind this, prior to CMICm, software has to stop the linkscan before any MDIO write/read operation as the MDIO controller in hardware doesn't handle parallel access between link and MDIO write/read.
<p>Problem:
======
When a port is set to disabled while configured at 100M speed, the link down interrupt from the CMICm is missed. The time between the linkscan event restarts and the interrupt generation from CMICm is not synchronized. It could be due to some race condition.
<p>Solution:
======
SDK should be able to perform MDIO write/read operation without stalling active linkscan operation now as it is handled in CMICm hardware (well controlled by HW MDIO controller). 
Hence, removed the <tt>bcm_linkscan_pause</tt>() and <tt>bcm_linkscan_continue</tt>() functions from all the miim read/write calls.
</td></tr><tr><td> SDK-53822 
 </td><td></td><td> 56850_A1
56850_A2
56850_A0
 </td><td> provided new objects to get the information about
<p>a) Max 128B V6, 64B V6, V4 entries for a given configuration
b)used 128B V6, 64B V6, V4 entries
c) Free 128B V6, 64B V6, V4 entries
</td></tr><tr><td> SDK-53830 
 </td><td></td><td> 88650_A0
88650_B0
 </td><td> When calling <tt>bcm_port_match_add</tt> with an egress match, with a valid input but a remote port, the return value should be <tt>BCM_E_NONE</tt> without any configuration. Instead return value is <tt>BCM_E_NOT_FOUND</tt>.
</td></tr><tr><td> SDK-53875 
 </td><td> 737326
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> There was no BCM API to control the L2 learning per VXLAN logical port before. Now <tt>bcm_port_learn_get</tt>/set can be re-used to get/set the L2 learning per VXLAN logical port.
</td></tr><tr><td> SDK-53876 
 </td><td> 740022
 </td><td> 56850_A0
 </td><td> bcmFieldQualifyMhOpcode and bcmFieldQualifySourceVirtualPortValid qualifiers offsets are updated for Ingress Field Processor to match with regfile (56850).
<p>Problem : SDK was unable to use bcmFieldQualifyMhOpcode and bcmFieldQualifySourceVirtualPortValid qualifiers in the Key format - FPF3 in Ingress Field Processor.
<p>Solution : bcmFieldQualifyMhOpcode and bcmFieldQualifySourceVirtualPortValid qualifiers offsets are updated for Ingress Field Processor to match with regfile (56850).
<p>This is done in Initialization routine of Ingress Field Processor for the Key Format - FPF3 .
</td></tr><tr><td> SDK-53885 
 </td><td> 740483
 </td><td> 56450_A0
 </td><td> Fixed the issue where entry in <tt>EGR_MPLS_VC_SWAP_LABEL_TABLE</tt> is replaced when a dfferent MPLS port uses the same VC label but having different properties. With this fix a new entry will be created in the above mentioned table instead of replacing the existing entry.
</td></tr><tr><td> SDK-53890 
 </td><td></td><td> 88650_A0
 </td><td> Fix of building errors occurred when the Makefile includes KBP flags :
+ <tt>FEATURE_LIST</tt> := .... KBP
+ <tt>KBP_DEVICE</tt> := <tt>KBP_ALG</tt>
and missing WB flags:
- CFGFLAGS += -<tt>DBCM_WARM_BOOT_SUPPORT</tt>
- CFGFLAGS += -<tt>DBCM_WARM_BOOT_SUPPORT_SW_DUMP</tt>
- CFGFLAGS += -<tt>DBCM_EASY_RELOAD_WB_COMPAT_SUPPORT</tt>
</td></tr><tr><td> SDK-53894 
 </td><td></td><td> 56640_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56640_A1
56643_A1
56644_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
 </td><td> Support added for software assisted virtual port L2 flush. In addition, there was an issue where the software copy of the L2 entries learnt on external ESM was out of sync with the hardware,. This is now handled by correctly extracting and updating external L2 entries into internal software copy.
</td></tr><tr><td> SDK-53907 
 </td><td> 740307
 </td><td> 88650_A0
 </td><td> Fixed alloc manager failure in case PWE is created over LAG.
The scenario that caused failure:
1. Tunnel application setup using <tt>l3_egress_object</tt> on a LAG port.
2. Create a PWE on the tunnel interface
</td></tr><tr><td> SDK-53912 
 </td><td> 739785
 </td><td> 56850_A0
56340_A0
 </td><td> Added ability to support ETAG(Port Extender VLAN Tag) tunneled mirror.
</td></tr><tr><td> SDK-53919 
 </td><td> 740350
 </td><td> All
 </td><td> STG Id - 0 is reserved and used for internal purposes only and VLANs should not be added to this group. Updated the users guide with the above information.
</td></tr><tr><td> SDK-53926 
 </td><td> 740455
 </td><td> 88650_A0
 </td><td> In Metering HW, rate configuration is performed via a mantissa and exponent representation.
An internal SW function is used to convert from a rate to the mantissa and exponent representation, and takes as input the maximal allowed exponent and mantissa.
<p>Due to a bug, in some cases this function could return an out-of-bounds value (bigger than the maximal mantissa), which causes an assertion failure when the value is written to the HW.
<p>This is now fixed.
</td></tr><tr><td> SDK-53934 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In previous releases, if we configured L3Depth larger than 0, it was not possible that single-wide or double-wide entries could be moved to other banks to free its original space for wider entries like double-wide or quad-wide entry. In this release, single-wide or double-wide entries can be moved to other banks to free its original space for wider entry, and the total utilization of L3 benefits from this.
</td></tr><tr><td> SDK-53935 
 </td><td></td><td> 56850_A0
 </td><td>In earlier releases, <tt>bcm_l2_matched_traverse</tt> API call did not have a way to retrieve Static only entries. Code has been added to deal with the action for the STATIC only entry. When the action is for the STATIC only entry, we now set <tt>STATIC_BIT</tt> in both data and mask fields. 
</td></tr><tr><td> SDK-53940 
 </td><td></td><td> 56850_A2
 </td><td> There is one issue for eye scan extrapolation that yields 1e-0.0 BER. The reason is that the sample points used in the extrapolation are less than 2 and the eye scan function rejects its calculation. Also the sample points are not screened, but to include all nodes, to fit the extrapolation equations. This JIRA is to fix these issues by picking or creating the proper sample points for extrapolation.
<p>For the PRBS error count, the read back from the PRBS status register is 2X for some counting modes, but the calculation equation is expected to be 1X in eye scan, while 2X in the eye margin.   This JIRA irons out the difference by changing the eye margin to expect 1X as well. 
</td></tr><tr><td> SDK-53946 
 </td><td></td><td> 88650_B1
88660_A0
 </td><td> Important note: in Fiber channel APIs, due to an API change, the user must replace <tt>bcm_fcoe_zone_entry_t</tt>-&gt;vsan.vsan by <tt>bcm_fcoe_zone_entry_t</tt>-&gt;<tt>vsan_id</tt>, e.g. in <tt>bcm_fcoe_zone_add</tt> API.
</td></tr><tr><td> SDK-53952 
 </td><td> 741900
 </td><td> 56450_A0
 </td><td> Resource leakage issue in <tt>EGR_MPLS_VC_AND_SWAP_LABEL_TABLE</tt> caused by <tt>bcm_mpls_port_add</tt>() API is fixed.
</td></tr><tr><td> SDK-53955 
 </td><td> 740686
 </td><td> 56640_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56640_A1
56643_A1
56644_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
 </td><td> In some configurations, ISM memory buckets greater than what is desired was being allocated. This has been addressed by correctly allocating just what is needed, by checking for boundary conditions.
</td></tr><tr><td> SDK-53956 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> Egress compensation can be configured for egress ports using the API <tt>bcm_cosq_control_set</tt> (bcmCosqControlPacketLengthAdjust).
When the compensation is configured for port with header type XGS_DiffServ, XGS_HQoSan error will occur.
Fixed.
</td></tr><tr><td> SDK-53960 
 </td><td></td><td> 88650_A0
 </td><td> when running on little Endian CPU (gto is big Endian) some field BCM APIs may fail, for example following :
create pre-selector egress PMF entry with qualifier bcmFieldForwardingTypeIp4Ucast .
The fix was in the internal function "<tt>shr_bitop_range_copy</tt>"
</td></tr><tr><td> SDK-53961 
 </td><td></td><td> 88650_B0
 </td><td> 5.75G support is added for ILKN mode
</td></tr><tr><td> SDK-53963 
 </td><td> 741711
 </td><td> 56850_A2
 </td><td> Fixed VXLAN/L2GRE tunnel initiator's udp port update functionality.
</td></tr><tr><td> SDK-53968 
 </td><td> 740158
 </td><td> 56850_A0
 </td><td> Fixed to validate VXLAN and L2GRE VPN during <tt>port_delete</tt> and <tt>port_get</tt> API.
</td></tr><tr><td> SDK-53972 
 </td><td></td><td> 88650_A0
 </td><td> Petra-B-ARAD system: initialize values correctly for system-headers under Petra-B ARAD system
</td></tr><tr><td> SDK-53992 
 </td><td></td><td> 56640_A0
56850_A0
56640_A1
56640_B0
56850_A1
56850_A2
 </td><td> When a new V6 prefix group is being created and if the start index falls in paired TCAM the following is being done.
<p>1. Check if the previous prefix group has free entries in unpaired TCAM. If yes, set the start of the new prefix group to be that index.
2. if the previous group doesnt have any free entries in unpaired tcam, try to move entries up. if entries can be moved up, then set start as start - 1 of the next prefix group.
</td></tr><tr><td> SDK-53993 
 </td><td> 742520
 </td><td> 56450_A0
 </td><td> The <tt>bcm_port_match_add</tt>() API was writing the data into wrong entry in <tt>vlan_xlate</tt> table because the search key did not include the field <tt>source_type</tt>=1(sglp). As a result it was not matching the existing entry.
Modified <tt>bcm_mpls_port_match_add</tt>() API to include the  <tt>SOURCE_TYPE</tt> field as part of key for adding  entry in <tt>VLAN_XLATE</tt> table.
</td></tr><tr><td> SDK-53994 
 </td><td> 741664
 </td><td> 88650_B0
88650_B1
 </td><td> L3: TTL scope entries were not freed when the RIF is deleted.
</td></tr><tr><td> SDK-53996 
 </td><td> 741161
 </td><td> 56640_A0
 </td><td> Fixed the problem of wrong tunnel index generation in SDK. The tunnel index was wrongly multiplied by 4 before being written into hardware. it made the tunnel index space to use only quarter entries in hardware. Rest of the tunnel indexes values were out of the limit to be written into hardware and resulted in error. Due to this reason, the capwap tunnels were able to scale only to quarter of full hardware space.
</td></tr><tr><td> SDK-53998 
 </td><td> 737239
 </td><td> 56800_A0
56334_A0
 </td><td> In previous SDK, the statistics snmpIfOutDiscards returned wrong value on some old devices.
This snmp counter was mapped to MMU_CTR_MC_DROP_MEMm, but this memory was not existed in some old devices, so the counter should be mapped to some other memories.
This issue has now been resolved. 
</td></tr><tr><td> SDK-54001 
 </td><td></td><td> All
 </td><td> Show KNET protocol override option in CLI help.
Added proper support for protocol override in <tt>bcm_knet_filter_get</tt> API.
</td></tr><tr><td> SDK-54004 
 </td><td></td><td> 56640_B0
 </td><td> Added the support code for the new SKU BCM56044.
</td></tr><tr><td> SDK-54009 
 </td><td> 739826
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> In L2, during access of static entries (get or delete operations), the parsing of the MAC entry age field was incorrect, causing an internal function failure.
The parsing error is fixed, including the removal of an unneeded HW access.
</td></tr><tr><td> SDK-54014 
 </td><td></td><td> 88660_A0
 </td><td> In BCM88660, the user can select packets which tries to transplant a static MAC Table entry during learning.
Specifically, when a statically inserted MACT entry is matched in the learning lookup, but the Source-Port is mismatched, the entry is not modified.
If the user wants to match in Ingress Field Processor such packets, 
The fix includes: 
1. Setting Out-LIF valid bit when inserting a static L2 entry with no OutLIF and no valid EEI. 
2. Modifying the is-dynamic-entry indication to fix the transplant indication that arrives to the FP.
3. Running <tt>cint_field_drop_static_sa_transplant</tt>.c (new CINT example) to drop such packets
</td></tr><tr><td> SDK-54015 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> In the policer module, when calling the <tt>bcm_policer_create</tt> and <tt>bcm_policer_set</tt> functions, the <tt>BCM_POLICER_REPLACE</tt> can be used to replace the configuration of a meter, or the template that the meter points to.
<p>A cint example has been added that shows how to use the <tt>BCM_POLICER_REPLACE</tt> flag to change the configuration of a meter.
For details see the function <tt>metering_replace_example</tt> in <tt>cint_policer_metering_example</tt>.c.
</td></tr><tr><td> SDK-54019 
 </td><td></td><td> 88650_B1
88660_A0
 </td><td> Provide a CINT example for followed improvement.
In case of L2GRE and VXLAN bud node, MC packet received from overlay recycle port couldn't be decapsulated correctly at previous release. Now the issue was fixed based on new soc property <tt>default_logical_interface_ip_tunnel_overlay_mc</tt>.
</td></tr><tr><td> SDK-54021 
 </td><td></td><td> 88650_A0
88650_B0
 </td><td> Bug was fixed in event handling of events with high RMEP indices for Arad A0/B0.
</td></tr><tr><td> SDK-54031 
 </td><td> 743203
 </td><td> 88650_A0
88650_B0
88660_A0
 </td><td> Configuration of the Credit Discount of ISQs is now possible using:
<tt>bcm_cosq_control_set</tt>(unit, <tt>isq_gport</tt>, cosq, bcmCosqControlPacketLengthAdjust, <tt>header_size</tt>);
</td></tr><tr><td> SDK-54034 
 </td><td> 743244
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Added bcmFieldQualifySrcNivGport,bcmFieldQualifyDstNivGport,bcmFieldQualifyDstGport Qualifiers. In this JIRA, these new qualifiers are initialized only for TD2. Updated bcmFieldQualifySrcGport Qualifier in TD2 to support Niv source GPORT.
</td></tr><tr><td> SDK-54035 
 </td><td></td><td> 56850_A2
 </td><td> This JIRA is to fix the port status (ps) command about the speed reporting problem for 11G forced speed modes for the TSC driver.
</td></tr><tr><td> SDK-54037 
 </td><td> 739743
 </td><td> All
 </td><td> On certain devices which do not support
the blocking of <tt>KNOWN_MCAST</tt> type of traffic
a fix has been added to no longer return error.
This issue was originally reported on Raven
</td></tr><tr><td> SDK-54038 
 </td><td></td><td> 88650_A0
 </td><td> In Field diagnostics (mode 3) entries validation is performed for all banks. This causes a segmentation fault because it should only be for banks that their owner is PMF, since the entry management for other owners is not performed by PMF. Fixed.
</td></tr><tr><td> SDK-54042 
 </td><td></td><td> 88650_B1
 </td><td> In BCM L3 file, the macro <tt>DPP_VRF_VALID</tt>(<tt>_vrf</tt>) definition included a limitation that was not correct for Arad devices. This caused an error when trying to create a L3 interface with VRF&gt;255.
The macro definition is changed to support the Arad's limitation.
</td></tr><tr><td> SDK-54053 
 </td><td> 743221
 </td><td> 56640_A0
56640_B0
 </td><td> On parity error in MMU counters the hardware was not clearing the entries. As a fix, when the parity error happens we now clear parity status and then clear the entry.
</td></tr><tr><td> SDK-54055 
 </td><td></td><td> 88650_A0
 </td><td> Trill: <tt>bcm_trill_multicast_entry_get</tt> is now supported.
</td></tr><tr><td> SDK-54058 SDK-53881 SDK-53879 SDK-53878 SDK-53880
 </td><td></td><td> 88650_A0
 </td><td> The Drop-Precedence (DP) is a value that represents QoS internally.
The DP is a 2 bit value that represents the colors green (0), yellow (1-2), and red (3).
<p>Today, when a packet was received in the device, and its DP was resolved to 2 (or yellow), the device would change it to 1 (also yellow) when sending the packet.
This is a result of an attempt to always represent yellow as 1.
However in some cases -- for instance when a packet is sent to the device and receives a DP of 2, and this DP should remain 2 -- this will cause problems for the user.
<p>This is now fixed by keeping the DP at the same value instead of changing it to 1.
</td></tr><tr><td> SDK-54063 
 </td><td> 743248
 </td><td> 56643_A0
 </td><td> <tt>XMAC_OSTS_TIMESTAMP_ADJUST</tt> accounts for delays during the mac stage. This register was always being programmed to zero.
Now, This register will be configured with proper value for non GE ports, and for GE ports this will be configured to  zero. The value of this register doesnot matter for GMII/MII speeds
</td></tr><tr><td> SDK-54064 
 </td><td> 743921
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> Resolved schan time out when setting pfc refresh timer. The error is caused by reading non-existent register.
</td></tr><tr><td> SDK-54067 
 </td><td></td><td> All
 </td><td> Converted MAID value to network byte order before writing to HW table in order to avoid CCM convergence issues arising due to host processor endianness.
</td></tr><tr><td> SDK-54072 
 </td><td> 744057
 </td><td> 56850_A0
 </td><td> Updated bcmFieldQualifyDstNivGport,bcmFieldQualifyDstGport Qualifiers to support Niv GPORT at EFP in TD2
</td></tr><tr><td> SDK-54075 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> VLAN-compression: Delete correctly global VLAN range, in case of no ports refer to it.
</td></tr><tr><td> SDK-54083 
 </td><td> 735871
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> <tt>bcm_l2_addr_add</tt>() returns error when trunk tgid is used and more than 256. This issue was due to wrong define max value. We fixed the define value.
</td></tr><tr><td> SDK-54087 
 </td><td> 743745
 </td><td> 56850_A0
 </td><td> In the previous release <tt>bcm_mirror_port_dest_add</tt> failed with -18 on NIV ports,This issue has been fixed.
</td></tr><tr><td> SDK-54088 
 </td><td></td><td> 56850_A0
 </td><td> In earlier releases <tt>bcm_l3_init</tt>() should clear <tt>rh_ecmp_flowset</tt> but this function did not work. This has been resolved.
</td></tr><tr><td> SDK-54092 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> During Driver initialization, all the meter were initialized to use Meter-profile 0.
This was unnecessary and removed, since the HW table was already initialized to zero.
</td></tr><tr><td> SDK-54093 
 </td><td> 743673
 </td><td> 88650_A0
 </td><td> Ingress packet size limit is set to (16KB-128bytes) if the DRAM buffer size is 512 bytes or higher, and set to 8KB if the DRAM buffer size is 256 bytes.
</td></tr><tr><td> SDK-54100 
 </td><td></td><td> 88650_A0
 </td><td> Different threads (Counter Processor, Rx LOS) were failing due to forbidden access to the device during Warm-boot procedure. In counter processor case exceptional access is allowed. For RX LOS initialization postponed till after the Warm Boot finished
</td></tr><tr><td> SDK-54114 
 </td><td></td><td> 88650_A0
 </td><td> In Field Processor, the Diagnostics command "BCM&gt; diag field res"displays information on databases and banks.
The number of entries per bank and database displayed by the diagnostic was incorrect when the entry (bank 0, line 0) was occupied by this Database. 
Fixed.
</td></tr><tr><td> SDK-54115 
 </td><td> 743990
 </td><td> 88650_B1
 </td><td> Template management: Resolved issue in a template allocation mechanism that caused on some cases a crash in bcm.user when resource fails to be allocated. This could happen when asking for more profiles than device capable for example: asking more LLVP profile in <tt>bcm_port_tpid_class_set</tt>.
</td></tr><tr><td> SDK-54117 
 </td><td></td><td> 88650_A0
 </td><td> <tt>port_enable_set</tt> API changed: The API is no longer stop EGQ or disable NBI FIFOs. Instead it drops the traffic in the NIF.
</td></tr><tr><td> SDK-54131 
 </td><td> 744562
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> CINT: Adjust <tt>vswitch_p2p_init</tt>, <tt>qos_map_gport</tt> to suit
the correct number of parameters when called from <tt>cint_qos_l2</tt>.c, <tt>qos_map_l2_run_with_untagged</tt> respectively.
</td></tr><tr><td> SDK-54148 
 </td><td></td><td> 88650_A0
88640_A0
 </td><td> In BCM L3 file, some errors were returned with a generic "TODO err message" text. All error messages in l3.c file are now meaningful.
</td></tr><tr><td> SDK-54154 
 </td><td></td><td> 88650_A0
 </td><td> In Field Processor, internal and external TCAM tables shared a limitation for the number of uninstalled entries. This limitation is now separated for internal and external TCAMs, in order to allow better control of limitations and memory allocations.
</td></tr><tr><td> SDK-54162 
 </td><td> 744768
 </td><td> All
 </td><td> Fixed VXLAN/L2GRE issue with <tt>bcm_vxlan_tunnel_initiator_destroy</tt> API associated with same-SIP, Multi-DIP scenario.
</td></tr><tr><td> SDK-54168 
 </td><td> 738971
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In previous release, parity error occurred at second half memory of <tt>ING_L3_NEXT_HOP</tt> could not be corrected. This has been resolved by correcting the memory depth of <tt>ING_L3_NEXT_HOP</tt> in SER.
</td></tr><tr><td> SDK-54171 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Move trill deprecated tests from 88640 devices to a deprecated folder.
</td></tr><tr><td> SDK-54174 
 </td><td> 744799
 </td><td> 88650_A0
88640_A0
88650_B0
88650_B1
88660_A0
 </td><td> VLAN: Remove an incorrect "entry not found" error when calling <tt>bcm_vlan_port_create</tt>().
</td></tr><tr><td> SDK-54183 
 </td><td> 745284
 </td><td> 88650_A0
88660_A0
 </td><td> VLAN: Calling <tt>bcm_vlan_port_create</tt> with the <tt>BCM_VLAN_PORT_CREATE_WITH_ID</tt> flag, prompts an API check whether the requested ID is available.
There was a bug where this check for valid ID would always check if a FEC ID is free, even though the VLAN port might be a multicast ID or a LIF ID.
This bug was fixed, and now every VLAN port created <tt>WITH_ID</tt> would check the appropriate resource is free.
</td></tr><tr><td> SDK-54185 
 </td><td></td><td> All
 </td><td> knetctrl filter show did not display the <tt>dest_proto</tt> field. Show overrided protocol type when showing knet filter infomation in bcm shell. This has been addressed.
</td></tr><tr><td> SDK-54186 
 </td><td> 743815
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Added SDK Support of ETHERTYPE key in FPF1 Mode 6 in Trident2 Chipset.
</td></tr><tr><td> SDK-54191 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> Changed replace logic in <tt>bcm_l3_intf_create</tt>.
After change, when creating l3 intf for the first time, REPLACE flag should not be added.
when creating existing l3 intf, REPLACE flag should be added.
</td></tr><tr><td> SDK-54192 
 </td><td> 738575
 </td><td> 88660_A0
 </td><td> DSCP/EXP marking when bridging allows the user to change the DSCP value of the IP header or the EXP value of the MPLS header of a packet, even when the packet is only bridged.
<p>To perform DSCP/EXP marking during bridging, the device is configured to set DSCP and EXP according to the assigned TC, DP, QoS profile and InLIF profile of a packet (map).
<p>Due to a SW bug, when configuring a map with TC 4 .. 7, nothing would be configured.
As a result packets that have TC 4..7 assigned to them and that DSCP/EXP should be performed on them will get invalid DSCP and EXP values.
<p>This fix resolves this issue.
</td></tr><tr><td> SDK-54194 
 </td><td> 745534
 </td><td> 56850_A0
 </td><td> An SDK crash issue was reported when trying to call <tt>bcm_l2_addr_replace</tt>() with &gt; 8K MAC address configured on various of vxlan tunnels. This was resolved by correcting the memory allocation. The system now allocates memory for l2 freezing according to the actual size of SOURCE_VPm instead of 8192.
</td></tr><tr><td> SDK-54195 
 </td><td></td><td> 88660_A0
 </td><td> MPLS tunnel works in two modes: Uniform and Pipe.
For Pipe mode, struct <tt>bcm_mpls_egress_label_t</tt> has two flags: <tt>BCM_MPLS_EGRESS_LABEL_EXP_SET</tt>, <tt>BCM_MPLS_EGRESS_LABEL_EXP_COPY</tt>, to distinguish between different MPLS pipe modes. 
In ARAD Pipe mode supports only <tt>BCM_MPLS_EGRESS_LABEL_EXP_SET</tt> flag.
ARAD PLUS supports global configuration of these settings, which is set using switch control
<tt>bcm_switch_contro_set</tt>(unit,bcmSwitchMplsPipeTunnelLabelExpSet, 1);
Default of the behavior is <tt>EXP_COPY</tt>.
The flags should be set in consistency with the global configuration.
If <tt>BCM_MPLS_EGRESS_LABEL_EXP_SET</tt> flag is set but bcmSwitchMplsPipeTunnelLabelExpSet switch control is not called, an error will be generated.
The same with copy - If <tt>BCM_MPLS_EGRESS_LABEL_EXP_COPY</tt> flag is set but bcmSwitchMplsPipeTunnelLabelExpSet switch control is called, an error will be generated.
See an example of use in: <tt>cint_mpls_lsr</tt>.c <tt>mpls_pipe_mode_exp_set</tt> function
</td></tr><tr><td> SDK-54202 
 </td><td> 741184
 </td><td> 56240_B0
 </td><td> <tt>MMU_INTR_MASK</tt> bits for CI0, CI1 and CI2 remain reset (set to 1) based on available memory banks. If number of external banks available is 0 then all for all CI0,1,2 the mask will be set. If it is 1 then the mask will be set for CI1 and CI2. if it is 2 then mask will be set only for CI2 and if it is 3 then mask will not be set for any of CI0-CI2.
</td></tr><tr><td> SDK-54203 
 </td><td></td><td> 56440_A0
56440_B0
 </td><td> Parity checks will now be turned off for non-existent external DDR memory banks.
</td></tr><tr><td> SDK-54205 
 </td><td> 738767
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> It was reported that small packets will be dropped if <tt>ENQ_ASF_HS_OVERSUB_EN</tt> hasn't been set for the 40G ports which are in oversubscription cut through mode. The issue has been resolved as below:
Add 40G/30G ports with oversub to <tt>ENQ_ASF_HS_OVERSUB_EN</tt> during init. As no matter the ports are enabled CT or not, these ports can always be in <tt>ENQ_ASF_HS_OVERSUB_EN</tt>.
</td></tr><tr><td> SDK-54209 
 </td><td> 744936
 </td><td> 56340_A0
56342_A0
 </td><td> Issue :- Segmentation Fault was observed when more than 254 Flex Counters were created in VFP region in Helix4.
   Fix :- Maximum number of Flex counters per pool were wrongly assigned during init. Updated the code with correct values.
</td></tr><tr><td> SDK-54211 
 </td><td> 682994
 </td><td> 88650_A0
88650_B0
88660_A0
 </td><td> A bug in <tt>bcm_oam_action_set</tt>() causing certain OAM frames to be erroneously pre-pended with an additional set of system headers in certain situations was fixed.
</td></tr><tr><td> SDK-54212 
 </td><td> 690179
 </td><td> 88650_B0
 </td><td> The following bug was fixed: OAM endpoints deletion is not releasing internal allocations in case of insertion of a MEP, calling <tt>bcm_oam_endpoint_action_set</tt> and then deleting the endpoint. After performing this sequence several times a failure will be returned.
</td></tr><tr><td> SDK-54213 
 </td><td> 736267
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Add received oversized frame counter (ROVR) value to snmpIfInErrors counter (<tt>bcm_stat_get</tt> API).
</td></tr><tr><td> SDK-54215 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Added documentation for a traffic example and additional documentation per function in <tt>cint_qos</tt>.c
</td></tr><tr><td> SDK-54220 
 </td><td> 745537
 </td><td> 88750_B0
 </td><td> When the CL72 mode is enabled, snake test with external loopback failed on fe1600, fixed.
</td></tr><tr><td> SDK-54230 
 </td><td> 741970
 </td><td> 88650_B0
88660_A0
 </td><td> 1588 Termination:
Added support to following 1588 termination classification (in addition to already supported 1588oE, 1588oUDPoIPoE): 
1. 1588oUDPoIPoIPoE
2. 1588oUDPoIPoMPLSoE
3. 1588oEoMPLSoE 
Packets will be identified as 1588 packets regardless the forwarding header: Switching  (Ethernet forwarding) Routing (IPV4/MPLS forwarding) or Tunnel (IP/MPLS) termination.
</td></tr><tr><td> SDK-54233 
 </td><td></td><td> 88650_A0
88650ACP_A0
88650_B0
88650_B1
 </td><td> Change diag pp DB_LIF_lkup_info diagnostic to print lif information instead of the rif information it was displaying previously.
</td></tr><tr><td> SDK-54235 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Egress VLAN Edit: EVE Operations are processed per packet after an ESEM lookup that yields an Out-LIF with a value up to 64K. ESEM entries for Out-LIFs with value above 32K, produced an incorrect Out-LIF value that in turn processed an incorrect EVE action.
The fix enables correct EVE behavior for OUt-LIFs above 32K as well.
</td></tr><tr><td> SDK-54236 
 </td><td></td><td> 88650_B0
88660_A0
 </td><td> In external Tcam, in the application file kbp.c, compilation warnings may appear due to a wrong return value variable type. The variable type is fixed.
</td></tr><tr><td> SDK-54246 
 </td><td> 733382
 </td><td> 88650_A0
 </td><td> When calling <tt>bcm_oam_init</tt>(0), <tt>counter_engine_source_0</tt> was used for <tt>INGRESS_OAM</tt> and <tt>counter_engine_source_1</tt> was used for <tt>EGRESS_OAM</tt>, regardless of the soc property configurations. After the fix, any one of the 4 counter_engine_source_Ns may be used for egress/ingress oam, however if OAM is used, at least on counter engine must be set to <tt>EGRESS_OAM</tt> and at least one must be set to <tt>INGRESS_OAM</tt>.
</td></tr><tr><td> SDK-54253 
 </td><td> 746153
 </td><td> All
 </td><td> Implemented <tt>bcm_field_qualify_data_get</tt> API for all devices supporting User Defined Function in Field module.
This helps to display qualifier data fed into User Defined Function during Field entry creation.
</td></tr><tr><td> SDK-54262 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Using the API <tt>bcm_cosq_stat_sync_get</tt>() to retrieve statistics resulted in incorrect values for counters that are wider than 32bits. The reason being only the initial 32bits were being retrieved. Now the width of the counter is fetched before retrieving the counter value.
</td></tr><tr><td> SDK-54263 
 </td><td> 744368
 </td><td> 88650_A0
88650ACP_A0
88650_B0
88650_B1
 </td><td> When replacing PWE using <tt>bcm_mpls_port_add</tt> api with a new push profile, the old push profile was not freed which might cause resources leak. This issue is fixed.
Note that replacing push profile is supported only in case PWE is protected.
</td></tr><tr><td> SDK-54264 
 </td><td></td><td> 88650_B0
88660_A0
 </td><td> Required changes in SDK in order to support KBP-SDK 1.1.1 for external TCAM.
</td></tr><tr><td> SDK-54266 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Fixed a bug in the bcm shell diagnostic function "diag pp cc". The vlan port information displayed in the diagnostic was missing some fields. These fields will now be displayed correctly.
</td></tr><tr><td> SDK-54269 
 </td><td> 746371
 </td><td> 88660_A0
 </td><td> OAM: Incorrect CCM interval was previously used.
</td></tr><tr><td> SDK-54271 
 </td><td></td><td> 88650_A0
88660_A0
88670_A0
 </td><td> VPLS: Up to now, calling <tt>bcm_mpls_port_create</tt> would always allocate both InLif and OutLif.
Current enhancement allocates OutLif resource only in case it's required by HW. 
In other words, in case of PWE unprotected P2P, OutLif is not allocated and can be used for other applications.
</td></tr><tr><td> SDK-54279 
 </td><td> 738771
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Some PHYs always set the bit <tt>XLMAC_RX_LSS_STATUS</tt>.<tt>LOCAL_FAULT_STATUS</tt> no matter the actual speed the port is running at. This leads to always displaying local faults with the CLI command "port xe", which would confuse the customers when the port is running at speeds less than 10G. Now the local faults will be displayed only if the bit <tt>XLMAC_RX_LSS_CTRL</tt>.<tt>LOCAL_FAULT_DISABLE</tt> is clear.
</td></tr><tr><td> SDK-54307 
 </td><td></td><td> 56850_A0
 </td><td> This query contained two questions related to the setting for <tt>num_ipv6_lpm_128b_entries</tt> in ALPM mode.
<p>The first question was about setting <tt>num_ipv6_lpm_128b_entries</tt> to 3072 with URPF enabled. This question was answered by Zheng Wang, and it looks like we do not support this configuration.
<p>The second question was about confirming the table sizes for l3 routes when varying the settings <tt>ipv6_lpm_128b_enable</tt>, <tt>l3_alpm_enable</tt>, and URPF.  It looks like the table was mostly right with a small modification in IPv6 64-bit mode (<tt>ipv6_lpm_128b_enable</tt>=0).
<p>2. Disable IPv6-128(config add <tt>ipv6_lpm_128b_enable</tt>=0)
<p>  2-1 Combined mode(config add <tt>l3_alpm_enable</tt>=2)
    IPv4-32(non-URPF)/(URPF)  IPv6-64(non-URPF)/(URPF) 
    128K/64K                  85K/21K
<p>  2-2 Parallel mode(config add <tt>l3_alpm_enable</tt>=1)
    IPv4-32(non-URPF)/(URPF)  IPv6-64(non-URPF)/(URPF) 
    64K/16K                   21K/5K
</td></tr><tr><td> SDK-54309 
 </td><td></td><td> 88650_A0
 </td><td> KBP compilation fix for not GTO processors
</td></tr><tr><td> SDK-54314 
 </td><td></td><td> 88660_A0
 </td><td> Add diag counter graphical representation for - <tt>EGQ_RQP_DISCARD_SOP_COUNTER</tt>
</td></tr><tr><td> SDK-54322 
 </td><td></td><td> 88650_A0
 </td><td> 1. In Ingress parser, the support of a single IPv6 extension header parsing is added, where only Hop-by-Hop extension is supported.
2. In Ingress Parser, the custom macro allocation is now dynamic. There are four configurable macros (aka custom macros), that are programmed to identify a header. These custom macros are dynamically allocated according to the enabled features (enabled by soc properties). The following soc properties determine the custom macros in the parser:
- <tt>bcm886xx_ipv6_ext_hdr_enable</tt> - new soc property that enables IPv6 header extension parsing, requires two custom macros.
- <tt>bcm886xx_fcoe_switch_mode</tt> - enables FCoE, requires two custom macros.
- <tt>custom_feature_udp_parse_disable</tt> - UDP custom macro is configured by default, however, if needed it can be disabled by this soc property. Note that if disabling UDP parsing, then VxLAN and 1588oUDP are affected.
- <tt>trill_mode</tt> - enables Trill, requires one custom macro.
- <tt>bcm886xx_vxlan_enable</tt> - enables VxLAN, requires one custom macro.
In the specific case of UDPoIPv4oEth, enabling or disabling VxLAN changes the value of parser object end-leaf, which is used in Trap in case there is an error in the Header size or in case of invalid packet format code.
3. In Ingress Field Group, a new qualifier bcmFieldQualifyExtensionHeaderType is introduced, which refers to the Next Header field in first IPv6 extension header after IPv6 header.
</td></tr><tr><td> SDK-54323 
 </td><td></td><td> 88650_A0
 </td><td> Due to inefficient internal implementation, the allocation manager was taking a lot of time during the warmboot recovery. The implementation was changed to reduce the number of function called during restoration and to accelerate the warm reboot.
</td></tr><tr><td> SDK-54328 
 </td><td> 743038
 </td><td> All
 </td><td> When configuring an OAM endpoint, <tt>L3_LOCK</tt> was not being released when an endpoint was in multiple maintenance domain levels. This was corrected.
</td></tr><tr><td> SDK-54329 
 </td><td> 735713
 </td><td> 88750_A0
88650_A0
 </td><td> Due to miss-configuration some corrupted cells not dropped as expected. Fixed.
</td></tr><tr><td> SDK-54343 
 </td><td></td><td> 88650_A0
 </td><td> 11.25G ILKN speed support is added
</td></tr><tr><td> SDK-54344 
 </td><td></td><td> 88650_A0
 </td><td> Device bring up fail when more than 191 ports are defined. fixed.
</td></tr><tr><td> SDK-54346 
 </td><td> 746652
 </td><td> 56850_A0
56850_A1
 </td><td> <tt>bcm_l3_cleanup</tt> was causing ASSERT error with L3 Egress Mode enabled, <tt>nh_index</tt> -1 could be used for <tt>bcm_xgs3_nh_del</tt> as array index and eventually could cause array bounds write and break the defensive area of allocated memory. Added <tt>nh_index</tt> parameter check to avoid invalid access.
</td></tr><tr><td> SDK-54347 
 </td><td> 738808
 </td><td> All
 </td><td> bcmPortControlFabricSourceKnockout was not documented in BCM SDK manual.
<p>Added documentation for bcmPortControlFabricSourceKnockout.
</td></tr><tr><td> SDK-54352 
 </td><td> 743979
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In previous SDK, the <tt>COS_MAP_SEL</tt> table on TD2 sometimes was constructed incorrectly by <tt>bcm_cosq_gport_mapping_set</tt> API.
The root cause of this problem was that the SDK would use <tt>ing_port</tt> to generate a index of the <tt>COS_MAP_SEL</tt> table, but this index was overwritten incorrectly and caused the problem.
This issue has been resolved.
</td></tr><tr><td> SDK-54357 
 </td><td></td><td> 56850_A2
 </td><td> The TX squelch function will be persistent through phy enable (on) function, so <tt>mac_loopback</tt> with port disabled could be operable with the helps of the above functions.
</td></tr><tr><td> SDK-54363 
 </td><td></td><td> 88660_A0
 </td><td> PON: Trap packets that are send to PON port 12Bytes were added by egress-editor. 12Bytes padding is now removed.
</td></tr><tr><td> SDK-54369 
 </td><td> 747308
 </td><td> 56850_A2
 </td><td> Fixed VXLAN/L2GRE Tunnel Terminator State modification during <tt>multicast_port_create</tt>
</td></tr><tr><td> SDK-54378 
 </td><td></td><td> 88650_A0
 </td><td> To debug more easily warmboot issues, a SW state dump is available via BCM&gt;diag ssdump
The SW state dump output to screen can now be disabled.
</td></tr><tr><td> SDK-54385 
 </td><td> 747110
 </td><td> 88650_B1
 </td><td> In the HW implementation of the Exact Match (EM) tables, a defrag machine can be enabled for all the EM tables.
This machine was enabled only for Large-EM, and it is now enabled by default for all the EM tables.
</td></tr><tr><td> SDK-54395 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Support binding 32 LIF cos profiles to InLIF in case of local switching enabled.
</td></tr><tr><td> SDK-54398 
 </td><td> 746146
 </td><td> 56854_B0
56850_A2
 </td><td> In previous releases, when one interrupt was raised rather than CHIP Function's, only it would beprocessed and the CHIP Function's was lost. In this release they will be processed one by one through comparing all the irqState with irqMask.
</td></tr><tr><td> SDK-54400 
 </td><td> 746935
 </td><td> 56850_A0
 </td><td> Fixed <tt>EGR_PORT_TO_NHI_MAPPING</tt> during multicast egress object destroy
</td></tr><tr><td> SDK-54414 
 </td><td> 739326
 </td><td> 56640_B0
 </td><td> following phy diag command is created to be able to poke into core0,1,3 and MLD register for100G plus port. And the format is
 phy diag pbm reg core0(core1, core2, mld) aer <tt>reg_addr</tt> (for read)
 phy diag pbm reg core0(core1, core2, mld) aer <tt>reg_addr</tt> <tt>write_value</tt> (for write) 
</td></tr><tr><td> SDK-54420 
 </td><td> 746955
 </td><td> All
56850_A0
 </td><td> Only physical gport type supported in function <tt>bcm_l2_addr_delete_by_vlan_gport_multi</tt> for specific usage, added support for trunk gport type accordingly.
</td></tr><tr><td> SDK-54423 
 </td><td></td><td> 88650_A0
 </td><td> Vlan Translation: a new feature is added to support configurable VLAN translation for IP packets according to 5-tuples (DIP, SIP, IP-next protocol, TCP/UDP src port, TCP/UDP dst port).
<p>In SW, the sequence to enable the feature is as follows:
1.	Set SOC property: <tt>vlan_translation_match_ipv4</tt>.
2.	Set VT port profile via <tt>bcm_vlan_control_port_set</tt> API using bcmVlanPortPreferIP4 attribute.
3.	Create VSI and add ports to VSI (create InLif).
4.	Create Field Group using <tt>bcm_field_group_create</tt>()  set QSET with bcmFieldQualifyStageIngressVlanTranslation and all 5-tuples qualifiers.
5.	Configure ASET with bcmFieldActionIngressGportSet action, and call <tt>bcm_field_group_action_set</tt>().
6.	Add entries to created field group.
<p>This feature cannot coexist with EVB support
<p>A new CINT is added for example: <tt>cint_field_flexible_qinq_example</tt>.c
</td></tr><tr><td> SDK-54424 
 </td><td></td><td> 56850_A0
 </td><td> Added new shell module - cosq. currently supported sub modules are compensation get/set for ingress/egress
</td></tr><tr><td> SDK-54426 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> BFD doesn't work properly on management system (one CPU that controls more than one device).
</td></tr><tr><td> SDK-54429 
 </td><td></td><td> All
 </td><td> Added new API <tt>bcm_stat_clear_single</tt>() to clear a single port stat
</td></tr><tr><td> SDK-54435 
 </td><td></td><td> 88660_A0
 </td><td> Important note:
SOC property <tt>ipmc_vpn_lookup</tt> was misused in code. 
Default value of soc property was set to 1 but the actual SW implementation is default value 0.
Default value of <tt>ipmc_vpn_lookup</tt> changed from 1 to 0 to match SW implementation.
</td></tr><tr><td> SDK-54436 
 </td><td></td><td> 88660_A0
 </td><td> Support to enable global IPMC function when <tt>ipmc_vpn_lookup_enable</tt>=0, and IPV4 compatible MC packets forwarding is according to &lt;RIF,G,SIP&gt; regardless the VRF value.
</td></tr><tr><td> SDK-54438 
 </td><td></td><td> 88650_A0
 </td><td> Added diag for header size difference on ingress and egress.
<p>usage:
cosq comp ing voq=&lt;id&gt;                         - show ingress compensation
cosq comp egr port=&lt;id&gt;                        - show egress compensation
cosq comp ing [voq=&lt;id&gt;] Compensation=&lt;value&gt;  - set ingress compensation
cosq comp egr [port=&lt;id&gt;] Compensation=&lt;value&gt; - set egress compensation
<p>if only compensation value is give (without port or voq), then all ports/voqs are set with the given compensation value.
</td></tr><tr><td> SDK-54441 
 </td><td></td><td> 88650_B0
88660_A0
 </td><td> OAM ARAD+ RDI can not be set by user. It is updated automatically according to:
1. Scanner LOC discovery on RMEP with same index as the MEP.
2. Received packet information.
The mode can be set in <tt>bcm_oam_endpoint_create</tt> using the following flags:
<tt>BCM_OAM_ENDPOINT2_RDI_FROM_RX_DISABLE</tt>, <tt>BCM_OAM_ENDPOINT2_RDI_FROM_LOC_DISABLE</tt>
</td></tr><tr><td> SDK-54442 SDK-54129 SDK-54128
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> The meter feature has two possible modes of operation - 32K or 64K.
In 32K mode, each packet has up to 2 meters with an ID spanning from 0 to 32K-1.
In 64K mode, each packet has just 1 meter,  with an ID spanning from 0 to 64K-1.
<p>The default Meter-ID is 0:
- In 64K mode, Meter-ID 0 is set as an invalid pointer. Thus, the meter processor does not perform metering on a packet if its Meter-ID has not been  modified.
- In 32K mode, Meter-ID 0 was not set as invalid. 
Since meter 0 is defined to allow the maximal rate, there was no issue with traffic loss.
However, it was affecting the color (drop precedence) given to the packet at egress.
E.g., if a packet was yellow or red, its color could change to green, ignoring the incoming color, even if a valid Meter-ID was not set to this packet.
<p>Meter-ID 0 is now invalid also in 32K mode. Thus, a packet with default Meter-ID will not have its color changed by metering.
Additionally, for backward compatibility sake, a SOC property is available to configure the device to set meter pointer 0 as valid: set the SOC property <tt>custom_feature_meter_pointer_0_enable</tt> to 1.
</td></tr><tr><td> SDK-54460 
 </td><td></td><td> 56850_A0
 </td><td> In earlier releases, Embedded NH's MAC and Port information was absent in l3 table traverse.This has been resolved.
</td></tr><tr><td> SDK-54484 
 </td><td> 745674
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> <tt>BCM_L2_REPLACE_MATCH_UC</tt> and <tt>BCM_L2_REPLACE_MATCH_MC</tt> are provided for specifying which type of MAC entries will be performed the delete operation.
Using the <tt>BCM_L2_REPLACE_DELETE</tt> flag and <tt>BCM_L2_REPLACE_MATCH_MC</tt> or  <tt>BCM_L2_REPLACE_MATCH_UC</tt> or both to delete all Unicast entries, Multicast entries or both respectively.
Using the <tt>BCM_L2_REPLACE_DELETE</tt> without either <tt>BCM_L2_REPLACE_MATCH_MC</tt> nor <tt>BCM_L2_REPLACE_MATCH_UC</tt> is the same as both are set. 
</td></tr><tr><td> SDK-54500 
 </td><td></td><td> 88660_A0
 </td><td> In FCoE module, the NPV switch support is added.
To configure it:
1. Set the relevant ports to be N_Port by using the <tt>bcm_port_control_set</tt> API with type bcmPortControlFcoeNetworkPort. 
2. Add new routes for source routing by setting in <tt>bcm_fcoe_route_add</tt> API the flags to (<tt>BCM_FCOE_SOURCE_ROUTE</tt> | <tt>BCM_FCOE_HOST_ROUTE</tt>).
Refer to <tt>cint_fcoe_route</tt>.c (<tt>fcoe_fcf_npv_example</tt> function) for configuration example.
When setting the NPV functionality, 2 new FLP programs are required.
</td></tr><tr><td> SDK-54501 SDK-51080
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> The template management is an internal module managing the profiles according to their attributes.
A diagnostic has been added to display:
1. The profile-ID range per template IDs
2. How many objects are pointing to each profile
3. The raw content of each profile 
</td></tr><tr><td> SDK-54505 
 </td><td></td><td> 88650_B1
 </td><td> OAM packets of all opcodes trapped to the CPU at the egress (up-MEPs) will include the OAM-ID on the FHEI. In 6.3, to attain this behavior the soc property <tt>custom_feature_oam_upmep_oam_id_on_fhei</tt> should be set to 1.
</td></tr><tr><td> SDK-54509 
 </td><td></td><td> 88650_A0
 </td><td> In general, SW state must be handled per unit, since multiple device SDK can run on the same CPU.
Multiple global SW states have been found not to be defined per unit. Fixed.
</td></tr><tr><td> SDK-54511 
 </td><td></td><td> 56850_A0
 </td><td> Changed the error type to Parameter error (<tt>BCM_E_PARAM</tt>) from <tt>BCM_E_UNAVAIL</tt> for the invalid relative offset input parameter in <tt>bcm_field_data_qualifier_ethertype_add</tt>() API.
</td></tr><tr><td> SDK-54515 
 </td><td></td><td> 88660_A0
 </td><td> DEFAULT BEHAVIOR CHANGE (ARAD+ only).
Out AC: Out ACs can be created in pairs by calling <tt>bcm_vlan_port_create</tt> with a <tt>BCM_VLAN_PORT_WITH_ID</tt> flag and pairs of <tt>vlan_port_id</tt>.
A problem occurs when creating a pair of Out ACs (15 MSBs) with the odd entry created first.When the even entry is created second, the odd entry gets corrupted.
The issue detailed above affects the Out AC creation. Pairs of Out AC can be created correctly after the fix in any order.
The fix include changing by default all empty EEDB entries to be with bit 34 set to 0.
</td></tr><tr><td> SDK-54519 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In the previous release, hash bits were not being calculated in <tt>soc_td2_l2x_hash</tt>() function. This has been fixed.
</td></tr><tr><td> SDK-54529 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> OAM RDI clear event does not generate a callback
</td></tr><tr><td> SDK-54533 SDK-57729
 </td><td></td><td> 56340_A0
56340M_A0
 </td><td> Added separate Ingress Qualifier Init routine for Helix4 device with required offset changes as per Regfile
</td></tr><tr><td> SDK-54536 
 </td><td></td><td> 88030_A0
 </td><td> It is not necessary to guard against oversubscribing the fabric
</td></tr><tr><td> SDK-54544 
 </td><td> 748071
 </td><td> 56840_A0
56440_A0
56850_A0
56450_A0
 </td><td> We received a customer request to make an l2 entry not routable by resetting the flag <tt>BCM_L2_L3LOOKUP</tt>.
In the previous release, some chips in the Trident family did not remove the entry from <tt>my_station_tcam</tt> table when the flag <tt>BCM_L2_L3LOOKUP</tt> was cleared.
This has now been resolved.
</td></tr><tr><td> SDK-54545 
 </td><td> 741393
 </td><td> All
56850_A0
56850_A1
56850_A2
 </td><td> There was a bug in the SDK when configuring the port using the following function in trident2 platform
<p><tt>bcm_port_control_set</tt>(unit,port,bcmPortControlExtenderType,<tt>BCM_PORT_EXTENDER_TYPE_SWITCH</tt>)
<p>The SDK was setting the PORT.<tt>VT_KEY_TYPE_2</tt> field correctly, but was not  setting the PORT.<tt>VT_PORT_TYPE_SELECT</tt>
 field. However PORT.<tt>VT_PORT_TYPE_SELECT_2</tt> field should be set.
<p>Fixed the port configuration in function '<tt>bcm_port_control_set</tt>'
</td></tr><tr><td> SDK-54551 SDK-50401
 </td><td> 747647
 </td><td> 56850_A0
 </td><td> Support has been added for TD2 for <tt>bcm_port_subsidiary_ports_get</tt> API.
</td></tr><tr><td> SDK-54557 
 </td><td> 742238
 </td><td> 88650_B1
 </td><td> A priority list is a data structure that keeps a list sorted according to some priority. This data structure is used for TCAM management of the TCAM entries according to priority.
<p>Due to a SW bug, invalid memory is read and returned in a local function when trying to get the previous element of the first element, which can cause an invalid memory access. 
<p>This fix resolves this issue, by returning the head in the aforementioned case.
</td></tr><tr><td> SDK-54567 
 </td><td> 748978
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> The bcm shell diagnostic command "diag pp dblif" support:
- for vxlan: key: vni, data: vsi 
- for l2gre: key: vsid, data: vsi. 
</td></tr><tr><td> SDK-54571 
 </td><td> 749766
 </td><td> 56643_A0
56644_A0
56643_A1
56644_A1
 </td><td> Issue observed was <tt>P_START_SPRI</tt> was not programmed correctly and this was evident in CLI output of LLS command where the FC "first child" calculation does not match the index of first SP child.
Fix provided - in port sched dynamic mode, the <tt>P_START_SPRI</tt> is correctly configured to the index of first SP child.
</td></tr><tr><td> SDK-54573 
 </td><td> 745949
 </td><td> 88650_A0
88650_B0
88660_A0
 </td><td> <tt>bcm_port_tpid_class_get</tt>() should call the SOC_PPD_LLP_PARSE_INFO_clear before using the <tt>SOC_PPD_LLP_PARSE_INFO</tt> structure.
</td></tr><tr><td> SDK-54585 
 </td><td> 742690
 </td><td> All
 </td><td> During VPLS Virtual routing using Ingress Field Processor, <tt>REDIRECT_TO_DVP</tt> Action [bcmFieldActionRedirect] in Field module takes Virtual Port information from <tt>ING_DVP_2_TABLE</tt> for devices like Trident, Trident2, Triumph3.
Currently we were configuring <tt>ING_DVP_TABLE</tt> only with next hop entries and support to configure <tt>ING_DVP_2_TABLE</tt> was missing.
Hence added code to configure next hop entries in <tt>ING_DVP_2_TABLE</tt> during VP port add , through this JIRA.
Also added code to delete next hop entries in <tt>ING_DVP_2_TABLE</tt> during VP port delete.
</td></tr><tr><td> SDK-54589 
 </td><td> 749529
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Offset state was not being properly cleaned up when programming flex hash.
In this release we have corrected the UDF_CONDITIONAL_CHECK_TABLE_RAMm configuration flow when destroy a flexible hash entry.
</td></tr><tr><td> SDK-54604 
 </td><td></td><td> 56450_A0
56440_B0
56450_B0
 </td><td> In previous releases bcmCosqControlBandwidthBurstMax and bcmCosqControlBandwidthBurstMin could not update refresh rate based on burst and shaping rate.The implementation has been modified to calculate refresh rate and update shaper configuration.
</td></tr><tr><td> SDK-54605 
 </td><td> 735909
 </td><td> 56640_B0
 </td><td> In single lane or dual lane mode, if the autoneg is enabled, firmware mode 0 should be used. However all the 4 lanes of that core firmware was to set to 0 instead of relevant lanes only. This has been fixed.
</td></tr><tr><td> SDK-54606 
 </td><td> 651774
 </td><td> 56850_A2
 </td><td> The supports for per-lane PHY controls have been added in TSCMOD.
</td></tr><tr><td> SDK-54610 
 </td><td> 750318
 </td><td> All
 </td><td> The counter thread could end up in a continuous loop when sbusdma was busy/not initialized, In this release we have added timeout to break from this loop.
</td></tr><tr><td> SDK-54615 
 </td><td> 748837
 </td><td> 56224_B0
56224_A0
 </td><td> Background:
=========
<tt>bcm_vlan_translate_add</tt>(),delete, <tt>egress_add</tt> and <tt>egress_delete</tt> functions were not implemented to handle wildcard port parameter.
<p>Problem:
======
<tt>bcm_vlan_translate_add</tt>(),delete, <tt>egress_add</tt> and <tt>egress_delete</tt> functions were throwing error when  wildcard port parameter was passed.
<p>Solution:
======
Added port specific check in <tt>bcm_vlan_translate_add</tt>(),delete, <tt>egress_add</tt> and <tt>egress_delete</tt> functions which allows user to perform vlan operations by passing wildcard port parameter.
</td></tr><tr><td> SDK-54619 
 </td><td></td><td> 88650_B0
 </td><td> Added diag "cosq flush" to flush all egress queues per port
</td></tr><tr><td> SDK-54620 
 </td><td></td><td> 88660_A0
 </td><td> In L2 bridging, the number of MACT entries can be limited globally, per FID or LIF. During packet SA learning, events are sent to the OLP when the MACT entry number limit is exceeded.
In BCM88660, a new functionality allows to disable sending these limit-reached messages, reducing the number of created events, by setting the <tt>switch_control</tt> bcmSwitchL2LearnLimitToCpu to 0.
In this case, in the HW, an interrupt is enabled to indicate that the limit was reached.
</td></tr><tr><td> SDK-54621 
 </td><td></td><td> 88650_B1
88660_A0
 </td><td> For a packet performing a Traffic Management (TM) processing, the regular egress processing removes the system headers (i.e. FTMH and its extensions if exist, PPH and its extensions if exist, User-Header).
An improvement allows to remove only the FTMH header and its extensions if exist. 
If the <tt>custom_feature_otmh_keep_pph_</tt>&lt;port&gt; SOC property is set, then on this port all the headers starting from the PPH header are preserved.
</td></tr><tr><td> SDK-54625 
 </td><td></td><td> 88650_A0
 </td><td> increased the table size for warmboot in arad.soc in order to have enough storage space when running with OAM application.
</td></tr><tr><td> SDK-54635 SDK-37263
 </td><td></td><td> 56846_A1
 </td><td> In the previous release, SDK only configured the mac driver of current mode when invoking the <tt>mac_control_set</tt>() function. In this release, we will do <tt>mac_control_set</tt>() in both XMAC and UniMAC MAC driver except for some special cases. This has been fixed.
</td></tr><tr><td> SDK-54638 
 </td><td> 727800
 </td><td> 56640_A0
56643_A0
56640_A1
56643_A1
56640_B0
56643_B0
 </td><td> An issue was reported where external FP failed to qualify IPv6/TCP-IP packets with given L4SrcPort and L4DstPort. Corrected the offset of the qualifiers L4SrcPort, L4DstPort for external FP (<tt><tt>_FP_EXT_ACL_L2_IPV6</tt></tt> ACL) during qualifiers init.
</td></tr><tr><td> SDK-54640 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> For a TRILL Multicast entry, the get/delete APIs did not check both port and MC group match.
It could cause deletion of an incorrect entry. This is fixed
</td></tr><tr><td> SDK-54641 
 </td><td> 746928
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> STG: A "STG" diag cli command is added to operate or display STG info of device. The usages of "STG" command are listed as below.
BCM.0&gt; stg
Usage (STG): Usages:
          stg create [&lt;id&gt;]            - Create a STG; optionally specify ID
          stg destroy &lt;id&gt;             - Destroy a STG
          stg show [&lt;id&gt;]              - List STG(s)
          stg add &lt;id&gt; &lt;<tt>vlan_id</tt>&gt; [...]     - Add VLAN(s) to a STG
          stg remove &lt;id&gt; &lt;<tt>vlan_id</tt>&gt; [...]  - Remove VLAN(s) from a STG
          stg stp                      - Get span tree state, all ports/STGs
          stg stp &lt;id&gt;                 - Get span tree state of ports in STG
          stg stp &lt;id&gt; &lt;pbmp&gt; &lt;state&gt;  - Set span tree state of ports in STG
                                         (disable/block/listen/learn/forward)
          stg default [&lt;id&gt;]           - Show or set the default STG
</td></tr><tr><td> SDK-54642 
 </td><td> 750484
 </td><td> 88230_C0
 </td><td> 1) Changed #if/#else/#endif comment at #endif to match #if, which was changed from <tt>BCM_FE2000_SUPPORT</tt> to <tt>BCM_SBX_SUPPORT</tt>.
<p>2) Changed several internal functions beginning with <tt>string_to</tt> to static functions to make the more unique to the specific source file. 
</td></tr><tr><td> SDK-54646 
 </td><td></td><td> 56340_A0
 </td><td> <tt>SOC_EGRESS_METERING_LOCK</tt> is not unlocked on exceptions which led to crash on event processing.
Fixed in the exceptions to unlock the semaphore.
</td></tr><tr><td> SDK-54661 
 </td><td> 750105
 </td><td> 88230_C0
88230_B0
88230_A0
 </td><td> Fixed Make procedure for 88230 devices
</td></tr><tr><td> SDK-54669 SDK-52871
 </td><td> 787225
 </td><td> 56850_A0
 </td><td> Previously, trunk based <tt>MY_STATION_TCAM</tt> was not programmed for VXLAN and TRILL. Now it is programmed as l3 egress object is created.
</td></tr><tr><td> SDK-54672 
 </td><td> 749143
 </td><td> All
 </td><td> Issue :-
<p>While doing warm boot(level 2)  two times with intra slice double wide group, virtual map information in fp was not recovered properly after the first warm boot and this downgrades the recovery level from level 2 to level 1 during second  warm boot.
<p>Fix :- 
While doing level 2 warm boot, after the warm boot succeeds, recreate the virtual map information based on the group information that was recovered.
</td></tr><tr><td> SDK-54680 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> MPLS: <tt>bcm_mpls_port</tt> add() supports <tt>BCM_MPLS_PORT_REPLACE</tt> flag to replace egress label only if the tunnel port id is protected.
A problem occurs when calling <tt>bcm_mpls_port_add</tt>() with valid egress label but with <tt>BCM_MPLS_PORT_REPLACE</tt>. It doesn't return fail.
<tt>bcm_mpls_port_add</tt>() returns <tt>BCM_E_UNAVAIL</tt> if the parameters include a valid egress label but with <tt>BCM_MPLS_PORT_REPLACE</tt>.
</td></tr><tr><td> SDK-54688 
 </td><td></td><td> 56846_A0
56845_B0
56845_A2
56844_A0
56850_A0
56855_A0
56843_B0
56854_B0
56854_A0
56850_A1
 </td><td> Issue :- A) Mirror resources(Entries configured in <tt>im_mtp_index</tt>/ <tt>em_mtp_index</tt> using MirrorIngress/MirrorEgress fp actions) are not cleaned while deleting FP entry in case FP installation FAIL case.
               B) Only 3 FP mirror actions are allowed even though there are 4 mirror indexes available in <tt>im_mtp_index</tt>/<tt>ex_mtp_index</tt>.
Fix :-
------ 
              A) Added Support to clean up the Mirror Resources as well along with FP entry delete in case FP installation failure.   
              B) It is a hardware limitation where only 3 FP mirror actions are allowed.
</td></tr><tr><td> SDK-54689 
 </td><td></td><td> 88660_A0
 </td><td> Fix for 88660 egress multicast traffic getting stuck in high egress multicast bandwidth.
</td></tr><tr><td> SDK-54692 
 </td><td> 747803
 </td><td> 88650_A0
88650_B0
88660_A0
 </td><td> OAM: Deleting a MEP with Long MEG ID fails with assertion.
</td></tr><tr><td> SDK-54711 
 </td><td></td><td> 88650_B0
88660_A0
 </td><td> User-Header is a fabric header located between system-headers (FTMH, PPH) and start of packet (e.g., Ethernet).
The user-header size is set via <tt>field_class_id_size</tt> SOC property. User-Headers-0/1 can have a total sizes of 0, 8b, 16b, 24b or 32b. The value of 24 bits was not enabled. This is fixed.
</td></tr><tr><td> SDK-54715 
 </td><td> 722160
 </td><td> 88660_A0
 </td><td> In metering, color blind meters are used to do metering without referring to the color of the incoming packet.
<p>Currently when a meter is configured to be color blind, it will always drop incoming red packets by error,  instead of ignoring the color.
<p>This fix corrects this behavior.
</td></tr><tr><td> SDK-54722 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> In Field Processor, when creating or destroying TCAM entries, a time consuming debug code section was running.
This code section has been removed, resulting in significant decrease of TCAM entries creation and destroying running time.
</td></tr><tr><td> SDK-54725 
 </td><td></td><td> All
56850_A0
 </td><td> Support added in '<tt>bcm_l2_addr_delete_by_vlan_gport_multi</tt>' API to flush L2 entries based on virtual ports, deletes based on virtual port trunks are also supported.
</td></tr><tr><td> SDK-54726 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> The CCM and Loopback programs in the egress PRGE loaded LFEMs that were not used.
</td></tr><tr><td> SDK-54731 
 </td><td></td><td> 88650_A0
88660_A0
88670_A0
 </td><td> The error message macros in the soc layer were renamed as following:
<tt><tt>_SOCDNX_SAND_IF_ERR_EXIT</tt></tt>  --&gt; <tt>SOCDNX_SAND_IF_ERR_EXIT</tt>
<tt><tt>_SOCDNX_EXIT_WITH_ERR</tt></tt> --&gt; <tt>SOCDNX_EXIT_WITH_ERR</tt>
<p>In addition, a new macro was added:
<tt>SOCDNX_IF_ERR_EXIT_MSG</tt>
</td></tr><tr><td> SDK-54748 
 </td><td> 749898
 </td><td> 56450_B0
56440_A0
56450_A0
56440_B0
 </td><td> <tt>bcm_port_rate_egress_set</tt> API allowed user to configure only the recommended minimum burst value irrespective of the passed burst argument. The API implementation has been modified to compute the shaping parameters based on shaping rate and burst value and configure the hardware tables accordingly.
</td></tr><tr><td> SDK-54755 
 </td><td></td><td> 88650_A0
88660_A0
88650_B0
88650_B1
 </td><td> PON: SDK now supports also L3 subnet source-bind.
For more information see src/examples/dpp/pon/<tt>cint_pon_general_anti_spoofing</tt>.c
</td></tr><tr><td> SDK-54761 
 </td><td> 752348
 </td><td> All
 </td><td> Fixed potential endless loop during PCIe Deemphasis settings, by limiting the range to search for PCIe Capabilities registers to valid range.
</td></tr><tr><td> SDK-54763 
 </td><td> 751831
 </td><td> 56450_A0
 </td><td> Support has been added for following features for Katana2:
1. Advanced URPF lookup  where 2 lookups, both DIP and SIP, are performed using single <tt>L3_DEFIP</tt> entry at line rate.
2. Capability to add IPv6 LPM entries with subnet mask greater than 64 bits.
    By default 1K entries are reserved for Ipv6 LPM  entries with subnet mask &gt; 64 bits. The default behaviour can be overridden by setting config variable <tt>num_ipv6_lpm_128b_entries</tt>=0
</td></tr><tr><td> SDK-54775 
 </td><td> 750966
 </td><td> 88650_A0
88650ACP_A0
88650_B0
88650_B1
88660_A0
 </td><td> L2CP (Layer2 Control Protocol) traps were not updated correctly when calling multiple times <tt>bcm_l2_cache_set</tt>.
</td></tr><tr><td> SDK-54776 
 </td><td> 751147
 </td><td> 88660_A0
 </td><td> The OAM and BFD applications are using TCAM HW to identify some OAM packets on transit tunnels, what causes them to be trapped.
A SW bug was allowing using a prefix for this key, and multiple Databases were created (for specific forwarding-types).
<p>The fixes are:
1. when OAM is enabled, all the packets performs a look-up into this Database at the forwarding stage (i.e. for any forwarding type).
2. since the HW key length for this TCAM Database, there is no place for prefix and this Database is using exclusively now the TCAM banks 12 and 13. 
3. the different Databases were unified to a single Database, since forwarding-type is part of the key.
</td></tr><tr><td> SDK-54779 
 </td><td> 748470
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In the previous release, the feature of cosq warmboot in TRIDENT2 was not supported. In this release, this issue has been addressed by syncing the left members of <tt>_bcm_td2_mmu_info</tt>[unit].
</td></tr><tr><td> SDK-54792 
 </td><td></td><td> 56640_B0
 </td><td> On TR3, if EGR_ING_PORTm register is not configured, L3 traffic received on EHG port seen as source mac and destination mac zero on cpu port. Added configuration for <tt>EGR_ING_PORT</tt>.
</td></tr><tr><td> SDK-54802 
 </td><td> 738723
 </td><td> 88750_A0
 </td><td> In polling mode, the hardware IRQ mask is always zero. This is TRUE for all devices.
Implementation fixed to achieve this.
</td></tr><tr><td> SDK-54810 
 </td><td> 752795
 </td><td> 56450_A0
 </td><td> Support added for BCM56450 (Katana2) to match 3 MPLS labels in UDF.
</td></tr><tr><td> SDK-54819 SDK-53920
 </td><td> 752509
 </td><td> 56450_A0
56440_B0
 </td><td> During port shutdown traffic buffered in the queues for the port was not flushed.
<p>Implemented queue flush during port shutdown .
Implemented the thresholds reset  and replay for the flush activity to be completed during congestion scenarios.
</td></tr><tr><td> SDK-54840 
 </td><td> 753240
 </td><td> 88660_A0
 </td><td> Broad Sync API: implemented ToD get function (<tt>bcm_time_capture_get</tt>).
</td></tr><tr><td> SDK-54845 
 </td><td> 753234
 </td><td> 88650_A0
 </td><td> fixed C++ compilation error: added missing "#include &lt;soc/dpp/SAND/Utils/<tt>sand_footer</tt>.h&gt;" at the end of <tt>arad_debug</tt>.h.
</td></tr><tr><td> SDK-54846 
 </td><td> 752653
 </td><td> 88650_A0
88660_A0
 </td><td> Enabled setting the he Packet-TC to Queue-TC mapping for ISQs using <tt>bcm_cosq_port_mapping_set</tt>().
</td></tr><tr><td> SDK-54848 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> CINT: New example for IPv4 routing over 802.1q where the VSI/RIF is explicitly supplied by the user
and not determined by the incoming VLAN value. 
This allows VSI routing interface that straddles several LANs.
The example uses In-LIF (per In-Port x VLAN) and Out-LIF (per VSI x Out-Port) to achieve that. 
Reference: <tt>cint_ip_route_explicit_rif</tt>.c. In the CINT example a routing scheme with two different Routing Interfaces(RIF) that are based on &lt;Port, VLAN&gt; added.
</td></tr><tr><td> SDK-54849 
 </td><td></td><td> 88650_A0
 </td><td> IMPORTANT: Injection of TM packet with user define header is not supported on systems which have OAM yet (SDK-57826).
<p>Background: user headers are optional internal system headers located after the FTMH and PPH headers (extensions included). The User header can be used for different purposes:
- Cascaded ingress egress ACLs, to transmit data from Ingress FP to egress FP
- Various work-arounds
The user header size is configured via field_class_id_size_X SOC property.
<p>Issue: when injecting TM packets with additional headers after ITMH (e.g. PPH or OAM-TS) and if the user headers are used, the user must include the user headers in the packet after the additional headers and before the payload (e.g. before the Ethernet header). Set this mode via the SOC property <tt>custom_feature_injection_with_user_header_enable</tt>. 
In this mode, the user header is not added: injected TM packets must be injected with a User-Header with the same size as the configured user-header size (field_class_id_size_X). If the destination port of the TM packets are Ethernet port, the user also must set the <tt>custom_feature_user_header_always_remove</tt> SOC property.
</td></tr><tr><td> SDK-54865 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> issues in snoop APIs:
<tt>bcm_rx_snoop_get</tt>() now returns the same size and probability as the values entered by <tt>bcm_rx_snoop_set</tt>().
</td></tr><tr><td> SDK-54869 
 </td><td></td><td> 88660_A0
 </td><td> BFD non-accelerated mep is restored incorrectly after WB.
</td></tr><tr><td> SDK-54870 
 </td><td></td><td> 88660_A0
 </td><td> In Field Processor range APIs, internal commands were added to skip Warm-boot on these APIs during Warm-boot validation.
</td></tr><tr><td> SDK-54877 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Diag improvement: IPv4 multicast routing table can be displayed from diagnostic shell Diag pp IPv4_MC.
</td></tr><tr><td> SDK-54880 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Diag improvement: The allocation manager section now displays general information regarding all pools. In addition, support was added to the detailed information options of the IVE/EVE pools.
The "hw" option was renamed to "direct".
</td></tr><tr><td> SDK-54903 
 </td><td> 751870
 </td><td> 88660_A0
 </td><td> OAM: in arad plus, packet below the lowest MEP level was not trapped with trap code <tt>error_level</tt> as it should be but was forwarded.
</td></tr><tr><td> SDK-54906 
 </td><td> 749980
 </td><td> 54240_C0
54280_A0
54282_A0
54285_C0
54290_A0
54292_A0
54295_A0
 </td><td> WarmBoot support for BCM54240/5428x/5429x has been added.
</td></tr><tr><td> SDK-54907 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Warmboot: The TPID profile stores up to two expected TPIDs for each port. Each profile can be used by multiple ports and should be discarded when no port is using it.
Performing Warmboot has doubled the correct number of ports that are attached to each Port Profile. Thus, preventing proper discard of the TPID Profile when no ports are attached to it and eventually causing an init error that may happen after 256 Warmboots.
The WB for Port TPID profile now functions correctly.
</td></tr><tr><td> SDK-54921 
 </td><td></td><td> 88650_B1
 </td><td> In Egress Field Processor, when configuring bcmFieldActionStat action, a validation is performed on the data field value. The validation is incorrect, and in case the value is out of range, it will not be identified. This is fixed.
</td></tr><tr><td> SDK-54923 
 </td><td> 752947
 </td><td> 88650_B0
88650_B1
 </td><td> For stacking systems, the KeepAlive application allows the CPU to retrieve the stacking link topology by sending unicast packets from CPU to CPU.
The implementation is performing a specific process in the second stacking device when the FTMH.Stacking-Route-History.MSB is set. However, this process should be done only for Unicast packets.
This is fixed
</td></tr><tr><td> SDK-54927 
 </td><td> 752923
 </td><td> 56450_B0
56450_A0
 </td><td> In previous releases <tt>bcm_cosq_gport_delete</tt> API could return <tt>BCM_E_TIMEOUT</tt> during congestion scenarios. This issue has been fixed in API implementation by adjusting bandwidth and flush the packets completely.
</td></tr><tr><td> SDK-54931 
 </td><td></td><td> 56854_B0
 </td><td>If there was an error in the internal functions of the ecmp create routines. the software state was not cleared.
<p>Made changes to clean the s/w state in case there is some error in internal routines or h/w writes of ecmp creation.
</td></tr><tr><td> SDK-54937 
 </td><td> 752666
 </td><td> 88650_A0
88660_A0
 </td><td> gport shell command shows incorrect voq id (-1) for ingress shaping queues. Fixed.
</td></tr><tr><td> SDK-54939 
 </td><td></td><td> 88650_A0
 </td><td> In L2 Control Protocol traps, the attributes of the programmable traps and of the Reserved-Multicast traps are saved in the <tt>_rx_virtual_traps</tt> variable between the RX-trap API definition and the L2-cache setting. This variable was not restored correctly after warmboot because the struct was not saved to external storage.
Fixed. 
ISSU: if upgrading from an earlier version, this data is not restored.
</td></tr><tr><td> SDK-54945 
 </td><td></td><td> 56340_A0
56344_A0
 </td><td> Big Endian mode has been added to the SDK when using Helix4 with iProc and latest LDK release
To build SDK in Big Endian mode, type "make <tt>ENDIAN_MODE</tt>=BE".
</td></tr><tr><td> SDK-54947 
 </td><td> 752756
 </td><td> 56440_A0
 </td><td> SDK support for 1588 Transparent Clock is added as part of this JIRA.
</td></tr><tr><td> SDK-54971 
 </td><td></td><td> 88650_A0
 </td><td> In Field Processor, the cascaded value width is set via bcmFieldControlCascadedKeyWidth.
The bcmFieldQualifyCascadedKeyValue qualifier has a length equal to this value. 
However, the bcmFieldActionCascadedKeyValueSet action had always a constant length of 20 bits. This length is reduced to {4 + cascaded width}, where 4 bits are needed for HW encoding. 
This improvement can be disabled by setting <tt>custom_feature_increased_cascaded_action</tt> to 1.
</td></tr><tr><td> SDK-54980 
 </td><td> 753002
 </td><td> 88650_A0
88660_A0
 </td><td> 6.3.4 introduced a new feature called IGMP and Compatible-MC after existing tunnel (VXLAN, L2GRE, VPLS) in ARAD+.
See <tt>cint_igmp_example</tt>.c for application explanation and valid packet flows.
<p>In HW it required to enable Second-stage-parsing in order to make the feature work. Second-stage-parsing should be enabled only for MPLS TT programs.
By mistake we enabled Second-stage-parsing to MPLS, IPV6 and Trill while the correct configuration should enable it to MPLS only.
The issue cause Packet-format-code to be Ethernet instead of IPV6 (or Trill).
</td></tr><tr><td> SDK-54982 
 </td><td></td><td> 88650_B0
88650_B1
88660_A0
 </td><td> At egress, a new feature allows to maintain the User Defined Headers (UDH) before the packet exits the device, by defining <tt>UDH_ETH</tt> property. As a result, UDH is stamped pre-pending the packet headers.
<p>Enable this port by configuring the following SOC properties:
1. Update the port header type SOC property definition to <tt>UDH_ETH</tt> for this port:
       - <tt>tm_port_header_type_out_</tt>[port#].BCM88650=<tt>UDH_ETH</tt>
2. Update the User Header sizes according to the field_class_id_size_X SOC property - see its documentation for the acceptable values.
</td></tr><tr><td> SDK-54984 
 </td><td></td><td> 88650_A0
 </td><td> Fix an error when setting egress port bandwidth (<tt>bcm_cosq_gport_bandwidth_set</tt>, using <tt>GPORT_LOCAL</tt>) to low rate relative to other ports.
</td></tr><tr><td> SDK-54992 
 </td><td> 753214
 </td><td> 56840_A0
 </td><td> Updated Tx packet padding logic in Linux KNET module to properly handle RCPU encapsulation. The previous code could cause Tx data corruption if the padding required reallocation of socket buffer.
</td></tr><tr><td> SDK-55003 
 </td><td></td><td> 88650_A0
 </td><td> In Rx thread, more internal fields (from FTMH, PPH and their extension headers) are parsed into <tt>bcm_pkt_t</tt>.
A complete description of the parsed fields will be added to the TM User Manual.
The parsing is done for ports of type CPU and STACKING.
</td></tr><tr><td> SDK-55007 
 </td><td> 752699
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> Port: <tt>ilkn_interface_status_oob_ignore</tt> can be used to force ILKN interface status indication.
If ILKN interface status indication is forced up after the ILKN OOB interface is enabled, a low number of error message will be sent from ILKN interface. 
After the fix, ILKN lane and interface status indication will be forced up before the ILKN OOB interface is enabled. 
</td></tr><tr><td> SDK-55023 
 </td><td> 734742
 </td><td> 88650_A0
 </td><td> A new corrective action added at this interrupt handler which checking if the interrupt is cleared every 10ms.
The mechanism stops only if the interrupt clear or period of 500ms passed.
moreover we are suggesting to use <tt>force_unmask</tt> option for this interrupt in order to force unmasking  the interrupt at the end of interrupt handler.
The following is driver reference for this action:
                uint32* flags;
                int inter = /*interrupt number*/;
<p>                rc = <tt>soc_interrupt_flags_get</tt>(unit, inter, &amp;flags);
                <tt>BCMDNX_IF_ERR_EXIT</tt>(rc);
<p>                if (value == 0) {
                    <tt>SHR_BITCLR</tt>(&amp;flags, <tt>SOC_INTERRUPT_DB_FLAGS_FORCE_UNMASK</tt>);
                } else {
                    <tt>SHR_BITSET</tt>(&amp;flags, <tt>SOC_INTERRUPT_DB_FLAGS_FORCE_UNMASK</tt>);
                }
<p>                rc = <tt>soc_interrupt_flags_set</tt>(unit, inter, flags);
                <tt>BCMDNX_IF_ERR_EXIT</tt>(rc);
</td></tr><tr><td> SDK-55026 
 </td><td></td><td> 88650_A0
 </td><td> XGS MAC extender port support 1G extension capabilities when ARAD/ARAD+ is connected to XGS devices to extend 1G capabilities in chassis.
<p>Several Ethernet Inport properties weren't configured right for XGS MAC extender port for example: custom macros for Trill header parsing were not set. Fixed.
</td></tr><tr><td> SDK-55036 
 </td><td></td><td> 56850_A2
 </td><td> <tt>ENQ_ASF_HS_OVERSUB_EN</tt> is enabled during init for all the ports in TD2 [ SDK-54205 ] hence the <tt>ASF_ENABLE_HS_PORT_EP_CREDIT_CHK</tt> also should be set to 0 on init.
</td></tr><tr><td> SDK-55067 
 </td><td></td><td> 88750_A0
88650_A0
88750_B0
88650_B0
88650_B1
88660_A0
 </td><td> Added a mechanism to control logging and console messages formats.
Please look at file src/appl/diag/bsldnx.c, function <tt>bsldnx_cons_init</tt>().
</td></tr><tr><td> SDK-55071 
 </td><td></td><td> 56850_A0
 </td><td> Implemented new data formats (macros) to match on the incoming packets with or without VNTAG/CNTAG/ETAG/ICNM packets. For example: setting <tt>BCM_FIELD_DATA_FORMAT_F_VNTAG</tt> flag, an entry is created in <tt>UDF_TCAM</tt> to validate on the incoming packets tagged with VNTAG. Likewise, setting <tt>BCM_FIELD_DATA_FORMAT_F_NO_VNTAG</tt> flag, an entry is created in <tt>UDF_TCAM</tt> to validate on the incoming packets without VNTAG.
</td></tr><tr><td> SDK-55081 
 </td><td></td><td> 56640_A0
56540_A0
56640_A1
56640_B0
56540_B0
 </td><td> Before the code change <tt>bcm_tr2_cosq_gport_get</tt> function is returning only <tt>BCM_COSQ_GPORT_UCAST_QUEUE_GROUP</tt> ,
now code is added so that it returns flags as per the type
<tt>BCM_COSQ_GPORT_VLAN_UCAST_QUEUE_GROUP</tt>(for vlan gport)
<tt>BCM_COSQ_GPORT_DESTMOD_UCAST_QUEUE_GROUP</tt>(for dmvoq gport)
<tt>BCM_COSQ_GPORT_MCAST_QUEUE_GROUP</tt>(for multicast gport port)
</td></tr><tr><td> SDK-55083 
 </td><td> 753905
 </td><td> 56340_A0
56340M_A0
 </td><td> ISM total calculation was simplified. Previously total was incremented initially and from then, every time when the number of entries were bumped up. Now the increment will be done only when we allocate the memory from a bank to a table.
</td></tr><tr><td> SDK-55084 
 </td><td> 753827
 </td><td> 88650_A0
88660_A0
 </td><td> Trap PWE TTL=0/1 is now supported:
1) bcmRxTrapMplsTtl0, bcmRxTrapMplsTtl1 traps are now supported.
2) To set trapping PWE packets with TTL&lt;=1 use <tt>bcm_mpls_port_t</tt>.<tt>vccv_type</tt>=bcmMplsPortControlChannelTtl. 
Example can be found in <tt>cint_vswitch_vpls</tt>.c
</td></tr><tr><td> SDK-55095 
 </td><td></td><td> 88660_A0
 </td><td> Trill Warmboot: Upon warmboot, Trill init called to HW access as it shouldn't be.
</td></tr><tr><td> SDK-55101 
 </td><td></td><td> 88650_B0
88660_A0
 </td><td> Required changes in SDK in order to support KBP-SDK 1.2.1 and higher.
The changes include configuration of newly used instructions and their transport layer implementation.
</td></tr><tr><td> SDK-55102 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> During initialization, the SOC property configuring the OTMH Destination extension has an uninitialized value, instead of being disabled by default. Fixed.
</td></tr><tr><td> SDK-55107 
 </td><td></td><td> 88650_A0
 </td><td> Trill warmboot: Upon warmboot, trill sw states were not restored.
</td></tr><tr><td> SDK-55109 
 </td><td></td><td> 88660_A0
 </td><td> ROP transcations failed when using LE CPU.
Fix ROP access endianess.
</td></tr><tr><td> SDK-55132 
 </td><td> 752736
 </td><td> All
56850_A0
56850_A1
56850_A2
 </td><td> Software state and Ref-counts were not maintained across warmboot. Therefore After warmboot, <tt>soc_profile_mem_get</tt> api would not be able to retrieve the <tt>l3_iif_profile</tt> entry as the software states/ref-count are reset and not recovered.
<p>Added support to recover the <tt>l3_iif_profile</tt> state during level-2 warmboot. The bitmap for valid <tt>L3_IIF</tt> entries are stored in scache.  After warmboot, The <tt>l3_iif</tt> entries are read from scache and ref-counts are set for L3_iif_profiles indexes.
</td></tr><tr><td> SDK-55143 
 </td><td></td><td> 88650_B0
88660_A0
 </td><td> Required changes in SDK in order to support KBP-SDK 1.2.1 for external TCAM are introduced.
</td></tr><tr><td> SDK-55161 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> IMPORTANT - API SIGNATURE CHANGE:
For better coherency, the Multicast-ID parameter was changed in the <tt>bcm_l2_addr_t</tt> structure: the   <tt>l2mc_index</tt> variable was changed to <tt>l2mc_group</tt>.
If used, the user must adapt its calling sequence accordingly.
</td></tr><tr><td> SDK-55162 
 </td><td></td><td> 88660_A0
88670_A0
 </td><td> IP Routing-Over-Overlay (ROO) refers to a set of protocols/applications where the L2 forwarding to the Host/Next-Hop router is not accomplished by simple 802.1q bridging, but by L2-Overlay protocols (VXLAN, etc).
BCM8866X supports ROO Host Unicast over VXLAN.
See <tt>cint_vxlan_roo</tt>.c for cint example and Programmer's Reference Guide for more details. 
</td></tr><tr><td> SDK-55167 
 </td><td> 755011
 </td><td> 56455_A0
56640_A0
56850_A0
56640_A1
56640_B0
56850_A1
56850_A2
 </td><td> Problem:
PacketRes enumerations getting remapped internally causing data ,mask mismatch during qualifier installation.
<p>Solution:
Updated code to qualify packet Resolution in below 2 ways:
 1) print bcm_field_qualify_PacketRes(0,0,<tt>BCM_FIELD_PKT_RES_L3UCKNOWN</tt>, <tt>BCM_FIELD_PKT_RES_L3UCKNOWN</tt>);
 2) print bcm_field_qualify_PacketRes(0,0,<tt>BCM_FIELD_PKT_RES_L3UCKNOWN</tt>, <tt>BCM_FIELD_EXACT_MATCH_MASK</tt>);
<p>This is also documented as valid set of mask values
</td></tr><tr><td> SDK-55175 
 </td><td> 749262
 </td><td> 88660_A0
 </td><td> Extracting a BCM88660 that is configured to VSC128 cell format mode, caused performance degradation in the system. Fixed.
</td></tr><tr><td> SDK-55184 
 </td><td></td><td> 56850_A0
 </td><td> Earlier SDK releases did not allow configuring MTU value for vxlan access ports. This release now supports setting/resetting MTU for vxlan access ports through <tt>bcm_vxlan_port_add</tt>() API.
</td></tr><tr><td> SDK-55205 
 </td><td> 751154
 </td><td> 56850_A0
 </td><td> ENABLE_1588MPLSf flag is used to enable/disable encapsulation and decapsualtion for PTP packets over MPLS. Memory validation check is added to avoid crash while accessing memory for chips that donot have this flag. TD2 does not have this feature.
</td></tr><tr><td> SDK-55222 
 </td><td></td><td> 88660_A0
88670_A0
 </td><td> MPLS: When adding MPLS termination label using api <tt>bcm_mpls_tunnel_switch_add</tt>, action <tt>BCM_MPLS_SWITCH_ACTION_POP</tt>, next protocol after MPLS label will be calculated from next header first nibble and not from the Lif table.
Flags <tt>BCM_MPLS_SWITCH_NEXT_HEADER_L2</tt>, <tt>BCM_MPLS_SWITCH_NEXT_HEADER_IPV4</tt>, <tt>BCM_MPLS_SWITCH_NEXT_HEADER_IPV6</tt> are not supported.
</td></tr><tr><td> SDK-55225 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> BFD creation of accelerated endpoints with remote destination is fixed and now working without configuring any OAMP instances. Irrelevant validation checks were removed as well.
Restrictions on <tt>endpoint_id</tt> and <tt>local_discr</tt> fields:
1. In case endpoint is accelerated to the OAMP, endpoint id should be equal to lowest 16 bits of <tt>local_discr</tt>.
2. In case endpoint is accelerated to the OAMP or endpoint type is bcmBFDTunnelTypeUdp, BFD <tt>local_discr</tt> msbs (bit number 16 and above) should be constant for all endpoints.
3. Non-accelerated endpoint cannot be created <tt>WITH_ID</tt>.
<p>Also fixed error in creating oam/bfd endpoint with id 4096.
</td></tr><tr><td> SDK-55229 
 </td><td></td><td> 88650_B0
88660_A0
 </td><td> When using external TCAM, usage of the diagnostics command "kbp print" may have caused a segmentation fault.
This happened due to inappropriate use of unallocated memory and is now fixed.
</td></tr><tr><td> SDK-55243 
 </td><td></td><td> All
 </td><td> Improved execution time of <tt>bcm_l3_intf_create</tt>() in XGS devices. In addition, removed deadlock with VLAN APIs such as <tt>bcm_vlan_control_vlan_set</tt>().
</td></tr><tr><td> SDK-55263 
 </td><td> 739431
 </td><td> 56540_A0
56440_A0
56450_A0
 </td><td> Fix for PTP operation using little-endian host.
</td></tr><tr><td> SDK-55274 
 </td><td> 756256
 </td><td> 56850_A0
56855_A0
56854_B0
56854_A0
56850_A1
56851P_A1
56851_A1
56850_A2
56851_A2
56851P_A2
56854_A2
56853_A2
56852_A2
56855_A2
56851_A0
56852_A0
56852_A1
56853_A0
56853_A1
 </td><td> Problem:
Src/Dst IP6 qualifier was sent to 32 bit EFP qualifier routine [<tt>_field_efp_qualify32</tt>] for TD2 devices which was internally causing the mask to be reset to 0. [since offset width calculation is assuming width to be 32 but actual width is 128].
Since its a 32 bit routine, the last 32 bit part of mask was getting reset here. 
<p>Solution:
Added appropriate checks to make sure that only 32 bit IP address falls into the check and hence mask will not get reset.
</td></tr><tr><td> SDK-55280 
 </td><td> 750005
 </td><td> 56440_A0
 </td><td> Support has been added for proper reload of <tt>MAC_BLOCK</tt> table during warmboot for BCM5644x devices.
</td></tr><tr><td> SDK-55283 
 </td><td> 756559
 </td><td> All
 </td><td> Removed StrataXGS restriction from <tt>bcm_tx_array</tt> documentation that all packets should have same values for Source module, Source port, PFM and Internal Priority as it does not exist now.
</td></tr><tr><td> SDK-55286 
 </td><td> 755758
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> When L2X table parity error was detected and processed in Y-pipe context, the <tt>acc_type</tt> list for Y-pipe would be iterated to decode memory id via routine <tt>soc_addr_to_mem_extended</tt>(). The <tt>acc_type</tt> of L2X table is 4, not in the list for Y-pipe, and this would cause memory decode fail. So the <tt>acc_type</tt> 4 has been added into the list for Y-pipe to fix this issue.
</td></tr><tr><td> SDK-55288 
 </td><td></td><td> 88660_A0
 </td><td> Trill Multi-homing connectivity. Define up to 3 virtual rbridges in system was not correctly supported and leads to memory leak.
</td></tr><tr><td> SDK-55293 
 </td><td> 739558
 </td><td> 88650_B1
 </td><td> In L2 forwarding, when MAC learning mode was centralized, the aging time accuracy has been improved: the aging time is maximal whether the entry has been inserted by this device or not.
A SOC property (<tt>custom_feature_centralized_owned</tt>) allows the user to work in previous mode.
</td></tr><tr><td> SDK-55296 
 </td><td></td><td> 88660_A0
 </td><td> OAM: When replacing entries in the in the O-EM 1/2 tables, instead of deleting the entries and then inserting, it is possible to replace the entries in one fell swoop. Previous configuration might have caused packet loss in the time between the deletion and creation of new entry.
Likewise oem1/2_entry_delete() did not wait for the task to complete before returning. This bug was fixed as well.
</td></tr><tr><td> SDK-55298 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> When using lag over a stacking system with <tt>number_of_trunks</tt>=[512/256/128/64] packets might be dropped.
When a FAP resolves a LAG destination, it passes the packet to the next stacking FAP with the LAG id and part (8bit) of the lb-key. Since only a part of the lb-key passes, the next FAP may conclude a different destination for the packet. As a result, the packet can be sent back to a FAP that already passed this packet, resulting in dropping the packet.
<p>This fix makes the FAP pass the packet to the next stacking FAP with the Destination System Port (DSP) (instead of the lag id), so that next FAP(s) will forward the packet according to the DSP and will not need to recalculate the destination.
No change in default behavior, the feature is disabled by default.
In order to enable this fix on 6.3.7, the following SOC property configuration is needed:
<tt>custom_feature_stamp_uc_destination</tt>.BCM88650=1
</td></tr><tr><td> SDK-55299 
 </td><td></td><td> 88660_A0
 </td><td> OAM diagnostics: Lookups are displayed in parsed format (key and result, if found).
The relevant command is 
diag oam lu
and the output is for example:
IHB OEMA last lookup: Key=0X2002, result=0X60000080
        OEMA key: ingress: 0, OAM LIF: 0x1001
        OEMA payload: MP profile: 0x3, MEP bitmap: 0x0, MIP bitmap: 0x80, counter index: 0x0
IHB OEMB last lookup: Key=0X1001e  , result=0X0
        OEMA key: ingress: 0, MDL: 7, OAM LIF: 0x1001, your disc: 0
        Not found.
</td></tr><tr><td> SDK-55305 
 </td><td></td><td> 88660_A0
88670_A0
 </td><td> The masks for Vlan gport id and MPLS gport id has been extended from 24 bits to 26 bits.
</td></tr><tr><td> SDK-55317 SDK-55378
 </td><td></td><td> 56340_A0
 </td><td> On Helix_4, Bank 0 in every stage is disabled in ISM. This is taken care of while allocating banks for ISM tables, but while configuring the <tt>hash_offset</tt> for each bank, the disabled bank was not taken into account. Now the number of disabled banks are calculated and is added to the bank number in each stage.
</td></tr><tr><td> SDK-55323 
 </td><td> 755643
 </td><td> 56850_A0
 </td><td> For Trident_2, when station tcam entries were being recovered during warmboot, they were not being checked for validity. Even blank entries were being counted as valid entries and so, after recovery, the table showed up as full. So, when a new entry was added after warmboot, it returned no resources.
This  validity check is now added for Trident2
</td></tr><tr><td> SDK-55329 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> APIs receiving a <tt>bcm_gport_t</tt> input argument as a destination, will now work properly when the gport type is MODPORT, and the given module port is not defined in the local device.
</td></tr><tr><td> SDK-55332 
 </td><td> 753717
 </td><td> 88650_A0
88650ACP_A0
88650_B0
88650_B1
88660_A0
 </td><td> In Ingress Field Processor, the qualifiers bcmFieldQualifyInnerSrcMac and bcmFieldQualifyInnerDstMac can be taken from second or third header in stack (first or second after Ethernet header). In order to indicate which header to consider, one of the qualifiers bcmFieldQualifyIp4, bcmFieldQualifyIp6, bcmFieldQualifyMpls can be used in QSET. If one of these qualifiers exists, then the inner mac will be taken from the third header, otherwise from the second.
</td></tr><tr><td> SDK-55335 
 </td><td> 708385
 </td><td> 88650_B0
 </td><td> fixed the prbs issue going out the analog part for 8b/10b encoding speed.
</td></tr><tr><td> SDK-55339 
 </td><td></td><td> 88650_A0
 </td><td> Slow start mechanism for FMQs (using bcmCosqGportTypeGlobalFmqGuaranteed control) is not functional.
Fixed.
</td></tr><tr><td> SDK-55344 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> BFD: fields that are only used by endpoints accelerated to the OAMP are configured only for relevant endpoints. Likewise in <tt>endpoint_destroy</tt>().
</td></tr><tr><td> SDK-55345 
 </td><td></td><td> 88660_A0
 </td><td> OAM: RDI indication on outgoing packets from the OAMP might be inconsistent.
</td></tr><tr><td> SDK-55346 
 </td><td></td><td> 88650_A0
88660_A0
88650_B0
 </td><td> OAM: In Arad, all MEG levels 0-7 may be used. In Arad+, level 0 is unavailable by default, however this may be used if the classifier is used in Arad mode - if the soc property "<tt>oam_classifier_advanced_mode</tt>" is set to 0.
</td></tr><tr><td> SDK-55347 
 </td><td></td><td> 88650_B1
 </td><td> OAM: For trapped DM packets (both up and down, NTP or 1588), the packet will be prepended with the 4 MSBs of the time (the 4 LSBs appear in the OAM-TS). In other words, the packet format will be FTMH+OAM-TS+PPH+4 time MSBs+packet.
To use the old format where there is only the 34 bits in the TS unset soc property "<tt>custom_feature_oam_dm_tod_msb_add_enable</tt>=0" (1 by default).
</td></tr><tr><td> SDK-55350 
 </td><td></td><td> 88660_A0
 </td><td> Adjusted <tt>cint_system_vswitch_vpls</tt>.c to fit PWE/LSP pipe mode.
</td></tr><tr><td> SDK-55352 
 </td><td> 756202
 </td><td> All
 </td><td> In the previous release there was a coding issue with the usage of sizeof operator.The object used to calculate the sizeof operation in a function was passed as a value instead of passing it by reference. Hence sizeof operator was returning a wrong value. This issue has now been addressed in this release.
</td></tr><tr><td> SDK-55353 
 </td><td> 757018
 </td><td> 88640_A0
 </td><td> Bug in counter processor calculation of counter ids from counter set ids was fixed.
</td></tr><tr><td> SDK-55359 
 </td><td> 756745
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
88670_A0
 </td><td> Changed Init sequence prints.
</td></tr><tr><td> SDK-55360 
 </td><td> 757697
 </td><td> All
 </td><td> In the previous release, on TD2, the double bit ECC error notifications from the EP following init cycles were seen on rare occasion.
In this release, this issue has been addressed by initializing all of packet buffers to the value of zero. 
</td></tr><tr><td> SDK-55361 
 </td><td> 749578
 </td><td> All
56850_A0
56850_A1
56850_A2
 </td><td> There are three commands have been added.
 l3 <tt>nat_ingress</tt> show
 l3 <tt>nat_egress</tt> add 
 l3 <tt>nat_egress</tt> show
These commands enhancements to the BCM diag shell to both program and show NAT status.
</td></tr><tr><td> SDK-55362 
 </td><td> 757471
 </td><td> 88030_A0
 </td><td> The code to set and check individual bit fields of the PPE variable is now automatically generated by the tools.
</td></tr><tr><td> SDK-55375 
 </td><td> 755943
 </td><td> 56850_A0
 </td><td> Problem : Below qualifier was not getting recovered and actions were getting recovered as colour specific.
Action Parameters were not getting recovered for CopyToCpu and EcnNew
<p>Qualifier:
DstClassL3
Actions:
CopyToCpu,,EcnNew,DropCancel,PrioIntNew,EgressMask,Drop,EgressPortsAdd,SwitchToCpuCancel 
<p>Solution:
Actions mentioned in the list are expected to work this way since action internally sets colour specific actions. Hence after recovery we read from hardware or cache and display individual actions because we cannot confirm if actual action led to these or they were individually configured.
Quoting the part in warmboot section in api document where information regarding the above mentioned actions and its behavior is mentioned. 
"There are some color-dependent actions that may get aliased during Warm boot recovery. For example, the SDK cannot distinguish whether the application added bcmFieldActionDrop or specifically added bcmFieldActionGpDrop, bcmFieldActionYpDrop and bcmFieldActionRpDrop. This is true for all recovery levels." 
<p>For CopyToCpu, we are passing param0=1 and param1=0,
 param0=1 -&gt; means that we are matching the <tt>rule_id</tt>
 param1=x -&gt; x is the <tt>rule_id</tt> value that we are planning to match.
 This code will internally check if param0=1 . If so sets a field <tt>MATCHING_RULE</tt> as param1 in <tt>FP_POLICY_TABLE</tt>. Now while recovering we check if <tt>MATCHING_RULE</tt> !=0 and then recover param1 as <tt>rule_id</tt> and param0 as 1. 
Due to this logic, if param0=1 and param1=0, we set <tt>MATCHING_RULE</tt> as 0.
When we recover we dont know if this is due to <tt>rule_id</tt>=0 or no <tt>rule_id</tt> configured, because default value for <tt>MATCHING_RULE</tt> = 0. [ we dont have any hardware fields to save param0 to check if <tt>rule_id</tt> is to be matched or not]
This rules out possibility of configuring param1 as 0 with param0=1 if warmboot recovery required. U can configure param1 as 1-127 with param0=1.
<p>Code for recovery of parameter of EcnNew Action and for recovery of DstClassL3 qualifier, has been done through this JIRA. EcnNew has a new Field for Triumph3 and Trident2 to keep the value [G_NEW_ECNf] which was missed to be recovered. DestClassL3 was not getting recovered due to double wide mode slice number being passed wrongly. These two problems are handled.
</td></tr><tr><td> SDK-55387 
 </td><td> 752326
 </td><td> 88650_A0
 </td><td> Configuring a discrete WFQ weight for a CL (using bcmCosqControlDiscreteWeightLevel0..3 controls) with the same weight already assigned by another element failed.
Fixed.
</td></tr><tr><td> SDK-55388 
 </td><td> 756617
 </td><td> 88750_A0
88650_A0
88750_B0
 </td><td> The port enable indication might be wrong after warm boot sequence.
As a result RX LOS application will not get reliable state of the port an might try to reset the port.
Fixed.
</td></tr><tr><td> SDK-55392 
 </td><td></td><td> 88650_A0
 </td><td> In internal SOC functions related egress port header type setting, beautify the code by introducing #defines instead of hard numbers.
</td></tr><tr><td> SDK-55396 
 </td><td> 757120
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> For TD2 <tt>L3_ENTRY</tt> table, the case that parity error located in dedicated L3 banks was missed when UFT shared banks are used. Entry index checking for TD2 <tt>L3_ENTRY</tt> table when retrieving SRAM info via routine <tt>_soc_trident2_mem_sram_info_get</tt>() has been added for entry indexes in dedicated L3 banks.
</td></tr><tr><td> SDK-55415 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> "g *" command will display MAC regs only once for channelized ports.
</td></tr><tr><td> SDK-55426 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Setting OCB threshold for ingress queues is done with a voq handle,
Use this macro to create the relevant gport handle: <tt>BCM_GPORT_UNICAST_QUEUE_GROUP_SET</tt>.
It used to be the case where setting OCB threshold for ingress queues used a voq-connector handle; this is no longer a valid calling sequence.
</td></tr><tr><td> SDK-55434 
 </td><td></td><td> 88660_A0
 </td><td> In Field processor, at ingress, the Compare operation performs a comparison between the two halves of key-D in second cycle. The comparison first performs a XOR between the two halves and then AND with a predefined mask. The XOR operation is not enabled and therefore the compare result is incorrect.
This was fixed.
</td></tr><tr><td> SDK-55443 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> PWE: <tt>bcm_mpls_tunnel_initiator_create</tt> api can be used to update PWE next tunnel used in encapsulation of multicast PWE packets (unicast packets won't be effected).
This functionality is available only when PWE is not protected and MPLS tunnel is used by a FEC entry.
Example can be found in <tt>cint_vswitch_vpls</tt>.c <tt>switch_pwe_tunnel</tt> function.
</td></tr><tr><td> SDK-55456 
 </td><td></td><td> 56850_A0
56850_A1
56830_A1
56850_A2
56830_A0
56830_A2
 </td><td> In the previous release, flexible counter thread could occasionally report a huge counter statistic when the two hardware counters belonging to two ports which locate at different pipelines rolled over at the same time. In this release, this issue has been addressed by handling rollover for individual pipelines.
</td></tr><tr><td> SDK-55460 
 </td><td></td><td> 56850_A2
 </td><td> The access type of <tt>ING_NEXT_HOP</tt> table is defined as 1 per regfile <tt>bcm56850_a0</tt>. This access type was missed in TD2 Y-pipe list in SER correction routine.
The access type 1 has been added into TD2 Y-pipe list in SER correction routine to resolve this problem. 
</td></tr><tr><td> SDK-55464 
 </td><td></td><td> 88650_A0
88650_B1
88660_A0
 </td><td> diag nif shell command speed improvement, PHY rate is measured once for each interface,
instead of measuring PHY rate for all interface channels.
no modifications required in customer applications.
</td></tr><tr><td> SDK-55470 
 </td><td> 758460
 </td><td> 88650_A0
 </td><td> An updating logic happens when creating VLAN port with <tt>BCM_VLAN_PORT_REPLACE</tt> and <tt>BCM_VLAN_PORT_WITH_ID</tt>. If a new key to be added is different from the existed old key, the updating logic removes the old key and adds the new key.
An error occurred when the updating logic removed the old key of egress AC for CEP ports. The updating logic compared the new key with an uninitialized old key to check whether the new key is different with the old key.
The issue detailed above affected Out AC replacing of CEP ports. The correct egress AC key can be removed after the fix.
</td></tr><tr><td> SDK-55471 
 </td><td></td><td> All
 </td><td> === FOR THE CUSTOMER USING SDK-6.3.X
  Customer needs to follow below instructions to create new build target.
<p>  1. copy $SDK/systems/user/gto-2_6 $SDK/systems/user/custom-3_10
  2. modify 2 lines in $SDK/systems/user/custom-3_10/Makefile
      override <tt>kernel_version</tt>=3_10 
      platform=myboard-$ (<tt>kernel_version</tt>) 
  3. copy $SDK/make/Makefile.linux-gto-2_6 $SDK/make/Makefile.linux-custom-3_10 
     and modify <tt>CROSS_COMPILE</tt>, <tt>TOOLCHAIN_BIN_DIR</tt>, KERNDIR appropriately.
  4. copy $SDK/make/Makefile.linux-kmodule-2_6 $SDK/make/Makefile.linux-kmodule-3_10
     Customer doesn't need to modify this file.
  5. cd $SDK/systems/linux/user/custom-3_10 &amp;&amp; make 
<p>=== FOR THE CUSTOMER USING SDK-6.4.X
  Customer needs to follow below instructions to create new build target.
<p>  1. copy $SDK/systems/user/gto-2_6 $SDK/systems/user/custom-3_10
  2. modify 2 lines in $SDK/systems/user/custom-3_10/Makefile
      override <tt>kernel_version</tt>=3_10 
      platform=myboard-$ (<tt>kernel_version</tt>) 
  3. copy $SDK/make/Makefile.linux-gto-2_6 $SDK/make/Makefile.linux-custom-3_10 
     and modify <tt>CROSS_COMPILE</tt>, <tt>TOOLCHAIN_BIN_DIR</tt>, KERNDIR appropriately.
  4. cd $SDK/systems/linux/user/custom-3_10 &amp;&amp; make 
</td></tr><tr><td> SDK-55479 
 </td><td> 739565
 </td><td> 88030_B0
 </td><td> Note.
</td></tr><tr><td> SDK-55487 
 </td><td></td><td> 88950_a0
88750_A0
 </td><td> Added logging information during initialization.
</td></tr><tr><td> SDK-55495 
 </td><td></td><td> 88650_A0
 </td><td> BFD: bugs that hindered calling <tt>bcm_bfd_endpoint_create</tt>() with the flag <tt>BCM_BFD_ENDPOINT_UPDATE</tt> set for type= bcmBFDTunnelTypeMplsTpCc and bcmBFDTunnelTypeMpls were fixed.
</td></tr><tr><td> SDK-55500 
 </td><td> 758887
 </td><td> 88650_A0
88650ACP_A0
88650_B0
88650_B1
88660_A0
 </td><td> In the cint <tt>cint_policer_metering_example</tt>.c, the function <tt>header_compensation_example</tt> used the wrong function to set header compensation.
<p>This is now fixed.
</td></tr><tr><td> SDK-55501 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> In Field Processor, when creating a new Field Group, it is verified that the key can be allocated with the existing occupation of the program's instructions. However, the verification does not consider the used key bitmap which may indicate that all LSB/MSB keys are used. In which case, the algorithm should disregard the relevant (LSB/MSB) instructions. This is fixed.
</td></tr><tr><td> SDK-55502 
 </td><td> 759144
 </td><td> 56450_B0
56450_A0
 </td><td> <tt>soc_mem_config_set</tt>() ( is set to <tt>sal_config_set</tt>() in our local SDK environment with SAL implementation) may or may not be available with customer code.
so assert is not considered good idea.
If <tt>soc_mem_config_set</tt> not available and <tt>auto_portgroup</tt> and <tt>auto_polarity_flip</tt> is set true, SDK will suggest settings on screen so that end user can re-update config.bcm accordingly.
<p>Also made auto generated config variables unit specific (i.e. portgroup_&lt;num&gt;.unit=&lt;lanes)) happens with <tt>auto_polarity_flip</tt> and <tt>auto_portgroup</tt> config variables. This is relevant in multi unit setup.
</td></tr><tr><td> SDK-55515 
 </td><td> 752139
 </td><td> 56640_A0
56440_A0
56850_A0
56440_A1
56640_A1
56640_B0
56440_B0
56850_A1
56850_A2
 </td><td> <tt>bcm_port_learn_set</tt> is used to control the learning behavior on a port. The learning behavior can be set/modified using this API. This API was not supporting vlan virtual ports previously. Now, support is added to modify learning behavior for vlan virtual ports.
</td></tr><tr><td> SDK-55518 
 </td><td> 757054
 </td><td> 56634_A0
56634_B0
 </td><td> <tt>START_BY_START</tt> error interrupt was not being handled resulting in high CPU utilization. Added handler for this error, to clear the interrupt status register when set.
</td></tr><tr><td> SDK-55524 
 </td><td> 759557
 </td><td> 88660_A0
 </td><td> <tt>bcm_port_loopback_get</tt> bug fix for ILKN port in 2 Caui+ ILKN mode (BCM 88660)
</td></tr><tr><td> SDK-55528 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> OAM: <tt>bcm_oam_endpoint_action_set</tt> supports new actions: bcmOAMActionUcFwdAsData, bcmOAMActionMcFwdAsData to configure forwarding the packet instead of trapping/snooping.
The destination when calling this api with the actions above should be <tt>BCM_GPORT_INVALID</tt>.
This scenario is useful in case of MIP where we should forward the data as is without any special OAM action.
</td></tr><tr><td> SDK-55531 
 </td><td></td><td> 56340_A0
 </td><td> The variables to calculate the tokens are integers (4 bytes) but on multiplying two integer variables results in a much bigger number which cannot be accommodated in 4 bytes of allocated memory. This was impacting the vstorm control feature. Declared a temp variable of long integer (8 bytes) to store the resultant value to fix the issue.
</td></tr><tr><td> SDK-55537 
 </td><td></td><td> 88660_A0
 </td><td> When doing metering on packets, it is possible to compensate for Ethernet inter-packet gap (IPG) and/or Ethernet preamble by setting the switch control bcmSwitchMeterAdjustInterframeGap to 20.
This will add 20 bytes to the packet size for meter compensation calculation.
<p>Currently due to a software bug, this switch control is not set, and no compensation is performed.
<p>This is now fixed.
</td></tr><tr><td> SDK-55540 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> An access to an HW table (EGQ-VSI-Profile memory) was performed with a uint32 variable, although the table width is 33 bits. It resulted in a memory corruption. This is fixed.
</td></tr><tr><td> SDK-55542 
 </td><td> 755020
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> Ring Port: G.8032 Ring-Port can be associated with multiple VLAN-Ports using <tt>bcm_port_class_set</tt>().
De-associating a VLAN-Port from a Ring-Port where the physical port is on remote device have sometimes left the de-associated VLAN-Port in a state where it can't be reused and failed when referred by VLAN-Port APIs.
The issue was fixed, so that remote VLAN-Ports that are de-associated can always be reused.
</td></tr><tr><td> SDK-55543 
 </td><td> 759990
 </td><td> 88030_B0
 </td><td> <tt>EML_144</tt> supported added to tools:
<p><tt>INDEX_TYPE_144</tt>
<tt>LKUP_EML_144</tt>
<p>Note that <tt>EML_144</tt> can not be mixed with <tt>EML_176</tt>.
</td></tr><tr><td> SDK-55559 
 </td><td> 760422
 </td><td> 56643_A1
 </td><td> The new support for the below port configuration has been implemented.
<p>Device =56643
Frequency (MHz)= 450
Option = 4
GbE Port Group (XC[12:0]) = 36 x GbE+1 x GbE
High Speed Port Gr 1 (WC[2:0])= 4 x XFI
High Speed Port Gr 2 (WC[6:3])= 2 x HG[42] + x F.H [42]"
AXP Port Guaranteed Bandwidth = 5G 
</td></tr><tr><td> SDK-55560 
 </td><td></td><td> 56640_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56340_A0
56344_A0
56342_A0
56342M_A0
56340M_A0
 </td><td> add an workaround for TR3 and HX4 on both cases AT_L2_Limit_019 and AT_L2_Limit_042
</td></tr><tr><td> SDK-55567 
 </td><td></td><td> All
56850_A0
56855_A0
56854_B0
56854_A0
56850_A1
56851P_A1
56851_A1
56850_A2
56851_A2
56851P_A2
56854_A2
56853_A2
56852_A2
56855_A2
56851_A0
56852_A0
56852_A1
56853_A0
56853_A1
 </td><td> Problem:
<tt>bcm_field_qualify_data_get</tt> was not working for little endian hosts because of ordering of bytes during copy.
Solution:
If the host is little endian, updated code to swap the bytes in the expected ordering required for further processing.
</td></tr><tr><td> SDK-55583 
 </td><td></td><td> 56640_A0
56640_A1
56640_B0
 </td><td> Currently, Policers in cascade mode are mapped based on dot1P priorities of the incoming packet.
Two new policer group modes are added : bcmPolicerGroupModeIntPriCascade and bcmPolicerGroupModeIntPriCascadeWithCoupling which map the incoming packets to policers based on internal priority. Policers work in cascade mode where bandwidth flows from higher priority to lower priority.
</td></tr><tr><td> SDK-55600 
 </td><td> 719068
 </td><td> 56449_B0
56445_B0
56440_B0
56447_B0
56443_B0
56441_B0
56446_B0
56448_B0
56442_B0
 </td><td> Fixed crash observed during Level 2 warmboot on BCM56440.
</td></tr><tr><td> SDK-55604 
 </td><td> 760276
 </td><td> 56224_B0
56224_A0
 </td><td> Issue :- After warmboot, Recovered Entries were being shown as Disabled.
Fix :- The Entries were actually recovered properly both in H/W and S/W
          But code changes to mark the entries are enabled was missing. 
          Added the code change to mark the recovered entries as enabled.
</td></tr><tr><td> SDK-55615 
 </td><td> 758680
 </td><td> 88650_A0
88650ACP_A0
88650_B0
88650_B1
88660_A0
 </td><td> Counter processor example cint, <tt>cint_voq_count</tt>.c, was updated. The
bcmCosqGporYellowAcceptedPkts counter type replaced by bcmCosqGportNotGreenAcceptedPkts.
This change reflects change in the counter processor counters in <tt>FULL_COLOR</tt> counting mode from version 6.3.2
</td></tr><tr><td> SDK-55620 
 </td><td> 758957
 </td><td> 56640_A0
56540_A0
 </td><td> Two issues fixed as a part of this JIRA:
<p>Issue 1: Linkscan SW mode becomes NONE after executing the ibod WAR. 
Fix: IBOD sync recovery function <tt>_bcm_tr3_ibod_sync_recovery_port</tt>() is invoked from different threads and as the function is not properly protected, there is difference in the linkscan states. Provided the synchronization using <tt>IBOD_LOCK</tt>.
<p>Issue 2: When <tt>bcm_port_enable_set</tt> is getting called even before the LS thread is updated its bitmap ,so when <tt>bcm_port_enable_set</tt> calls <tt>_bcm_tr3_ibod_sync_recovery_port</tt> it takes the snap shot of port mode ,which comes to "<tt>BCM_LINKSCAN_MODE_NONE</tt>" so later on at the end of the function when it update the port mode it removes it from LS ,that where we see some times port is not part of linkscan.
<p>Fix: During the ibod WAR execution, the links of the port are set to link UP forcefully by invoking the API <tt>_bcm_esw_link_force</tt>() API with flags <tt><tt>_BCM_LINK_STATUS_NO_CALLBACK</tt></tt>.
<p>The flags are introduced newly and if the flag is set, the link state change notification is ignored to the registered linkscan users in function <tt>_bcm_esw_linkscan_update_port</tt>.
</td></tr><tr><td> SDK-55621 
 </td><td></td><td> 88650_B1
 </td><td> When replacing existing MTU value using <tt>bcm_l3_intf_create</tt> api, the MTU value might in some cases change to 0 instead of the requested value. This happens in case MTU value is unique for certain L3 Intf
</td></tr><tr><td> SDK-55630 
 </td><td></td><td> 88660_A0
 </td><td> OAM: when calling <tt>bcm_oam_loss_add</tt>() with the flag <tt>BCM_OAM_LOSS_SINGLE_ADDED</tt> set, loss management will be based on LMM PDUs, otherwise on CCM PDUs.
</td></tr><tr><td> SDK-55631 
 </td><td> 758623
 </td><td> 88650_B1
 </td><td> It is now possible to assign ports with a vlan translation port property, and create IP tunnel terminators that use {SIP,DIP,Next_protocol,Port_property} as key for tunnel termination.
To activate this mode, use soc property:
<tt>bcm886xx_ip4_tunnel_termination_mode</tt>= 4 or 5 
For an example, see <tt>cint_ip_tunnel_term</tt>.c, call <tt>ipv4_tunnel_term_next_protocol_example</tt> with <tt>use_port_property</tt>=1.
</td></tr><tr><td> SDK-55632 
 </td><td></td><td> 88650_B1
 </td><td> In FLP program selection initialization, some program IDs may have been overridden due to static program ID allocation that followed dynamic program ID allocation. For example, there were conflicts between FCoE and MAC-in-MAC FLP programs.
All dynamic allocation of program IDs is now after static allocation, so that no program ID override can be caused.
Note that if ISSU is performed, the fix will not apply.
</td></tr><tr><td> SDK-55639 
 </td><td></td><td> 56850_A2
 </td><td> In earlier releases, nexthop and ecmp reference count were not decreased when replacing vxlan port. This has been resolved.
</td></tr><tr><td> SDK-55654 
 </td><td> 754909
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Fixed DMA abort sequence in KNET Linux kernel module.
</td></tr><tr><td> SDK-55661 
 </td><td> 761066
 </td><td> 56548_A0
56547_A0
 </td><td> Support for F.HG[42] [SDK-46947] has been ported to the 6_3_branch.
</td></tr><tr><td> SDK-55681 
 </td><td></td><td> 56850_A2
 </td><td> In the previous release, assertion happened when <tt>bcm_cosq_port_mapping_set</tt> was called in ETS mode.In this release, this issue has been addressed by configuring a correct field of COS_MAPm and modifying the queue mode of HG ports to the value of zero.
</td></tr><tr><td> SDK-55683 
 </td><td></td><td> 53394_A0
 </td><td> Added SPI slave mode support of BCM56150 family. Only pure register access path is available in this mode without interrupt and DMA and the access speed is pretty slow in comparison to PCIe.
</td></tr><tr><td> SDK-55691 
 </td><td></td><td> 88650_B1
 </td><td> In L3, when calling the API function <tt>bcm_l3_host_add</tt>(), a lock may have been taken but not released in some cases.
The lock is always released now before exiting the function.
</td></tr><tr><td> SDK-55710 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> OAM: Deleting a MEP with RX configurations only (gport field in <tt>endpoint_create</tt> api is <tt>BCM_GPORT_INVALID</tt>) was failing.
</td></tr><tr><td> SDK-55712 SDK-55535
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Add the option to Use Dram saved config Parameters, and in case there are no Parameters to Perform Shmoo on init. Set this option as Default.
<p># 2 = Use Dram saved config Parameters, if no Parameters Perform Shmoo on init. Default option.
# 1 = Perform Shmoo on init.
# 0 = Use Dram saved config Parameters, if no Parameters do nothing.
<tt>ddr3_auto_tune</tt>.BCM88650=2
<p>Also, as default Load DRAM tuning properties from local File (/home/negev/<tt>bcm88650_dram_tune</tt>.soc). RcLoad will not fail if file not found.
</td></tr><tr><td> SDK-55713 
 </td><td></td><td> 88650_B0
88650_B1
88660_A0
 </td><td> Broad Sync API: implemented all missing <tt>bcm_time_</tt>* APIs .
</td></tr><tr><td> SDK-55715 
 </td><td></td><td> 88650_A0
 </td><td> PWE: verification case of updating TPIDs per PWE using bcm port tpid APIs <tt>bcm_port_tpid_add</tt>/delete does not work correctly (API always update TPIDs regardless of gport type)
</td></tr><tr><td> SDK-55719 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> OAM: api <tt>bcm_oam_endpoint_get</tt> returns incorrect flags in field flags2.
</td></tr><tr><td> SDK-55720 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> In Ingress Field Processor, when using TM programs per port profile (soc property <tt>post_headers_size</tt> is set), the program selection shuffle algorithm resets lines of Ethernet programs due to incorrect range calculation. This is fixed.
</td></tr><tr><td> SDK-55722 
 </td><td> 761214
 </td><td> 56450_A0
56450_B0
 </td><td> External DDR has 1024 columns but SDK was assuming it as fixed 2048. Due to this , calculated max bist address was crossing boundary and SDK was thowring assertion(crash) message. Issue is fixed by below below two steps
1) Added safety check for max BIST Addr. With this, even if user passes wrong parameter for running DDR TR 140 test case, assertion (i.e. crash) will be avoided.
<p>2) Used config properties (<tt>ext_ram_columns</tt> and <tt>ext_ram_banks</tt>) to set  <tt>NUM_COLUMNS</tt> and BANKS of external DDR memory. i.s.o. fixed 2048 and 8. Default will be 1024 and 8.  Settings will be displayed on screern. With this, if required , user can changes values based on connected DDR capability.
</td></tr><tr><td> SDK-55727 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> OAM: Mac-In-Mac OAM packet identification causes non-oam packets to be trapped to OAM engine.
</td></tr><tr><td> SDK-55730 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In the previous release, <tt>bcm_td_cosq_gport_detach</tt> intermittently returned <tt>BCM_E_RESOURCE</tt> incorrectly when the schedule nodes were not used up. In this release, this issue has been addressed by releasing the schedulers which are used by legacy setup once ETS mode is enabled.
</td></tr><tr><td> SDK-55736 
 </td><td></td><td> 88650_B1
 </td><td> In FCoE application, a new improvement allows the support for VSAN assignment from VFT or VSI (according to a device configuration) and supports a default VFT value per incoming port.
The calling sequence is:
1. Set the default VSAN assignment between VFT (by default) or VSI via <tt>bcm_port_control_set</tt>(unit, port = -1, type=bcmPortControlFcoeFabricSel, value = bcmPortFcoeVsanSelectVft / bcmPortFcoeVsanSelectOuterVlan)
<p>2. If the mode is VFT, set the default VFT per port via  <tt>bcm_port_control_set</tt>(unit, port, type = bcmPortControlFcoeFabricId, value);
<p>Note: FCoE application cannot co-exist with the usage of the Field Processor bcmFieldQualifyInterfaceClassProcessingPort qualifier at external stage (bcmFieldQualifyStageExternal) due to the usage of the same HW resource (the port key profile in forwarding stage).
</td></tr><tr><td> SDK-55740 SDK-56736
 </td><td> 757357
 </td><td> All
 </td><td> <tt>sand_erorr_code</tt> mechanizm shouldn't be used without initialization.
If init sequence failed before initializing the error mechanizm &amp; deinit try to use it Segmentation error will occur.
In order to solve this problem we are not using <tt>sand_error</tt> mechanizm at deinit sequence.
</td></tr><tr><td> SDK-55766 
 </td><td></td><td> 56640_A0
 </td><td> Currently, Policers in cascade mode are mapped based on dot1P priorities of the incoming packet.
Two new policer group modes are added : bcmPolicerGroupModeIntPriCascade and bcmPolicerGroupModeIntPriCascadeWithCoupling which map the incoming packets to policers based on internal priority. Policers work in cascade mode where bandwidth flows from higher priority to lower priority.
</td></tr><tr><td> SDK-55770 
 </td><td> 762574
 </td><td> 56850_A0
 </td><td> In previous releases, if multi-thread user accessed L3 memory with different view (i.e., <tt>L3_ENTRY_IPV4_UNICAST</tt>, <tt>L3_ENTRY_IPV4_MULTICAST</tt>), the physical memory could be corrupted because different view of same physical memory was using different LOCK, and the entry movement between banks could happen with invalid LOCK protection. In this release, different views of same physical memory are pointed to same LOCK, so the protection is effective.
</td></tr><tr><td> SDK-55793 
 </td><td> 757103
 </td><td> 88650_A0
88650_B0
88660_A0
 </td><td> VPLS: Enabled modification of working Incoming-PWE configuration under traffic by first creating new instance (the traffic will be moved to the new instance), then deleting the old entries using <tt>bcm_mpls_port_delete</tt>().
Example can be found in <tt>cint_vswitch_vpls</tt>.c when <tt>make_before_break</tt> field is set to 1.
</td></tr><tr><td> SDK-55803 SDK-55946
 </td><td></td><td> 88660_A0
 </td><td> When using <tt>bcm_port_control_set</tt> with the control bcmPortControlEgressModifyDscp, an inlif profile is expected in the port argument.
<p>An issue was found when one of the ports 0-16 is disabled. 
In this case when using an inlif profile with the same number as a disabled port, the API will produce an error, even though the argument is valid.
<p>This is now fixed.
</td></tr><tr><td> SDK-55818 
 </td><td> 761770
 </td><td> 56334_B0
56334_A0
 </td><td> In the previous release, SDK delete old next hop entry before new entry was installed when invoking the <tt>bcm_mpls_port_add</tt> API with <tt>BCM_MPLS_PORT_REPLACE</tt> flag asserted. In this release, this has been changed to delete old entry after new entry is installed.
</td></tr><tr><td> SDK-55822 
 </td><td></td><td> 88650_A0
 </td><td> LUT ROP transcations was failing when using LE CPU. Fix LUT ROP access endianess
Also improve KBP code by:
Add <tt>NULL</tt> checks at XPT layer.
Add <tt>ARAD_KBP_ROP_DEBUG_PRINTS</tt> define around prints to Improve access time.
</td></tr><tr><td> SDK-55823 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Function that related to Petra-B in Trill moved to trill.c/h files.
Remove initializing of sw-states(<tt>mc_trill_route_info_db</tt>,<tt>mc_trill_root_src_db</tt>) from ARAD.
</td></tr><tr><td> SDK-55825 
 </td><td></td><td> 88650_A0
88650_B0
 </td><td> IMPORTANT: In Rx parsing the <tt>src_gport</tt> and <tt>dst_gport</tt> interpretation and values were switched.
<p>Before, due to a bug, the <tt>dst_gport</tt> had the same interpretation as <tt>src_gport</tt>.
From  now on, the <tt>src_gport</tt> is the Source-Port where the packet enters the device and  <tt>dst_gport</tt> is where the packet exits the device.
</td></tr><tr><td> SDK-55830 
 </td><td> 763499
 </td><td> 88650_B0
88650_B1
88660_A0
 </td><td> Trill Ingress learning: For TRILL egress MC RBridge, it learns according to the native SA and VSI.
The original instruction which is used to learn native SA is incorrect for ingress learning. It caused ARAD to learn a random SA. The correct SA can be learned after fixing the instruction of lookup native SA.
</td></tr><tr><td> SDK-55831 
 </td><td> 762481
 </td><td> 56340_A0
56344_A0
56342_A0
56342M_A0
56340M_A0
 </td><td> Helix4/Triumph3 supports SW based aging and when age interval was modified, the new value did not take effect immediately. Code changes have been added to notify the SW Aging thread when age interval is updated, to take immediate effect.
</td></tr><tr><td> SDK-55840 
 </td><td> 761378
 </td><td> 56850_A0
56855_A0
56854_B0
56854_A0
56850_A1
56851P_A1
56851_A1
56850_A2
56851_A2
56851P_A2
56854_A2
56853_A2
56852_A2
56855_A2
56851_A0
56852_A0
56852_A1
56853_A0
56853_A1
 </td><td> In earlier releases entries[] can be potentially used without initialization in <tt>_bcm_td_cosq_wred_set</tt>. This has been resolved.
</td></tr><tr><td> SDK-55850 
 </td><td></td><td> 56846_A0
 </td><td> Support has been added for HG[11] and force cl72 on TD+.
</td></tr><tr><td> SDK-55857 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> IMPORTANT: the interpretation (and value) of pkt-&gt;<tt>pkt_len</tt> has been changed.
<p>In Packet parsing, 2 fields in <tt>bcm_pkt_t</tt> are referring to the packet length:
1. The <tt>tot_len</tt> (total length) field is unchanged, and corresponds to the packet length as received
2. The <tt>pkt_len</tt> field is changed to correspond to the packet length without the internal headers (i.e. system header size as FTMH, PPH, etc.). The previous value of <tt>pkt_len</tt> was equal to <tt>tot_len</tt>.
</td></tr><tr><td> SDK-55859 
 </td><td> 758730
 </td><td> 56640_A0
 </td><td> Two issues are resolved as a part of this JIRA. Here is the description:
<p>Issue 1. When a port gets the link up notification and also a remote fault is detected on the port, the port remains down and the <tt>linkup_bitmap</tt> and <tt>fault_bitmap</tt> for the port are set. After this state if the port is removed from the SW linkscan mode (the <tt>fault_bitmap</tt> is cleared) and if a link up notification occurred after adding the port back to SW linkscan. The function returns without setting the link status (as <tt>linkup_bitmap</tt> is already set to up) and it causes the SW link status for the port in down status.
<p>Solution- While clearing the <tt>fault_bit</tt> map, also clear the <tt>link_bitmap</tt>. So that when the linkscan for the port is enabled, it updates the state in the next iteration as per the new link status.
<p>Issue 2: When <tt>bcm_port_enable_set</tt> is getting called even before the LS thread is updated its bitmap ,so when <tt>bcm_port_enable_set</tt> calls <tt>_bcm_tr3_ibod_sync_recovery_port</tt> it takes the snap shot of port mode ,which comes to "<tt>BCM_LINKSCAN_MODE_NONE</tt>" so later on at the end of the function when it update the port mode it removes it from LS ,that where we see some times port is not part of linkscan .
<p>Solution- For this particular scenario, while restore the linkscan mode after the ibod WAR, retrieve the current linkscan mode and comparing it with the mode it got set before ibod WAR (<tt>BCM_LINKSCAN_MODE_NONE</tt>), if it is not same, the linkscan mode is not restored.
</td></tr><tr><td> SDK-55882 
 </td><td></td><td> 88650_A0
 </td><td> In Warmboot module, some fixes are inserted to prevent some uncatched <tt>wb_engine</tt> set\get timing issue (in ipmc module on 6.3 branch).
Besides, the error mechanism in <tt>wb_engine</tt> is changed to raise assertions when uninitialized SW database is accessed.
</td></tr><tr><td> SDK-55885 
 </td><td></td><td> 88650_B0
88650_B1
88660_A0
 </td><td> In case of User Defined Header, Egress Programmable Editor default program incorrectly removes some data bytes from the packet.
the fix updates the additional <tt>bytes_to_remove</tt> to 0.
This way no additional bytes are removed beside the system and network headers.
</td></tr><tr><td> SDK-55889 
 </td><td> 762107
 </td><td> 88650_B1
88660_A0
 </td><td> In Field Processor, when creating Direct Extraction field group, only one (1) qualifier is allowed to be used as filter qualifier per entry. When calling <tt>bcm_field_qualify_data</tt>() for an entry, and then calling <tt>bcm_field_qualify_xxx</tt>() the operation succeeds when an error should be produced. This is fixed.
</td></tr><tr><td> SDK-55902 
 </td><td></td><td> 56640_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56340_A0
56640_A1
56643_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
56344_A0
56342_A0
56342M_A0
56340M_A0
 </td><td> Problem:
When REGEX feature is enabled, compilation of SDK for linux kernel mode fails. This is because of inclusion of ctype.h file, which is not available directly.
Solution:
Removed the inclusion of ctype.h. Also re-define the logic in the function isprint() as a new function local to the file, since isprint() is dependent on ctype.h.
Affected platforms:
All platforms where REGEX is supported.
</td></tr><tr><td> SDK-55903 
 </td><td></td><td> 56640_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56340_A0
56640_A1
56643_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
56344_A0
56342_A0
56342M_A0
56340M_A0
 </td><td> Problem:
When REGEX feature is enabled, the compilation of SDK in Linux Kernel mode fails because of variable declarations mixed up with code.
Solution:
Moved the variable declarations to the beginning of the function and removed some dead code to get the compilation working.
Affected Platforms:
All platforms where REGEX is supported.
</td></tr><tr><td> SDK-55913 
 </td><td> 763695
 </td><td> 88650_B1
88660_A0
 </td><td> OAM may be initialized without setting any of the <tt>counter_engine_source_</tt>{0,1,2,3} soc properties to EGRESS/<tt>INGRESS_OAM</tt>.
Notice that in this case LM functionality is not supported.
</td></tr><tr><td> SDK-55915 
 </td><td> 764134
 </td><td> 56850_A2
 </td><td> In earlier releases,inALPM mode, even if we disabled URPF, the bits URPF_LOOKUP_CAMx in register <tt>L3_DEFIP_KEY_SEL</tt> was still 1
<p>Switching back and forth between urpf and non-urpf could result in URPF_CAM_LOOKUPx bits always set to 1. This has been addressed by  making  sure register settings are set correctly every time urpf switch control changes, and not just the first time.
</td></tr><tr><td> SDK-55919 
 </td><td> 764630
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Previously, <tt>bcm_vxlan_port_add</tt> with <tt>BCM_VXLAN_PORT_REPLACE</tt> overwrote <tt>CML_FLAGS</tt> set by <tt>bcm_port_learn_set</tt>. It is fixed now.
</td></tr><tr><td> SDK-55920 
 </td><td> 742940
 </td><td> 88030_A0
 </td><td> Fix EML304 and EML424 lookup for bcm88030
</td></tr><tr><td> SDK-55921 
 </td><td> 764681
 </td><td> 56850_A0
 </td><td> In earlier releases, nexthop and ecmp reference count were not decreased when replacing vxlan port. This has been resolved.
</td></tr><tr><td> SDK-55935 
 </td><td> 763171
 </td><td> 56850_A0
 </td><td> In earlier releases, the disabled pbmp of flexible ports was not recoverd during the warmboot. This has been resolved.
</td></tr><tr><td> SDK-55942 
 </td><td> 764885
 </td><td> 56850_A0
 </td><td> Implemented following IFP missing actions on TD2.
bcmFieldActionPortPrioIntCosQNew
bcmFieldActionRpPortPrioIntCosQNew
bcmFieldActionYpPortPrioIntCosQNew
bcmFieldActionGpPortPrioIntCosQNew
</td></tr><tr><td> SDK-55945 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> Allocation manager malfunction was fixed in OAM and L3 applications.
The bug was in allocating new profile resources (oam endpoint new actions, ttl scope) instead of existing profile.
</td></tr><tr><td> SDK-55956 
 </td><td> 764773
 </td><td> 88660_A0
 </td><td> In trap module, the <tt>bcm_l2_cache_set</tt> API is used to configure Reserve-Multicast and Programmable traps. This API returns an index, which can be used to delete the trap with <tt>bcm_l2_cache_delete</tt>.
<p>Due to a SW bug, <tt>bcm_l2_cache_delete</tt> was allocating another trap instead of deleting the allocated one. This is fixed.
Besides, <tt>bcm_l2_cache_get</tt> was returning incorrectly the EtherType (and its mask) parameters. This is fixed.
</td></tr><tr><td> SDK-55964 
 </td><td> 742713
 </td><td> 88650_B0
88650_B1
88660_A0
 </td><td> VLAN-Port Protection: Replace functionality of 1:1 protected VLAN Port to update <tt>failover_id</tt> is now available
</td></tr><tr><td> SDK-55967 
 </td><td> 755351
 </td><td> 88650_B0
88650_B1
88660_A0
 </td><td> OAM/BFD: When calling <tt>bcm_bfd_init</tt>() after <tt>bcm_oam_init</tt>(), not all BFD functionalities were properly initialized. Analogously when calling <tt>bcm_oam_init</tt>() after <tt>bcm_bfd_init</tt>().
</td></tr><tr><td> SDK-55968 
 </td><td> 756702
 </td><td> 88660_A0
 </td><td> OAM: configuring correct counter pointer for accelerated loss management, as well as correctly stamping counters on CCM based LM.
</td></tr><tr><td> SDK-55970 
 </td><td></td><td> 56440_A0
 </td><td> The parity protection on TCAM tables is implemented via SER engine and a SRAM table that is utilized to store parity bits of TCAM entries. Only enabling SER engine for the new-added <tt>L3_DEFIP</tt> table but not clearing its corresponding SRAM portion will leave the parity bits of <tt>L3_DEFIP</tt> table in an uninitialized state with random values. if the table is dumped, SER engine will check entry parity bits of table entries, this will trigger many parity errors reported.
Besides adding <tt>L3_DEFIP</tt> table into SER engine protection list, memory clear operation for  <tt>L3_DEFIP</tt> has also been added to initialize the parity bits of <tt>L3_DEFIP</tt> table into correct values.
</td></tr><tr><td> SDK-55972 
 </td><td> 764939
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Code for Warmboot support of <tt>MPLS_EXP_MAP</tt> has been added.
</td></tr><tr><td> SDK-55974 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> When using external TCAM, the access ROP mechanism was substantially improved.
The following new compilation flags are available:
<tt>ARAD_KBP_ROP_OPTIMIZATION</tt> - enable ROP performance optimization.
<tt>ARAD_KBP_DISABLE_IHB_LOOKUP_REPLY_FOR_ROP_TRANSMIT</tt> - enable ROP optimization without reading the IHB reply registers.
<tt>ARAD_KBP_ROP_TIME_MEASUREMENTS</tt>, <tt>ARAD_PP_KBP_TIME_MEASUREMENTS</tt> - enable time measurements.
</td></tr><tr><td> SDK-55997 
 </td><td></td><td> 56640_A0
56544_A0
56542_A0
56541_A0
56540_A0
56524_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56640_A1
56643_A1
56644_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
56524_B0
56540_B0
56541_B0
56544_B0
56542_B0
 </td><td>Enhancement:- There are 16 FP physical tcam slices with 512 entries per slice. There are 8 physical FP meter pools with 1024 entries per meter pool. Currently only 8 physical tcam slices are allowed to access the 8 FP meter pools. Requirement was to ensure the 16 physical tcam slices are allowed to access the 8 FP meter pools
<p>Support :- The 8 FP Physical meter pools are split into 16 logical meter pools so that the 16 FP tcam slices can attach to the 16 Logical FP meter pools.
</td></tr><tr><td> SDK-55998 
 </td><td></td><td> 56240_B0
 </td><td> Support has been added for the new Saber SKUs BCM56245 and BCM56246 with support for 256k buffer entries/192MB buffering.
</td></tr><tr><td> SDK-56009 
 </td><td> 765570
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> In Rx Trap module, an error is fixed when calling <tt>bcm_rx_trap_type_create</tt>(unit, 0, type, &amp;<tt>trap_id</tt>) with 'type' as one of the following :
- bcmRxTrapIpv4SipEqualDip
- bcmRxTrapIpv4DipZero
- bcmRxTrapIpv4SipIsMc
</td></tr><tr><td> SDK-56013 
 </td><td> 765696
 </td><td> 56850_A2
 </td><td> Fixed <tt>tunnel_initiator_delete</tt> followed by <tt>tunnel_initiator_create</tt>.In previous releases, this case could results in an abort of the SDK.
</td></tr><tr><td> SDK-56015 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> OAM: MIPs default behavior was changed to the following:
MIPs are transparent to all OAM packet types except for LTM unicast, LTM multicast and LBM unicast. If a MIP receives any other OAM packet with destination address == MIPs MAC address (configured in the <tt>dest_mac_address</tt> field in <tt>bcm_oam_endpoint_create</tt>()), the packet will be trapped to the CPU with trap code oam-error-level. If the destination address != MIPs MAC address then the packet will be forwarded (it was trapped to the CPU until now).
</td></tr><tr><td> SDK-56017 
 </td><td> 765489
 </td><td> 56840_A0
 </td><td> Enhanced warmboot shutdown to detach and close KNET device when present. This allows the application to remove the KNET kernel module without exiting.
</td></tr><tr><td> SDK-56022 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In the previous release, <tt>bcm_vxlan_port_delete</tt> returned <tt>BCM_E_NOT_FOUND</tt> for default VPN associated NW port. The problem was caused by the flex-counter detachment on VFI table. Originally the detachment was implemented in the deletion of VxLAN logical port and thus the operation on VFI table was executed repeatedly when deleting many logical ports in the same VFI. In this release this issue has been fixed by moving the operation to the VPN destroy.
</td></tr><tr><td> SDK-56024 
 </td><td></td><td> 56850_A0
 </td><td> There's a bit in the <tt>VLAN_XLATE</tt> table called <tt>VLAN_ACTION_VALID</tt>,It must be enabled to process <tt>XLATE__DISABLE_VLAN_CHECKS</tt> for VXLAN virtual ports, but disable it for VXLAN access ports to drop packets at ingress. They have conflict. To solve the problem, a new flag has been added that allows the customer to control the bit, The new flag is <tt>BCM_VXLAN_PORT_ENABLE_VLAN_CHECKS</tt>.
</td></tr><tr><td> SDK-56033 
 </td><td> 765288
 </td><td> 56850_A0
 </td><td> Problem:
Multiple Mirror Ingress actions were not removed during <tt>bcm_field_action_remove_all</tt> because during the action remove routine, we removed first MirrorIngress action and then returned without further processing the remaining actions
Solution:
Updated code to loop through all the actions [in case of similar group of actions] to remove each one of them in action remove routine.
</td></tr><tr><td> SDK-56038 
 </td><td> 766065
 </td><td> 56850_A0
56850_A1
56850_A2
56455_A0
 </td><td> During warmboot, the reference count for <tt>DSCP_TABLE</tt> has been updated to reflect the coldboot state.
</td></tr><tr><td> SDK-56040 SDK-56095
 </td><td> 766058
 </td><td> 56850_A0
56855_A0
56854_B0
56854_A0
56850_A1
56851P_A1
56851_A1
56850_A2
56851_A2
56851P_A2
56854_A2
56853_A2
56852_A2
56855_A2
56851_A0
56852_A0
56852_A1
56853_A0
56853_A1
 </td><td> In earlier releases <tt>bcm_esw_port_dscp_map_get</tt>() was taken care only for <tt>BCM_PRIO_DROP_FIRST</tt>, not taken care for other CNG values. This has been resolved.
</td></tr><tr><td> SDK-56043 
 </td><td></td><td> 88660_A0
 </td><td> During warm-boot validation, multiple issues have been found:
1. The <tt>bcm_l2_init</tt> was considered as a separate API: when called, the L2 module was detached and re-attached. This is fixed since L2 is initialized during BCM init and cannot be considered as separate API
2. When the device is initialized in TM (Traffic Management) mode, some init code was accessing by mistake uninitialized SW DB. This is fixed.
3. In L2 module, the freeze state (e.g. set by the <tt>bcm_l2_addr_freeze</tt> API) was not restored correctly after Warm-boot. This is fixed
</td></tr><tr><td> SDK-56045 
 </td><td> 766017
 </td><td> 56640_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56640_A1
56643_A1
56644_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
 </td><td> Committed Information Rate (CIR) and Committed Burst Size (CBS) configured in ICAP policer were not recovered correctly during warm boot on TR3 device. The ICAP policer recovery logic is updated to fix this issue.
</td></tr><tr><td> SDK-56047 
 </td><td> 761668
 </td><td> 56850_A2
 </td><td> The customer requested configuration of <tt>RTAG7_HASH_CONTROL_4</tt>.<tt>VXLAN_PAYLOAD_HASH_SELECT_A</tt>/B to meet their hash requirement. For Trident2 and subsequent XGS devices, 2 switch controls bcmSwitchHashVxlanPayloadSelect0 and bcmSwitchHashVxlanPayloadSelect1 have been provided to support the requirement.
</td></tr><tr><td> SDK-56053 
 </td><td></td><td> 88650_B1
88660_A0
 </td><td> IP Tunnel CINT: In a GRE termination example in <tt>cint_ip_tunnel_term</tt>.c, a tunnel configuration was changed to use the correct GRE enum type.
</td></tr><tr><td> SDK-56058 
 </td><td> 766252
 </td><td> 56850_A2
 </td><td> Fixed specific sequence of (SIP, multi-DIP)-add followed by delete and then add of <tt>vxlan_tunnel_initiators</tt>.
</td></tr><tr><td> SDK-56068 
 </td><td> 765431
 </td><td> 56640_A0
56640_A1
56640_B0
 </td><td> In the previous release there was an issue reported where TR3 semlock was out of order when creating 2 OAM sessions with same vlan/port, different level. This issue of memory locks not being released in failure case in OAM code for OAM_OPCODE_CONTROL_PROFILEm and ING_SERVICE_PRI_MAPm has been fixed.
</td></tr><tr><td> SDK-56069 
 </td><td></td><td> 56340_A0
 </td><td> while merging the ranges of TCP and UDP, on range not equal pointer index should increment. In this case no increment is done which leads to infinite loop on the same pointer. Fixed the indexing increment on no range match.
</td></tr><tr><td> SDK-56071 
 </td><td></td><td> 88650_B0
88650_B1
88660_A0
 </td><td> OAM: For UP-MEPs, all OAM frames trapped to the FPGA/CPU will be prepended with one set of internal headers, specifically an FTMH, PPH and a FHEI, with the OAM-ID on the FHEI. Formerly some frames included two sets of internal headers.
</td></tr><tr><td> SDK-56074 
 </td><td> 750523
 </td><td> 56440_A0
56440_A1
56440_B0
 </td><td> Issue: After setting spn_BCM5644X_CONFIG to 1 to split HG2 and HG3 into GE24 - GE31, the number of priority groups for these ports were not updated.
<p>Fix: After setting spn_BCM5644X_CONFIG to 1  to split HG2 and HG3 into GE24 - GE31, the number of priority groups for these ports are changed from 7 to 0, before configuring the priority group realted registers/tables in BCM5644x devices.
</td></tr><tr><td> SDK-56100 
 </td><td> 751146
 </td><td> 56450_B0
56450_A0
 </td><td> Support has been added for APIs <tt>bcm_port_timesync_config_set</tt>() and <tt>bcm_port_timesync_config_get</tt>() for BCM5645x devices.
</td></tr><tr><td> SDK-56108 
 </td><td> 762032
 </td><td> 88660_A0
 </td><td> OAM: Enable creating accelerated MPLS OAM endpoint after Ethernet endpoint
</td></tr><tr><td> SDK-56122 
 </td><td> 763713
 </td><td> All
 </td><td> Added <tt>PORT_INIT</tt> check to all bcm_port_XXX functions to avoid their invocation before port subsytem is initialized.
</td></tr><tr><td> SDK-56123 
 </td><td> 753886
 </td><td> 56243_B0
56240_B0
56243_A0
56242_A0
56242_B0
 </td><td> Enabled OAM endpoint addition and deletion multiple times without any error
</td></tr><tr><td> SDK-56128 
 </td><td></td><td> 56840_A0
56850_A2
 </td><td> In earlier releases, <tt>mac_xl_egress_queue_drain</tt>() blindly adds the PORT back to <tt>EPC_LINK_BMAP</tt> regardless previous <tt>EPC_LINK_BMAP</tt> state. This has been resolved.
</td></tr><tr><td> SDK-56140 
 </td><td> 766375
 </td><td> 56640_A1
 </td><td> Problem: When external TCAM table size is configured for IPv4 routes, IPv6 routes were not getting properly programmed/getting hit in the internal TCAM.
Solution: Added support for this specific case of having all IPv4 routes on external TCAM and all IPv6 routes on internal TCAM. 
</td></tr><tr><td> SDK-56142 
 </td><td> 765705
 </td><td> 56850_A0
56850_A2
 </td><td> In the previous release, customer reported that the rate is not accurate after changing rate from VERY HIGH PPS to low PPS.
This issue had been solved by adding condicision while in <tt>_bcm_trx_rate_meter_portmode_set</tt>(), while adding dlf value, not need to refer to previous setting in register/memory.
</td></tr><tr><td> SDK-56154 
 </td><td></td><td> 56640_A0
56544_A0
56542_A0
56541_A0
56540_A0
56524_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56640_A1
56643_A1
56644_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
56524_B0
56540_B0
56541_B0
56544_B0
56542_B0
 </td><td> Enhancement:- There are 16 FP physical tcam slices with 512 entries per slice. There are 8 physical FP meter pools with 1024 entries per meter pool. Currently only 8 physical tcam slices are allowed to access the 8 FP meter pools. Requirement was to ensure the 16 physical tcam slices are allowed to access the 8 FP meter pools
<p>Support :- The 8 FP  Physical meter pools are split into 16 logical meter pools so that the 16 FP tcam slices can attach to the 16 Logical FP meter pools.
</td></tr><tr><td> SDK-56160 
 </td><td> 766445
 </td><td> 56850_A0
 </td><td> In previous releases, L2 polling thread can process a MAC address insert/delete/move within a bucket, but it cannot process the scenario that a MAC address move from a bucket in a bank to another bucket in another bank.
In this release, processing the scenario that a MAC address move from a bucket in a bank to another bucket in another bank has been added in L2 polling thread.
</td></tr><tr><td> SDK-56189 
 </td><td></td><td> 88650_B0
88660_A0
 </td><td> Required changes in SDK in order to support KBP-SDK 1.2.3 and higher.
The changes include configuration of a newly used instruction and its transport layer implementation.
</td></tr><tr><td> SDK-56190 
 </td><td> 767623
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In previous release, <tt>bcm_l3_route_add</tt> API may returned Not_Found if with an IPv6 <tt>VRF_GLOBAL</tt> route entry in ALPM mode even if ALPM memory table had enough space. In this release, it can be added successfully.
</td></tr><tr><td> SDK-56194 
 </td><td></td><td> 88650_A0
 </td><td> In Warmboot module, asserts were recently inserted to avoid modifying an uninitialized SW database.
These asserts are replaced by regular error mechanism. Thus, most set/get SW DB functions are modified to return also an error value.
</td></tr><tr><td> SDK-56195 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In the previous release, PORT table LOCK would not be released if gport validation failed when operating PORT table. In this release, PORT table LOCK will be successfully released if gport validation fails when operating PORT table.
</td></tr><tr><td> SDK-56199 
 </td><td></td><td> 88660_A0
 </td><td> OAM: when calling <tt>bcm_oam_loss_get</tt>() the near/far fields returned were mixed up.
</td></tr><tr><td> SDK-56203 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> XLPORT Overrun/Underrun Workaround
-----------------------------------------------------:
The Arad driver implements a sequence to recognize and recover the port from XLPORT Overrun/Underrun issue (see BCM88650 errata sheet).
To activate the sequence during device init use the following soc property:
<tt>custom_feature_nif_recovery_enable</tt>=1 (default is disabled on 6.3.x, and enabled on 6.4.x).
<p>The sequence might perform several iterations when trying to recover the port. To limit number of iteration use the following SoC property:
<tt>custom_feature_nif_recovery_iter</tt> (default is 3).
Note that from lab experience the port is recover within single iteration.
<p>Limitations:
1. The SW WA works for XLP0 only. 
2. The SW WA is called during init and isnt available for dynamic port.  
</td></tr><tr><td> SDK-56215 
 </td><td> 754083
 </td><td> All
56846_A0
56845_B0
56845_A2
56844_A0
56842_A0
56840_A0
56640_A0
56850_A0
56843_B0
56841_A3
56846_A1
56841_B0
56640_A1
56640_B0
56850_A1
56850_A2
 </td><td> In the previous release, <tt>bcm_cosq_port_mapping_set</tt> and <tt>bcm_cosq_mapping_set</tt> returned <tt>BCM_E_RESOURCE</tt> incorrectly when there was one unused profile of the <tt>COS_MAP</tt> table on Trident/Trident2/Triumph3. In this release, this issue has been addressed by setting the MC_COS1f and UC_COS1f of the <tt>COS_MAP</tt> table at the same time.
</td></tr><tr><td> SDK-56222 
 </td><td> 767209
 </td><td> 56846_A0
 </td><td> During warm boot upgrade from SDK 6.2.9 to SDK 6.3.3, data qualifiers (UDFs) are not recovered in field module as there is a mismatch between field qualifier count (bcmFieldQualifyCount) in 6.2.9 and 6.3.3. The more field qualifiers are added in SDK 6.3.3.
<p>The issue is fixed in SDK 6.3.8 by storing bcmFieldQualifyCount in scache and by mapping the recovered field qualifier Id to the appropriate data qualifier. 
</td></tr><tr><td> SDK-56225 
 </td><td> 767847
 </td><td> 88650_A0
 </td><td> E2E scheduler port shaper is limited from below.
Added fix such that in case requested rate is lower than allowed, the minimal rate will be set.
</td></tr><tr><td> SDK-56244 
 </td><td> 765693
 </td><td> 56840_A0
56850_A2
 </td><td> The guideline for <tt>bcm_cosq_gport_mapping_set</tt> is improved in this release by specifying that it can be used on chips which support ETS(Enhanced Transmission Selection) feature regardless of that the ETS mode is enabled.
</td></tr><tr><td> SDK-56249 
 </td><td></td><td> 88650_B0
 </td><td> Egress shaper for ILKN interfaces don't work properly, causing unexpected behavior(wrong rates).
The shaping for ILKN interface is set using:
<tt>bcm_cosq_gport_handle_get</tt>(0,bcmCosqGportTypeLocalPort,<tt>gport_info</tt>); 
Fixed!
</td></tr><tr><td> SDK-56253 PHY-1417
 </td><td> 768344
 </td><td> 84328_B0
 </td><td> Issue Reported: G40 Port Disable not working as expected
Fix: Register sequence is modified to fix this issue.
</td></tr><tr><td> SDK-56254 
 </td><td> 765972
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> OAM: when creating a MIP and calling <tt>bcm_oam_action_set</tt>() for that MIP, the profile was handled incorrectly and might have caused packet drop. This issue was fixed and resources are properly managed and freed.
</td></tr><tr><td> SDK-56272 
 </td><td> 767442
 </td><td> 56340_A0
 </td><td> In earlier releases, Helix 4 GS GE48 was using incorrect lane information in the PHY driver. The port affected using quad smgii was using lane 2 and not lane 0, This has been fixed.
</td></tr><tr><td> SDK-56291 
 </td><td> 768458
 </td><td> All
 </td><td> The definitions of <tt>COUNTER_ATOMIC_BEGIN</tt>/END in COUNTER thread adopted <tt>sal_splhi</tt>/<tt>sal_spl</tt> as mutex lock to protect some small critical sections, which can cause a considerable performance loss due to its overhead and coverage scope. Replacing the old one with a new lock mechanism, the <tt>sal_spinlock</tt> primitives can be more efficent especially for protecting small critical sections somewhere like in COUNTER thread. <tt>sal_spinlock</tt> can be used in Linux user space, Linux kernel and vxworks, even in interrupt context. To be noted, it can't be used recursively.
</td></tr><tr><td> SDK-56295 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> BFD accelerated endpoint that is handled in remote gport - SW DB is not restored correctly after WB.
</td></tr><tr><td> SDK-56306 
 </td><td> 769032
 </td><td> 88030_A0
 </td><td> note.
</td></tr><tr><td> SDK-56317 
 </td><td></td><td> 56846_A0
56846_A1
 </td><td> In previous releases, created multipaths more than max capacity could corrupt existing ECMP groups and return wrong value -1 if ECMP group size of TD+ configured to 256 as TD device. In this release, it returns <tt>BCM_E_FULL</tt>(-6) if creating ECMP multipaths more than max capacity.
</td></tr><tr><td> SDK-56340 
 </td><td> 755455
 </td><td> 88650_A0
 </td><td> Port enable sequence was fixed to support 1588 on 1G ports.
</td></tr><tr><td> SDK-56350 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> The "multiple packet dequeue" feature which is meant for usage in low latency credit request profiles can now be configured using the <tt>bcm_cosq_delay_tolerance_level_set</tt>/get APIs.
The feature is activated for a credit request profile if the following new flag is used in the flags field of the structure: <tt>BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY</tt> .
<p>In release 6.4.1 all the credit request profiles named <tt>BCM_COSQ_DELAY_TOLERANCE_</tt>*<tt><tt>_LOW_DELAY</tt></tt> will have this feature set.
In 6.3.* releases the default profiles are not changed, though this can be done manually. Example of changing one predefined profile manually:
<tt>bcm_cosq_delay_tolerance_level_get</tt>(unit, <tt>BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY</tt>, &amp;<tt>delay_tolerance</tt>);
<tt>delay_tolerance</tt>.flags |= <tt>BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY</tt>;
<tt>bcm_cosq_delay_tolerance_level_set</tt>(unit, <tt>BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY</tt>
</td></tr><tr><td> SDK-56352 
 </td><td></td><td> 88660_A0
 </td><td> Fixed ECN (Explicit Congestion Notification) to work correctly in 88660
</td></tr><tr><td> SDK-56353 SDK-56332
 </td><td> 768573
 </td><td> 88650_A0
88650_B0
88660_A0
 </td><td> In Policer rate computation function, the exponent and mantissa configuration was fixed in case the required value is too small.
<p>When allocating a meter with a very low rate (for instance when using <tt>bcm_policer_config_t</tt>.<tt>max_pkbits_sec</tt> = 128), the driver produces an error, even though this is a valid rate.
This is now fixed.
</td></tr><tr><td> SDK-56355 
 </td><td> 767767
 </td><td> 88660_A0
 </td><td> In L2 module, when working in centralized mode, the LIF-valid bit entry was not received correctly on learn events (i.e., when the CPU was inserting learnt entries via BCM SDK).
The LIF-valid bit is now set correctly on the learn events and matches the payload of the device learned entry.
</td></tr><tr><td> SDK-56379 
 </td><td></td><td> All
 </td><td> Support has been added for resolving the modern GPORT types (TRILL, VXLAN, NIV, L2GRE, etc.) in the Diag Shell.
</td></tr><tr><td> SDK-56387 
 </td><td> 769040
 </td><td> 56450_B0
56450_A0
 </td><td> Support has been added for IFP qualifier bcmFieldQualifyRouterAlertLabelValid for BCM5645x devices.
</td></tr><tr><td> SDK-56409 
 </td><td></td><td> All
 </td><td> PTP clocks can now be re-created in order to change the "immutable" clock parameters. The only restriction is that the number of clock ports on re-creation may not exceed the value used on the initial creation.
</td></tr><tr><td> SDK-56410 
 </td><td> 769158
 </td><td> 88650_A0
 </td><td> TC\DP mapping using <tt>bcm_cosq_gport_egress_map_set</tt> uses profiles of mapping, and associate each port to relevant profile. The API supported up to 4 different profiles, although HW support up to 8 profiles (when new profile is required but not avaliable, the API return an error).
The API was fixed to support 8 profiles as the HW.
</td></tr><tr><td> SDK-56425 
 </td><td> 767797
 </td><td> 88650_A0
88660_A0
 </td><td> All the SER's are enabled at initialization sequence.
There is no need to enable them by script anymore.
</td></tr><tr><td> SDK-56439 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> Ethernet OAM does not recover from Warm-boot. This is fixed.
</td></tr><tr><td> SDK-56440 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> MPLS Tunnel initiator clear all API does not clean up MPLS WB information as well.
</td></tr><tr><td> SDK-56441 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> During Warmboot in vswitch module, the VSI MSTP was always restored, even if it was cleared before the warmboot. This restoration is skipped upon Warmboot.
</td></tr><tr><td> SDK-56446 
 </td><td> 759287
 </td><td> 88650_A0
88660_A0
 </td><td> Fix <tt>low_vid</tt> verify value in <tt>bcm_vswitch_port_delete</tt> function (<tt>arad_pp_frwrd_trill</tt>.c).
</td></tr><tr><td> SDK-56447 
 </td><td> 763576
 </td><td> 88650_A0
88660_A0
 </td><td> When creating an ECMP group using <tt>bcm_l3_egress_ecmp_create</tt>, if the 'ecmp' parameter is <tt>NULL</tt>, a segmentation fault was occurring.
This is now fixed - the software checks that the 'ecmp' parameter is not <tt>NULL</tt>.
</td></tr><tr><td> SDK-56451 
 </td><td></td><td> 88650_B0
88660_A0
 </td><td> Required changes in SDK in order to support KBP-SDK 1.2.3 for external TCAM are introduced.
</td></tr><tr><td> SDK-56452 
 </td><td> 760578
 </td><td> 56450_B0
56450_A0
 </td><td> When 1 + 1 protection switching is enabled/disabled (with label swapping on IPMC group), the MPLS::<tt>LABEL_ACTION_SWAP</tt> field of <tt>EGR_L3_NEXT_HOP</tt> table need to be set/cleared respectively to achieve the functionality. This support has now been added.
</td></tr><tr><td> SDK-56455 SDK-56327
 </td><td> 769233
 </td><td> 56224_B0
56224_A0
 </td><td> Issue :- IpType Qualifier was not recovered properly after warmboot.
<p>Fix :- Recovery of IpType Qualifier was not handled properly in BCM56624.
         Added Code to recover IpType qualifier after warmboot.
</td></tr><tr><td> SDK-56464 
 </td><td> 765386
 </td><td> 56640_A0
56640_A1
56640_B0
 </td><td> Problem: When there is no signature configured, if there is traffic being sent to signature matching engine(SME) for deep packet inspection, the SME goes into a hung state. Even after configuring some signatures later on, it doesn't indicate any match though it receives matching traffic.
<p>Solution: Do not let any traffic to be forwarded to SME until at least one signature is configured successfully. Also, stop the traffic from being forwarded to SME while detaching the last active engine. This is achieved by modifying flow tracker configuration register field.
</td></tr><tr><td> SDK-56476 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> In Field Processor's diagnostics, in case field groups were created however no entry was inserted, an error is produced when calculating the number of entries from an empty bitmap. This is fixed.
</td></tr><tr><td> SDK-56482 
 </td><td> 768774
 </td><td> 56450_B0
56450_A0
 </td><td> Added support for associating a MPLS label to a given protection switching group for BCM5645x devices.
API <tt>bcm_mpls_tunnel_switch_add</tt>() can be used to achieve this by passing the protection switching group id in "<tt>failover_id</tt>" member of structure "<tt>bcm_mpls_tunnel_switch_t</tt>". 
</td></tr><tr><td> SDK-56492 
 </td><td> 769633
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> The related <tt>EGR_PORT_TO_NHI_MAPPING</tt> was not cleaned when the last port was removed from the trunk where a VXLAN logical port is created. Now it is fixed by adding the specific implementation for VXLAN.
</td></tr><tr><td> SDK-56495 
 </td><td> 768732
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> In Field Processor, at Egress, the support of two new qualifiers is introduced: bcmFieldQualifyISid (MAC-in-MAC I-SID) and bcmFieldQualifyMplsForwardingLabelAction. Both qualifiers are mapped internally to the EEI value.
</td></tr><tr><td> SDK-56514 
 </td><td></td><td> 56850_A0
56854_B0
 </td><td> In previous releases, SER correction for MMU CTR block was not implemented. In this release, MMU CTR block SER correction logic has been implemented. Once parity error is detected in tables in MMU CTR block, the corrupted table entry will be cleared.
</td></tr><tr><td> SDK-56533 
 </td><td> 769718
 </td><td> 56850_A2
 </td><td> Fixed multicast module to return error when deleting member from a MC group that was already destroyed.
</td></tr><tr><td> SDK-56554 
 </td><td> 770975
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Support has been added for the ability to transmit even if port is down.
</td></tr><tr><td> SDK-56572 
 </td><td> 771276
 </td><td> 88660_A0
 </td><td> When using external TCAM for forwarding, serial IP and RPF, then high rate lookups return sometimes wrong results.
This is fixed: serial lookups in external TCAM are always returning reliable results at any supported rate.
</td></tr><tr><td> SDK-56577 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Removing sw database MC-ID -&gt; nickname.
Nickname can be extracted from <tt>trill_port_id</tt> database (<tt>encap_id</tt> field).
</td></tr><tr><td> SDK-56578 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> New sequence for ECMP creation using forward-group port instead of trill-port-ecmp.
</td></tr><tr><td> SDK-56580 
 </td><td> 772058
 </td><td> 88650_B1
88660_A0
 </td><td> QOS: Fixed the ability to set Inner-PCP to TC/DP table in <tt>bcm_qos_map_add</tt>.
</td></tr><tr><td> SDK-56581 
 </td><td></td><td> 88650_A0
 </td><td> In Field Processor diagnostics, the actions offsets are incorrect when cascaded action is used. This is fixed.
</td></tr><tr><td> SDK-56591 
 </td><td> 768899
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> New API <tt>bcm_l3_egress_stat_counter_sync_get</tt>() added to retrieve l3 egress stats after updating the software copy of the counter value with the hardware counter value.
</td></tr><tr><td> SDK-56594 SDK-57957
 </td><td> 769099
 </td><td> 56440_A0
56445_A0
56440_A1
56445_A1
56444_A1
56450_A0
56340_A0
56449_B0
56445_B0
56440_B0
56447_B0
56443_B0
56441_B0
56446_B0
56448_B0
56344_A0
56342_A0
56442_B0
56342M_A0
56340M_A0
56455_A0
56456_A0
56450_B0
 </td><td> In earlier releases scheduler configuration with weight value 0 was incorrectly configured in WRR mode. This has been fixed in this release to configure scheduler configuration with weight value 0 to be in STRICT PRIORITY mode.
</td></tr><tr><td> SDK-56597 
 </td><td> 772109
 </td><td> 56850_A2
 </td><td> <tt>soc_alpm_insert</tt>: Route Insertion Failed due to DEFIP AUX Operation timeout.
On expiry of poll for ALPM hardware operations, <tt>soc_timeout_check</tt> requires that the status register needs to be read one more time to confirm operation has completed.
This support has been added.
</td></tr><tr><td> SDK-56607 
 </td><td></td><td> 88650_B0
 </td><td> Fix initial shaper to interface mapping. This fix has no functional impact.
</td></tr><tr><td> SDK-56608 
 </td><td> 765207
 </td><td> 56450_A0
56450_B0
 </td><td> When the physical port associated with MPLS port is replaced by using <tt>bcm_mpls_port_add</tt>() API with flag <tt>BCM_MPLS_PORT_REPLACE</tt>, the properties associated with old physical port is not cleared.
Appropriate check has been added to clear the properties associated with the old physical port for BCM5645X devices.
</td></tr><tr><td> SDK-56610 
 </td><td> 772885
 </td><td> 56450_A0
56450_B0
 </td><td> <tt>gport_attach</tt> function can be called passing cosq value as 0,1,2.. so on.
When coaq value was passed instead of -1, code was not handling it properly, So same <tt>hw_index</tt> was allocated again and again, Now checks are provided so that unique <tt>hw_cosq</tt> value is assigned for different values of cos
</td></tr><tr><td> SDK-56611 
 </td><td> 772970
 </td><td> 88650_A0
88650_B0
88660_A0
 </td><td> After Hard_Reset was called , CPU port was stuck. Resolved in the hard reset code by resetting CMIC TXi credits.
</td></tr><tr><td> SDK-56615 
 </td><td> 772971
 </td><td> 56450_A0
56450_B0
 </td><td> WRR scheduling under sub ports could not work due to missing weight configuration in L0 nodes. This configuration issue has been corrected to get the expected scheduling behavior.
</td></tr><tr><td> SDK-56628 
 </td><td></td><td> 88660_A0
 </td><td> BFD: for BFD endpoints of type bcmBFDTunnelTypeMpls (BFD PDUs are encapsulated by UDP, IP, MPLS, Eth), IP TOS, TTL may be configurable through the fields <tt>ip_tos</tt>, <tt>ip_ttl</tt>. Note that the protocol dictates that the IP TTL be set to 1.
</td></tr><tr><td> SDK-56629 
 </td><td></td><td> 88650_A0
88650_B1
88660_A0
 </td><td> When compiling with <tt>INCLUDE_KBP</tt> compilation flag, a large memory allocation for Field Processor software state was performed, related to external TCAM.
This large memory allocation is now performed only if ELK usage is indicated via SOC properties.
</td></tr><tr><td> SDK-56635 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> In some scenarios, trunk ports <tt>lb_key_min</tt> and <tt>lb_key_max</tt> values do not cover all <tt>lb_key</tt> range [0:255] which results in packet drop. This issue is fixed.
</td></tr><tr><td> SDK-56636 
 </td><td></td><td> 88650_A0
 </td><td> At SOC layer, a new mechanism to improve the performance of entry insertion for Large-Exact-Match, Small-Exact-Match and TCAM databases has been implemented. By default, this mechanism is enabled.
To disable this mechanism, unset the compilation flag <tt>ARAD_FAST_REGISTERS_AND_FIELDS_ACCESS</tt>.
</td></tr><tr><td> SDK-56641 
 </td><td></td><td> 56850_A2
 </td><td> In earlier releases, VxLAN multicast was treated as non-Layer3 multicast. It caused VxLAN multicast group to still have members after being re-created. This has been resolved.
</td></tr><tr><td> SDK-56644 
 </td><td></td><td> 56440_B0
 </td><td> <tt>EGR_L3_NEXT_HOP</tt> table has overlapping views, for ex: L3, MPLS, <tt>SD_TAG</tt> etc., and for a given entry in <tt>EGR_L3_NEXT_HOP</tt> table the fields corresponding to a particular view, decided by <tt>ENTRY_TYPE</tt> field, should only be modified. But some fields of L3 view (overlapping with <tt>MAC_DA_PROFILE_INDEX</tt> field of MPLS view) were always getting modified resulting in wrong <tt>EGR_MAC_DA_PROFILE</tt> entry getting overwritten when a given L3 egress object is updated using the flags <tt>BCM_L3_REPLACE</tt> | <tt>BCM_L3_WITH_ID</tt>.
<p>Protection (i.e, check for appropriate <tt>ENTRY_TYPE</tt> value before modifying fields in L3 view)  has been added to overcome the issue.
</td></tr><tr><td> SDK-56646 
 </td><td></td><td> 88650_A0
88660_A0
88670_A0
 </td><td> Fixed a problem in <tt>bcm_mpls_port_add</tt>. The issue caused the driver to crash with a segmentation fault when the API is called with the REPLACE flag.
</td></tr><tr><td> SDK-56647 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> In FCoE, when adding a route via <tt>bcm_fcoe_route_add</tt> API with flags <tt>BCM_FCOE_LOCAL_ADDRESS</tt> | <tt>BCM_FCOE_HOST_ROUTE</tt>, the entry was not be added correctly to the forwarding database. This is fixed.
</td></tr><tr><td> SDK-56649 
 </td><td> 772044
 </td><td> 88660_A0
 </td><td> In metering when the SOC property <tt>policer_color_resolution_mode</tt> is set to 1, the meter processor outputs the following DP values:
green - 0
yellow - 1
meter processor red - 2
ethernet policer red - 3.
<p>Due to a software bug, when the meter processor gave a packet a color of yellow, the actual DP would be 2, instead of 1.
This is now fixed.
</td></tr><tr><td> SDK-56657 SDK-54730
 </td><td></td><td> 88660_A0
 </td><td> Currently, unless specified by SOC property, ethernet policers drop all packets that arrive red to the device.
Color blind ethernet policers allow to do rate policing even for packets that arrive red to the device.
<p>This fix introduces the ability to change ethernet policers to be color blind or color aware dynamically.
To set color blind ethernet policing, both the ethernet policer and aggregate policer associated with a port and traffic class must be set to be color blind.
To set an ethernet policer to be color blind, the <tt>BCM_RATE_COLOR_BLIND</tt> flag can be used when calling <tt>bcm_rate_bandwidth_set</tt>.
To set an aggregate policer to be color blind, the <tt>BCM_POLICER_COLOR_BLIND</tt> flag can be used when calling <tt>bcm_policer_set</tt> with an aggregate policer.
</td></tr><tr><td> SDK-56688 
 </td><td></td><td> 56340_A0
 </td><td> In the previous release the packet/byte fields were not working correctly in regex reports. The packet and Byte counter registry values are now retrieved and updated in the match reports.
</td></tr><tr><td> SDK-56693 
 </td><td></td><td> 56340_A0
 </td><td> When only engine 0 is enable, the CSF table will not be updated no toggling on CSF valid signal.
When other engine are enabled, the CSF table will be loaded when the valid signal of other engines toggle. 
Hence enabling starts from engine 1 and engine 0 will be enabled at last.
</td></tr><tr><td> SDK-56700 
 </td><td> 774184
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
88670_A0
 </td><td> When calling <tt>bcm_mpls_port_add</tt> with pwe id &gt; 32K, error printouts are provided but the API returns <tt>BCM_E_NONE</tt>. This is fixed and error is returned.
</td></tr><tr><td> SDK-56701 
 </td><td> 773800
 </td><td> All
 </td><td> In earlier releases diag shell would intermittently crash in "l3 egress show" command. This has been resolved.
</td></tr><tr><td> SDK-56709 
 </td><td> 773764
 </td><td> 56334_B0
56334_A0
 </td><td> Issue:
====
Remote trunk identifier bit has to be ignored while setting the srcTrunk mask.
<p>The MSB of the modId represents Remote trunk bit and hence it was calculated based on the width of the qualifier. However, the width of the qualifier varies for different devices. Due to this, for devices like Enduro, the bit was positioned wrongly and was ignoring trunk bit instead of the remote trunk bit.
<p>Fix:
===
Instead of using the width of qualifier, the bit position of the trunkBit minus 1 (<tt>trunk_bit_pos</tt> - 1) is used to calculate the remote trunk bit position and ignoring the bit by masking the bit to 0.
</td></tr><tr><td> SDK-56714 
 </td><td> 758491
 </td><td> 56450_A0
56440_B0
 </td><td> Issue :
---------------
In katana and katana2 the <tt>rqe_port_config</tt> register was programmed with <tt>cos_mode</tt>=1 when extended queueing was enabled
but <tt>cos_mode</tt> =1 is not valid for this register and this causes traffic to go through cos 0 always 
Fix
-----
If extended queing is enabled then we program <tt>cos_mode</tt> with value 0 in <tt>RQE_PORT_CONFIG</tt> .
</td></tr><tr><td> SDK-56720 
 </td><td> 769698
 </td><td> 56224_B0
56224_A0
 </td><td> Output of "trunk show" command displays the port names correctly by resolving the gports for all XGS devices.
</td></tr><tr><td> SDK-56725 
 </td><td></td><td> 56850_A0
56855_A0
56850_A2
 </td><td> In previous release, the functions <tt>bcm_vxlan_stat_attach</tt> and <tt>bcm_vxlan_stat_counter_get</tt> took high execution time, about 13000 usec per call, which couldn't meet customer expectations. In this release, the functions have been optimized, and they takes about 100 usec per call. The performance has been improved.
</td></tr><tr><td> SDK-56741 
 </td><td> 763657
 </td><td> 56640_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56340_A0
56640_A1
56643_A1
56644_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
56344_A0
56342_A0
56342M_A0
56340M_A0
 </td><td> In earlier releases, the validation on the PORT for ETS was incorrect on the return value which might lead to wrong COSQ mapping. Fixed the validation.
</td></tr><tr><td> SDK-56753 
 </td><td></td><td> 56640_A0
56643_A0
56640_A1
56643_A1
56640_B0
56643_B0
 </td><td> Problem: Due to a hardware bug, the hardware team had recommended to disable bus parity protection for a bunch of memories which includes IESMIF. However, the SDK still has the bus parity enabled on IESMIF and this is causing spurious parity errors in the cases where ESM accesses are involved.
<p>Solution: Disable the bus parity protection for IESMIF by default, to workaround the hardware issue. 
</td></tr><tr><td> SDK-56756 
 </td><td> 773877
 </td><td> 56540_A0
56540_B0
 </td><td> Previously, "l3 ip6route show" command was broken on Firebolt-4. This is due to that <tt>soc_feature_l3_shared_defip_table</tt> is not supported on Firebolt-4 and thus <tt>bcm_switch_object_count_get</tt> called in this command returns an error. It is fixed by adding the additional check on <tt>soc_feature_l3_shared_defip_table</tt> to avoid calling <tt>bcm_switch_object_count_get</tt> for Firebolt-4.
</td></tr><tr><td> SDK-56761 
 </td><td></td><td> 56540_A0
56340_A0
56540_B0
 </td><td> In Apollo2 and Helix4 devices, during an OAM CCM timeout event, remote endpoint index passed from SDK to OAM event callback function was not correct, this issue has been addressed.
</td></tr><tr><td> SDK-56763 
 </td><td> 772471
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In the previous release, the API <tt>bcm_cosq_gport_bandwidth_set</tt> would set the shaper on a wrong scheduler node. In this release, this issue has been addressed by setting the software resources which have been assigned to the HSP ports.
</td></tr><tr><td> SDK-56765 
 </td><td></td><td> 88660_A0
 </td><td> Add driver support to new Arad SKU - 88363
</td></tr><tr><td> SDK-56770 
 </td><td> 774767
 </td><td> 88650_B0
 </td><td> Trill learning: In TRILL multicast, ingress learning, MACT learning is disabled at Egress Router-Bridge for TRILL multicast packets otherwise unrelated MACs (Link Layer SA) are learned.
</td></tr><tr><td> SDK-56779 
 </td><td> 774862
 </td><td> 56850_A0
56855_A0
56854_B0
56854_A0
56850_A1
56851P_A1
56851_A1
56850_A2
56851_A2
56851P_A2
56854_A2
56853_A2
56852_A2
56855_A2
56851_A0
56852_A0
56852_A1
56853_A0
56853_A1
 </td><td> In earlier release, TD2 had 48 HIGIG trunks and SDK was not able to record/maintain the bitmap of higig trunk override id which was larger than 31. This issue has been fixed in this release.
</td></tr><tr><td> SDK-56781 
 </td><td> 774909
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> The root cause of this issue is that when l2 addresses are learnt on Y pipeline, the hit bits of the corresponding L2X table entries are not set. But <tt>bcm_l2_matched_traverse</tt> function will read all L2X table entries and check the hit bits, so the traverse function can't find the l2 address learnt on Y pipeline.
Code has been added to update the hit bits of L2X entries when the L2 addresses are learnt on Y pipe line.
</td></tr><tr><td> SDK-56786 
 </td><td> 773228
 </td><td> All
 </td><td> Support has been added for displaying counter register's alias name which register's name larger than 13 charactors
</td></tr><tr><td> SDK-56801 
 </td><td> 774468
 </td><td> 56440_A0
56445_A0
56440_A1
56450_A0
56440_B0
56450_B0
 </td><td> In earlier releases, Enabling of <tt>tcam_protect_write</tt> resulted in incorrectcomputation of the number of entries per slice on Katana. This issue has been fixed by correcting size of the FP TCAM value used for computing the size of each slice.
</td></tr><tr><td> SDK-56805 
 </td><td></td><td> 88660_A0
 </td><td> ARP downstream checking didn't use separately, now the fixes resolve this issue.
</td></tr><tr><td> SDK-56821 
 </td><td></td><td> 56820_B0
 </td><td> In Scorpion, IP Packets with 0x9100 (other than default TPID 0x8100) outer tag are treated as untagged and non IP packets when these packets ingress on YPIPE and egress on XPIPE. This behavior is detected by the EFP when it is configured to match anything beyond the L2 header.
<p>The software work around is added in SDK to fix this issue by changing the access type of the per-port register <tt>EGR_SRC_PORT</tt>.
</td></tr><tr><td> SDK-56840 
 </td><td> 772939
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> In MAC-in-MAC, when using API <tt>bcm_l2_addr_add</tt>(), multicast group destination was not supported in BMACT Forwarding table.
Multicast group destination is now supported and can be added to BMACT forwarding table.
</td></tr><tr><td> SDK-56848 
 </td><td> 776418
 </td><td> 82328_A0
 </td><td> Added PHY BCM82322 support. This PHY supports 10G,20G and 40G modes
</td></tr><tr><td> SDK-56850 
 </td><td> 776440
 </td><td> 56450_A0
56450_B0
 </td><td> Issue : Support for ECAP CopytoCpu is missing on KT2.
Fix :  Added Support for ECAP CopytoCPU in KT2 in SDK
</td></tr><tr><td> SDK-56854 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> In FCoE zoning, when adding an entry, all entry actions were applicable (allow, deny, redirect), but the same action (allow) was always executed. A validation is introduced so that only the action allow is applicable.
</td></tr><tr><td> SDK-56869 
 </td><td></td><td> 56450_A0
56450_B0
56640_B0
56440_B0
 </td><td> PTP master sends Announce messages to PTP slaves. PTP slaves compares announce messages received from several PTP master to decide which PTP master to choose to synchronize time. Following three new fields are added to PTP master information structure.
<p>ClockAccuracy:
The clockAccuracy indicates the expected accuracy of a clock when it becomes grandmaster or in event it becomes grandmaster. Various granularities are possible. This specifies time is accurate to within
25 ns/100 ns/250 ns/1 ?s/2.5 ?s/10 ?s etc.
<p>OffsetScaledLogVariance:
The offsetScaledLogVariance indicates inherent precision of a clock. This is the precision of the timestamps included in message issued by clock when it is not synchronzied to another clock using the protocol. The reference clock when not synchronized to another clock may be an atomic clock, a GPS receiver, a stable local oscillator, a suite of clocks synchronized via NTP, etc. These sources may contribute to the variance estimate. The value of offsetScaledLogVariance can also be a staic constant determined by manufacturer.
<p>StepsRemoved:
The distance measured by the number of boundary clocks between the local clock and the foreign master
is used when two Announce messages reflect the same foreign master. The distance is indicated in the
stepsRemoved field of Announce messages. 
</td></tr><tr><td> SDK-56876 
 </td><td> 776002
 </td><td> 56640_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56640_A1
56643_A1
56644_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
 </td><td> The scheduler configuration with weights value 0 will be considered as <tt>STRICT_PRIORITY</tt>. Fixed the same behavior in SDK.
</td></tr><tr><td> SDK-56878 
 </td><td> 776733
 </td><td> 88650_B1
 </td><td> The <tt>bcm_cosq_control_set</tt>/get(unit, 0, 0, bcmCosqControlAdmissionTestProfileA, bitmap) APIs did not work correctly if the bitmap bits for PFC or LLFC VSQ types were set.
This was fixed.
</td></tr><tr><td> SDK-56884 
 </td><td></td><td> 88650_A0
88650_B0
 </td><td> MIM: DEFAULT BEHAVIOR CHANGE .
Encoding of returned handler <tt>station_id</tt> for MIM is now changed in l2 station APIs.
<tt>bcm_l2_station_get</tt>() API failed in some cases when LSB for MyMac was considered to be global instead of per ingress port.
This happened when the MIM global LSB bit in the created <tt>station_id</tt> was wrongfully set due to an overlap in the <tt>station_id</tt> encoding.
This is fixed by changing the encoding of the <tt>station_id</tt> so that there is no overlap with the MIM LSB global indication bit. The MIM global LSB indication bit in <tt>station_id</tt> changed from bit 7 to bit 16.
</td></tr><tr><td> SDK-56887 
 </td><td></td><td> 88660_A0
 </td><td> Default value of Chicken bit <tt>EGQ_CFG_BUG_FIX_CHICKEN_BITS_REG_1</tt> <tt>CFG_BUG_FIX_87_DISABLE</tt> was changed to disable (instead of enable) as it doesn't provide any new functionality.
</td></tr><tr><td> SDK-56888 SDK-56945
 </td><td> 742236
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Support reflector functionality in accordance with RFC-2544 (benchmarking methodology). This JIRA contains IP+MAC swap functionality (swap the SIP with the DIP, SA with DA) as well as a light MAC-only-swap functionality (swap the SA with the DA).
For the former, the soc property
RFC2544_reflector_mac_and_ip_swap_port 
should be set to the reflector port. All packets arriving at the ETPP with the Out-TM-port set to the reflector port will have their MAC addresses and IP addresses swapped, and the packet will be prepended with a PTCH with the SSP set to the original Out-PP-Port. The reflector port should be defined as a recycle port and the IP routing should be done at the second pass. The light MAC-only swap functionality can be used analogously with the soc property 
RFC2544_reflector_mac_swap_port 
For a more detailed account (For example setting an egress-PMF rule modifying the Out-TM-port), refer to <tt>cint_benchmarking_methodology</tt>.c
</td></tr><tr><td> SDK-56903 
 </td><td></td><td> 56850_A0
 </td><td> Adding a flag <tt>BCM_NIV_VNTAG_L_BIT_FORCE_1</tt> to choose if frames can be headed back towards the Interface Virtualizer that it originated from.
</td></tr><tr><td> SDK-56913 
 </td><td> 759274
 </td><td> All
 </td><td> In earlier releases on overflow the DMA timeout/overflow stat was cleared only when the entries were available. On entry empty this was not getting cleared. Fixed in the changes when the entry is empty.
</td></tr><tr><td> SDK-56917 
 </td><td> 777278
 </td><td> 56340_A0
 </td><td> SMEmatchnotreportedfortwitterandwebexsignatures due to hex representation of ASCII. Provided support in SDK API <tt>bcm_regex_match_set</tt>() to parse hex representation of ASCII Alphabets.
</td></tr><tr><td> SDK-56925 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> PON: In previous release, DHCP IPv6 anti-spoofing wasn't working when soc property <tt>l3_source_bind_mode</tt> is IPV6, now fixed this issue.
</td></tr><tr><td> SDK-56929 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In earlier releases, next hop information was not initialized before using it. This has been resolved.
</td></tr><tr><td> SDK-56931 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In previous releases, the API <tt>bcm_l3_egress_get</tt> returned <tt>BCM_E_INTERNAL</tt> in vxlan case. A new case <tt>_bcmVpTypeVxlan</tt> has been added to fix this issue. Now if the case is vxlan, the egr-&gt;port will be set to vxlan and the API will return <tt>BCM_E_NONE</tt>.
</td></tr><tr><td> SDK-56954 
 </td><td></td><td> 56850_A0
 </td><td> In earlier releases, source trunk table was not being cleared up if a customer used an incorrect sequence. This has been resolved.
</td></tr><tr><td> SDK-56956 
 </td><td> 774358
 </td><td> 88650_A0
88650_B0
88660_A0
 </td><td> In Field Processor, in Direct Extraction field groups, it is possible to set a bias value as part of the extraction field configuration. The procedure failed when the bias value is negative. This is fixed.
</td></tr><tr><td> SDK-56960 
 </td><td></td><td> 88650_A0
88650ACP_A0
88650_B0
88650_B1
 </td><td> QOS: Qos map id can be destroyed by calling <tt>bcm_qos_map_destroy</tt>.
Improvement in entry deletion for <tt>bcm_qos_map_destroy</tt> by adding new SW DB to record each entry is occupy or not.
</td></tr><tr><td> SDK-56961 
 </td><td></td><td> 88660_A0
 </td><td> BFD: When calling <tt>bcm_bfd_endpoint_create</tt>() with the flag <tt>BCM_BFD_ENDPOINT_REPLACE</tt> set and type==bcmBFDTunnelTypeMplsTpCc, static registers were mismanaged, causing such calls to fail.
</td></tr><tr><td> SDK-56962 
 </td><td> 776131
 </td><td> 88650_A0
88650_B0
88660_A0
 </td><td> The OAM DM DOWN program at the egress editor has been fixed so that only appropriate packets will select this program. Previously this program was catching other packets as well which cased outgoing packet corruption.
</td></tr><tr><td> SDK-56964 
 </td><td></td><td> 56850_A1
56850_A2
56850_A0
 </td><td> In earlier releases the related <tt>EGR_PORT_TO_NHI_MAPPING</tt> was not cleaned when the last port was removed from the trunk where a VXLAN logical port was created. This is fixed by adding the specific implementation for VXLAN.
</td></tr><tr><td> SDK-56975 
 </td><td> 774350
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Customers requested more granularity in <tt>bcm_vxlan_vpn_create</tt>. To enable this modifications were made to <tt>BCM_VXLAN_VPN_WITH_VPNID</tt> to meet this goal. Before this change, when customer created a vpn, <tt>BCM_VXLAN_VPN_WITH_VPNID</tt> us required, and both VFI and VNID were created.After this change, the behavior is as follows:
<p>When create a VXLAN VPN:
If use <tt>BCM_VXLAN_VPN_WITH_VPNID</tt>, both VFI and VNID will be created.
If not. use flag <tt>BCM_VXLAN_VPN_WITH_VPNID</tt>, only VFI will be created.
<p>When updating an existing  VXLAN VPN(<tt>BCM_VXLAN_VPN_REPLACE</tt> should be used.
If use both <tt>BCM_VXLAN_VPN_REPLACE</tt> and <tt>BCM_VXLAN_VPN_WITH_VPNID</tt>, both VFI and VNID will be created.
If only use <tt>BCM_VXLAN_VPN_REPLACE</tt>, the VNID will be removed.
</td></tr><tr><td> SDK-56980 
 </td><td> 777710
 </td><td> 56240_B0
 </td><td> In previous releases, If the given port was configured with WRR scheduling and then warmboot was done the SW did not recover the correct scheduling algorithm back after the warmboot .The hardware continued to have correct value . This has been resolved.
</td></tr><tr><td> SDK-56988 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Customer wanted to use VLAN and VFI flex counter simultaneously.
But in the previous release, SDK assigned VLAN and VFI counter in the same pool, and this  would cause the VFI counter to not be updated when the packet hit two memories.
Now the customer can use the SOC property <tt>ing_share_flex_counter_pool</tt>=split(vlan,vfi) to prevent VLAN and VFI from sharing the same pool.
</td></tr><tr><td> SDK-56991 
 </td><td> 778526
 </td><td> 56850_A2
 </td><td> In earlier releases, when using <tt>bcm_vxlan_port_add</tt>() API with <tt>BCM_VXLAN_PORT_REPLACE</tt> flag, it will clear the flex counter configuration if this vxlan port has attached with flex counter. This has been resolved.
</td></tr><tr><td> SDK-56994 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> It was found that network facing flex counters were not working for both bcmStatGroupModeSvpType and bcmStatGroupModeSvpType group modes. After investigation we located the RCA was the counter offsets were not set correctly in previous implementation.
<p>The issuse was fixed by adjusting the counter offset for both bcmStatGroupModeSvpType and bcmStatGroupModeDvpType group modes.
</td></tr><tr><td> SDK-56995 
 </td><td> 777713
 </td><td> 56845_A2
56850_A0
56850_A1
 </td><td> In the previous release, when using RPCs and calling <tt>bcm_vxlan_stat_counter_get</tt>(), the values in the <tt>counter_indexes</tt>[] parameter are not being properly propagated from the client to the server. This has been resolved.
</td></tr><tr><td> SDK-57002 
 </td><td> 778714
 </td><td> 56850_A2
 </td><td> In earlier releases, SDK code was not able to resolve the ports for which id was larger than 64 in BITMAPf of IFP_REDIRECTION_PROFILEm table on TD2 after warmboot. This has been resolved.
</td></tr><tr><td> SDK-57004 
 </td><td></td><td> 56640_A0
56340_A0
 </td><td> In previous release, the schan response type for devices with ISM, e.g. Triumph3 and Helix4 is not properly checked. The following response types <tt>SCHAN_GEN_RESP_L2_MOD_FIFO_FULL</tt>, <tt>SCHAN_GEN_RESP_MAC_LIMIT_THRESHOLD</tt> and <tt>SCHAN_GEN_RESP_MAC_LIMIT_DELETE</tt> have been added in schan response type checking in the routine <tt>soc_mem_generic_insert</tt>().
</td></tr><tr><td> SDK-57009 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In previous releases, <tt>bcm_vxlan_stat_detach</tt> took high execution time because redundant memory operation was executed. In this release, we remove memory read operation and use <tt>soc_mem_write</tt> instead of <tt>soc_mem_write_range</tt> conditionally to save time, then the execution time can be reduced a lot.
</td></tr><tr><td> SDK-57027 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In earlier releases, Trunk useful information was cleared by VXLAN API.This has been resolved.
</td></tr><tr><td> SDK-57032 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In earlier releases, <tt>bcm_vxlan_port_get</tt>() could not get the <tt>BCM_VXLAN_PORT_DROP</tt> and <tt>BCM_VXLAN_PORT_MULTICAST</tt> flags correctly. This has been resolved.
</td></tr><tr><td> SDK-57034 
 </td><td> 775986
 </td><td> 56450_A0
56242_A0
 </td><td> Issue :
Packet based Wred profiles would not be restored properly in katana/katana2  after warmboot .As part of fix During warmboot  we scan packet based wred table  and update the software profile. 
</td></tr><tr><td> SDK-57038 
 </td><td></td><td> 88650_B1
 </td><td> <tt>stat_if_pkt_size</tt> description in config-sand.bcm example was misleading.
The correct description can be found in user manual or in property.h.
Description in config-sand.bcm fixed as well.
</td></tr><tr><td> SDK-57054 
 </td><td> 778731
 </td><td> 88650_B1
 </td><td> add more detail prints and update the UM. Changing jira to improvment
</td></tr><tr><td> SDK-57075 
 </td><td></td><td> 88650_B0
 </td><td> Arad initialization time significantly improved for channelized interface configuration.
</td></tr><tr><td> SDK-57077 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> IMPORTANT CHANGE FOR PWE P2P:
OAM PWE P2P was not identified as OAM in the classifier because of wrong lif id (0 value instead of the real LIF-ID value). This is fixed by setting valid LIF-ID for PWE P2P. 
The change may cause same-interface to be invoked for PWE P2P case when In-LIF PWE P2P ID is equals Out-LIF ID.
</td></tr><tr><td> SDK-57078 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> OAM: Supporting down MEPs in the format CFMoEthoMplsoEth in OAM classifier. In order to enable initialization of the OAM TCAM to identify CFMoEthoMplsoEth, set soc property <tt>custom_feature_oam_downmep_pwe_classification</tt> to 1.
This feature supports CFM identification per-md level only. 
This feature does not support identification per opcode. All CFM packets will be associated with opcode=1 (CCM).
Inner Ethernet frames with 0 or 1 VLAN tags preceding the CFM EtherType are supported.
For a more detailed explanation (including examples), consult <tt>cint_oam_cfm_o_eth_o_pwe_o_eth</tt>.c
</td></tr><tr><td> SDK-57080 
 </td><td> 766661
 </td><td> 88650_B1
 </td><td> TRILL and FCoE could not be supported simultaneously on the same device, due to an overlap in FLP (i.e. forwarding HW block) programs allocation.
TRILL and FCoE can now be supported and coexist on the same device.
</td></tr><tr><td> SDK-57082 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Important Note: the default Drop Precedence (DP) mapping of a yellow packet with DP=2 has been changed.
<p>Usually the final DP (Drop Precedence) given by the meter (or the In-DP) is unchanged, and can be from 0-3.
In the past the final DP was always changed from 2 to 1 when passed to ingress, meaning that the only available DP results were 0, 1 and 3 (at ingress).
To support this old behavior the SOC property <tt>policer_color_resolution_mode</tt> is introduced.
When <tt>policer_color_resolution_mode</tt>=1, if the final DP is 2, this DP is mapped to 1 instead (at ingress).
</td></tr><tr><td> SDK-57083 
 </td><td> 776583
 </td><td> 88650_B0
88650_B1
88660_A0
 </td><td> IMPORTANT: for improved performance after <tt>bcm_field_group_install</tt> call, it is recommended to set <tt>USING_TCAM_PRIO_LIST_INVERSE_SCAN</tt> compilation flag.
<p>In Field processor entry insertion procedure, the user can:
- after initialization, define all the entries and then insert them in one call (<tt>bcm_field_group_install</tt>)
- on-the-fly, insert the entries dynamically one by one (<tt>bcm_field_entry_install</tt>)
<p>The advantage of the first case is the absence of TCAM shuffling, since the entries are sorted according to their priority before their insertion.
<p>In this case, the limiting factor in the entry performance was the entry insertion in the priority sorted list, an internal data structure detailing for each priority the acceptable TCAM location range. The scanning of  this list was always performed from the first node to the last one, even if in the sorted case the inserted entry was the last one. 
This scanning has been changed to scan from the end, if the compilation flag <tt>USING_TCAM_PRIO_LIST_INVERSE_SCAN</tt> is set. We highly recommend to users to set this compilation flag for performance improvement.
</td></tr><tr><td> SDK-57085 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> If <tt>bcm_mpls_tunnel_initiator_create</tt> is called with <tt>WITH_ID</tt> flag and an existing egress tunnel id, this is illegal configuration.
We added a check to verify this won't happen.
</td></tr><tr><td> SDK-57100 
 </td><td> 778739
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In Trident2, <tt>IP_FRAG_INFO</tt>(2bit) is defined in 5 field selectors (<tt>F1_6</tt>, <tt>F1_15</tt>, <tt>F2_1</tt>, <tt>F3_3</tt> and <tt>IFP_PAIRING_FIXED</tt>). But In SDK ,<tt>IP_FRAG_INFO</tt> in these 5 different selectors are initialized with 2 different qualifiers as below which is wrong. Modify the SDK to make it consistent i.e use bcmFieldQualifyIpFrag qualifier at all places.
<tt>F1_6</tt> - initialized for bcmFieldQualifyIpInfo
<tt>F1_15</tt> - initialized for bcmFieldQualifyIpFrag
<tt>F2_1</tt> - initialized for bcmFieldQualifyIpFrag
<tt>F3_3</tt> - initialized for bcmFieldQualifyIpInfo
<tt>IFP_PAIRING_FIXED</tt> - initialized for bcmFieldQualifyIpFrag
Now <tt>IP_CHECKSUM_OK</tt> is 1 bit field and part of FIXED part of IngressFieldProcessor key. Currently SDK doesnot have support for this 1 bit field and  bcmFieldQualifyIpInfo qualifier is used  to initialize <tt>IP_CHECKSUM_OK</tt> bit.
</td></tr><tr><td> SDK-57102 
 </td><td> 779185
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In earlier releases, If adding l3 host entry to HW failed, SDK should decrease the related reference count but this function did not work when it has a multipath flag. This has been resolved.
</td></tr><tr><td> SDK-57104 
 </td><td> 779184
 </td><td> 56526_A0
56524_A0
56521_A0
56526_B0
56524_B0
 </td><td> For BCM_5652x devices, whenever a tpid other than the default tpid was created, reference count of default tpid was decremented once but was not incremented during deletion.
<p>During repeated creation and deletion , this reference count became negative resulting in error.         
<p>This has been fixed by incrementing default tpid reference count upon deletion of tpid thus providing support for repeated creation and deletion of tpid on a port 
</td></tr><tr><td> SDK-57105 
 </td><td></td><td> 56850_A2
 </td><td> The customer requested configuration of <tt>RTAG7_HASH_CONTROL_4</tt>.<tt>VXLAN_PAYLOAD_HASH_SELECT_A</tt>/B to meet their hash requirement. For Trident2 and subsequent XGS devices, 2 switch controls bcmSwitchHashVxlanPayloadSelect0 and bcmSwitchHashVxlanPayloadSelect1 have been provided to support the requirement.
</td></tr><tr><td> SDK-57107 
 </td><td></td><td> 56850_A2
 </td><td> The customer requested configuration of <tt>RTAG7_HASH_CONTROL_4</tt>.<tt>VXLAN_PAYLOAD_HASH_SELECT_A</tt>/B to meet their hash requirement. For Trindent2 and subsequent XGS device, 2 switch controls bcmSwitchHashVxlanPayloadSelect0 and bcmSwitchHashVxlanPayloadSelect1 have been provided to support the requirement.
</td></tr><tr><td> SDK-57123 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Issue:- bcmSwitchL3Max128BV6Entries switch control setting caused assertion failed message due to array index overflow in array <tt>defip_tcam_log_index</tt> and <tt>defip_tcam_urpf_log_index</tt> of <tt>SOC_CONTROL</tt>.
Fix:- Modified the <tt>soc_trident2_mem_config</tt> function to make sure <tt>l3_defip_index_remap</tt> won't exceed the physical size, and the arrays can be initialized after that. 
</td></tr><tr><td> SDK-57132 
 </td><td> 757170
 </td><td> 88650_B1
88660_A0
88670_A0
 </td><td> OAM: Packets trapped by the OAM classifier with an incorrect level by an up-MEP will include two sets of system headers. The inner set will include the DSP, SSP on the FTMH, as well as a PPH and FHEI, the outer set will include a FHEI with the CPU-Trap-Code field set to 0xa2 (bcmRxTrapOamLevel).
Similarly for packets that arrive at an up-MEP from the passive side. In this case the CPU-Trap-Code on the outer FHEI will be 0xac (bcmRxTrapOamPassive) and the inner set of system headers will be as above.
This behavior may be enabled by setting the soc property "custom_feature_oam_additional_FTMH_on_error_packets" to 1.
</td></tr><tr><td> SDK-57133 
 </td><td> 748626
 </td><td> 88650_A0
88660_A0
 </td><td> When <tt>ilkn_tdm_dedicated_queuing</tt> feature is enabled, non-TDM ports can't reach wire speed. (blocked in ~60G). Fixed.
</td></tr><tr><td> SDK-57141 
 </td><td> 779921
 </td><td> 56840_A0
56850_A2
 </td><td> Problem:
<p>Ipbm mask setting was missing during field entry movement, which gets called when a higher priority field entry is installed. 
<p>Solution:
<p>Ipbm mask was set properly during field entry movement for Trident Series of devices.
</td></tr><tr><td> SDK-57164 
 </td><td> 763730
 </td><td> 56440_A0
56450_B0
 </td><td> In the earlier release the tag information derivation was incorrect for <tt>PPD_TYPE</tt>=2, for <tt>PPD_TYPE</tt>=2 the tag information is present in packet itself and get derived through it, HG header contain tag information in case of <tt>PPD_TYPE</tt>=0 and 1 only where the outer tag get stripped out and added in the hg header, while the inner tag is still derived from the packet itself.
This issue has been addressed and fixed in this release.
</td></tr><tr><td> SDK-57184 SDK-57276
 </td><td></td><td> 88660_A0
 </td><td> Bug found and fixed in BCM command diag <tt>prge_last</tt> causing "default null" program to be incorrectly printed.
</td></tr><tr><td> SDK-57187 
 </td><td> 776877
 </td><td> 56440_A0
 </td><td> For Katana2, <tt>bcm_cosq_gport_bandwidth_set</tt> was not setting the l2 shaper properly.
As part of the fix  l2 shaper will be configured properly.
</td></tr><tr><td> SDK-57188 
 </td><td> 780510
 </td><td> 56450_A0
56450_B0
 </td><td> <tt>bcm_mpls_port_add</tt> allocates two VPs in VPWS case, one for access and one for network port. But when <tt>bcm_mpls_port_add</tt> was invoked for second time to add network port to VPWS a new VP was being allocated instead of reusing the already allocated VP. Added fix to not allocate new VP if already allocated.
</td></tr><tr><td> SDK-57199 
 </td><td></td><td> 88650_B1
 </td><td> IMPORTANT: DEFAULT BEHAVIOR CHANGE
FCoE packets were dropped when FCoE switch was not enabled (<tt>bcm886xx_fcoe_switch_mode</tt> = 0). 
From now on, FCoE packets are treated as Ethernet packets when FCoE is disabled.
</td></tr><tr><td> SDK-57201 
 </td><td> 779706
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> STG: STG APIs create/destroy STGs and set/get spanning tree status of ports in STGs.
Certain STG APIs (<tt>bcm_stg_create_id</tt>/<tt>bcm_stg_destroy</tt>/<tt>bcm_stg_stp_set</tt>/<tt>bcm_stg_stp_get</tt>/<tt>bcm_stg_detach</tt>) didn't release the mutex when existing with a non-zero value.
The issue detailed above can cause deadlock when using certain STG APIs. Mutex can be correctly released after the fix.
</td></tr><tr><td> SDK-57207 
 </td><td> 777630
 </td><td> 56640_A0
56640_A1
56640_B0
 </td><td> Issue:Packets of size 64 to 75 bytes getting dropped for XE ports.
Root Cause: The runt threshold value for XE ports was getting set as 76 instead of the correct value 64. Hence packets of size 64-75 bytes were getting dropped. 
Fix: For Triumph3 and Katana2, put explicit checks to ensure that runt threshold value is set to correct value, i.e. <tt>RUNT_THRESHOLD_XE</tt> = 64, <tt>RUNT_THRESHOLD_GE</tt> = 64 and <tt>RUNT_THRESHOLD_HG</tt> = 76.
Also optimized the function <tt>mac_x_init</tt> for multiple READ and WRITE for <tt>XMAC_RX_CTRL</tt> and <tt>XMAC_TX_CTRL</tt>. Added a single write common for all devices instead of multiple instances as was present previously.
</td></tr><tr><td> SDK-57215 
 </td><td></td><td> 88650_A0
88660_A0
88670_A0
 </td><td> Trill multicast adjacency BCM API implemented with new APIs:
<tt>bcm_trill_multicast_adjacency_add</tt>/delete
<tt>bcm_trill_multicast_adjacency_delete_all</tt>
<tt>bcm_trill_multicast_adjacency_traverse</tt>
<p>Example can be found in <tt>cint_trill</tt>.c file in function <tt>mult_adjacency</tt>.
</td></tr><tr><td> SDK-57220 
 </td><td> 780270
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> When programming <tt>MPLS_ACTION_IF_BOS</tt>=0x5(0x5 = <tt>L3_ECMP</tt>) for a given MPLS label, the next hop entry type was set to be 1 for sending out the regular L3 packet in the previous release. In this release, the next hop entry type is set to be 0.
</td></tr><tr><td> SDK-57224 
 </td><td> 780313
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In earlier releases, <tt>BCM_L2_REPLACE_DES_HIT_CLEAR</tt> flag was not supported in XGS devices. This has been supported. This flag only can reset the HITDA field in <tt>L2_ENTRY</tt> table.
</td></tr><tr><td> SDK-57230 
 </td><td> 758870
 </td><td> 88660_A0
 </td><td> VLAN: L2 FECs can be used either for protection or to group LIFs like in the case of the PON application, in which the flag <tt>BCM_VLAN_PORT_FORWARD_GROUP</tt> is applied at <tt>bcm_vlan_port_create</tt>().
Removal of a L2 FEC using <tt>bcm_vlan_port_destroy</tt>() for a protection FEC, is performed at once for both the working and the protecting FECs upon removal of the Working path.
This logic was applied also in cases where the FEC wasn't used for protection as in the case of <tt>FORWARD_GROUP</tt>, but only the specified FEC was removed as only one FEC is used for this type of applications.
This logic caused <tt>FORWARD_GROUP</tt> FECs with odd id number not to be deleted as if they represent a protecting path. This was fixed, so that the protection working/protecting state condition upon FEC removal is applied only for protection FECs.
</td></tr><tr><td> SDK-57235 
 </td><td></td><td> 56340_A0
 </td><td> On every DMA interval the counter value are read from <tt>FT_EXPORT_FIFO</tt> table and the value is populated in the report. On every read the value gets reset leading to the cumulative values not getting retained in the END report when the flow expires. With this release read of the registries clear of counter values is avoided to retain the cumulative value for the END report.
</td></tr><tr><td> SDK-57239 
 </td><td> 778949
 </td><td> 88650_B0
 </td><td> OAM: The following bugs have been fixed:
When updating endpoints with <tt>bcm_oam_endpoint_create</tt>() with the <tt>BCM_OAM_ENDPOINT_REPLACE</tt> flag set, the SW DBs were incorrectly updated causing subsequent calls to <tt>bcm_oam_endpoint_destry</tt>() to fail. 
Similarly for BFD endpoints of type bcmBFDTunnelTypeUdp, multi-hop.
</td></tr><tr><td> SDK-57245 
 </td><td> 781014
 </td><td> 56450_A0
56450_B0
 </td><td> <tt>FLEX_CTR_BASE_COUNTER_IDX</tt> and <tt>FLEX_CTR_POOL_NUMBER</tt> were not being restored during mpls entry replace operation. Added fix to restore the FLEX counter fields and update during replace operation.
</td></tr><tr><td> SDK-57263 
 </td><td> 774859
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> In some cases when using the diagnostic 'diag pp pkttm', the meter pointer assigned to the packet would be displayed as invalid, even when the meter pointer assigned to the packet was valid.
This is now fixed.
</td></tr><tr><td> SDK-57270 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> Field Processor: Redirecting at egress according to a GPort of type System-Port was not supported. This is fixed.
<p>Reflector: The function <tt>setup_port_for_reflector_program</tt>() in <tt>cint_benchmarking_methodology</tt>.c has been changed so that the Egress FP rule modifies only the out-TM-port (by calling only the bcmFieldActionRedirect without bcmFIeldActionStat actions). For a more detailed account, see <tt>cint_benchmarking_methodology</tt>.c
</td></tr><tr><td> SDK-57272 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> Diag pp dblif used to return 0 for the <tt>has_cw</tt> (in case lif is pwe) with no relation to the real value of. Now, it is returned depending on the real value.
</td></tr><tr><td> SDK-57277 
 </td><td> 780887
 </td><td> 56850_A0
56855_A0
56854_B0
56854_A0
56850_A1
56851P_A1
56851_A1
56850_A2
56851_A2
56851P_A2
56854_A2
56853_A2
56852_A2
56855_A2
56851_A0
56852_A0
56852_A1
56853_A0
56853_A1
 </td><td> Issue:- In parallel mode, if VRF=0, then hardware looks only in global bucket space for bucket match, so route with VRF=0 is not allowed to be inserted to ALPM table. But the examination code was not working for the first VRF=0 route insertion.
<p>Fix:- Adding VRF=0 is disallowed explicitly in parallel mode. Update the document for this restriction.
</td></tr><tr><td> SDK-57278 
 </td><td> 775407
 </td><td> 88650_A0
88650ACP_A0
88650_B0
88650_B1
88660_A0
 </td><td> QOS: There are total 16 Egress PCP VLAN profile for Arad.
Error is invoked when allocating Egress PCP VLAN profile 15.
Changed the number of Egress PCP VLAN profile can be used from 15 to 16. 
</td></tr><tr><td> SDK-57283 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> There was a value mismatch between set and get by calling <tt>bcm_switch_control_port_set</tt>/get APIs, where type=bcmSwitchHashIP4Field0.
This mismatch is fixed.
</td></tr><tr><td> SDK-57289 
 </td><td> 779367
 </td><td> 88650_B1
88660_A0
 </td><td> When using external TCAM, control-plane writes to the external TCAM could sometimes fail when performed during line speed traffic.
This issue is fixed by setting "CpuRecordPrio" field in register "TransmitCfgs" to '1' in the external TCAM application initialization. 
</td></tr><tr><td> SDK-57290 
 </td><td> 781195
 </td><td> 88650_A0
88660_A0
 </td><td> Fix <tt>bcm_petra_trill_port_delete</tt> functionality.
Add calling of <tt>_bcm_dpp_mc_to_trill_remove</tt> function, that removes sw db <tt>mc_id</tt> to nickname.
</td></tr><tr><td> SDK-57333 
 </td><td> 739837
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Issue:- In previous implementation for BST index resolution, if cosq value -1 was used as input, cosq 0~7 were used to retrieve the index. but by default the max cosq number is 3. So the insertion was triggered.
<p>Fix:- replace cosq 0~7 by 0 ~ <tt>COS_MAX</tt>(unit) - 1.
</td></tr><tr><td> SDK-57341 
 </td><td> 780620
 </td><td> 56649_A0
 </td><td> When using "<tt>bcm_l2_learn_port_set</tt>" API to enable Class Based Learning for a trunk port, the function was returning error even though hardware programming was successful. This was because the API was trying to access another table which is not relevant for trunk ports and was using mod id value "-1" for this.
The issue was resolved by adding an early return after programming the relevant Trunk table.
</td></tr><tr><td> SDK-57343 
 </td><td> 782070
 </td><td> 56640_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56640_A1
56643_A1
56644_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
 </td><td> Communication between aging thread and other <tt>l2_addr_delete</tt> APIs thread is synchronized by binary semaphore. Ocasionally when the aging thread was stopped and restarted, there was a mismatch between semaphore give and take between aging thread and other API threads. This has been fixed.
</td></tr><tr><td> SDK-57349 
 </td><td> 781836
 </td><td> 88650_B1
88660_A0
 </td><td> L3 VRRP:
In some cases, if there was an error in the l3 vrrp APIs, the L3 mutex was not released.
The error has been fixed, and the mutex will always be released.
</td></tr><tr><td> SDK-57354 
 </td><td></td><td> 56840_A0
 </td><td> After clear operation through <tt>bcm_esw_l2_clear</tt>(), the data in structure <tt>_bcm_l2_match_ctrl</tt> was sometimes released while the backgroud thread L2MOD still needed to refer to the invalid data. This sometimes led to a crash of L2MOD.
Currently the data in <tt>_bcm_l2_match_ctrl</tt> won't be released in <tt>bcm_esw_l2_clear</tt>() in order to avoid this race condition.
</td></tr><tr><td> SDK-57434 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In previous releases, memory write operation to Ingress Pipeline tables during a <tt>ING_RESET_CONTROL</tt> Operation causes inadvertent writes to <tt>L3_TUNNEL</tt>, <tt>UDF_CAM</tt> and <tt>ING_FC_HEADER_TYPE</tt> Tables. In this release, a new flag <tt>SOC_F_MEM_CLEAR_HW_ACC</tt> indicating whether <tt>ING_HW_RESET_CONTROL</tt> is used to clear a table was added. <tt>ING_HW_RESET_CONTROL</tt> action will only happen during system initialization. In any other cases, table clear is done via table SLAM operations.
</td></tr><tr><td> SDK-57437 
 </td><td></td><td> 56850_A0
 </td><td> api <tt>bcm_vxlan_port_delete</tt> is working.
</td></tr><tr><td> SDK-57459 
 </td><td> 782198
 </td><td> 88650_B0
88650_B1
88660_A0
 </td><td> Fixing memory leak issue in TRILL.
Destroy TRILL port didn't free allocated memory (Add <tt>BCM_FREE</tt> to <tt>_bcm_dpp_mc_to_trill_remove</tt> function).
</td></tr><tr><td> SDK-57462 
 </td><td> 757100
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Fixed l2 show diagnostic output for VPLS interface.
</td></tr><tr><td> SDK-57469 
 </td><td> 780971
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Add support for split-horizon for MPLS-Tunnel-initiator.
This is useful when PWE label is built using EEI (label+push profile) and outlif that points to the EEDB is MPLS-Tunnel-initiator. In this case the PWE inherits it's orientation (HUB/SPOKE) from the next tunnel. 
To set the orientation of MPLS tunnel use <tt>bcm_port_class_set</tt> with class=bcmPortClassForwardEgress and port=mpls tunnel gport.
</td></tr><tr><td> SDK-57470 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Reflector (RFC-2544): Etherner Reflector program (Swaping MAC adresses) has been updated to support double tagged packets. IP program will only support single tagged packets.
</td></tr><tr><td> SDK-57476 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In earlier releases <tt>bcm_stat_group_create</tt> could get stuck in loop for egress SVP counters under scaled set-up. The issue was due to macro <tt>FLEX_COUNTER_DEFAULT_EGR_DVP_ATTRIBUTE_1_TABLE_POOL_NUMBER</tt> not being defined correctly for TD2, which led to endless loop when the egress flex counter pool were exhausted. It was defined to 5 for all the chips include TD2 but actually it should be less than 4 for TD2 as TD2 only has 4 egress flex counter pools.
<p>The fix was to define separate macro for TD2.
</td></tr><tr><td> SDK-57487 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Previously, 1-bit error reporting enabling logic and SER correction logic for all MMU tables that are CPU accessible on TD2 was not fully implemented. They have been implemented in this release.
</td></tr><tr><td> SDK-57498 
 </td><td> 783084
 </td><td> 56450_A0
56450_B0
 </td><td> In <tt>bcm_qos_map_create</tt> API an untagged PHB variable was being used uninitialized and that resulted in an unexpected <tt>ING_UNTAGGED_PHB</tt> entry being created. This was fixed toprevent untagged PHB variable from creating an unexpected <tt>ING_UNTAGGED_PHB</tt> entry.
</td></tr><tr><td> SDK-57500 
 </td><td> 783310
 </td><td> 56850_A0
56855_A0
56854_B0
56854_A0
56850_A1
56851P_A1
56851_A1
56850_A2
56851_A2
56851P_A2
56854_A2
56853_A2
56852_A2
56855_A2
56851_A0
56852_A0
56852_A1
56853_A0
56853_A1
 </td><td> In the previous release, the CPU port was not removed when the API <tt>bcm_multicast_egress_delete_all</tt> was called on Trident2. In this release, this issue has been addressed by removing the CPU port when the API <tt>bcm_multicast_egress_delete_all</tt> is called.
</td></tr><tr><td> SDK-57503 
 </td><td></td><td> 56340_A0
 </td><td> Problem: <tt>bcm_regex_policy_policer_attach</tt> results in a crash because of internal compatibility check being done between level0 and level1 meters.
Solution: Hierarchical meters are not supported on regex policies. Hence the compatibility check is disabled until we support hierarchical meters.
</td></tr><tr><td> SDK-57505 
 </td><td> 783296
 </td><td> 88650_A0
 </td><td> Fixed packet loss related to Reset CMIC interface in soft reset sequence.
</td></tr><tr><td> SDK-57507 
 </td><td> 776846
 </td><td> 88030_A0
88030_B0
 </td><td> Modification to <tt>CORE_PORT_MODE</tt> &amp; <tt>PHY_PORT_MODE</tt> must be made with MAC in reset. Not following this rule may leave MAC in a state that no packets can be received or all received packets are runts. Other than this symptom, the MAC doesn't report anything wrong.
</td></tr><tr><td> SDK-57515 
 </td><td> 780895
 </td><td> 88650_A0
88660_A0
 </td><td> In L2 learning, traversing over the MACT to get all the inserted entries while learning, may result in an infinite loop in some rare cases. This is due to mis-handling of a rare state in an internal buffer.
This is fixed.
</td></tr><tr><td> SDK-57525 
 </td><td> 782992
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Customer requested a mechanism to find out the entropy label used for a given vxlan flow.
<p>In order to provide the requested mechanism, <tt>bcm_switch_pkt_info_hash_get</tt> has been modified to return the entropy label used if the packet is for the vxlan.
<p>For packets encapsulated into VxLAN tunnels, Entropy label is generated using RTAG7 hash.
By using <tt>bcm_switch_pkt_info_hash_get</tt>(), entropy label used for VxLan can be retrieved.
<p>Note that entropy label is piggy backed  in <tt>dst_intf</tt>.
<p>Example)
 <tt>hash_info</tt>.flags = <tt>BCM_SWITCH_PKT_INFO_HASH_UDP_SOURCE_PORT</tt>  
 print <tt>bcm_switch_pkt_info_hash_get</tt>(unit, &amp;<tt>hash_info</tt>, &amp;<tt>dst_gport</tt>, &amp;<tt>dst_intf</tt>);   
</td></tr><tr><td> SDK-57533 
 </td><td></td><td> 56450_A0
5645_A0
56450_B0
56456_A0
56455_A0
 </td><td> Problem 1) Null get was returning value 0 which is valid phy master value (i.e. slave).
Fix 1) Added dummy <tt>get_master</tt>() in xgxs16g1l driver.
         Code is changed to return <tt>MS_NONE</tt> and that makes phy -master as NONE
<p>Problem 2: Proper medium was being detected in WARM-BOOT scenario only 
Fix 2: Corrected Copper/Fiber Medium detection concern in WC driver(which was applicable in Warmboot
         case only)
         Removed surrounding warm-boot condition in init part and now correct medium is returned
<p>Problem 3) Speed 1G was not advertised when port comes up as HG port and later converted to XE port due 
                 to  max-speed set to &gt;10000
Fix 3)  Corrected WC 1g speed issue by 
          checking additional <tt>XE_PORT</tt> type along with current speed before advertising speed
<p>Problem 4: TR 19 issue was happening with medium fiber i.e. test case was forcefully setting speed to 1G
Fix 4)  Added WC driver name check  before forcing speed to 1G and by-passed concern 
</td></tr><tr><td> SDK-57534 
 </td><td></td><td> 56450_A0
5645_A0
56450_B0
56456_A0
56455_A0
 </td><td> Problem 1) Problem was happening due to wrong use of portgroup config variable in init phase and
    auto portgroup creation in flex-io operation i.e. assumed RXAUI related port group setting while converting
    hg port to 2 lane XE ports.
<p>Fix 1) Removed auto portgroup creation decision in flex-io operation and now user needs to set portgroup 
         prior to flex-io operation and SDK initialization accordingly. 
         If User doesn't use <tt>auto_portgroup</tt> config variable and doesn't set portgroup config variable prior to
         flex-io operation, SDK will throw "Behavior not guaranteed" message
</td></tr><tr><td> SDK-57539 
 </td><td> 781348
 </td><td> 56640_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56640_A1
56643_A1
56644_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
 </td><td> Logical table Register settings of <tt>ACL_L2IP4_ONLY</tt> partition of external TCAM are not accommodating source mac and destination mac addresses in final key. In this JIRA, LTR settings of <tt>ACL_L2IP4_ONLY</tt> are modified to have source mac and destination mac at right offsets in final key.
</td></tr><tr><td> SDK-57543 
 </td><td> 781991
 </td><td> 56846_A0
56845_B0
56845_A2
56844_A0
56842_A0
56840_A0
56850_A0
56855_A0
56843_B0
56841_A3
56846_A1
56841_B0
56854_B0
56854_A0
56850_A1
56851P_A1
56851_A1
56850_A2
56851_A2
56851P_A2
56854_A2
56853_A2
56852_A2
56855_A2
56851_A0
56852_A0
56852_A1
56853_A0
56853_A1
 </td><td> In the previous release, when <tt>L2_MOD_FIFO</tt> mode was used and station movements happened, only one "ADD" notification would be issued on TD+, which was not incorrect. In this release, this issue has been improved by notifying one ""DEL" notification and one "ADD" notification in this kind of situation.
</td></tr><tr><td> SDK-57548 
 </td><td> 783511
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> It was reported that all packets appear to be store and forward on the port when the <tt>INIT_VALUE</tt> was set to 0x3 during chip initialization for 1G mode.
<p>The issue was fixed by modifying the egress credit to 12 for all the speeds lower than 10Gbps.
</td></tr><tr><td> SDK-57550 
 </td><td> 777385
 </td><td> 56450_A0
56450_B0
 </td><td> <tt>THDO_QCONFIG_CELL</tt> could not be configured for packet processing ports greater than 128. This issue has been fixed to support complete range of packet processing ports(sub ports).
</td></tr><tr><td> SDK-57556 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> corrected the test script by add the flag <tt>BCM_IPMC_RPF_FAIL_TOCPU</tt> to set value of <tt>IPMC_EXPECTED_L3_IIF_MISMATCH_TOCPU</tt> to 1
</td></tr><tr><td> SDK-57558 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In previous releases, <tt>bcm_vxlan_stat_detach</tt> still took high execution time because of some unnecessary memory operation and extra overhead. In this release, we cut some unnecessary memory operations and redundant codes to save time, therefore execution time are reduced.
</td></tr><tr><td> SDK-57571 
 </td><td></td><td> 56540_A0
56540_B0
 </td><td> On TR3 device, if the number of COSQs is changed from default value (4) to 8, after the warm boot recovery, the number of COSQs still shows as 4, since this information is not stored in the persistent storage (scache). The issue is fixed by storing this information in scache and retrieving it during warm boot level 2 recovery.
</td></tr><tr><td> SDK-57582 
 </td><td> 782398
 </td><td> 56624_A0
56224_A0
 </td><td> Dirty bit is not set in case of remote link failure. So, the resulting state may not be in sync with the scache in cases of auto sync. Change is to set the dirty bit in case of link update.
<p>Also, <tt>link_mask2</tt> is not being recovered properly after warmboot. Now, this will be updated to valid up ports.
</td></tr><tr><td> SDK-57584 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> BFD: When calling <tt>bfd_endpoint_create</tt>() with type== bcmBFDTunnelTypeMpls an additional TCAM entry is needed. Due to limited resources only 128 TCAM entries may be used for OAM/BFD. This JIRA verifies that this amount has not been exceeded and that TCAM indexes used are in the range 0-127.
</td></tr><tr><td> SDK-57600 
 </td><td> 780870
 </td><td> 88650_A0
88660_A0
 </td><td> Add push profile free when deleting PWE.
Fixes resource push profile exhaustion when adding several MPLS tunnels and PWEs.
</td></tr><tr><td> SDK-57625 
 </td><td> 786811
 </td><td> 56340_A0
 </td><td> <tt>bcm_cosq_gport_attach</tt> is returning failure for some ports (<tt>RESOURCE_UNAVAIL</tt>) due to unavailability of L0 nodes.scheduler list is not reset completely on mmu soc reinitialize.Fixed the scheduler list reset.
</td></tr><tr><td> SDK-57627 
 </td><td> 787010
 </td><td> 56450_A0
 </td><td> Provided the API sequence on how to configure the burst rate
</td></tr><tr><td> SDK-57630 
 </td><td></td><td> 88660_A0
 </td><td> OAM: fixed the <tt>loss_farend</tt>/nearend fields to return correct values (expressed in 100th of percent) in <tt>bcm_oam_loss_get</tt>()
</td></tr><tr><td> SDK-57650 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Failover ID values '-1' &amp; '-2' are reserved for FEC Protection as 'No Protection' and 'Facility Protection' respectively.
Those reserved values  failed with an internal error.
Now those values, when used with the <tt>BCM_FAILOVER_WITH_ID</tt> flag, produce an error that states that the value is out of range.
</td></tr><tr><td> SDK-57652 
 </td><td> 781357
 </td><td> 88650_A0
88660_A0
 </td><td> Ring Port: There was an error in <tt>bcm_vlan_port_find</tt>() where the returned <tt>failover_port_id</tt> was incorrect for a G.8032 Ring Port. The error has been fixed, and the <tt>failover_port_id</tt> is now returned correctly.
</td></tr><tr><td> SDK-57663 
 </td><td> 783147
 </td><td> All
56846_A0
56844_A0
56846_A1
 </td><td> Field groups auto expansion is not recovered in Level 2 Warm Boot. Allocated an unused bit in scache layout of field module to store the groups auto expansion capability.
</td></tr><tr><td> SDK-57669 
 </td><td> 770442
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Added validity check that returns an error when user configure cos profile that is &gt; 16 for PWE P2P.
</td></tr><tr><td> SDK-57689 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Changes to interrupt handling as implemented in Diag shell reference application:
 - Unmasked port interrupts by default
 - Fixed some tables to be designated as dynamic and not configuration.
Changes to reference application, no changes to the driver and default behavior.
</td></tr><tr><td> SDK-57691 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> bcm shell command "diag ssdump" was disabled. It's now enabled.
</td></tr><tr><td> SDK-57707 
 </td><td> 787634
 </td><td> 56640_A0
 </td><td> For some MACs in L2 cache, BPDU flag was not being set.
This was causing ports to drop BPDUs when in STP blocked state.
<p>This issue was due to overwriting of flags for these MACs.
Corrected the flags to CPU | BPDU.
</td></tr><tr><td> SDK-57725 
 </td><td> 788276
 </td><td> 88030_A0
88030_B0
 </td><td> src/appl/diag/ledproc.c:
Change the previous common code into C3 dedicated code, in order to not affect other modules.
</td></tr><tr><td> SDK-57739 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> add a new case AT_L3MC_Rep_009 to verify the flag of <tt>BCM_IPMC_RPF_FAIL_DROP</tt>
</td></tr><tr><td> SDK-57743 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In previous release, five variables were calculated based on <tt>stat_counter_id</tt>, and three of them were used as subscript to access arrays without checking their legal ranges. Therefore, memory access violation happened. This problem has been resolved through adding proper check to those parameters to ensure the validity of their values.
</td></tr><tr><td> SDK-57744 
 </td><td> 787141
 </td><td> 88750_A0
88650_A0
 </td><td> <tt>bcm_fabric_link_status_get</tt> retrieves several link status indications. some of these link indications are sticky and should be cleared. This indications changed to be cleared on read.
Meaning that this API retrieves the status since the last call. 
</td></tr><tr><td> SDK-57745 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> In Field Processor, the validation of the action size was changed incorrectly, such that it verifies that the size is smaller the MAX size instead of smaller or equal to it. This is fixed.
</td></tr><tr><td> SDK-57749 
 </td><td></td><td> 56340_A0
56640_A0
 </td><td> BCM56640, BCM56340 support Software Aging. The L2 entries are aged out if HITSA and HITDA are both 0.
New capability is added to age out entries based on ONLY HITSA and not consider the HITDA. 
This is done by setting the config property '<tt>l2x_age_only_on_hitsa</tt>' to 1. 
</td></tr><tr><td> SDK-57751 
 </td><td></td><td> 56340_A0
56640_A0
 </td><td> BCM56640, BCM56340 support Software Aging. The L2 entries are aged out if HITSA and HITDA are both 0.
New capability is added to age out entries based on ONLY HITSA and not consider the HITDA. 
This is done by setting the config property '<tt>l2x_age_only_on_hitsa</tt>' to 1. 
</td></tr><tr><td> SDK-57769 
 </td><td> 784039
 </td><td> 56334_B0
56334_A0
 </td><td> In previous SDK releases, there are no SER correction support for several MMU blocks on Enduro, and thus once a parity error occurs in these blocks, it cannot be corrected and the error will be detected continuously.
Fixed overview:
The feature of SER correction for these MMU blocks on Enduro have been implemented. In addition, SER injection function has been added as well.
</td></tr><tr><td> SDK-57774 
 </td><td> 781863
 </td><td> 56850_A2
 </td><td> In the previous release, when the deleted l3 interface which had been added into the multicast group was re-created with the same id, the l3 interface was not attached to the multicast group, which was incorrect. In this release, this issue has been addressed by ensuring that the next hop index will be allocated and de-allocated by multicast module when the l3 interface's encapsulation id is added into and deleted from the multicast group.
</td></tr><tr><td> SDK-57775 
 </td><td> 788841
 </td><td> 56150_A0
 </td><td> Fixed possible race condition in SOC initialization routines.
</td></tr><tr><td> SDK-57791 
 </td><td> 774941
 </td><td> 88650_A0
 </td><td> In Policer module, in some cases <tt>bcm_policer_create</tt> fails incorrectly when the mode is bcmPolicerModeCoupledCascade, due to an internal software usage of an uninitialized structure.
This is now fixed.
</td></tr><tr><td> SDK-57802 
 </td><td> 788015
 </td><td> 88650_A0
88650_B0
88660_A0
 </td><td> Fixed failure when deleting MPLS label in ILM table when using <tt>bcm_mpls_tunnel_switch_delete</tt> and SOC property '<tt>mpls_termination_label_index_enable</tt>=1'
</td></tr><tr><td> SDK-57812 
 </td><td></td><td> 88650_B0
88660_A0
 </td><td> When using external TCAM for ACL and/or forwarding databases, its configuration was not restored after warmboot.
A preliminary support is added to restore external TCAM configuration during warmboot.
</td></tr><tr><td> SDK-57813 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
88670_A0
 </td><td> In previous version, <tt>BCM_VLAN_PORT_WITH_ID</tt> wasn't working in forward group.now support this function.
</td></tr><tr><td> SDK-57821 SDK-58760
 </td><td></td><td> 88650_A0
88660_A0
88670_A0
 </td><td> BFD: In <tt>bcm_bfd_endpoint_create</tt>() the field <tt>remote_flags</tt> was changed to monitor the Flags field on incoming BFD frames (as opposed to monitoring Flags in <tt>bcm_bfd_endpoint_get</tt>() as well as setting the Flags on outgoing packets).
The field <tt>local_flags</tt> was added and is used to control the Flags on outgoing BFD frames and (this is consistent with fields such as <tt>remote_state</tt>/<tt>local_state</tt>, <tt>remote_daig</tt>/<tt>local_diag</tt>, etc.).
</td></tr><tr><td> SDK-57828 SDK-56669
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> BFD: addition of the filed <tt>loc_clear_threshold</tt> for <tt>bcm_bfd_endpoint_create</tt>().
This determines the amount of BFD frames received by the OAMP before a loss of continuity is cleared and a bcmBFDEventEndpointTimein event is triggered.
This may be set at 0,1,2,3. Default behavior remains unaffected.
</td></tr><tr><td> SDK-57844 
 </td><td></td><td> 56850_A0
 </td><td> In earlier release, adding one more <tt>IPV6_64B</tt> entry to table already with full <tt>IPV6_64B</tt> entries and some free <tt>IPV6_128B</tt> entries would result in inconsistency in software tables. Then trying to insert another route with same prefix would cause the process to fall into an infinite loop. This issue has been resolved.
</td></tr><tr><td> SDK-57853 
 </td><td></td><td> 88660_A0
 </td><td> Trill warmboot. Sw state trill alloc link list size was not correctly calculated at warmboot trill restore, causing incorrect size after warmboot
</td></tr><tr><td> SDK-57863 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> BFD: Adding accelerated endpoint with <tt>bcm_bfd_endpoint_create</tt>() while in <tt>local_discr</tt> field any of the bits 13-15 is set, caused error.
</td></tr><tr><td> SDK-57866 
 </td><td></td><td> 88650_A0
 </td><td> In Rx trap module, in the allocation of a programmable trap, the error validation was incorrect. Fixed.
</td></tr><tr><td> SDK-57889 
 </td><td> 789898
 </td><td> 56340_A0
 </td><td> Aging thread runs independently , wait on semphore for age time and wakes up &amp; runs the bulk operaion. L2 bulk operation stops and starts the aging thread. Here aging thread does not account for elapsed time
it has already spent on semaphore.Lets say, aging thread already spent 25 sec and port delete operation 
is called at that time, aging thread stopped and restarted. Here MAC will be deleted at (25 + 30) sec =
45 sec. This is adjusted by keeping a log of elapsed time on semaphore during aging thread exit 
and readjusting it, during next time aging thread started. 
</td></tr><tr><td> SDK-57911 
 </td><td> 789281
 </td><td> 88650_A0
 </td><td> The previous is that pass the <tt>NULL</tt> pointer of uc/mc/bc for <tt>_bcm_petra_vlan_flooding_per_lif_get</tt>() caused the segment fault.
The fix is that pass the uc/mc/bc for <tt>_bcm_petra_vlan_flooding_per_lif_get</tt>() and get the value by the uc/mc/bc.
</td></tr><tr><td> SDK-57942 
 </td><td></td><td> 88750_A0
88750_B0
 </td><td> When using BCM88750 repeater,
due to miss-configuration some corrupted cells might be dropped at the repeater ingress while it should be dropped at the destination device.
Fixed.
</td></tr><tr><td> SDK-57952 
 </td><td></td><td> 56640_A0
 </td><td> In TR3 device we were not able to delete last set of vlan service queues in the given port.
We are now able to delete all the vlan service queues.
</td></tr><tr><td> SDK-57958 
 </td><td> 782029
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> MPLS bug fixed: when creating and deleting a tunnel label and PWE <tt>WITH_ID</tt>, if they are re-created and the lif ids swapped, the tunnel termination fails and the tunnel label is used for forwarding. Issue is due to uninitialized values (Destination and Destination valid) when setting MPLS tunnel termination in LIF table.
</td></tr><tr><td> SDK-57961 
 </td><td> 777725
 </td><td> 56640_B0
56850_A2
 </td><td> V4 routes take half entry in shared defip tables. There can be some defip indexes containing V4 routes that does not have other half filled due to prefix restrictions. When SDK tries to recover number of indexes used for V4 prefixes in defip tables, it divides total number of routes by half but does not account about half entries. Due to this, SDK gives wrong number for total available 64/128 V6 route entries. This lead to overwriting of already existing routes in the defip tables.
<p>The fix is to count the number of half entries in defip tables and then use them during derivation of total free entries left in defip table for 64V6 and 128V6. This way SDK can return <tt>BCM_E_FULL</tt> error at table full and will not ov
</td></tr><tr><td> SDK-57962 
 </td><td> 747614
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> In L2 MAC table, when using API <tt>bcm_l2_addr_delete_by_vlan_port</tt>() to flush all the entries on a specific PWE, all the entries that are on the same MPLS-FEC as the specified PWE were flushed.
This is fixed and now only entries that are on the specific PWE (PWE-label+MPLS-FEC) are flushed.
</td></tr><tr><td> SDK-57969 
 </td><td> 790396
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In earlier releases, <tt>bcm_ipmc_traverse</tt> did not get IPMC v6 entries after level 2 warmboot. "ipmc ip6table show" shows nothing, but the HW table <tt>L3_ENTRY_IPV6_MULTICAST</tt> showed all installed entries.
<p>There were two root causes as follows:
1. The first <tt>L3_IPMC</tt> entry (index == 0) was reserved for default behavior for all chips except Katana and Katana2. In cold boot, we can find it was initilized in routine <tt>bcm_esw_ipmc_init</tt>. But routine <tt>_bcm_tr_ipmc_reinit</tt> considered it as normal <tt>L3_IPMC</tt> entry. 
2. Flag of <tt>BCM_L3_IP6</tt> was not set when recovering <tt>L3_ENTRY_IPV6_MULTICAST</tt> to l3 entry in warmboot. This caused the 'ipmc ip6table show' not work since low level driver considered it as IPV4 entries. 
<p>The solutions are as follows:
Routine <tt>_bcm_tr_ipmc_reinit</tt> has been changed to reserve first <tt>L3_IPMC</tt> entry for the default behavior for both Kanata and Katana2.
<p>Flag <tt>BCM_L3_IP6</tt> has been set in recovering <tt>L3_ENTRY_IPV6_MULTICAST</tt> to l3 entry in warmboot in this release.
</td></tr><tr><td> SDK-57975 
 </td><td> 790586
 </td><td> 56450_B0
 </td><td> VLAN parameter check was being verified for both VPLS and MIM VPNs, though the VPN is of VPLS type. Fixed to validate VLAN only for the matching VPN type VPLS or MIM accordingly.
</td></tr><tr><td> SDK-57977 
 </td><td> 769739
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> In Ingress Field Processor, cascaded Field groups are using the bcmFieldActionCascadedKeyValueSet action to transmit an action value as part of the key value. This action is always performed in the HW. If unset, a zero value is expected to be transmitted.
<p>The entry TCAM action encoding was incorrect if:
1. The Field group ASET was including bcmFieldActionCascadedKeyValueSet
2. No action value was explicitly set for bcmFieldActionCascadedKeyValueSet (even a zero value)
<p>This is fixed.
</td></tr><tr><td> SDK-57984 
 </td><td></td><td> 56640_A0
56640_A1
56640_B0
 </td><td> After the successful warm boot recovery of VFP configuration with flex stat on TR3, if one of the field qualifiers is deleted, reinstalling of field entry fails with invalid parameter.
The issue is fixed by passing the right parameter (<tt>offset_mode</tt>) in the internal function while updating flex stat for the field entry.
</td></tr><tr><td> SDK-57994 
 </td><td></td><td> 88650_A0
 </td><td> In L3 IP applications, the max VRF value is limited to 4095 in HW, but a segmentation fault was occurring when using a VRF larger than 255. This was due to a warmboot engine variable saving a VRF bitmap with an inappropriate size.
Fixed. ISSU is handled transparently.
</td></tr><tr><td> SDK-57998 
 </td><td></td><td> 56640_A0
56340_A0
 </td><td> For BCM56640 and BCM56340, if config property <tt>l2x_age_only_on_hitsa</tt> is set, aging occurs only on HITSA, ignoring HITDA. In accordance with this the behavior of <tt>BCM_L2_HIT</tt> flag (<tt>bcm_l2_addr_t</tt> structure) is also changed, when this config variable is set.
If the config variable is not set, <tt>BCM_L2_HIT</tt> flag is set for the entries passed to callbacks which have either HITSA or HITDA set. Also, in cases when an entry is being added, if this flag is set in the input <tt>bcm_l2_addr_t</tt> structure, both HITSA and HITDA will be set for the added entry.
If the config variable is set, <tt>BCM_L2_HIT</tt> flag is set for those entries which have  HITSA set.  In case adding an entry, if this flag is set in the input <tt>bcm_l2_addr_t</tt> structure, only HITSA is set. To set HITDA, <tt>BCM_L2_DES_HIT</tt> flag has to set explicitly.
Similar changes are reflected in l2 show diag shell command.
</td></tr><tr><td> SDK-57999 
 </td><td></td><td> 88650_A0
 </td><td> In L2CP traps set via <tt>bcm_l2_cache_set</tt>, the handling of L2CP trap index of type Multicast and ports was incorrect. This is fixed.
</td></tr><tr><td> SDK-58006 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Cint: <tt>cint_ip_tunnel</tt>.c.
ip tunnel was created in cint with incorrect ttl and dscp. Caused by SDK-55162. 
Consequently, checking ttl or dscp values in ip tunnels were failing when using <tt>cint_ip_tunnel</tt>.c. 
</td></tr><tr><td> SDK-58016 
 </td><td></td><td> 56850_A2
 </td><td> In the previous release, when configuring same Virtual Port (NIV Port) under multiple Mirroring sessions to get multiple copies, the function "<tt>_bcm_xgs3_mtp_slot_port_indexes_get</tt>" was called with the input port" parameter set to be physical gport.
In this release, this function is called with the input port" parameter set to be physical unit port in this situation.
</td></tr><tr><td> SDK-58023 
 </td><td> 736724
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Added support for Split-Horizon filter in AC P2P VSI service.
Up until now AC P2P service set always as Spoke, now user can configure and decide to set it either as Spoke or Hub using <tt>BCM_VLAN_PORT_NETWORK</tt> flag.
</td></tr><tr><td> SDK-58043 
 </td><td> 790661
 </td><td> 56450_A0
56450_B0
 </td><td> <tt>mpls_port</tt> add for VPLS configuration was using uninitialized pp port for given modid and portid. Fixed to convert given modid and portid to appropriate pp port before actual use. Another issue was that during subport trunk add for mpls VPLS port <tt>source_trunk_map</tt> table for the required entry is not configured appropriately due to incorrect modid and portid use internally. Fixed to convert pp port to appropriate modid and portid to update the required entry in <tt>source_trunk_map</tt> table.
</td></tr><tr><td> SDK-58047 
 </td><td></td><td> 56850_A0
 </td><td> Problem Statement: DMVOQ functionality is not working
Incorporated all the required change in SDK to make DMVOQ to work,
for ex: Programming <tt>E2ECC_TX_PORTS_NUM</tt>, Programming of <tt>INTFI_CFG</tt>,Programming of <tt>CONGESTION_STATE_BYTES</tt> , implementation to support higig trunk ,Warmboot changes, Hw_index allocation is not proper, handled all the error cases ,Corrected the programming of <tt>FC_MAP_TBL</tt>, <tt>FC_ST_TBL</tt>, <tt>MMU_INTFI_OFFSET_MAP_TBL</tt>
</td></tr><tr><td> SDK-58081 
 </td><td> 791991
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Customer found rate limit on broadcast traffic was affected by changing DLF rate limit on the same port on TD2.
It was the expected behavior in the system but some special improvement could be implemented for TD2.
Now an improvement has been added to reduce this impact.
</td></tr><tr><td> SDK-58087 
 </td><td> 792172
 </td><td> 56450_A0
56450_B0
 </td><td> Subscriber delete was failing as the corresponding entry in <tt>REPL_LIST</tt> list was not removed when there are no <tt>EGR_L3_INTF</tt>/<tt>EGR_L3_NEXT_HOP</tt> interfaces valid for replication of subscriber traffic and instead a new entry with <tt>NULL</tt> interfaces was added.
The user is now able to delete the subscriber  replication entries after correcting the behavior to remove the entry from the replication list when there are no replication interfaces.
</td></tr><tr><td> SDK-58102 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> OAM: The following bug was fixed: Protection packets might not be sent until an event is registered.
</td></tr><tr><td> SDK-58119 
 </td><td> 792999
 </td><td> 56850_A2
 </td><td> Issue :- Qualifying SrcVxlanGport in Lookup Stage returns Internal Error
<p>Fix :- During Stage Lookup Qualifiers init routine, assigning secondary Qualifier for SrcVxlanGport was missed out. Hence the issue. Added Secondary qualifiers for SrcVxlanGport
</td></tr><tr><td> SDK-58132 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> In some cases in bcm88650_A0, bcm88650_B0 and bcm88660_A0 (when the SOC property <tt>RATE_COLOR_BLIND</tt> is set to 0) the driver would crash when calling <tt>bcm_policer_destroy_all</tt>. This is due to a software bug where uninitialized memory is used.
<p>This issue is now fixed.
</td></tr><tr><td> SDK-58135 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> PWE bug fixed: When deleting mpls port, push profiles of the PWE is deleted as well as all the push profiles of the MPLS tunnels that the PWE is pointing on.
</td></tr><tr><td> SDK-58136 
 </td><td> 760903
 </td><td> 88650_B1
 </td><td> The original issue was that ARAD PCIe controller dropped the completion when accessing the null space CMIC descriptor address that caused the CMIC logic to wait for completion forever.
The current fix is that we enable the ENABLE PURGE IF USERIF TIMESOUT in  which case CMIC HW will inject a fake completion after timer expires and injects a ECRC error so that DMA engines will come out gracefully.
</td></tr><tr><td> SDK-58138 
 </td><td> 791882
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> PWE P2P: Model was always Uniform, no matter what user configuration is. This was fixed - both Uniform and Pipe models can be configured.
</td></tr><tr><td> SDK-58140 
 </td><td> 792399
 </td><td> 88650_B1
88660_A0
 </td><td> Prevented false alarm memory ECC errors from happening when using the direct base queue to modport mapping mode, and not configuring queue mappings for queues that receive traffic or credits for a scheduler.
</td></tr><tr><td> SDK-58144 
 </td><td> 792827
 </td><td> 56224_B0
 </td><td> Multicast init fails during warmboot in <tt>bcm_esw_mcast_init</tt>() on some flavors of RAVEN chipset which do not have native L3 support. Provided a runtime check in <tt>bcm_esw_mcast_init</tt>() to check whether L3 features are supported on chipset.
</td></tr><tr><td> SDK-58188 
 </td><td> 791948
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> In L2 MAC table, when using API <tt>bcm_l2_replace_match</tt>() with flag <tt>BCM_L2_REPLACE_PROTECTION_RING</tt>, the user supplied port mask was not used.
This is fixed and now port mask is taken into consideration correctly.
</td></tr><tr><td> SDK-58194 
 </td><td></td><td> 88650_A0
 </td><td> Fix bug in print encapsulation name in case of SOP only encapsulation.
No effect on customer application
</td></tr><tr><td> SDK-58198 
 </td><td></td><td> 88650_A0
 </td><td> Fixed - <tt>bcm_port_loopback_set</tt>() with <tt>BCM_PORT_LOOPBACK_PHY_REMOTE</tt> does not work as expected
</td></tr><tr><td> SDK-58208 
 </td><td></td><td> 88650_A0
 </td><td> In external TCAM ACL, the actions are different between BCM88650 and BCM88660 due to the common IP database in BCM88660:
- The first action (bcmFieldActionExternalValue0Set) can be used for forwarding (or ACL) in both devices, with size of 48 bits
- The second action (bcmFieldActionExternalValue1Set) can be used for RPF (or ACL) in BCM88650, with size of 16 bits. In BCM88660, it can be used as ACL with size 32 bits.
- The second action (bcmFieldActionExternalValue2Set) can be used for RPF (or ACL) in BCM88660, with size of 16 bits. In BCM88650, it can be used as ACL with size 32 bits.
- The third action (bcmFieldActionExternalValue3Set) can be used as ACL with size 24 bits.
<p>The distinction between BCM88650 and BCM88660 devices was performed only according to the compilation flag (<tt>BCM_88660_A0</tt>) and not according to the unit type.
</td></tr><tr><td> SDK-58237 
 </td><td></td><td> 56850_A2
 </td><td> Added 10G XFI FEC support.
</td></tr><tr><td> SDK-58243 
 </td><td> 790578
 </td><td> 88650_A0
88640_A0
88670_A0
 </td><td> FP: Fixed cases in which upper bits of the result were not initialized to Zeros while getting a Field.
</td></tr><tr><td> SDK-58275 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> OAM: Following bug was fixed:
When soc property "<tt>custom_feature_egress_snooping_advanced</tt>" is on and calling <tt>bcm_oam_endpoint_action_set</tt>() with the destination set as a trap, function may fail to properly update the classifier for up MEPs.
</td></tr><tr><td> SDK-58315 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Ring Protection: Added support for an optional sequence to perform Fast Flush. The sequence is comprised of encoding the Ring Port (FEC) as a gport of type FORWARD Port and calling <tt>bcm_l2_replace</tt> with <tt>BCM_L2_REPLACE_MATCH_DEST</tt> instead of <tt>BCM_L2_REPLACE_PROTECTION_RING</tt>.
</td></tr><tr><td> SDK-58345 
 </td><td></td><td> 56850_A0
56855_A0
56850_A2
 </td><td> In the previous release, customer found the flex counters were not cleared after detaching.
It was because on TD2, SDK only cleared X-pipe counters after detaching, but not Y-pipe counters.
Now this issue has been fixed on TD2.
</td></tr><tr><td> SDK-58358 
 </td><td></td><td> 88650_A0
88660_A0
88670_A0
 </td><td> Jericho Protection: BCM API added for all Jericho Protection enhancements.
Separate Protection tables are implemented.
For Arad, the usage of <tt>bcm_failover_create</tt>() is modified and it's required to specify a failover type by
setting one of the failover type flags: <tt>BCM_FAILOVER_FEC</tt>, <tt>BCM_FAILOVER_INGRESS</tt> &amp; <tt>BCM_FAILOVER_L2_LOOKUP</tt>.
The failover ID itself is now encoded with a failover type.
</td></tr><tr><td> SDK-58360 
 </td><td></td><td> 88750_A0
88650_A0
 </td><td> <tt>bcm_fabric_link_status_get</tt> retrieve the fabric link status.
This specific link status should be cleared on read. However, the entire quad was cleared .
Fixed.
</td></tr><tr><td> SDK-58364 
 </td><td> 794704
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In previous release, when customers changed one port encapsulation on TD2, the Rx Max Size was reset but Egress MTU is not.
This was an omission and has been resolved.
</td></tr><tr><td> SDK-58375 
 </td><td> 795815
 </td><td> 88750_A0
88750_B0
 </td><td> Fixed a bug in "diag queues" command, the command previously printed a wrong occupied link number.
</td></tr><tr><td> SDK-58382 
 </td><td></td><td> 56243_B0
56243_A0
56242_B0
 </td><td> When one port is moved to PHY loopback on 56243_A0, it turns all 4 ports in loopback. Provided a protective check in 56243_A0 internal phy driver to use broadcast mode of PHY config only when lane 0 is disabled, else use single lane config mode.
</td></tr><tr><td> SDK-58392 
 </td><td></td><td> 88660_A0
 </td><td> <tt>bcm_port_enable_set</tt> bug fix: In case that 2 CAUI ports and ELK are configured, The CGE1 traffic was dropped when the ELK port was disabled.
</td></tr><tr><td> SDK-58393 
 </td><td> 794812
 </td><td> 56541_A0
56540_A0
56540_B0
56541_B0
 </td><td> Wrong meter table size configuration in BCM5654X devices resulting in failure of <tt>bcm_policer_destroy</tt>, is fixed.
</td></tr><tr><td> SDK-58398 
 </td><td> 793706
 </td><td> 88750_A0
 </td><td> All the SER monitor registers set by default in order to enable interrupt assertion upon memory fault.
When interrupt asserted, SW can log and perform a corrective action if needed.
</td></tr><tr><td> SDK-58407 
 </td><td> 769153
 </td><td> 56640_A0
 </td><td> On TR3 device ,for HSP ports the sdk was not programming <tt>HES_PORT_CONFIG</tt> register , hence the scheduling was not proper .As part of the fix we are programming it properly .
</td></tr><tr><td> SDK-58409 
 </td><td></td><td> 56640_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56640_A1
56643_A1
56644_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
 </td><td> Previously, the software control structure for IBOD was not stored in scache, and hence during warmboot, the state was lost, which causeed the workaround (IBOD WAR) to run again on all the effected ports. Now, the related fields in the control structure are stored in scache and are recovered during warmboot.
</td></tr><tr><td> SDK-58410 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> OAM: when calling <tt>bcm_oam_action_set</tt>(), a newly allocated trap code will be returned via the field <tt>rx_trap</tt>, when applicable.
</td></tr><tr><td> SDK-58423 
 </td><td> 793902
 </td><td> All
56850_A0
56850_A1
56850_A2
 </td><td> In the previous release, the function <tt>rx_higig2_vpn_resolve</tt> didn`t parse VNI field in HIGIG2 header when it was VxLan. In this release, support has been added to parse VNI field in HIGIG2 header when it is VxLan.
</td></tr><tr><td> SDK-58425 
 </td><td> 796179
 </td><td> 56440_B0
56450_B0
 </td><td> For BCM5645x devices, support has been added for L3 packets, ingressing from trunk member ports, to be able to be trapped to CPU.
</td></tr><tr><td> SDK-58428 
 </td><td> 796509
 </td><td> 56450_B0
 </td><td> Fixed the issue of CCM RX not working after deletion and re-creation of RMEP due to wrongful deletion of OAM lookup key as part of RMEP delete.
</td></tr><tr><td> SDK-58445 
 </td><td></td><td> 56640_A0
56640_A1
56640_B0
 </td><td> Problem: When the cascaded TCAMs are present, and the lookups are configured to include L2, L3, and L2+ACL, the system will forward a few thousand packets and then hang when the ESM bandwidth is oversubscribed. This will manifest itself as an ETU response FIFO underrun.
Solution: Number of lanes to the TCAM interface is different when there are multiple TCAMs present. Fixed the issue by setting the number of lanes based on the number of TCAMs present in the system.
</td></tr><tr><td> SDK-58460 
 </td><td></td><td> 88660_A0
 </td><td> Routing Over VXLAN feature in <tt>BCM_88660</tt>.
At ingress node, UDP length calculation was incorrect when sending a packet from TOR to Overlay network. 
API require to configure per native router interface, the expected amount of native Ethernet VLAN tags to be built at the native Ethernet header. 
BCM calling sequence: when creating the native router interface: (<tt>bcm_l3_intf_create</tt>), fill the member: <tt>native_routing_vlan_tags</tt> from <tt>bcm_l3_intf_t</tt> with the expected amount of native Ethernet vlan tags to be built at the native Ethernet header.  see <tt>cint_vxlan_roo</tt>.c for more information.
See <tt>cint_vxlan_roo</tt>. 
</td></tr><tr><td> SDK-58461 
 </td><td> 794274
 </td><td> 88650_A0
88650ACP_A0
88650_B0
88650_B1
88660_A0
 </td><td> Problematic part is removed.
there should be no limitation to 16 indices.
</td></tr><tr><td> SDK-58462 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> Uninitialized variables were found in both PMF compare operation function and in LIF &amp; RIF profile management function. This is fixed.
</td></tr><tr><td> SDK-58463 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> In TCAM management, a sorted linked-list is used to handle the entry priority ranges: given a priority, the sorted list indicates the acceptable line range to insert a new TCAM entry.
When looking to insert / get a node of this linked-list, the lookup function scans the list until it founds a node with lower priority and a node with higher priority. 
This lookup was not always correct. This is fixed.
</td></tr><tr><td> SDK-58466 
 </td><td></td><td> 88650_B0
88650_B1
88660_A0
 </td><td> Required changes in SDK in order to have full support of external TCAM configuration restoration after warmboot.
Note that this support requires the use KBP-SDK 1.2.5 and higher. 
</td></tr><tr><td> SDK-58472 
 </td><td> 793850
 </td><td> 88650_B1
 </td><td> remove ECC 1bit and 2 bit monitoring from ILKN memories of lanes that are not in use.
</td></tr><tr><td> SDK-58487 
 </td><td></td><td> 88650_B0
88650_B1
88660_A0
88670_A0
 </td><td> In Ingress Field Processor, for field groups of bcmFieldGroupModeDirectExtraction type, if an entry has a 1x1 mapping (action=extracted-field) then use action macro FES instead of FEM.
</td></tr><tr><td> SDK-58493 
 </td><td></td><td> 88650_A0
 </td><td> Masking all interrupt are not done for all instances of interrupt register. This is fixed now.
Memories shadows did not updated by HW memory values after initialization sequence. This is also fixed.
</td></tr><tr><td> SDK-58528 
 </td><td> 688507
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> OAM: Bug in OAM classification exposed only when adding the build option <tt>DEBUG_OPTIMIZE</tt>=TRUE. This bug causes incorrect oam module initialization when running in optimized mode.
</td></tr><tr><td> SDK-58553 
 </td><td> 796964
 </td><td> 56744_A0
 </td><td> In previous release, HG port with 25G speed config couldn't be added to config file.
<p>HG port with 25G speed config was enabled by modifying SDK to accept such configuration.
</td></tr><tr><td> SDK-58565 
 </td><td> 797854
 </td><td> 56850_A2
 </td><td> In the previous release, in <tt>bcm_tr2_vlan_gport_add</tt>, the <tt>ing_port_bitmap</tt> was overwritten by IPMC groups member port bitmap when we updated the <tt>ing_port_bitmap</tt> in <tt>VLAN_TAB</tt>. In this release, the <tt>ing_port_bitmap</tt> is read out first and then ORed with IPMC groups member port bitmap.
</td></tr><tr><td> SDK-58568 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> In IPv6 Multicast FLP program, a new SOC property (<tt>custom_feature_ipv6_mc_forwarding_disable</tt>) is implemented.
When this SOC property is enabled, the IPv6 Multicast FLP program is initialized with default values, where no key (and no lookup) is defined.
</td></tr><tr><td> SDK-58596 
 </td><td></td><td> 56850_A2
 </td><td> Redirect to NIV virtual port from Ingress Stage Field Processor support was missing in earlier releases. The support is now added.
</td></tr><tr><td> SDK-58630 
 </td><td> 792060
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In previous releases, command "l3 ip6route show" would result in a cause when ALPM was enabled. This has been resolved by adding proper check to return feature unavailable instead of crashing when ALPM is enabled.
</td></tr><tr><td> SDK-58649 
 </td><td> 792420
 </td><td> 88660_A0
 </td><td> On Arad+, when calling <tt>bcm_trunk_set</tt> where all members have <tt>BCM_TRUNK_MEMBER_INGRESS_DISABLE</tt> set, an assert occurs.
This assertion was fixed.
</td></tr><tr><td> SDK-58651 
 </td><td></td><td> 56850_A0
56850_A1
 </td><td> Issue :- Hashing is not happening when FP RedirectEgressNextHop action is used to forward packets to ECMP group.
Solution:- 
<p>When the IFP wants to route an IP packet to an ECMP group, it must use
the <tt>L3_SWITCH</tt> action. This will ensure that the correct ECMP hash
selectors are applied to the packet.  (bcmFieldActionL3Switch)
<p>Only when the IFP wants to "route" a non-IP packet to an ECMP group, it must
use the "Redirect to ECMP Group" action. 
</td></tr><tr><td> SDK-58667 
 </td><td></td><td> 56640_B0
 </td><td> a new enum value is added to enable the <tt>rx_lox</tt> external pin for 100G application
</td></tr><tr><td> SDK-58695 
 </td><td> 799873
 </td><td> 56450_A0
 </td><td> For BCM5645x devices, support has been added for L3 packets, ingressing from trunk member ports, to be able to be trapped to CPU.
</td></tr><tr><td> SDK-58733 
 </td><td></td><td> All
 </td><td> New build toolchain XLP SDK 3.0.2 effected on GTR and WRX based SVKs.
</td></tr><tr><td> SDK-58752 
 </td><td> 783027
 </td><td> All
 </td><td> OAM: Support handling of CCM packets in the OAMP for packet types with 2 Ethernet headers (i.e. Mac in Mac).
This requires correctly setting PPH.<tt>FWD_HEADER_OFFSET</tt> to the start of the OAM header.
</td></tr><tr><td> SDK-58769 
 </td><td></td><td> 56450_A0
56450_B0
 </td><td> Problem statement: DMVOQ is not working when fabric is in between and trunk ports are used in fabric
Fix description: Incorporated the changes so that DMVOQ works properly, when fabric is connected inbetween the modules and trunk ports are used to connect the egress module
</td></tr><tr><td> SDK-58821 
 </td><td> 672112
 </td><td> 88750_A0
88750_B0
 </td><td> "phy measure sfi" diagnostic command is used to measure fabric link rate.
Using this command caused to the fabric link counters to stop.
</td></tr><tr><td> SDK-58824 
 </td><td> 798782
 </td><td> 88650_B1
 </td><td> fixed incorrect behaviour of "memory-arrays" on cache.
</td></tr><tr><td> SDK-58863 
 </td><td> 797630
 </td><td> 88650_A0
88660_A0
88670_A0
 </td><td> arp extension feature: Backward compatibilty for arp extension feature.
<tt>BCM_88660_A0</tt> can now work in <tt>BCM_88650</tt> mode using custom soc property <tt>custom_feature_next_hop_mac_ext_arad_compatible</tt>. 
Using <tt>BCM_88650</tt> mode implies learning extension header always appended when PP packet is sent to the fabric. 
</td></tr><tr><td> SDK-58870 
 </td><td> 800874
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Provided the debug (FP+Verbose) prints to display the UDF chunks allocated during data qualifier create <tt>bcm_field_data_qualifier_create</tt>() and <tt>bcm_field_data_qualifier_get</tt>() API. It helps to understand the chunks used in the UDF offset during creation.
</td></tr><tr><td> SDK-58893 
 </td><td> 798171
 </td><td> 88030_B0
 </td><td> add per channel counters for "show counter" CLI command on bcm88030
</td></tr><tr><td> SDK-58900 
 </td><td></td><td> 88650_B1
88660_A0
88670_A0
 </td><td> In Ingress Field Processor, in Direct Extraction field groups diagnostics, the source key selection for the action was read from wrong location. This is fixed.
</td></tr><tr><td> SDK-58943 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Allocation of MPLS push profile is now supported through <tt>bcm_mpls_port_add</tt> api.
To allocate push profile, api should be called with <tt>BCM_MPLS_PORT_WITH_ID</tt> and <tt>BCM_MPLS_PORT2_TUNNEL_PUSH_INFO</tt> flags set. <tt>mpls_port_id</tt> is used to indicate the push profile. Function <tt>system_aux_push_profile_to_push_profile_id</tt> in <tt>cint_system_vswitch_encoding</tt>.c should be used to set the encoding of the id to be of type push profile.
<tt>egress_label</tt> field and <tt>BCM_MPLS_PORT_CONTROL_WORD</tt> flag indicate the push profile properties.
Example of usage can be found in <tt>vswitch_vpls_allocate_push_profile</tt> function in <tt>cint_vswitch_vpls</tt>.c.
</td></tr><tr><td> SDK-58944 
 </td><td></td><td> 88650_B0
88650_B1
88660_A0
88670_A0
 </td><td> Documentation for <tt>cint_field_presel_advanced_mode</tt> added to readme file
</td></tr><tr><td> SDK-58984 
 </td><td> 802028
 </td><td> 56248L_A0
56248L_B0
56450_A0
56450_B0
 </td><td> The TTL value of VC label was not retained when replacing l3 egress object using API <tt>bcm_l3_egress_create</tt>() with "flags = <tt>BCM_L3_WITH_ID</tt> | <tt>BCM_L3_REPLACE</tt>". The issue has been fixed for BCM5645x and BCM56248L devices.
</td></tr><tr><td> SDK-59142 
 </td><td> 804236
 </td><td> 56063
56064
56062
56060
53400_A0
53406_A0
53404_A0
53403_A0
53402_A0
53401_A0
 </td><td> The RCPU support is aligned with the declared feature set in Make.local for Greyhound and Ranger2 devices in this release. In previous release, a warning message of "feature not available" was shown if RCPU was removed from feature set.
</td></tr><tr><td> SDK-59202 
 </td><td> 763574
 </td><td> 56854_A2
 </td><td>In the 6.3.7 release, SDK initialization would occasionally fail on BCM56854 devices. This has been resolved.
</td></tr></tbody></table><br><br><hr noshade><br><br>
    <a name=section_unresolved6.4.1>
    <h3>Section 6:  Unresolved Issues for 6.4.1
</h3>
<p>The following issues are unresolved in version 6.4.1 of the SDK.
<p><table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> Number
 </b></td><td><b> CSP #
 </b></td><td><b> Chips
 </b></td><td><b> Release Notes
</b></td></tr><tr><td> SDK-30856 
 </td><td></td><td> All
 </td><td> When mirror-to port resides on a different unit, the mirrored packet may not egress correctly.
</td></tr><tr><td> SDK-33686 
 </td><td> 389108
 </td><td> 56634_A0
 </td><td> If a MiM virtual port has statistics enabled for it and if such MiM port is replaced using
BCM API <tt>bcm_mim_port_add</tt>( ) along with flag <tt>BCM_MIM_PORT_REPLACE</tt> then the 
statistics of that MiM port might be lost.
</td></tr><tr><td> SDK-35755 
 </td><td> 411572
 </td><td> 56820_A0
56820_B0
 </td><td> Compared to older releases, L2 Notification thread (bcmL2X) requires more CPU bandwidth to run in polling mode (<tt>l2xmsg_mode</tt>=0), due to the requirement for more thorough entry comparisons.
<p>The recommendation, however, is to run L2 notification thread using <tt>L2MOD_FIFO</tt> DMA mechanism, which is much more efficient and provides more functionality. To do that, please, set the configuration variable (property) <tt>l2xmsg_mode</tt> to 1.
</td></tr><tr><td> SDK-37821 
 </td><td></td><td> 56846_A0
56845_B0
56845_A2
56844_A0
56842_A0
56840_A0
56440_A0
56843_B0
56841_A3
56846_A1
56841_B0
 </td><td> <tt>bcm_cosq_config_set</tt>() had traditionally been used to set the system wide number of COSQs.
This does not apply to devices with hierarchical schedulers. For these devices, the hierarchy
constructed at device initialization time is dependent upon the number of COSQs defined in
the system configuration at the time of initialization. Changing the queue count after the
hierarchy has been constructed has no effect. 
</td></tr><tr><td> SDK-42259 
 </td><td></td><td> 56440_A0
56440_A1
 </td><td> Spurious error messages may be seen when executing Rx/TX tests TR90 and TR91
when the KNET modules is loaded.
</td></tr><tr><td> SDK-44416 
 </td><td></td><td> 88640_A0
 </td><td> 1. API is reading the wrong register from the device.
2. API is missing the parameter of ResetLoad, so this value cannot be configured.
</td></tr><tr><td> SDK-44471 
 </td><td> 599747
 </td><td> 56544_A0
 </td><td> BCM56544 XAUI ports support single lane GE operation via lane 0 (at boot time).
The applicable config is <tt>bcm56544_4x10_12x10</tt>=1. However, current software has not supported this yet.
Modifying the src/soc/esw/triumph3.c-&gt;<tt>port_speed_max_94</tt> as following can support GE operation:
<p>   static const int <tt>port_speed_max_94</tt>[] = {
        -1,
        1/* 10 */, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 1/* 10 */, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 1/* 10 */, -1, -1, -1, -1, -1, -1, -1,
         1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, 1/* 10 */, -1, -1, -1,
        -1, -1, -1, -1, 10, 10, 10, 10, -1, -1, -1, -1,
        -1, -1, -1, -1,
        -1, -1, -1, -1, 10, 10, 10, 10, 10, 10, 10, 10,
        -1, -1, -1, -1, -1
   };
<p>However, there should be more decent way to achieve this feature.
</td></tr><tr><td> SDK-45075 
 </td><td></td><td> All
 </td><td> When an interrupt occurs on different blocks of the same type (e.g. multiple FMAC blocks), the count will be accumulated in the same counter.
For example RX-LOS interrupt may occur on different FMAC blocks, and counted as same recurring event, although it is in fact a different interrupt. This may affect corrective action in case it is different for a recurring event, in the case if recurring-threshold for this event is crossed. 
</td></tr><tr><td> SDK-45366 
 </td><td> 611273
 </td><td> 56440_A0
 </td><td> When the API <tt>bcm_cosq_port_bandwidth_set</tt>(...) is called on a particular port and COSq to enable egress rate limiting, sometimes the CLI command "show c" will show the incorrect dropping statistics on a irrelevant port.
</td></tr><tr><td> SDK-46556 
 </td><td> 621213
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> <tt>bcm_l2_cache_delete</tt>() API does not delete <tt>general_trap</tt> entry configuration in HW
</td></tr><tr><td> SDK-47366 
 </td><td> 642398
 </td><td> All
 </td><td> The implementation of SER (Soft Error Recovery mechanism) requires the SDK to perform periodical scanning of certain memories. The infrastructure for this scanning is provided by the optional <tt>MEM_SCAN</tt> feature (component) of the SDK.
<p>Since SER is a mandatory component, that can't be compiled out, <tt>MEM_SCAN</tt> becomes a mandatory component too as long as you are using a device, supported by SER.
</td></tr><tr><td> SDK-47739 
 </td><td> 628786
 </td><td> 56540_A0
56540_B0
 </td><td> For devices in the BCM56540 family, the CPU queues are allocated differently depending on
the revision of the device (Ax vs. Bx). This force the developer to include revision specific
code in the application.
</td></tr><tr><td> SDK-48091 
 </td><td> 662661
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> For BCM56850 devices, when only a single GigE port is allocated to a TSC lane (the other
3 TSC lanes are not used), that port may be configured incorrectly resulting in port that
appears functional but is not.
</td></tr><tr><td> SDK-48913 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> In RX Trap API, setting a new Counter-Pointer value may not take effect.
Under investigation.
</td></tr><tr><td> SDK-49910 
 </td><td></td><td> 56640_A0
56640_A1
56640_B0
 </td><td> If the default schedule hierarchy is changed, subsequent calls to various "cos" commands may
fail with an "INVALID PORT" error, "cos config" is one example.
</td></tr><tr><td> SDK-51099 
 </td><td> 695521
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> In L2, in distributed systems under extreme scenario, the MAC Table reply FIFO may be empty but its interrupt is up.
In this case, the interrupt should be reset before trying inserting a MAC Table address, otherwise a failure in the insertion will be returned by the Driver.
</td></tr><tr><td> SDK-51978 
 </td><td></td><td> 88650_A0
 </td><td> In a device with channalized CPU ports, where some of the CPU ports are Higig and some not, the WB wont preserve the Higig indication correctly.
</td></tr><tr><td> SDK-52383 
 </td><td></td><td> 88650_A0
88650_B0
 </td><td> Cud extension for Arad is not supported
</td></tr><tr><td> SDK-54219 
 </td><td> 744517
 </td><td> 88650_B1
 </td><td> In ARAD B1, VxLAN/L2GRE packet size of 236B-299B will be dropped by EPNI if the packet needs to be terminated. Workaround is introduced in FP CINT: <tt>cint_field_ingress_large_termination</tt>.c
</td></tr><tr><td> SDK-54488 
 </td><td></td><td> 88650_A0
 </td><td> In Field Processor, when creating a cascaded field group, a failure might occur in key allocation in case the key ID is already determined. To be investigated.
</td></tr><tr><td> SDK-54623 
 </td><td></td><td> 88660_A0
 </td><td> In Field Processor, when creating a field group, false error messages are printed when operation succeeds (return value indicates success). To be fixed.
</td></tr></tbody></table><br><br><hr noshade><br><br>
    <a name=section_platforms>
    <h3>Section 7:  Device and Platform Support
</h3>
<p>The section describes all devices, platforms, and operating
systems that are supported by this release. 
<br><hr noshade><a name="devices"></a>
<h3>Section 7.1:   Switch Devices
</h3>
<p><h3>Table 94:   Switch Devices
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Family</b></td><td><b>  Devices</b></td><td><b> Description
</b></td></tr><tr><td> BCM5389
</td><td> BCM5389 A0
</td><td> 8-Port GbE Switch with Integrated Serdes
</td></tr><tr><td></td><td> BCM5389 A1
</td><td> 8-Port GbE Switch with Integrated Serdes
</td></tr><tr><td> BCM5396
</td><td> BCM5396 A0
</td><td> 16-Port GbE Switch with Integrated Serdes
</td></tr><tr><td> BCM53010
</td><td> BCM53010 A0
</td><td> 5-Port Gigabit Ethernet Managed Switch integrated with single core ARM Cortex-A9 processor
</td></tr><tr><td></td><td> BCM53010 A2
</td><td></td></tr><tr><td></td><td> BCM53011 A0
</td><td> 5-Port Gigabit Ethernet Managed Switch integrated with dual cores ARM Cortex-A9 processor
</td></tr><tr><td></td><td> BCM53011 A2
</td><td></td></tr><tr><td></td><td> BCM53012 A0
</td><td> 5-Port Gigabit Ethernet Managed Switch with one RGMII I/F integrated with dual cores ARM Cortex-A9 processor
</td></tr><tr><td></td><td> BCM53012 A2
</td><td></td></tr><tr><td> BCM53018
</td><td> BCM53017 A0
</td><td> 2-Port Gigabit Ethernet Managed Switch with one RGMII I/F integrated with dual cores ARM Cortex-A9 processor
</td></tr><tr><td></td><td> BCM53018 A0
</td><td> 5-Port Gigabit Ethernet Managed Switch with one RGMII I/F integrated with dual cores ARM Cortex-A9 processor
</td></tr><tr><td></td><td> BCM53019 A0
</td><td> 5-Port Gigabit Ethernet Managed Switch integrated with dual cores ARM Cortex-A9 processor
</td></tr><tr><td> BCM53020
</td><td> BCM58522 A0
</td><td> 5-Port Gigabit Ethernet Managed Switch integrated with 2 PHYs, ARM Cortex-A9 processor and macsec cores
</td></tr><tr><td></td><td> BCM58525 A0
</td><td> 5-Port Gigabit Ethernet Managed Switch integrated with 2 PHYs, SGMII I/F, ARM Cortex-A9 processor and macsec cores
</td></tr><tr><td></td><td> BCM58622 A0
</td><td> 8-Port Gigabit Ethernet Managed Switch integrated with 5 PHYs, ARM Cortex-A9 processor and macsec cores
</td></tr><tr><td></td><td> BCM58623 A0
</td><td> 8-Port Gigabit Ethernet Managed Switch integrated with 5 PHYs, ARM Cortex-A9 processor and macsec cores
</td></tr><tr><td></td><td> BCM58625 A0
</td><td> 8-Port Gigabit Ethernet Managed Switch integrated with 5 PHYs, SGMII I/F, ARM Cortex-A9 processor and macsec cores
</td></tr><tr><td> BCM53101
</td><td> BCM53101 A0
</td><td> 5-Port Fast Ethernet Managed Switch + 1 Fast Ethernet WAN port
</td></tr><tr><td></td><td> BCM53101 B0
</td><td></td></tr><tr><td> BCM53115
</td><td> BCM53115 A0
</td><td> 5-Port GbE Managed Switch + 1 Gigabit WAN port with integrated serdes
</td></tr><tr><td></td><td> BCM53115 A1
</td><td></td></tr><tr><td></td><td> BCM53115 B0
</td><td></td></tr><tr><td></td><td> BCM53115 B1
</td><td></td></tr><tr><td></td><td> BCM53115 C0
</td><td></td></tr><tr><td> BCM53118
</td><td> BCM53118 A0
</td><td> 8-Port Gigabit Ethernet Switch
</td></tr><tr><td></td><td> BCM53118 B0
</td><td></td></tr><tr><td></td><td> BCM53118 B1
</td><td></td></tr><tr><td> BCM53125
</td><td> BCM53125 A0
</td><td> 5-Port Gigabit Ethernet Switch with 1 Gigabit WAN port and 8051 processor
</td></tr><tr><td></td><td> BCM53125 B0
</td><td></td></tr><tr><td> BCM53128
</td><td> BCM53128 A0
</td><td> 8-Port Gigabit Ethernet Switch with embedded 8051 processor
</td></tr><tr><td></td><td> BCM53128 B0
</td><td></td></tr><tr><td> BCM53242
</td><td> BCM53242 A0
</td><td> Managed Switch with 24 FE Ports + 2 GbE Interface
</td></tr><tr><td></td><td> BCM53242 B0
</td><td></td></tr><tr><td></td><td> BCM53242 B1
</td><td></td></tr><tr><td></td><td> BCM53262 A0
</td><td> Managed Switch with 24 FE Ports + 4 GbE Interface
</td></tr><tr><td></td><td> BCM53262 B0
</td><td></td></tr><tr><td></td><td> BCM53262 B1
</td><td></td></tr><tr><td> BCM53280
</td><td> BCM53282 A0
</td><td> 8-Port Fast Ethernet + 2-Port Gigabit Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM53282 B0
</td><td></td></tr><tr><td></td><td> BCM53282 B1
</td><td></td></tr><tr><td></td><td> BCM53282 B2
</td><td></td></tr><tr><td></td><td> BCM53283 A0
</td><td> 16-Port Fast Ethernet + 2-Port Gigabit Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM53283 B0
</td><td></td></tr><tr><td></td><td> BCM53283 B1
</td><td></td></tr><tr><td></td><td> BCM53283 B2
</td><td></td></tr><tr><td></td><td> BCM53284 A0
</td><td> 24-Port Fast Ethernet + 2-Port Gigabit Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM53284 B0
</td><td></td></tr><tr><td></td><td> BCM53284 B1
</td><td></td></tr><tr><td></td><td> BCM53284 B2
</td><td></td></tr><tr><td></td><td> BCM53286 A0
</td><td> 24-Port Fast Ethernet + 4-Port Gigabit Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM53286 B0
</td><td></td></tr><tr><td></td><td> BCM53286 B1
</td><td></td></tr><tr><td></td><td> BCM53286 B2
</td><td></td></tr><tr><td></td><td> BCM53288 A0
</td><td> 24-Port Fast Ethernet + 2-Port Gigabit Ethernet Multilayer Switch
   with one 2.5GbE Uplink Port
</td></tr><tr><td></td><td> BCM53288 B0
</td><td></td></tr><tr><td></td><td> BCM53288 B1
</td><td></td></tr><tr><td></td><td> BCM53288 B2
</td><td></td></tr><tr><td> BCM53300
</td><td> BCM53300 A0
</td><td> Managed 24-port L2 Switch
</td></tr><tr><td></td><td> BCM53300 A1
</td><td></td></tr><tr><td></td><td> BCM53301 A0
</td><td> Managed 16-port L2 Switch
</td></tr><tr><td></td><td> BCM53301 A1
</td></tr><tr><td></td><td> BCM53302 A0
</td><td> Managed 24-port L2 Switch
</td></tr><tr><td></td><td> BCM53302 A1
</td><td></td></tr><tr><td> BCM53310
</td><td> BCM53312 A0
</td><td> BCM53312 Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM53312 B0
</td><td></td></tr><tr><td></td><td> BCM53313 A0
</td><td> BCM53313 Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM53313 B0
</td><td></td></tr><tr><td></td><td> BCM53314 A0
</td><td> BCM53314 Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM53314 B0
</td><td></td></tr><tr><td> BCM53320
</td><td> BCM53322 A0
</td><td> BCM53322 Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM53323 A0
</td><td> BCM53323 Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM53324 A0
</td><td> BCM53324 Integrated Multilayer Switch and CPU
</td></tr><tr><td> BCM53400
</td><td> BCM53401 A0
</td><td> 24-port GbE plus 4-port 10GbE Multilayer Ethernet Switch with HiGi Uplinks
</td></tr><tr><td></td><td> BCM53402 A0
</td><td> 8-port 10GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM53405 A0
</td><td> 16-port 10GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM53406 A0
</td><td> 12-port 10GbE plus 8-port 2.5GbE and 4-port 5GbE/2.5GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM53408 A0
</td><td> 24-port 1GbE/2.5GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM53411 A0
</td><td> 24-port GbE plus 4-port 10GbE Multilayer Ethernet Switch with HiGi Uplinks and integrated CPU
</td></tr><tr><td></td><td> BCM53412 A0
</td><td> 8-port 10GbE Multilayer Ethernet Switch with integrated CPU
</td></tr><tr><td></td><td> BCM53415 A0
</td><td> 16-port 10GbE Multilayer Ethernet Switch with integrated CPU
</td></tr><tr><td></td><td> BCM53416 A0
</td><td> 12-port 10GbE plus 8-port 2.5GbE and 4-port 5GbE/2.5GbE Ethernet Switch with integrated CPU
</td></tr><tr><td></td><td> BCM53418 A0
</td><td> 24-port 1GbE/2.5GbE Multilayer Ethernet Switch with integrated CPU
</td></tr><tr><td> BCM53600
</td><td> BCM53602 A0
</td><td> 8-Port Fast Ethernet + 3-Port Gigabit Ethernet Switch with one 1/2G-EPON ONU MAC/SerDes
   and embedded 600MHz MIPS32 74K processor
</td></tr><tr><td></td><td> BCM53603 A0
</td><td> 16-Port Fast Ethernet + 3-Port Gigabit Ethernet Switch with one 1/2G-EPON ONU MAC/SerDes
   and embedded 600MHz MIPS32 74K processor
</td></tr><tr><td></td><td> BCM53604 A0
</td><td> 24-Port Fast Ethernet + 3-Port Gigabit Ethernet Switch with one 1/2G-EPON ONU MAC/SerDes
   and embedded 600MHz MIPS32 74K processor
</td></tr><tr><td></td><td> BCM53606 A0
</td><td> 24-Port FE with S3MII interface + 3-Port Gigabit Ethernet Switch with one 1/2G-EPON ONU MAC/SerDes
   and embedded 600MHz MIPS32 74K processor
</td></tr><tr><td> BCM89500
</td><td> BCM89500 A0
</td><td> 4-Port Integrated Dedicated BRPHY + 3-Port Gigabit Ethernet Switch with embedded ARM processor
</td></tr><tr><td></td><td> BCM89500 B0
</td><td></td></tr><tr><td> BCM89500
</td><td> BCM89501 A0
</td><td> 4-Port Integrated Dedicated BRPHY + 1-Port Integrated Dual-Mode BRPHY + 2-Port Gigabit Ethernet Switch with embedded ARM processor
</td></tr><tr><td></td><td> BCM89501 B0
</td><td></td></tr><tr><td> BCM89500
</td><td> BCM89200 A0
</td><td> 1-Port Integrated Dedicated BRPHY + 1-Port Integrated Dual-Mode BRPHY + 2-Port Gigabit Ethernet Switch with embedded ARM processor
</td></tr><tr><td></td><td> BCM89200 B0
</td><td></td></tr><tr><td> BCM53710
</td><td> BCM53714 A0
</td><td> BCM56714 Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM53714 A1
</td><td></td></tr><tr><td></td><td> BCM53714 A2
</td><td></td></tr><tr><td></td><td> BCM53716 A0
</td><td> BCM56716 Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM53716 A1
</td><td></td></tr><tr><td></td><td> BCM53716 A2
</td><td></td></tr><tr><td></td><td> BCM53718 A0
</td><td> BCM56718 Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM53718 A1
</td><td></td></tr><tr><td></td><td> BCM53718 A2
</td><td></td></tr><tr><td> BCM53720
</td><td> BCM53724 A0
</td><td> Managed 24-port L2 Switch with Integrated CPU
</td></tr><tr><td></td><td> BCM53724 B0
</td><td></td></tr><tr><td></td><td> BCM53726 A0
</td><td> Managed 24-port L2 Switch with Integrated CPU
</td></tr><tr><td></td><td> BCM53726 B0
</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td> BCM5675 A1
</td><td></td></tr><tr><td></td><td> BCM5676 A0
</td><td> 4-Port, 96-Gbps Switch Fabric
</td></tr><tr><td></td><td> BCM5676 A1
</td><td></td></tr><tr><td> BCM56010
</td><td> BCM56014 A0
</td><td> 24-Port Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM56014 A1
</td><td></td></tr><tr><td></td><td> BCM56014 A2
</td><td></td></tr><tr><td></td><td> BCM56018 A0
</td><td> 48-Port Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM56018 A1
</td><td></td></tr><tr><td></td><td> BCM56018 A2
</td><td></td></tr><tr><td></td><td> BCM56018 A1
</td><td> 48-Port Integrated Multilayer Switch and CPU
</td></tr><tr><td> BCM56020
</td><td> BCM56024 A0
</td><td> 24-Port Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM56024 B0
</td><td></td></tr><tr><td></td><td> BCM56025 A0
</td><td> 24-Port Integrated L2 Switch and CPU
</td></tr><tr><td></td><td> BCM56025 B0
</td><td></td></tr><tr><td></td><td> BCM56026 A0
</td><td> 24-Port Integrated L2 Switch and CPU
</td></tr><tr><td></td><td> BCM56026 B0
</td><td></td></tr><tr><td> BCM56060
</td><td> BCM56060 A0
</td><td> 16-port 10GbE Multilayer Ethernet Switch with integrated CPU
</td></tr><tr><td></td><td> BCM56063 A0
</td><td> 16-port 1GbE plus 4-port 10GbE (XFI) Multilayer Switch with integrated CPU
</td></tr><tr><td></td><td> BCM56064 A0
</td><td> 24-port GbE plus 4-port 10GbE Multilayer Managed Switch with HiGi Uplinks and integrated CPU
</td></tr><tr><td> BCM56100
</td><td> BCM56100 A0
</td><td> 24-Port Fast Ethernet and 2-Port Gigabit Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56100 A1
</td><td></td></tr><tr><td></td><td> BCM56101 A0
</td><td> 24-Port Fast Ethernet and 2-Port Gigabit Ethernet Multilayer Switch with
One 10-Gigabit Ethernet/HiGig Port
</td></tr><tr><td></td><td> BCM56101 A1
</td><td></td></tr><tr><td></td><td> BCM56102 A0
</td><td> 24-Port Fast Ethernet and 2-Port Gigabit Ethernet Multilayer Switch with
Two 10-Gigabit Ethernet/HiGig Ports
</td></tr><tr><td></td><td> BCM56102 A1
</td><td></td></tr><tr><td></td><td> BCM56105 A0
</td><td> 24-Port Fast Ethernet and 2-Port Gigabit Ethernet Layer 2 Switch
</td></tr><tr><td></td><td> BCM56105 A1
</td><td></td></tr><tr><td></td><td> BCM56106 A0
</td><td> 24-Port Fast Ethernet and 2-Port Gigabit Ethernet Layer 2 Switch with One
10-Gigabit Ethernet/HiGig Port
</td></tr><tr><td></td><td> BCM56106 A1
</td><td></td></tr><tr><td></td><td> BCM56107 A0
</td><td> 24-Port Fast Ethernet and 2-Port Gigabit Ethernet Layer 2 Switch with Two
10-Gigabit Ethernet/HiGig Ports
</td></tr><tr><td></td><td> BCM56107 A1
</td><td></td></tr><tr><td> BCM56110
</td><td> BCM56110 A0
</td><td> 24-Port Fast Ethernet and 2-Port Gigabit Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56111 A0
</td><td> 24-Port Fast Ethernet and 2-Port Gigabit Ethernet Multilayer Switch with
One 10-Gigabit Ethernet/HiGig Port
</td></tr><tr><td></td><td> BCM56112 A0
</td><td> 24-Port Fast Ethernet and 2-Port Gigabit Ethernet Multilayer Switch with
Two 10-Gigabit Ethernet/HiGig Ports
</td></tr><tr><td></td><td> BCM56115 A0
</td><td> 24-Port Fast Ethernet and 2-Port Gigabit Ethernet Layer 2 Switch
</td></tr><tr><td></td><td> BCM56116 A0
</td><td> 24-Port Fast Ethernet and 2-Port Gigabit Ethernet Layer 2 Switch with One
10-Gigabit Ethernet/HiGig Port
</td></tr><tr><td></td><td> BCM56117 A0
</td><td> 24-Port Fast Ethernet and 2-Port Gigabit Ethernet Layer 2 Switch with Two
10-Gigabit Ethernet/HiGig Ports
</td></tr><tr><td> BCM56130
</td><td> BCM56132 A0
</td><td> 24-Port Fast Ethernet Multilayer Switch with Two 10-GbE/HiGig2 and
Two 1G/2.5Gb Uplink Ports 
</td></tr><tr><td></td><td> BCM56132 B0
</td><td></td></tr><tr><td></td><td> BCM56132 B1
</td><td></td></tr><tr><td></td><td> BCM56134 A0
</td><td> 24-Port Fast Ethernet Multilayer Switch with four 1G/2.5Gb Uplink Ports
</td></tr><tr><td></td><td> BCM56134 B0
</td><td></td></tr><tr><td></td><td> BCM56134 B1
</td><td></td></tr><tr><td> BCM56140
</td><td> BCM56140 A0
</td><td> 24-Port Gigabit Ethernet/6-Port SGMII GbE Multilayer switch with combination of two/four 1G/2.5/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56142 A0
</td><td> 24-Port Gigabit Ethernet Multilayer switch with combination of two/four 1G/2.5/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56143 A0
</td><td> 24-Port Gigabit Ethernet Multilayer switch with combination of two/four 1G/2.5/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56144 A0
</td><td> 16-Port Gigabit Ethernet Multilayer switch with four 1G/2.5HG Uplink Ports
</td></tr><tr><td></td><td> BCM56146 A0
</td><td> 24-Port Fast-Ethernet Multilayer switch with four 2.5HG Uplink Ports
</td></tr><tr><td></td><td> BCM56147 A0
</td><td> 24-Port Fast-Ethernet Multilayer switch with combination of one/two/four 1G/2.5G/10/12/13HG Uplink Ports
</td></tr><tr><td> BCM56150
</td><td> BCM56150 A0
</td><td> 24-port GbE Managed Switch with 4-port 10 GbE uplinks, integrated CPU and 16 copper PHYs
</td></tr><tr><td></td><td> BCM56151 A0
</td><td> 24-port GbE Managed Switch with 4-port 10 GbE uplinks, integrated CPU (without PHYs)
</td></tr><tr><td></td><td> BCM56152 A0
</td><td> 24-port GbE plus 2-port GbE and 2-port 1GbE/13GbE uplinks Managed Switch, integrated CPU and 16 copper PHYs
</td></tr><tr><td></td><td> BCM53342 A0
</td><td> 8-port GbE Multilayer WebSmart Switch with Integrated CPU and Copper PHYs
</td></tr><tr><td></td><td> BCM53343 A0
</td><td> 16-port GbE plus 4-port GbE uplinks Multilayer WebSmart Switch with Integrated CPU and 16 Copper PHYs
</td></tr><tr><td></td><td> BCM53344 A0
</td><td> 24-port GbE plus 2-port GbE and 2-port 1GbE/13GbE uplinks WebSmart Switch, integrated CPU and 16 copper PHYs
</td></tr><tr><td></td><td> BCM53346 A0
</td><td> 24-port GbE Multilayer WebSmart Switch with 4-port 10 GbE uplinks, integrated CPU and 16 copper PHYs
</td></tr><tr><td></td><td> BCM53393 A0
</td><td> 14-port GbE Multilayer Embedded Switch with integrated CPU (without PHY)
</td></tr><tr><td></td><td> BCM53394 A0
</td><td> 10-port GbE Multilayer Embedded Switch with 4-port 10 GbE uplinks, integrated CPU (without PHY)
</td></tr><tr><td> BCM56210
</td><td> BCM56212 A0
</td><td></td></tr><tr><td></td><td> BCM56212 A1
</td><td></td></tr><tr><td></td><td> BCM56212 A2
</td><td></td></tr><tr><td></td><td> BCM56213 A0
</td><td></td></tr><tr><td></td><td> BCM56213 A1
</td><td></td></tr><tr><td></td><td> BCM56213 A2
</td><td></td></tr><tr><td></td><td> BCM56214 A0
</td><td> BCM56214 Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM56214 A1
</td><td></td></tr><tr><td></td><td> BCM56214 A2
</td><td></td></tr><tr><td></td><td> BCM56215 A0
</td><td></td></tr><tr><td></td><td> BCM56215 A1
</td><td></td></tr><tr><td></td><td> BCM56215 A2
</td><td></td></tr><tr><td></td><td> BCM56216 A0
</td><td> BCM56216 Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM56216 A1
</td><td></td></tr><tr><td></td><td> BCM56216 A2
</td><td></td></tr><tr><td></td><td> BCM56217 A0
</td><td></td></tr><tr><td></td><td> BCM56217 A1
</td><td></td></tr><tr><td></td><td> BCM56217 A2
</td><td></td></tr><tr><td></td><td> BCM56218 A0
</td><td> BCM56218 Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM56218 A1
</td><td></td></tr><tr><td></td><td> BCM56218 A2
</td><td></td></tr><tr><td></td><td> BCM56219 A0
</td><td> BCM56219 Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM56219 A1
</td><td></td></tr><tr><td></td><td> BCM56219 A2
</td><td></td></tr><tr><td> BCM56220
</td><td> BCM56224 A0
</td><td> 24 GbE + 4 x 1 Gb/2.5 Gb, L3/L2+
</td></tr><tr><td></td><td> BCM56224 B0
</td><td> 24 GbE + 4 x 1 Gb/2.5 Gb, L3/L2+
</td></tr><tr><td></td><td> BCM56225 A0
</td><td> 24 GbE + 4 x 1 Gb/2.5 Gb, L2+
</td></tr><tr><td></td><td> BCM56225 B0
</td><td> 24 GbE + 4 x 1 Gb/2.5 Gb, L2+
</td></tr><tr><td></td><td> BCM56226 A0
</td><td> 16 GbE + 4 x 1 Gb/2.5 Gb, L3/L2+
</td></tr><tr><td></td><td> BCM56226 B0
</td><td> 16 GbE + 4 x 1 Gb/2.5 Gb, L3/L2+
</td></tr><tr><td></td><td> BCM56227 A0
</td><td> 16 GbE + 4 x 1 Gb/2.5 Gb, L2+
</td></tr><tr><td></td><td> BCM56227 B0
</td><td> 16 GbE + 4 x 1 Gb/2.5 Gb, L2+
</td></tr><tr><td></td><td> BCM56228 A0
</td><td> 8 GbE + 4 x 1 Gb/2.5 Gb, L3/L2+
</td></tr><tr><td></td><td> BCM56228 B0
</td><td> 8 GbE + 4 x 1 Gb/2.5 Gb, L3/L2+
</td></tr><tr><td></td><td> BCM56229 A0
</td><td> 8 GbE + 4 x 1 Gb/2.5 Gb, L2+
</td></tr><tr><td></td><td> BCM56229 B0
</td><td> 8 GbE + 4 x 1 Gb/2.5 Gb, L2+
</td></tr><tr><td> BCM56230
</td><td> BCM56230 B1
</td><td> 12-Port GbE Multilayer Switch
</td></tr><tr><td></td><td> BCM56231 B1
</td><td> 6-Port GbE Multilayer Switch
</td></tr><tr><td> BCM56300
</td><td> BCM56300 A0
</td><td> 24-Port Gigabit Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56300 A1
</td><td></td></tr><tr><td></td><td> BCM56300 B0
</td><td></td></tr><tr><td></td><td> BCM56300 B1
</td><td></td></tr><tr><td></td><td> BCM56301 A0
</td><td> Four 10-Gigabit Ethernet/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56301 A1
</td><td></td></tr><tr><td></td><td> BCM56301 B0
</td><td></td></tr><tr><td></td><td> BCM56301 B1
</td><td></td></tr><tr><td></td><td> BCM56302 A0
</td><td> 24-Port Gigabit Ethernet Multilayer Switch with Two 10-Gigabit
Ethernet/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56302 A1
</td><td></td></tr><tr><td></td><td> BCM56302 B0
</td><td></td></tr><tr><td></td><td> BCM56302 B1
</td><td></td></tr><tr><td></td><td> BCM56303 A0
</td><td> 24-Port Gigabit Ethernet Multilayer Switch with Three 10 Gigabit
Ethernet/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56303 A1
</td><td></td></tr><tr><td></td><td> BCM56303 B0
</td><td></td></tr><tr><td></td><td> BCM56303 B1
</td><td></td></tr><tr><td></td><td> BCM56304 A0
</td><td> 24-Port Gigabit Ethernet Multilayer Switch with Four 10-Gigabit
Ethernet/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56304 A1
</td><td></td></tr><tr><td></td><td> BCM56304 B0
</td><td></td></tr><tr><td></td><td> BCM56304 B1
</td><td></td></tr><tr><td></td><td> BCM56305 A0
</td><td> 24-Port Gigabit Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56305 A1
</td><td></td></tr><tr><td></td><td> BCM56305 B0
</td><td></td></tr><tr><td></td><td> BCM56305 B1
</td><td></td></tr><tr><td></td><td> BCM56306 A0
</td><td> 16 Port Gigabit Ethernet Switch
</td></tr><tr><td></td><td> BCM56306 A1
</td><td></td></tr><tr><td></td><td> BCM56306 B0
</td><td></td></tr><tr><td></td><td> BCM56306 B1
</td><td></td></tr><tr><td></td><td> BCM56307 A0
</td><td> 24-Port GE L2 Switch with Two 10 GE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56307 A1
</td><td></td></tr><tr><td></td><td> BCM56307 B0
</td><td></td></tr><tr><td></td><td> BCM56307 B1
</td><td></td></tr><tr><td></td><td> BCM56308 A0
</td><td> 24-Port GE L2 Switch with Three 10 GE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56308 A1
</td><td></td></tr><tr><td></td><td> BCM56308 B0
</td><td></td></tr><tr><td></td><td> BCM56308 B1
</td><td></td></tr><tr><td></td><td> BCM56309 A0
</td><td> 24-Port GE L2 Switch with Four 10 GE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56309 A1
</td><td></td></tr><tr><td></td><td> BCM56309 B0
</td><td></td></tr><tr><td></td><td> BCM56309 B1
</td><td></td></tr><tr><td> BCM56310
</td><td> BCM56310 A0
</td><td> BCM56310 Series 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig+
Uplink Ports
</td></tr><tr><td></td><td> BCM56311 A0
</td><td> Four 10-Gigabit Ethernet/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56312 A0
</td><td> 24-Port Gigabit Ethernet Multilayer Switch with Two 10-Gigabit
Ethernet/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56313 A0
</td><td> 24-Port Gigabit Ethernet Multilayer Switch with Three 10-Gigabit
Ethernet/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56314 A0
</td><td> 24-Port Gigabit Ethernet Multilayer Switch with Four 10-Gigabit
Ethernet/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56315 A0
</td><td> BCM56310 Series 24-Port GbE Layer 2 Switch with Four 10-GbE/HiGig+
Uplink Ports
</td></tr><tr><td></td><td> BCM56316 A0
</td><td> Four 10-Gigabit Ethernet/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56317 A0
</td><td> 24-Port Gigabit Ethernet Layer 2 Switch with Two 10-Gigabit
Ethernet/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56318 A0
</td><td> 24-Port Gigabit Ethernet Layer 2 Switch with Three 10-Gigabit
Ethernet/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56319 A0
</td><td> 24-Port Gigabit Ethernet Layer 2 Switch with Four 10-Gigabit
Ethernet/HiGig+ Ports
</td></tr><tr><td> BCM56320
</td><td> BCM56320 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56320 B0
</td><td></td></tr><tr><td></td><td> BCM56320 B1
</td><td></td></tr><tr><td></td><td> BCM56321 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56321 B0
</td><td></td></tr><tr><td></td><td> BCM56321 B1
</td><td></td></tr><tr><td> BCM56330
</td><td> BCM56331 A0
</td><td> 24-Port GbE Multilayer Switch with Four 2.5GbE Uplink Ports
</td></tr><tr><td></td><td> BCM56331 B0
</td><td></td></tr><tr><td></td><td> BCM56331 B1
</td><td></td></tr><tr><td></td><td> BCM56333 A0
</td><td> 16-Port GbE Multilayer Switch
</td></tr><tr><td></td><td> BCM56333 B0
</td><td></td></tr><tr><td></td><td> BCM56333 B1
</td><td></td></tr><tr><td></td><td> BCM56334 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56334 B0
</td><td></td></tr><tr><td></td><td> BCM56334 B1
</td><td></td></tr><tr><td></td><td> BCM56338 A0
</td><td> 8-Port GbE Multilayer Switch with two 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56338 B0
</td><td></td></tr><tr><td></td><td> BCM56338 B1
</td><td></td></tr><tr><td> BCM56340
</td><td> BCM56040 A0
</td><td> 1xF.QSGMII + 3xF.HG[42] + 1GE
</td></tr><tr><td></td><td> BCM56041
</td><td> Ranger device, meant for embedded connectivity supports 1Ge (port 49), 2 X GE (iPROC), Flex 4x10G, 3 X 4 X 10G
</td></tr><tr><td></td><td> BCM56042
</td><td> 12x2.5GE/1GE + 12x2.5GE/1GE + 1GE
</td></tr><tr><td></td><td> BCM56340 A0
</td><td> 12xF.QSGMII + Flex[4x10] + 2xHG[21] + 1GE, 12xF.QSGMII + 4xSGMII + 2xXFI + 2xHGd[21] + 1GE
</td></tr><tr><td></td><td> BCM56342 A0
</td><td> 7xF.QSGMII + Flex[4x10] + 2xHG[21] + 1GE
</td></tr><tr><td></td><td> BCM56344
</td><td> 10xF.QSGMII + 3xFlex[4x10] + 1GE
</td></tr><tr><td> BCM56340
</td><td> BCM56547 A0
</td><td> 10xF.QSGMII + 3xF.HG[42] + 1GE, 12xF.QSGMII + 2xF.HG[42] + 1GE, 12xF.QSGMII + F.HG[42] + 2xHG[42] + 1GE
</td></tr><tr><td> BCM56340
</td><td> BCM56548 A0
</td><td> 7xF.QSGMII + 3xF.HG[42] + 1GE
</td></tr><tr><td> BCM56440
</td><td> BCM56440 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/Hig2 Uplink ports
</td></tr><tr><td></td><td> BCM56440 B0
</td><td></td></tr><tr><td></td><td> BCM56441 A0
</td><td> 8-Port GbE Multilayer Switch with Two 10-GbE/Hig2 Uplink ports
</td></tr><tr><td></td><td> BCM56441 B0
</td><td></td></tr><tr><td></td><td> BCM56442 A0
</td><td> 16-Port GbE Multilayer Switch
</td></tr><tr><td></td><td> BCM56442 B0
</td><td></td></tr><tr><td></td><td> BCM56443 A0
</td><td> 8-Port 2.5GbE Multilayer Switch with Two 10-GbE/Hig2 Uplink ports
</td></tr><tr><td></td><td> BCM56443 B0
</td><td></td></tr><tr><td></td><td> BCM56445 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/Hig2 Uplink ports pin compatible with BCM56334
</td></tr><tr><td></td><td> BCM56445 B0
</td><td></td></tr><tr><td></td><td> BCM56446 A0
</td><td> 8-Port GbE Multilayer Switch with Two 10-GbE/Hig2 Uplink ports pin compatible with BCM56338
</td></tr><tr><td></td><td> BCM56447 A0
</td><td> 16-Port GbE Multilayer Switch pin compatible with BCM56333
</td></tr><tr><td></td><td> BCM56447 B0
</td><td></td></tr><tr><td></td><td> BCM56448 A0
</td><td> 24-Port GbE Multilayer Switch with Four 1GbE/ One 2.5G Uplink ports
</td></tr><tr><td></td><td> BCM56448 B0
</td><td></td></tr><tr><td> BCM56450
</td><td> BCM56450 A0
</td><td> 24-port GbE Multilayer Switch with 4-port 10 GbE uplinks, stacking, integrated CPU and Traffic Manager
</td></tr><tr><td></td><td> BCM56455
</td><td> 2 x 20GE (G.INT) + 2 x HG13
</td></tr><tr><td></td><td> BCM56456 
</td><td> 1 x XAUI + 8 x GE
</td></tr><tr><td> BCM56500
</td><td> BCM56500 A0
</td><td> 24-Port Gigabit Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56500 A1
</td><td></td></tr><tr><td></td><td> BCM56500 B0
</td><td></td></tr><tr><td></td><td> BCM56500 B1
</td><td></td></tr><tr><td></td><td> BCM56500 B2
</td><td></td></tr><tr><td></td><td> BCM56501 A0
</td><td> Four 10-Gigabit Ethernet/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56501 A1
</td><td></td></tr><tr><td></td><td> BCM56501 B0
</td><td></td></tr><tr><td></td><td> BCM56501 B1
</td><td></td></tr><tr><td></td><td> BCM56501 B2
</td><td></td></tr><tr><td></td><td> BCM56502 A0
</td><td> 24-Port GbE Multilayer Switch with Two 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56502 A1
</td><td></td></tr><tr><td></td><td> BCM56502 B0
</td><td></td></tr><tr><td></td><td> BCM56502 B1
</td><td></td></tr><tr><td></td><td> BCM56502 B2
</td><td></td></tr><tr><td></td><td> BCM56503 A0
</td><td> 24-Port GbE Multilayer Switch with Three 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56503 A1
</td><td></td></tr><tr><td></td><td> BCM56503 B0
</td><td></td></tr><tr><td></td><td> BCM56503 B1
</td><td></td></tr><tr><td></td><td> BCM56503 B2
</td><td></td></tr><tr><td></td><td> BCM56504 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56504 A1
</td><td></td></tr><tr><td></td><td> BCM56504 B0
</td><td></td></tr><tr><td></td><td> BCM56504 B1
</td><td></td></tr><tr><td></td><td> BCM56504 B2
</td><td></td></tr><tr><td></td><td> BCM56505 A0
</td><td> 24-Port GbE Layer 2 Switch
</td></tr><tr><td></td><td> BCM56505 A1
</td><td></td></tr><tr><td></td><td> BCM56505 B0
</td><td></td></tr><tr><td></td><td> BCM56505 B1
</td><td></td></tr><tr><td></td><td> BCM56505 B2
</td><td></td></tr><tr><td></td><td> BCM56506 A0
</td><td> Four 10-Gigabit Ethernet/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56506 A1
</td><td></td></tr><tr><td></td><td> BCM56506 B0
</td><td></td></tr><tr><td></td><td> BCM56506 B1
</td><td></td></tr><tr><td></td><td> BCM56506 B2
</td><td></td></tr><tr><td></td><td> BCM56507 A0
</td><td> 24-Port GbE Layer 2 Switch with Two 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56507 A1
</td><td></td></tr><tr><td></td><td> BCM56507 B0
</td><td></td></tr><tr><td></td><td> BCM56507 B1
</td><td></td></tr><tr><td></td><td> BCM56507 B2
</td><td></td></tr><tr><td></td><td> BCM56508 A0
</td><td> 24-Port GbE Layer 2 Switch with Three 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56508 A1
</td><td></td></tr><tr><td></td><td> BCM56508 B0
</td><td></td></tr><tr><td></td><td> BCM56508 B1
</td><td></td></tr><tr><td></td><td> BCM56508 B2
</td><td></td></tr><tr><td></td><td> BCM56509 A0
</td><td> 24-Port GbE Layer 2 Switch with Four 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56509 A1
</td><td></td></tr><tr><td></td><td> BCM56509 B0
</td><td></td></tr><tr><td></td><td> BCM56509 B1
</td><td></td></tr><tr><td></td><td> BCM56509 B2
</td><td></td></tr><tr><td> BCM56510
</td><td> BCM56510 A0
</td><td> 24-Port Gigabit Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56511 A0
</td><td> Four-Port 10-GbE/HiGig+ Multilayer Switch
</td></tr><tr><td></td><td> BCM56512 A0
</td><td> 24-Port GbE Multilayer Switch With Two 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56513 A0
</td><td> 24-Port GbE Multilayer Switch With Three 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56514 A0
</td><td> 24-Port GbE Multilayer Switch With Four 10-GbE/HiGig+ Ports
</td></tr><tr><td> BCM56520
</td><td> BCM56520 A0
</td><td> 24-Port GbE Multilayer Switch
</td></tr><tr><td></td><td> BCM56520 B0
</td><td></td></tr><tr><td></td><td> BCM56522 A0
</td><td> 24-Port GbE Multilayer Switch with Two 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56522 B0
</td><td></td></tr><tr><td></td><td> BCM56524 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56524 B0
</td><td></td></tr><tr><td></td><td> BCM56526 A0
</td><td> 28-Port GbE Multilayer Switch with Six 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56526 B0
</td><td></td></tr><tr><td> BCM56530
</td><td> BCM56534 B0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56538 B0
</td><td> 48-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td> BCM56540
</td><td> BCM56540 A1
</td><td> 48xGE + 2xHG[42] + 2xHG[21] + 1GE, 48xGE + 4xXFI + 2xHG[42] + 1GE, 48xGE + 8xXFI + 1GE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56540 B0
</td><td></td></tr><tr><td></td><td> BCM56541 A1
</td><td> 28xGE + 2xHG[42] + 2xHG[21] + 1GE, 28xGE + 4xXFI + 2xHG[42] + 1GE, 28xGE + 8xXFI + 1GE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56541 B0
</td><td></td></tr><tr><td></td><td> BCM56542 A1
</td><td> 28xGE + 2xF.XAUI/2x10GE + 2xF.HG[42] + 2xF.HG[21] + 1GE, 28xGE + 8xGE/8x2.5GE + 2xHG[42] + 2xHG[21] + 1GE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56544 A1
</td><td> 10xF.XAUI + 4xHG[21] + 1GE, 10xF.XAUI + 4xXFI, 10xF.XAUI + 2xHG[42], 4xXAUI + 12xXFI + 1GE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56544 B0
</td><td> 10xF.XAUI + 4xHG[21] + 1GE, 10xF.XAUI + 4xXFI, 10xF.XAUI + 2xHG[42], 4xXAUI + 12xXFI + 1GE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56545 A1
</td><td> 48xGE + 2xHG[42] + 2xHG[21] + 1GE, 48xGE + 4xXFI + 2xHG[42] + 1GE, 48xGE + 8xXFI + 1GE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56545 B0
</td><td> 48xGE + 2xHG[42] + 2xHG[21] + 1GE, 48xGE + 4xXFI + 2xHG[42] + 1GE, 48xGE + 8xXFI + 1GE, 24xGE + 4xXAUI + 2xXFI + 2xHG[12] + 1GE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56546 A1
</td><td> 28xGE + 2xHG[42] + 2xHG[21] + 1GE, 28xGE + 4xXFI + 2xHG[42] + 1GE, 28xGE + 8xXFI + 1GE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56546 B0
</td><td></td></tr><tr><td> BCM56580
</td><td> BCM56580 A0
</td><td> 16 x 2.5 GbE + 4 x 10 GbE Ethernet Multilayer Switch
</td></tr><tr><td> BCM56620
</td><td> BCM56620 A0
</td><td></td></tr><tr><td></td><td> BCM56620 A1
</td><td></td></tr><tr><td></td><td> BCM56620 B0
</td><td></td></tr><tr><td></td><td> BCM56620 B1
</td><td></td></tr><tr><td></td><td> BCM56620 B2
</td><td></td></tr><tr><td></td><td> BCM56624 A0
</td><td> 49 port 1-GbE Multilayer Ethernet Switch with 4 x 10-GbE/HiGig2
Uplink ports and External Table Expansion
</td></tr><tr><td></td><td> BCM56624 A1
</td><td></td></tr><tr><td></td><td> BCM56624 B0
</td><td></td></tr><tr><td></td><td> BCM56624 B1
</td><td></td></tr><tr><td></td><td> BCM56624 B2
</td><td></td></tr><tr><td></td><td> BCM56626 A0
</td><td> 25 port 1-GbE Multilayer Ethernet Switch with 6 x 10-GbE/HiGig2 Uplink ports and External Table Expansion
</td></tr><tr><td></td><td> BCM56626 A1
</td><td></td></tr><tr><td></td><td> BCM56626 B0
</td><td></td></tr><tr><td></td><td> BCM56626 B1
</td><td></td></tr><tr><td></td><td> BCM56626 B2
</td><td></td></tr><tr><td></td><td> BCM56628 A0
</td><td> 8 port 10-GbE/HiGig2 Multilayer Ethernet Switch with External Table Expansion
</td></tr><tr><td></td><td> BCM56628 A1
</td><td></td></tr><tr><td></td><td> BCM56628 B0
</td><td></td></tr><tr><td></td><td> BCM56628 B1
</td><td></td></tr><tr><td></td><td> BCM56628 B2
</td><td></td></tr><tr><td></td><td> BCM56629 B0      
</td><td> 25 port 1-GbE Multilayer Ethernet Switch with 8 x 10-GbE/HiGig2 Uplink ports and External Table Expansion
</td></tr><tr><td></td><td> BCM56629 B1
</td><td></td></tr><tr><td></td><td> BCM56629 B2
</td><td></td></tr><tr><td> BCM56630
</td><td> BCM56630 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56630 B0
</td><td></td></tr><tr><td></td><td> BCM56634 A0
</td><td> 48-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56634 B0
</td><td></td></tr><tr><td></td><td> BCM56636 A0
</td><td> 24-Port GbE + 2-Port 10-GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56636 B0
</td><td></td></tr><tr><td></td><td> BCM56638 A0
</td><td> 4-Port 10-GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56638 B0
</td><td></td></tr><tr><td></td><td> BCM56639 A0
</td><td> 24-Port GbE + 4-Port 10-GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56639 B0
</td><td></td></tr><tr><td> BCM56640
</td><td> BCM56045 B0
</td><td> 3xF.40GE + 3xF.HG[42] + 1GE
</td></tr><tr><td></td><td> BCM56046 B0
</td><td> 3xF.40GE + 2xF.HG[42] + 1GE
</td></tr><tr><td></td><td> BCM56640 A1
</td><td> 1x100GE + 1xHG[127], 1x100GE + 4xHG[32], 1x100GE + 8xHGd[16], 3xF.HG[42] + 1xHG[127], 3xF.HG[42] + 4xHG[32], 3xF.HG[42] + 8xHGd[16], 3xF.HG[42] + 3xF.HG[42] Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56640 B0
</td><td></td></tr><tr><td></td><td> BCM56643 A1
</td><td> 48xGE + 4xXFI + 4xHG[42] + 1GE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56643 B0
</td><td></td></tr><tr><td></td><td> BCM56644 A1
</td><td> 48xGE + 2xHG[25] + 2xHG[25] + 1GE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56644 B0
</td><td></td></tr><tr><td></td><td> BCM56648 A1
</td><td> 48xGE + 2xHG[42] + 2xHG[21] + 1GE, 48xGE + 4xXFI + 2xHG[42] + 1GE, 48xGE + 8xXFI + 1GE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56648 B0
</td><td></td></tr><tr><td></td><td> BCM56649 A1
</td><td> 28xGE + 2xHG[42] + 2xHG[21] + 1GE, 28xGE + 4xXFI + 2xHG[42] + 1GE, 28xGE + 8xXFI + 1GE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56649 B0
</td><td></td></tr><tr><td> BCM56680
</td><td> BCM56680 A0
</td><td> 25 port 1-GbE/2.5GbE Multilayer Ethernet Switch with 4 x
10-GbE/HiGig2 Uplink ports
</td></tr><tr><td></td><td> BCM56680 A1
</td></tr><tr><td></td><td> BCM56680 B0
</td><td></td></tr><tr><td></td><td> BCM56680 B1
</td><td></td></tr><tr><td></td><td> BCM56684 A0
</td><td> 24 port 1-GbE/2.5GbE Multilayer Ethernet Switch with 4 x
10-GbE/HiGig2 Uplink ports
</td></tr><tr><td></td><td> BCM56684 A1
</td><td></td></tr><tr><td></td><td> BCM56684 B0
</td><td></td></tr><tr><td></td><td> BCM56684 B1
</td><td></td></tr><tr><td> BCM56685
</td><td> BCM56685 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56685 B0
</td><td></td></tr><tr><td></td><td> BCM56689 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56689 B0
</td><td></td></tr><tr><td> BCM56700
</td><td> BCM56700 A0
</td><td> 16-Port, 192-Gbps Lossless Switch Fabric
</td></tr><tr><td></td><td> BCM56701 A0
</td><td> 12-Port, 144-Gbps Lossless Switch Fabric
</td></tr><tr><td> BCM56720
</td><td> BCM56720 A0
</td><td> 16 Port, 16-Gbps HiGig2 Switch Fabric
</td></tr><tr><td></td><td> BCM56721 A0
</td><td> 12 Port, 16-Gbps HiGig2 Switch Fabric
</td></tr><tr><td> BCM56725
</td><td> BCM56725 A0
</td><td> 8 Port, 20-Gbps + 4 Port, 16-Gbps HiGig2 Switch Fabric
</td></tr><tr><td> BCM56740
</td><td> BCM56743 A0
</td><td> 480 Gbps Switch fabric
</td></tr><tr><td></td><td> BCM56743 A1
</td><td></td></tr><tr><td></td><td> BCM56743 A2
</td><td></td></tr><tr><td></td><td> BCM56743 A3
</td><td></td></tr><tr><td></td><td> BCM56743 A4
</td><td></td></tr><tr><td></td><td> BCM56743 B0
</td><td></td></tr><tr><td></td><td> BCM56743 B1
</td><td></td></tr><tr><td></td><td> BCM56745 A0
</td><td> 640 Gbps Switch fabric
</td></tr><tr><td></td><td> BCM56745 A1
</td><td></td></tr><tr><td></td><td> BCM56745 A2
</td><td></td></tr><tr><td></td><td> BCM56745 A3
</td><td></td></tr><tr><td></td><td> BCM56745 A4
</td><td></td></tr><tr><td></td><td> BCM56745 B0
</td><td></td></tr><tr><td></td><td> BCM56745 B1
</td><td></td></tr><tr><td> <tt>BCM56740_PLUS</tt>
</td><td> BCM56744 A0
</td><td> 480 Gbps Switch fabric
</td></tr><tr><td></td><td> BCM56744 A1
</td><td></td></tr><tr><td></td><td> BCM56746 A0
</td><td> 640 Gbps Switch fabric
</td></tr><tr><td></td><td> BCM56746 A1
</td><td></td></tr><tr><td> BCM56800
</td><td> BCM56800 A0
</td><td> 20-Port 10-Gigabit Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56801 A0
</td><td> 10-Port 10-Gigabit Ethernet and 8-Port HiGig2/10GbE Multilayer Switch
</td></tr><tr><td></td><td> BCM56802 A0
</td><td> 16-Port 10-GbE/HiGig2 Multilayer Switch
</td></tr><tr><td></td><td> BCM56803 A0
</td><td> 12 Port 10GE/HiGig2 Multilayer Switch
</td></tr><tr><td> BCM56820
</td><td> BCM56820 A0
</td><td> 24 x 10-GbE + 4 x 1-GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56820 B0
</td><td></td></tr><tr><td></td><td> BCM56821 A0
</td><td> 12 x 10-GbE + 8 x HiGig2 + 4 x 1-GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56821 B0
</td><td></td></tr><tr><td></td><td> BCM56822 A0
</td><td> 12 x 10-GbE + 4 x 20-Gbps HiGig2 + 4 x 1-GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56822 B0
</td><td></td></tr><tr><td></td><td> BCM56823 A0
</td><td> 8 x 10-GbE + 4 x 20-Gbps HiGig2 + 4 x 1-GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56823 B0
</td><td></td></tr><tr><td></td><td> BCM56825 B0
</td><td> 16 x 10-GbE + 8 x 20-Gbps HiGig2 + 1 x 1-GbE Multilayer Ethernet Switch
</td></tr><tr><td> BCM56740
</td><td> BCM56743 A0
</td><td> 480 Gbps Switch fabric
</td></tr><tr><td></td><td> BCM56743 A1
</td><td></td></tr><tr><td></td><td> BCM56743 A2
</td><td></td></tr><tr><td></td><td> BCM56743 A3
</td><td></td></tr><tr><td></td><td> BCM56743 A4
</td><td></td></tr><tr><td></td><td> BCM56743 B0
</td><td></td></tr><tr><td></td><td> BCM56743 B1
</td><td></td></tr><tr><td></td><td> BCM56745 A0
</td><td> 640 Gbps Switch fabric
</td></tr><tr><td></td><td> BCM56745 A1
</td><td></td></tr><tr><td></td><td> BCM56745 A2
</td><td></td></tr><tr><td></td><td> BCM56745 A3
</td><td></td></tr><tr><td></td><td> BCM56745 A4
</td><td></td></tr><tr><td></td><td> BCM56745 B0
</td><td></td></tr><tr><td></td><td> BCM56745 B1
</td><td></td></tr><tr><td> <tt>BCM56740_PLUS</tt>
</td><td> BCM56744 A0
</td><td> 480 Gbps Switch fabric
</td></tr><tr><td></td><td> BCM56744 A1
</td><td></td></tr><tr><td></td><td> BCM56746 A0
</td><td> 640 Gbps Switch fabric
</td></tr><tr><td></td><td> BCM56746 A1
</td><td></td></tr><tr><td> BCM56840
</td><td> BCM56841 A0
</td><td> 320 Gbps Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56841 A1
</td><td></td></tr><tr><td></td><td> BCM56841 A2
</td><td></td></tr><tr><td></td><td> BCM56841 A3
</td><td></td></tr><tr><td></td><td> BCM56841 A4
</td><td></td></tr><tr><td></td><td> BCM56841 B0
</td><td></td></tr><tr><td></td><td> BCM56841 B1
</td><td></td></tr><tr><td></td><td> BCM56843 A0
</td><td> 480 Gbps Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56843 A1
</td><td></td></tr><tr><td></td><td> BCM56843 A2
</td><td></td></tr><tr><td></td><td> BCM56843 A3
</td><td></td></tr><tr><td></td><td> BCM56843 A4
</td><td></td></tr><tr><td></td><td> BCM56843 B0
</td><td></td></tr><tr><td></td><td> BCM56843 B1
</td><td></td></tr><tr><td></td><td> BCM56845 A0
</td><td> 640 Gbps Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56845 A1
</td><td></td></tr><tr><td></td><td> BCM56845 A2
</td><td></td></tr><tr><td></td><td> BCM56845 A3
</td><td></td></tr><tr><td></td><td> BCM56845 A4
</td><td></td></tr><tr><td></td><td> BCM56845 B0
</td><td></td></tr><tr><td></td><td> BCM56845 B1
</td><td></td></tr><tr><td> <tt>BCM56840_PLUS</tt>
</td><td> BCM56842 A0
</td><td> 320 Gbps Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56842 A1
</td><td></td></tr><tr><td></td><td> BCM56844 A0
</td><td> 480 Gbps Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56844 A1
</td><td></td></tr><tr><td></td><td> BCM56846 A0
</td><td> 640 Gbps Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56846 A1
</td><td></td></tr><tr><td> BCM56850
</td><td> BCM56850 A1
</td><td> 1.28Tbps I/O, 1Tbps Core Ethernet Switch
</td></tr><tr><td></td><td> BCM56852 A2
</td><td> 100x10G, 960Gbps Multilayer Switch
</td></tr><tr><td></td><td> BCM56854 A1
</td><td></td></tr><tr><td></td><td> BCM56751P A2
</td><td> 1.28Tbps I/O, 960Gbps Core Ethernet Switch Fabric
</td></tr><tr><td></td><td> BCM56751P A1
</td><td> 1.28Tbps I/O, 960Gbps Core Ethernet Switch Fabric
</td></tr><tr><td></td><td> BCM56830 A1
</td><td> 960Gbps Ethernet Switch
</td></tr><tr><td></td><td> BCM56830 A2
</td><td> 960Gbps Ethernet Switch
</td></tr><tr><td> BCM56851
</td><td> BCM56751 A2
</td><td> 1.28Tbps I/O, 960Gbps Core Ethernet Switch Fabric
</td></tr><tr><td> BCM88732
</td><td> BCM88732 B2
</td><td> Eight-Port 10 GbE or 2-Port 40 GbE MAC Aggregation Switch with 80 Gbps Uplink Capacity
</td></tr><tr><td> BCM88020
</td><td> BCM88020 A0
</td><td> XGS Core (XCore/SBX) Fully Programmable Carrier Packet Processor with 24 GbE Ports,
2 10GbE Ports and 2 SPI Interfaces
</td></tr><tr><td></td><td> BCM88020 A1
</td><td></td></tr><tr><td></td><td> BCM88020 A2
</td><td></td></tr><tr><td> BCM88025
</td><td> BCM88025 A0
</td><td> XGS Core (XCore/SBX) Fully Programmable Carrier Packet Processor with 24 GbE Ports, 2 10GbE Ports and 2 SPI Interfaces
</td></tr><tr><td> BCM88030 
</td><td> BCM88030 A0
</td><td> XGS Core (XCore/SBX) Scalable Switching 100 Gbps Fully Programmable Carrier Packet Processor
</td></tr><tr><td> BCM88130
</td><td> BCM88130 A0
</td><td> XGS Core (XCore/SBX) 630 Gbps Bandwidth Manager and Switching Engine
</td></tr><tr><td></td><td> BCM88130 A1
</td><td></td></tr><tr><td> BME-3200
</td><td> BME-3200 A0
</td><td> XGS Core (XCore/SBX) Fabric Bandwidth Manager with 32 SCI control ports
and up to 40 SFI data ports
</td></tr><tr><td></td><td> BME-3200 B0
</td><td></td></tr><tr><td> QE-2000
</td><td> QE-2000 A1
</td><td> XGS Core (XCore/SBX) Fabric Queueing Engine with 49 SPI 4.2 subports
</td></tr><tr><td></td><td> QE-2000 A2
</td><td></td></tr><tr><td></td><td> QE-2000 A3
</td><td></td></tr><tr><td></td><td> QE-2000 A4
</td><td></td></tr><tr><td>BCM88230
</td><td>BCM88230 A0
</td><td>XGS Core (XCore/SBX) Fabric Queueing Engine with Integrated Traffic Management
with 4 HiGig2 ports, 50Gbps
</td></tr><tr><td></td><td>BCM88230 B0
</td><td></td></tr><tr><td></td><td>BCM88235 A0
</td><td>XGS Core (XCore/SBX) Fabric Queueing Engine with Integrated Traffic Management
with 4 HiGig2 ports, 80Gbps
</td></tr><tr><td></td><td>BCM88235 B0
</td><td></td></tr><tr><td></td><td>BCM88231 A0
</td><td>XGS Core (XCore/SBX) Traffic Manager with 4 HiGig2 ports, 50Gbps
</td></tr><tr><td></td><td>BCM88231 B0
</td><td></td></tr><tr><td></td><td>BCM88236 A0
</td><td>XGS Core (XCore/SBX) Traffic Manager with 4 HiGig2 ports, 80Gbps
</td></tr><tr><td></td><td>BCM88236 B0
</td><td></td></tr><tr><td>BCM56930
</td><td>BCM56931 A0
</td><td>XGS pass-through and standalone Traffic Manager, 4 HiGig2 ports, 50Gbps
</td></tr><tr><td></td><td>BCM56931 B0
</td><td></td></tr><tr><td></td><td>BCM56936 A0
</td><td>XGS pass-through and standalone Traffic Manager, 4 HiGig2 ports, 80Gbps
</td></tr><tr><td></td><td>BCM56936 B0
</td><td></td></tr><tr><td> BCM88640
</td><td> BCM88640 A0
</td><td> DNX 100G Flexible Packet Processor with Integrated Traffic Management
</td></tr><tr><td></td><td> BCM88640 B0
</td><td></td></tr><tr><td> BCM88650
</td><td> BCM88650 A0
</td><td> DNX 200G Flexible Packet Processor with Integrated Traffic Management
</td></tr><tr><td></td><td> BCM88650 B0
</td><td></td></tr><tr><td></td><td> BCM88650 B1
</td><td> 200 GBps DNX Traffic Manager and Packet Processor
</td></tr><tr><td> BCM88660
</td><td> BCM88660 A0
</td><td> DNX 200G Flexible Packet Processor with Integrated Traffic Management
</td></tr><tr><td> BCM88750
</td><td> BCM88750 A0
</td><td> DNX 1600 GBps Switch Fabric
</td></tr><tr><td></td><td> BCM88750 B0
</td><td></td></tr></tbody></table><p>
<a name=tbl_sersupporteddevices></a>
<h3>Table 95:   SER Supported Devices
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Family</b></td><td><b> Devices
</b></td></tr><tr><td>  Trident</td><td> 56841, 56842, 56843, 56844, 56845, 56846, 56850
</td></tr><tr><td>  Triumph</td><td> 56640, 56643, 56644, 56648, 56649, 56540, 56541, 56542, 56544, 56545
</td></tr><tr><td>  Katana</td><td> All SKUs
</td></tr><tr><td>  Katana2</td><td> 56450, 56455, 56456
</td></tr><tr><td>  Enduro2</td><td> All SKUs
</td></tr><tr><td>  Hurricane2</td><td> 56150, 56151, 53344, 53346, 53393, 53394
</td></tr><tr><td>  Helix4</td><td> 56340, 56040, 56344, 56042, 56342
</td></tr></tbody></table>
<a name=wbsd></a>
<h3>Table 96:   Switch Devices that support Warm boot
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Family</b></td><td><b>  Devices</b></td><td><b> Description
</b></td></tr><tr><td> BCM5675
</td><td> BCM5675 A0
</td><td> 8-Port, 192-Gbps Switch Fabric
</td></tr><tr><td></td><td> BCM5675 A1
</td><td></td></tr><tr><td></td><td> BCM5676 A0
</td><td> 4-Port, 96-Gbps Switch Fabric
</td></tr><tr><td></td><td> BCM5676 A1
</td><td></td></tr><tr><td> BCM56020
</td><td> BCM56024 A0
</td><td> 24-Port Integrated Multilayer Switch and CPU
</td></tr><tr><td></td><td> BCM56024 B0
</td><td></td></tr><tr><td></td><td> BCM56025 A0
</td><td> 24-Port Integrated L2 Switch and CPU
</td></tr><tr><td></td><td> BCM56025 B0
</td><td></td></tr><tr><td></td><td> BCM56026 A0
</td><td> 24-Port Integrated L2 Switch and CPU
</td></tr><tr><td></td><td> BCM56026 B0
</td><td></td></tr><tr><td> BCM56130
</td><td> BCM56132 A0
</td><td> 24-Port Fast Ethernet Multilayer Switch with Two 10-GbE/HiGig2 and
Two 1G/2.5Gb Uplink Ports 
</td></tr><tr><td></td><td> BCM56132 B0
</td><td></td></tr><tr><td></td><td> BCM56132 B1
</td><td></td></tr><tr><td></td><td> BCM56134 A0
</td><td> 24-Port Fast Ethernet Multilayer Switch with four 1G/2.5Gb Uplink Ports
</td></tr><tr><td></td><td> BCM56134 B0
</td><td></td></tr><tr><td></td><td> BCM56134 B1
</td><td></td></tr><tr><td> BCM56142
</td><td> BCM56142 A0
</td><td> 24-Port Fast Ethernet Multilayer Switch with four 1G/2.5Gb/Higig2/HG Lite Uplink Ports
</td></tr><tr><td> BCM56150
</td><td> BCM56150 A0
</td><td> 24-port GbE Managed Switch with 4-port 10 GbE uplinks, integrated CPU and 16 copper PHYs
</td></tr><tr><td></td><td> BCM56151 A0
</td><td> 24-port GbE Managed Switch with 4-port 10 GbE uplinks, integrated CPU (without PHYs)
</td></tr><tr><td></td><td> BCM56152 A0
</td><td> 24-port GbE plus 2-port GbE and 2-port 1GbE/13GbE uplinks Managed Switch, integrated CPU and 16 copper PHYs
</td></tr><tr><td></td><td> BCM53342 A0
</td><td> 8-port GbE Multilayer WebSmart Switch with Integrated CPU and Copper PHYs
</td></tr><tr><td></td><td> BCM53343 A0
</td><td> 16-port GbE plus 4-port GbE uplinks Multilayer WebSmart Switch with Integrated CPU and 16 Copper PHYs
</td></tr><tr><td></td><td> BCM53344 A0
</td><td> 24-port GbE plus 2-port GbE and 2-port 1GbE/13GbE uplinks WebSmart Switch, integrated CPU and 16 copper PHYs
</td></tr><tr><td></td><td> BCM53346 A0
</td><td> 24-port GbE Multilayer WebSmart Switch with 4-port 10 GbE uplinks, integrated CPU and 16 copper PHYs
</td></tr><tr><td></td><td> BCM53393 A0
</td><td> 14-port GbE Multilayer Embedded Switch with integrated CPU (without PHY)
</td></tr><tr><td></td><td> BCM53394 A0
</td><td> 10-port GbE Multilayer Embedded Switch with 4-port 10 GbE uplinks, integrated CPU (without PHY)
</td></tr><tr><td> BCM56220
</td><td> BCM56224 A0
</td><td> 24 GbE + 4 x 1 Gb/2.5 Gb, L3/L2+
</td></tr><tr><td></td><td> BCM56224 B0
</td><td> 24 GbE + 4 x 1 Gb/2.5 Gb, L3/L2+
</td></tr><tr><td></td><td> BCM56225 A0
</td><td> 24 GbE + 4 x 1 Gb/2.5 Gb, L2+
</td></tr><tr><td></td><td> BCM56225 B0
</td><td> 24 GbE + 4 x 1 Gb/2.5 Gb, L2+
</td></tr><tr><td></td><td> BCM56226 A0
</td><td> 16 GbE + 4 x 1 Gb/2.5 Gb, L3/L2+
</td></tr><tr><td></td><td> BCM56226 B0
</td><td> 16 GbE + 4 x 1 Gb/2.5 Gb, L3/L2+
</td></tr><tr><td></td><td> BCM56227 A0
</td><td> 16 GbE + 4 x 1 Gb/2.5 Gb, L2+
</td></tr><tr><td></td><td> BCM56227 B0
</td><td> 16 GbE + 4 x 1 Gb/2.5 Gb, L2+
</td></tr><tr><td></td><td> BCM56228 A0
</td><td> 8 GbE + 4 x 1 Gb/2.5 Gb, L3/L2+
</td></tr><tr><td></td><td> BCM56228 B0
</td><td> 8 GbE + 4 x 1 Gb/2.5 Gb, L3/L2+
</td></tr><tr><td></td><td> BCM56229 A0
</td><td> 8 GbE + 4 x 1 Gb/2.5 Gb, L2+
</td></tr><tr><td></td><td> BCM56229 B0
</td><td> 8 GbE + 4 x 1 Gb/2.5 Gb, L2+
</td></tr><tr><td> BCM56230
</td><td> BCM56230 B1
</td><td> 12-Port GbE Multilayer Switch
</td></tr><tr><td></td><td> BCM56231 B1
</td><td> 6-Port GbE Multilayer Switch
</td></tr><tr><td> BCM56240
</td><td> BCM56240 A0
</td><td> 2-Port 10GbE (OR 8 *2.5GbE) Multilayer Switch with Two 10-GbE/Hig2 Uplink ports
</td></tr><tr><td> BCM56240
</td><td> BCM56240 B0
</td><td> 2-Port 10GbE (OR 8 *2.5GbE) Multilayer Switch with Two 10-GbE/Hig2 Uplink ports
</td></tr><tr><td></td><td> BCM56241 A0
</td><td> 6-Port GbE Multilayer Switch with Two 2.5GbE Uplink ports
</td></tr><tr><td></td><td> BCM56242 A0
</td><td> 8-Port 2.5GbE Multilayer Switch with Two 2.5GbE Uplink ports
</td></tr><tr><td></td><td> BCM56243 A0
</td><td> 4-Port 2.5GbE Multilayer Switch
</td></tr><tr><td> BCM56320
</td><td> BCM56320 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56320 B0
</td><td></td></tr><tr><td></td><td> BCM56320 B1
</td><td></td></tr><tr><td></td><td> BCM56321 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56321 B0
</td><td></td></tr><tr><td></td><td> BCM56321 B1
</td><td></td></tr><tr><td> BCM56330
</td><td> BCM56331 A0
</td><td> 24-Port GbE Multilayer Switch with Four 2.5GbE Uplink Ports
</td></tr><tr><td></td><td> BCM56331 B0
</td><td></td></tr><tr><td></td><td> BCM56331 B1
</td><td></td></tr><tr><td></td><td> BCM56333 A0
</td><td> 16-Port GbE Multilayer Switch
</td></tr><tr><td></td><td> BCM56333 B0
</td><td></td></tr><tr><td></td><td> BCM56333 B1
</td><td></td></tr><tr><td></td><td> BCM56334 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56334 B0
</td><td></td></tr><tr><td></td><td> BCM56334 B1
</td><td></td></tr><tr><td></td><td> BCM56338 A0
</td><td> 8-Port GbE Multilayer Switch with two 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56338 B0
</td><td></td></tr><tr><td></td><td> BCM56338 B1
</td><td></td></tr><tr><td> BCM56440
</td><td> BCM55441 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/Hig2 Uplink ports
</td></tr><tr><td></td><td> BCM56440 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/Hig2 Uplink ports
</td></tr><tr><td></td><td> BCM56440 B0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/Hig2 Uplink ports
</td></tr><tr><td></td><td> BCM56441 A0
</td><td> 8-Port GbE Multilayer Switch with Two 10-GbE/Hig2 Uplink ports
</td></tr><tr><td></td><td> BCM56442 A0
</td><td> 16-Port GbE Multilayer Switch
</td></tr><tr><td></td><td> BCM56443 A0
</td><td> 8-Port 2.5GbE Multilayer Switch with Two 10-GbE/Hig2 Uplink ports
</td></tr><tr><td></td><td> BCM56445 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/Hig2 Uplink ports pin compatible with BCM56334
</td></tr><tr><td></td><td> BCM56446 A0
</td><td> 8-Port GbE Multilayer Switch with Two 10-GbE/Hig2 Uplink ports pin compatible with BCM56338
</td></tr><tr><td></td><td> BCM56447 A0
</td><td> 16-Port GbE Multilayer Switch pin compatible with BCM56333
</td></tr><tr><td></td><td> BCM56448 A0
</td><td> 24-Port GbE Multilayer Switch with Four 1GbE/ One 2.5G Uplink ports
</td></tr><tr><td> BCM56450
</td><td> BCM56450 A0
</td><td> 24-port GbE Multilayer Switch with 4-port 10 GbE uplinks, stacking, integrated CPU and Traffic Manager
</td></tr><tr><td></td><td> BCM56455 A0
</td><td> 2 x 20GE (G.INT) + 2 x HG13
</td></tr><tr><td></td><td> BCM56456 B0
</td><td> 1 x XAUI + 8 x GE
</td></tr><tr><td> BCM56500
</td><td> BCM56500 A0
</td><td> 24-Port Gigabit Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56500 A1
</td><td></td></tr><tr><td></td><td> BCM56500 B0
</td><td></td></tr><tr><td></td><td> BCM56500 B1
</td><td></td></tr><tr><td></td><td> BCM56500 B2
</td><td></td></tr><tr><td></td><td> BCM56501 A0
</td><td> Four 10-Gigabit Ethernet/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56501 A1
</td><td></td></tr><tr><td></td><td> BCM56501 B0
</td><td></td></tr><tr><td></td><td> BCM56501 B1
</td><td></td></tr><tr><td></td><td> BCM56501 B2
</td><td></td></tr><tr><td></td><td> BCM56502 A0
</td><td> 24-Port GbE Multilayer Switch with Two 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56502 A1
</td><td></td></tr><tr><td></td><td> BCM56502 B0
</td><td></td></tr><tr><td></td><td> BCM56502 B1
</td><td></td></tr><tr><td></td><td> BCM56502 B2
</td><td></td></tr><tr><td></td><td> BCM56503 A0
</td><td> 24-Port GbE Multilayer Switch with Three 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56503 A1
</td><td></td></tr><tr><td></td><td> BCM56503 B0
</td><td></td></tr><tr><td></td><td> BCM56503 B1
</td><td></td></tr><tr><td></td><td> BCM56503 B2
</td><td></td></tr><tr><td></td><td> BCM56504 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56504 A1
</td><td></td></tr><tr><td></td><td> BCM56504 B0
</td><td></td></tr><tr><td></td><td> BCM56504 B1
</td><td></td></tr><tr><td></td><td> BCM56504 B2
</td><td></td></tr><tr><td></td><td> BCM56505 A0
</td><td> 24-Port GbE Layer 2 Switch
</td></tr><tr><td></td><td> BCM56505 A1
</td><td></td></tr><tr><td></td><td> BCM56505 B0
</td><td></td></tr><tr><td></td><td> BCM56505 B1
</td><td></td></tr><tr><td></td><td> BCM56505 B2
</td><td></td></tr><tr><td></td><td> BCM56506 A0
</td><td> Four 10-Gigabit Ethernet/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56506 A1
</td><td></td></tr><tr><td></td><td> BCM56506 B0
</td><td></td></tr><tr><td></td><td> BCM56506 B1
</td><td></td></tr><tr><td></td><td> BCM56506 B2
</td><td></td></tr><tr><td></td><td> BCM56507 A0
</td><td> 24-Port GbE Layer 2 Switch with Two 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56507 A1
</td><td></td></tr><tr><td></td><td> BCM56507 B0
</td><td></td></tr><tr><td></td><td> BCM56507 B1
</td><td></td></tr><tr><td></td><td> BCM56507 B2
</td><td></td></tr><tr><td></td><td> BCM56508 A0
</td><td> 24-Port GbE Layer 2 Switch with Three 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56508 A1
</td><td></td></tr><tr><td></td><td> BCM56508 B0
</td><td></td></tr><tr><td></td><td> BCM56508 B1
</td><td></td></tr><tr><td></td><td> BCM56508 B2
</td><td></td></tr><tr><td></td><td> BCM56509 A0
</td><td> 24-Port GbE Layer 2 Switch with Four 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56509 A1
</td><td></td></tr><tr><td></td><td> BCM56509 B0
</td><td></td></tr><tr><td></td><td> BCM56509 B1
</td><td></td></tr><tr><td></td><td> BCM56509 B2
</td><td></td></tr><tr><td> BCM56510
</td><td> BCM56510 A0
</td><td> 24-Port Gigabit Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56511 A0
</td><td> Four-Port 10-GbE/HiGig+ Multilayer Switch
</td></tr><tr><td></td><td> BCM56512 A0
</td><td> 24-Port GbE Multilayer Switch With Two 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56513 A0
</td><td> 24-Port GbE Multilayer Switch With Three 10-GbE/HiGig+ Ports
</td></tr><tr><td></td><td> BCM56514 A0
</td><td> 24-Port GbE Multilayer Switch With Four 10-GbE/HiGig+ Ports
</td></tr><tr><td> BCM56520
</td><td> BCM56520 A0
</td><td> 24-Port GbE Multilayer Switch
</td></tr><tr><td></td><td> BCM56520 B0
</td><td></td></tr><tr><td></td><td> BCM56522 A0
</td><td> 24-Port GbE Multilayer Switch with Two 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56522 B0
</td><td></td></tr><tr><td></td><td> BCM56524 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56524 B0
</td><td></td></tr><tr><td></td><td> BCM56526 A0
</td><td> 28-Port GbE Multilayer Switch with Six 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56526 B0
</td><td></td></tr><tr><td> BCM56530
</td><td> BCM56534 B0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56538 B0
</td><td> 48-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td> BCM56620
</td><td> BCM56620 A0
</td><td></td></tr><tr><td></td><td> BCM56620 A1
</td><td></td></tr><tr><td></td><td> BCM56620 B0
</td><td></td></tr><tr><td></td><td> BCM56620 B1
</td><td></td></tr><tr><td></td><td> BCM56624 A0
</td><td> 49 port 1-GbE Multilayer Ethernet Switch with 4 x 10-GbE/HiGig2
Uplink ports and External Table Expansion
</td></tr><tr><td></td><td> BCM56624 A1
</td><td></td></tr><tr><td></td><td> BCM56624 B0
</td><td></td></tr><tr><td></td><td> BCM56624 B1
</td><td></td></tr><tr><td></td><td> BCM56624 B2
</td><td></td></tr><tr><td></td><td> BCM56626 A0
</td><td> 25 port 1-GbE Multilayer Ethernet Switch with 6 x 10-GbE/HiGig2 Uplink ports and External Table Expansion
</td></tr><tr><td></td><td> BCM56626 A1
</td><td></td></tr><tr><td></td><td> BCM56626 B0
</td><td></td></tr><tr><td></td><td> BCM56626 B1
</td><td></td></tr><tr><td></td><td> BCM56626 B2
</td><td></td></tr><tr><td></td><td> BCM56628 A0
</td><td> 8 port 10-GbE/HiGig2 Multilayer Ethernet Switch with External Table Expansion
</td></tr><tr><td></td><td> BCM56628 A1
</td><td></td></tr><tr><td></td><td> BCM56628 B0
</td><td></td></tr><tr><td></td><td> BCM56628 B1
</td><td></td></tr><tr><td></td><td> BCM56628 B2
</td><td></td></tr><tr><td></td><td> BCM56629 B0      
</td><td> 25 port 1-GbE Multilayer Ethernet Switch with 8 x 10-GbE/HiGig2 Uplink ports and External Table Expansion
</td></tr><tr><td></td><td> BCM56629 B1
</td><td></td></tr><tr><td> BCM56630
</td><td> BCM56630 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56630 B0
</td><td></td></tr><tr><td></td><td> BCM56634 A0
</td><td> 48-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56634 B0
</td><td></td></tr><tr><td></td><td> BCM56636 A0
</td><td> 24-Port GbE + 2-Port 10-GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56636 B0
</td><td></td></tr><tr><td></td><td> BCM56638 A0
</td><td> 4-Port 10-GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56638 B0
</td><td></td></tr><tr><td></td><td> BCM56639 A0
</td><td> 24-Port GbE + 4-Port 10-GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56639 B0
</td><td></td><td></td></tr><tr><td> BCM56540
</td><td> BCM56540 A0
</td><td> 48xGE + 2xHG[42] + 2xHG[21] + 1GE, 48xGE + 4xXFI + 2xHG[42] + 1GE, 48xGE + 8xXFI + 1GE Multilayer Ethernet Switch (Preview)
</td></tr><tr><td></td><td> BCM56540 A1
</td><td></td></tr><tr><td> BCM56540
</td><td> BCM56541 A0
</td><td> 28xGE + 2xHG[42] + 2xHG[21] + 1GE, 28xGE + 4xXFI + 2xHG[42] + 1GE, 28xGE + 8xXFI + 1GE Multilayer Ethernet Switch (Preview)
</td></tr><tr><td></td><td> BCM56541 A1
</td><td></td></tr><tr><td> BCM56540
</td><td> BCM56542 A0
</td><td> 28xGE + 2xF.XAUI/2x10GE + 2xF.HG[42] + 2xF.HG[21] + 1GE, 28xGE + 8xGE/8x2.5GE + 2xHG[42] + 2xHG[21] + 1GE Multilayer Ethernet Switch (Preview)
</td></tr><tr><td></td><td> BCM56542 A1
</td><td></td></tr><tr><td> BCM56540
</td><td> BCM56544 A0
</td><td> 10xF.XAUI + 4xHG[21] + 1GE, 10xF.XAUI + 4xXFI, 10xF.XAUI + 2xHG[42], 4xXAUI + 12xXFI + 1GE Multilayer Ethernet Switch (Preview)
</td></tr><tr><td></td><td> BCM56544 A1
</td><td></td></tr><tr><td> BCM56540
</td><td> BCM56545 A0
</td><td> 48xGE + 2xHG[42] + 2xHG[21] + 1GE, 48xGE + 4xXFI + 2xHG[42] + 1GE, 48xGE + 8xXFI + 1GE Multilayer Ethernet Switch (Preview)
</td></tr><tr><td></td><td> BCM56545 A1
</td><td></td></tr><tr><td> BCM56540
</td><td> BCM56546 A0
</td><td> 28xGE + 2xHG[42] + 2xHG[21] + 1GE, 28xGE + 4xXFI + 2xHG[42] + 1GE, 28xGE + 8xXFI + 1GE Multilayer Ethernet Switch (Preview)
</td></tr><tr><td> BCM56640
</td><td> BCM56640 A0
</td><td> 1x100GE + 1xHG[127], 1x100GE + 4xHG[32], 1x100GE + 8xHGd[16], 3xF.HG[42] +
1xHG[127], 3xF.HG[42] + 4xHG[32], 3xF.HG[42] + 8xHGd[16], 3xF.HG[42] + 3xF.HG[42] Multilayer Ethernet Switch (Preview)
</td></tr><tr><td></td><td> BCM56640 A1
</td><td></td></tr><tr><td> BCM56640
</td><td> BCM56643 A0
</td><td> 48xGE + 4xXFI + 4xHG[42] + 1GE Multilayer Ethernet Switch (Preview)
</td></tr><tr><td></td><td> BCM56643 A1
</td><td></td></tr><tr><td> BCM56640
</td><td> BCM56644 A0
</td><td> 48xGE + 2xHG[25] + 2xHG[25] + 1GE Multilayer Ethernet Switch (Preview)
</td></tr><tr><td></td><td> BCM56644 A1
</td><td></td></tr><tr><td> BCM56640
</td><td> BCM56648 A0
</td><td> 48xGE + 2xHG[42] + 2xHG[21] + 1GE, 48xGE + 4xXFI + 2xHG[42] + 1GE, 48xGE + 8xXFI + 1GE Multilayer Ethernet Switch (Preview)
</td></tr><tr><td></td><td> BCM56648 A1
</td><td></td></tr><tr><td> BCM56640
</td><td> BCM56649 A0
</td><td> 28xGE + 2xHG[42] + 2xHG[21] + 1GE, 28xGE + 4xXFI + 2xHG[42] + 1GE, 28xGE + 8xXFI + 1GE Multilayer Ethernet Switch (Preview)
</td></tr><tr><td> BCM56680
</td><td> BCM56680 A0
</td><td> 25 port 1-GbE/2.5GbE Multilayer Ethernet Switch with 4 x
10-GbE/HiGig2 Uplink ports
</td></tr><tr><td></td><td> BCM56680 A1
</td></tr><tr><td></td><td> BCM56680 B0
</td><td></td></tr><tr><td></td><td> BCM56680 B1
</td><td></td></tr><tr><td></td><td> BCM56684 A0
</td><td> 24 port 1-GbE/2.5GbE Multilayer Ethernet Switch with 4 x
10-GbE/HiGig2 Uplink ports
</td></tr><tr><td></td><td> BCM56684 A1
</td><td></td></tr><tr><td></td><td> BCM56684 B0
</td><td></td></tr><tr><td></td><td> BCM56684 B1
</td><td></td></tr><tr><td> BCM56685
</td><td> BCM56685 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56685 B0
</td><td></td></tr><tr><td></td><td> BCM56689 A0
</td><td> 24-Port GbE Multilayer Switch with Four 10-GbE/HiGig2 Uplink Ports
</td></tr><tr><td></td><td> BCM56689 B0
</td><td></td></tr><tr><td> BCM56700
</td><td> BCM56700 A0
</td><td> 16-Port, 192-Gbps Lossless Switch Fabric
</td></tr><tr><td></td><td> BCM56701 A0
</td><td> 12-Port, 144-Gbps Lossless Switch Fabric
</td></tr><tr><td> BCM56720
</td><td> BCM56720 A0
</td><td> 16 Port, 16-Gbps HiGig2 Switch Fabric
</td></tr><tr><td></td><td> BCM56721 A0
</td><td> 12 Port, 16-Gbps HiGig2 Switch Fabric
</td></tr><tr><td> BCM56725
</td><td> BCM56725 A0
</td><td> 8 Port, 20-Gbps + 4 Port, 16-Gbps HiGig2 Switch Fabric
</td></tr><tr><td> BCM56800
</td><td> BCM56800 A0
</td><td> 20-Port 10-Gigabit Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56801 A0
</td><td> 10-Port 10-Gigabit Ethernet and 8-Port HiGig2/10GbE Multilayer Switch
</td></tr><tr><td></td><td> BCM56802 A0
</td><td> 16-Port 10-GbE/HiGig2 Multilayer Switch
</td></tr><tr><td></td><td> BCM56803 A0
</td><td> 12 Port 10GE/HiGig2 Multilayer Switch
</td></tr><tr><td> BCM56820
</td><td> BCM56820 A0
</td><td> 24 x 10-GbE + 4 x 1-GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56820 B0
</td><td></td></tr><tr><td></td><td> BCM56821 A0
</td><td> 12 x 10-GbE + 8 x HiGig2 + 4 x 1-GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56821 B0
</td><td></td></tr><tr><td></td><td> BCM56822 A0
</td><td> 12 x 10-GbE + 4 x 20-Gbps HiGig2 + 4 x 1-GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56822 B0
</td><td></td></tr><tr><td></td><td> BCM56823 A0
</td><td> 8 x 10-GbE + 4 x 20-Gbps HiGig2 + 4 x 1-GbE Multilayer Ethernet Switch
</td></tr><tr><td></td><td> BCM56823 B0
</td><td></td></tr><tr><td></td><td> BCM56825 B0
</td><td> 16 x 10-GbE + 8 x 20-Gbps HiGig2 + 1 x 1-GbE Multilayer Ethernet Switch
</td></tr><tr><td> BCM56840
</td><td> BCM56841 A0
</td><td> 320 Gbps Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56841 A1
</td><td></td></tr><tr><td></td><td> BCM56841 A2
</td><td></td></tr><tr><td></td><td> BCM56841 A3
</td><td></td></tr><tr><td></td><td> BCM56841 A4
</td><td></td></tr><tr><td></td><td> BCM56841 B0
</td><td></td></tr><tr><td></td><td> BCM56841 B1
</td><td></td></tr><tr><td></td><td> BCM56843 A0
</td><td> 480 Gbps Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56843 A1
</td><td></td></tr><tr><td></td><td> BCM56843 A2
</td><td></td></tr><tr><td></td><td> BCM56843 A3
</td><td></td></tr><tr><td></td><td> BCM56843 A4
</td><td></td></tr><tr><td></td><td> BCM56843 B0
</td><td></td></tr><tr><td></td><td> BCM56843 B1
</td><td></td></tr><tr><td></td><td> BCM56845 A0
</td><td> 640 Gbps Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56845 A1
</td><td></td></tr><tr><td></td><td> BCM56845 A2
</td><td></td></tr><tr><td></td><td> BCM56845 A3
</td><td></td></tr><tr><td></td><td> BCM56845 A4
</td><td></td></tr><tr><td></td><td> BCM56845 B0
</td><td></td></tr><tr><td></td><td> BCM56845 B1
</td><td></td></tr><tr><td> <tt>BCM56840_PLUS</tt>
</td><td> BCM56842 A0
</td><td> 320 Gbps Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56842 A1
</td><td></td></tr><tr><td></td><td> BCM56844 A0
</td><td> 480 Gbps Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56844 A1
</td><td></td></tr><tr><td></td><td> BCM56846 A0
</td><td> 640 Gbps Ethernet Multilayer Switch
</td></tr><tr><td></td><td> BCM56846 A1
</td><td></td></tr><tr><td> BCM56850
</td><td> BCM56850 A0
</td><td> 1.28Tbps I/O, 1Tbps Core Ethernet Switch
</td></tr><tr><td></td><td> BCM56854 A0
</td><td> 1.28Tbps I/O, 1Tbps Core Ethernet Switch
</td></tr><tr><td></td><td> BCM56850 A1
</td><td> 1.28Tbps I/O, 1Tbps Core Ethernet Switch
</td></tr><tr><td></td><td> BCM56854 A1
</td><td> 1.28Tbps I/O, 1Tbps Core Ethernet Switch
</td></tr><tr><td> BCM88640
</td><td> BCM88640 A0
</td><td> 80GBps DNX Traffic manager + Packet processor
</td></tr><tr><td></td><td> BCM88640 B0
</td><td></td></tr><tr><td> BCM88650
</td><td> BCM88650 A0
</td><td> 200GBps DNX Traffic manager + Packet processor
</td></tr><tr><td></td><td> BCM88650 B0
</td><td></td></tr><tr><td></td><td> BCM88650 B1
</td><td></td></tr><tr><td> BCM88660
</td><td> BCM88660 A0
</td><td> 200GBps DNX Traffic manager + Packet processor
</td></tr><tr><td> BCM88750 
</td><td> BCM88750 A0
</td><td> 1600GBps DNX Switch fabric
</td></tr><tr><td></td><td> BCM88750 B0
</td><td></td></tr></tbody></table>Note: There is no warm boot support for External table expansion in BCM56620, BCM56630 and BCM56640 device family.
<p><br><hr noshade><a name="phys"></a>
<h3>Section 7.2:   PHYs
</h3>
<p><h3>Table 97:   PHYs
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Device</b></td><td><b>  Driver Family</b></td><td><b> Description
</b></td></tr><tr><td> BCM5218
</td><td> 522x
</td><td> 10/100Base-TX/FX Octal-PHY(tm) Transceiver
</td></tr><tr><td> BCM5220
</td><td> 522x
</td><td> 10/100BASE-TX/FX Mini-F(tm) Transceiver
</td></tr><tr><td> BCM5221
</td><td> 522x
</td><td> 10/100BASE-TX/FX Mini-F(tm) Transceiver
</td></tr><tr><td> BCM5226
</td><td> 522x
</td><td> 10/100 BASE- TX/FX Hex-PHY(tm) Transceiver
</td></tr><tr><td> BCM5228
</td><td> 522x
</td><td> 10/100BASE-TX/FX Octal-F(tm) Transceiver
</td></tr><tr><td> BCM5238
</td><td> 522x
</td><td> 10/100BASE-TX OCTAL-f(tm) Transceiver
</td></tr><tr><td> BCM5248
</td><td> 522x
</td><td> 10/100BASE-TX Octal-F(tm) Transceiver
</td></tr><tr><td> BCM52681E A1
</td><td> 54680
</td><td> Octal 10/100 Ethernet Transceiver
</td></tr><tr><td> BCM5401
</td><td> 5401
</td><td> 10/100/1000BASE-T Gigabit Copper Transceiver
</td></tr><tr><td> BCM5402
</td><td> 5402
</td><td> 10/100/1000BASE-T Gigabit Copper Transceiver
</td></tr><tr><td> BCM5404
</td><td> 5404
</td><td> Quad-Port 10/100/1000BASE-T Gigabit Copper Transceiver
</td></tr><tr><td> BCM5424
</td><td> 5424
</td><td> Quad 10/100/1000BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> BCM5434
</td><td> 5424
</td><td> Quad 10/100/1000BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> BCM5411
</td><td> 5411
</td><td> 10/100/1000BASE-T Gigabit Copper Transceiver
</td></tr><tr><td> BCM5421
</td><td> 5421S
</td><td> 10/100/1000BASE-T Gigabit Copper Transceiver
</td></tr><tr><td> BCM5421S
</td><td> 5421S
</td><td> 10/100/1000BASE-T Gigabit Copper Transceiver with SerDes
</td></tr><tr><td> BCM5461
</td><td> 5464
</td><td> 10/100/1000BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> BCM5464
</td><td> 5464
</td><td> Quad-Port 10/100/1000BASE-T Gigabit Copper Transceiver
</td></tr><tr><td> BCM5464R
</td><td> 5464
</td><td> Quad-Port 10/100/1000BASE-T Gigabit Copper Transceiver
</td></tr><tr><td> BCM5464S
</td><td> 5464
</td><td> Quad-Port Gigabit Copper Transceiver with Copper/Fiber Media Interface
</td></tr><tr><td> BCM5464SR
</td><td> 5464
</td><td> Quad-Port Gigabit Copper Transceiver with Copper/Fiber Media Interface
</td></tr><tr><td> BCM5466
</td><td> 5464
</td><td> Quad-Port 10/100/1000BASE-T Gigabit Copper Transceiver
</td></tr><tr><td> BCM5466R
</td><td> 5464
</td><td> Quad-Port 10/100/1000BASE-T Gigabit Copper Transceiver
</td></tr><tr><td> BCM5466S
</td><td> 5464
</td><td> Quad-Port Gigabit Copper Transceiver with Copper/Fiber Media Interface
</td></tr><tr><td> BCM5466SR
</td><td> 5464
</td><td> Quad-Port Gigabit Copper Transceiver with Copper/Fiber Media Interface
</td></tr><tr><td> BCM5482
</td><td> 5482
</td><td> Dual-Port 10/100/1000BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> BCM5488
</td><td> 5464
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54240_C0</tt>
</td><td> 54280
</td><td> Quad 1000/100/10BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54240_C1</tt>
</td><td> 54280
</td><td> Quad 1000/100/10BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54280_A0</tt>
</td><td> 54280
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54280_C0</tt>
</td><td> 54280
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54280_C1</tt>
</td><td> 54280
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54282_A0</tt>
</td><td> 54280
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54282_C0</tt>
</td><td> 54280
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54282_C1</tt>
</td><td> 54280
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54285_C0</tt>
</td><td> 54280
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54285_C1</tt>
</td><td> 54280
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54290_A0</tt>
</td><td> 54280
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver (1588 feature is Preview)
</td></tr><tr><td> <tt>BCM54292_A0</tt>
</td><td> 54280
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver (1588 feature is Preview)
</td></tr><tr><td> <tt>BCM54294_A0</tt>
</td><td> 54280
</td><td> Quad 1000/100/10BASE-T Gigabit Ethernet Transceiver (1588 feature is Preview)
</td></tr><tr><td> <tt>BCM54340_B0</tt>
</td><td> 54380
</td><td> Quad 1000/100/10BASE-T Gigabit Ethernet Transceiver (Needs additional software component)
</td></tr><tr><td> <tt>BCM54340_C0</tt>
</td><td> 54380
</td><td> Quad 1000/100/10BASE-T Gigabit Ethernet Transceiver (Needs additional software component)
</td></tr><tr><td> <tt>BCM54340_C1</tt>
</td><td> 54380
</td><td> Quad 1000/100/10BASE-T Gigabit Ethernet Transceiver (Needs additional software component)
</td></tr><tr><td> <tt>BCM54380_B0</tt>
</td><td> 54380
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver (Needs additional software component)
</td></tr><tr><td> <tt>BCM54380_C0</tt>
</td><td> 54380
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver (Needs additional software component)
</td></tr><tr><td> <tt>BCM54380_C1</tt>
</td><td> 54380
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver (Needs additional software component)
</td></tr><tr><td> <tt>BCM54382_B0</tt>
</td><td> 54380
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver (Needs additional software component)
</td></tr><tr><td> <tt>BCM54382_C0</tt>
</td><td> 54380
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver (Needs additional software component)
</td></tr><tr><td> <tt>BCM54382_C1</tt>
</td><td> 54380
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver (Needs additional software component)
</td></tr><tr><td> <tt>BCM54385_B0</tt>
</td><td> 54380
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver (Needs additional software component)
</td></tr><tr><td> <tt>BCM54385_C0</tt>
</td><td> 54380
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver (Needs additional software component)
</td></tr><tr><td> <tt>BCM54385_C1</tt>
</td><td> 54380
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver (Needs additional software component)
</td></tr><tr><td> <tt>BCM54616_A0</tt>
</td><td> 54616
</td><td> Single-Chip 10/100/1000BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> BCM54640 
</td><td> 54640
</td><td> Quad-Port Gigabit Copper Transceiver with Copper/Fiber Media Interface
</td></tr><tr><td> <tt>BCM54640E_A1</tt>
</td><td> 54640
</td><td> Quad-Port Gigabit Copper Transceiver with Copper/Fiber Media Interface
</td></tr><tr><td> BCM54640E B0
</td><td> 54640
</td><td> Quad-Port Gigabit Copper Transceiver with Copper/Fiber Media Interface
</td></tr><tr><td> <tt>BCM54680_A0</tt>
</td><td> 54680
</td><td> Octal-Port 10/100/1000BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54680E_A1</tt>
</td><td> 54680
</td><td> Octal-Port 10/100/1000BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54680E_B0</tt>
</td><td> 54680
</td><td> Octal-Port 10/100/1000BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54682E_A1</tt>
</td><td> 54682
</td><td> Octal-Port 10/100/1000BASE-T Gigabit Ethernet Transceiver with 2 Copper/Fiber Media Interface
</td></tr><tr><td> <tt>BCM54682E_B0</tt>
</td><td> 54682
</td><td> Octal-Port 10/100/1000BASE-T Gigabit Ethernet Transceiver with 2 Copper/Fiber Media Interface
</td></tr><tr><td> <tt>BCM54684_D0</tt>
</td><td> 54684
</td><td> Octal-Port 10/100/1000BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> BCM54684E B0
</td><td> 54682
</td><td> 10/100/1000 Octal (65nm) QSGMII-Copper/Fiber(2) with EEE
</td></tr><tr><td> BCM54685
</td><td> 54682
</td><td> Octal QSGMII to 10/100/1000BaseT or Fiber Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54685E_A1</tt>
</td><td> 54682
</td><td> Octal-Port 10/100/1000BASE-T Gigabit Ethernet Transceiver with Copper/Fiber Media Interface
</td></tr><tr><td> <tt>BCM54810_A0</tt>
</td><td> 54880
</td><td> BroadR-Reach Single-Port 10/100/1000BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54880_A0</tt>
</td><td> 54880
</td><td> Octal-Port 10/100/1000BASE-T Gigabit Ethernet Transceiver with BroadR-Reach support
</td></tr><tr><td> <tt>BCM54880_B0</tt>
</td><td> 54880
</td><td> Octal-Port 10/100/1000BASE-T Gigabit Ethernet Transceiver with BroadR-Reach support
</td></tr><tr><td> <tt>BCM54880E_A1</tt>
</td><td> 54680
</td><td> Octal-Port 10/100/1000BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54880E_B0</tt>
</td><td> 54680
</td><td> Octal-Port 10/100/1000BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54881_B0</tt>
</td><td> 54880
</td><td> Octal 10/100Base/Tx Ethernet BroadReach Transceiver
</td></tr><tr><td> BCM54942 A0
</td><td> 84728
</td><td> Quad-Channel 10GbE XAUI-to-XFI PHY. Firmware version 0124
</td></tr><tr><td> <tt>BCM54980_B2</tt>
</td><td> 54980
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54980_C0</tt>
</td><td> 54980
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM54980_C1</tt>
</td><td> 54980
</td><td> Octal 1000/100/10BASE-T Gigabit Ethernet Transceiver
</td></tr><tr><td> <tt>BCM8040_A2</tt>
</td><td> 8040
</td><td> Eight-Channel Multirate 1-Gbps - 3.2-Gbps Retimer/Switch
</td></tr><tr><td> <tt>BCM8073_A0</tt>
</td><td> 8072
</td><td> Dual-Channel Serial 10-GbE BASE-KR to XAUI Transceiver. Firmware version d502.
</td></tr><tr><td> <tt>BCM8074_A0</tt>
</td><td> 8072
</td><td> Quad-Channel Serial 10-GbE BASE-KR to XAUI Transceiver. Firmware version 010C.
</td></tr><tr><td> BCM8704
</td><td> 8703
</td><td> Serial 10-Gigabit Ethernet/Fibre Channel Transceiver with XAUI Interface
</td></tr><tr><td> BCM8705
</td><td> 8705
</td><td> Serial 10-Gigabit Ethernet/Fibre Channel Transceiver with WIS Layer and XAUI Interface
</td></tr><tr><td> BCM8725
</td><td> 8705
</td><td> Dual Serial 10-Gigabit Ethernet/Fibre Channel Transceiver with WIS Layer and XAUI
Interface
</td></tr><tr><td> <tt>BCM8726_A0</tt>
</td><td> 8706
</td><td> Dual Serial 10-Gigabit Ethernet/Fibre Channel Transceiver with XAUI Interface
</td></tr><tr><td> <tt>BCM8726_B1</tt>
</td><td> 8706
</td><td> Dual Serial 10-Gigabit Ethernet/Fibre Channel Transceiver with XAUI(TM) Interface. Firmware version 0x0127
</td></tr><tr><td> <tt>BCM8727_B0</tt>
</td><td> 8706
</td><td> Dual Serial 10-Gigabit Ethernet/Fibre Channel Transceiver with XAUI Interface. Firmware version 0406.
</td></tr><tr><td> <tt>BCM8727_C0</tt>
</td><td> 8706
</td><td> Dual Serial 10-Gigabit Ethernet/Fibre Channel Transceiver with XAUI Interface. Firmware version 050D.
</td></tr><tr><td> <tt>BCM84727_A0</tt>
</td><td> 84728
</td><td> Dual SFI to XAUI with 1588 (Firmware version 0x124. Preview)
</td></tr><tr><td> <tt>BCM8728_A0</tt>
</td><td> 8706
</td><td> Dual-Channel 10-GbE SFI-to-XAUI(TM) Transceiver with EDC. Firmware version 0511. (Preview)
</td></tr><tr><td> BCM8742
</td><td> 8706
</td><td> Quad-Channel 10-GbE SFI-to-XAUI(TM) Transceiver. Firmware version 0511.
</td></tr><tr><td> <tt>BCM8747_A0</tt>
</td><td> 8706
</td><td> Quad-Channel 10-GbE SFI-to-XAUI(TM) Transceiver with EDC. Firmware version 0511.
</td></tr><tr><td> <tt>BCM8750_A0</tt>
</td><td> 8750
</td><td> Dual-Channel 10 GbE SFI-to-XFI PHY with EDC
</td></tr><tr><td> <tt>BCM8752_A0</tt>
</td><td> 8750
</td><td> Dual-Channel 10 GbE SFI-to-XFI PHY with EDC
</td></tr><tr><td> <tt>BCM8754_A0</tt>
</td><td> 8750
</td><td> Quad-Channel 10 GbE SFI-to-XFI PHY with EDC. Firmware version 0411.
</td></tr><tr><td> <tt>BCM8481_B0</tt>
</td><td> 8481
</td><td> 10GBASE-T Transceiver (Firmware version B0 02.10)
</td></tr><tr><td> <tt>BCM8481_C0</tt>
</td><td> 8481
</td><td> 10GBASE-T Transceiver (Firmware version C0 02.13)
</td></tr><tr><td> BCM84164
</td><td> BCM84740
</td><td> Quad 10GBASE-KR-to-XFI or 40GBASE-KR4-to-XLAUI Transceiver Firmware version 0x128
</td></tr><tr><td> BCM84168
</td><td> BCM84740
</td><td> Octal 10GBASE-KR-to-XFI or Dual 40GBASE-KR4-to-XLAUI Transceiver Firmware version 0x128
</td></tr><tr><td> <tt>BCM84318_A0</tt>
</td><td> 84740
</td><td> 10.3 Gbps Octal Port CDR/Retimer with EDC. Firmware version D007
</td></tr><tr><td> <tt>BCM82328_A0</tt>
</td><td> 82328
</td><td> Dual 40 GbE/Octal 10 GbE QSFP+ XLPPI-to-XLAUI PHY. Firmware version 9 "(Preview)
</td></tr><tr><td> <tt>BCM82328_B0</tt>
</td><td> 82328
</td><td> Dual 40 GbE/Octal 10 GbE QSFP+ XLPPI-to-XLAUI PHY. Firmware version B "(Preview)
</td></tr><tr><td> <tt>BCM84328_A0</tt>
</td><td> 84328
</td><td> Dual 40 GbE/Octal 10 GbE QSFP+ XLPPI-to-XLAUI PHY. Firmware version D026
</td></tr><tr><td> <tt>BCM84328_B0</tt>
</td><td> 84328
</td><td> Dual 40 GbE/Octal 10 GbE QSFP+ XLPPI-to-XLAUI PHY. Firmware version R026
</td></tr><tr><td> <tt>BCM84333_B1</tt>
</td><td> 8481
</td><td> Quad 10GBASE-T Transceiver. Firmware version 1.69 (Preview) (Needs additional software component)
</td></tr><tr><td> <tt>BCM84334_B1</tt>
</td><td> 8481
</td><td> Quad 10GBASE-T Transceiver. Firmware version 1.69 (Preview) (Needs additional software component)
</td></tr><tr><td> <tt>BCM84336_B1</tt>
</td><td> 8481
</td><td> Dual 10GBASE-T Transceiver. Firmware version 1.69 (Preview) (Needs additional software component)
</td></tr><tr><td> <tt>BCM84793_A0</tt>
</td><td> 84793
</td><td> 100GbE/OTN 4x25/28G VSR28 to 10x10/11G CAUI Gearbox PHY. Firmware version 0xD009 (Preview - Mode-1 and Mode-3)
</td></tr><tr><td> <tt>BCM84812_A0</tt>
</td><td> 8481
</td><td> Dual 10GBASE-T Transceiver. Firmware version 2.13
</td></tr><tr><td> <tt>BCM84821_A0</tt>
</td><td> 8481
</td><td> 10GBASE-T Transceiver. Firmware version 2.13 (Preview)
</td></tr><tr><td> <tt>BCM84822_A0</tt>
</td><td> 8481
</td><td> Dual 10GBASE-T Transceiver. Firmware version 3.02
</td></tr><tr><td> <tt>BCM84823_A0</tt>
</td><td> 8481
</td><td> Dual 10GBASE-T Transceiver. Firmware version 3.02
</td></tr><tr><td> <tt>BCM84823_B0</tt>
</td><td> 8481
</td><td> Dual 10GBASE-T Transceiver. Firmware version 4.02
</td></tr><tr><td> <tt>BCM84823_B1</tt>
</td><td> 8481
</td><td> Dual 10GBASE-T Transceiver. Firmware version 4.02
</td></tr><tr><td> <tt>BCM84833_B1</tt>
</td><td> 8481
</td><td> Dual 10GBASE-T Transceiver. Firmware version 1.69(Driver support for IEEE 1588 features are preview)
</td></tr><tr><td> <tt>BCM84834_B1</tt>
</td><td> 8481
</td><td> Quad 10GBASE-T Transceiver. Firmware version 1.69(Driver support for IEEE 1588 features are preview)
</td></tr><tr><td> <tt>BCM84836_B1</tt>
</td><td> 8481
</td><td> Dual 10GBASE-T Transceiver. Firmware version 1.69(Driver support for IEEE 1588 features are preview)
</td></tr><tr><td> <tt>BCM84844_A0</tt>
</td><td> 8481
</td><td> Quad 10GBASE-T Transceiver. Firmware version 1.06(Driver support is preview)
</td></tr><tr><td> <tt>BCM84846_A0</tt>
</td><td> 8481
</td><td> Dual 10GBASE-T Transceiver. Firmware version 1.06(Driver support is preview)
</td></tr><tr><td> <tt>BCM84848_A0</tt>
</td><td> 8481
</td><td> Quad 10GBASE-T Transceiver. Firmware version 1.06(Driver support is preview)
</td></tr><tr><td> BCM84728 A0
</td><td> 84728
</td><td> Dual-Channel 10 GbE SFI-to-XAUI LAN/WAN PHY with 1588. Firmware version 0124 (Driver support for IEEE 1588 features is preview)
</td></tr><tr><td> <tt>BCM84729_A0</tt>
</td><td> 84729
</td><td> Dual-Channel SFI to XAUI with Macsec, 1588 (Firmware version 0x124. Driver support for IEEE 1588 features are preview)
</td></tr><tr><td> BCM84740 A0
</td><td> 84740
</td><td> 40 GbE PPI-to-XLAUI PHY with EDC. Firmware version D106.
</td></tr><tr><td> BCM84741 B0
</td><td> 84756
</td><td> 40GbE XLPPI-to-XLAUI/Quad 10G with IEEE MACsec/1588 Firmware version 0x0128 [Preview]
</td></tr><tr><td> <tt>BCM84747_A0</tt>
</td><td> 84728
</td><td> Quad SFI to XAUI with 1588 (Firmware version 0x124. Preview)
</td></tr><tr><td> <tt>BCM84748_A0</tt>
</td><td> 84728
</td><td> Quad SFI to XAUI with WAN/1588 (Firmware version 0x124. Preview)
</td></tr><tr><td> <tt>BCM84749_A0</tt>
</td><td> 84749
</td><td> Quad SFI to XAUI with Macsec, 1588 (Firmware version 0x124. Driver support for IEEE 1588 features are preview)
</td></tr><tr><td> BCM84752 A0
</td><td> 84740
</td><td> Dual-Channel 10 GbE SFI-to-XFI PHY with EDC. Firmware version D105. (Preview)
</td></tr><tr><td> BCM84753 A0
</td><td> 84740
</td><td> Quad-Channel 10 GbE SFI-to-XFI PHY with EDC. Firmware version D105.
</td></tr><tr><td> BCM84754 A0
</td><td> 84740
</td><td> Quad-Channel 10 GbE SFI-to-XFI PHY with EDC. Firmware version D105.
</td></tr><tr><td> BCM84756 A0
</td><td> 84756
</td><td> Quad SGMII/XFI to SGMII/SFI Transceiver Firmware version D105. (Needs additional software component)
</td></tr><tr><td> BCM84756 B0
</td><td> 84756
</td><td> Quad SGMII/XFI to SGMII/SFI Transceiver Firmware version 0x0128(Needs additional software component)
</td></tr><tr><td> BCM84756 C0
</td><td> 84756
</td><td> Quad SGMII/XFI to SGMII/SFI Transceiver Firmware version 0x0128(Needs additional software component) [Preview]
</td></tr><tr><td> BCM84758
</td><td> 84740
</td><td> 10GbE Quad SFI-XFI PHY with IEEE 1588 Firmware version 0x128
</td></tr><tr><td> BCM84759 A0
</td><td> 84756
</td><td> Quad SGMII/XFI to SGMII/SFI Transceiver Firmware version D105.
</td></tr><tr><td> BCM84759 C0
</td><td> 84756
</td><td> Quad SGMII/XFI to SGMII/SFI Transceiver Firmware version 0x0128. (Preview)
</td></tr><tr><td> <tt>BCM84780_A0</tt>
</td><td> 84740
</td><td> Octal-Channel 10 GbE SFI-to-XFI PHY with 1588. Firmware version 0x128 (Preview)
</td></tr><tr><td> <tt>BCM84784_A0</tt>
</td><td> 84740
</td><td> Dual 40GbE/Octal 10GbE QSFP+ XLPPI-to-XLAUI PHY. Firmware version 0x125 (Preview)
</td></tr><tr><td> <tt>BCM84764_A0</tt>
</td><td> 84728
</td><td> Quad SFI to RXAUI with 1588 (Firmware version 0x124. Preview)
</td></tr><tr><td> BCM84064 A0
</td><td> 84740
</td><td> Quad 10G-KR-to-XFI or 40G-KR4-to-XLAUI Transceiver. Firmware version 0108.
</td></tr><tr><td> <tt>BCM84074_A0</tt>
</td><td> 84728
</td><td> Quad KR to XAUI (Firmware version 0x124. Preview)
</td></tr></tbody></table><p><br><hr noshade><a name="os"></a>
<h3>Section 7.3:   Operating Systems
</h3>
<p>The SDK provides the SAL and BDE abstraction implementations
necessary for running the SDK on the following operating systems.
See the Platform Guide (56XX-PG817-R) for 
instructions on porting the SDK to another platform. 
<p><h3>Table 98:   Operating Systems
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> Operating System
</b></td></tr><tr><td> VxWorks 5.5
</td></tr><tr><td> VxWorks 6.2
</td></tr><tr><td> VxWorks 6.4
</td></tr><tr><td> VxWorks 6.5
</td></tr><tr><td> VxWorks 6.6
</td></tr><tr><td> Linux 2.6.21 User Mode
</td></tr><tr><td> Linux 2.6.21 Kernel Resident Mode
</td></tr><tr><td> Linux 2.6.25 User Mode
</td></tr><tr><td> Linux 2.6.25 Kernel Resident Mode
</td></tr><tr><td> Linux 2.6.27 User Mode
</td></tr><tr><td> Linux 2.6.27 Kernel Resident Mode
</td></tr><tr><td> Linux 2.6.35 User Mode
</td></tr><tr><td> Linux 2.6.35 Kernel Resident Mode
</td></tr><tr><td> POSIX Compliant (SAL ONLY)
</td></tr></tbody></table><p><br><hr noshade><a name="cpu"></a>
<h3>Section 7.4:   CPU Subsystems
</h3>
<p><h3>Table 99:   CPU Subsystems
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  CPU Subsystem</b></td><td><b> Description
</b></td></tr><tr><td> BCM98245
</td><td> CPCI 32-bit PPC with Motorola 8245 Processor
</td></tr><tr><td> BCM98548XMC
</td><td> XMC 32-bit PPC with Freescale 8548 Processor
</td></tr><tr><td> BCM953003C
</td><td> XMC 32-bit MIPS74Kc with BCM53003 Processor
</td></tr><tr><td> BCM5300X
</td><td> 32-bit MIPS74Kc with BCM5300X Processor
</td></tr><tr><td> BCM5301X
</td><td> Integrated ARM Cortex-A9 CPU on BCM5301X Switch Devices
</td></tr><tr><td> BCM5302X
</td><td> Integrated ARM Cortex-A9 CPU on BCM5302X Switch Devices
</td></tr><tr><td> BCM5621X
</td><td> Integrated MIPS CPU on BCM5621X Switch Devices
</td></tr><tr><td> BCM5622X
</td><td> Integrated MIPS CPU on BCM5622X Switch Devices
</td></tr><tr><td> BCM5331X
</td><td> Integrated MIPS CPU on BCM5331X Switch Devices
</td></tr><tr><td> BCM5360X
</td><td> Integrated MIPS74Kc CPU on BCM5360X Switch Devices
</td></tr><tr><td> BCM9XLP316LXMC
</td><td> XMC with Broadcom XLP 316 processor that includes up to sixteen NXCPUs (4 cores)
</td></tr><tr><td> BCM9XLP208XMC
</td><td> XMC with Broadcom XLP 208 processor that includes up to eight NXCPUs (2 cores)
</td></tr></tbody></table><p><br><hr noshade><a name="combinations"></a>
<h3>Section 7.5:   CPU and Operating System Combinations
</h3>
<p>The following CPU and Operating System combinations are supported
by the SDK (in addition to the above):
<p><h3>Table 100:   CPU and Operating System Combinations
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  CPU Subsystem</b></td><td><b>  Operating System</b></td><td><b> Description
</b></td></tr><tr><td> BCM98245
</td><td> VxWorks 6.2
</td><td> BSP Provided
</td></tr><tr><td> BCM98245
</td><td> Linux 2.6.21
</td><td> Available through WindRiver Linux 2.0
</td></tr><tr><td></td><td></td><td></td></tr><tr><td> BCM5621X
</td><td> VxWorks 6.4
</td><td> BSP Provided
</td></tr><tr><td> BCM5621X
</td><td> Linux 2.6.21
</td><td> Available through WindRiver Linux 2.0 <tt>bcm_ntswics</tt>
</td></tr><tr><td></td><td></td><td></td></tr><tr><td> BCM5331X
</td><td> VxWorks 6.4
</td><td> BSP Provided
</td></tr><tr><td> BCM5331X
</td><td> Linux 2.6.21
</td><td> Available through WindRiver Linux 2.0 <tt>bcm_ntswics</tt>
</td></tr><tr><td></td><td></td><td></td></tr><tr><td> BCM98548XMC
</td><td> VxWorks 6.5
</td><td> BSP Provided
</td></tr><tr><td> BCM98548XMC
</td><td> Linux 2.6.27
</td><td> Available through WindRiver Linux 3.0. Note: Additional patches for issues WIND00172598 and WIND00161649 are required. Contact your WindRiver support personnel for these patches and other WindRiver information.
</td></tr><tr><td></td><td></td><td></td></tr><tr><td> BCM5300X
</td><td> VxWorks 6.6
</td><td> BSP Provided
</td></tr><tr><td> BCM5300X
</td><td> Linux 2.6.21
</td><td> Available through WindRiver Linux 2.0
</td></tr><tr><td> BCM5300X
</td><td> Linux 2.6.27
</td><td> Available through WindRiver Linux 3.x
</td></tr><tr><td></td><td></td><td></td></tr><tr><td> BCM5301X
</td><td> Linux 2.6.35
</td><td> Available through Broadcom Customer Support Portal
</td></tr><tr><td></td><td></td><td></td></tr><tr><td> BCM5302X
</td><td> Linux 2.6.35
</td><td> Available through Broadcom Customer Support Portal
</td></tr><tr><td></td><td></td><td></td></tr><tr><td> BCM5360X
</td><td> VxWorks 6.6
</td><td> BSP Provided
</td></tr><tr><td> BCM5360X
</td><td> Linux 2.6.21
</td><td> Available through WindRiver Linux 2.0
</td></tr><tr><td> BCM5360X
</td><td> Linux 2.6.27
</td><td> Available through WindRiver Linux 3.x
</td></tr><tr><td></td><td></td><td></td></tr><tr><td> Generic X86
</td><td> Linux 2.6.25/2.6.27
</td><td></td></tr></tbody></table><p><br><br><hr noshade><br><br>
    <a name=section_media>
    <h3>Section 8:  Release Media
</h3>
<p>The Software Development Kit is released as a gzipped tar file on the Broadcom Customer Support Portal, http://support.broadcom.com. The Network Switching Software Platform Guide, also available on the Customer Support Portal, provides documentation on the various components, the source directory layout, how to build the release for various platforms, and how to customize and port the
software to new platforms. 
<br><br><hr noshade><br><br>
    <a name=section_support>
    <h3>Section 9:  Support
</h3>
<p>Questions, feedback, and/or suggestions should be sent to your Broadcom FAE.
<br><br><hr noshade><br><br>
    <a name=section_compatibility>
    <h3>Section 10:  Firmware Compatibility Matrix
 </h3>
<p>    The following table shows compatibility between different versions of SDK and Firmware releases.
 <p> <br><hr noshade><a name="bcm56440_fcm"></a>
<h3>Section 10.1:   BCM56440 Firmware Compatibility Matrix
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> SDK
 </b></td><td><b> Firmware 2.0
 </b></td><td><b> Firmware 2.1
 </b></td><td><b> Firmware 2.2
 </b></td><td><b> Firmware 3.0.0
 </b></td><td><b> Firmware 3.0.1
 </b></td><td><b> Firmware 3.1.0
 </b></td><td><b> Firmware 3.2.0
 </b></td><td><b> Firmware 3.2.1
 </b></td><td><b> Firmware 3.2.2
 </b></td><td><b> Firmware 4.0.0
 </b></td><td><b> Firmware 4.0.1
</b></td></tr><tr><td> SDK-6.2.0
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.2.1
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.2.3
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.2.4
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.2.5
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.2.6
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.2.7
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.2.8
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.2.9
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.3.0
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.3.1
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.3.2
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.3.3
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.3.4
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.3.5
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.3.6
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
</td></tr><tr><td> SDK-6.3.7
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
</td></tr><tr><td> SDK-6.4.0
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.4.1
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td></tr></tbody></table><p><p> <br><hr noshade><a name="bcm56640_fcm"></a>
<h3>Section 10.2:   BCM56640 Firmware Compatibility Matrix
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> SDK
 </b></td><td><b> Firmware 3.0.0
 </b></td><td><b> Firmware 3.0.1
 </b></td><td><b> Firmware 3.1.0
 </b></td><td><b> Firmware 3.2.0
 </b></td><td><b> Firmware 3.2.1
 </b></td><td><b> Firmware 3.2.2
 </b></td><td><b> Firmware 4.0.0
 </b></td><td><b> Firmware 4.0.1
 </b></td></tr><tr><td> SDK-6.2.3
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.4
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.5
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.6
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.7
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.8
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.9
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.0
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.1
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.2
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.3
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes*
 </td><td> Yes*
 </td><td> Yes*
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.4
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.5
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.6
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.7
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> Yes
 </td></tr><tr><td> SDK-6.4.0
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.4.1
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td></tr></tbody></table>        * In order to support embedded applications, a patch is needed to merge the fix for SDK-53008 to SDK 6.3.3 release.
 <p><p> <br><hr noshade><a name="bcm88650_fcm"></a>
<h3>Section 10.3:   BCM88650 Firmware Compatibility Matrix
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> SDK
 </b></td><td><b> Firmware 3.0.0
 </b></td><td><b> Firmware 3.0.1
 </b></td><td><b> Firmware 3.1.0
 </b></td><td><b> Firmware 3.2.0
 </b></td><td><b> Firmware 3.2.1
 </b></td><td><b> Firmware 3.2.2
 </b></td><td><b> Firmware 4.0.0
 </b></td><td><b> Firmware 4.0.1
 </b></td></tr><tr><td> SDK-6.2.3
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.4
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.5
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.6
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.7
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.8
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.9
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.0
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.1
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.2
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.3
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.4
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.5
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.6
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.7
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> Yes
 </td></tr><tr><td> SDK-6.4.0
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.4.1
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td></tr></tbody></table><p><p> <br><hr noshade><a name="bcm56850_fcm"></a>
<h3>Section 10.4:   BCM56850 Firmware Compatibility Matrix
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> SDK
 </b></td><td><b> Firmware 3.1.0
 </b></td><td><b> Firmware 3.2.0
 </b></td><td><b> Firmware 3.2.1
 </b></td><td><b> Firmware 3.2.2
 </b></td><td><b> Firmware 4.0.0
 </b></td><td><b> Firmware 4.0.1
 </b></td></tr><tr><td> SDK-6.2.6
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.7
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.8
 </td><td> No
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.9
 </td><td> No
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.0
 </td><td> No
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.1
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.2
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.3
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.4
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.5
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.6
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td></tr><tr><td> SDK-6.3.7
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td></tr><tr><td> SDK-6.4.0
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.4.1
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td></tr></tbody></table><p><p> <br><hr noshade><a name="bcm88030_fcm"></a>
<h3>Section 10.5:   BCM88030 Firmware Compatibility Matrix
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> SDK
 </b></td><td><b> Firmware 3.2.0
 </b></td><td><b> Firmware 3.2.1
 </b></td><td><b> Firmware 3.2.2
 </b></td><td><b> Firmware 4.0.0
 </b></td><td><b> Firmware 4.0.1
 </b></td></tr><tr><td> SDK-6.2.8
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.2.9
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.1
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.2
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.3
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.4
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.5
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.3.6
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td></tr><tr><td> SDK-6.3.7
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td></tr><tr><td> SDK-6.4.0
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td></tr><tr><td> SDK-6.4.1
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td></tr></tbody></table><p><p> <br><hr noshade><a name="bcm56450_fcm"></a>
<h3>Section 10.6:   BCM56450 Firmware Compatibility Matrix
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> SDK
 </b></td><td><b> Firmware 2.0
 </b></td><td><b> Firmware 2.1
 </b></td><td><b> Firmware 2.2
 </b></td><td><b> Firmware 3.0.0
 </b></td><td><b> Firmware 3.0.1
 </b></td><td><b> Firmware 3.1.0
 </b></td><td><b> Firmware 3.2.0
 </b></td><td><b> Firmware 3.2.1
 </b></td><td><b> Firmware 3.2.2
 </b></td><td><b> Firmware 4.0.0
 </b></td><td><b> Firmware 4.0.1
</b></td></tr><tr><td> SDK-6.3.6
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> No
</td></tr><tr><td> SDK-6.3.7
 </td><td> Yes
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
</td></tr><tr><td> SDK-6.4.0
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
</td></tr><tr><td> SDK-6.4.1
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> No
 </td><td> Yes
 </td><td> Yes
 </td><td> Yes
 </td></tr></tbody></table><p><p> <br><hr noshade><a name="bmacsec_cm"></a>
<h3>Section 10.7:   BMACSEC SDK Compatibility Matrix
 </h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b>  Switch SDK Release</b></td><td><b> BMACSEC SDK Release
 </b></td></tr><tr><td>  5.10.2</td><td> 3.1
 </td></tr><tr><td>  5.10.3</td><td> 3.2
 </td></tr><tr><td>  6.0.1</td><td> 3.3
 </td></tr><tr><td>  5.10.4</td><td> 3.4
 </td></tr><tr><td>  6.0.2</td><td> 3.4
 </td></tr><tr><td>  6.2.0</td><td> 3.5
 </td></tr><tr><td>  5.11.0</td><td> 3.6
 </td></tr><tr><td>  6.2.1</td><td> 3.7
 </td></tr><tr><td>  6.2.2</td><td> 3.8
 </td></tr><tr><td>  6.2.3</td><td> 3.8
 </td></tr><tr><td>  5.11.1</td><td> 3.9
 </td></tr><tr><td>  6.2.4</td><td> 3.9
 </td></tr><tr><td>  6.2.5</td><td> 3.10
 </td></tr><tr><td>  6.2.6</td><td> 3.11
 </td></tr><tr><td>  6.2.7</td><td> 3.12
 </td></tr><tr><td>  6.2.8</td><td> 3.13
 </td></tr><tr><td>  6.2.9</td><td> 3.14
 </td></tr><tr><td>  6.3.0</td><td> 4.0
 </td></tr><tr><td>  6.3.1</td><td> 4.1
 </td></tr><tr><td>  6.3.2</td><td> 4.2
 </td></tr><tr><td>  6.3.3</td><td> 4.3
 </td></tr><tr><td>  6.3.4</td><td> 4.4
 </td></tr><tr><td>  6.4.0</td><td> 4.5
 </td></tr><tr><td>  6.3.5</td><td> 4.6
 </td></tr><tr><td>  6.3.6</td><td> 4.7
 </td></tr><tr><td>  6.3.7</td><td> 4.8
 </td></tr><tr><td>  6.4.1</td><td> 4.8
 </td></tr></tbody></table><p><br><br><hr noshade><br><br>
    <a name=section_Appendix_A>
    <h3>Section 11:  SDK Externally Licensed Software Components
</h3>
<p>SDK contains a number of third-party externally licensed software components.
This appendix contains information regarding these components, the license for each of these components, and where these components are used in SDK.
<h3>Table 108:   EXTERNALLY LICENSED SOFTWARE COMPONENTS
</h3>
<table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> Component
 </b></td><td><b> Origin
 </b></td><td><b> Location in source tree
 </b></td><td><b> License terms and conditions
</b></td></tr><tr><td> EDITLINE
 </td><td> /afs/athena.mit.edu/contrib/sipb/src/editline
 </td><td> src/sal/appl/editline
 </td><td>  See  <a href="#EDITLINE_license_terms_and_conditions">Section 11.1:  EDITLINE License terms and conditions
</a> </td></tr><tr><td> ED Editor
 </td><td> USENET comp.sources.misc Volume 9, Issue 36
 </td><td> src/appl/diag/edline.c
 </td><td>  See  <a href="#ED_editor_license_terms_and_conditions">Section 11.2:  ED Editor License terms and conditions
</a> </td></tr><tr><td> CINT
 </td><td> http://www.gnu.org/software/bison/
 </td><td> src/appl/cint/<tt>cint_parser</tt>.[ch]
 </td><td>  See  <a href="#CINT_license_terms_and_conditions">Section 11.3:  CINT parser license terms and conditions
</a> </td></tr><tr><td> CES Driver
 </td><td> BATM Advanced Communications Ltd
 </td><td> src/soc/ces/<tt>nemo_driver</tt>/*.[ch], src/soc/ces/clsbuilder/*.[ch]
 </td><td>  See  <a href="#CES_Driver_license_terms_and_conditions">Section 11.4:  Circuit Emulation Service (CES) Driver terms and conditions
</a> </td></tr><tr><td> BIGDIGITS
 </td><td> David Ireland, copyright (c) 2001-11 by D.I. Management Services Pty Limited &lt;www.di-mgt.com.au&gt;
 </td><td> src/soc/dpp/SAND/Utils/<tt>sand_u64</tt>.c
 </td><td>  See  <a href="#BIGDIGITS_license_terms_and_conditions">Section 11.5:  BIGDIGITS license terms and conditions
</a> </td></tr><tr><td> APIMODE
 </td><td> http://www.gnu.org/software/bison/
 </td><td> src/appl/diag/api/<tt>api_grammar</tt>.tab.[ch]
 </td><td>  See  <a href="#APIMODE_license_terms_and_conditions">Section 11.6:  APIMODE parser license terms and conditions
</a> </td></tr><tr><td> VxWorks
 </td><td> Wind River Systems, Inc.
 </td><td> systems/vxworks
 </td><td>  See  <a href="#WRS_license_terms_and_conditions">Section 11.7:  Wind River Systems license terms and conditions
</a> </td></tr></tbody></table><br><hr noshade><a name="EDITLINE_license_terms_and_conditions"></a>
<h3>Section 11.1:   EDITLINE License terms and conditions
</h3>
<blockquote><pre>This package was obtained from the following location, and was modified
for purposes of inclusion into the SOC diagnostics shell.

Removed files:
        MANIFEST Make.os9 Makefile os9.h sysos9.c testit.c unix.h

Added files:
        sysvxworks.c Makefile

Changed functionality:
        Merged unix.h into editline.h
        M-P and M-N now behave like tcsh.
        <tt>list_history</tt>(count) routine displays history
        Commented out completion
        Changed <tt>rl_complete</tt> and <tt>rl_list_possib</tt> into caller-settable
                global functions
        Don't ring bell on TAB if word is already complete

------------------------------------------------------------------------------

Index of /afs/athena.mit.edu/contrib/sipb/src/editline

[     ] Name                   Last modified     Size  Description
  ------------------------------------------------------------------------

 [DIR]  Parent Directory       11-May-99 03:40      -
 [   ]  MANIFEST               07-Jul-97 11:20     1k
 [   ]  Make.os9               07-Jul-97 11:20     1k
 [   ]  Makefile               01-Sep-97 00:34     2k
 [   ]  complete.c             07-Jul-97 11:20     4k
 [   ]  editline.3             07-Jul-97 11:20     5k
 [   ]  editline.c             07-Jul-97 11:20    25k
 [   ]  editline.h             07-Jul-97 11:20     2k
 [   ]  os9.h                  07-Jul-97 11:20     1k
 [   ]  sysos9.c               07-Jul-97 11:20     1k
 [   ]  sysunix.c              07-Jul-97 11:20     3k
 [   ]  testit.c               07-Jul-97 11:20     1k
 [   ]  unix.h                 07-Jul-97 11:20     1k

  ------------------------------------------------------------------------

$Revision: 1.7 $

This is a line-editing library.  It can be linked into almost any
program to provide command-line editing and recall.

It is call-compatible with the FSF readline library, but it is a
fraction of the size (and offers fewer features).  It does not use
standard I/O.  It is distributed under a "C News-like" copyright.

Configuration is done in the Makefile.  Type "make testit" to get
a small slow shell for testing.

This contains some changes since the posting to comp.sources.misc:
    -   Bugfix for completion on absolute pathnames.
    -   Better handling of M-n versus showing raw 8bit chars.
    -   Better signal handling.
    -   Now supports termios/termio/sgttyb ioctl's.
    -   Add M-m command to toggle how 8bit data is displayed.
The following changes, made since the last public release, come from
J.G. Vons &lt;vons@cesar.crbca1.sinet.slb.com&gt;:
    -   History-searching no longer redraws the line wrong
    -   Added ESC-ESC as synonym for ESC-?
    -   SIGQUIT (normally ^\) now sends a signal, not indicating EOF.
    -   Fixed some typo's and unclear wording in the manpage.
    -   Fixed completion when all entries shared a common prefix.
    -   Fixed some meta-char line-redrawing bugs.

Enjoy,
        Rich $alz
        &lt;rsalz@osf.org&gt;

 Copyright 1992,1993 Simmule Turner and Rich Salz.  All rights reserved.

 This software is not subject to any license of the American Telephone
 and Telegraph Company or of the Regents of the University of California.

 Permission is granted to anyone to use this software for any purpose on
 any computer system, and to alter it and redistribute it freely, subject
 to the following restrictions:
 1. The authors are not responsible for the consequences of use of this
    software, no matter how awful, even if they arise from flaws in it.
 2. The origin of this software must not be misrepresented, either by
    explicit claim or by omission.  Since few users ever read sources,
    credits must appear in the documentation.
 3. Altered versions must be plainly marked as such, and must not be
    misrepresented as being the original software.  Since few users
    ever read sources, credits must appear in the documentation.
 4. This notice may not be removed or altered.
</pre></blockquote><p><br><hr noshade><a name="ED_editor_license_terms_and_conditions"></a>
<h3>Section 11.2:   ED Editor License terms and conditions
</h3>
<blockquote><pre>  ed - standard editor
  ^^
	Authors: Brian Beattie, Kees Bot, and others

 Copyright 1987 Brian Beattie Rights Reserved.
 Permission to copy or distribute granted under the following conditions:
 1). No charge may be made other than reasonable charges for reproduction.
 2). This notice must remain intact.
 3). No further restrictions may be added.

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  TurboC mods and cleanup 8/17/88 RAMontante.
  Further information (posting headers, etc.) at end of file.
 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
 Modification log:
 25Aug92  (W.Metzenthen) Changed malloc() call to calloc() in makebitmap()
          to remove bugs under Linux. Changed a few '^' to the correct '~'.
          General tidying. Recognize Linux via the <tt>__linux__</tt> symbol.
          Main change based upon suggestion by Wolfgang Thiel.
 07Sep99  Changed large amounts of stuff to simplify  --Curt McDowell
</pre></blockquote><p><br><hr noshade><a name="CINT_license_terms_and_conditions"></a>
<h3>Section 11.3:   CINT parser license terms and conditions
</h3>
<blockquote><pre>The C code for the CINT parser was generated by using GNU Bison parser
generator from the file <tt>cint_grammar</tt>.y   CINT is an optional diagnostic
tool that can be included in your system  by adding CINT to the
<tt>FEATURE_LIST</tt> in SDK compilation flags.

Removed files:
        None

Added files:
        None

Changed functionality:
        None

------------------------------------------------------------------------------
/* A Bison parser, made by GNU Bison 2.4.1.  */

/* Skeleton implementation for Bison's Yacc-like parsers in C

      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
   Free Software Foundation, Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */

/* As a special exception, you may create a larger work that contains
   part or all of the Bison parser skeleton and distribute that work
   under terms of your choice, so long as that work isn't itself a
   parser generator using the skeleton or a modified version thereof
   as a parser skeleton.  Alternatively, if you modify or redistribute
   the parser skeleton itself, you may (at your option) remove this
   special exception, which will cause the skeleton and the resulting
   Bison output files to be licensed under the GNU General Public
   License without this special exception.

   This special exception was added by the Free Software Foundation in
   version 2.2 of Bison.  */

/* C LALR(1) parser skeleton written by Richard Stallman, by
   simplifying the original so-called "semantic" parser.  */
</pre></blockquote><p><br><hr noshade><a name="CES_Driver_license_terms_and_conditions"></a>
<h3>Section 11.4:   Circuit Emulation Service (CES) Driver terms and conditions
</h3>
<blockquote><pre>The Circuit Emulation Services (CES) driver code provided herewith is provided
by BATM Advanced Communications Ltd (BATM) and is subject to licensing agreement
between BATM and Broadcom Corporation. 
</pre></blockquote><p><br><hr noshade><a name="BIGDIGITS_license_terms_and_conditions"></a>
<h3>Section 11.5:   BIGDIGITS license terms and conditions
</h3>
<blockquote><pre>Contains BIGDIGITS multiple-precision arithmetic code originally
written by David Ireland, copyright (c) 2001-11 by D.I. Management
Services Pty Limited &lt;www.di-mgt.com.au&gt;, and is used with
permission.

David Ireland and DI Management Services Pty Limited make no
representations concerning either the merchantability of this software
or the suitability of this software for any particular purpose. It is
provided "as is" without express or implied warranty of any kind. Our
liability will be limited exclusively to the refund of the money you
paid us for the software, namely nothing. By using the software you
expressly agree to such a waiver. If you do not agree to the terms, do
not use the software.
</pre></blockquote><p><br><hr noshade><a name="APIMODE_license_terms_and_conditions"></a>
<h3>Section 11.6:   APIMODE parser license terms and conditions
</h3>
<blockquote><pre>The C code for the APIMODE parser was generated by using GNU Bison parser
generator from the file <tt>api_grammar</tt>.y   APIMODE is an optional diagnostics
shell interface that can be included in your system  by adding APIMDOE to the
<tt>FEATURE_LIST</tt> in SDK compilation flags.
</pre></blockquote> See  <a href="#CINT_license_terms_and_conditions">Section 11.3:  CINT parser license terms and conditions
</a>  for the Bison licence.
<p><br><hr noshade><a name="WRS_license_terms_and_conditions"></a>
<h3>Section 11.7:   Wind River Systems license terms and conditions
</h3>
<p>See <tt>WRS_LICENSE</tt>.pdf contained in each systems/vxworks subdirectory.
<p><br><br><hr noshade><br><br>
    <a name=section_resolved6.4.0>
    <h3>Section 12:  Resolved Issues for 6.4.0
</h3>
<p>The following issues are resolved in version 6.4.0 of the SDK.
<p><table cellpadding="4" cellspacing="0" border="1" summary="section"><tbody><tr><td><tr><td><b> Number
 </b></td><td><b> CSP #
 </b></td><td><b> Chips
 </b></td><td><b> Release Notes For 6.4.0
</b></td></tr><tr><td> SDK-39298 
 </td><td></td><td> 56640_A0
56640_A1
 </td><td> Added a new feature to control metering in egress mode
</td></tr><tr><td> SDK-39435 
 </td><td> 625583
 </td><td> 56846_A0
56845_B0
56845_A2
56844_A0
56842_A0
56840_A0
56850_A0
56855_A0
56843_B0
56841_A3
56846_A1
56841_B0
56854_B0
56854_A0
56850_A1
 </td><td> Add supports for the dual-lane forced speed mode running with CL72. It requires FW version <tt>A041_003</tt> or above.
</td></tr><tr><td> SDK-41137 
 </td><td> 549821
 </td><td> All
 </td><td> On multicast removal all the ports are iterated to clear the ports associated with the multicast address. This iteration is not required as iteration on the port members of the multicast address will save more cylces of iteration.
   Fixed the Iteration based on the member ports of the multicast group.
</td></tr><tr><td> SDK-41495 
 </td><td> 557384
 </td><td> 56640_B0
 </td><td> Support has been added for Triumph 3 in <tt>bcm_switch_pkt_info_hash_get</tt>() API and incomplete functionality in compute load balancing and compute trunk hash has been corrected.
</td></tr><tr><td> SDK-42899 
 </td><td> 558213
 </td><td> 56640_A0
56850_A0
 </td><td> When the traffic is running, issuing a stats clear can cause the
MMU unicast drop counters to get into a state, where the counts are not updated. The entry has 3 fields  packet count, <tt>byte_count</tt> and parity field and all the fields need to be cleared if parity is not enabled. Fixed the issue.
.
</td></tr><tr><td> SDK-43520 
 </td><td></td><td> 56640_A0
56440_A0
56450_A0
 </td><td> When SDK is initialized along with Firmware, queue configuration is required to indicate the Rx queues mapped to external CPU (Ehost) and microcontrollers (UC0, UC1). If the queue configuration is not present then SDK init fails.
An error message is now displayed indicating if SDK init fails due to to missing queue configuration.
</td></tr><tr><td> SDK-44138 
 </td><td> 717410
 </td><td> 56634_A0
 </td><td> snmpDot1dBasePortMtuExceededDiscards only counts packets dropped on Rx
and does NOT include the count of packets dropped by the pipeline because they 
exceeded the configured max frame size. This counter will be equal to or less than
 the number of packets dropped due to MTU violations
</td></tr><tr><td> SDK-44342 
 </td><td> 601905
 </td><td> 56640_A0
56640_A1
56640_B0
 </td><td> Triumph3 chip supports attaching up to 3 counters for an entry in IFP. Field STAT APIs have been enhanced to support the same in SDK.
</td></tr><tr><td> SDK-45115 
 </td><td></td><td> 88650_B0
 </td><td> BCM shell: Typing "diag pp MODE_info_Set ?" in BCM shell would cause segmentation fault.
</td></tr><tr><td> SDK-46431 
 </td><td></td><td> 56334_B0
 </td><td> In earlier releases IP multicast configuration did not work on Enduro (<tt>BCM56334_B0</tt>). Made code changes to configure L3_IIFf in VLAN_TABm during init to allow this to work correctly.
</td></tr><tr><td> SDK-46565 
 </td><td> 633504
 </td><td> 56334_B0
 </td><td> In PTP/1588 application for Keystone processor there was an issue where setting VLAN priority &lt;&gt;"0" resulted in loss of communication between ToP and Host. In this release the VLAN priority mask has been corrected for Keystone.
</td></tr><tr><td> SDK-46612 
 </td><td> 628861
 </td><td> 56640_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56640_A1
56643_A1
56644_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
 </td><td> Triumph 3 MAC Table Deletion Callbacks were are inconsistent in Polling mode . this has been fixed by the following:
1. The '<tt>l2_entry_data_t</tt>-&gt;enable' was wrongly being set for FIFO mode where L2 data store is not needed, it is unset for FIFO, but set for POLL mode, this is done in '<tt>soc_tr3_l2x_start</tt>'
 2. On a MAC re-learn case, with callback's suppressed, the deleted entry was being wrongly sent to the callback handler (<tt>soc_l2_entry_callback</tt>) from within '<tt>_soc_l2x_sync_bucket</tt>', this is now changed to <tt>NULL</tt>, so that no-DEL callbacks are called in such cases
</td></tr><tr><td> SDK-46734 
 </td><td> 636372
 </td><td> 56448_B0
All
56440_A0
56445_A0
56440_A1
56445_A1
56444_A1
56450_A0
56449_B0
56445_B0
56440_B0
56447_B0
56443_B0
56441_B0
56446_B0
 </td><td> Introduced new flag '<tt>BCM_PORT_MATCH_PORT_VLAN16</tt>' in <tt>bcm_port_match_t</tt> to match mod-port/trunk+16 bit outer VLAN TAG for VLAN translation
</td></tr><tr><td> SDK-47155 
 </td><td> 620527
 </td><td> 56440_A0
 </td><td> In previous release, is, the <tt>egress_tunnel_if</tt> was only returned if the flag <tt>BCM_MPLS_PORT_NETWORK</tt> was set - which was incorrect because it should be set as well if <tt>BCM_MPLS_PORT_EGRESS_TUNNEL</tt> is used. In this release the following has been updated:
<p>retrieving <tt>mpls_port</tt>-&gt;<tt>egress_tunnel_if</tt> no longer depends on <tt>network_port_flag</tt>. 
We now check the <tt>egr_l3_next_hop</tt> entry type, if it is MPLS type, then we now set the <tt>BCM_MPLS_PORT_EGRESS_TUNNEL</tt> flag and retrieve the <tt>egress_tunnel_if</tt>. 
</td></tr><tr><td> SDK-47170 
 </td><td> 641741
 </td><td> 56440_A0
 </td><td> During warmboot the SDK does not distinguish if the replication is on nexthop or L3 interface. This causes a warmboot failure when the replication is on nexthop.
Fixed the warmboot logic to identify if the replication is on nexthop or L3 interface as per the configuration in HW replication table.
</td></tr><tr><td> SDK-47774 
 </td><td></td><td> 88650_A0
 </td><td> In IP routing, the L3VPN-Default-Routing feature was not implemented: <tt>BCM_L3_INGRESS_GLOBAL_ROUTE</tt> had no effect upon calling.
This is fixed: if the L3VPN-Default-Routing attribute is set, the IP routing lookups of the packet are &lt;VRF, DIP&gt; key and &lt;0, DIP&gt; if not found. No RPF check is performed.
</td></tr><tr><td> SDK-47997 
 </td><td> 660499
 </td><td> 88030_A0
 </td><td> The individual tests can now be configured to retain their configuration parameters upon termination of that test. That parameters will then apply to all subsequent tests. The default behavior is to roll back all the configurations. However, if it is desired to make a particular parameter persistent, it should have the line &lt;cleanup&gt; 0 &lt;/cleanup&gt; on it.
</td></tr><tr><td> SDK-48018 
 </td><td> 652215
 </td><td> 56840_A0
 </td><td> In earlier releases, <tt>bcm_cosq_gport_bandwidth_get</tt>() did not work. This has been resolved.
</td></tr><tr><td> SDK-48130 
 </td><td> 663340
 </td><td> 56640_A0
56640_A1
 </td><td> Added code to initialize rtag7 flow based hash related parameters to enable macroflow offset APIs.
</td></tr><tr><td> SDK-48272 
 </td><td> 665127
 </td><td> 56334_B0
56334_A0
 </td><td> In earlier releases <tt>bcm_esw_mirror_port_get</tt>() did not return correct flags. This has been resolved by removing the " if" condition which was preventing the proper update of the flag for the egress mirroring
</td></tr><tr><td> SDK-48433 
 </td><td> 627988
 </td><td> 56224_B0
56224_A0
 </td><td> Removed the check in SDK which prevents the customer from configuring both <tt>BCM_L2_LEARN_LIMIT_ACTION_DROP</tt>
and <tt>BCM_L2_LEARN_LIMIT_ACTION_CPU</tt> at the same time when making calls to
<tt>bcm_l2_learn_limit_set</tt>()
<p>The corresponding actions  are supported in the hardware for RAPTOR/RAVEN/HAWKEYE devices.
</td></tr><tr><td> SDK-48449 
 </td><td></td><td> 56850_A2
 </td><td> The support for one-lane port running CL72 is added for the JIRA. Customers need to put
1) <tt>port_init_cl72</tt>=0x1 in their configuration file, or 2) call API to enable the CL72 mode, then set the port speed.   This JIRA requires FW version <tt>A041_002</tt> or above.
</td></tr><tr><td> SDK-49335 
 </td><td></td><td> 56640_A0
56640_A1
 </td><td> In an earlier release the TR3 shadow tables were not getting initialized correctly in some cases. In this release we are now initializing the arlShadow tables to correct values, applicable for TR3 when no external TCAM is in use.
<p>In '<tt>soc_tr3_l2_attach</tt>', L2_ENTRY_1m, EXT_L2_ENTRY_1m and EXT_L2_ENTRY_2m are initialized to their '<tt>soc_mem_index_count</tt>'s, Previously they were being set 0 earlier.
</td></tr><tr><td> SDK-49347 
 </td><td></td><td> NA
 </td><td> Updated the grog file for <tt>bcm_port_encap_config_t</tt> documentation.
</td></tr><tr><td> SDK-49464 
 </td><td> 681536
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> When the packet is trapped and parsed in the CPU, the Source-System-Port parsing was not considering the LAG case. This is fixed, by setting the <tt>src_trunk</tt> parameter for the LAG Id, and the <tt>src_port</tt> and <tt>src_mod</tt> parameters corresponding to the selected LAG member port.
</td></tr><tr><td> SDK-49473 
 </td><td> 683076
 </td><td> 54680E_A1
54680E_B0
54682E_A1
54682E_B0
54685E_A1
 </td><td> In earlier releases there were Display errors in the EEE command for BCM54685E. This has been fixed.
</td></tr><tr><td> SDK-49649 
 </td><td></td><td> All
 </td><td> In an earlier release, in file src/soc/common/mem.c, <tt>MEM_LOCK</tt>/<tt>MEM_UNLOCK</tt> in functions <tt>_soc_mem_read</tt>() / <tt>_soc_mem_write</tt>() and <tt>soc_mem_alpm_read</tt>() / <tt>soc_mem_alpm_wrte</tt>() was done when doing S-Chan processing, but in functions <tt>soc_mem_generic_insert</tt>() / <tt>soc_mem_g</tt> <tt>eneric_delete</tt>() / <tt>soc_mem_generic_lookup</tt>() and <tt>soc_mem_alpm_lookup</tt>() / <tt>soc_mem_alpm_insert</tt>() / <tt>soc_mem_alpm_delete</tt>(), we were missing this, This protection has been added.
</td></tr><tr><td> SDK-49699 
 </td><td> 677743
 </td><td> 88030_A0
 </td><td> New feature to support multiple cos levels and strict priority queue selection
</td></tr><tr><td> SDK-49700 
 </td><td> 685812
 </td><td> 88030_A0
 </td><td> The API <tt>soc_sbx_caladan3_cop_policer_token_number_get</tt>() is used to read token number of a policer.
</td></tr><tr><td> SDK-49746 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> Enable Bounce back filter for 2-pass trill:
In the second pass going back to trill packets are filtered by bounce-back-filter.
</td></tr><tr><td> SDK-49806 
 </td><td></td><td> 88650_A0
88650_B0
 </td><td> In PON application, in IPv6 Source bind implementation, the code has been changed to be more generic.
</td></tr><tr><td> SDK-49819 
 </td><td></td><td> 88650_A0
 </td><td> Calling <tt>soc_dpp_wb_engine_deinit</tt> on one unit zeroed internal structs that contain information for all units in the system. problem is now FIXED, deinit will zero only structs belong to the specified unit.
</td></tr><tr><td> SDK-49829 
 </td><td> 684594
 </td><td> 56440_B0
 </td><td> Fixed the code to configure the RQE_PORT_CONFIGr in the bcmPortControlCustomerQueuing switchcontrol set for Katana/Katana2
</td></tr><tr><td> SDK-49861 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> When working in MESH mode, VoQ must be mapped to a legal VoQ connector.
Therefore adding\deleting a VOQ when it is under traffic is forbidden (these operations map the VOQ to an invalid VOQ). 
A verification was added in MESH mode, such that when voq is unmapped (a.e. mapped to an invalid connector), an error will be thrown if traffic still arrives to the VoQ.
Note that this fix doesn't provide full protection, and is intended to catch an invalid state where possible. It is the application responsibility to make sure that the VoQ currently being unmapped doesn't receive any traffic.
</td></tr><tr><td> SDK-49932 
 </td><td> 689754
 </td><td> 88650_A0
 </td><td> In L3, in BCM886XX, the IPv6 host table is shared in TCAM with regular IPv6 forwarding table.
However, <tt>bcm_l3_host_add</tt> API was supported for IPv6 but not <tt>bcm_l3_host_remove</tt> and <tt>bcm_l3_host_find</tt>. This is fixed.
</td></tr><tr><td> SDK-50029 
 </td><td> 682932
 </td><td> 56334_B0
56142_A0
56132_A0
 </td><td> In earlier releases, FP qualifiers had a mismatch when there two FP groups on the multi slice. In this release we have modified the code such that we now install the selcodes in the slice if the slice is not empty and this is the first entry for the group in that slice.
</td></tr><tr><td> SDK-50064 
 </td><td> 687256
 </td><td> 56643_B0
 </td><td> MCSPRI was programmed with offset of 1024. The bit length of register MCSPRI is sufficient for absolute index and no offset is required. Fixed in by writing the actual index in the registry with no offset.
</td></tr><tr><td> SDK-50066 
 </td><td></td><td> 88660_A0
 </td><td> In BCM88660, introduce new support for IPMC and IGMP after exiting tunnel (VXLAN, L2GRE, VPLS).
See <tt>cint_igmp_example</tt>.c for application explanation and valid packet flows. 
</td></tr><tr><td> SDK-50087 
 </td><td> 690469
 </td><td> 88030_A0
 </td><td> When immediate values are used for hstore they are checked for:
<ul><li> range (38 -256)
</li><li>  That the index plus the length does not exceed 256</li></ul></td></tr><tr><td> SDK-50121 
 </td><td></td><td> 88650_A0
 </td><td> KBP Serdes init sequence changed to use KBP SDK API. Internal implementation change, no affect on customer application
</td></tr><tr><td> SDK-50142 
 </td><td> 690184
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> A request was received such that the hardware queue number could be retrieved when the system was transmiting packets from the cpu port to a front panel port in bypass mode.
The new API is implemented to support the ability to retrieve hardware queue number in PBSMH header according to the port and cosq.
</td></tr><tr><td> SDK-50144 
 </td><td> 692372
 </td><td> 88750_A0
88650_A0
88750_B0
88650_B0
88650_B1
 </td><td> In eyescan.h SOC function <tt>soc_port_phy_eyescan_res_print</tt> is no longer available for use.
The print function has  been  moved to diagnostics shell, and is called from "phy diag eyescan" command.
</td></tr><tr><td> SDK-50148 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Add BST software Snapshot improvement. This included adding the following capabilities.
A) Enabled bst for all ingress and egress resources.
B) Provided a sw trigger for taking snapshot . 
C) Allow the user to read the statistics without clearing the counters 
D) Added a separate api for clearing each specific resource counter. See API Section of this document. 
E) Added the ability to disable the snapshot mode via the api if needed.
F) Enabled the ability to Disable BST 
G) 'BST "max used mode" and "current counting" mode are supported
</td></tr><tr><td> SDK-50162 
 </td><td> 692128
 </td><td> All
 </td><td> Multiple RX interrupt packet handlers were being called when a packet was handled. This has been resolved.
</td></tr><tr><td> SDK-50212 
 </td><td></td><td> 56850_A2
 </td><td> The code supports for 40G/42G HG FEC are added.
</td></tr><tr><td> SDK-50231 
 </td><td> 691831
 </td><td> 88030_A0
 </td><td> A bug in the prior releases of the MDE manifested itself in the following way:
<p>If a 64 bit register is accessed that would result in a latency violation (e.g. it was the target of a 'hread' instruction but was subsequently accessed before the header load latency) , it crashed the assembler instead of reporting the violation gracefully. This is now resolved.
</td></tr><tr><td> SDK-50288 
 </td><td> 692335
 </td><td> All
 </td><td> In ealier releases, BFD could not be supported in the LAN network because of IP addresses limitation. This has been fixed.
</td></tr><tr><td> SDK-50337 
 </td><td> 692830
 </td><td> 88030_A0
 </td><td> Packets arriving on the 1G ports were being redirected to incorrect queues due to incorrect PR ICC config mismatching.
This has been fixed
</td></tr><tr><td> SDK-50365 
 </td><td> 694983
 </td><td> 88650_A0
88650_B0
 </td><td> Making sure bcm is attached before trying to detach it.
</td></tr><tr><td> SDK-50368 
 </td><td></td><td> 88750_A0
88650_A0
88640_A0
 </td><td> Unused SOC properties (e.g. <tt>policer_fairness_enable</tt>) defined in config-sand.bcm were removed from this file
</td></tr><tr><td> SDK-50377 
 </td><td> 686726
 </td><td> 56150_A0
 </td><td> Add KNET support for switch devices attached via iProc AXI bus.
</td></tr><tr><td> SDK-50437 
 </td><td> 695853
 </td><td> 88030_A0
 </td><td> There was a bug in the previous releases of the MDE that prevented correct parsing of variable length headers only for the first header (any variable length header that came afterwards has been parsing correctly all along; this is how IPv4 headers have been parsed for a long time).
<p>This bug has been fixed in the current release.
</td></tr><tr><td> SDK-50440 
 </td><td> 695544
 </td><td> 88030_A0
 </td><td> A summary CSV sheet is generated showing switch, key and port usage. To use either option:
<p>-suo "file-name"
--<tt>output_summary_csv</tt> "file-name"
</td></tr><tr><td> SDK-50441 
 </td><td> 695303
 </td><td> 88030_A0
 </td><td> The ability to configure the ingress and egress queue parameters on a per queue basis is now supported by the MDE. In other words, it is possible to assign different parameters to each of the 64 ingress and 64 egress queues.
</td></tr><tr><td> SDK-50442 
 </td><td> 695307
 </td><td> 88030_A0
 </td><td> In the earlier releases of the MDE, the PPE property table did not get cleaned of the previous values consistently after a test has been run. This has been fixed.
</td></tr><tr><td> SDK-50477 
 </td><td> 696358
 </td><td> 88030_A0
 </td><td> Previous releases of the MDE had a bug with the following characteristics:
<p>If a masked 64 bit register (e.g of the form rr0[40:20]) was the destination of an 'hload' or 'hread' operation, the values read were put in starting at the lowest bits, i.e. the masking bits were ignored (SDK-50477).
<p>This has been fixed with this release.
</td></tr><tr><td> SDK-50481 
 </td><td> 692651
 </td><td> All
 </td><td> Modified to check fiber channel inner and outer fields with <tt>BCM_FIELD_DATA_FORMAT_FIBRE_CHAN_ANY</tt> instead of 0
</td></tr><tr><td> SDK-50490 
 </td><td> 695720
 </td><td> 88030_A0
 </td><td> Sync attribute has been added to CMU counter config. Valid values are "true" or "false".
</td></tr><tr><td> SDK-50498 
 </td><td> 696599
 </td><td> All
 </td><td> Add KNET support for BCM56150 family of devices.
</td></tr><tr><td> SDK-50519 
 </td><td> 696880
 </td><td> 88030_A0
 </td><td> Previous releases of the MDE had a bug where the TSR did not get updated for instructions in the egress task. This has been fixed.
</td></tr><tr><td> SDK-50530 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> When setting FabricMC using Egress+Ingress MC, the OUTLIF in <tt>IRR_MCDB</tt> must be - '0'
</td></tr><tr><td> SDK-50569 
 </td><td> 697394
 </td><td> 88030_A0
 </td><td> Previous releases of the MDE implicitly limited the length of header fields to 32 bits (MAC fields were broken to 6 byte-length fields). This is now resolved.
</td></tr><tr><td> SDK-50570 
 </td><td> 697442
 </td><td> 88030_A0
 </td><td> Earlier releases of the MDE had a bug that prevented new direct-mapped tables to be added. This has been fixed in this release.
</td></tr><tr><td> SDK-50571 
 </td><td> 697639
 </td><td> 88030_A0
 </td><td> If the ingress/egress queues in the packet header get mangled (e.g. due to a microcode bug) the model now reports this.
</td></tr><tr><td> SDK-50595 
 </td><td></td><td> 88650_A0
88650_B0
 </td><td> ERSPAN ARAD: Outbound Multicast ERSPAN mirroring is not supported in default application. To support multicast ERSPAN outbound mirroring a new soc property introduce "<tt>custom_feature_erspan_mc_support</tt>=1". In case it is set , first 16 entries in ISID-table are used for ERSPAN feature. When custom feature is enabled, User can allocate for MIM, VXLAN, L2GRE only VPNs that pass the constraint (vsi &amp; 0xFFF) &gt; 16. Additionally, VPN must be allocated for those application WITH-ID only.
See more details in <tt>cint_mirror_erspan</tt>.c
</td></tr><tr><td> SDK-50611 
 </td><td> 684857
 </td><td> 88650_A0
 </td><td> In Field Processor in Egress stage, an HW limitation requires that none or both lookup keys are valid in Egress PMF. If a single lookup key is valid, the second lookup key returned result will be invalid once used in the future.
To handle this limitation, the Driver uses the last TCAM DB Profile (ID 47). It allows the user to define only 47 TCAM Databases instead of 48.
To disable this implementation (e.g. if Egress Field Processor is not used), set the SOC property <tt>custom_feature_egress_pmf_lookups_always_valid_disable</tt>=1.
</td></tr><tr><td> SDK-50637 
 </td><td> 689475
 </td><td> All
 </td><td> Added new soc property <tt>eb2_2bytes_big_endian</tt> to support EB2 endianism
</td></tr><tr><td> SDK-50675 
 </td><td></td><td> 88650_B1
 </td><td> 88550 and 88560 are Arad-SKU chips without Interlaken. During the Arad initialization, the 88550 &amp; 88560 SKU were incorrectly considered TDM-only devices - fixed.
</td></tr><tr><td> SDK-50718 
 </td><td> 699557
 </td><td> 88030_A0
 </td><td> Ports are initialized in the following order: 6,13,7,14,12,11,10,2,3,4,5,8,9,0,1
</td></tr><tr><td> SDK-50724 
 </td><td> 699541
 </td><td> 88030_A0
 </td><td> To have two tables share the same memory the user must create two tables of the same width and size using the same ports and with the second table using the base address of the first table. For example:
<p> sample8 {
    	    <tt>table_capacity</tt> =(32 * 100)
<p>                /*#
                "g3p1"."ocm"."Sample LRP OCM Port 8 Table."
                "Sample LRP OCM Port 8 Table.
                   Test table."
                 */
<p>            index {
                    test8i: 7
            }
<p>            entry {
                    <tt>ocm_port</tt>(<tt>LRP_PORT_8</tt>, width=32) {
                            pad:1
                            test8:31:0
                    }
            }
    }
<p>    sample9 {
    	    <tt>table_capacity</tt> =(32 * 100)
                /*#
                "g3p1"."ocm"."Sample LRP OCM Port 9 Table."
                "Sample LRP OCM Port 9 Table.
                   Test table."
                 */
<p>            index {
                    test9i: 7
            }
<p>            entry {
	    	  <tt>ocm_port</tt>(<tt>LRP_PORT_8</tt>, width=32, <tt>mem_base</tt>=sample8::base) {
                            pad:1
                            test9:31:0
                    }
            }
    }
</td></tr><tr><td> SDK-50748 
 </td><td> 699893
 </td><td> 88030_A0
 </td><td> DM table results will be ordered correctly in the results registers.
</td></tr><tr><td> SDK-50753 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Add new diag "diag <tt>ing_congestion</tt>" to display ingress global resource.
</td></tr><tr><td> SDK-50756 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Added new diagnostics to display voq/vsq programmable counters:
diag counter voq/vsq Queue=x (Interval=y)
diag counter voq Basequeue=x (Interval=y)
</td></tr><tr><td> SDK-50757 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Added diagnostics "diag rates sch" to display E2E scheduler rate.
</td></tr><tr><td> SDK-50758 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Added diagnostics "Gtimer" to control gtimer in sub-block for rate calculation.
Added interval option for "diag counter". 
</td></tr><tr><td> SDK-50759 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Added new diag "diag cosq voq id=&lt;id&gt; detail=1" to print given VOQ's attributes.
</td></tr><tr><td> SDK-50779 
 </td><td> 696166
 </td><td> 88650_A0
 </td><td> New APIs were added to dynamically enable/disable counter collection by counter processor engines:
<tt>bcm_switch_service_get</tt>
<tt>bcm_switch_service_set</tt>
for more details about these APIs see Arad PP user manual (886X0-PG3XX)
</td></tr><tr><td> SDK-50812 
 </td><td> 700562
 </td><td> 88030_A0
 </td><td> The MDE now supports configuring the PPE variable in a similar manner as the property table entry. The configuration can be global or per-test. For example, to configure some fields in the ingress variable, enter the following within the ppe configuration (inside the scope of &lt;ppe-m&gt;... &lt;/ppe-m&gt;:
     &lt;<tt>ing_ppevar</tt>&gt;
      	&lt;field-m&gt; &lt;name&gt;<tt>mim_transit</tt>&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/field-m&gt;
      	&lt;field-m&gt; &lt;name&gt;<tt>lsp_gal</tt>&lt;/name&gt;     &lt;value&gt;1&lt;/value&gt; &lt;/field-m&gt;
      	&lt;field-m&gt; &lt;name&gt;vrrp&lt;/name&gt;        &lt;value&gt;1&lt;/value&gt; &lt;/field-m&gt;
      &lt;/<tt>ing_ppevar</tt>&gt;
</td></tr><tr><td> SDK-50823 
 </td><td> 699173
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> At egress, the user can define a packet to be trapped and sent to the CPU.
By default, the trap profile (action profile) was sending the packet to the Egress Queue Pair with ID = CPU Port number instead of sending to the CPU. This is fixed
</td></tr><tr><td> SDK-50828 
 </td><td> 686923
 </td><td> 88650_B1
 </td><td> STG: <tt>bcm_stg_vlan_add</tt>() and <tt>bcm_stg_stp_set</tt>() do not return
    <tt>BCM_E_NOT_FOUND</tt> when passed in a spanning tree group that does not exist. Update verification on those functions.
</td></tr><tr><td> SDK-50836 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Add new diag(tdm edit show [port=15]) to display tdm edit information.
</td></tr><tr><td> SDK-50849 
 </td><td></td><td> 88750_A0
88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> 1. MBIST (internal memories BIST) is fixed to work on 88660.
MBIST can be enabled at startup using the <tt>bist_enable</tt> soc property.
<p>2. Starting with the 6.3.2 release, enabling of the mbist output is done using:
dbm socdnx +mem +VERbose +err -cnt
Instead of the previous:
dbm soc +mem +VERbose +nor +err
<p>Using the reporting line above, all the memory debugging information previously available (for 88650 and for 88750) is displayed as before.
</td></tr><tr><td> SDK-50859 
 </td><td> 697873
 </td><td> 56850_A0
 </td><td> It was discovered that 15 profiles could be created for the mapping from internal priority to MPLS Exp at the egress but 16 profiles could not be created successfully when repeating the profiles creation although the system allowed the user to attempt this . It is fixed in this release and max 15 profiles can be created.
</td></tr><tr><td> SDK-50894 
 </td><td> 701166
 </td><td> 88030_A0
 </td><td> Release 144 of the MDE had an issue that the PPE header checker and LAG template must be specified, even if the application does not need it. Omitting these two optional parameters crashed the MDE. This has been fixed.
</td></tr><tr><td> SDK-50963 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> When using User-Header (e.g. in cascaded Ingress-Egress ACL or in VMAC), the user-header should be removed before the packet exits the system.
This was not the case for OTMH program and Mac-in-Mac. This has been corrected.
</td></tr><tr><td> SDK-50972 
 </td><td> 701844
 </td><td> 88650_A0
88650ACP_A0
88650_B0
88650_B1
 </td><td> Table <tt>EGQ_FQP_NIF_PORT_MUX</tt> need to be tuned to avoid packet drops. Optimized internal table arrangement to prevent underrun and insure the desired ports rate.
The fix is applied only on driver initialization.
</td></tr><tr><td> SDK-50982 
 </td><td> 703790
 </td><td> 56850_A0
 </td><td> Add BCM shell CLI support and <tt>HG_TRUNK</tt> mode for packet hash select API.
</td></tr><tr><td> SDK-51019 
 </td><td> 687800
 </td><td> 56850_A1
 </td><td> Implemented in the new policer mode bcmPolicerGroupModeShortIntPri for creation of 8 internal policers.
</td></tr><tr><td> SDK-51035 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> VLAN assignment according to port,protocol: VLAN assignment procedure is according to profile. Increased the number of port protocol entries per profile from 10 to 16
</td></tr><tr><td> SDK-51048 
 </td><td> 700857
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> <tt>PFM_RULE_APPLY</tt> field in <tt>IGMP_MLD_PKT_CONTROL</tt> register cannot be controlled in previous release. Added support for controlling this bit by pkt protocol control approach.
</td></tr><tr><td> SDK-51065 
 </td><td> 705285
 </td><td> All
56643_A0
56643_A1
56643_B0
 </td><td> Updated to make <tt>triumph_3</tt> devices boot in 64 port single modid mode by default and if config variable spn_MODULE_64PORTS = 0 then boot in dual modid mode
</td></tr><tr><td> SDK-51093 
 </td><td> 705776
 </td><td> 88030_A0
 </td><td> The condition (header access latency) was considered cleared after one cycle (i.e. next instruction) rather than two cycles.
</td></tr><tr><td> SDK-51127 
 </td><td> 702045
 </td><td> 56640_A0
56643_A0
56640_A1
56643_A1
56640_B0
56643_B0
 </td><td> An issue was reported where external FP failed to qualify IPv6/TCP-IP packets with given L4SrcPort and L4DstPort. Corrected the offset of the qualifiers L4SrcPort, L4DstPort for external FP during qualifiers init.
</td></tr><tr><td> SDK-51154 
 </td><td> 701733
 </td><td> 56640_A0
56440_A0
56643_A0
56644_A0
56648_A0
56850_A0
56445_A0
56440_A1
56445_A1
56444_A1
56340_A0
56640_A1
56643_A1
56644_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
56449_B0
56445_B0
56440_B0
56447_B0
56850_A1
56443_B0
56441_B0
56446_B0
56448_B0
56850_A2
56342_A0
56442_B0
 </td><td> Added bcmFieldActionETagNew [Add/Change ETAG] &amp; bcmFieldActionETagDelete [Delete ETAG] in IFP to support Port Extenders Etag add/delete/change options.
</td></tr><tr><td> SDK-51170 
 </td><td></td><td> 88660_A0
 </td><td> OAM: Support RDI generation method.
Generation method is configured through the <tt>bcm_oam_endpoint_create</tt> api with the following flags2:
<tt>BCM_OAM_ENDPOINT2_RDI_FROM_RX_DISABLE</tt> /* RDI bit on outgoing packets may be taken from RDI indication on received packets. */ 
<tt>BCM_OAM_ENDPOINT2_RDI_FROM_LOC_DISABLE</tt> /* RDI bit on outgoing packets may be taken from LOC indication of peer endpoint. */ 
</td></tr><tr><td> SDK-51184 
 </td><td> 705114
 </td><td> 88030_A0
 </td><td> The LUG is out of date with respect to the COP load latency, the correct value is 40.
</td></tr><tr><td> SDK-51230 
 </td><td> 708240
 </td><td> All
 </td><td> Support has been added for new API to retrieve member port for DLB HG Trunk
</td></tr><tr><td> SDK-51340 
 </td><td> 709181
 </td><td> 88650_B1
 </td><td> Upon FEC creation (<tt>bcm_l3_egress_create</tt>) Correct the verification of LAG ID to allow also group IDs that are higher than 32.
</td></tr><tr><td> SDK-51348 
 </td><td></td><td> 88650_A0
 </td><td> To end a tdm session using you have two options:
1.Set destination port to an invalid destination - <tt>BCM_GPORT_BLACK_HOLE</tt>.
2.Call <tt>bcm_port_control_set</tt> () with type bcmPortControlRxEnable.
Be advised, for tdm ports, when disabling a port rx, the valid range cell size min filter must be of 192B or above, and this configuration affects all of the other tdm sessions.
</td></tr><tr><td> SDK-51351 
 </td><td> 709776
 </td><td> 88030_A0
 </td><td> I can see the code the load latency is changed from 37 to 40
</td></tr><tr><td> SDK-51368 
 </td><td> 707551
 </td><td> 56830_A1
56830_A0
56830_A2
 </td><td> BCM56830 is considered as a switch instead of a fabric and attached with proper drivers. SDK implementation has been corrected based on this determination
</td></tr><tr><td> SDK-51405 
 </td><td></td><td> 56640_A0
56640_A1
56640_B0
 </td><td> L2 entries learnt on the trunk ports were not being deleted on ring flush. The trunk ports are now matched with the Trunk port module ID (0x80) and the entry is deleted on ring flush in addition to the line ports.
</td></tr><tr><td> SDK-51451 
 </td><td></td><td> 56846_A0
56845_B0
56845_A2
56844_A0
56842_A0
56840_A0
56850_A0
56843_B0
56841_A3
56846_A1
56841_B0
56850_A1
56850_A2
 </td><td> Support for <tt>BCM_L2_STATION_COPY_TO_CPU</tt> configuration in l2 station entry for TD/TD2/TT2 has been added.
</td></tr><tr><td> SDK-51498 
 </td><td> 696152
 </td><td> 88130_B0
 </td><td> QE2000 to Sirius traffic issue was resolved with a fix to <tt>bcm_fabric_crossbar_connection_set</tt>() to set up both A and B plane connections to support plane crossover.
</td></tr><tr><td> SDK-51506 
 </td><td></td><td> 56640_A0
56548_A0
56546_A0
56545_A0
56544_A0
56542_A0
56541_A0
56540_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56640_A1
56643_A1
56644_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
56545_A1
56540_B0
56541_B0
56546_B0
56544_B0
56547_A0
56545_B0
56542_B0
 </td><td> Fixed issue in handling flushing MAC entries by Virtual Port's correctly.
On Triumph3, the <tt>key_type</tt> was not being set correctly for Flush-by-VP calls. The <tt>key_type</tt> for MPLS, MiM, L2GRE, VXLAN VFI types needs to be set to VFI type
</td></tr><tr><td> SDK-51521 
 </td><td></td><td> 88650_B1
 </td><td> Diagnostics: "diag pp Parsing_Info" sometimes output incorrect <tt>inner_vid</tt> value due to wrong initialization.
</td></tr><tr><td> SDK-51528 
 </td><td> 711580
 </td><td> All
 </td><td> Fixed the issue with packet drop counter when the packet is dropped by policer.
</td></tr><tr><td> SDK-51541 SDK-50704
 </td><td></td><td> 88650_A0
 </td><td> In order to detect and fix ECC2 and parity errors, one can use the BCM switch control bcmSwitchCacheTableUpdateAll. The procedure will go over all cached memories, read them from HW, and in case it detects an error, a matching interrupt will be initiated to be corrected by the appropriate corrective action. When caching memories, it is recommended to update all cached memories before initiating a WB/ISSU cycle. The cached memories are read from the HW during WB/ISSU. Updating all cached memories ensures that all potential errors are handled using the available shadow data.
</td></tr><tr><td> SDK-51553 
 </td><td> 710528
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Corrected the VLAN_PROFILEm configuration flow in qos module.
</td></tr><tr><td> SDK-51568 
 </td><td> 705719
 </td><td> 56850_A0
56850_A1
56830_A1
56850_A2
56830_A0
56830_A2
 </td><td> In earlier releases <tt>BCM56850_SVK</tt> would automatically reboot within 1 minute if "<tt>table_dma_enable</tt>=0" is set in config.bcm or in SVK flash. This has been fixed by modifying memory scan with dma-disabled.
</td></tr><tr><td> SDK-51597 
 </td><td> 704238
 </td><td> 56224_B0
56224_A0
 </td><td> Made code changes to allow '-1' as valid port parameter in <tt>bcm_vlan_translate_add</tt>() for 56224 devices.'-1' is valid for 56224 as given in the Programmer's reference guide which indicates configuration on all the ports. The function <tt>bcm_esw_vlan_translate_add</tt>() should now able to configure for '-1' as well for 56224 devices.
</td></tr><tr><td> SDK-51599 
 </td><td> 712774
 </td><td> All
 </td><td> In earlier releases SDK cli "mc show" did not display all OIFs for a multicast groupfixed to support any number of OIFs. This has been fixed to support any number of OIFs.
</td></tr><tr><td> SDK-51643 
 </td><td></td><td> 56340_A0
 </td><td> Fixed and tested on GTO/BCM56340A. BCM init and rc failures aren't happening anymore.
</td></tr><tr><td> SDK-51645 
 </td><td> 713523
 </td><td> 56850_A0
 </td><td> Renamed conflicting #define <tt>MAX_NAME_LEN</tt> to <tt>SOC_MAX_NAME_LEN</tt>
</td></tr><tr><td> SDK-51652 
 </td><td> 703012
 </td><td> 88650_A0
88650_B0
88660_A0
 </td><td> L3 Egress object optimization: When connecting between MPLS/IP tunnel to link-layer (<tt>bcm_l3_egress_create</tt>), API always set Link-layer information even in case no Link-layer information has been modified. Use combination of flags <tt>BCM_L3_KEEP_DSTMAC</tt>, <tt>BCM_L3_KEEP_VLAN</tt> and <tt>BCM_L3_REPLACE</tt> and valid <tt>encap_id</tt> to modify only connection between MPLS/IP tunnel to link-layer. No link-layer modifications are done.
</td></tr><tr><td> SDK-51665 
 </td><td> 713519
 </td><td> All
 </td><td> Add vlan control vlan selective set/get API to control UMC_IDXf/BC_IDXf/UUC_IDXf in Vlan Table
</td></tr><tr><td> SDK-51677 
 </td><td> 695953
 </td><td> 88650_B0
88650_B1
 </td><td> When egress packets are dropped at the EGQ, i.e. EGQ-delete-queue is receiving traffic, it'll take priority over the NIF ports, and might cause packet drop.
After the fix delete queue will get priority over NIF only if it is almost full.
</td></tr><tr><td> SDK-51689 
 </td><td> 713650
 </td><td> 88650_B1
 </td><td> In BCM8865X, a bug at egress HW was mishandling packets that being terminated to size of 192-255 Bytes.
In BCM88660, this HW bug was fixed. Enabling this bugfix during the Driver init is inserted.
</td></tr><tr><td> SDK-51811 
 </td><td> 713635
 </td><td> 56640_A0
56850_A0
56640_A1
56640_B0
56850_A1
56850_A2
 </td><td> Support for symmetric hash for Resilient Hashing has been added for TD2/TR3.
</td></tr><tr><td> SDK-51814 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> When configuring VRRP for ARAD+, up to 4k VSIs can be assigned to each VRID.
There was an error that made it impossible to delete a VRID if exactly 4k (4096) VSIs entries were assigned to it.
The error is now fixed.
</td></tr><tr><td> SDK-51821 
 </td><td> 716070
 </td><td> 88030_A0
 </td><td> Added check for invalid combination (Simple64 &amp; Automatic mode):
<p>Error!   [87509] null-&gt;0:0-&gt;0.1 = Counters group ertctr: Simple64 counters don't support automatic mode.
</td></tr><tr><td> SDK-51823 
 </td><td> 716406
 </td><td> 88030_A0
 </td><td> ppe config error carse variable length of packet header not work. modify ppe associate structure define to fix this issue.
</td></tr><tr><td> SDK-51824 
 </td><td> 716986
 </td><td> All
 </td><td> Added a new command 'ser inject' which may be used to inject single-bit parity errors into memories while having a minimal effect on system state.
</td></tr><tr><td> SDK-51827 
 </td><td> 716807
 </td><td> 88030_A0
 </td><td> Resolves ucode reload issue seen in 2_146 and TOT.
</td></tr><tr><td> SDK-51857 
 </td><td> 715638
 </td><td> All
56440_A0
56440_A1
56440_B0
 </td><td> An error with <tt>_bcm_esw_stat_flex_destroy_ingress_table_counterswas</tt> reported. Fixed bug in <tt>stat_group_create</tt> which was intializing '256' counters.
</td></tr><tr><td> SDK-51881 
 </td><td> 702602
 </td><td> 56640_B0
56850_A2
 </td><td> Vlan Service queuing bugs addressed. 1. <tt>gport_attach</tt>/detach to take care of internally attaching the given number of Queues during add. 2. Queue alignment of Vlan queuing changed to 1(no alignment required).
</td></tr><tr><td> SDK-51900 
 </td><td></td><td> 56640_B0
 </td><td> In earlier releases, priority to queue mapping was limited to 15 entries.The table supports 16 entries per profile. There was an error in validating the number of entries parameter which was corrected
</td></tr><tr><td> SDK-51902 
 </td><td> 705911
 </td><td> 56440_A0
56440_B0
 </td><td> Corrected issue with BFD event thread not exiting by increasing the timeout to 5 seconds.
</td></tr><tr><td> SDK-51920 
 </td><td></td><td> 88660_A0
 </td><td> OAM/BFD events: Support the DMA reroute writes intended to the Interrupt Message Register to a local host memory.
<p>To support this functionality the following soc properties should be configured: 
1) <tt>oamp_fifo_dma_enable</tt> - enables fifo dma mode. Default is 0. 
2) <tt>oamp_fifo_dma_buffer_size</tt> - length of the messages buffer we store in the CPU. 
3) <tt>oamp_fifo_dma_timout</tt> - the time for generating an interrupt when the fifo is not full. Value 0 indicates interrupt is sent only when fifo is full. Default is 0 
4) <tt>oamp_fifo_dma_threshold</tt> - the number of events written until interrupt is generated.
</td></tr><tr><td> SDK-51925 
 </td><td> 702621
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> Trill allows now multiple flooding-groups with the same nickname.
This can be used to create flooding with the same nickname for different VSIs.
Procedures which used both nickname and ID as the key (like <tt>trill_port_get</tt>) will work only with id.
See an example of configuration in <tt>cint_trill</tt>: <tt>trill_with_two_vlan_flooding</tt>.
</td></tr><tr><td> SDK-51933 
 </td><td></td><td> 88660_A0
 </td><td> In stacking systems, BCM88660 is able to pass 16 bits of Load-Balancing key and to reproduce the hashing decision in the second system. Thus, any limitation or performance decrease in hashing trunk is removed when using this option.
<p>In the data path, the first LB-Key byte is copied in the FTMH.LB-Key-Extension, whereas the second byte is copied in the second User-Header. At egress editor block of the first system, the second User-Header is copied to the start of packet to be extracted by the Ingress PMF in the second system.
<p>This option can be enabled by setting the following SOC properties:
1. <tt>system_ftmh_load_balancing_ext_mode</tt>=<tt>FULL_HASH</tt>
2. <tt>first_header_size_</tt>&lt;all stacking ports&gt;=1
3. <tt>field_class_id_size_1</tt>=8
</td></tr><tr><td> SDK-51934 
 </td><td></td><td> 88650_A0
 </td><td> In Field Processor, the Direct table is one of possible Databases (bcmFieldGroupModeDirect). Its key is very short (10 bits maximum) and corresponds to the index line of the TCAM Action table.
The support of the Warmboot was faulty in the Driver: the entry content was not retrieved correctly. This is fixed.
</td></tr><tr><td> SDK-51939 
 </td><td> 717396
 </td><td> All
56850_A0
56850_A1
56850_A2
 </td><td> Modify <tt>bcm_port_queued_count_get</tt>() to support in Trident2
</td></tr><tr><td> SDK-51961 
 </td><td> 712277
 </td><td> 88650_B0
 </td><td> MIM: DEFAULT BEHAVIOR CHANGE .
<tt>bcm_l2_station_get</tt>() API failed in some cases when VSI for MyMac was considered to be B-MyMac. 
This happened when the MIM indication bit in the created <tt>station_id</tt> was wrongfully set due to an overlap in the <tt>station_id</tt> encoding.
This is fixed by changing the encoding of the <tt>station_id</tt> so that there is no overlap with the MIM indication bit. The MIM indication bit in <tt>station_id</tt> changed from bit 7 to bit 29.
</td></tr><tr><td> SDK-51984 
 </td><td> 711243
 </td><td> 56640_A0
56641_A0
56642_A0
56643_A0
56644_A0
56645_A0
56648_A0
56640_A1
56643_A1
56644_A1
56640_B0
56644_B0
56643_B0
56648_B0
56649_B0
56649_A0
 </td><td> In earlier releases, an issue was reported in <tt>soc_tr_parity_process_mmu_qcn</tt>(). Corrected the bit number values for detecting the memory type.
</td></tr><tr><td> SDK-51993 
 </td><td></td><td> 88660_A0
 </td><td> Trill: Introduce Multi-homing connectivity to the trill network allow a host to have access to trill campus using more than one RBridges. The host treats a group of edge RBridges as an Uplink link bundle that works in an active-active load sharing model.
Arad+ support up to 3 virtual RBridges in system. 
<p>See <tt>cint_trill_multi_homing</tt>.c for more description and packet-flows
</td></tr><tr><td> SDK-51994 
 </td><td> 707370
 </td><td> 88650_B1
 </td><td> IP tunnel termination lookup key is defined by SOC property: <tt>bcm886xx_ip4_tunnel_termination_mode</tt>.
Added 2 new lookup key for IPV4 tunnel termination: 
<tt>bcm886xx_ip4_tunnel_termination_mode</tt> = 4 - Key is : {DIP, SIP, IPV4.Next-protocol}
<tt>bcm886xx_ip4_tunnel_termination_mode</tt> = 5 - Keys are : {DIP, SIP, IPV4.Next-protocol}, {DIP}
Lookup IPV4 next protocol is useful to configure multiple separate VPNs, with same DIP and SIP, but 
with different tunnel-types. See an example of use in: <tt>cint_ip_tunnel_term</tt>.c
</td></tr><tr><td> SDK-52013 
 </td><td></td><td> 56440_A0
56243_B0
56240_B0
56242_B0
 </td><td> 1.Corrected configuration of shared pool sizes for Saber.
2.Only ports 25 tot 28 of MXQPorts use PG7. SDK was setting it for ports 25 to 34. This is corrected now.
3.Corrected configuration of <tt>RQE_WQE</tt>, CFAPI, CFAPE and QENTRY free address pools based on how devide is OTPd. This will prevent ECC errors when using Saber(BCM56240).
</td></tr><tr><td> SDK-52033 
 </td><td></td><td> 56150_A0
 </td><td> Fixed DXGS mode of HG ports may not be consistently programmed.
</td></tr><tr><td> SDK-52081 
 </td><td></td><td> 56850_A2
 </td><td> The JIRA fixes the temperature reading bug in the TSC driver. Also it provides the chip version information in DSC dump.
</td></tr><tr><td> SDK-52098 
 </td><td></td><td> 56850_A0
 </td><td> Renamed <tt>BCM_FCOE_VSAN_NORMALIZED_CHECK</tt> to <tt>BCM_FCOE_VSAN_NORMALIZED_ZONE_CHECK</tt>
</td></tr><tr><td> SDK-52110 
 </td><td> 720063
 </td><td> 88030_A0
 </td><td> Support the encoding and decoding of ITMH, NPH and OAM headers in cint.
</td></tr><tr><td> SDK-52139 
 </td><td> 679766
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> In earlier releases Port Extender Controlling Bridge not working consistently in a stacked configuration. This has been resolved.
On the egress chip, we must program the <tt>SOURCE_VP</tt> table entry with <tt>TPID_SOURCE</tt>=2, i.e. use TPIDs based on SGLP. The default is 0 - use SVP-based TPIDs from this table.
<p>   mod <tt>source_vp</tt> 1 1 <tt>TPID_SOURCE</tt>=2
<p>Once we do this, the stacking setup for port extender works.
</td></tr><tr><td> SDK-52148 
 </td><td> 718595
 </td><td> 56846_A0
56845_B0
56845_A2
56844_A0
56842_A0
56840_A0
56850_A0
56855_A0
56843_B0
56841_A3
56846_A1
56841_B0
56854_B0
56854_A0
56850_A1
56851P_A1
56851_A1
56850_A2
56851_A2
56851P_A2
56854_A2
56853_A2
56852_A2
56855_A2
56851_A0
56852_A0
56852_A1
56853_A0
56853_A1
 </td><td> Problem:
<tt>bcm_field_action_add</tt>() API in SDK uses only one part of a <tt>FP_POLICY_TABLE</tt> entry to program the Field  actions applied to an entry.
bcmFieldActionCosQCpuNew and bcmFieldActionServicePoolIdNew are conflicting actions for SINGLE WIDE entry.
For DOUBLE WIDE entry both actions can be applied to an Entry by programming them independently in the two parts of <tt>FP_POLICY_TABLE</tt> belonging to a double wide entry. 
But software does not support this behavior and <tt>bcm_field_action_add</tt>() API must be enhanced to support the same.
<p>Solution: 
Enhanced <tt>bcm_field_action_add</tt>() API to program bcmFieldActionCosQCpuNew and bcmFieldActionServicePoolIdNew Field
Actions in different parts of an Entry belonging to a Multi Wide Group as hardware support this feature. For an entry belonging
To Single Wide mode group, API will return <tt>BCM_E_CONFIG</tt> error as these two actions are conflicting and must be programmed in the same hardware field in <tt>FP_POLICY_TABLE</tt>.
</td></tr><tr><td> SDK-52166 
 </td><td> 715996
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> In External TCAM, when used with forwarding tables, each entry content (data and mask) is saved internally in a hash table to get the KBP Driver Entry-ID.
This hash table had an incorrect key-size (only according to data), thus 2 entries with same data but different masks were considered as being identical. This is fixed.
</td></tr><tr><td> SDK-52168 
 </td><td></td><td> 88750_A0
 </td><td> Minor change to FE1600 isolation sequence, no effect on functionality or customer application.
</td></tr><tr><td> SDK-52169 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> PON: bcmVlanPortIgnoreInnerPktTag can be used only for PON-Ports. NNI/CPU/Recycle ports do not support that vlan control value.
</td></tr><tr><td> SDK-52189 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> The ISSU version handling is fixed. Otherwise, 6.3.4 would not be ISSU-able from 6.3.3.
</td></tr><tr><td> SDK-52216 
 </td><td> 711504
 </td><td> 56846_A0
56845_B0
56845_A2
56844_A0
56842_A0
56840_A0
56820_A0
56820_B0
56800_A0
56746_A0
56745_A0
56744_A0
56743_A0
56740_A0
56725_A0
56720_A0
56700_A0
56689_B0
56685_B0
56685_A0
 </td><td> A request was made to add the ability to override "protocol" field in SKB before pushing packet into network stack. the following fields were added in the packet filter structure to support this request. :
<p>int <tt>dest_proto</tt>; /* If non-zero this value overrides the 
                                           default protocol type when matching 
                                           packet is passed to network stack. */
 int <tt>mirror_proto</tt>; /* If non-zero this value overrides the 
                                           default protocol type when matching 
                                           packet is passed to network stack. */  add corresponding fields in packet filter structure to configure the desired protocol type.
</td></tr><tr><td> SDK-52234 
 </td><td> 720648
 </td><td> All
56850_A0
56850_A1
56850_A2
 </td><td> In earlier releases <tt>L3_IIF_PROFILE</tt> table profile sharing was not working correctly. In this release we have.added logic to find a matched entry in <tt>l3_iif_profile</tt> table during update of a entry.
</td></tr><tr><td> SDK-52241 
 </td><td></td><td> 56850_A0
56850_A2
 </td><td> This fix modifies driver code to support HG20G non-scramble mode with DFE off. The scramble mode requires the DFE to be on.
</td></tr><tr><td> SDK-52247 
 </td><td> 721059
 </td><td> 56643_A0
56644_A0
56643_A1
56644_A1
 </td><td> Added fix to update the field group selector (IFP) during warm boot if vpn qualifier is part of the qset.
</td></tr><tr><td> SDK-52253 
 </td><td> 716433
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> [ALPM] Some of the ipv4 streams were not hitting an LPM route. If there is a more specific match (in case of a bucket miss) for a destination IP, in some cases the more specific match could miss and hit the global default. This change fixes that issue.
</td></tr><tr><td> SDK-52264 
 </td><td> 721288
 </td><td> 56850_A0
 </td><td> Counter XAUI activity feature support for TD2 has been removed. <tt>_soc_xgs3_update_link_activity</tt> will not be called for TD2.
</td></tr><tr><td> SDK-52355 
 </td><td></td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Support has been added for retry in mem insert and delete for hash tables. Inline hash memory recovery was implemented for insert and delete operations.When an insert/delete operation encounters a parity error, the inline recovery routine will be invoked. The inline recovery routine will calculate different hash buckets in different hash memory banks based on the entry that will be inserted/deleted, then restore the each bucket in these banks.
For new-added hash key types in Trident2 hash tables, support for these key types in hash entry comparing routine has also been added.   
</td></tr><tr><td> SDK-52358 
 </td><td> 722565
 </td><td> 56850_A0
 </td><td> Support to get rtag7 hash value in port based HiGig proxy mode has been added.
</td></tr><tr><td> SDK-52361 
 </td><td> 722981
 </td><td> 56850_A2
 </td><td> Added L3 lock in ser correction call to avoid deadlock in mem op and dpc ser correction thread.
Moved definition of L3 lock from BCM to SOC layer.
</td></tr><tr><td> SDK-52362 
 </td><td> 723016
 </td><td> 88650_A0
 </td><td> PON: Creation of VLAN-Port with port parameter as VOQ-PON resulted in the API failure in the case where the PON PortnProfile that associate to the VLAN-Port is not profile 0.
The sequence to support it
1.create VOQ per destination system-port (PON-port 0-7)
2.<tt>bcm_vlan_port_create</tt> with port being flow-VOQ gport. API will retrieve the correct PortnProfile and update the learn-information of PON-LIF to be VOQ
</td></tr><tr><td> SDK-52368 
 </td><td> 721631
 </td><td> 88650_A0
 </td><td> <tt>cint_vlan_control_config</tt>.c CINT example missing documentation specifying that <tt>dflt_frwrd</tt> variable must be set to 1 in ARAD/ARAD+.
VSI flooding group must be set the same for all unknown-uc/unknown-mc/broadcast fields. 
In order to set various default forwarding modes, e.g unknown unicast, unknown multicast and broadcast, use: bcmPortControlFloodUnknownUcastGroup, bcmPortControlFloodUnknownMcastGroup, bcmPortControlFloodBroadcastGroup
</td></tr><tr><td> SDK-52381 
 </td><td> 717920
 </td><td> 56850_A0
 </td><td> In earlier releases, L3 Conflict Get, <tt>bcm_td2_l3_conflict_get</tt>() was broken. This has been resolved.
</td></tr><tr><td> SDK-52397 
 </td><td> 722792
 </td><td> 88030_A0
 </td><td> Fixed bcm88030 A1 port status LED issue
</td></tr><tr><td> SDK-52405 
 </td><td> 723353
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> RX-LOS application - added support interlaken ports
</td></tr><tr><td> SDK-52407 
 </td><td> 723478
 </td><td> 56850_A0
 </td><td> Added support for Concatenate mode in calculating ECMP, LAG and HGT rtag7 hash index.
</td></tr><tr><td> SDK-52416 
 </td><td></td><td> 88660_A0
 </td><td> ARAD+ fails to init OAM after WB when adding lm or dm object.
</td></tr><tr><td> SDK-52419 
 </td><td></td><td> All
 </td><td> Added a check to prevent statistics increment if replace and ID flags are set
</td></tr><tr><td> SDK-52434 SDK-47421
 </td><td> 723350
 </td><td> 56640_A0
56640_A1
56640_B0
 </td><td> Fixed packet alignment issue on higig port. When a higig port is connected to external phy and if user configures 42K speed on it, then <tt>xlgmii_align</tt> bit should be set with 1. This fix sets the <tt>xlgmii_align</tt> bit when higig port is configured in 42000 speed.
</td></tr><tr><td> SDK-52443 
 </td><td> 705504
 </td><td> 88650_A0
 </td><td> Case Summary: Traffic drops at ingress on a newly added LAG member, if it is the first member on the ARAD device after cross connection created.
To avoid the problem, API support was added. Using the following function flags <tt>bcm_trunk_member_add</tt>\<tt>bcm_trunk_member_delete</tt> and <tt>bcm_trunk_set</tt> the user can update only egress or ingress tables.
The user can update only egress tables, configure relevant port parameter and then update ingress port, with this sequence there will be no traffic drop.
</td></tr><tr><td> SDK-52448 
 </td><td> 723913
 </td><td> 56450_A0
 </td><td> HQOS support is added for UNI ports on Katana2
</td></tr><tr><td> SDK-52453 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> In Field Processor, external TCAM configuration was not restored during warmboot.
Preliminary support is added to restore external TCAM configuration during warmboot. Warmboot is not supported for External TCAM yet.
</td></tr><tr><td> SDK-52469 
 </td><td> 701853
 </td><td> All
 </td><td> <tt>BCM_FIELD_DATA_QUALIFIER_OFFSET_NEGATIVE</tt> is not valid on xgs ,hence returning <tt>BCM_E_UNAVAIL</tt> when qualifier is set
</td></tr><tr><td> SDK-52471 
 </td><td> 723924
 </td><td> 88030_A0
 </td><td> Order issue addressed in template generated code.
</td></tr><tr><td> SDK-52474 
 </td><td></td><td> 56850_A1
56850_A2
56850_A0
 </td><td> Added doc changes for bcmFieldActionETagNew [Add/Change ETAG] &amp; bcmFieldActionETagDelete [Delete ETAG] in IFP to support Port Extenders Etag add/delete/change options.
</td></tr><tr><td> SDK-52490 
 </td><td> 724657
 </td><td> 56640_A0
56440_A0
56440_B0
 </td><td> In earlier releases it was not possible to send a one-step 1588 packet via PCIE. In this release support has been added to specify the timestamp offset during CPU packet tx.
</td></tr><tr><td> SDK-52496 
 </td><td> 723483
 </td><td> 84756_A0
84756_C0
 </td><td> An issue was reported where hot swap on 8x10G card failed. A fix was required in the <tt>phy84756_fcmap</tt>.c driver : Added pluggable PHY support
</td></tr><tr><td> SDK-52512 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> MPLS VPN creation <tt>bcm_mpls_vpn_id_create</tt> is now valid for both VPN ranges 0-4K and 4K-32K.
</td></tr><tr><td> SDK-52513 
 </td><td></td><td> 88650_A0
 </td><td> VLAN-Port: SW-DB forwarding information of VLAN-Port might not update correctly because of uninitialized parameters caused <tt>bcm_vswitch_port_add</tt> to fail on random cases.
</td></tr><tr><td> SDK-52514 
 </td><td> 725210
 </td><td> 88030_A0
 </td><td> Release 149 had a bug where the MDE crashed if a hash template was not configured for the ingress queue. This has been addressed in this release.
</td></tr><tr><td> SDK-52518 
 </td><td> 705177
 </td><td> 88650_B1
 </td><td> STG Warmboot: Warmboot stored STP state per port up to STG-ID 12 and so didn't recover for all other groups. Updated Warmboot STG allocation size to correct size.
</td></tr><tr><td> SDK-52519 
 </td><td></td><td> 88750_B0
 </td><td> Snake test with external loopback failed when running it over <tt>BCM88750_B0</tt>. Fixed.
</td></tr><tr><td> SDK-52521 
 </td><td> 724174
 </td><td> 56850_A0
 </td><td> In the previous release, in function <tt>_soc_td2_alloc_sched</tt>(), HQOS hierarchy was being assumed. If users did not use the same hierarchy as defined in <tt>_td2_port_lls_config</tt>(), issues would be seen. In this release, a LLS port doesn't clear other ports' hardware resource when <tt>bcm_cosq_gport_add</tt>() is called on Trident2 chips.
</td></tr><tr><td> SDK-52526 
 </td><td> 719683
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> VLAN: A VLAN-Port object can be created per port by calling the API <tt>bcm_vlan_port_create</tt>() with a <tt>MATCH_PORT</tt> criteria and can be identified by
a <tt>vlan_port_id</tt> value. The object may be destroyed using <tt>bcm_vlan_port_destroy</tt>() by suppling the <tt>vlan_port_id</tt>. Destroying the object frees the
<tt>vlan_port_id</tt> that can be used for some other VLAN-Port object creation when the <tt>WITH_ID</tt> flag is used and the <tt>vlan_port_id</tt> is supplied.
<p>A problem occurs when performing a create and destroy sequence for 3 times with the same <tt>vlan_port_id</tt>. The third creation fails as some
resources weren't freed correctly during the destroy of objects with <tt>MATCH_PORT</tt> criteria.
<p>The resource freeing during destroy, was fixed for the <tt>MATCH_PORT</tt> criteria objects as well.
<p>The issue detailed above affects the unicast RPF mode per RIF feature (the SOC property <tt>bcm886xx_l3_ingress_urpf_enable</tt>=1).
When this feature is used by specifying a uRPF mode other than <tt>BCM_SWITCH_URPF_DISABLE</tt> in <tt>bcm_l3_ingress_t</tt>.<tt>urpf_mode</tt> for <tt>bcm_l3_ingress_create</tt>, 
deleting LIFs which are members of RIFs that use uRPF with the <tt>MATCH_PORT</tt> criteria will result in undefined behavior.
</td></tr><tr><td> SDK-52529 
 </td><td></td><td> 88660_A0
 </td><td> Support oam accelerated loopback.
See an example of use in : <tt>cint_oam_arad_plus</tt>.c
</td></tr><tr><td> SDK-52575 
 </td><td> 725460
 </td><td> 53343_A0
56150_A0
 </td><td> Correct supported number of multicast replication interface of BCM56150.
</td></tr><tr><td> SDK-52583 
 </td><td> 710089
 </td><td> 56450_A0
 </td><td> CLI command "oam endpoint show" fixed to exhibit correct endpoint information for BCM56450
</td></tr><tr><td> SDK-52584 
 </td><td> 725729
 </td><td> 56450_A0
 </td><td> In the previous release SP and WRR did not work correctly on extended queues. The reason was that the MMU thresholds were not configured for extended queues. Added queue configuration assuming internal-lossless settings
</td></tr><tr><td> SDK-52588 
 </td><td> 725824
 </td><td> 56450_A0
 </td><td> Fixed to handle -1 as numq for scheduler gport.
</td></tr><tr><td> SDK-52592 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> MPLS VPNs can be created using <tt>bcm_petra_mpls_vpn_id_create</tt>().
In DNX Arch only VPLS mode requires valid VPN ID. VPWS does not require to go by VPN (Cross-connect only).
The VPWS VPN creation isn't supported but the API succeed to allocate a VPN that in fact is created with VPLS encoding.
For the 6.3 branch, the ability to enter VPWS VPN is valid only for ID 0
For 6.4, the VPWS flag is no longer supported, as it is not required in MPLS VPWS sequence. See <tt>cint_vswitch_cross_connect_p2p</tt>.c for more information on VPWS connection.
</td></tr><tr><td> SDK-52600 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> A LIF can be created with no Ingress AC-Key matching by calling <tt>bcm_vlan_port_create</tt>() with a criteria field set to <tt>BCM_VLAN_PORT_MATCH_NONE</tt>. Later, the LIF values may be
edited by calling the same BCM API with the additional <tt>BCM_VLAN_PORT_REPLACE</tt> flag.
The modification of LIFs (using <tt>BCM_VLAN_PORT_REPLACE</tt>) that were originally created with criteria <tt>BCM_VLAN_PORT_MATCH_NONE</tt>, was failed.
</td></tr><tr><td> SDK-52618 
 </td><td> 724270
 </td><td> 88030_A0
 </td><td> SDk-52618 RCE Errors (ECC etc) - was test packet
</td></tr><tr><td> SDK-52622 
 </td><td></td><td> 56850_A1
 </td><td> An issue was reported with the performance of the L2 match replace function.
1. Resolved RPC issue for the new API array arguments by fixing the papi.
2. Updated internal API implementation using bitmaps instead of multiple iterations to improve the performance.
</td></tr><tr><td> SDK-52628 
 </td><td></td><td> 88660_A0
 </td><td> CGE1 traffic fall in NBI in case of 2Caui +Elk was fixed
</td></tr><tr><td> SDK-52629 
 </td><td></td><td> 88660_A0
 </td><td> Fixed: PRBS APIs support 2 CAUI + ELK
</td></tr><tr><td> SDK-52630 
 </td><td> 726283
 </td><td> 56450_A0
 </td><td> Changed the delete sequence for L0 and L1 Nodes
First delete the subtree node first and then delete the parent node
</td></tr><tr><td> SDK-52633 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> In 6.3.3, a version compiled without the WARMBOOT compilation flags was failing at initialization due to minor code missing in switch init.
This is fixed.
</td></tr><tr><td> SDK-52637 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> In Policer, a single 2-rate color blind meter with the default configuration (32 range mode, SERIAL) would not do rate limitation.
This behavior is now corrected.
</td></tr><tr><td> SDK-52639 
 </td><td> 710412
 </td><td> 88650_A0
88650_B0
88660_A0
 </td><td> In Egress L2, an HW field (CustomLearn) was set by mistake - it is a debug-only not-validated field intended to allow more packets to be learnt.
</td></tr><tr><td> SDK-52643 
 </td><td> 723104
 </td><td> 88650_B1
 </td><td> In 1588 application, an ITMH packet can be injected with an OAM-TS header above to indicate the header offset for the timestamp.
Due to HW implementation, the usage of User-Header requires the following action from the user:
- if a SOC property field_class_id_size_X is set, then an injected packet of type Ethernet over OAM-TS over ITHM over PTCH-2 requires:
1. to insert the User-Header to be inserted between Ethernet and OAM-TS
2. the Opaque-Attribute.LSB in PTCH-2 (bit 12) must be set
3. the ITMH destination is of type System-Port
</td></tr><tr><td> SDK-52667 
 </td><td> 724073
 </td><td> 88750_A0
88650_A0
88650_B0
88650_B1
 </td><td> Fixed a misconfiguration when setting FE1600 to work in repeater mode, that could cause occasional drops.
</td></tr><tr><td> SDK-52668 
 </td><td> 725913
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Fixed issue where hash-move when moving an invalid entry may break wider conflict entry.
</td></tr><tr><td> SDK-52673 
 </td><td> 726396
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> an issue was reported where Buffers were getting stuck on control queue of egress port when port was shut in the presence of fragmentation. This has been resolved as described below:
<p>When port is disabled or link down, remove related bitmap from below three registers. Thus traffic will not be enqueued to these ports any more.
<p><tt>THDU_OUTPUT_PORT_RX_ENABLE0_64</tt> 
<tt>MMU_THDM_DB_PORTSP_RX_ENABLE0_64</tt> 
<tt>MMU_THDM_MCQE_PORTSP_RX_ENABLE0_64</tt>
</td></tr><tr><td> SDK-52678 
 </td><td></td><td> 88750_A0
88650_A0
88650_B0
88650_B1
 </td><td> In a multi-stage system, live removal of an FE1600 or ARAD device could result in occasional drops. Fixed.
</td></tr><tr><td> SDK-52691 
 </td><td> 726146
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> VLAN-Port Advanced VLAN translation:
Packet discard can be set either per physical port or per LIF.
In standard VLAN edit mode, the API <tt>bcm_port_discard_set</tt>() is used to set the discard state
both for physical ports and for Out-LIFs.
In Advanced VLAN edit mode, the API <tt>bcm_port_tpid_class_set</tt>() is used to set the physical
discard state, while Out-LIF discard is also blocked in <tt>bcm_port_discard_set</tt>().
The API <tt>bcm_port_discard_set</tt>() is now available for setting Out-LIF discard state in AVT mode as well.
The same way, <tt>bcm_port_discard_get</tt>() now retrieves an Out-LIF discard state in AVT mode.
</td></tr><tr><td> SDK-52699 
 </td><td> 725215
 </td><td> 88650_B1
 </td><td> Fabric source routed cell receive did not support multiple SR cells in parallel. Fixed.
</td></tr><tr><td> SDK-52722 
 </td><td></td><td> 88650_A0
 </td><td> <tt>bcm_l3_ingress_create</tt> now returns an error if the flag <tt>BCM_L3_INGRESS_WITH_ID</tt> is not enabled (instead of just ignore)
</td></tr><tr><td> SDK-52731 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> Fixed corrective action in case of parity error interrupt in WDF table
</td></tr><tr><td> SDK-52733 
 </td><td></td><td> 56850_A0
56855_A0
56854_B0
56854_A0
 </td><td> In earlier releases ROUTE updates were decreasing bcmSwitchObjectEcmpCurrent count in error. This has been addressed.
</td></tr><tr><td> SDK-52741 
 </td><td> 720579
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Fast flush enables clearing MACT entries for LIFs that are associated with a ring protection group FEC using <tt>bcm_l2_replace</tt>() using
the <tt>BCM_L2_REPLACE_PROTECTION_RING</tt> flag. A LIF association to a group is done by calling <tt>bcm_port_class_set</tt>() with the class set to
bcmPortClassL2Lookup.
A LIF association of a remote LIF to ring protection group performs LIF HW configuration instead of only SW DB configuration, resulting
potential problems when remote LIFs are used.
The API <tt>bcm_port_class_set</tt>() has changed so that it configures the LIF HW only for local LIFs.
Ring Protection CINTs and tests where updated to support a multidevice setup. See <tt>cint_l2_fast_flush</tt>.c
</td></tr><tr><td> SDK-52742 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Support TDM (OTN/CBR) traffic for mixed systems. Specially for mixed systems with ARAD and PetraB, when using VCS256 fabric cells, the packets are split to smaller cells by fabric devices (FE1600) during their transport, and are reassembled at the receiving FAP. The reassemble is done based on an attribute called "source-FAP-ID".
This source FAP-ID is calculated as the FAP-ID of the source FAP plus a configurable offset. This source-FAP-ID value must be unique in the TM domain, and different from all FAP-IDs in the TM domain. The offset is specified by a new soc property called <tt>tdm_source_fap_id_offset</tt> . If it is not specified by the soc property, its default value is 256. 
</td></tr><tr><td> SDK-52758 
 </td><td> 727046
 </td><td> 88030_A0
 </td><td> BCM88030: fixed bug where MPLS label was over-writing the IP address RCE key field.
</td></tr><tr><td> SDK-52762 
 </td><td> 728229
 </td><td> 56450_A0
 </td><td> CoE/LinkPHY subports are not added to default VLAN 1.
Customer application needs to manage the VLAN 1 membership for CoE/LinkPHY subports. 
The subport should be added to the VLAN 1 after creating the scheduler tree for the subport. 
</td></tr><tr><td> SDK-52763 
 </td><td> 719360
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Fixed mirroring and snooping settings that did not work in certain cases.
</td></tr><tr><td> SDK-52766 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> When a CAUI port is disabled and then enabled (no traffic is running), the MIB counters show incorrect values. The issue was fixed.
</td></tr><tr><td> SDK-52767 
 </td><td></td><td> 88750_A0
88650_A0
88750_B0
88650_B0
88650_B1
88660_A0
 </td><td> "show features" diagnostics was added.
</td></tr><tr><td> SDK-52771 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> RSPAN: does not work when port control bcmPortControlErspanEnable is set to 1
</td></tr><tr><td> SDK-52772 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> OAM snooped packets are corrupted - snooped packet arrives to the CPU with trap headers.
</td></tr><tr><td> SDK-52774 
 </td><td> 728360
 </td><td> 56850_A0
 </td><td> In earlier releases, deleting and adding back source to mtp dest in TX direction returned -14. This has been addressed by clearing the egress mirroring MTP index of port unless the MTP slot is released.
</td></tr><tr><td> SDK-52782 
 </td><td> 728467
 </td><td> 56850_A0
 </td><td> In this release, we can use <tt>DISABLE_TUNNEL_IP4_GRE_IP6</tt> <tt>DISABLE_TUNNEL_IP4_GRE_IP4</tt> to set <tt>DISABLE_HASH_INNER_IPV4_OVER_GRE_IPV6_A</tt>/B ,<tt>DISABLE_HASH_INNER_IPV4_OVER_GRE_IPV4_A</tt>/B individually, or still use the old flag <tt>BCM_HASH_FIELD0_DISABLE_TUNNEL_IP4_GRE</tt> to set both fields in RTAG7_HASH_CONTROLr as legacy.
IPv6 flags are same to IPv4.
</td></tr><tr><td> SDK-52788 
 </td><td> 728597
 </td><td> All
 </td><td> Solved <tt>FIELD_ENTRY_MISMATCH</tt> problem in bcm_field_qualify_IpType_get by implementing new device specific functions to get iptype encoding using <tt>hw_data</tt> and <tt>hw_mask</tt>.
</td></tr><tr><td> SDK-52795 
 </td><td> 728851
 </td><td> 56447_B0
 </td><td> MMU threshold settings for extended queues has been updated for Katana (BCM5644x)
</td></tr><tr><td> SDK-52796 
 </td><td> 728261
 </td><td> 56450_A0
 </td><td> In previous releases ICAP packet resolution L3MCKnown did not work. In this release we have fixed IFP packet resolution for BCM56450
</td></tr><tr><td> SDK-52806 
 </td><td> 728092
 </td><td> 56648_A0
 </td><td> On change of priority for the VLAN, A small delay was introduced as new priority mapping happens after deletion of old index. On live traffic, this transitional delay caused some packets to be on priority 0 queue as the mapping is under transition. Fixed in the transitional delay for smooth traffic flow on priority transition.
</td></tr><tr><td> SDK-52821 
 </td><td></td><td> 56850_A0
 </td><td> Updated documentation for the following new API;s added.
<tt>bcm_cosq_stat_sync_get</tt>,
<tt>bcm_cosq_stat_sync_get32</tt>
</td></tr><tr><td> SDK-52823 
 </td><td></td><td> 56850_A0
 </td><td> New API's added for <tt>cosq_stat</tt> retrieval have been added.
<tt>bcm_cosq_stat_sync_get</tt>
<tt>bcm_cosq_stat_sync_get32</tt>.
<p>Similar to   <tt>bcm_cosq_stat_get</tt>(), value returned is software accumulated 
counter synced with the hardware counter.
</td></tr><tr><td> SDK-52830 
 </td><td></td><td> 88030_A0
 </td><td> Fixed taps unified mode ucode lookup issue with certain config on bcm88030
</td></tr><tr><td> SDK-52831 
 </td><td></td><td> 88030_A0
 </td><td> Fixed taps capacity resource leak update rate and host memory leak issue found in last patch on bcm88030
</td></tr><tr><td> SDK-52833 SDK-52190
 </td><td></td><td> 56850_A2
 </td><td> This JIRA fixes the problem that TSCMOD doesn't have a clean restart for CL72, such that it may cause incorrect training results. The probablity of the training problem is about 1% of link restart.
</td></tr><tr><td> SDK-52836 
 </td><td> 728502
 </td><td> All
 </td><td> Fixed Assert While installing VFP entries with flex counters attached
</td></tr><tr><td> SDK-52844 
 </td><td> 728330
 </td><td> 56450_A0
 </td><td> Code fixed to update the reference count properly (next hop entry used by mpls port)
</td></tr><tr><td> SDK-52857 
 </td><td> 695985
 </td><td> All
 </td><td> Updated grog for Inports to reflect the correct behavior
</td></tr><tr><td> SDK-52859 
 </td><td> 707972
 </td><td> 54680_A0
54682E_A1
 </td><td> Enhancing documentation/description for the config property <tt>phy_port_primary_and_offset_</tt>&lt;port&gt;
</td></tr><tr><td> SDK-52860 
 </td><td> 728139
 </td><td> 88650_B1
 </td><td> In some scenarios, dependent on the allocated ports and typically involving CAUI ports, an underrun may occur resulting in not reaching full port capacity. Fixed.
</td></tr><tr><td> SDK-52873 
 </td><td> 729725
 </td><td> 56450_A0
 </td><td> Fixed the following issues for BCM56450
1. programming of <tt>FP_DOUBLE_WIDE_SELECT</tt>.<tt>slice_x_f1</tt>.
2. proper initialization of <tt>IFP_SINGLE_WIDE_F1_5</tt>.
</td></tr><tr><td> SDK-52895 
 </td><td> 729741
 </td><td> All
 </td><td> RPC has been enabled for the HASH bank APIs.
</td></tr><tr><td> SDK-52918 
 </td><td> 729962
 </td><td> 56840_A0
 </td><td> Added support for handling remote fault link status.
</td></tr><tr><td> SDK-52923 
 </td><td></td><td> 88660_A0
 </td><td> OAM: New support in updating loss and delay objects was added.
New object is created using <tt>bcm_oam_loss</tt>/<tt>delay_add</tt>(). The update is performed using the same api with the flag <tt>BCM_OAM_LOSS</tt>/<tt>DELAY_UPDATE</tt> flag set.
</td></tr><tr><td> SDK-52924 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> MPLS: A VSI can be associated as an MPLS VPN by calling <tt>bcm_mpls_vpn_id_create</tt>(). The VPN ID should be supplied as well as a <tt>BCM_MPLS_VPN_WITH_ID</tt> flag.
Changing VPN fields is possible after creation, using the additional <tt>BCM_MPLS_VPN_REPLACE</tt> flag. The same VSI may also be used for vswitch, MIM, etc.
The handling of the <tt>BCM_MPLS_VPN_WITH_ID</tt> &amp; <tt>BCM_MPLS_VPN_REPLACE</tt> flags wasn't correct. Performing a create, with the replace flag <tt>BCM_MPLS_VPN_REPLACE</tt>, 
failed for an allocated VPN ID instead of succeeding. The same way, for an unallocated VPN ID, the API succeeded instead of failing.
The behavior of the <tt>BCM_MPLS_VPN_WITH_ID</tt> &amp; <tt>BCM_MPLS_VPN_REPLACE</tt> flags in <tt>bcm_mpls_vpn_id_create</tt>() was fixed.
</td></tr><tr><td> SDK-52925 
 </td><td></td><td> 88660_A0
 </td><td> arad+ : minimum number of links warning message will be displayed only when current number of links &lt; minimum number of links configured
</td></tr><tr><td> SDK-52930 
 </td><td> 728932
 </td><td> 56850_A0
56855_A0
56854_B0
56854_A0
56850_A1
56851P_A1
56851_A1
56850_A2
56851_A2
56851P_A2
56854_A2
56853_A2
56852_A2
56855_A2
56851_A0
56852_A0
56852_A1
56853_A0
56853_A1
 </td><td> In the previous release it was found that if you set bcmPortControlMmuDrain control to an admin-down port (disabled port), then after the port is re-enabling, the traffic to that port will be blocked. This issue was fixed by restoring the value of <tt>XLMAC_CTRL</tt> after draining cell.
</td></tr><tr><td> SDK-52943 
 </td><td> 730095
 </td><td> 56840_A0
 </td><td> New option "nocache" added to dump command, to display h/w table contents skipping cache.
</td></tr><tr><td> SDK-52951 
 </td><td></td><td> 88650_A0
 </td><td> Enabling of slow rate 2 corrected:
Previously, calling: <tt>bcm_cosq_control_set</tt> with control: bcmCosqControlFlowSlowRate and arg=1 would have set slowRate2.
If the same API was called  with the same control and arg=2 an error would occur.
Both were corrected so now calling with arg=0 disables <tt>slow_rate</tt>, calling with arg=1 enables <tt>slow_rate1</tt> and calling with arg=2 enables <tt>slow_rate2</tt> 
</td></tr><tr><td> SDK-52952 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> OAM-BFD co-existence: <tt>bcm_bfd_init</tt> resets some of the oam registers (in <tt>bcm_oam_init</tt>). Thus no oam endpoints can be added before calling <tt>bfd_init</tt>.
</td></tr><tr><td> SDK-52954 
 </td><td> 723963
 </td><td> 88650_A0
 </td><td> For better latency performance, especially when working with high volume traffic, ilkn ports can be configured to have dedicated TDM queues at the egress. This feature is enabled by setting the soc property: <tt>ilkn_tdm_dedicated_queuing</tt>=1.
</td></tr><tr><td> SDK-52970 
 </td><td> 730058
 </td><td> All
 </td><td> L2 <tt>matched_traverse</tt> used a loop to test availability of MOD FIFO, and if MOD FIFO became hung, the loop became endless and eventually caused MOD FIFO thread to become dead. Added a timeout to break out of the loop if MOD FIFO hangs.
</td></tr><tr><td> SDK-52971 
 </td><td></td><td> 88660_A0
 </td><td> ARAD plus device supports either BFDoPWE or BFDCCoMPLSTP encapsulations. This should be defined by the user with a soc property.
<tt>bfd_encapsulation_mode</tt> soc property is setting bfd pwe (mode 0) or bfd cc mplstp mode (mode 1). 0 by default. See example of use in <tt>cint_bfd</tt>.c.
</td></tr><tr><td> SDK-52990 
 </td><td> 730016
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Advanced VLAN translation: Upon Configuration of an advanced VLAN edit action entry using <tt>bcm_vlan_translate_action_id_set</tt>(), the TPID values
that will be used are mandatory fields. At the Ingress side, those TPIDs are matched with an existing
TPID profile value that is passed to the Egress. The API is failed if no such TPID profile matching is found.
The TPID profile consists of up to two global TPIDs.
The TPID profile matching consists of two stages:
1. Exact match - The supplied TPIDs are similar to those of the TPID profile and are similarly positioned (Outer/Inner).
2. Opposite match - The supplied TPIDs are similar to those of the TPID profile but are inversely positioned (Outer/Inner).
<p>The problem occurs when supplying two similar TPIDs: Only a TPID profile that consists of two instances of this TPID will be matched.
If no such TPID profile exists, the command will be failed.
<p>A third matching lookup was added to address the cases where two similar TPIDs are supplied. This lookup requires that this TPID
will be included only once in a TPID profile, in any position, in order to match the TPID profile.
</td></tr><tr><td> SDK-53007 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> <tt>bcm_oam_opcode_map_set</tt>/get is now functional
</td></tr><tr><td> SDK-53011 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> <tt>bcm_port_learn_set</tt> now supports enable/disable SA when destination is Flow-ID
</td></tr><tr><td> SDK-53012 
 </td><td> 715940
 </td><td> 88030_A0
 </td><td> Fixed the wrong action type for mirror &amp; drop in egress RCE action table.
</td></tr><tr><td> SDK-53019 
 </td><td></td><td> 88660_A0
 </td><td> OAM: Add support for <tt>bcm_oam_loss_get</tt>, <tt>bcm_oam_delay_get</tt>, <tt>bcm_oam_loopback_get</tt> apis.
</td></tr><tr><td> SDK-53021 
 </td><td> 720668
 </td><td> 56850_A0
 </td><td> Updated the documentation related to <tt>BCM_PORT_CONGESTION_CONFIG_DESTMOD_FLOW_CONTROL</tt>
</td></tr><tr><td> SDK-53045 
 </td><td> 730837
 </td><td> 56540_B0
 </td><td> Added new redirect soc APIs for autoneg and loopback configurations to get accessed for phy specific GPORTs. Implemented this into existing APIs <tt>bcm_port_autoneg_set</tt>/get() <tt>bcm_port_loopback_set</tt>/get() APIs.
</td></tr><tr><td> SDK-53056 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> PON: Recycle and mirror ports must be allocated from port 128 and above. Other ports (0-127) are used for PON side.
</td></tr><tr><td> SDK-53070 
 </td><td> 688151
 </td><td> 56850_A2
 </td><td> Two command options are added for the eye margin functional calls. The syntax example is
phy diag xe0 veye lane=0xc <tt>time_upper_bound</tt>=16
<p>The "lane" option specifies which lane in a given port is enabled for the eye measurement.  If the lane is not specified, the default is 0 which means all the lanes are enabled for the eye measurement in a given port.   0xC means lane 2 and lane 3 of the port is enabled.  Each binary bit of the value represents a lane.
<p>The "<tt>time_upper_bound</tt>" is to specify the total max time limit for a given eye measurement node.  Its unit is second.   The default is 256 seconds.  Note that this option only accepts the value equal to or larger than 4 seconds.
</td></tr><tr><td> SDK-53077 
 </td><td> 731557
 </td><td> 88030_A0
 </td><td> For IPv4, we now could use <tt>max_capacity_limit</tt>/240 to estimate the number of tcam entries need to be used.
For IPv6, use <tt>max_capacity_limit</tt>/168 to estimate it.
</td></tr><tr><td> SDK-53082 
 </td><td> 730548
 </td><td> All
 </td><td> Prevent potential data corruption after KNET kernel driver call to <tt>skb_padto</tt>.
</td></tr><tr><td> SDK-53099 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> Trill RPF-Check: In SDK 6.3.3 RPF check was moved to LEM + PMF. See <tt>cint_trill</tt>.c for more information. In SDK 6.3.4, 6.4.0 removed unused code <tt>bcm_trill_multicast_source_add</tt>/<tt>bcm_trill_multicast_source_delete</tt>/<tt>bcm_trill_multicast_source_get</tt> for ARAD.
</td></tr><tr><td> SDK-53108 
 </td><td></td><td> 88650_A0
 </td><td> Different ports can now be set with pfc/llfc (could not be set differently before).
Also - disabling one port fc will not stop fc in a device level - Fixed
</td></tr><tr><td> SDK-53112 
 </td><td> 677748
 </td><td> 88030_A0
 </td><td> As of the current release of the MDE, the TMU MAC table subkeys can be split into three (as opposed to two: VSI and MAC) fields ONLY for testing on the model as follows:
<p>An optional 1-bit field, called 'bmac' can be specified as part of the MAC subkey. This means that the MAC subkey can be optionally split into three fields (1 bit BMAC, 15 bit VSI and 48 bit MAC address) This is meant to used in simulating a PBB (Mac-in-Mac) header where the bmac field can be 1 to specify that the MAC address in the subkey is a bridging MAC or 0 to specify that it is a customer (inner) MAC. Since this field is optional, the default value is 0 which covers both the cases of a non-PBB header as well as the inner MAC of a PBB header.
<p>The UcTst.xml file that is provided with this release has placeholder examples of this new usage.
</td></tr><tr><td> SDK-53115 
 </td><td> 731716
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> For TCAM memories protected by SER engine, corrupt bitmaps have been added to track SER errors detected on them. SER correction logic will filter duplicated SER errors via this corrupt bitmap.
</td></tr><tr><td> SDK-53127 
 </td><td> 730044
 </td><td> 56334_B0
56334_A0
 </td><td> In an earlier release switching double tagged frames between layer 2 logical ports on Enduro was inconsistent with TR3/TR2 behavior. This has been correction by synchronizing the behavior of double tagged frames switching on Enduro with TR2's behavior.
</td></tr><tr><td> SDK-53129 
 </td><td> 731105
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> Fixed link interrupt miss issue in 1G mode
</td></tr><tr><td> SDK-53149 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> Fixed wrong check pon port when setting and getting bcmVlanPortIgnoreInnerPktTag for pon port.
</td></tr><tr><td> SDK-53183 
 </td><td> 728584
 </td><td> All
 </td><td> API <tt>bcm_cosq_gport_connection_get</tt> returned error for ISQ ports.
The API is now valid also for ISQ ports.
</td></tr><tr><td> SDK-53192 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> L3 APIs replace:
1.Support to replace vrf, mac addr, ttl, mtu and dscp qos map id by <tt>bcm_l3_intf_create</tt> with <tt>BCM_L3_REPLACE</tt> flag.
2.Support to replace l3 intf, next hop mac, port tgid and encap id by <tt>bcm_l3_host_add</tt> with <tt>BCM_L3_REPLACE</tt> flag.
3.Support to replace l3 intf and port tgid by <tt>bcm_l3_route_add</tt> with <tt>BCM_L3_REPLACE</tt> flag.
</td></tr><tr><td> SDK-53194 
 </td><td></td><td> 88650_A0
88650_B0
 </td><td> Support the replace for <tt>bcm_mim_vpn_create</tt> and <tt>bcm_trill_vpn_create</tt>.
</td></tr><tr><td> SDK-53195 SDK-53298
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> 1.Support to replace mc-group and L3 route interface by <tt>bcm_ipmc_add</tt> with <tt>BCM_IPMC_REPLACE</tt> flags.
2.Support to replace unknown unicast mc-group, unknown multicast mc-group  and broadcast mc-group  by <tt>bcm_l2gre_vpn_create</tt> with <tt>BCM_L2GRE_VPN_REPLACE</tt>,<tt>BCM_L2GRE_VPN_UNKNOWN_UCAST_REPLACE</tt>, <tt>BCM_L2GRE_VPN_UNKNOWN_MCAST_REPLACE</tt>, <tt>BCM_L2GRE_VPN_BCAST_REPLACE</tt> flags
3.Support to replace match port and flag with/without <tt>BCM_L2GRE_PORT_NETWORK</tt> by <tt>bcm_l2gre_port_add</tt> with <tt>BCM_L2GRE_PORT_REPLACE</tt> flag.
4.Support to replace unknown unicast mc-group, unknown multicast mc-group  and broadcast mc-group by <tt>bcm_vxlan_vpn_create</tt> with <tt>BCM_VXLAN_VPN_REPLACE</tt>,<tt>BCM_VXLAN_VPN_UNKNOWN_UCAST_REPLACE</tt>, <tt>BCM_VXLAN_VPN_UNKNOWN_MCAST_REPLACE</tt>, <tt>BCM_VXLAN_VPN_BCAST_REPLACE</tt> flags.
5.support to replace match port and flag  with/without <tt>BCM_VXLAN_PORT_NETWORK</tt> by <tt>bcm_vxlan_port_add</tt> with <tt>BCM_VXLAN_PORT_REPLACE</tt> flag.
</td></tr><tr><td> SDK-53196 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> MPLS APIs Replace:
1.Support <tt>bcm_mpls_port_add</tt> to replace <tt>match_label</tt>, vpn, and flags (<tt>BCM_MPLS_PORT_CONTROL_WORD</tt>, <tt>BCM_MPLS_PORT_ENTROPY_ENABLE</tt>) with <tt>BCM_MPLS_PORT_REPLACE</tt> and <tt>mpls_port_id</tt>. In case of <tt>mpls_port_id</tt> is protected, <tt>egress_label</tt>.label and port of FEC can also be replaced.
2.Support <tt>bcm_mpls_tunnel_initiator_create</tt> to replace label, vsi and action with <tt>BCM_MPLS_EGRESS_LABEL_REPLACE</tt> and <tt>tunnel_id</tt>.
3.Support <tt>bcm_mpls_tunnel_switch_create</tt> to replace <tt>egress_label</tt>, <tt>qos_map_id</tt>, <tt>tunnel_if</tt> and flags (<tt>BCM_MPLS_SWITCH_FRR</tt>, <tt>BCM_MPLS_SWITCH_LOOKUP_SECOND_LABEL</tt>, <tt>BCM_MPLS_SWITCH_ENTROPY_ENABLE</tt>, <tt>BCM_MPLS_SWITCH_TRAP_TTL_0</tt>, <tt>BCM_MPLS_SWITCH_TRAP_TTL_1</tt>, <tt>BCM_MPLS_SWITCH_SKIP_ETHERNET</tt>, <tt>BCM_MPLS_SWITCH_NEXT_HEADER_L2</tt>, <tt>BCM_MPLS_SWITCH_NEXT_HEADER_IPV4</tt>, <tt>BCM_MPLS_SWITCH_NEXT_HEADER_IPV6</tt>) with <tt>BCM_MPLS_SWITCH_REPLACE</tt> and <tt>in_label</tt>, in case of action is <tt>BCM_MPLS_SWITCH_ACTION_POP</tt>.
4.Support <tt>bcm_mpls_vpn_id_create</tt> to replace <tt>broadcast_group</tt>, <tt>unknown_multicast_group</tt> and <tt>unknown_unicast_group</tt> with flags <tt>BCM_MPLS_VPN_VPLS</tt>|<tt>BCM_MPLS_VPN_WITH_ID</tt>. The replaced <tt>broadcast_group</tt> should be equal to <tt>unknown_multicast_group</tt> and also equal to <tt>unknown_unicast_group</tt>.
</td></tr><tr><td> SDK-53198 
 </td><td> 733029
 </td><td> 56640_A0
56440_A0
56641_A0
56450_A0
 </td><td> The problem in existing code was - <tt>bcm_l3_egress_get</tt>() was not able get the <tt>mpls_qos_map_id</tt> i.e logical qos id ( if object was created by <tt>bcm_qos_map_create</tt>). In this release to solve this issue, a new routine <tt>_egr_qos_hw_idx2id</tt>() has been created. This converts the hardware index to logical qos id. This function is used in the <tt>bcm_l3_egress_get</tt> to retrieve the <tt>mpls_qos_map_id</tt>.
This function can handle both the <tt>qos_id</tt> created by <tt>bcm_qos_map_create</tt>() and <tt>bcm_mpls_exp_map_create</tt>().
</td></tr><tr><td> SDK-53201 
 </td><td> 710888
 </td><td> 88650_A0
88650_B0
 </td><td> ARP extender provides the ability for IPV4 UC packets MAC extension offset from IPV4 host table to next-hop mac address. In ARAD-A/B ARP extender is implemented using the egress-editor micro-code. Program caused on some Trill packets to drop. Modified ARP extender program to handle only IPV4 UC packets as it should be.
</td></tr><tr><td> SDK-53202 
 </td><td> 727655
 </td><td> 88650_B0
 </td><td> <tt>bcm_bfd_endpoint_create</tt> <tt>WITH_ID</tt> ignores the given id and returns a new allocated one.
</td></tr><tr><td> SDK-53204 
 </td><td> 732754
 </td><td> 88030_A0
 </td><td> Certain configuration parameters are required to set and configure the ILKN OOB flow control.
The following illustrates how the required parameters are used and when to use them
Some parameters are specific to Caladan3 chip.
<p>1) Enable Interlaken Flow control when there is an interlaken port
 <ul><li>  <tt>fc_oob_type_</tt>&lt;ilx&gt;=2</li></ul>2) Enable Interlaken flow control when there is no interlaken port
 <ul><li> <tt>fc_type_il_line</tt>=1
 </li><li>  <tt>fc_type_il_fabric</tt>=1</li></ul>3) Default Calendar length is 64, if not the following has to be set appropriately
 <ul><li> <tt>fc_calendar_length_il_line</tt>=&lt;len&gt;
 </li><li>  <tt>fc_calendar_length_il_fabric</tt>=&lt;len&gt;</li></ul>4)  Debugging
           1.Ignore the FC OOB status
 <ul><li>  <tt>ilkn_interface_status_oob_ignore</tt>=1</li></ul>           2.Enable Loopback of FC data
 <ul><li>  <tt>fc_oob_loopback_</tt>&lt;ilx&gt; = 1</li></ul></td></tr><tr><td> SDK-53218 
 </td><td> 727679
 </td><td> 88650_A0
88650_B0
88650_B1
 </td><td> Port TPIDs: When deleting TPID to default behavior with API <tt>bcm_port_tpid_delete</tt> or <tt>bcm_port_tpid_delete_all</tt> , TPID profile wasn't changed correctly.
</td></tr><tr><td> SDK-53225 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> VLAN: SDK/src/examples/dpp/<tt>cint_vlan_translation_new_mode</tt>.c was renamed to appropriate name:
SDK/src/examples/dpp/<tt>cint_advanced_vlan_translation_mode</tt>.c 
</td></tr><tr><td> SDK-53227 
 </td><td> 733542
 </td><td> 56450_A0
 </td><td> Corrected code for Multicast traffic.
PID will be updated by cosq scheduler function at run time (for subport queue configuration etc)
</td></tr><tr><td> SDK-53242 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> VLAN: The api <tt>bcm_petra_vlan_control_port_set</tt> is responsible of setting miscellaneous port-specific vlan options. It receives as a parameter <tt>bcm_vlan_control_port_t</tt> type. Two enumerations
of this variable are not supported in AVT mode: bcmVlanPortPriTaggedDrop and bcmVlanPortTranslateKeyFirst. Hitherto this change, these cases returned <tt>BCM_E_NOT_FOUND</tt>. The fix returns <tt>BCM_E_UNAVAIL</tt> in case the type equals one of the two.
</td></tr><tr><td> SDK-53255 
 </td><td> 728560
 </td><td> 56640_B0
 </td><td> In the previous release,when external phy called the speed notify of 100M on the internal serdes, the default was 100FX(fiber mode). However
100FX was not supported on warpcore C0, so packets would not go through. 
Since WarpCore C0 does not support 100FX and the default mode is fiber, so for 100M speed it will not work. The fix will be using sgmii 100M mode for warpCore c0.
</td></tr><tr><td> SDK-53283 
 </td><td> 733471
 </td><td> 56450_A0
 </td><td> Clear HQOS configuration while switching from extended queuing to diffserv queuing.
</td></tr><tr><td> SDK-53286 
 </td><td> 733518
 </td><td> 88650_A0
88660_A0
 </td><td> PON: Add a new criteria "<tt>BCM_VLAN_PORT_MATCH_PORT_TUNNEL_PCP</tt>" to classify PON InLIF based on PON-Port, Tunnel-ID and outer PCP.
</td></tr><tr><td> SDK-53289 
 </td><td> 734160
 </td><td> 56450_A0
 </td><td> Fixed <tt>SOURCE_TRUNK_MAP_MODBASE</tt> and <tt>SOURCE_TRUNK_MAP</tt> configuration for BCM56450. Previously there was a configuraton error for subport.
</td></tr><tr><td> SDK-53290 
 </td><td></td><td> 88660_A0
 </td><td> When a link status changed , fabric min number of links feature might not work, and traffic won't stop. Fixed.
</td></tr><tr><td> SDK-53301 SDK-53047
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Trill functionality always enabled Trill designated VLAN check: A single VLAN allowed for Trill encapsulated packet on a specific port. Device supports up to 8 different designated VLANs. In case more than 8 different designated VLANs are needed, user needs to disable this check.
New soc property added to disable this check - <tt>trill_designated_vlan_check_disable</tt>=1. 
User can mimic check using ACLs.
</td></tr><tr><td> SDK-53304 
 </td><td></td><td> 88660_A0
 </td><td> Introduce a new VLAN-Port property : <tt>FORWARD_GROUP</tt>
In the regular VLAN-Port settings MACT forward to VLAN-Port. In order to forward to VLAN-Port MACT needs two fields information: Out-LIF (outgoing logical interface) and Out-Port (physical destination).
Forward-Group allows instead of using the MACT to result for forwarding information, have indirection group (forward-group) to provide the information on destination and the other bits to use the FP settings in a flexible way.
<p>The indirection object (Forward-group) that consist both the physical-destination and the outgoing logical-interface (out-LIF) is implemented in DNX using FEC.
<p>To allow such a scheme a flag indicate it <tt>BCM_VLAN_PORT_FORWARD_GROUP</tt> /* Use forwarding group */
Note: When supporting Forward-Group device must disable HW learning and use only CPU learning.
</td></tr><tr><td> SDK-53311 
 </td><td> 733395
 </td><td> 56850_A2
 </td><td> Operations in <tt>soc_l2x_freeze</tt>/thaw() for TD2 have been optimized by using <tt>ING_MISC_CFG2</tt> <tt>CML_NEW_OVERRIDE</tt>/<tt>CML_MOVE_OVERRIDE</tt> to disable/enable the learning instead of modifying individual port/svp table entries.
</td></tr><tr><td> SDK-53327 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> PON: In application level, upstream and downstream should use different MC-ID upon VPN PON service creation.
</td></tr><tr><td> SDK-53338 
 </td><td></td><td> 56850_A1
56850_A2
56850_A0
 </td><td> Fixed range check for VXLAN <tt>VN_ID</tt> and L2GRE VPNID during vpn create API
</td></tr><tr><td> SDK-53341 
 </td><td></td><td> 88650_A0
 </td><td> Calculation of channelized interface shaper is now corrected when calling:
<tt>bcm_cosq_gport_bandwidth_set</tt>(unit,<tt>parent_port</tt>,cosq,0,<tt>kbits_per_sec</tt>,0);
Where <tt>parent_port</tt> is: 
<tt>BCM_COSQ_GPORT_E2E_PORT_SET</tt>(<tt>e2e_port</tt>,port);
<tt>bcm_fabric_port_get</tt>(unit,<tt>e2e_port</tt>,0,<tt>parent_port</tt>);
</td></tr><tr><td> SDK-53345 
 </td><td> 734829
 </td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Warmboot: Performing WB or synchronizing the warmboot DB using <tt>bcm_switch_control_set</tt>() may have caused DB segmentation fault due to a short buffer that handles protection FECs.
The buffer size was fixed.
In 6.3.3, if protection FECs with values of 8K and above were used or if a warmboot was performed, a device reboot in 6.3.4 is required in order to eliminate any possible memory override issues.
</td></tr><tr><td> SDK-53346 
 </td><td> 731211
 </td><td> 88650_A0
 </td><td> The member ID of Trunk port as it written to the <tt>IHP_PTC_SYS_PORT_CONFIG</tt> &amp; <tt>IHP_VIRTUAL_PORT_TABLE</tt> was not the index in the IRR lag mapping table.
We fixed lag member delete/add to keep this tables synced.
</td></tr><tr><td> SDK-53348 
 </td><td> 733779
 </td><td> 88030_A0
 </td><td> In the previous release an issue was discovered with clearing Interlaken counters. This has been fixed. When using "clear counters", we now clear those counts for both hardware counters and the software variable, then we will reset those counts.
</td></tr><tr><td> SDK-53356 
 </td><td></td><td> All
 </td><td> Ensure that KNET DMA abort works correctly on idle DMA channels on CMICe-based devices such as BCM5684x.
</td></tr><tr><td> SDK-53358 
 </td><td></td><td> 88660_A0
 </td><td> OAM LM packets are always counted in ARAD due to HW bug.
In ARAD+ LM packets are counted only upon user request (can be configured using <tt>bcm_oam_endpoint_action_set</tt> api).
</td></tr><tr><td> SDK-53360 
 </td><td></td><td> All
 </td><td> Fixed potential Tx DMA lockup in KNET kernel module.
</td></tr><tr><td> SDK-53362 
 </td><td></td><td> 88650_A0
 </td><td> In Field Processor, when using direct extraction tables, a segmentation fault may have occurred in some cases when setting qualifiers.This is fixed.
</td></tr><tr><td> SDK-53363 
 </td><td> 732741
 </td><td> 88650_A0
 </td><td> On some operating systems in previous releases, init might fail with segmentation fault in egress editor init. This has been fixed
</td></tr><tr><td> SDK-53367 
 </td><td> 735381
 </td><td> 88030_A0
 </td><td> SDK-53367 PTN6500 - line rate test cause "ped egress drop" issue. This is actually a COP access constraint that was not
	     covered. The constraint is the 2nd rule of the following:
<p>	1st rule: Independent of the targeted instance, COP accesses always have AT LEAST a 64 instruction resource shadow. (covered
	          by 51017 R-000-10 COP Resource Shadow (load) and 51018 R-001-10 COP Load Latency)
<p>    2nd rule: Per COP instance, the assembler maintains a counter (initialized to 0). The counter value must be &lt;= 128 in order to access 
              the associated COP instance without violating the constraint. The counter is maintained as follows:
                1.) Starts at 0.
                2.) Add 128 to the counter when the associated COP instance is accessed.
                3.) For each instruction slot, if the counter is non-zero, and it has been at least 64 instructions 
                    since the associated COP instance has been accessed, subtract 2 from the counter. Note that this 
                    is not the same as the COP port resource shadow (see 1st rule) which is common to both COP instances.
<p>	New resource constraint: R-002-10
    New error number: 51064
<p>    Example error message:
<p>    Error! [51064] copTest.lrp3-&gt;90:5-&gt;1.76 =&gt; 223:5-&gt;1.199 = constraint R-002-10 COP per instance access constraint violation. shadow:1 Next safe instruction for COP instance 0 access is: 200	
</td></tr><tr><td> SDK-53370 
 </td><td> 726683
 </td><td> 88650_B1
 </td><td> When using FCoE example CINT, the FCoE header in the forwarded packet was omitted.
The trap ID that is used for FCF workaround, which fixes the forwarding header offset was wrong and is now fixed.
</td></tr><tr><td> SDK-53374 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> The default range of the credit watchdog was fixed to include all queues.
The default range before the fix was one queue - queue zero.
A side affect of the driver coming with the previous default and not changing it later is that if the system comes up under traffic, queues may get stuck and require ingress soft-reset.
</td></tr><tr><td> SDK-53385 
 </td><td> 721111
 </td><td> 88650_A0
 </td><td> In RX snoop, the number of HW snoop commands is 16, where 0 is reserved for packets which are not snooped.
Due to a SW bug, the number of available snoop commands was 15 and not 16. This is fixed.
<p>This fix was reverted in 6.3.5 because it breaks ISSU and can be taken from TOT as a patch.
</td></tr><tr><td> SDK-53414 
 </td><td> 734150
 </td><td> 56850_A0
 </td><td> In the previous release we did not support HG13 on TD2. In this release support has been added for speed 13000M. Additionally in <tt>soc_td2_port_asf_speed_set</tt>(),if speed = 0xe, speed 13000M duplex full will be selected.
</td></tr><tr><td> SDK-53431 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> TM only mode: When bcm.user loads in TM mode, it shouldn't matter what PP soc properties are active, since PP is disabled.
There was a problem where setting the Advanced Vlan Translation mode soc property caused a conflict that made bmc.user crash at startup.
The problem was fixed, and now the device can start normally with both modes on.
</td></tr><tr><td> SDK-53449 
 </td><td> 733944
 </td><td> 56850_A0
56855_A0
56854_B0
56854_A0
56850_A1
56851P_A1
56851_A1
56850_A2
56851_A2
56851P_A2
56854_A2
56853_A2
56852_A2
56855_A2
56851_A0
56852_A0
56852_A1
56853_A0
56853_A1
 </td><td> In the previous release. bcmportControlDoNotCheckVlan was being overwritten by unrelated port API calls. This has been fixed.
</td></tr><tr><td> SDK-53453 
 </td><td> 675993
 </td><td> 56846_A0
56845_B0
56840_A0
56640_A0
56440_A0
56850_A0
56855_A0
56843_B0
56340_A0
56640_B0
56440_B0
56850_A1
56850_A2
56344_A0
56342_A0
 </td><td> Added support for MIM payload tpid select and MIM hash by using payload or tunnel header.
</td></tr><tr><td> SDK-53470 
 </td><td> 736427
 </td><td> 56450_A0
 </td><td> Fixed issue with mpls port delete for CoE subport on BCM56450
</td></tr><tr><td> SDK-53472 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> In the example application (called by arad.soc), the RX module was not activated after warmboot.
This is fixed by calling DPP application in WB mode.
Reference code for customer application. No driver change.
</td></tr><tr><td> SDK-53473 
 </td><td> 736455
 </td><td> 56450_A0
 </td><td> In an earlier release <tt>bcm_cosq_gport_attach</tt> return <tt>BCM_E_RESOURCE</tt> after several rounds of subport add and delete actions. In this release hardware resources of strict priority children are now bing released when the number of children becomes zero which makes node unresolved function consistent with node resolve.
</td></tr><tr><td> SDK-53478 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> MPLS: <tt>bcm_mpls_vpn_id_get</tt>() retrieves VPN information from a VSI that was associated as an MPLS VPN (<tt>bcm_mpls_vpn_id_create</tt>).
The same VSI may also be used for vswitch, MIM, etc.
The supplied VSI to <tt>bcm_mpls_vpn_id_get</tt>() was validated for VSI existance, but it also successfully retrieved VSI info for VSIs
that were allocated by other applications, but were not used by the MPLS.
The validation for <tt>bcm_mpls_vpn_id_get</tt>() was fixed so that VSIs that are not used by the MPLS, return an <tt>E_NOT_FOUND</tt> error.
</td></tr><tr><td> SDK-53484 
 </td><td></td><td> 88650_A0
 </td><td> Fixed uninitialized value in internal function <tt>_bcm_dpp_am_egress_encap_init</tt>.
</td></tr><tr><td> SDK-53488 
 </td><td> 736297
 </td><td> 88650_A0
 </td><td> ARAD does not support Type-4 VCCV (GAL over PWE).
We propose a solution to trap GALoPWEoLSPoETH packets to CPU by using bcmRxTrapMplsUnexpectedNoBos trap.
Field processor is used to change the MPLS InLif to PWE Inlif, so the trapped packet contains PWE InLif in the PPH.
NOTE: In ARAD soc property <tt>custom_feature_mpls_termination_check_bos_disable</tt> should be set.
In ARAD+ no soc property is required.
<p>For usage example see <tt>cint_gal_o_pwe_o_mpls</tt>.c
</td></tr><tr><td> SDK-53515 
 </td><td> 734789
 </td><td> 5615_A0
 </td><td> HR2: QSGMII running as SGMII mode was showing the wrong duplex attribute. In this release we have fixed the duplex get function for qsgmii serdes in sgmii mode
</td></tr><tr><td> SDK-53531 
 </td><td> 727653
 </td><td> 88650_A0
 </td><td> BFD packets may now be trapped to custom gports.
When calling <tt>bcm_bfd_endpoint_create</tt>(), set the <tt>remote_gport</tt> field to a valid gport for trapping BFD frames to that gport. Macros such as <tt>BCM_GPORT_LOCAL_SET</tt>() should be used for converting ports to gports and setting <tt>remote_gport</tt>.
If the default behavior is preferred, <tt>remote_gport</tt> should be set to <tt>BCM_GPORT_INVALID</tt> (this is configured in <tt>bcm_bfd_endpoint_info_t_init</tt>()).
</td></tr><tr><td> SDK-53542 
 </td><td></td><td> 88650_A0
 </td><td> ECMP - Trunk: a new CINT has been inserted, emulating the 88650 HW and how an hash member is selected in ECMP and Trunk (i.e., LAG).
The CINT is called: <tt>cint_trunk_ecmp_lb_key_and_member_retrieve</tt>.c
This CINT does not apply on BCM88660.
</td></tr><tr><td> SDK-53558 
 </td><td> 716344
 </td><td> 88030_A0
 </td><td> The exception byte counter was not incremented when a packet is dropped due to drop tag (or) drop untag configuration. This is fixed.
</td></tr><tr><td> SDK-53560 
 </td><td> 719326
 </td><td> 88030_A0
 </td><td> The pvv2e.hit bit handling is fixed. The <tt>soc_sbx_g3p1_utils_pvv2e_update</tt>() &amp; <tt>soc_sbx_g3p1_utils_pvv2e_add</tt>() functions sets the hit bit by default.
</td></tr><tr><td> SDK-53563 
 </td><td> 736727
 </td><td> 56334_B0
56334_A0
 </td><td> Fixed error return value of <tt>bcm_mpls_label_stat_get</tt>/get32 on Enduro
</td></tr><tr><td> SDK-53612 
 </td><td> 728198
 </td><td> 88650_B1
 </td><td> When working in 2P or 1P mode, ISQ root shaper doesn't work correctly (traffic is not shaped regardless shaper configuration).
</td></tr><tr><td> SDK-53613 
 </td><td> 735136
 </td><td> 88650_A0
88650ACP_A0
88650_B0
88650_B1
 </td><td> When setting WRED using <tt>bcm_cosq_gport_discard_set</tt>, and using min/max threshold values close to the limit of 256MB-1, an error was returned.
This was fixed, and the range of the min/max WRED thresholds was extended up to 2GB.
The actual value that can be specified is up to 2GB-1 sue to the range of the int structure field that specifies it.
</td></tr><tr><td> SDK-53619 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> Within advanced VLAN mode, <tt>cos_profile</tt> should be explicitly attached to LIF using <tt>bcm_qos_port_map_set</tt>() .
</td></tr><tr><td> SDK-53633 
 </td><td></td><td> 88650_A0
88660_A0
 </td><td> Warm Boot: Creating an In-LIF object may also create a FEC object as part of a 1:1 protection scheme or
a forwarding group of a VLAN Port, or as part of PWE protection. This is done by calling
calling <tt>bcm_vlan_port_create</tt>() or <tt>bcm_mpls_port_add</tt>() respectively.
If such an operation that creates a protection FEC, was created after a warmboot has been performed, it would fail.
The fix, enables the creation of a the above protetcion FECs after performing warm boot, as expected.
</td></tr><tr><td> SDK-53639 
 </td><td> 737816
 </td><td> All
 </td><td> bcmFieldQualifyL3Ingress qualifier offsets are updated for Ingress Field Processor to match with regfile (56850).
<p>Problem : 
Previously the qualifier set was showing "Feature Unavailable" error during group create.  This was due to missing initialization of L3Ingress qualifier.
<p>Solution: 
With this fix the  group create will cause "No resources for operation" error for the qualifier set mentioned above.
This is because after adding bcmFieldQualifyL3Ingress to the Groups QSET the KEY width is exceeding what TD2 IFP H/W can support.
<p>Customer has to remove either bcmFieldQualifyInterfaceClassL3 or bcmFieldQualifyIntPriority qualifier from the Groups QSET set to add bcmFieldQualifyL3Ingress to existing Group.
  OR 
Customer has to create a new Field Group with bcmFieldQualifyL3Ingress qualifier in it. 
</td></tr><tr><td> SDK-53640 
 </td><td></td><td> 56334_B0
56334_A0
 </td><td> In earlier releases a crash was introduced when initializing BCM56634 via changes added in <tt>soc_do_init</tt>. In this release we have added device checking for the new block of code introduced to change the PCIe SerDes deemphasis on certain devices (fix for SDK-50513).
</td></tr><tr><td> SDK-53650 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
 </td><td> Fixed the crash <tt>in_bcm_dpp_rx_packet_parse</tt> when called with <tt>BCM_ARAD_PARSE_PACKET_IN_INTERRUPT_CONTEXT</tt>.
<p>Registered are not accessed when working in interrupt context.
</td></tr><tr><td> SDK-53654 
 </td><td></td><td> 88650_A0
88650_B0
88650_B1
88660_A0
 </td><td> Fixed "diag rates sch" shell command crash which is caused by reading non-existent register.
</td></tr><tr><td> SDK-53675 
 </td><td></td><td> 88650_A0
88650_B0
88660_A0
 </td><td> BFD packets may now be trapped using pre-defined traps.
When calling <tt>bcm_bfd_endpoint_create</tt>(), the <tt>remote_gport</tt> field may be set to a valid gport for trapping BFD frames to that gport, <tt>GPORT_INVALID</tt> for the default behavior or <tt>remote_gport</tt> may be set to a pre-configured trap code.  For the latter, call <tt>bcm_rx_trap_type_create</tt>() to get a trap code, <tt>bcm_rx_trap_set</tt>() to set the trap code with a valid <tt>dest_port</tt> configured in <tt>bcm_rx_trap_config_t</tt>, <tt>BCM_RX_TRAP_UPDATE_DEST</tt> and <tt>BCM_RX_TRAP_TRAP</tt> flags set. Then set <tt>remote_gport</tt> to the said trap code before calling <tt>bcm_bfd_endpoint_create</tt>().
</td></tr><tr><td> SDK-53731 
 </td><td> 739297
 </td><td> 88750_A0
88750_B0
 </td><td> "diag queues" command shell wasn't functional over dual pipe.
</td></tr><tr><td> SDK-53767 
 </td><td></td><td> 88650_A0
 </td><td> cleaned HW access that were causing error prints during warm reboot (due to statistic threads that would perform HW access)
</td></tr><tr><td> SDK-53824 
 </td><td></td><td> 56450_A0
 </td><td> In previous releases a crash could occur with subport configuration. This has been addressed by correcting the wrong assumption of COE subport configuration for calculating <tt>op_nodes</tt> for physical ports.
 Now it is purely based on number of <tt>op_nodes</tt> consumed by each physical port in sequence (CPU,LPBK,1..40) 
</td></tr><tr><td> SDK-53826 
 </td><td></td><td> 88660_A0
 </td><td> PON: <tt>bcm_vlan_port_create</tt> set incorrect configuration when having 3 tags manipulation under <tt>bcm886xx_vlan_translate_mode</tt>=1.
</td></tr><tr><td> SDK-53837 
 </td><td></td><td> 88650_B0
88650_B1
 </td><td> Fix documentation of <tt>cint_vswitch_cross_connect_p2p</tt>.c to load all the cints in correct order.
</td></tr><tr><td> SDK-53839 
 </td><td></td><td> 88650_B0
88650_B1
 </td><td> VPLS: Added cint <tt>cint_vswitch_vpls</tt>.c support in index mpls mode that enables termination of up to 3 labels.
Index mode is set using soc property <tt>mpls_termination_label_index_enable</tt>.
</td></tr><tr><td> SDK-53867 
 </td><td> 740320
 </td><td> 56850_A0
56850_A1
56850_A2
 </td><td> One of the following solutions can be used to address the persistent link flap problem with CR4 + AutonegOn on ports:
<p>(a) Do NOT enable <tt>RX_SERDES_LOS</tt> and Fast linkscan property in the configuration. This means to disable the SOC property <tt>rx_serdes_los</tt>, or, EXCLUDE the port(s) from the SOC property <tt>rx_fast_los_link_</tt>{port}.
<p>(b) If the user wants to be able to remove/add ports into fast linkscan dynamically,user can now  disable the fast linkscan port control "bcmPortControlRxFastLOS" : <tt>bcm_port_control_set</tt>/get(unit, port, bcmPortControlRxFastLOS, ...).
</td></tr><tr><td> SDK-53891 
 </td><td></td><td> 88650_A0
 </td><td> Relevant only for TDM bypass mode: Warm boot would reset some of the TDM fabric direct routing configuration, and cause later configuration of it to be incorrect.
</td></tr><tr><td> SDK-53946 
 </td><td></td><td> 88650_B1
88660_A0
 </td><td> Important note: in Fiber channel APIs, due to an API change, the user must replace <tt>bcm_fcoe_zone_entry_t</tt>-&gt;vsan.vsan by <tt>bcm_fcoe_zone_entry_t</tt>-&gt;<tt>vsan_id</tt>, e.g. in <tt>bcm_fcoe_zone_add</tt> API.
</td></tr><tr><td> SDK-54096 
 </td><td></td><td> 88650_A0
 </td><td> The private header that includes the packet size was supported in previous version, but collide with other PP features that are supported by the egress editor.
This fix resolves the issues when trying to enable multiple PP features while still maintaining the usage of the "size header" addition on top of the packet header.
</td></tr><tr><td> SDK-54378 
 </td><td></td><td> 88650_A0
 </td><td> To debug more easily warmboot issues, a SW state dump is available via BCM&gt;diag ssdump
The SW state dump output to screen can now be disabled.
</td></tr><tr><td> SDK-56158 
 </td><td> 756172
 </td><td> 56440_A0
 </td><td> Problem description: When L2 MAC Table is full, customer was unable to create the BFD session due to MAC table full issue.
Fix description: This issue is fixed by calling <tt>_bcm_l2_hash_dynamic_replace</tt> function, if <tt>soc_mem_insert</tt> function returns <tt>BCM_E_FULL</tt>.
                 and also code changes are done in <tt>_bcm_l2_hash_dynamic_replace</tt> function to support <tt>BFD_KEY</tt> for Katana device.
</td></tr></tbody></table></html></body>
