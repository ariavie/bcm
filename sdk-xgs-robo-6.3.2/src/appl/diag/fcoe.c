/*
 * $Id: fcoe.c 1.13 Broadcom SDK $
 *
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 */

#include <sal/appl/sal.h>
#include <sal/appl/config.h>
#include <sal/appl/io.h>
#include <sal/core/alloc.h>
#include <sal/core/thread.h>
#include <bcm/error.h>
#include <bcm/tx.h>
#include <bcm/rx.h>
#include <bcm/link.h>
#include <bcm/vlan.h>
#include <bcm/stat.h>
#include <bcm/field.h>
#include <bcm/port.h>
#include <bcm/fcmap.h>
#include <soc/enet.h>
#include <soc/debug.h>
#include <soc/cm.h>
#include <appl/diag/shell.h>
#include <appl/diag/system.h>
#include <appl/diag/dport.h>


#ifdef INCLUDE_FCMAP
typedef struct fip_flogi_s {
    char used;
    sal_mac_addr_t sa;
    int port;
    uint16 oxid;
    uint16 rxid;
}fip_flogi_t;

#define FCOE_MAX_FIP_FLOGI 16
fip_flogi_t fip_flogi_pending[FCOE_MAX_FIP_FLOGI];


bcm_mac_t  fcf_sa_mac = {0x00,0x10,0x18,0x01,0x02,0x03};
static volatile sal_thread_t fcoe_thread_id = SAL_THREAD_ERROR;

static int fcoe_fc_port; /* FC port */
STATIC void _print_fcmap_cfg(bcm_fcmap_port_config_t *cfg);
STATIC void fcoe_fip_thread(void *cookie);

unsigned char lldp[] = {
0x01, 0x80, 0xC2, 0x00, 0x00, 0x0E, 0x00, 0x10, 
0x18, 0x01, 0x02, 0x03, 0x88, 0xCC, 0x02, 0x07, 
0x04, 0x00, 0x10, 0x18, 0x01, 0x02, 0x03, 0x04, 
0x07, 0x05, 0x45, 0x74, 0x68, 0x31, 0x2F, 0x39, 
0x06, 0x02, 0x00, 0x78, 0x08, 0x09, 0x4E, 0x35, 
0x4B, 0x2D, 0x50, 0x6F, 0x72, 0x74, 0x00, 0x0A, 
0x07, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x00, 
0x0C, 0x0A, 0x4E, 0x35, 0x4B, 0x2D, 0x53, 0x77, 
0x69, 0x74, 0x63, 0x68, 0x0E, 0x04, 0x00, 0x04, 
0x00, 0x04, 0x10, 0x0E, 0x07, 0x06, 0x00, 0x0D, 
0xEC, 0xCD, 0xFD, 0x00, 0x02, 0x1A, 0x00, 0x80, 
0x00, 0x00, 0xFE, 0x37, 0x00, 0x1B, 0x21, 0x02, 
0x02, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
0x00, 0x00, 0x00, 0x01, 0x06, 0x06, 0x00, 0x00, 
0x80, 0x00, 0x08, 0x08, 0x08, 0x0A, 0x00, 0x00, 
0x80, 0x00, 0x89, 0x06, 0x00, 0x1B, 0x21, 0x08, 
0x04, 0x11, 0x00, 0x00, 0x80, 0x00, 0x00, 0x01, 
0x00, 0x00, 0x32, 0x32, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x02, 0xFE, 0x05, 0x00, 0x01, 0x42, 
0x01, 0x01, 0xFE, 0x06, 0x00, 0x80, 0xC2, 0x01, 
0x00, 0x01, 0x00, 0x00, 0xBC, 0x2A, 0x44, 0x0A, 
0xFD, 0x07, 0x07, 0x07};

unsigned char FLOGI_Request[] = 
{0x00, 0x0D, 0xEC, 0xCD, 0xFD, 0x00, 0x00, 0xC0, 0xDD, 0x12, 0xAB, 0x1D, 0x81,
0x00, 0x60, 0x04, 0x89, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x22, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00,
0x00, 0x01, 0x29, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x19, 0xFF, 0xFF,
0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x20, 0x20, 0x00, 0x0f, 0x80,
0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
0x00, 0x10, 0x18, 0x44, 0x2f, 0x55, 0x20, 0x00, 0x00, 0x10, 0x18, 0x44, 0x2f,
0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x01, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00,
0xFF, 0x00, 0x0C, 0x00, 0x01, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00,
0x08, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0xf0, 0xc3, 0x3c, 0x2b, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00};

unsigned char FIP_VLAN_Response[] = {
0x00, 0xc0, 0xdd, 0x12, 0xab, 0x1d, 0x00, 0x10, 
0x18, 0x01, 0x02, 0x03, 0x89, 0x14, 0x10, 0x00, 
0x00, 0x04, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00, 
0x02, 0x02, 0x00, 0x10, 0x18, 0x01, 0x02, 0x03, 
0x0e, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x50, 0x82, 0x96, 0x32 };

#if 0
unsigned char FIP_Keep_Alive_Response[] = {
0x00, 0x0D, 0xEC, 0xCD, 0xFD, 0x00, 0x00, 0x10, 
0x18, 0x96, 0xCF, 0xA7, 0x81, 0x00, 0x60, 0x0A, 
0x89, 0x14, 0x10, 0x00, 0x00, 0x03, 0x00, 0x01, 
0x00, 0x02, 0x80, 0x07, 0x02, 0x02, 0x00, 0x10,
0x18, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x76, 0x7A, 0xA2, 0x3E, 
0xFD, 0x07, 0x07, 0x07};
#endif

unsigned char FIP_Advertisement[] = {
0x00, 0xC0, 0xDD, 0x12, 0xAB, 0x1D, 0x00, 0x10, 0x18, 0x01, 0x02, 0x03, 0x81, 0x00, 0x60, 0x04,
0x89, 0x14, 0x10, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x0d, 0x80, 0x07, 0x01, 0x01, 0x00, 0x80,
0x02, 0x02, 0x00, 0x10, 0x18, 0x01, 0x02, 0x03, 0x04, 0x03, 0x00, 0x00, 0x20, 0x00, 0x00, 0x10,
0xEC, 0xCD, 0xFD, 0x01, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x20, 0x00, 0x00, 0x10,
0xEC, 0xCD, 0xFD, 0x01, 0x0C, 0x02, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x40, 0x06, 0x01, 0x08, 0x2E,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xFD, 0x07, 0x07, 0x07};
/* 0x6B, 0x7A, 0x56, 0xD3, 0xFD, 0x07, 0x07, 0x07}; */

unsigned char FIP_FLOGI_Response[] = {
0x00, 0x10, 0x18, 0x44, 0x2f, 0x55, 0x00, 0x0d, 
0xec, 0xca, 0x05, 0x40, 0x81, 0x00, 0x60, 0x04, 
0x89, 0x14, 0x10, 0x00, 0x00, 0x02, 0x00, 0x02, 
0x00, 0x26, 0x80, 0x00, 0x07, 0x24, 0x00, 0x00, 
0x23, 0xb8, 0x02, 0x3c, 0x00, 0xff, 0xff, 0xfe, 
0x01, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x05, 0x55, 0xd3, 0xc8, 0x00, 0x00, 0x00, 0x00, 
0x02, 0x00, 0x00, 0x00, 0x20, 0x06, 0x00, 0x00, 
0x33, 0x00, 0x08, 0x40, 0x00, 0x00, 0x27, 0x10, 
0x00, 0x00, 0x07, 0xd0, 0x20, 0x13, 0x00, 0x0d, 
0xec, 0xca, 0x05, 0x7f, 0x20, 0x01, 0x00, 0x0d, 
0xec, 0xc9, 0x03, 0x41, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0xfc, 
0x00, 0xb8, 0x02, 0x3c, 0x2e, 0x53, 0xe3, 0xe3 };

unsigned char FDISC_Request[] = {
0x00, 0x0D, 0xEC, 0xCD, 0xFD, 0x00, 0x00, 0xC0, 
0xDD, 0x12, 0xAB, 0x1D, 0x81, 0x00, 0x60, 0x04, 
0x89, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 
0x22, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 
0x01, 0x29, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 
0x00, 0x19, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 
0x51, 0x00, 0x00, 0x00, 0x20, 0x20, 0x00, 0x28, 
0x80, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x10, 
0x18, 0x44, 0x2f, 0x56, 0x20, 0x00, 0x00, 0x10, 
0x18, 0x44, 0x2f, 0x55, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x01, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x08, 0x00, 0x00, 0xFF, 0x00, 0x0C, 
0x00, 0x01, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x08, 0x00, 0x00, 0xFF, 0x00, 0x00, 
0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xa0, 0x5c, 0x1e, 0xff, 
0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

#define FIP_OPCODE_DISCOVERY 0x1
#define FIP_SUBCODE_DISCOVERY_SOLICITION   0x1
#define FIP_SUBCODE_DISCOVERY_ADVERTISMENT 0x2


#define FIP_OPCODE_FLOGI 0x2
#define FIP_SUBCODE_FLOGI_REQUEST 0x1
#define FIP_SUBCODE_FLOGI_REPLY   0x2

#define FIP_OPCODE_VLAN 0x4
#define FIP_SUBCODE_VLAN_REQUEST 0x1
#define FIP_SUBCODE_VLAN_REPLY 0x2

#define FIP_OPCODE_KEEPALIVE 0x3
#define FIP_SUBCODE_KEEPALIVE_REQUEST 0x1
#define FIP_SUBCODE_KEEPALIVE_REPLY 0x2

#define FCOE_FIP_OPCODE(pkt) \
    ((uint16) ((BCM_PKT_VLAN_PTR(pkt)[8] << 8) | (BCM_PKT_VLAN_PTR(pkt)[9])))

#define FCOE_FIP_SUBCODE(pkt) \
    ((uint8)(BCM_PKT_VLAN_PTR(pkt)[11]))

#define FCOE_FIP_DESC_LEN(pkt) \
    ((uint16) ((BCM_PKT_VLAN_PTR(pkt)[13] << 8) | (BCM_PKT_VLAN_PTR(pkt)[12])))


#define FCOE_R_CTL(pkt) \
    ((uint8)(BCM_PKT_VLAN_PTR(pkt)[20]))

/* 
 * 1> All FCOE frames origniation from Source NPort Id, will be routed to dest fc
 * port.
 * 2> All FCOE frames from dest_fc port with src nport ID will be routed to
 * src_eth_port
 */
STATIC int
fcoe_add_nport_route(int unit, int src_eth_port, int src_nport_id, int dest_fc_port)
{
    bcm_field_qset_t qset;
    bcm_field_group_t group;
    bcm_field_entry_t entry;
    bcm_field_action_t action = bcmFieldActionRedirect;
    bcm_field_stat_t stat_entry = bcmFieldStatPackets;
    int stat_id;
    bcm_gport_t gport[2] = {0x8000007, 0x8000009}; /* xe2, xe4 */

    bcm_mac_t mac1 = {0x00, 0xfc, 0x00, 0x00, 0x00, 0x00};
    bcm_mac_t mac2 = {0x00, 0x10, 0x18, 0x01, 0x02, 0x03};
    bcm_mac_t mac_mask = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    bcm_port_gport_get(unit, dest_fc_port, &gport[0]);
    bcm_port_gport_get(unit, src_eth_port, &gport[1]);

    mac1[3] = (src_nport_id & 0xff0000) > 16; 
    mac1[4] = (src_nport_id & 0x00ff00) > 8; 
    mac1[5] = (src_nport_id & 0x0000ff); 

    printk("fcoe_add_nport_route: src_eth_port = %d, src_nport_id = %x, dest_fc_port = %d\n",  src_eth_port, src_nport_id, dest_fc_port);

    BCM_FIELD_QSET_INIT(qset);
    BCM_FIELD_QSET_ADD(qset, bcmFieldQualifySrcMac);
    BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyDstMac);

    /* group create */
    bcm_field_group_create(unit, qset, 1, &group);

    /* Entry1: Redirect to xe4 */
    bcm_field_entry_create(unit, group, &entry);
    bcm_field_qualify_DstMac(0, entry, mac1, mac_mask);
    bcm_field_qualify_SrcMac(0, entry, mac2, mac_mask);
    bcm_field_action_add(unit, entry, action, -1, gport[1]); 
    bcm_field_stat_create(0, group, 1, &stat_entry, &stat_id);
    bcm_field_entry_stat_attach(0, entry, stat_id);
    printk("EID:%d STATID:%d\n", entry, stat_id);
    bcm_field_entry_install(unit, entry);

    /* Entry2: Redirect to xe2 */
    bcm_field_entry_create(unit, group, &entry);
    bcm_field_qualify_SrcMac(0, entry, mac1, mac_mask);
    bcm_field_qualify_DstMac(0, entry, mac2, mac_mask);
    bcm_field_action_add(unit, entry, action, -1, gport[0]);
    bcm_field_stat_create(0, group, 1, &stat_entry, &stat_id);
    bcm_field_entry_stat_attach(0, entry, stat_id);
    printk("EID:%d STATID:%d\n", entry, stat_id);
    bcm_field_entry_install(unit, entry);

    return BCM_E_NONE;
}

STATIC int
fcoe_tx_pkt_helper(int unit, int port, unsigned char *pkt_data, int len)
{
    bcm_pkt_t pkt;
    enet_hdr_t   *ep = NULL;    
    int rv = BCM_E_FAIL;
    pbmp_t  tx_pbmp, tx_upbmp;
    int pktSize;

    bcm_pkt_t_init(&pkt);
    pktSize = len;
  
    BCM_PBMP_PORT_SET(tx_pbmp, port);
    BCM_PBMP_PORT_SET(tx_upbmp, port);

    /* alloc packet body */    
    pkt.alloc_ptr = (uint8 *)soc_cm_salloc(unit, pktSize, "LLDP"); 
  
    if (pkt.alloc_ptr == NULL) {        
        printk("WARNING: Could not alloc tx buffer. Memory error.\n");    
        return rv;
    } else {        
        pkt._pkt_data.data = pkt.alloc_ptr;        
        pkt.pkt_data = &pkt._pkt_data;        
        pkt.blk_count = 1;        
        pkt._pkt_data.len = pktSize;
    }
    /* packet re-init */    
    sal_memset(pkt.pkt_data[0].data, 0, pkt.pkt_data[0].len);        
    ep = (enet_hdr_t *)(pkt.pkt_data[0].data);    
  
    /* setup the packet */    
    pkt.flags &= ~BCM_TX_CRC_FLD;    
    pkt.flags |= BCM_TX_CRC_REGEN; 
    pkt.flags |= BCM_PKT_F_NO_VTAG; 
  
    /* assign pbmp */    
    sal_memcpy((uint8 *)&pkt.tx_pbmp, (uint8 *)&tx_pbmp, sizeof(bcm_pbmp_t));    
    sal_memcpy((uint8 *)&pkt.tx_upbmp, (uint8 *)&tx_upbmp, sizeof(bcm_pbmp_t));
  
    sal_memcpy(pkt.pkt_data[0].data, pkt_data, pktSize );
    if ((rv = bcm_tx(unit, &pkt, NULL)) != BCM_E_NONE) {        
        soc_cm_debug(DK_ERR, "bcm_tx failed: Unit %d: %s\n",                   
                     unit, bcm_errmsg(rv));        
        return rv;
     }
     soc_cm_sfree(unit, pkt.alloc_ptr );
     return BCM_E_NONE; 
}

/* Send VLAN response */
STATIC int
fip_tx_vlan_response(bcm_pkt_t *info)
{
    int rv = 0;
    enet_hdr_t   *ep = NULL;    
    ep = (enet_hdr_t *)(info->pkt_data[0].data);
    ENET_SET_MACADDR(FIP_VLAN_Response, ep->en_shost);
    if ((rv = fcoe_tx_pkt_helper(info->unit, info->src_port, 
                           FIP_VLAN_Response, sizeof(FIP_VLAN_Response))) !=
                           BCM_E_NONE) {
        soc_cm_debug(DK_ERR, "bcm_tx failed: Unit %d: %s\n",
                     info->unit, bcm_errmsg(rv));
        return BCM_E_FAIL;
    }
    return BCM_E_NONE; 
}


STATIC int
fip_tx_advertisement(bcm_pkt_t *info)
{
    int rv = 0;
    enet_hdr_t   *ep = NULL;    
    ep = (enet_hdr_t *)(info->pkt_data[0].data);
    ENET_SET_MACADDR(FIP_Advertisement, ep->en_shost);
    FIP_Advertisement[27] = 0x07; /* response to solicit */
    if ((rv = fcoe_tx_pkt_helper(info->unit, info->src_port, 
                           FIP_Advertisement, sizeof(FIP_Advertisement))) !=
                           BCM_E_NONE) {
        soc_cm_debug(DK_ERR, "bcm_tx failed: Unit %d: %s\n",
                     info->unit, bcm_errmsg(rv));
        return BCM_E_FAIL;
    }
    return BCM_E_NONE; 
}

#if 0
STATIC int
fip_tx_keepaliveResp(bcm_pkt_t *info)
{
    int rv = 0;
    enet_hdr_t   *ep = NULL;    
    ep = (enet_hdr_t *)(info->pkt_data[0].data);
    ENET_SET_MACADDR(FIP_Keep_Alive_Response, ep->en_shost);
    ENET_SET_MACADDR(FIP_Keep_Alive_Response+6, ep->en_dhost);
    if ((rv = fcoe_tx_pkt_helper(info->unit, info->src_port, 
                           FIP_Keep_Alive_Response, sizeof(FIP_Keep_Alive_Response))) !=
                           BCM_E_NONE) {
        soc_cm_debug(DK_ERR, "bcm_tx failed: Unit %d: %s\n",
                     info->unit, bcm_errmsg(rv));
        return BCM_E_FAIL;
    }
    return BCM_E_NONE; 
}
#endif




STATIC int 
fcoe_get_unused_fip_flogi_entry(int *entry)
{
    int i;
    for (i = 0; i < FCOE_MAX_FIP_FLOGI; i++) {
        if (fip_flogi_pending[i].used == 0) {
            break;
        }
    }
    if (i < FCOE_MAX_FIP_FLOGI) {
        *entry = i;
        return BCM_E_NONE;
    }
    return BCM_E_FAIL;
}


STATIC int 
fcoe_get_fip_flogi_entry(uint16 oxid, int *entry)
{
    int i;
    for (i = 0; i < FCOE_MAX_FIP_FLOGI; i++) {
        if ((fip_flogi_pending[i].used == 1) &&
            (oxid == fip_flogi_pending[i].oxid)) {
            break;
        }
    }
    if (i < FCOE_MAX_FIP_FLOGI) {
        *entry = i;
        return BCM_E_NONE;
    }
    return BCM_E_FAIL;
}



STATIC int
fip_handle_flogi(bcm_pkt_t *info)
{
    enet_hdr_t   *ep = NULL;    
    int rv = 0;
    int entry;

    unsigned char *fdisc_req;

    fdisc_req = sal_alloc(sizeof(FDISC_Request), "Fdisc copy");
    if (fdisc_req == NULL) {
        printk("unable to allocate memory for FDISC\n");
        return BCM_E_FAIL;
    }

    /* Update pending FIP FLOGI */
    /* Store SMAC, port on which FIP was received */
    if (fcoe_get_unused_fip_flogi_entry(&entry) != BCM_E_NONE) {
        printk("fip_handle_flogi: Failed to get unused entry \n");
        return BCM_E_FAIL;
    }
    
    ep = (enet_hdr_t *)(info->pkt_data[0].data);    
    printk("FIP FLOGI from CNA port = %d\n", info->src_port);

    /* Make a copy of FDISC */
    sal_memcpy(fdisc_req, FDISC_Request, sizeof(FDISC_Request)); 

    /* Copy the FIP FLOGI to the FDISC Request before sending */
    sal_memcpy(fdisc_req + 32, info->pkt_data[0].data + 32,   /* Where FCframe starts */
                                   info->tot_len - 32 - 16);
    FDISC_Request[56] = 0x51; /* FDISC request */
    fdisc_req[56] = 0x51;

    if (fcoe_get_unused_fip_flogi_entry(&entry) != BCM_E_NONE) {
        printk("fcoe_transmit_FLOGI: Failed to get unused entry \n");
        return BCM_E_FAIL;
    }

    ENET_SET_MACADDR(fip_flogi_pending[entry].sa, ep->en_shost);   
    fip_flogi_pending[entry].port = info->src_port;
    fip_flogi_pending[entry].oxid = *(uint16 *)(fdisc_req + 48); /* mark entry as used */
    fip_flogi_pending[entry].used = 1; /* mark entry as used */
    printk("OXID = %x\n", fip_flogi_pending[entry].oxid);

    

    /* send FDISC to FC port */
    if ((rv = fcoe_tx_pkt_helper(info->unit, fcoe_fc_port, 
                           fdisc_req, sizeof(FDISC_Request))) !=
                           BCM_E_NONE) {
        soc_cm_debug(DK_ERR, "bcm_tx failed: Unit %d: %s\n",
                     info->unit, bcm_errmsg(rv));
        sal_free(fdisc_req);
        return BCM_E_FAIL;
    }
    
    sal_free(fdisc_req);
    return BCM_E_NONE; 
}


/* Handle FIP packet */
STATIC int
fcoe_handle_fip_packet(bcm_pkt_t *info)
{
    uint16 opcode;
    opcode = FCOE_FIP_OPCODE(info);
    /* received a VLAN discovery */
    if (FCOE_FIP_OPCODE(info) == FIP_OPCODE_VLAN) {
        if (FCOE_FIP_SUBCODE(info) != FIP_SUBCODE_VLAN_REQUEST) {
            printk("Invalid FIP-VLAN Packet received \n");
        } else {
            fip_tx_vlan_response(info);
        }
    }

    /* received a Solicitation */
    if (FCOE_FIP_OPCODE(info) == FIP_OPCODE_DISCOVERY) {
        if (FCOE_FIP_SUBCODE(info) != FIP_SUBCODE_DISCOVERY_SOLICITION) {
            printk("Invalid FIP-Discovery Packet received \n");
        } else {
            fip_tx_advertisement(info);
        }
    }
#if 0
    /* received a FIP KeepAlive */
    if (FCOE_FIP_OPCODE(info) == FIP_OPCODE_KEEPALIVE) {
        if (FCOE_FIP_SUBCODE(info) != FIP_SUBCODE_KEEPALIVE_REQUEST) {
            printk("Invalid FIP-Keep Alive Packet received \n");
        } else {
            fip_tx_keepaliveResp(info);
        }
    }
#endif

    /* Received a FLOGI frame */
    if (FCOE_FIP_OPCODE(info) == FIP_OPCODE_FLOGI) {
        fip_handle_flogi(info);
    }

    return BCM_E_NONE;
}

#define FCOE_CMD_CODE(pkt) \
    ((uint8)(BCM_PKT_VLAN_PTR(pkt)[44]))

#define FCOE_FC_BB_CREDIT(pkt) \
    ((uint16) ((BCM_PKT_VLAN_PTR(pkt)[51] << 8) | (BCM_PKT_VLAN_PTR(pkt)[50])))

char fcf_nport_id[3];  /* NPV nport ID to use */
uint16 bb_credit;      /* FC credit of remote link */
int fc_nport_init = 0; /* NPV port is not initailized */

STATIC int
fip_tx_els_reply(int unit, bcm_pkt_t *info)
{
    bcm_pkt_t pkt;
    enet_hdr_t   *ep = NULL;    
    int rv = 0;
    int pktSize;
    int i, entry;
    uint16 oxid;
    int nport_id; 

    bcm_pkt_t_init(&pkt);
    pktSize = sizeof(FIP_FLOGI_Response); /* Size of the above packet */
  
    /* alloc packet body */    
    pkt.alloc_ptr = (uint8 *)soc_cm_salloc(info->unit, pktSize, "FIP_FLOGI_Response"); 
  
    if (pkt.alloc_ptr == NULL) {        
        printk("WARNING: Could not alloc tx buffer. Memory error.\n");    
    } else {        
        pkt._pkt_data.data = pkt.alloc_ptr;        
        pkt.pkt_data = &pkt._pkt_data;        
        pkt.blk_count = 1;        
        pkt._pkt_data.len = pktSize;
    }
    /* packet re-init */    
    sal_memset(pkt.pkt_data[0].data, 0, pkt.pkt_data[0].len);        
    ep = (enet_hdr_t *)(pkt.pkt_data[0].data);    
  
    /* setup the packet */    
    pkt.flags &= ~BCM_TX_CRC_FLD;    
    pkt.flags |= BCM_TX_CRC_REGEN; 
    pkt.flags |= BCM_PKT_F_NO_VTAG; 

    oxid = *(uint16 *)(info->pkt_data[0].data + 48); /* mark entry as used */
    if (fcoe_get_fip_flogi_entry(oxid, &entry) != BCM_E_NONE) {
        printk("Unknown OXID = %x\n", oxid);
        return BCM_E_FAIL;
    }
    printk("ELS reply packet : %d", fip_flogi_pending[entry].port);
    for (i = 0; i < 16; i +=2 ) {
        printk("0x%2x ", *(uint16 *)(BCM_PKT_DMAC(info) + i));
    }
    printk("\n");


    /* assign pbmp */    
    BCM_PBMP_PORT_SET(pkt.tx_pbmp, fip_flogi_pending[entry].port);
    BCM_PBMP_PORT_SET(pkt.tx_upbmp, fip_flogi_pending[entry].port);

    sal_memcpy(pkt.pkt_data[0].data, FIP_FLOGI_Response, pktSize);

    /* assign mac addr */    
    ENET_SET_MACADDR(ep->en_dhost, fip_flogi_pending[entry].sa);    
    ENET_SET_MACADDR(ep->en_shost, fcf_sa_mac);    
    /* Overwrite the response */
    /* Copy only FC frame; FIP header = 16bytes. 
     * FCoE Header = 16 Bytes, + Eth Header + VLAN = 16 bytes.
     */
    sal_memcpy(pkt.pkt_data[0].data + 32, BCM_PKT_VLAN_PTR(info) + 20, info->tot_len - 32 - 12);

    /* Construct FPMA */
    sal_memcpy(pkt.pkt_data[0].data + info->tot_len - 7, pkt.pkt_data[0].data + 33, 3);



    if ((rv = bcm_tx(info->unit, &pkt, NULL)) != BCM_E_NONE) {        
        soc_cm_debug(DK_ERR, "bcm_tx failed: Unit %d: %s\n",                   
                     info->unit, bcm_errmsg(rv));
        return rv;
    }

    /* Add route in FP */
    nport_id = 0;
    sal_memcpy(((char *)&nport_id)+1, pkt.pkt_data[0].data + 33, 3);
    fcoe_add_nport_route(unit, fip_flogi_pending[entry].port,
                               nport_id, 
                               info->src_port);

    fip_flogi_pending[entry].used = 1;
    soc_cm_sfree(info->unit, pkt.alloc_ptr);
    return BCM_E_NONE; 
}

STATIC int
fcoe_handle_flogi_response(int unit, bcm_pkt_t *info)
{
    uint16 oxid; 
    bcm_mac_t  fcf_sa_mac = {0x00,0x10,0x18,0x01,0x02,0x03};
    int entry;
    int bbc;
    bcm_fcmap_port_config_t cfg;

    /* Get OXID */
    oxid = *(uint16 *)((info->pkt_data[0].data) + 48);    
    if (fcoe_get_fip_flogi_entry(oxid, &entry) != BCM_E_NONE) {
        printk("Unknown OXID = %x\n", oxid);
        return BCM_E_FAIL;
    }
    if (ENET_CMP_MACADDR(fip_flogi_pending[entry].sa, fcf_sa_mac) == 0) {
        /* Flogi reply from FC switch to my originated FLOGI */
        /* store the nport ID to use */
        /* BB Credit of the link partner */
        if (FCOE_CMD_CODE(info) == 0x02) { /* Accept */
            sal_memcpy(fcf_nport_id, BCM_PKT_VLAN_PTR(info) + 21, 3);
            bb_credit = FCOE_FC_BB_CREDIT(info);
        } else {  /* Reject */
        }
        printk("ACC for FLOGI \n");
        fip_flogi_pending[entry].used = 0;

        /* Retrive BB Credits and program to into the device */
        bbc = *((info->pkt_data[0].data) + 63);    
        printk("BBC = %x\n", bbc);

        /* Get FC port Configuration details */
        memset(&cfg, 0, sizeof(cfg));
        if (bcm_fcmap_port_config_get(unit, info->src_port, &cfg) != BCM_E_NONE) {
            printk("Port Configuration retrive failed\n");
            return BCM_E_FAIL;
        }

        cfg.tx_buffer_to_buffer_credits = bbc;
        if (bcm_fcmap_port_config_set(unit, info->src_port, &cfg) != BCM_E_NONE) {
            printk("Port Configuration Set failed\n");
            return BCM_E_FAIL;
        }

        /* FC port Configurations */
        _print_fcmap_cfg(&cfg);

    } else {
        /* 
         * The FLOGI response is for a CNA initiated FLOGI.
         * Package the FLOGI response and send back to CNA
         */
        /* Extract only FC frame from the response */
        /* DA + SA + VLAN + FCOEHdr = 32 */
        /* FC crc + FCoE trailer + FCS  = 12 */
        /* sal_memcpy(pdata, BCM_PKT_VLAN_PTR(info) + 20, info->tot_len - 32 - * 12); */
        if (fip_tx_els_reply(unit, info) != BCM_E_NONE) {
            return BCM_E_FAIL;
        }

        /* Initialize PFC on all ports */
        if (bcm_port_control_set(0, fip_flogi_pending[0].port, 
                                 bcmPortControlPFCReceive, 1) != BCM_E_NONE)
        {  
            printk("Enabling PFC Receive failed...\n");
            return BCM_E_FAIL;
        }
        if (bcm_port_control_set(0, fip_flogi_pending[0].port, 
                                 bcmPortControlPFCTransmit, 1) != BCM_E_NONE)
        {  
            printk("Enabling PFC Transmit failed...\n");
            return BCM_E_FAIL;
        }
    }
    return BCM_E_NONE;
}


STATIC int
fcoe_handle_fcoe_packet(int unit, bcm_pkt_t *info)
{
    /* we should only receive Accept/Reject in FCoE all other are invlaid */
    if (FCOE_R_CTL(info) == 0x23) {  /* ELS reply */
        /* If DMAC is my DA then save the Nport ID */
        fcoe_handle_flogi_response(unit, info);
    } else {
        printk("Error: fcoe_handle_fcoe_packet: Received FCoE Packet which is not ELS reply...\n");
        return BCM_E_FAIL;
    }
    return BCM_E_NONE;
    

}



/* Transmit LLDP to CNA */
STATIC int 
fcoe_transmit_LLDP(bcm_pkt_t *info)
{
    int rv = 0;
    if ((rv = fcoe_tx_pkt_helper(info->unit, info->src_port, lldp, sizeof(lldp))) !=
                           BCM_E_NONE) {
        soc_cm_debug(DK_ERR, "bcm_tx failed: Unit %d: %s\n",
                     info->unit, bcm_errmsg(rv));
        return BCM_E_FAIL;
    }
    return BCM_E_NONE; 
}

STATIC int
fcoe_handle_lldp_packet(bcm_pkt_t *info)
{
    /* Transmit LLDP to CNA */
    if (fcoe_transmit_LLDP(info) != BCM_E_NONE) {
        printk("LLDP to CNA failed \n");
        return BCM_E_FAIL;
    }
    return BCM_E_NONE;
}

bcm_rx_t
fcoe_rx_callback(int unit, bcm_pkt_t *info, void *cookie)
/*
 * Function:    fcoe_rx_callback
 * Purpose:     This is the callback handler for the packets forwarded to
 *              the CMIC.
 * Parameters:
 *              unit - device code.
 *              info - received packet description structure.
 *              cookie - lw - pointer to lb work.
 * Returns:     0 - success, -1 failed.
 * Notes:
 *       Called in INTERRUPT CONTEXT
 */
{
    uint8 *pkt_data;
    uint16 eth_type = 0;

    pkt_data = BCM_PKT_DMAC(info); /* Pointer to Destination MAC */

    if (BCM_PKT_TAG_PROTOCOL(info) != 0x8100) { 
        printk("Untagged packet ...");
        /* untagged packet */
        if (BCM_PKT_TAG_PROTOCOL(info) == 0x8906) { /* FCoE Packet */
            printk("fcoe packet \n");
            fcoe_handle_fcoe_packet(unit, info);
        }
        if (BCM_PKT_TAG_PROTOCOL(info) == 0x8914) { /* FIP Packet */
            printk("FIP packet \n");
            fcoe_handle_fip_packet(info);
        }
        if (BCM_PKT_TAG_PROTOCOL(info) == 0x88cc) { /* LLDP Packet */
            printk("lldp packet \n");
            fcoe_handle_lldp_packet(info);
        }
    } else {
        eth_type = *(uint16 *)(pkt_data + 16);
        if (eth_type == 0x8906) { /* FCoE Packet */
            fcoe_handle_fcoe_packet(unit, info);
        }
        if (eth_type == 0x8914) { /* FIP Packet */
            fcoe_handle_fip_packet(info);
        }
        if (eth_type == 0x88cc) { /* LLDP Packet */
            fcoe_handle_lldp_packet(info);
        }

    }
    return BCM_RX_HANDLED;
}



/* RX Init */
STATIC int 
fcoe_rx_init(int unit)
{
    int rv = BCM_E_NONE;
    bcm_rx_cfg_t rx_cfg;

    if (BCM_RX_INIT_DONE(unit)) {
        printk("fcoe_rx_init:  RX already running (u=%d)\n", unit);
        return BCM_E_INIT;
    }

    /* Get current configuration */
    bcm_rx_cfg_init(unit);   /* Re-init in case in bad state */
    bcm_rx_cfg_get(unit, &rx_cfg);
    rx_cfg.global_pps = BCM_RX_RATE_NOLIMIT;
    rx_cfg.chan_cfg[BCM_RX_CHAN_DFLT].rate_pps = BCM_RX_RATE_NOLIMIT;
    rv = bcm_rx_start(unit, &rx_cfg);

    if (BCM_E_NONE != rv) {
        printk("fcoe_rx_init:" "rx_start failed: %s\n", bcm_errmsg(rv));
        return rv;
    }

    rv = bcm_rx_register(unit, "FCOE NPV Diag", fcoe_rx_callback,
                         BCM_RX_PRIO_MAX, (void *)&unit,
                         BCM_RCO_F_ALL_COS);
    if (BCM_E_NONE != rv) {
        printk("fcoe_rx_init:"
               "rx_register failed: %s\n", bcm_errmsg(rv));
        return rv;
    }
    return BCM_E_NONE;
}


/* Transmit FLOGI to the FC switch */
STATIC int 
fcoe_transmit_FLOGI(int unit, int port)
{
    int rv = 0;
    int entry;

    if (fcoe_get_unused_fip_flogi_entry(&entry) != BCM_E_NONE) {
        printk("fcoe_transmit_FLOGI: Failed to get unused entry \n");
        return BCM_E_FAIL;
    }

    ENET_SET_MACADDR(fip_flogi_pending[entry].sa, fcf_sa_mac);   
    fip_flogi_pending[entry].port = port;
    fip_flogi_pending[entry].oxid = *(uint16 *)(FLOGI_Request + 48); /* mark entry as used */
    fip_flogi_pending[entry].used = 1; /* mark entry as used */

    printk("OXID = %x\n", fip_flogi_pending[entry].oxid);
    if ((rv = fcoe_tx_pkt_helper(unit, port, 
                           FLOGI_Request, sizeof(FLOGI_Request))) !=
                           BCM_E_NONE) {
        soc_cm_debug(DK_ERR, "Couldn't send FLOGI Unit %d: %s\n",                   
                     unit, bcm_errmsg(rv));
        return rv;
    }
    return BCM_E_NONE; 
}




STATIC int 
fcoe_add_donot_learn_fcoe(int unit, int port)
{
    bcm_field_qset_t qset;
    bcm_field_group_t group;
    bcm_field_entry_t entry;
    bcm_field_stat_t stat_entry = bcmFieldStatPackets;
    int stat_id;

    /* qset */
    BCM_FIELD_QSET_INIT(qset);
    BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyStageLookup);
    BCM_FIELD_QSET_ADD(qset, bcmFieldQualifyEtherType);

    /* group create */
    BCM_IF_ERROR_RETURN(
        bcm_field_group_create(unit, qset, BCM_FIELD_GROUP_PRIO_ANY, &group));

    /* EtherType == 0x8914 */
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_create(unit, group, &entry));
    BCM_IF_ERROR_RETURN(
        bcm_field_qualify_EtherType(0, entry, 0x8914, 0xffff));
    BCM_IF_ERROR_RETURN(
        bcm_field_action_add(unit, entry, bcmFieldActionDoNotLearn, 0,0)); 
    BCM_IF_ERROR_RETURN(
        bcm_field_action_add(unit, entry, bcmFieldActionCopyToCpu, 0,0)); 
    BCM_IF_ERROR_RETURN(
        bcm_field_stat_create(0, group, 1, &stat_entry, &stat_id));
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_stat_attach(0, entry, stat_id));
    printk("EID:%d STATID:%d\n", entry, stat_id);
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_install(unit, entry));

    /* EtherType == 0x8906 */
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_create(unit, group, &entry));
    BCM_IF_ERROR_RETURN(
        bcm_field_qualify_EtherType(0, entry, 0x8906, 0xffff));
    BCM_IF_ERROR_RETURN(
        bcm_field_action_add(unit, entry, bcmFieldActionDoNotLearn, 0,0)); 
    BCM_IF_ERROR_RETURN(
        bcm_field_stat_create(0, group, 1, &stat_entry, &stat_id));
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_stat_attach(0, entry, stat_id));
    printk("EID:%d STATID:%d\n", entry, stat_id);

    BCM_IF_ERROR_RETURN(
        bcm_field_entry_install(unit, entry));
    return BCM_E_NONE;
}

STATIC int
fcoe_fabric_trans(int unit, int port)
{
    int qual_id;
    bcm_field_qset_t qset;                                                                                               
    bcm_field_group_t group;                                                                                             
    bcm_field_entry_t entry;                                                                                             
    bcm_field_action_t action;                                                                                           
    bcm_field_data_qualifier_t data_qualifier;                                                                           
    bcm_field_data_packet_format_t packet_format;                                                                        
    uint8 data[3] = {0xff, 0xff, 0xfe};
    uint8 mask[3] = {0xff, 0xff, 0xff};                                                                                  
    int length = sizeof(data);                                                                                           
    bcm_field_stat_t stat_entry = bcmFieldStatPackets;
    int stat_id;

    action = bcmFieldActionCopyToCpu;
    BCM_FIELD_QSET_INIT(qset);                                                                                           

    bcm_field_data_qualifier_t_init(&data_qualifier);

    data_qualifier.offset_base = bcmFieldDataOffsetBaseFcoeHeader;
    data_qualifier.offset = 19;
    data_qualifier.length = 3;                                                                                           

    BCM_IF_ERROR_RETURN(
        bcm_field_data_qualifier_create(unit, &data_qualifier));                                                        
    qual_id = data_qualifier.qual_id;                                                                                    

   
    bcm_field_data_packet_format_t_init(&packet_format);                                                                 

    packet_format.relative_offset = 0;                                                                                   
    packet_format.l2 = BCM_FIELD_DATA_FORMAT_L2_ETH_II;                                                                  
    packet_format.vlan_tag = BCM_FIELD_DATA_FORMAT_VLAN_SINGLE_TAGGED;                                                   
    packet_format.tunnel = BCM_FIELD_DATA_FORMAT_TUNNEL_NONE;
    packet_format.fibre_chan_outer = BCM_FIELD_DATA_FORMAT_FIBRE_CHAN;

    BCM_IF_ERROR_RETURN(
        bcm_field_data_qualifier_packet_format_add(unit, qual_id, &packet_format));                                     

    BCM_IF_ERROR_RETURN(
        bcm_field_qset_data_qualifier_add(unit, &qset, qual_id));                                                        
    BCM_IF_ERROR_RETURN(
        bcm_field_group_create(unit, qset, 1, &group));                                                                 
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_create(unit, group, &entry));                                                                   
    BCM_IF_ERROR_RETURN(
        bcm_field_qualify_data(unit, entry, qual_id, data, mask, length));                                            
    BCM_IF_ERROR_RETURN(
        bcm_field_action_add(unit, entry, action, 0, 0));                                                             

    action = bcmFieldActionDrop;
    BCM_IF_ERROR_RETURN(
        bcm_field_action_add(unit, entry, action, 0, 0));                                                             
    BCM_IF_ERROR_RETURN(
        bcm_field_stat_create(0, group, 1, &stat_entry, &stat_id));
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_stat_attach(0, entry, stat_id));
    printk("EID:%d STATID:%d\n", entry, stat_id);
    BCM_IF_ERROR_RETURN(
        bcm_field_entry_install(unit, entry));                                                                          

    return BCM_E_NONE;
}



#define PRINT_MAC(addr) \
do {  \
   int i; \
   for (i = 0; i < 6; i++) { \
       printk("%x ", addr[i]); \
   } \
   printk("\n"); \
}while(0)

STATIC void 
_print_fcmap_cfg(bcm_fcmap_port_config_t *cfg) 
{
    if (cfg != NULL) {
        printk("Port configuration\n");
        printk("------------------\n");
        printk("Port Mode => %d\n", cfg->port_mode);
        printk("Port Speed => %d\n", cfg->speed);
        printk("TX BBC     => %d\n", cfg->tx_buffer_to_buffer_credits);
        printk("RX BBC     => %d\n", cfg->rx_buffer_to_buffer_credits);
        printk("E_D_TOV    => %d\n", cfg->e_d_tov);
        printk("R_T_TOV    => %d\n", cfg->r_t_tov);
        printk("SRC MAC    => "); PRINT_MAC(cfg->src_mac_addr);
        printk("DST MAC    => "); PRINT_MAC(cfg->dst_mac_addr);
        printk("VLAN Tag   => %x\n", cfg->vlan_tag);
        printk("SRC FPMA Prefix => %x\n", cfg->src_fcmap_prefix);
        printk("DST FPMA Prefix => %x\n", cfg->dst_fcmap_prefix);

        printk("Mapper Bypass => %d\n", cfg->mapper_bypass);
        printk("Mapper Length => %d\n", cfg->mapper_len);
        printk("FC Mapper Mode => %d\n", cfg->fc_mapper_mode);
        printk("FC Mapper Dir => %d\n", cfg->mapper_direction);
        printk("FC Mapper Table Input => %d\n", cfg->map_table_input);
        printk("FC CRC Mode => %d\n", cfg->fc_crc_mode);
        printk("VFT Hdr Processing mode => %d\n", cfg->vfthdr_proc_mode);
        printk("VLAN TAG Processing mode => %d\n", cfg->vlantag_proc_mode);
        printk("SRC MAC Construct Mode => %d\n", cfg->src_mac_construct);
        printk("DST MAC Construct Mode => %d\n", cfg->dst_mac_construct);
    }
}

STATIC void
fcoe_fip_thread(void *cookie)
{
    int i, rv;
    bcm_mac_t  fcf_all = {0x01,0x10,0x18,0x01,0x00,0x01}; 
    printk("Thread started to send advertisements \n");
    /* Send FIP Discovery Advertisement to all VN_ports */
    while (1) {
        sal_sleep(5);
        /* Loop through all the VN ports */
        for (i = 0; i < FCOE_MAX_FIP_FLOGI; i++) {
            if (fip_flogi_pending[i].used == 0) {
                continue;
            }
            ENET_SET_MACADDR(FIP_Advertisement, fcf_all);
            FIP_Advertisement[27] = 0x05; /* Plain Advertisement */
            /* printk("sending advertisements to port %d\n", * fip_flogi_pending[i].port); */
            if ((rv = fcoe_tx_pkt_helper(0, fip_flogi_pending[i].port, 
                                   FIP_Advertisement, sizeof(FIP_Advertisement))) !=
                                   BCM_E_NONE) {
                soc_cm_debug(DK_ERR, "Periodic DISC bcm_tx failed: port %d: %s\n",
                             fip_flogi_pending[i].port, bcm_errmsg(rv));
            }
        }
    }
}

int fcoe_start(int unit, int fc_port)
{

    bcm_fcmap_port_config_t cfg;
    fcoe_fc_port = fc_port;

    /* Start thread to send advertisements */
    fcoe_thread_id = sal_thread_create("bcmFCOE", SAL_THREAD_STKSZ,
				     100,
				     fcoe_fip_thread, NULL);
    if (fcoe_thread_id == SAL_THREAD_ERROR) {
        printk("Thread create failed \n");
        return BCM_E_RESOURCE;
    }
    /* Don't learn L2 address for FIP and FCoE frames */
    /* Initialize switch to route FIP frames to CPU */
    printk("Adding Do Not Learn L2 for FIP and FCoE Frames\n");
    if (fcoe_add_donot_learn_fcoe(unit, fc_port) != BCM_E_NONE) {
        printk("Failed to add donot learn rules\n");
        return BCM_E_FAIL;
    }

    /*  All FCoE transactions from 0xFFFFFE go to cpu */
    printk("Transactions to Fabric Controller handled by CPU\n");
    if (fcoe_fabric_trans(unit, fc_port) != BCM_E_NONE) {
        printk("Failed to add fabric transactions rules....\n");
        return BCM_E_FAIL;
    }

    /* Create VLAN on which FCOE/FIP traffic for a given FC port */
    /* Get FC port Configuration details */
    memset(&cfg, 0, sizeof(cfg));
    if (bcm_fcmap_port_config_get(unit, fc_port, &cfg) != BCM_E_NONE) {
        printk("Port Configuration retrive failed\n");
        return BCM_E_FAIL;
    }

    /* FC port Configurations */
    _print_fcmap_cfg(&cfg);

    cfg.port_mode = BCM_FCMAP_FCOE_TO_FC_MODE;
    cfg.fc_crc_mode = 1;
    cfg.src_fcmap_prefix = 0x00fc00;
    cfg.dst_fcmap_prefix = 0x00fc00;
    cfg.vlan_tag = 0x81006004;
    ENET_SET_MACADDR(cfg.src_mac_addr, fcf_sa_mac);
    cfg.src_mac_construct = BCM_FCMAP_ENCAP_FCOE_ETH_ADDRESS_USER;
    cfg.dst_mac_construct = BCM_FCMAP_ENCAP_FCOE_FPMA;
    if (bcm_fcmap_port_config_set(unit, fc_port, &cfg) != BCM_E_NONE) {
        printk("Port Configuration Set failed\n");
        return BCM_E_FAIL;
    }

    /* Initialize RX (FIP and FCoE packets rx)*/
    printk("fcoe: Initializing RX ...");
    if (fcoe_rx_init(unit) != BCM_E_NONE) {
        /* goto clean_up; */
        printk("fcoe: Failed \n");
    } else {
        printk("Done\n");
    }


    printk("fcoe: FLogi to FC Switch ...");
    /* Transmit FLOGI to FC switch */
    if (fcoe_transmit_FLOGI(unit, fc_port) != BCM_E_NONE) {
        printk("FLOGI to Switch failed \n");
        return BCM_E_FAIL;
    }
    printk("Done\n");

    return BCM_E_NONE;
}


/*
 * Function: 	if_fcoe
 * Purpose:	Start or stop fcoe NPV
 * Parameters:	u - SOC unit #
 *		a - pointer to args
 * Returns:	CMD_OK/CMD_FAIL/
 */
cmd_result_t
if_esw_fcoe(int u, args_t *a)
{
    soc_pbmp_t pbm ;
    soc_port_t p, dport;
    char *c;

    if (!sh_check_attached(ARG_CMD(a), u)) {
        return CMD_FAIL;
    }

    c = ARG_GET(a);
    if (c != NULL && sal_strcasecmp(c, "start") == 0) {
        if (((c = ARG_GET(a)) == NULL) || (parse_bcm_pbmp(u, c, &pbm) < 0)) {
            printk("%s: ERROR: unrecognized port bitmap: %s\n", ARG_CMD(a), c);
            return CMD_FAIL;
        }

        if ((c = ARG_CUR(a)) != NULL) {
            printk("Extra arguments ignored\n");
        }
        DPORT_SOC_PBMP_ITER(u, pbm, dport, p) {
           if (fcoe_start(u, p) != BCM_E_NONE) {
               printk("FCoE NPV start failed\n");
               return CMD_FAIL;
           } else {
               printk("FCoE NPV Started\n");
           }
        }
    }
    if (c != NULL && sal_strcasecmp(c, "stop") == 0) {
        /* fcoe_stop(unit) */
    }
    return CMD_OK;
}
#endif /*INCLUDE_FCMAP */
