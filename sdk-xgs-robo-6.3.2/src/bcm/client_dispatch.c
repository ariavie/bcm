/*
 * $Id: client_dispatch.c 1.455 Broadcom SDK $
 * 
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

int _bcm_client_dispatch_not_empty;

#include <bcm_int/control.h>
#include <bcm_int/api_xlate_port.h>
#include <bcm/error.h>
#include <bcm/debug.h>
#include <bcm/ces.h>
#include <bcm/custom.h>
#include <bcm/field.h>
#include <bcm/ipfix.h>
#include <bcm/knet.h>
#include <bcm/l2.h>
#include <bcm/link.h>
#include <bcm/port.h>
#include <bcm/rx.h>
#include <bcm/stack.h>
#include <bcm/stg.h>
#include <bcm/switch.h>
#include <bcm/time.h>
#include <bcm/tx.h>
#include <bcm/txbeacon.h>
#include <bcm/vlan.h>
#include <bcm_int/client_dispatch.h>
#if defined(INCLUDE_FCMAP)
#include <bcm/fcmap.h>
#endif
#if defined(INCLUDE_I2C)
#include <bcm/bcmi2c.h>
#endif
#if defined(INCLUDE_L3)
#include <bcm/ipmc.h>
#include <bcm/l3.h>
#include <bcm/nat.h>
#endif
#if defined(INCLUDE_MACSEC)
#include <bcm/macsec.h>
#endif
#if defined(INCLUDE_PTP)
#include <bcm/ptp.h>
#endif
#if defined(INCLUDE_REGEX)
#include <bcm/bregex.h>
#endif

#if defined(INCLUDE_CES)
int 
bcm_client_ces_cb_register(
    int unit, 
    bcm_ces_event_types_t events, 
    bcm_ces_event_cb callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_CES)
int 
bcm_client_ces_cb_unregister(
    int unit, 
    bcm_ces_event_types_t events, 
    bcm_ces_event_cb callback)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_custom_register(
    int unit, 
    bcm_custom_cb_t func, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_custom_unregister(
    int unit)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_event_enable_get(
    int unit, 
    bcm_fcmap_event_t t, 
    int *enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_event_enable_set(
    int unit, 
    bcm_fcmap_event_t t, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_event_register(
    int unit, 
    bcm_fcmap_event_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_event_unregister(
    int unit, 
    bcm_fcmap_event_cb cb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_config_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_config_t *cfg)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_config_set(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_config_t *cfg)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_enable(
    int unit, 
    bcm_port_t port)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_link_reset(
    int unit, 
    bcm_port_t port)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_shutdown(
    int unit, 
    bcm_port_t port)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_speed_set(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_speed_t speed)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_traverse(
    int unit, 
    bcm_fcmap_port_traverse_cb callbk, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_stat_clear(
    int unit, 
    bcm_port_t port)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_stat_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_stat_t stat, 
    uint64 *val)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_stat_get32(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_stat_t stat, 
    uint32 *val)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_vlan_map_add(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_vlan_vsan_map_t *vlan)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_vlan_map_delete(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_vlan_vsan_map_t *vlan)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_vlan_map_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_vlan_vsan_map_t *vlan)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(BROADCOM_DEBUG)
int 
bcm_client_field_entry_dump(
    int unit, 
    bcm_field_entry_t entry)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(BROADCOM_DEBUG)
int 
bcm_client_field_group_dump(
    int unit, 
    bcm_field_group_t group)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(BROADCOM_DEBUG)
int 
bcm_client_field_show(
    int unit, 
    const char *pfx)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_I2C)
int 
bcm_client_i2c_ioctl(
    int unit, 
    int fd, 
    int opcode, 
    void *data, 
    int len)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_I2C)
int 
bcm_client_i2c_open(
    int unit, 
    char *devname, 
    uint32 flags, 
    int speed)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_I2C)
int 
bcm_client_i2c_read(
    int unit, 
    int fd, 
    uint32 addr, 
    uint8 *data, 
    uint32 *nbytes)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_I2C)
int 
bcm_client_i2c_write(
    int unit, 
    int fd, 
    uint32 addr, 
    uint8 *data, 
    uint32 nbytes)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_ipfix_register(
    int unit, 
    bcm_ipfix_callback_t callback, 
    void *userdata)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_ipfix_unregister(
    int unit, 
    bcm_ipfix_callback_t callback, 
    void *userdata)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_L3)
int 
bcm_client_ipmc_age(
    int unit, 
    uint32 flags, 
    bcm_ipmc_traverse_cb age_cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_knet_cleanup(
    int unit)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_filter_create(
    int unit, 
    bcm_knet_filter_t *filter)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_filter_destroy(
    int unit, 
    int filter_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_filter_get(
    int unit, 
    int filter_id, 
    bcm_knet_filter_t *filter)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_filter_traverse(
    int unit, 
    bcm_knet_filter_traverse_cb trav_fn, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_init(
    int unit)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_netif_create(
    int unit, 
    bcm_knet_netif_t *netif)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_netif_destroy(
    int unit, 
    int netif_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_netif_get(
    int unit, 
    int netif_id, 
    bcm_knet_netif_t *netif)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_netif_traverse(
    int unit, 
    bcm_knet_netif_traverse_cb trav_fn, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_l2_key_dump(
    int unit, 
    char *pfx, 
    bcm_l2_addr_t *entry, 
    char *sfx)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_L3)
int 
bcm_client_l3_host_age(
    int unit, 
    uint32 flags, 
    bcm_l3_host_traverse_cb age_cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_L3)
int 
bcm_client_l3_nat_ingress_age(
    int unit, 
    uint32 flags, 
    bcm_l3_nat_ingress_traverse_cb age_cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_L3)
int 
bcm_client_l3_route_age(
    int unit, 
    uint32 flags, 
    bcm_l3_route_traverse_cb age_out, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_linkscan_port_register(
    int unit, 
    bcm_port_t port, 
    bcm_linkscan_port_handler_t f)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_linkscan_port_unregister(
    int unit, 
    bcm_port_t port, 
    bcm_linkscan_port_handler_t f)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_event_enable_get(
    int unit, 
    bcm_macsec_event_t t, 
    int *enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_event_enable_set(
    int unit, 
    bcm_macsec_event_t t, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_event_register(
    int unit, 
    bcm_macsec_event_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_event_unregister(
    int unit, 
    bcm_macsec_event_cb cb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_flow_create(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_macsec_flow_match_t *flow, 
    bcm_macsec_flow_action_t *action, 
    int *flowId)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_flow_destroy(
    int unit, 
    bcm_port_t port, 
    int flowId)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_flow_get(
    int unit, 
    bcm_port_t port, 
    int flowId, 
    bcm_macsec_flow_match_t *flow, 
    bcm_macsec_flow_action_t *a)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_flow_traverse(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_flow_traverse_cb callbk, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_port_capability_get(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_port_capability_t *cap)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_port_config_get(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_port_config_t *cfg)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_port_config_set(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_port_config_t *cfg)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_port_traverse(
    int unit, 
    bcm_macsec_port_traverse_cb callbk, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_assoc_create(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int chanId, 
    bcm_macsec_secure_assoc_t *assoc, 
    int *assocId)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_assoc_destroy(
    int unit, 
    bcm_port_t port, 
    int assocId)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_assoc_get(
    int unit, 
    bcm_port_t port, 
    int assocId, 
    bcm_macsec_secure_assoc_t *assoc, 
    int *chanId)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_assoc_traverse(
    int unit, 
    bcm_port_t port, 
    int chanId, 
    bcm_macsec_secure_assoc_traverse_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_chan_create(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_macsec_secure_chan_t *chan, 
    int *chanId)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_chan_destroy(
    int unit, 
    bcm_port_t port, 
    int chanId)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_chan_get(
    int unit, 
    bcm_port_t port, 
    int chanId, 
    bcm_macsec_secure_chan_t *chan)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_chan_traverse(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_chan_traverse_cb calback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_stat_clear(
    int unit, 
    bcm_port_t port)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_stat_get(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint64 *val)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_stat_get32(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint32 *val)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_stat_set(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint64 val)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_stat_set32(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint32 val)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_port_medium_status_register(
    int unit, 
    bcm_port_t port, 
    bcm_port_medium_status_cb_t callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_port_medium_status_unregister(
    int unit, 
    bcm_port_t port, 
    bcm_port_medium_status_cb_t callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_port_phy_drv_name_get(
    int unit, 
    bcm_port_t port, 
    char *name, 
    int len)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_port_phy_reset_register(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_reset_cb_t callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_port_phy_reset_unregister(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_reset_cb_t callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_acceptable_master_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int priority1_alt_value, 
    bcm_ptp_clock_peer_address_t *master_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_acceptable_master_enabled_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint8 *enabled)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_acceptable_master_enabled_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint8 enabled)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_acceptable_master_list(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_masters, 
    int *num_masters, 
    bcm_ptp_clock_peer_address_t *master_addr)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_acceptable_master_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_address_t *master_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_acceptable_master_table_clear(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_acceptable_master_table_size_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int *max_table_entries)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_cb_register(
    int unit, 
    bcm_ptp_cb_types_t cb_types, 
    bcm_ptp_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_cb_unregister(
    int unit, 
    bcm_ptp_cb_types_t cb_types, 
    bcm_ptp_cb cb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_accuracy_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_accuracy_t *accuracy)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_accuracy_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_accuracy_t *accuracy)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_create(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    bcm_ptp_clock_info_t *clock_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_current_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_current_dataset_t *dataset)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_default_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_default_dataset_t *dataset)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_domain_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *domain)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_domain_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 domain)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_info_t *clock_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_parent_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_parent_dataset_t *dataset)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_announce_receipt_timeout_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 *timeout)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_announce_receipt_timeout_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 timeout)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_configure(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_clock_port_info_t *info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_port_dataset_t *dataset)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_delay_mechanism_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 *delay_mechanism)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_delay_mechanism_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 delay_mechanism)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_disable(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_enable(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_identity_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_port_identity_t *identity)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_info_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_clock_port_info_t *info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_latency_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 latency_in, 
    uint32 latency_out)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_announce_interval_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_announce_interval_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_min_delay_req_interval_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_min_delay_req_interval_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_min_pdelay_req_interval_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_min_pdelay_req_interval_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_sync_interval_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_sync_interval_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_mac_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_mac_t *mac)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_protocol_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_protocol_t *protocol)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_type_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_port_type_t *type)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_version_number_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 *version)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_priority1_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *priority1)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_priority1_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 priority1)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_priority2_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *priority2)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_priority2_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 priority2)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_slaveonly_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *slaveonly)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_slaveonly_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 slaveonly)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_time_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timestamp_t *time)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_time_properties_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_time_properties_t *data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_time_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timestamp_t *time)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_timescale_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timescale_t *timescale)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_timescale_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timescale_t *timescale)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_traceability_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_trace_t *trace)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_traceability_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_trace_t *trace)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_user_description_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 *desc)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_utc_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_utc_t *utc)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_utc_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_utc_t *utc)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_alarm_callback_register(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_ctdev_alarm_cb alarm_cb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_alarm_callback_unregister(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_alpha_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 *alpha_numerator, 
    uint16 *alpha_denominator)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_alpha_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 alpha_numerator, 
    uint16 alpha_denominator)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_enable_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *enable, 
    uint32 *flags)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_enable_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int enable, 
    uint32 flags)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_verbose_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *verbose)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_verbose_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int verbose)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_foreign_master_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_foreign_master_dataset_t *data_set)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_input_channel_precedence_mode_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int channel_select_mode)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_input_channel_switching_mode_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int channel_switching_mode)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_input_channels_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *num_channels, 
    bcm_ptp_channel_t *channels)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_input_channels_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int num_channels, 
    bcm_ptp_channel_t *channels)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_enable_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *enable, 
    uint32 *flags)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_enable_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int enable, 
    uint32 flags)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_phyts_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *phyts, 
    int *framesync_pin)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_phyts_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int phyts, 
    int framesync_pin)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_portbitmap_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_pbmp_t *pbmp)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_portbitmap_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_pbmp_t pbmp)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_verbose_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *verbose)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_verbose_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int verbose)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_packet_counters_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_packet_counters_t *counters)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_peer_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_peers, 
    bcm_ptp_peer_entry_t *peers, 
    int *num_peers)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_primary_domain_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *primary_domain)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_primary_domain_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int primary_domain)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_servo_configuration_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_servo_config_t *config)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_servo_configuration_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_servo_config_t *config)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_servo_status_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_servo_status_t *status)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signal_output_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *signal_output_count, 
    bcm_ptp_signal_output_t *signal_output_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signal_output_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int signal_output_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signal_output_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *signal_output_id, 
    bcm_ptp_signal_output_t *output_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signaled_unicast_master_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_unicast_master_t *master_info, 
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signaled_unicast_master_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_address_t *master_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signaled_unicast_slave_list(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_slaves, 
    int *num_slaves, 
    bcm_ptp_clock_peer_t *slave_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signaled_unicast_slave_table_clear(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int callstack)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_stack_create(
    int unit, 
    bcm_ptp_stack_info_t *ptp_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_master_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_unicast_master_t *master_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_master_list(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_masters, 
    int *num_masters, 
    bcm_ptp_clock_peer_address_t *master_addr)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_master_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_address_t *master_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_master_table_clear(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_master_table_size_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int *max_table_entries)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_slave_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_t *slave_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_slave_list(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_slaves, 
    int *num_slaves, 
    bcm_ptp_clock_peer_t *slave_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_slave_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_t *slave_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_slave_table_clear(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_sync_phy(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_sync_phy_input_t sync_input)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_init(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_network_option_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_network_option_t *network_option)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_network_option_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_network_option_t network_option)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_port_address_t *address)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_best_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_pktmaster_t *pktmaster)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_port_address_t *address, 
    bcm_ptp_telecom_g8265_pktmaster_t *pktmaster)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_list(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int max_master_count, 
    int *num_masters, 
    int *best_master, 
    bcm_ptp_telecom_g8265_pktmaster_t *pktmaster)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_lockout_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 lockout, 
    bcm_ptp_clock_port_address_t *address)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_non_reversion_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 nonres, 
    bcm_ptp_clock_port_address_t *address)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_priority_override(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 override, 
    bcm_ptp_clock_port_address_t *address)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_priority_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 priority, 
    bcm_ptp_clock_port_address_t *address)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_port_address_t *address)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_wait_duration_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint64 wait_sec, 
    bcm_ptp_clock_port_address_t *address)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_pktstats_thresholds_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_pktstats_t *thresholds)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_pktstats_thresholds_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_pktstats_t thresholds)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_quality_level_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_quality_level_t ql)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_receipt_timeout_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_message_type_t message_type, 
    uint32 *receipt_timeout)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_receipt_timeout_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_message_type_t message_type, 
    uint32 receipt_timeout)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_shutdown(
    int unit)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_time_format_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    bcm_ptp_time_type_t type)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_timesource_input_status_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timesource_status_t *status)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_tod_input_sources_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *num_tod_sources, 
    bcm_ptp_tod_input_t *tod_sources)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_tod_input_sources_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int num_tod_sources, 
    bcm_ptp_tod_input_t *tod_sources)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_tod_output_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *tod_output_count, 
    bcm_ptp_tod_output_t *tod_output)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_tod_output_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int tod_output_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_tod_output_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *tod_output_id, 
    bcm_ptp_tod_output_t *output_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_transparent_clock_default_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_transparent_clock_default_dataset_t *data_set)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_transparent_clock_port_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 clock_port, 
    bcm_ptp_transparent_clock_port_dataset_t *data_set)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_config_get(
    int unit, 
    bcm_regex_config_t *config)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_config_set(
    int unit, 
    bcm_regex_config_t *config)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_engine_create(
    int unit, 
    bcm_regex_engine_config_t *config, 
    bcm_regex_engine_t *engid)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_engine_destroy(
    int unit, 
    bcm_regex_engine_t engid)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_engine_get(
    int unit, 
    bcm_regex_engine_t engid, 
    bcm_regex_engine_config_t *config)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_engine_traverse(
    int unit, 
    bcm_regex_engine_traverse_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_exclude_add(
    int unit, 
    uint8 protocol, 
    uint16 l4_start, 
    uint16 l4_end)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_exclude_delete(
    int unit, 
    uint8 protocol, 
    uint16 l4_start, 
    uint16 l4_end)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_exclude_delete_all(
    int unit)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_exclude_get(
    int unit, 
    int array_size, 
    uint8 *protocol, 
    uint16 *l4low, 
    uint16 *l4high, 
    int *array_count)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_init(
    int unit)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_match_check(
    int unit, 
    bcm_regex_match_t *matches, 
    int count, 
    int *metric)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_match_set(
    int unit, 
    bcm_regex_engine_t engid, 
    bcm_regex_match_t *matches, 
    int count)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_report_register(
    int unit, 
    uint32 reports, 
    bcm_regex_report_cb callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_report_unregister(
    int unit, 
    uint32 reports, 
    bcm_regex_report_cb callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(BROADCOM_DEBUG)
int 
bcm_client_rx_show(
    int unit)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_stg_list(
    int unit, 
    bcm_stg_t **list, 
    int *count)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stg_list_destroy(
    int unit, 
    bcm_stg_t *list, 
    int count)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stg_vlan_list(
    int unit, 
    bcm_stg_t stg, 
    bcm_vlan_t **list, 
    int *count)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stg_vlan_list_destroy(
    int unit, 
    bcm_vlan_t *list, 
    int count)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_modmap_register(
    int unit, 
    bcm_stk_modmap_cb_t func)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_modmap_unregister(
    int unit)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_port_get(
    int unit, 
    bcm_port_t port, 
    uint32 *flags)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_port_modmap_group_get(
    int unit, 
    bcm_port_t port, 
    int *group)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_port_modmap_group_max_get(
    int unit, 
    int *max_group)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_port_modmap_group_set(
    int unit, 
    bcm_port_t port, 
    int group)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_port_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_update_callback_register(
    int unit, 
    bcm_stk_cb_f cb, 
    void *cookie)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_update_callback_unregister(
    int unit, 
    bcm_stk_cb_f cb, 
    void *cookie)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_event_register(
    int unit, 
    bcm_switch_event_cb_t cb, 
    void *userdata)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_event_unregister(
    int unit, 
    bcm_switch_event_cb_t cb, 
    void *userdata)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_hash_banks_config_get(
    int unit, 
    bcm_switch_hash_table_t hash_table, 
    uint32 bank_num, 
    int *hash_type, 
    uint32 *hash_offset)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_hash_banks_config_set(
    int unit, 
    bcm_switch_hash_table_t hash_table, 
    uint32 bank_num, 
    int hash_type, 
    uint32 hash_offset)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_hash_banks_max_get(
    int unit, 
    bcm_switch_hash_table_t hash_table, 
    uint32 *bank_count)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_stable_register(
    int unit, 
    bcm_switch_read_func_t rf, 
    bcm_switch_write_func_t wf)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_temperature_monitor_get(
    int unit, 
    int temperature_max, 
    bcm_switch_temperature_monitor_t *temperature_array, 
    int *temperature_count)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_time_heartbeat_register(
    int unit, 
    bcm_time_if_t id, 
    bcm_time_heartbeat_cb f, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

#if defined(BROADCOM_DEBUG)
int 
bcm_client_tx_dv_dump(
    int unit, 
    void *dv_p)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_tx_pkt_l2_map(
    int unit, 
    bcm_pkt_t *pkt, 
    bcm_mac_t dest_mac, 
    int vid)
{
    return BCM_E_UNAVAIL;
}

#if defined(BROADCOM_DEBUG)
int 
bcm_client_tx_show(
    int unit)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_txbeacon_destroy(
    int unit, 
    bcm_txbeacon_pkt_id_t pkt_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_txbeacon_init(
    int unit, 
    int uC)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_txbeacon_pkt_get(
    int unit, 
    bcm_txbeacon_t *txbeacon)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_txbeacon_pkt_setup(
    int unit, 
    bcm_txbeacon_t *txbeacon)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_txbeacon_start(
    int unit, 
    bcm_txbeacon_pkt_id_t pkt_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_txbeacon_stop(
    int unit, 
    bcm_txbeacon_pkt_id_t pkt_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_txbeacon_traverse(
    int unit, 
    bcm_txbeacon_traverse_cb_t trav_fn, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_vlan_list(
    int unit, 
    bcm_vlan_data_t **listp, 
    int *countp)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_vlan_list_by_pbmp(
    int unit, 
    bcm_pbmp_t ports, 
    bcm_vlan_data_t **listp, 
    int *countp)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_vlan_list_destroy(
    int unit, 
    bcm_vlan_data_t *list, 
    int count)
{
    return BCM_E_UNAVAIL;
}

