/*******************************************************************************
 *
 * $Id: bfcmap84756_a0.h 1.6 Broadcom SDK $
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * Definition file for the bcm84756_a0.
 * This file provides all basic definitions required to program the bcm84756_a0.
 *
 * This file is autogenerated. Please do not edit.
 *
 ******************************************************************************/
#ifndef __bcm84756_a0_DEFS_H__
#define __bcm84756_a0_DEFS_H__

#include <bbase_types.h>
#include <bfcmap.h>

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 *
 ******************************************************************************/



#define BCM84756_A0_BLK_SECPORT       0x00000001
#define BCM84756_A0_BLK_MFP       0x00000002


#define BCM84756_A0_NUM_REG      154

#define BCM84756_A0_NUM_MEM      0

/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_BAD_TX_CHAR_COUNT
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Bad TX Char Counter Register.
 *
 * SIZE:     32
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_BAD_TX_CHAR_COUNTr(c) \
		(0x13100060 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_BAD_TX_CHAR_COUNTr_SIZE 1

/*
 * This structure should be used to declare and program FCM_BAD_TX_CHAR_COUNT.
 *
 */
typedef union bcm84756_a0_FCM_BAD_TX_CHAR_COUNTr_s {
	buint32_t v[1];
	buint32_t fcm_bad_tx_char_count[1];
	buint32_t _fcm_bad_tx_char_count;
} bcm84756_a0_FCM_BAD_TX_CHAR_COUNTr_t;

#define bcm84756_a0_FCM_BAD_TX_CHAR_COUNTr_CLR(r)   \
            (r).fcm_bad_tx_char_count[0] = 0

#define bcm84756_a0_FCM_BAD_TX_CHAR_COUNTr_SET(r,d) \
            (r).fcm_bad_tx_char_count[0] = d

#define bcm84756_a0_FCM_BAD_TX_CHAR_COUNTr_GET(r)   \
            (r).fcm_bad_tx_char_count[0]



/*
 * These macros can be used to access FCM_BAD_TX_CHAR_COUNT.
 *
 */
#define bcm84756_a0_READ_FCM_BAD_TX_CHAR_COUNTr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_BAD_TX_CHAR_COUNTr((c)),&((r)._fcm_bad_tx_char_count))

#define bcm84756_a0_WRITE_FCM_BAD_TX_CHAR_COUNTr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_BAD_TX_CHAR_COUNTr((c)),&((r)._fcm_bad_tx_char_count))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_BAD_TX_CHAR_COUNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_DEFAULT_CNTAG_ET
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Default CN-Tag Ethertype value.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VALUE            :
 *     Default CN-Tag Ethertype value.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_DEFAULT_CNTAG_ETr(c) \
		(0x13100010 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_DEFAULT_CNTAG_ETr_SIZE 1

/*
 * This structure should be used to declare and program FCM_DEFAULT_CNTAG_ET.
 *
 */
typedef union bcm84756_a0_FCM_DEFAULT_CNTAG_ETr_s {
	buint32_t v[1];
	buint32_t fcm_default_cntag_et[1];
	buint32_t _fcm_default_cntag_et;
} bcm84756_a0_FCM_DEFAULT_CNTAG_ETr_t;

#define bcm84756_a0_FCM_DEFAULT_CNTAG_ETr_CLR(r)   \
            (r).fcm_default_cntag_et[0] = 0

#define bcm84756_a0_FCM_DEFAULT_CNTAG_ETr_SET(r,d) \
            (r).fcm_default_cntag_et[0] = d

#define bcm84756_a0_FCM_DEFAULT_CNTAG_ETr_GET(r)   \
            (r).fcm_default_cntag_et[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_DEFAULT_CNTAG_ETr_VALUEf_GET(c,r)         \
	(((r).fcm_default_cntag_et[0]) & 0xffff)

#define bcm84756_a0_FCM_DEFAULT_CNTAG_ETr_VALUEf_SET(c,r,f)       \
	(r).fcm_default_cntag_et[0]=(((r).fcm_default_cntag_et[0] & ~((buint32_t)0xffff)) | \
		(((buint32_t)f) & 0xffff))


/*
 * These macros can be used to access FCM_DEFAULT_CNTAG_ET.
 *
 */
#define bcm84756_a0_READ_FCM_DEFAULT_CNTAG_ETr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_DEFAULT_CNTAG_ETr((c)),&((r)._fcm_default_cntag_et))

#define bcm84756_a0_WRITE_FCM_DEFAULT_CNTAG_ETr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_DEFAULT_CNTAG_ETr((c)),&((r)._fcm_default_cntag_et))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_DEFAULT_CNTAG_ETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_DEFAULT_FCOE_DSTMAC_hi
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR DEFAULT DSTMAC // Mapper Encap Header FCoE Default Dest MAC field. rw
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  DSTMAC           :
 *     Default DSTMAC field, bits [47:32].
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_HIr(c) \
		(0x13100016 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_HIr_SIZE 1

/*
 * This structure should be used to declare and program FCM_DEFAULT_FCOE_DSTMAC_hi.
 *
 */
typedef union bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_HIr_s {
	buint32_t v[1];
	buint32_t fcm_default_fcoe_dstmac_hi[1];
	buint32_t _fcm_default_fcoe_dstmac_hi;
} bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_HIr_t;

#define bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_HIr_CLR(r)   \
            (r).fcm_default_fcoe_dstmac_hi[0] = 0

#define bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_HIr_SET(r,d) \
            (r).fcm_default_fcoe_dstmac_hi[0] = d

#define bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_HIr_GET(r)   \
            (r).fcm_default_fcoe_dstmac_hi[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_HIr_DSTMACf_GET(c,r)         \
	(((r).fcm_default_fcoe_dstmac_hi[0]) & 0xffff)

#define bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_HIr_DSTMACf_SET(c,r,f)       \
	(r).fcm_default_fcoe_dstmac_hi[0]=(((r).fcm_default_fcoe_dstmac_hi[0] & ~((buint32_t)0xffff)) | \
		(((buint32_t)f) & 0xffff))


/*
 * These macros can be used to access FCM_DEFAULT_FCOE_DSTMAC_hi.
 *
 */
#define bcm84756_a0_READ_FCM_DEFAULT_FCOE_DSTMAC_HIr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_HIr((c)),&((r)._fcm_default_fcoe_dstmac_hi))

#define bcm84756_a0_WRITE_FCM_DEFAULT_FCOE_DSTMAC_HIr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_HIr((c)),&((r)._fcm_default_fcoe_dstmac_hi))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_DEFAULT_FCOE_DSTMAC_lo
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR DEFAULT DSTMAC // Mapper Encap Header FCoE Default Dest MAC field. rw
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  DSTMAC           :
 *     Default DSTMAC field, bits [31:0].
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_LOr(c) \
		(0x13100017 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_LOr_SIZE 1

/*
 * This structure should be used to declare and program FCM_DEFAULT_FCOE_DSTMAC_lo.
 *
 */
typedef union bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_LOr_s {
	buint32_t v[1];
	buint32_t fcm_default_fcoe_dstmac_lo[1];
	buint32_t _fcm_default_fcoe_dstmac_lo;
} bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_LOr_t;

#define bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_LOr_CLR(r)   \
            (r).fcm_default_fcoe_dstmac_lo[0] = 0

#define bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_LOr_SET(r,d) \
            (r).fcm_default_fcoe_dstmac_lo[0] = d

#define bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_LOr_GET(r)   \
            (r).fcm_default_fcoe_dstmac_lo[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_LOr_DSTMACf_GET(c,r)         \
	((r).fcm_default_fcoe_dstmac_lo[0])

#define bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_LOr_DSTMACf_SET(c,r,f)       \
	(r).fcm_default_fcoe_dstmac_lo[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_DEFAULT_FCOE_DSTMAC_lo.
 *
 */
#define bcm84756_a0_READ_FCM_DEFAULT_FCOE_DSTMAC_LOr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_LOr((c)),&((r)._fcm_default_fcoe_dstmac_lo))

#define bcm84756_a0_WRITE_FCM_DEFAULT_FCOE_DSTMAC_LOr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_LOr((c)),&((r)._fcm_default_fcoe_dstmac_lo))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_DEFAULT_FCOE_DSTMAC_LOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_DEFAULT_FCOE_ET
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Default FCoE Ethertype value.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VALUE            :
 *     Default FCoE Ethertype value.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_DEFAULT_FCOE_ETr(c) \
		(0x1310000f + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_DEFAULT_FCOE_ETr_SIZE 1

/*
 * This structure should be used to declare and program FCM_DEFAULT_FCOE_ET.
 *
 */
typedef union bcm84756_a0_FCM_DEFAULT_FCOE_ETr_s {
	buint32_t v[1];
	buint32_t fcm_default_fcoe_et[1];
	buint32_t _fcm_default_fcoe_et;
} bcm84756_a0_FCM_DEFAULT_FCOE_ETr_t;

#define bcm84756_a0_FCM_DEFAULT_FCOE_ETr_CLR(r)   \
            (r).fcm_default_fcoe_et[0] = 0

#define bcm84756_a0_FCM_DEFAULT_FCOE_ETr_SET(r,d) \
            (r).fcm_default_fcoe_et[0] = d

#define bcm84756_a0_FCM_DEFAULT_FCOE_ETr_GET(r)   \
            (r).fcm_default_fcoe_et[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_DEFAULT_FCOE_ETr_VALUEf_GET(c,r)         \
	(((r).fcm_default_fcoe_et[0]) & 0xffff)

#define bcm84756_a0_FCM_DEFAULT_FCOE_ETr_VALUEf_SET(c,r,f)       \
	(r).fcm_default_fcoe_et[0]=(((r).fcm_default_fcoe_et[0] & ~((buint32_t)0xffff)) | \
		(((buint32_t)f) & 0xffff))


/*
 * These macros can be used to access FCM_DEFAULT_FCOE_ET.
 *
 */
#define bcm84756_a0_READ_FCM_DEFAULT_FCOE_ETr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_DEFAULT_FCOE_ETr((c)),&((r)._fcm_default_fcoe_et))

#define bcm84756_a0_WRITE_FCM_DEFAULT_FCOE_ETr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_DEFAULT_FCOE_ETr((c)),&((r)._fcm_default_fcoe_et))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_DEFAULT_FCOE_ETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_DEFAULT_FCOE_SRCMAC_hi
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR DEFAULT SRCMAC // Mapper Encap Header FCoE Default Source MAC field.
 *	 rw
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  SRCMAC           :
 *     Default SRCMAC field, bits [47:32].
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_HIr(c) \
		(0x13100018 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_HIr_SIZE 1

/*
 * This structure should be used to declare and program FCM_DEFAULT_FCOE_SRCMAC_hi.
 *
 */
typedef union bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_HIr_s {
	buint32_t v[1];
	buint32_t fcm_default_fcoe_srcmac_hi[1];
	buint32_t _fcm_default_fcoe_srcmac_hi;
} bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_HIr_t;

#define bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_HIr_CLR(r)   \
            (r).fcm_default_fcoe_srcmac_hi[0] = 0

#define bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_HIr_SET(r,d) \
            (r).fcm_default_fcoe_srcmac_hi[0] = d

#define bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_HIr_GET(r)   \
            (r).fcm_default_fcoe_srcmac_hi[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_HIr_SRCMACf_GET(c,r)         \
	(((r).fcm_default_fcoe_srcmac_hi[0]) & 0xffff)

#define bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_HIr_SRCMACf_SET(c,r,f)       \
	(r).fcm_default_fcoe_srcmac_hi[0]=(((r).fcm_default_fcoe_srcmac_hi[0] & ~((buint32_t)0xffff)) | \
		(((buint32_t)f) & 0xffff))


/*
 * These macros can be used to access FCM_DEFAULT_FCOE_SRCMAC_hi.
 *
 */
#define bcm84756_a0_READ_FCM_DEFAULT_FCOE_SRCMAC_HIr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_HIr((c)),&((r)._fcm_default_fcoe_srcmac_hi))

#define bcm84756_a0_WRITE_FCM_DEFAULT_FCOE_SRCMAC_HIr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_HIr((c)),&((r)._fcm_default_fcoe_srcmac_hi))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_HIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_DEFAULT_FCOE_SRCMAC_lo
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR DEFAULT SRCMAC // Mapper Encap Header FCoE Default Source MAC field.
 *	 rw
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  SRCMAC           :
 *     Default SRCMAC field, bits [31:0].
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_LOr(c) \
		(0x13100019 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_LOr_SIZE 1

/*
 * This structure should be used to declare and program FCM_DEFAULT_FCOE_SRCMAC_lo.
 *
 */
typedef union bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_LOr_s {
	buint32_t v[1];
	buint32_t fcm_default_fcoe_srcmac_lo[1];
	buint32_t _fcm_default_fcoe_srcmac_lo;
} bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_LOr_t;

#define bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_LOr_CLR(r)   \
            (r).fcm_default_fcoe_srcmac_lo[0] = 0

#define bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_LOr_SET(r,d) \
            (r).fcm_default_fcoe_srcmac_lo[0] = d

#define bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_LOr_GET(r)   \
            (r).fcm_default_fcoe_srcmac_lo[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_LOr_SRCMACf_GET(c,r)         \
	((r).fcm_default_fcoe_srcmac_lo[0])

#define bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_LOr_SRCMACf_SET(c,r,f)       \
	(r).fcm_default_fcoe_srcmac_lo[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_DEFAULT_FCOE_SRCMAC_lo.
 *
 */
#define bcm84756_a0_READ_FCM_DEFAULT_FCOE_SRCMAC_LOr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_LOr((c)),&((r)._fcm_default_fcoe_srcmac_lo))

#define bcm84756_a0_WRITE_FCM_DEFAULT_FCOE_SRCMAC_LOr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_LOr((c)),&((r)._fcm_default_fcoe_srcmac_lo))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_DEFAULT_FCOE_SRCMAC_LOr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_DEFAULT_OUI_ET
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Default OUI extended Ethertype field.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VALUE            :
 *     Default 2-byte OUI Ethertype value.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_DEFAULT_OUI_ETr(c) \
		(0x13100011 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_DEFAULT_OUI_ETr_SIZE 1

/*
 * This structure should be used to declare and program FCM_DEFAULT_OUI_ET.
 *
 */
typedef union bcm84756_a0_FCM_DEFAULT_OUI_ETr_s {
	buint32_t v[1];
	buint32_t fcm_default_oui_et[1];
	buint32_t _fcm_default_oui_et;
} bcm84756_a0_FCM_DEFAULT_OUI_ETr_t;

#define bcm84756_a0_FCM_DEFAULT_OUI_ETr_CLR(r)   \
            (r).fcm_default_oui_et[0] = 0

#define bcm84756_a0_FCM_DEFAULT_OUI_ETr_SET(r,d) \
            (r).fcm_default_oui_et[0] = d

#define bcm84756_a0_FCM_DEFAULT_OUI_ETr_GET(r)   \
            (r).fcm_default_oui_et[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_DEFAULT_OUI_ETr_VALUEf_GET(c,r)         \
	(((r).fcm_default_oui_et[0]) & 0xffff)

#define bcm84756_a0_FCM_DEFAULT_OUI_ETr_VALUEf_SET(c,r,f)       \
	(r).fcm_default_oui_et[0]=(((r).fcm_default_oui_et[0] & ~((buint32_t)0xffff)) | \
		(((buint32_t)f) & 0xffff))


/*
 * These macros can be used to access FCM_DEFAULT_OUI_ET.
 *
 */
#define bcm84756_a0_READ_FCM_DEFAULT_OUI_ETr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_DEFAULT_OUI_ETr((c)),&((r)._fcm_default_oui_et))

#define bcm84756_a0_WRITE_FCM_DEFAULT_OUI_ETr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_DEFAULT_OUI_ETr((c)),&((r)._fcm_default_oui_et))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_DEFAULT_OUI_ETr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_DEFAULT_OUI_oui
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Default OUI field.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VALUE            :
 *     Default 3-byte OUI value.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_DEFAULT_OUI_OUIr(c) \
		(0x13100012 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_DEFAULT_OUI_OUIr_SIZE 1

/*
 * This structure should be used to declare and program FCM_DEFAULT_OUI_oui.
 *
 */
typedef union bcm84756_a0_FCM_DEFAULT_OUI_OUIr_s {
	buint32_t v[1];
	buint32_t fcm_default_oui_oui[1];
	buint32_t _fcm_default_oui_oui;
} bcm84756_a0_FCM_DEFAULT_OUI_OUIr_t;

#define bcm84756_a0_FCM_DEFAULT_OUI_OUIr_CLR(r)   \
            (r).fcm_default_oui_oui[0] = 0

#define bcm84756_a0_FCM_DEFAULT_OUI_OUIr_SET(r,d) \
            (r).fcm_default_oui_oui[0] = d

#define bcm84756_a0_FCM_DEFAULT_OUI_OUIr_GET(r)   \
            (r).fcm_default_oui_oui[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_DEFAULT_OUI_OUIr_VALUEf_GET(c,r)         \
	(((r).fcm_default_oui_oui[0]) & 0xffffff)

#define bcm84756_a0_FCM_DEFAULT_OUI_OUIr_VALUEf_SET(c,r,f)       \
	(r).fcm_default_oui_oui[0]=(((r).fcm_default_oui_oui[0] & ~((buint32_t)0xffffff)) | \
		(((buint32_t)f) & 0xffffff))


/*
 * These macros can be used to access FCM_DEFAULT_OUI_oui.
 *
 */
#define bcm84756_a0_READ_FCM_DEFAULT_OUI_OUIr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_DEFAULT_OUI_OUIr((c)),&((r)._fcm_default_oui_oui))

#define bcm84756_a0_WRITE_FCM_DEFAULT_OUI_OUIr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_DEFAULT_OUI_OUIr((c)),&((r)._fcm_default_oui_oui))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_DEFAULT_OUI_OUIr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_DEFAULT_OUI_protocol
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Default 2-byte OUI protocol field.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VALUE            :
 *     Default 2-byte OUI protocol value.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_DEFAULT_OUI_PROTOCOLr(c) \
		(0x13100013 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_DEFAULT_OUI_PROTOCOLr_SIZE 1

/*
 * This structure should be used to declare and program FCM_DEFAULT_OUI_protocol.
 *
 */
typedef union bcm84756_a0_FCM_DEFAULT_OUI_PROTOCOLr_s {
	buint32_t v[1];
	buint32_t fcm_default_oui_protocol[1];
	buint32_t _fcm_default_oui_protocol;
} bcm84756_a0_FCM_DEFAULT_OUI_PROTOCOLr_t;

#define bcm84756_a0_FCM_DEFAULT_OUI_PROTOCOLr_CLR(r)   \
            (r).fcm_default_oui_protocol[0] = 0

#define bcm84756_a0_FCM_DEFAULT_OUI_PROTOCOLr_SET(r,d) \
            (r).fcm_default_oui_protocol[0] = d

#define bcm84756_a0_FCM_DEFAULT_OUI_PROTOCOLr_GET(r)   \
            (r).fcm_default_oui_protocol[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_DEFAULT_OUI_PROTOCOLr_VALUEf_GET(c,r)         \
	(((r).fcm_default_oui_protocol[0]) & 0xffff)

#define bcm84756_a0_FCM_DEFAULT_OUI_PROTOCOLr_VALUEf_SET(c,r,f)       \
	(r).fcm_default_oui_protocol[0]=(((r).fcm_default_oui_protocol[0] & ~((buint32_t)0xffff)) | \
		(((buint32_t)f) & 0xffff))


/*
 * These macros can be used to access FCM_DEFAULT_OUI_protocol.
 *
 */
#define bcm84756_a0_READ_FCM_DEFAULT_OUI_PROTOCOLr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_DEFAULT_OUI_PROTOCOLr((c)),&((r)._fcm_default_oui_protocol))

#define bcm84756_a0_WRITE_FCM_DEFAULT_OUI_PROTOCOLr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_DEFAULT_OUI_PROTOCOLr((c)),&((r)._fcm_default_oui_protocol))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_DEFAULT_OUI_PROTOCOLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_DEFAULT_VFTHDR
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Default VFT Header Fields Register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VFID             :
 *     Default VFID.
 *
 *  PRI              :
 *     Default Priority field.
 *
 *  HOPCNT           :
 *     Default HOPCNT field value.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_DEFAULT_VFTHDRr(c) \
		(0x13100015 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_DEFAULT_VFTHDRr_SIZE 1

/*
 * This structure should be used to declare and program FCM_DEFAULT_VFTHDR.
 *
 */
typedef union bcm84756_a0_FCM_DEFAULT_VFTHDRr_s {
	buint32_t v[1];
	buint32_t fcm_default_vfthdr[1];
	buint32_t _fcm_default_vfthdr;
} bcm84756_a0_FCM_DEFAULT_VFTHDRr_t;

#define bcm84756_a0_FCM_DEFAULT_VFTHDRr_CLR(r)   \
            (r).fcm_default_vfthdr[0] = 0

#define bcm84756_a0_FCM_DEFAULT_VFTHDRr_SET(r,d) \
            (r).fcm_default_vfthdr[0] = d

#define bcm84756_a0_FCM_DEFAULT_VFTHDRr_GET(r)   \
            (r).fcm_default_vfthdr[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_DEFAULT_VFTHDRr_VFIDf_GET(c,r)         \
	((((r).fcm_default_vfthdr[0]) >> 1) & 0xfff)

#define bcm84756_a0_FCM_DEFAULT_VFTHDRr_VFIDf_SET(c,r,f)       \
	(r).fcm_default_vfthdr[0]=(((r).fcm_default_vfthdr[0] & ~((buint32_t)0xfff << 1)) | \
		((((buint32_t)f) & 0xfff) << 1))

#define bcm84756_a0_FCM_DEFAULT_VFTHDRr_PRIf_GET(c,r)         \
	((((r).fcm_default_vfthdr[0]) >> 13) & 0x7)

#define bcm84756_a0_FCM_DEFAULT_VFTHDRr_PRIf_SET(c,r,f)       \
	(r).fcm_default_vfthdr[0]=(((r).fcm_default_vfthdr[0] & ~((buint32_t)0x7 << 13)) | \
		((((buint32_t)f) & 0x7) << 13))

#define bcm84756_a0_FCM_DEFAULT_VFTHDRr_HOPCNTf_GET(c,r)         \
	((((r).fcm_default_vfthdr[0]) >> 24) & 0xff)

#define bcm84756_a0_FCM_DEFAULT_VFTHDRr_HOPCNTf_SET(c,r,f)       \
	(r).fcm_default_vfthdr[0]=(((r).fcm_default_vfthdr[0] & ~((buint32_t)0xff << 24)) | \
		((((buint32_t)f) & 0xff) << 24))


/*
 * These macros can be used to access FCM_DEFAULT_VFTHDR.
 *
 */
#define bcm84756_a0_READ_FCM_DEFAULT_VFTHDRr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_DEFAULT_VFTHDRr((c)),&((r)._fcm_default_vfthdr))

#define bcm84756_a0_WRITE_FCM_DEFAULT_VFTHDRr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_DEFAULT_VFTHDRr((c)),&((r)._fcm_default_vfthdr))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_DEFAULT_VFTHDRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_DEFAULT_VLAN_TAG
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Default 802.1Q VLAN tag register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VID              :
 *     Default 12-bit VLAN VID field.
 *
 *  CFI              :
 *     CFI should be 0.
 *
 *  PCP              :
 *     Default Priority field for inserted VLAN tag.
 *
 *  TPID             :
 *     Mapped from the 3-bit VFT Header Priority field. Default is 0x8100.
 *     This value is also used by the parser to identify the VLAN tag field in
 *     the FCoE packet.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_DEFAULT_VLAN_TAGr(c) \
		(0x13100014 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_DEFAULT_VLAN_TAGr_SIZE 1

/*
 * This structure should be used to declare and program FCM_DEFAULT_VLAN_TAG.
 *
 */
typedef union bcm84756_a0_FCM_DEFAULT_VLAN_TAGr_s {
	buint32_t v[1];
	buint32_t fcm_default_vlan_tag[1];
	buint32_t _fcm_default_vlan_tag;
} bcm84756_a0_FCM_DEFAULT_VLAN_TAGr_t;

#define bcm84756_a0_FCM_DEFAULT_VLAN_TAGr_CLR(r)   \
            (r).fcm_default_vlan_tag[0] = 0

#define bcm84756_a0_FCM_DEFAULT_VLAN_TAGr_SET(r,d) \
            (r).fcm_default_vlan_tag[0] = d

#define bcm84756_a0_FCM_DEFAULT_VLAN_TAGr_GET(r)   \
            (r).fcm_default_vlan_tag[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_DEFAULT_VLAN_TAGr_VIDf_GET(c,r)         \
	(((r).fcm_default_vlan_tag[0]) & 0xfff)

#define bcm84756_a0_FCM_DEFAULT_VLAN_TAGr_VIDf_SET(c,r,f)       \
	(r).fcm_default_vlan_tag[0]=(((r).fcm_default_vlan_tag[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_FCM_DEFAULT_VLAN_TAGr_CFIf_GET(c,r)         \
	((((r).fcm_default_vlan_tag[0]) >> 12) & 0x1)

#define bcm84756_a0_FCM_DEFAULT_VLAN_TAGr_CFIf_SET(c,r,f)       \
	(r).fcm_default_vlan_tag[0]=(((r).fcm_default_vlan_tag[0] & ~((buint32_t)0x1 << 12)) | \
		((((buint32_t)f) & 0x1) << 12))

#define bcm84756_a0_FCM_DEFAULT_VLAN_TAGr_PCPf_GET(c,r)         \
	((((r).fcm_default_vlan_tag[0]) >> 13) & 0x7)

#define bcm84756_a0_FCM_DEFAULT_VLAN_TAGr_PCPf_SET(c,r,f)       \
	(r).fcm_default_vlan_tag[0]=(((r).fcm_default_vlan_tag[0] & ~((buint32_t)0x7 << 13)) | \
		((((buint32_t)f) & 0x7) << 13))

#define bcm84756_a0_FCM_DEFAULT_VLAN_TAGr_TPIDf_GET(c,r)         \
	((((r).fcm_default_vlan_tag[0]) >> 16) & 0xffff)

#define bcm84756_a0_FCM_DEFAULT_VLAN_TAGr_TPIDf_SET(c,r,f)       \
	(r).fcm_default_vlan_tag[0]=(((r).fcm_default_vlan_tag[0] & ~((buint32_t)0xffff << 16)) | \
		((((buint32_t)f) & 0xffff) << 16))


/*
 * These macros can be used to access FCM_DEFAULT_VLAN_TAG.
 *
 */
#define bcm84756_a0_READ_FCM_DEFAULT_VLAN_TAGr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_DEFAULT_VLAN_TAGr((c)),&((r)._fcm_default_vlan_tag))

#define bcm84756_a0_WRITE_FCM_DEFAULT_VLAN_TAGr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_DEFAULT_VLAN_TAGr((c)),&((r)._fcm_default_vlan_tag))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_DEFAULT_VLAN_TAGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCGEN_TX_control
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 FC GEN status register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FC_PWR_DWN       :
 *     0 - The FC GEN TX block clocks are enabled. 1 - The FC GEN TX block is
 *     in the powered down state.
 *
 *  FC_SW_RST        :
 *     FC GEN software reset: 0 - The FC GEN Tx block is functional 1 - The FC
 *     GEN Tx block is held in the soft reset state.
 *
 *  LOOPBACK         :
 *     Loopback enable.
 *
 *  FC_OPER_RATE     :
 *     Configures the Fiber Channel Tx block speed. 3'b000 - Speed follows the
 *     receiver 3'b001 - reserved 3'b010 - 2.125 Gb/s 3'b011 - 4.25 Gb/s
 *     3'b100 - 8.5 Gb/s others - reserved.
 *
 *  NO_SYNC_DATA     :
 *     Indicates the data type to transmit when the speed in not acquired by
 *     the receiver: 2'b00 : Squelched data 2'b01 : Idle ordered set 2'b1X :
 *     Data from the receiver
 *
 *  TRANSMIT_LSB_FIRST :
 *     1 = FCGEN transmits lsb first 0 = FCGEN transmits msb first
 *
 *  FORCE_SPEED_NOT_ACQUIRED :
 *     1 = Enable bit-stuffed TX data on 20-bit TX data output for 2G and 4G.
 *     0 = Force non-stuffed data on 20-bit TX data output.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr(c) \
		(0x13100090 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCGEN_TX_control.
 *
 */
typedef union bcm84756_a0_FCM_FCGEN_TX_CONTROLr_s {
	buint32_t v[1];
	buint32_t fcm_fcgen_tx_control[1];
	buint32_t _fcm_fcgen_tx_control;
} bcm84756_a0_FCM_FCGEN_TX_CONTROLr_t;

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_CLR(r)   \
            (r).fcm_fcgen_tx_control[0] = 0

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_SET(r,d) \
            (r).fcm_fcgen_tx_control[0] = d

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_GET(r)   \
            (r).fcm_fcgen_tx_control[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_FC_PWR_DWNf_GET(c,r)         \
	(((r).fcm_fcgen_tx_control[0]) & 0x1)

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_FC_PWR_DWNf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_control[0]=(((r).fcm_fcgen_tx_control[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_FC_SW_RSTf_GET(c,r)         \
	((((r).fcm_fcgen_tx_control[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_FC_SW_RSTf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_control[0]=(((r).fcm_fcgen_tx_control[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_LOOPBACKf_GET(c,r)         \
	((((r).fcm_fcgen_tx_control[0]) >> 2) & 0x1)

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_LOOPBACKf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_control[0]=(((r).fcm_fcgen_tx_control[0] & ~((buint32_t)0x1 << 2)) | \
		((((buint32_t)f) & 0x1) << 2))

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_FC_OPER_RATEf_GET(c,r)         \
	((((r).fcm_fcgen_tx_control[0]) >> 3) & 0x7)

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_FC_OPER_RATEf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_control[0]=(((r).fcm_fcgen_tx_control[0] & ~((buint32_t)0x7 << 3)) | \
		((((buint32_t)f) & 0x7) << 3))

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_NO_SYNC_DATAf_GET(c,r)         \
	((((r).fcm_fcgen_tx_control[0]) >> 6) & 0x3)

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_NO_SYNC_DATAf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_control[0]=(((r).fcm_fcgen_tx_control[0] & ~((buint32_t)0x3 << 6)) | \
		((((buint32_t)f) & 0x3) << 6))

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_TRANSMIT_LSB_FIRSTf_GET(c,r)         \
	((((r).fcm_fcgen_tx_control[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_TRANSMIT_LSB_FIRSTf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_control[0]=(((r).fcm_fcgen_tx_control[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_FORCE_SPEED_NOT_ACQUIREDf_GET(c,r)         \
	((((r).fcm_fcgen_tx_control[0]) >> 9) & 0x1)

#define bcm84756_a0_FCM_FCGEN_TX_CONTROLr_FORCE_SPEED_NOT_ACQUIREDf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_control[0]=(((r).fcm_fcgen_tx_control[0] & ~((buint32_t)0x1 << 9)) | \
		((((buint32_t)f) & 0x1) << 9))


/*
 * These macros can be used to access FCM_FCGEN_TX_control.
 *
 */
#define bcm84756_a0_READ_FCM_FCGEN_TX_CONTROLr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCGEN_TX_CONTROLr((c)),&((r)._fcm_fcgen_tx_control))

#define bcm84756_a0_WRITE_FCM_FCGEN_TX_CONTROLr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCGEN_TX_CONTROLr((c)),&((r)._fcm_fcgen_tx_control))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCGEN_TX_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCGEN_TX_no_sync_data_word0
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 TX 10b data register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  DATA10B          :
 *     10b tx data.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD0r(c) \
		(0x13100094 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD0r_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCGEN_TX_no_sync_data_word0.
 *
 */
typedef union bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD0r_s {
	buint32_t v[1];
	buint32_t fcm_fcgen_tx_no_sync_data_word0[1];
	buint32_t _fcm_fcgen_tx_no_sync_data_word0;
} bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD0r_t;

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD0r_CLR(r)   \
            (r).fcm_fcgen_tx_no_sync_data_word0[0] = 0

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD0r_SET(r,d) \
            (r).fcm_fcgen_tx_no_sync_data_word0[0] = d

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD0r_GET(r)   \
            (r).fcm_fcgen_tx_no_sync_data_word0[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD0r_DATA10Bf_GET(c,r)         \
	(((r).fcm_fcgen_tx_no_sync_data_word0[0]) & 0x3ff)

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD0r_DATA10Bf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_no_sync_data_word0[0]=(((r).fcm_fcgen_tx_no_sync_data_word0[0] & ~((buint32_t)0x3ff)) | \
		(((buint32_t)f) & 0x3ff))


/*
 * These macros can be used to access FCM_FCGEN_TX_no_sync_data_word0.
 *
 */
#define bcm84756_a0_READ_FCM_FCGEN_TX_NO_SYNC_DATA_WORD0r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD0r((c)),&((r)._fcm_fcgen_tx_no_sync_data_word0))

#define bcm84756_a0_WRITE_FCM_FCGEN_TX_NO_SYNC_DATA_WORD0r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD0r((c)),&((r)._fcm_fcgen_tx_no_sync_data_word0))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCGEN_TX_no_sync_data_word1
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 TX 10b data register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  DATA10B          :
 *     10b tx data.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD1r(c) \
		(0x13100095 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD1r_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCGEN_TX_no_sync_data_word1.
 *
 */
typedef union bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD1r_s {
	buint32_t v[1];
	buint32_t fcm_fcgen_tx_no_sync_data_word1[1];
	buint32_t _fcm_fcgen_tx_no_sync_data_word1;
} bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD1r_t;

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD1r_CLR(r)   \
            (r).fcm_fcgen_tx_no_sync_data_word1[0] = 0

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD1r_SET(r,d) \
            (r).fcm_fcgen_tx_no_sync_data_word1[0] = d

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD1r_GET(r)   \
            (r).fcm_fcgen_tx_no_sync_data_word1[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD1r_DATA10Bf_GET(c,r)         \
	(((r).fcm_fcgen_tx_no_sync_data_word1[0]) & 0x3ff)

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD1r_DATA10Bf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_no_sync_data_word1[0]=(((r).fcm_fcgen_tx_no_sync_data_word1[0] & ~((buint32_t)0x3ff)) | \
		(((buint32_t)f) & 0x3ff))


/*
 * These macros can be used to access FCM_FCGEN_TX_no_sync_data_word1.
 *
 */
#define bcm84756_a0_READ_FCM_FCGEN_TX_NO_SYNC_DATA_WORD1r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD1r((c)),&((r)._fcm_fcgen_tx_no_sync_data_word1))

#define bcm84756_a0_WRITE_FCM_FCGEN_TX_NO_SYNC_DATA_WORD1r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD1r((c)),&((r)._fcm_fcgen_tx_no_sync_data_word1))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCGEN_TX_no_sync_data_word2
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 TX 10b data register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  DATA10B          :
 *     10b tx data.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD2r(c) \
		(0x13100096 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD2r_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCGEN_TX_no_sync_data_word2.
 *
 */
typedef union bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD2r_s {
	buint32_t v[1];
	buint32_t fcm_fcgen_tx_no_sync_data_word2[1];
	buint32_t _fcm_fcgen_tx_no_sync_data_word2;
} bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD2r_t;

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD2r_CLR(r)   \
            (r).fcm_fcgen_tx_no_sync_data_word2[0] = 0

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD2r_SET(r,d) \
            (r).fcm_fcgen_tx_no_sync_data_word2[0] = d

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD2r_GET(r)   \
            (r).fcm_fcgen_tx_no_sync_data_word2[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD2r_DATA10Bf_GET(c,r)         \
	(((r).fcm_fcgen_tx_no_sync_data_word2[0]) & 0x3ff)

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD2r_DATA10Bf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_no_sync_data_word2[0]=(((r).fcm_fcgen_tx_no_sync_data_word2[0] & ~((buint32_t)0x3ff)) | \
		(((buint32_t)f) & 0x3ff))


/*
 * These macros can be used to access FCM_FCGEN_TX_no_sync_data_word2.
 *
 */
#define bcm84756_a0_READ_FCM_FCGEN_TX_NO_SYNC_DATA_WORD2r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD2r((c)),&((r)._fcm_fcgen_tx_no_sync_data_word2))

#define bcm84756_a0_WRITE_FCM_FCGEN_TX_NO_SYNC_DATA_WORD2r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD2r((c)),&((r)._fcm_fcgen_tx_no_sync_data_word2))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCGEN_TX_no_sync_data_word3
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 TX 10b data register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  DATA10B          :
 *     10b tx data.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD3r(c) \
		(0x13100097 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD3r_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCGEN_TX_no_sync_data_word3.
 *
 */
typedef union bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD3r_s {
	buint32_t v[1];
	buint32_t fcm_fcgen_tx_no_sync_data_word3[1];
	buint32_t _fcm_fcgen_tx_no_sync_data_word3;
} bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD3r_t;

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD3r_CLR(r)   \
            (r).fcm_fcgen_tx_no_sync_data_word3[0] = 0

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD3r_SET(r,d) \
            (r).fcm_fcgen_tx_no_sync_data_word3[0] = d

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD3r_GET(r)   \
            (r).fcm_fcgen_tx_no_sync_data_word3[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD3r_DATA10Bf_GET(c,r)         \
	(((r).fcm_fcgen_tx_no_sync_data_word3[0]) & 0x3ff)

#define bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD3r_DATA10Bf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_no_sync_data_word3[0]=(((r).fcm_fcgen_tx_no_sync_data_word3[0] & ~((buint32_t)0x3ff)) | \
		(((buint32_t)f) & 0x3ff))


/*
 * These macros can be used to access FCM_FCGEN_TX_no_sync_data_word3.
 *
 */
#define bcm84756_a0_READ_FCM_FCGEN_TX_NO_SYNC_DATA_WORD3r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD3r((c)),&((r)._fcm_fcgen_tx_no_sync_data_word3))

#define bcm84756_a0_WRITE_FCM_FCGEN_TX_NO_SYNC_DATA_WORD3r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD3r((c)),&((r)._fcm_fcgen_tx_no_sync_data_word3))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCGEN_TX_NO_SYNC_DATA_WORD3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCGEN_TX_status
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 FC GEN status register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  STATUS           :
 *     TX FC GEN status register.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCGEN_TX_STATUSr(c) \
		(0x13100091 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCGEN_TX_STATUSr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCGEN_TX_status.
 *
 */
typedef union bcm84756_a0_FCM_FCGEN_TX_STATUSr_s {
	buint32_t v[1];
	buint32_t fcm_fcgen_tx_status[1];
	buint32_t _fcm_fcgen_tx_status;
} bcm84756_a0_FCM_FCGEN_TX_STATUSr_t;

#define bcm84756_a0_FCM_FCGEN_TX_STATUSr_CLR(r)   \
            (r).fcm_fcgen_tx_status[0] = 0

#define bcm84756_a0_FCM_FCGEN_TX_STATUSr_SET(r,d) \
            (r).fcm_fcgen_tx_status[0] = d

#define bcm84756_a0_FCM_FCGEN_TX_STATUSr_GET(r)   \
            (r).fcm_fcgen_tx_status[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCGEN_TX_STATUSr_STATUSf_GET(c,r)         \
	(((r).fcm_fcgen_tx_status[0]) & 0xffff)

#define bcm84756_a0_FCM_FCGEN_TX_STATUSr_STATUSf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_status[0]=(((r).fcm_fcgen_tx_status[0] & ~((buint32_t)0xffff)) | \
		(((buint32_t)f) & 0xffff))


/*
 * These macros can be used to access FCM_FCGEN_TX_status.
 *
 */
#define bcm84756_a0_READ_FCM_FCGEN_TX_STATUSr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCGEN_TX_STATUSr((c)),&((r)._fcm_fcgen_tx_status))

#define bcm84756_a0_WRITE_FCM_FCGEN_TX_STATUSr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCGEN_TX_STATUSr((c)),&((r)._fcm_fcgen_tx_status))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCGEN_TX_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCGEN_TX_tpat_gen_control
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 FC GEN status register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FC_TPAT_ENABLE   :
 *     Test pattern enable: 0 - The pattern generator outputs either idle
 *     ordered sets or squelches data. 1 - The pattern generator outputs idle
 *     ordered sets until tpat sof is written, then the selected test pattern
 *     is generated.
 *
 *  FC_TPAT_SOF      :
 *     Starts the pattern generation. This bit is self-clearing.
 *
 *  FC_TPAT_MODE     :
 *     Fiber Channel Test Pattern Type: 2'b00 - JSPAT 2'b01 - JTSPAT 2'b10 -
 *     CJTPAT 2'b11 - CRPAT
 *
 *  FC_NB_IDLES      :
 *     Number of idle ordered set to insert between test patterns.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr(c) \
		(0x13100092 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCGEN_TX_tpat_gen_control.
 *
 */
typedef union bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr_s {
	buint32_t v[1];
	buint32_t fcm_fcgen_tx_tpat_gen_control[1];
	buint32_t _fcm_fcgen_tx_tpat_gen_control;
} bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr_t;

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr_CLR(r)   \
            (r).fcm_fcgen_tx_tpat_gen_control[0] = 0

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr_SET(r,d) \
            (r).fcm_fcgen_tx_tpat_gen_control[0] = d

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr_GET(r)   \
            (r).fcm_fcgen_tx_tpat_gen_control[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr_FC_TPAT_ENABLEf_GET(c,r)         \
	(((r).fcm_fcgen_tx_tpat_gen_control[0]) & 0x1)

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr_FC_TPAT_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_tpat_gen_control[0]=(((r).fcm_fcgen_tx_tpat_gen_control[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr_FC_TPAT_SOFf_GET(c,r)         \
	((((r).fcm_fcgen_tx_tpat_gen_control[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr_FC_TPAT_SOFf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_tpat_gen_control[0]=(((r).fcm_fcgen_tx_tpat_gen_control[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr_FC_TPAT_MODEf_GET(c,r)         \
	((((r).fcm_fcgen_tx_tpat_gen_control[0]) >> 2) & 0x3)

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr_FC_TPAT_MODEf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_tpat_gen_control[0]=(((r).fcm_fcgen_tx_tpat_gen_control[0] & ~((buint32_t)0x3 << 2)) | \
		((((buint32_t)f) & 0x3) << 2))

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr_FC_NB_IDLESf_GET(c,r)         \
	((((r).fcm_fcgen_tx_tpat_gen_control[0]) >> 4) & 0xf)

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr_FC_NB_IDLESf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_tpat_gen_control[0]=(((r).fcm_fcgen_tx_tpat_gen_control[0] & ~((buint32_t)0xf << 4)) | \
		((((buint32_t)f) & 0xf) << 4))


/*
 * These macros can be used to access FCM_FCGEN_TX_tpat_gen_control.
 *
 */
#define bcm84756_a0_READ_FCM_FCGEN_TX_TPAT_GEN_CONTROLr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr((c)),&((r)._fcm_fcgen_tx_tpat_gen_control))

#define bcm84756_a0_WRITE_FCM_FCGEN_TX_TPAT_GEN_CONTROLr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr((c)),&((r)._fcm_fcgen_tx_tpat_gen_control))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCGEN_TX_TPAT_GEN_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCGEN_TX_tpat_nb_tpat_reg
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 FC GEN TX pattern count register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FC_TX_NB_TPAT    :
 *     Number of Fiber Channel test patterns to transmit after fc tpat sof is
 *     written. A value of 0 will generate continuous patterns.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCGEN_TX_TPAT_NB_TPAT_REGr(c) \
		(0x13100093 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_NB_TPAT_REGr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCGEN_TX_tpat_nb_tpat_reg.
 *
 */
typedef union bcm84756_a0_FCM_FCGEN_TX_TPAT_NB_TPAT_REGr_s {
	buint32_t v[1];
	buint32_t fcm_fcgen_tx_tpat_nb_tpat_reg[1];
	buint32_t _fcm_fcgen_tx_tpat_nb_tpat_reg;
} bcm84756_a0_FCM_FCGEN_TX_TPAT_NB_TPAT_REGr_t;

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_NB_TPAT_REGr_CLR(r)   \
            (r).fcm_fcgen_tx_tpat_nb_tpat_reg[0] = 0

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_NB_TPAT_REGr_SET(r,d) \
            (r).fcm_fcgen_tx_tpat_nb_tpat_reg[0] = d

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_NB_TPAT_REGr_GET(r)   \
            (r).fcm_fcgen_tx_tpat_nb_tpat_reg[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCGEN_TX_TPAT_NB_TPAT_REGr_FC_TX_NB_TPATf_GET(c,r)         \
	(((r).fcm_fcgen_tx_tpat_nb_tpat_reg[0]) & 0xffff)

#define bcm84756_a0_FCM_FCGEN_TX_TPAT_NB_TPAT_REGr_FC_TX_NB_TPATf_SET(c,r,f)       \
	(r).fcm_fcgen_tx_tpat_nb_tpat_reg[0]=(((r).fcm_fcgen_tx_tpat_nb_tpat_reg[0] & ~((buint32_t)0xffff)) | \
		(((buint32_t)f) & 0xffff))


/*
 * These macros can be used to access FCM_FCGEN_TX_tpat_nb_tpat_reg.
 *
 */
#define bcm84756_a0_READ_FCM_FCGEN_TX_TPAT_NB_TPAT_REGr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCGEN_TX_TPAT_NB_TPAT_REGr((c)),&((r)._fcm_fcgen_tx_tpat_nb_tpat_reg))

#define bcm84756_a0_WRITE_FCM_FCGEN_TX_TPAT_NB_TPAT_REGr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCGEN_TX_TPAT_NB_TPAT_REGr((c)),&((r)._fcm_fcgen_tx_tpat_nb_tpat_reg))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCGEN_TX_TPAT_NB_TPAT_REGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_ALTR
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR ALTR 7'h12 // AL TOV reload register R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  UNUSED_ALTR      :
 *     Unused in current FCMAC RTL, always read as 0.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_ALTRr(c) \
		(0x13100077 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_ALTRr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_ALTR.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_ALTRr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_altr[1];
	buint32_t _fcm_fcmac_altr;
} bcm84756_a0_FCM_FCMAC_ALTRr_t;

#define bcm84756_a0_FCM_FCMAC_ALTRr_CLR(r)   \
            (r).fcm_fcmac_altr[0] = 0

#define bcm84756_a0_FCM_FCMAC_ALTRr_SET(r,d) \
            (r).fcm_fcmac_altr[0] = d

#define bcm84756_a0_FCM_FCMAC_ALTRr_GET(r)   \
            (r).fcm_fcmac_altr[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_ALTRr_UNUSED_ALTRf_GET(c,r)         \
	((r).fcm_fcmac_altr[0])

#define bcm84756_a0_FCM_FCMAC_ALTRr_UNUSED_ALTRf_SET(c,r,f)       \
	(r).fcm_fcmac_altr[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_FCMAC_ALTR.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_ALTRr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_ALTRr((c)),&((r)._fcm_fcmac_altr))

#define bcm84756_a0_WRITE_FCM_FCMAC_ALTRr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_ALTRr((c)),&((r)._fcm_fcmac_altr))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_ALTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_AWWNX
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR AWWNX 7'h0A // Assigned WWN Register bits 63:32 R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  AWWN_X           :
 *     Assigned WWN[63:32].
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_AWWNXr(c) \
		(0x1310006f + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_AWWNXr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_AWWNX.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_AWWNXr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_awwnx[1];
	buint32_t _fcm_fcmac_awwnx;
} bcm84756_a0_FCM_FCMAC_AWWNXr_t;

#define bcm84756_a0_FCM_FCMAC_AWWNXr_CLR(r)   \
            (r).fcm_fcmac_awwnx[0] = 0

#define bcm84756_a0_FCM_FCMAC_AWWNXr_SET(r,d) \
            (r).fcm_fcmac_awwnx[0] = d

#define bcm84756_a0_FCM_FCMAC_AWWNXr_GET(r)   \
            (r).fcm_fcmac_awwnx[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_AWWNXr_AWWN_Xf_GET(c,r)         \
	((r).fcm_fcmac_awwnx[0])

#define bcm84756_a0_FCM_FCMAC_AWWNXr_AWWN_Xf_SET(c,r,f)       \
	(r).fcm_fcmac_awwnx[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_FCMAC_AWWNX.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_AWWNXr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_AWWNXr((c)),&((r)._fcm_fcmac_awwnx))

#define bcm84756_a0_WRITE_FCM_FCMAC_AWWNXr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_AWWNXr((c)),&((r)._fcm_fcmac_awwnx))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_AWWNXr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_AWWNY
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR AWWNY 7'h0B // Assigned WWN Register bits 31:0 R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  AWWN_Y           :
 *     Assigned WWN[31:00].
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_AWWNYr(c) \
		(0x13100070 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_AWWNYr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_AWWNY.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_AWWNYr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_awwny[1];
	buint32_t _fcm_fcmac_awwny;
} bcm84756_a0_FCM_FCMAC_AWWNYr_t;

#define bcm84756_a0_FCM_FCMAC_AWWNYr_CLR(r)   \
            (r).fcm_fcmac_awwny[0] = 0

#define bcm84756_a0_FCM_FCMAC_AWWNYr_SET(r,d) \
            (r).fcm_fcmac_awwny[0] = d

#define bcm84756_a0_FCM_FCMAC_AWWNYr_GET(r)   \
            (r).fcm_fcmac_awwny[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_AWWNYr_AWWN_Yf_GET(c,r)         \
	((r).fcm_fcmac_awwny[0])

#define bcm84756_a0_FCM_FCMAC_AWWNYr_AWWN_Yf_SET(c,r,f)       \
	(r).fcm_fcmac_awwny[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_FCMAC_AWWNY.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_AWWNYr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_AWWNYr((c)),&((r)._fcm_fcmac_awwny))

#define bcm84756_a0_WRITE_FCM_FCMAC_AWWNYr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_AWWNYr((c)),&((r)._fcm_fcmac_awwny))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_AWWNYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_BADRXCHAR_SUBSTVAL
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR RXBADCHAR SUBSTVAL 7'h23 // Decode Bad RX Transmission 8b Char
 *	 Substitution Register. rw
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  CODE_8B_SUBST    :
 *     text.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_BADRXCHAR_SUBSTVALr(c) \
		(0x13100004 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_BADRXCHAR_SUBSTVALr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_BADRXCHAR_SUBSTVAL.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_BADRXCHAR_SUBSTVALr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_badrxchar_substval[1];
	buint32_t _fcm_fcmac_badrxchar_substval;
} bcm84756_a0_FCM_FCMAC_BADRXCHAR_SUBSTVALr_t;

#define bcm84756_a0_FCM_FCMAC_BADRXCHAR_SUBSTVALr_CLR(r)   \
            (r).fcm_fcmac_badrxchar_substval[0] = 0

#define bcm84756_a0_FCM_FCMAC_BADRXCHAR_SUBSTVALr_SET(r,d) \
            (r).fcm_fcmac_badrxchar_substval[0] = d

#define bcm84756_a0_FCM_FCMAC_BADRXCHAR_SUBSTVALr_GET(r)   \
            (r).fcm_fcmac_badrxchar_substval[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_BADRXCHAR_SUBSTVALr_CODE_8B_SUBSTf_GET(c,r)         \
	((r).fcm_fcmac_badrxchar_substval[0])

#define bcm84756_a0_FCM_FCMAC_BADRXCHAR_SUBSTVALr_CODE_8B_SUBSTf_SET(c,r,f)       \
	(r).fcm_fcmac_badrxchar_substval[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_FCMAC_BADRXCHAR_SUBSTVAL.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_BADRXCHAR_SUBSTVALr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_BADRXCHAR_SUBSTVALr((c)),&((r)._fcm_fcmac_badrxchar_substval))

#define bcm84756_a0_WRITE_FCM_FCMAC_BADRXCHAR_SUBSTVALr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_BADRXCHAR_SUBSTVALr((c)),&((r)._fcm_fcmac_badrxchar_substval))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_BADRXCHAR_SUBSTVALr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_BBC
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR BBC 7'h06 // BB Credit and avail BB Credit reg R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  BBC_BB_CREDIT    :
 *     BB Credit count. This field should be written with the buffer-to-buffer
 *     credit value BB Credit obtained from the Common Service Parameters
 *     during Fabric Login. (TBD: this value should not be used to reload the
 *     Residual BB Credit Counter upon entering ACTIVE state.) In the ACTIVE
 *     state, a Write to this register to load the login BB Credit value also
 *     loads the login BB Credit value int the Residual BB Credit Counter
 *     field. This field is initialized to 0x00 by a hardware reset and is
 *     automatically loaded with 0x01 when the NPORT PSPE enters the ACTIVE
 *     state.
 *
 *  BBC_RESIDUAL_BB_CREDIT_CNT :
 *     Residual BB Credit count. This field reflects the current contents of
 *     the Residual BB Credit Counter. The Residual BB Credit Counter will
 *     decrement for each BB Credit-Controlled frame (not starting with an
 *     SOFil or SOFnl) that is transmitted. This counter will not decrement
 *     below zero. This counter will increment for each R RDY received. The
 *     Residual BB Credit Counter will not be increment higher than the
 *     maximum value (255). The Residual BB Credit CNT represents the total
 *     number of unoccupied Rx buffers at the other end of the Fibre Channel
 *     Link, while the difference between the BB Credit value and the Residual
 *     BB Credit CNT represents the number of outstanding (no corresponding R
 *     RDY) transmission frames. Transmission of BB Credit-Controlled frames
 *     will be suspended if the Residual BB Credit CNT is zero. The counter is
 *     initialized to 0x00 by a hardware reset and is automatically loaded
 *     with 0x01 when the NPORT PSPE enters the ACTIVE state.
 *
 *  BBC_AVAIL_BB_CREDIT_CNT :
 *     Avail. BB Credit count. Used in Loop mode only -- always 0 in
 *     point-to-point topology.
 *
 *  BBC_POLARITY     :
 *     This bit is SET when the bbcredit count becomes negative and CLEARED
 *     when positive.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_BBCr(c) \
		(0x1310006b + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_BBCr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_BBC.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_BBCr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_bbc[1];
	buint32_t _fcm_fcmac_bbc;
} bcm84756_a0_FCM_FCMAC_BBCr_t;

#define bcm84756_a0_FCM_FCMAC_BBCr_CLR(r)   \
            (r).fcm_fcmac_bbc[0] = 0

#define bcm84756_a0_FCM_FCMAC_BBCr_SET(r,d) \
            (r).fcm_fcmac_bbc[0] = d

#define bcm84756_a0_FCM_FCMAC_BBCr_GET(r)   \
            (r).fcm_fcmac_bbc[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_BBCr_BBC_BB_CREDITf_GET(c,r)         \
	(((r).fcm_fcmac_bbc[0]) & 0xff)

#define bcm84756_a0_FCM_FCMAC_BBCr_BBC_BB_CREDITf_SET(c,r,f)       \
	(r).fcm_fcmac_bbc[0]=(((r).fcm_fcmac_bbc[0] & ~((buint32_t)0xff)) | \
		(((buint32_t)f) & 0xff))

#define bcm84756_a0_FCM_FCMAC_BBCr_BBC_RESIDUAL_BB_CREDIT_CNTf_GET(c,r)         \
	((((r).fcm_fcmac_bbc[0]) >> 8) & 0xff)

#define bcm84756_a0_FCM_FCMAC_BBCr_BBC_RESIDUAL_BB_CREDIT_CNTf_SET(c,r,f)       \
	(r).fcm_fcmac_bbc[0]=(((r).fcm_fcmac_bbc[0] & ~((buint32_t)0xff << 8)) | \
		((((buint32_t)f) & 0xff) << 8))

#define bcm84756_a0_FCM_FCMAC_BBCr_BBC_AVAIL_BB_CREDIT_CNTf_GET(c,r)         \
	((((r).fcm_fcmac_bbc[0]) >> 16) & 0xff)

#define bcm84756_a0_FCM_FCMAC_BBCr_BBC_AVAIL_BB_CREDIT_CNTf_SET(c,r,f)       \
	(r).fcm_fcmac_bbc[0]=(((r).fcm_fcmac_bbc[0] & ~((buint32_t)0xff << 16)) | \
		((((buint32_t)f) & 0xff) << 16))

#define bcm84756_a0_FCM_FCMAC_BBCr_BBC_POLARITYf_GET(c,r)         \
	((((r).fcm_fcmac_bbc[0]) >> 31) & 0x1)

#define bcm84756_a0_FCM_FCMAC_BBCr_BBC_POLARITYf_SET(c,r,f)       \
	(r).fcm_fcmac_bbc[0]=(((r).fcm_fcmac_bbc[0] & ~((buint32_t)0x1 << 31)) | \
		((((buint32_t)f) & 0x1) << 31))


/*
 * These macros can be used to access FCM_FCMAC_BBC.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_BBCr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_BBCr((c)),&((r)._fcm_fcmac_bbc))

#define bcm84756_a0_WRITE_FCM_FCMAC_BBCr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_BBCr((c)),&((r)._fcm_fcmac_bbc))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_BBCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_BBC1
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR BBC 7'h17 // VC1 BB Credit and avail BB Credit reg R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  BBC_BB_CREDIT    :
 *     BB Credit count.
 *
 *  BBC_RESIDUAL_BB_CREDIT_CNT :
 *     Residual BB Credit count.
 *
 *  BBC_AVAIL_BB_CREDIT_CNT :
 *     Avail. BB Credit count.
 *
 *  BBC_POLARITY     :
 *     Polarity(+/-).
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_BBC1r(c) \
		(0x1310007c + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_BBC1r_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_BBC1.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_BBC1r_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_bbc1[1];
	buint32_t _fcm_fcmac_bbc1;
} bcm84756_a0_FCM_FCMAC_BBC1r_t;

#define bcm84756_a0_FCM_FCMAC_BBC1r_CLR(r)   \
            (r).fcm_fcmac_bbc1[0] = 0

#define bcm84756_a0_FCM_FCMAC_BBC1r_SET(r,d) \
            (r).fcm_fcmac_bbc1[0] = d

#define bcm84756_a0_FCM_FCMAC_BBC1r_GET(r)   \
            (r).fcm_fcmac_bbc1[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_BBC1r_BBC_BB_CREDITf_GET(c,r)         \
	(((r).fcm_fcmac_bbc1[0]) & 0xff)

#define bcm84756_a0_FCM_FCMAC_BBC1r_BBC_BB_CREDITf_SET(c,r,f)       \
	(r).fcm_fcmac_bbc1[0]=(((r).fcm_fcmac_bbc1[0] & ~((buint32_t)0xff)) | \
		(((buint32_t)f) & 0xff))

#define bcm84756_a0_FCM_FCMAC_BBC1r_BBC_RESIDUAL_BB_CREDIT_CNTf_GET(c,r)         \
	((((r).fcm_fcmac_bbc1[0]) >> 8) & 0xff)

#define bcm84756_a0_FCM_FCMAC_BBC1r_BBC_RESIDUAL_BB_CREDIT_CNTf_SET(c,r,f)       \
	(r).fcm_fcmac_bbc1[0]=(((r).fcm_fcmac_bbc1[0] & ~((buint32_t)0xff << 8)) | \
		((((buint32_t)f) & 0xff) << 8))

#define bcm84756_a0_FCM_FCMAC_BBC1r_BBC_AVAIL_BB_CREDIT_CNTf_GET(c,r)         \
	((((r).fcm_fcmac_bbc1[0]) >> 16) & 0xff)

#define bcm84756_a0_FCM_FCMAC_BBC1r_BBC_AVAIL_BB_CREDIT_CNTf_SET(c,r,f)       \
	(r).fcm_fcmac_bbc1[0]=(((r).fcm_fcmac_bbc1[0] & ~((buint32_t)0xff << 16)) | \
		((((buint32_t)f) & 0xff) << 16))

#define bcm84756_a0_FCM_FCMAC_BBC1r_BBC_POLARITYf_GET(c,r)         \
	((((r).fcm_fcmac_bbc1[0]) >> 31) & 0x1)

#define bcm84756_a0_FCM_FCMAC_BBC1r_BBC_POLARITYf_SET(c,r,f)       \
	(r).fcm_fcmac_bbc1[0]=(((r).fcm_fcmac_bbc1[0] & ~((buint32_t)0x1 << 31)) | \
		((((buint32_t)f) & 0x1) << 31))


/*
 * These macros can be used to access FCM_FCMAC_BBC1.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_BBC1r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_BBC1r((c)),&((r)._fcm_fcmac_bbc1))

#define bcm84756_a0_WRITE_FCM_FCMAC_BBC1r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_BBC1r((c)),&((r)._fcm_fcmac_bbc1))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_BBC1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_BBcr_Recovery
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 BBcredit recovery BB CNT N register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  BB_SC_N          :
 *     This contains the BBcredit recovery BB SC N register value. The
 *     programmed value sets the BBcredit recovery interval at 2^BB SC N. When
 *     this value = 0, the BBcredit recovery function is disabled. Note : To
 *     change this register from a non-zero value to another non-zero value,
 *     is it necessary to write 0 to the field as an intermediate step during
 *     the value change operation (i.e. N[old] -> 0 -> N[new]). This is
 *     required to initialize the hardware-based BB RDY N and TX FRM N
 *     counters.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_BBCR_RECOVERYr(c) \
		(0x13100005 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_BBCR_RECOVERYr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_BBcr_Recovery.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_BBCR_RECOVERYr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_bbcr_recovery[1];
	buint32_t _fcm_fcmac_bbcr_recovery;
} bcm84756_a0_FCM_FCMAC_BBCR_RECOVERYr_t;

#define bcm84756_a0_FCM_FCMAC_BBCR_RECOVERYr_CLR(r)   \
            (r).fcm_fcmac_bbcr_recovery[0] = 0

#define bcm84756_a0_FCM_FCMAC_BBCR_RECOVERYr_SET(r,d) \
            (r).fcm_fcmac_bbcr_recovery[0] = d

#define bcm84756_a0_FCM_FCMAC_BBCR_RECOVERYr_GET(r)   \
            (r).fcm_fcmac_bbcr_recovery[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_BBCR_RECOVERYr_BB_SC_Nf_GET(c,r)         \
	(((r).fcm_fcmac_bbcr_recovery[0]) & 0xf)

#define bcm84756_a0_FCM_FCMAC_BBCR_RECOVERYr_BB_SC_Nf_SET(c,r,f)       \
	(r).fcm_fcmac_bbcr_recovery[0]=(((r).fcm_fcmac_bbcr_recovery[0] & ~((buint32_t)0xf)) | \
		(((buint32_t)f) & 0xf))


/*
 * These macros can be used to access FCM_FCMAC_BBcr_Recovery.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_BBCR_RECOVERYr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_BBCR_RECOVERYr((c)),&((r)._fcm_fcmac_bbcr_recovery))

#define bcm84756_a0_WRITE_FCM_FCMAC_BBCR_RECOVERYr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_BBCR_RECOVERYr((c)),&((r)._fcm_fcmac_bbcr_recovery))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_BBCR_RECOVERYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_BWWNX
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR BWWNX 7'h0C // Broadcast WWN Register bits 63:32 R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  BWWN_X           :
 *     Broadcast WWN[63:32].
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_BWWNXr(c) \
		(0x13100071 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_BWWNXr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_BWWNX.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_BWWNXr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_bwwnx[1];
	buint32_t _fcm_fcmac_bwwnx;
} bcm84756_a0_FCM_FCMAC_BWWNXr_t;

#define bcm84756_a0_FCM_FCMAC_BWWNXr_CLR(r)   \
            (r).fcm_fcmac_bwwnx[0] = 0

#define bcm84756_a0_FCM_FCMAC_BWWNXr_SET(r,d) \
            (r).fcm_fcmac_bwwnx[0] = d

#define bcm84756_a0_FCM_FCMAC_BWWNXr_GET(r)   \
            (r).fcm_fcmac_bwwnx[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_BWWNXr_BWWN_Xf_GET(c,r)         \
	((r).fcm_fcmac_bwwnx[0])

#define bcm84756_a0_FCM_FCMAC_BWWNXr_BWWN_Xf_SET(c,r,f)       \
	(r).fcm_fcmac_bwwnx[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_FCMAC_BWWNX.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_BWWNXr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_BWWNXr((c)),&((r)._fcm_fcmac_bwwnx))

#define bcm84756_a0_WRITE_FCM_FCMAC_BWWNXr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_BWWNXr((c)),&((r)._fcm_fcmac_bwwnx))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_BWWNXr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_BWWNY
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR BWWNY 7'h0D // Broadcast WWN Register bits 31:0 R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  BWWN_Y           :
 *     Broadcast WWN[31:00].
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_BWWNYr(c) \
		(0x13100072 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_BWWNYr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_BWWNY.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_BWWNYr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_bwwny[1];
	buint32_t _fcm_fcmac_bwwny;
} bcm84756_a0_FCM_FCMAC_BWWNYr_t;

#define bcm84756_a0_FCM_FCMAC_BWWNYr_CLR(r)   \
            (r).fcm_fcmac_bwwny[0] = 0

#define bcm84756_a0_FCM_FCMAC_BWWNYr_SET(r,d) \
            (r).fcm_fcmac_bwwny[0] = d

#define bcm84756_a0_FCM_FCMAC_BWWNYr_GET(r)   \
            (r).fcm_fcmac_bwwny[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_BWWNYr_BWWN_Yf_GET(c,r)         \
	((r).fcm_fcmac_bwwny[0])

#define bcm84756_a0_FCM_FCMAC_BWWNYr_BWWN_Yf_SET(c,r,f)       \
	(r).fcm_fcmac_bwwny[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_FCMAC_BWWNY.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_BWWNYr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_BWWNYr((c)),&((r)._fcm_fcmac_bwwny))

#define bcm84756_a0_WRITE_FCM_FCMAC_BWWNYr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_BWWNYr((c)),&((r)._fcm_fcmac_bwwny))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_BWWNYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_DAID
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR DAID 7'h09 // Destination Port Address ID Register R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  DAID_ID          :
 *     Destination ID.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_DAIDr(c) \
		(0x1310006e + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_DAIDr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_DAID.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_DAIDr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_daid[1];
	buint32_t _fcm_fcmac_daid;
} bcm84756_a0_FCM_FCMAC_DAIDr_t;

#define bcm84756_a0_FCM_FCMAC_DAIDr_CLR(r)   \
            (r).fcm_fcmac_daid[0] = 0

#define bcm84756_a0_FCM_FCMAC_DAIDr_SET(r,d) \
            (r).fcm_fcmac_daid[0] = d

#define bcm84756_a0_FCM_FCMAC_DAIDr_GET(r)   \
            (r).fcm_fcmac_daid[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_DAIDr_DAID_IDf_GET(c,r)         \
	(((r).fcm_fcmac_daid[0]) & 0xffffff)

#define bcm84756_a0_FCM_FCMAC_DAIDr_DAID_IDf_SET(c,r,f)       \
	(r).fcm_fcmac_daid[0]=(((r).fcm_fcmac_daid[0] & ~((buint32_t)0xffffff)) | \
		(((buint32_t)f) & 0xffffff))


/*
 * These macros can be used to access FCM_FCMAC_DAID.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_DAIDr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_DAIDr((c)),&((r)._fcm_fcmac_daid))

#define bcm84756_a0_WRITE_FCM_FCMAC_DAIDr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_DAIDr((c)),&((r)._fcm_fcmac_daid))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_DAIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_ELOSTC
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR ELOSTC 7'h18 // Event TO & Loss Of Sync TO counters (ro).
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  UNUSED           :
 *     This register is Unused. Any write clears reg elostc sync<=9'd0 and reg
 *     elostc event<=10'd0. Not readable. This is a word sync loss timeout
 *     function, but this is now handled by the fc mon block.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_ELOSTCr(c) \
		(0x1310007d + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_ELOSTCr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_ELOSTC.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_ELOSTCr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_elostc[1];
	buint32_t _fcm_fcmac_elostc;
} bcm84756_a0_FCM_FCMAC_ELOSTCr_t;

#define bcm84756_a0_FCM_FCMAC_ELOSTCr_CLR(r)   \
            (r).fcm_fcmac_elostc[0] = 0

#define bcm84756_a0_FCM_FCMAC_ELOSTCr_SET(r,d) \
            (r).fcm_fcmac_elostc[0] = d

#define bcm84756_a0_FCM_FCMAC_ELOSTCr_GET(r)   \
            (r).fcm_fcmac_elostc[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_ELOSTCr_UNUSEDf_GET(c,r)         \
	((r).fcm_fcmac_elostc[0])

#define bcm84756_a0_FCM_FCMAC_ELOSTCr_UNUSEDf_SET(c,r,f)       \
	(r).fcm_fcmac_elostc[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_FCMAC_ELOSTC.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_ELOSTCr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_ELOSTCr((c)),&((r)._fcm_fcmac_elostc))

#define bcm84756_a0_WRITE_FCM_FCMAC_ELOSTCr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_ELOSTCr((c)),&((r)._fcm_fcmac_elostc))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_ELOSTCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_EXP
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Exception Pending Register, write-1-to-clear. Except for bit 31 (EXP LD),
 *	 the FCMAC interrupt signal will be asserted when any Exception Pending Bit
 *	 [30:0] is set and is not masked by the corresponding bits in the Exception
 *	 Pending Mask Register. The signal will remain asserted until all of the
 *	 unmasked bits have been cleared via a write to the Exception pending
 *	 register with the corresponding bit set.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  EXP_OL           :
 *     Open link. This bit is set whenever the rx los loss-of-signal input
 *     signal is asserted by the analog front-end.
 *
 *  EXP_TF           :
 *     Transceiver fault. This bit is set whenever the i tx fault input signal
 *     is asserted by the analog front-end.
 *
 *  EXP_LLF          :
 *     Local link failure. This bit is set whenever the PSPE N-port state
 *     machine is in the LF2 state. EXP LLF is set when any link fail
 *     condition is detected, i.e. : (1) a Loss of Synchronization for more
 *     than a time out period (R T TOV) while not in the Offline state or (2)
 *     a Loss of Signal occurs while not in the Offline state when the No Fail
 *     On Loss of Signal configuration bit is clear in the Port Configuration
 *     Register or (3) Timeout (R T TOV) during the Link Reset Protocol. If
 *     Loss of Signal occurs then one or both of the TF and OL bits will also
 *     be set. This bit is CLEARED by a hardware reset or by a write to the
 *     Exception Pending Register with EXP LLF set.
 *
 *  EXP_RLF          :
 *     Remote link failure. This bit is set whenever the PSPE N-port state
 *     machine is in the LF1 state.
 *
 *  EXP_LLR          :
 *     Local link reset. This bit is set whenever the PSPE N-port state
 *     machine is in the LR1 state.
 *
 *  EXP_RLR          :
 *     Remote link reset. This bit is set whenever the PSPE N-port state
 *     machine is in the LR2 state.
 *
 *  EXP_NPE          :
 *     N Port protocol error. This bit is SET whenever the Primitive Sequence
 *     Protocol Engine detects a protocol error; i.e., whenever the LRR
 *     primitive sequence is received and recognized and the Primitive
 *     Sequence Protocol Engine is currently in the ACTIVE state. This bit is
 *     CLEARED by a hardware reset or by a write to the Exception Pending
 *     Register with EXP NPE set.
 *
 *  EXP_WCD          :
 *     WWN Compare Done.
 *
 *  EXP_CLSR         :
 *     CLS received.
 *
 *  EXP_TXFRM_EDTOV  :
 *     This bit is set when a TX Frame EDTOV timeout is detected (frame TX
 *     ready with no TX BBCredit for 2 secs). For simulation and test, when
 *     PCFG1 TTM is set timeout is shortened to approx 4uSecs.
 *
 *  EXP_MRK          :
 *     MRKtx received.
 *
 *  EXP_LT           :
 *     Loop timeout.
 *
 *  EXP_LOF          :
 *     L port open failure.
 *
 *  EXP_ACTIVE       :
 *     This bit is set whenever the N-port state machine (PSPE) is in the
 *     ACTIVE state.
 *
 *  EXP_AF0R         :
 *     ARB(f0) primitive signal received.
 *
 *  EXP_LIPR         :
 *     Loop initialization primitive received.
 *
 *  EXP_RBBC0        :
 *     Residual BB Credit VC 0 overflow. This bit is set if the residual TX
 *     BBCredit counter exceeds the non-zero login BBCredit established at
 *     port login.
 *
 *  EXP_RBBC_ORUN    :
 *     This bit is set when a frame is received when the RX BBCredit is 0.
 *     This indicates an RX BBCredit Overflow condition. This will cause the
 *     N-Port PSPE to enter the LR1 state.
 *
 *  EXP_TLOS         :
 *     This bit is set when the Loss-of-word-sync timer expires. This is timer
 *     is based on (N * R T TOV).
 *
 *  EXP_SAI          :
 *      Signal Acquired interrupt. This bit is set when the RX LOS input from
 *     the analog front-end is deasserted.
 *
 *  EXP_LPB3X        :
 *     Series of three LPB's received.
 *
 *  EXP_LPE3X        :
 *     Series of three LPE's received.
 *
 *  EXP_EOVF         :
 *     EFIFO Overflow.
 *
 *  EXP_WUP          :
 *     WWN Updated.
 *
 *  EXP_LR           :
 *     This bit is set when a LR primitive sequence ordered set is received.
 *
 *  EXP_LRR          :
 *     This bit is set when a LRR primitive sequence ordered set is received.
 *
 *  EXP_OLS          :
 *     This bit is set when an OLS primitive sequence ordered set is received.
 *
 *  EXP_NOS          :
 *     This bit is set when a NOS primitive sequence ordered set is received.
 *
 *  EXP_IDLE         :
 *     This bit is set when an IDLE primitive signal ordered set is received.
 *
 *  EXP_LPBR         :
 *     LPB received.
 *
 *  EXP_LPER         :
 *     LPE received.
 *
 *  EXP_LD           :
 *     Link down exception. This bit is set if the port is in an INIT state
 *     (POI) or if it is in OLDPORT but not ACTIVE
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_EXPr(c) \
		(0x13100068 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_EXPr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_EXP.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_EXPr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_exp[1];
	buint32_t _fcm_fcmac_exp;
} bcm84756_a0_FCM_FCMAC_EXPr_t;

#define bcm84756_a0_FCM_FCMAC_EXPr_CLR(r)   \
            (r).fcm_fcmac_exp[0] = 0

#define bcm84756_a0_FCM_FCMAC_EXPr_SET(r,d) \
            (r).fcm_fcmac_exp[0] = d

#define bcm84756_a0_FCM_FCMAC_EXPr_GET(r)   \
            (r).fcm_fcmac_exp[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_OLf_GET(c,r)         \
	(((r).fcm_fcmac_exp[0]) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_OLf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_TFf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_TFf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LLFf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 2) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LLFf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 2)) | \
		((((buint32_t)f) & 0x1) << 2))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_RLFf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 3) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_RLFf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 3)) | \
		((((buint32_t)f) & 0x1) << 3))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LLRf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 4) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LLRf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 4)) | \
		((((buint32_t)f) & 0x1) << 4))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_RLRf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 5) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_RLRf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 5)) | \
		((((buint32_t)f) & 0x1) << 5))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_NPEf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 6) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_NPEf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 6)) | \
		((((buint32_t)f) & 0x1) << 6))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_WCDf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 7) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_WCDf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 7)) | \
		((((buint32_t)f) & 0x1) << 7))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_CLSRf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_CLSRf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_TXFRM_EDTOVf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 9) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_TXFRM_EDTOVf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 9)) | \
		((((buint32_t)f) & 0x1) << 9))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_MRKf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 10) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_MRKf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 10)) | \
		((((buint32_t)f) & 0x1) << 10))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LTf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 11) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LTf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 11)) | \
		((((buint32_t)f) & 0x1) << 11))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LOFf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 12) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LOFf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 12)) | \
		((((buint32_t)f) & 0x1) << 12))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_ACTIVEf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 13) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_ACTIVEf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 13)) | \
		((((buint32_t)f) & 0x1) << 13))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_AF0Rf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 14) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_AF0Rf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 14)) | \
		((((buint32_t)f) & 0x1) << 14))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LIPRf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 15) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LIPRf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 15)) | \
		((((buint32_t)f) & 0x1) << 15))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_RBBC0f_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 16) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_RBBC0f_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 16)) | \
		((((buint32_t)f) & 0x1) << 16))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_RBBC_ORUNf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 17) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_RBBC_ORUNf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 17)) | \
		((((buint32_t)f) & 0x1) << 17))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_TLOSf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 18) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_TLOSf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 18)) | \
		((((buint32_t)f) & 0x1) << 18))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_SAIf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 19) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_SAIf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 19)) | \
		((((buint32_t)f) & 0x1) << 19))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LPB3Xf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 20) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LPB3Xf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 20)) | \
		((((buint32_t)f) & 0x1) << 20))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LPE3Xf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 21) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LPE3Xf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 21)) | \
		((((buint32_t)f) & 0x1) << 21))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_EOVFf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 22) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_EOVFf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 22)) | \
		((((buint32_t)f) & 0x1) << 22))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_WUPf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 23) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_WUPf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 23)) | \
		((((buint32_t)f) & 0x1) << 23))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LRf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 24) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LRf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 24)) | \
		((((buint32_t)f) & 0x1) << 24))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LRRf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 25) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LRRf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 25)) | \
		((((buint32_t)f) & 0x1) << 25))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_OLSf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 26) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_OLSf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 26)) | \
		((((buint32_t)f) & 0x1) << 26))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_NOSf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 27) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_NOSf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 27)) | \
		((((buint32_t)f) & 0x1) << 27))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_IDLEf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 28) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_IDLEf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 28)) | \
		((((buint32_t)f) & 0x1) << 28))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LPBRf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 29) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LPBRf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 29)) | \
		((((buint32_t)f) & 0x1) << 29))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LPERf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 30) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LPERf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 30)) | \
		((((buint32_t)f) & 0x1) << 30))

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LDf_GET(c,r)         \
	((((r).fcm_fcmac_exp[0]) >> 31) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPr_EXP_LDf_SET(c,r,f)       \
	(r).fcm_fcmac_exp[0]=(((r).fcm_fcmac_exp[0] & ~((buint32_t)0x1 << 31)) | \
		((((buint32_t)f) & 0x1) << 31))


/*
 * These macros can be used to access FCM_FCMAC_EXP.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_EXPr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_EXPr((c)),&((r)._fcm_fcmac_exp))

#define bcm84756_a0_WRITE_FCM_FCMAC_EXPr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_EXPr((c)),&((r)._fcm_fcmac_exp))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_EXPr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_EXPM_HOST
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Exception pending mask register for HOST interrupts.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  EXPM_OL          :
 *     Open link mask bit.
 *
 *  EXPM_TF          :
 *     Transceiver fault mask bit.
 *
 *  EXPM_LLF         :
 *     Local link failure mask bit.
 *
 *  EXPM_RLF         :
 *     Remote link failure mask bit.
 *
 *  EXPM_LLR         :
 *     Local link reset mask bit.
 *
 *  EXPM_RLR         :
 *     Remote link reset mask bit.
 *
 *  EXPM_NPE         :
 *     N Port protocol error mask bit.
 *
 *  EXPM_WCD         :
 *     WWN Compare Done mask bit.
 *
 *  EXPM_CLSR        :
 *     CLS received mask bit.
 *
 *  EXPM_TXFRM_EDTOV :
 *     Mask bit for EXP TXFRM EDTOV.
 *
 *  EXPM_MRK         :
 *     MRKtx received mask bit.
 *
 *  EXPM_LT          :
 *     Link timeout mask bit.
 *
 *  EXPM_LOF         :
 *     L port open failure mask bit.
 *
 *  EXPM_ACTIVE      :
 *     Mask bit for EXP ACTIVE interrupt bit.
 *
 *  EXPM_AF0R        :
 *     ARB(f0) primitive signal received mask bit.
 *
 *  EXPM_LIPR        :
 *     Loop initialization primitive received mask bit.
 *
 *  EXPM_RBBC0       :
 *     Residual BB Credit VC 0 overflow mask bit.
 *
 *  EXPM_RBBC_ORUN   :
 *     RX BBCredit Overflow mask bit.
 *
 *  EXPM_TLOS        :
 *     Timer based Loss of Sync interrupt, R T TOV timer mask bit.
 *
 *  EXPM_SAI         :
 *     Signal Acquired interrupt mask bit.
 *
 *  EXPM_LPB3X       :
 *     Series of three LPB's received mask bit.
 *
 *  EXPM_LPE3X       :
 *     Series of three LPE's received mask bit.
 *
 *  EXPM_EOVF        :
 *     EFIFO Overflow mask bit.
 *
 *  EXPM_WUP         :
 *     WWN Updated mask bit.
 *
 *  EXPM_LR          :
 *     LR link reset received mask bit.
 *
 *  EXPM_LRR         :
 *     LRR link reset response mask bit.
 *
 *  EXPM_OLS         :
 *     OLS Offline sequence received mask bit.
 *
 *  EXPM_NOS         :
 *     NOS Not Operational Sequence received mask bit.
 *
 *  EXPM_IDLE        :
 *     IDLE received mask bit.
 *
 *  EXPM_LPBR        :
 *     LPB received mask bit.
 *
 *  EXPM_LPER        :
 *     LPE received mask bit.
 *
 *  EXPM_LD          :
 *     Link down exception mask bit.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr(c) \
		(0x13100069 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_EXPM_HOST.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_expm_host[1];
	buint32_t _fcm_fcmac_expm_host;
} bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_t;

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_CLR(r)   \
            (r).fcm_fcmac_expm_host[0] = 0

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_SET(r,d) \
            (r).fcm_fcmac_expm_host[0] = d

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_GET(r)   \
            (r).fcm_fcmac_expm_host[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_OLf_GET(c,r)         \
	(((r).fcm_fcmac_expm_host[0]) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_OLf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_TFf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_TFf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LLFf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 2) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LLFf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 2)) | \
		((((buint32_t)f) & 0x1) << 2))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_RLFf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 3) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_RLFf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 3)) | \
		((((buint32_t)f) & 0x1) << 3))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LLRf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 4) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LLRf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 4)) | \
		((((buint32_t)f) & 0x1) << 4))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_RLRf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 5) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_RLRf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 5)) | \
		((((buint32_t)f) & 0x1) << 5))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_NPEf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 6) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_NPEf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 6)) | \
		((((buint32_t)f) & 0x1) << 6))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_WCDf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 7) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_WCDf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 7)) | \
		((((buint32_t)f) & 0x1) << 7))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_CLSRf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_CLSRf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_TXFRM_EDTOVf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 9) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_TXFRM_EDTOVf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 9)) | \
		((((buint32_t)f) & 0x1) << 9))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_MRKf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 10) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_MRKf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 10)) | \
		((((buint32_t)f) & 0x1) << 10))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LTf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 11) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LTf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 11)) | \
		((((buint32_t)f) & 0x1) << 11))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LOFf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 12) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LOFf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 12)) | \
		((((buint32_t)f) & 0x1) << 12))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_ACTIVEf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 13) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_ACTIVEf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 13)) | \
		((((buint32_t)f) & 0x1) << 13))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_AF0Rf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 14) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_AF0Rf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 14)) | \
		((((buint32_t)f) & 0x1) << 14))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LIPRf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 15) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LIPRf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 15)) | \
		((((buint32_t)f) & 0x1) << 15))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_RBBC0f_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 16) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_RBBC0f_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 16)) | \
		((((buint32_t)f) & 0x1) << 16))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_RBBC_ORUNf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 17) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_RBBC_ORUNf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 17)) | \
		((((buint32_t)f) & 0x1) << 17))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_TLOSf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 18) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_TLOSf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 18)) | \
		((((buint32_t)f) & 0x1) << 18))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_SAIf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 19) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_SAIf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 19)) | \
		((((buint32_t)f) & 0x1) << 19))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LPB3Xf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 20) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LPB3Xf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 20)) | \
		((((buint32_t)f) & 0x1) << 20))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LPE3Xf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 21) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LPE3Xf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 21)) | \
		((((buint32_t)f) & 0x1) << 21))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_EOVFf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 22) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_EOVFf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 22)) | \
		((((buint32_t)f) & 0x1) << 22))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_WUPf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 23) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_WUPf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 23)) | \
		((((buint32_t)f) & 0x1) << 23))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LRf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 24) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LRf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 24)) | \
		((((buint32_t)f) & 0x1) << 24))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LRRf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 25) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LRRf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 25)) | \
		((((buint32_t)f) & 0x1) << 25))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_OLSf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 26) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_OLSf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 26)) | \
		((((buint32_t)f) & 0x1) << 26))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_NOSf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 27) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_NOSf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 27)) | \
		((((buint32_t)f) & 0x1) << 27))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_IDLEf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 28) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_IDLEf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 28)) | \
		((((buint32_t)f) & 0x1) << 28))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LPBRf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 29) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LPBRf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 29)) | \
		((((buint32_t)f) & 0x1) << 29))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LPERf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 30) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LPERf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 30)) | \
		((((buint32_t)f) & 0x1) << 30))

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LDf_GET(c,r)         \
	((((r).fcm_fcmac_expm_host[0]) >> 31) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_HOSTr_EXPM_LDf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_host[0]=(((r).fcm_fcmac_expm_host[0] & ~((buint32_t)0x1 << 31)) | \
		((((buint32_t)f) & 0x1) << 31))


/*
 * These macros can be used to access FCM_FCMAC_EXPM_HOST.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_EXPM_HOSTr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_EXPM_HOSTr((c)),&((r)._fcm_fcmac_expm_host))

#define bcm84756_a0_WRITE_FCM_FCMAC_EXPM_HOSTr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_EXPM_HOSTr((c)),&((r)._fcm_fcmac_expm_host))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_EXPM_HOSTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_EXPM_LOCAL
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Exception pending mask register for LOCAL (8051) interrupts.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  EXPM_OL          :
 *     Open link mask bit.
 *
 *  EXPM_TF          :
 *     Transceiver fault mask bit.
 *
 *  EXPM_LLF         :
 *     Local link failure mask bit.
 *
 *  EXPM_RLF         :
 *     Remote link failure mask bit.
 *
 *  EXPM_LLR         :
 *     Local link reset mask bit.
 *
 *  EXPM_RLR         :
 *     Remote link reset mask bit.
 *
 *  EXPM_NPE         :
 *     N Port protocol error mask bit.
 *
 *  EXPM_WCD         :
 *     WWN Compare Done mask bit.
 *
 *  EXPM_CLSR        :
 *     CLS received mask bit.
 *
 *  EXPM_TXFRM_EDTOV :
 *     Mask bit for EXP TXFRM EDTOV.
 *
 *  EXPM_MRK         :
 *     MRKtx received mask bit.
 *
 *  EXPM_LT          :
 *     Link timeout mask bit.
 *
 *  EXPM_LOF         :
 *     L port open failure mask bit.
 *
 *  EXPM_ACTIVE      :
 *     Mask bit for EXP ACTIVE interrupt bit.
 *
 *  EXPM_AF0R        :
 *     ARB(f0) primitive signal received mask bit.
 *
 *  EXPM_LIPR        :
 *     Loop initialization primitive received mask bit.
 *
 *  EXPM_RBBC0       :
 *     Residual BB Credit VC 0 overflow mask bit.
 *
 *  EXPM_RBBC_ORUN   :
 *     RX BBCredit Overflow mask bit.
 *
 *  EXPM_TLOS        :
 *     Timer based Loss of Sync interrupt, R T TOV timer mask bit.
 *
 *  EXPM_SAI         :
 *     Signal Acquired interrupt mask bit.
 *
 *  EXPM_LPB3X       :
 *     Series of three LPB's received mask bit.
 *
 *  EXPM_LPE3X       :
 *     Series of three LPE's received mask bit.
 *
 *  EXPM_EOVF        :
 *     EFIFO Overflow mask bit.
 *
 *  EXPM_WUP         :
 *     WWN Updated mask bit.
 *
 *  EXPM_LR          :
 *     LR link reset received mask bit.
 *
 *  EXPM_LRR         :
 *     LRR link reset response mask bit.
 *
 *  EXPM_OLS         :
 *     OLS Offline sequence received mask bit.
 *
 *  EXPM_NOS         :
 *     NOS Not Operational Sequence received mask bit.
 *
 *  EXPM_IDLE        :
 *     IDLE received mask bit.
 *
 *  EXPM_LPBR        :
 *     LPB received mask bit.
 *
 *  EXPM_LPER        :
 *     LPE received mask bit.
 *
 *  EXPM_LD          :
 *     Link down exception mask bit.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr(c) \
		(0x1310006a + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_EXPM_LOCAL.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_expm_local[1];
	buint32_t _fcm_fcmac_expm_local;
} bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_t;

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_CLR(r)   \
            (r).fcm_fcmac_expm_local[0] = 0

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_SET(r,d) \
            (r).fcm_fcmac_expm_local[0] = d

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_GET(r)   \
            (r).fcm_fcmac_expm_local[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_OLf_GET(c,r)         \
	(((r).fcm_fcmac_expm_local[0]) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_OLf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_TFf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_TFf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LLFf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 2) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LLFf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 2)) | \
		((((buint32_t)f) & 0x1) << 2))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_RLFf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 3) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_RLFf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 3)) | \
		((((buint32_t)f) & 0x1) << 3))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LLRf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 4) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LLRf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 4)) | \
		((((buint32_t)f) & 0x1) << 4))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_RLRf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 5) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_RLRf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 5)) | \
		((((buint32_t)f) & 0x1) << 5))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_NPEf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 6) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_NPEf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 6)) | \
		((((buint32_t)f) & 0x1) << 6))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_WCDf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 7) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_WCDf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 7)) | \
		((((buint32_t)f) & 0x1) << 7))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_CLSRf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_CLSRf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_TXFRM_EDTOVf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 9) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_TXFRM_EDTOVf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 9)) | \
		((((buint32_t)f) & 0x1) << 9))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_MRKf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 10) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_MRKf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 10)) | \
		((((buint32_t)f) & 0x1) << 10))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LTf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 11) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LTf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 11)) | \
		((((buint32_t)f) & 0x1) << 11))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LOFf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 12) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LOFf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 12)) | \
		((((buint32_t)f) & 0x1) << 12))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_ACTIVEf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 13) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_ACTIVEf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 13)) | \
		((((buint32_t)f) & 0x1) << 13))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_AF0Rf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 14) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_AF0Rf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 14)) | \
		((((buint32_t)f) & 0x1) << 14))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LIPRf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 15) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LIPRf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 15)) | \
		((((buint32_t)f) & 0x1) << 15))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_RBBC0f_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 16) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_RBBC0f_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 16)) | \
		((((buint32_t)f) & 0x1) << 16))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_RBBC_ORUNf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 17) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_RBBC_ORUNf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 17)) | \
		((((buint32_t)f) & 0x1) << 17))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_TLOSf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 18) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_TLOSf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 18)) | \
		((((buint32_t)f) & 0x1) << 18))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_SAIf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 19) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_SAIf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 19)) | \
		((((buint32_t)f) & 0x1) << 19))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LPB3Xf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 20) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LPB3Xf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 20)) | \
		((((buint32_t)f) & 0x1) << 20))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LPE3Xf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 21) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LPE3Xf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 21)) | \
		((((buint32_t)f) & 0x1) << 21))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_EOVFf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 22) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_EOVFf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 22)) | \
		((((buint32_t)f) & 0x1) << 22))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_WUPf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 23) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_WUPf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 23)) | \
		((((buint32_t)f) & 0x1) << 23))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LRf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 24) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LRf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 24)) | \
		((((buint32_t)f) & 0x1) << 24))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LRRf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 25) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LRRf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 25)) | \
		((((buint32_t)f) & 0x1) << 25))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_OLSf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 26) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_OLSf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 26)) | \
		((((buint32_t)f) & 0x1) << 26))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_NOSf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 27) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_NOSf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 27)) | \
		((((buint32_t)f) & 0x1) << 27))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_IDLEf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 28) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_IDLEf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 28)) | \
		((((buint32_t)f) & 0x1) << 28))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LPBRf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 29) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LPBRf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 29)) | \
		((((buint32_t)f) & 0x1) << 29))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LPERf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 30) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LPERf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 30)) | \
		((((buint32_t)f) & 0x1) << 30))

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LDf_GET(c,r)         \
	((((r).fcm_fcmac_expm_local[0]) >> 31) & 0x1)

#define bcm84756_a0_FCM_FCMAC_EXPM_LOCALr_EXPM_LDf_SET(c,r,f)       \
	(r).fcm_fcmac_expm_local[0]=(((r).fcm_fcmac_expm_local[0] & ~((buint32_t)0x1 << 31)) | \
		((((buint32_t)f) & 0x1) << 31))


/*
 * These macros can be used to access FCM_FCMAC_EXPM_LOCAL.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_EXPM_LOCALr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_EXPM_LOCALr((c)),&((r)._fcm_fcmac_expm_local))

#define bcm84756_a0_WRITE_FCM_FCMAC_EXPM_LOCALr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_EXPM_LOCALr((c)),&((r)._fcm_fcmac_expm_local))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_EXPM_LOCALr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_FCFG
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR FCFG 7'h1B // Force configuration reg R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  CFG_FORCE_AC     :
 *     text.
 *
 *  CFG_FORCE_LR1    :
 *     text.
 *
 *  CFG_FORCE_LR2    :
 *     text.
 *
 *  CFG_FORCE_LR3    :
 *     text.
 *
 *  CFG_FORCE_LF1    :
 *     text.
 *
 *  CFG_FORCE_LF2    :
 *     text.
 *
 *  CFG_FORCE_OL3    :
 *     text.
 *
 *  CFG_FORCE_OL2    :
 *     text.
 *
 *  CFG_FORCE_OL1D   :
 *     text.
 *
 *  CFG_FORCE_OL1C   :
 *     text.
 *
 *  CFG_FORCE_MON    :
 *     text.
 *
 *  CFG_FORCE_ARB    :
 *     text.
 *
 *  CFG_FORCE_ARBW   :
 *     text.
 *
 *  CFG_FORCE_OPEN   :
 *     text.
 *
 *  CFG_FORCE_OPND   :
 *     text.
 *
 *  CFG_FORCE_XCLS   :
 *     text.
 *
 *  CFG_FORCE_RCLS   :
 *     text.
 *
 *  CFG_FORCE_XFER   :
 *     text.
 *
 *  CFG_FORCE_INIT   :
 *     text.
 *
 *  CFG_FORCE_OINI   :
 *     text.
 *
 *  CFG_FORCE_OLDP   :
 *     text.
 *
 *  CFG_FORCE_POI    :
 *     text.
 *
 *  CFG_FORCE_OINI_CLS :
 *     text.
 *
 *  CFG_FORCE_RELS   :
 *     Force Configuration Release control bit. SET this bit will make all FRC
 *     CFG ST [22:0] bits to 0 and CLEAR all the force requests. It will clear
 *     the force after the state is entered and the State Machine continues
 *     with the normal processing.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_FCFGr(c) \
		(0x13100080 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_FCFGr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_FCFG.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_FCFGr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_fcfg[1];
	buint32_t _fcm_fcmac_fcfg;
} bcm84756_a0_FCM_FCMAC_FCFGr_t;

#define bcm84756_a0_FCM_FCMAC_FCFGr_CLR(r)   \
            (r).fcm_fcmac_fcfg[0] = 0

#define bcm84756_a0_FCM_FCMAC_FCFGr_SET(r,d) \
            (r).fcm_fcmac_fcfg[0] = d

#define bcm84756_a0_FCM_FCMAC_FCFGr_GET(r)   \
            (r).fcm_fcmac_fcfg[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_ACf_GET(c,r)         \
	(((r).fcm_fcmac_fcfg[0]) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_ACf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_LR1f_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_LR1f_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_LR2f_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 2) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_LR2f_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 2)) | \
		((((buint32_t)f) & 0x1) << 2))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_LR3f_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 3) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_LR3f_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 3)) | \
		((((buint32_t)f) & 0x1) << 3))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_LF1f_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 4) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_LF1f_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 4)) | \
		((((buint32_t)f) & 0x1) << 4))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_LF2f_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 5) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_LF2f_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 5)) | \
		((((buint32_t)f) & 0x1) << 5))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OL3f_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 6) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OL3f_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 6)) | \
		((((buint32_t)f) & 0x1) << 6))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OL2f_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 7) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OL2f_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 7)) | \
		((((buint32_t)f) & 0x1) << 7))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OL1Df_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OL1Df_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OL1Cf_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 9) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OL1Cf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 9)) | \
		((((buint32_t)f) & 0x1) << 9))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_MONf_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 10) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_MONf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 10)) | \
		((((buint32_t)f) & 0x1) << 10))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_ARBf_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 11) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_ARBf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 11)) | \
		((((buint32_t)f) & 0x1) << 11))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_ARBWf_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 12) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_ARBWf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 12)) | \
		((((buint32_t)f) & 0x1) << 12))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OPENf_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 13) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OPENf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 13)) | \
		((((buint32_t)f) & 0x1) << 13))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OPNDf_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 14) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OPNDf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 14)) | \
		((((buint32_t)f) & 0x1) << 14))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_XCLSf_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 15) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_XCLSf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 15)) | \
		((((buint32_t)f) & 0x1) << 15))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_RCLSf_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 16) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_RCLSf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 16)) | \
		((((buint32_t)f) & 0x1) << 16))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_XFERf_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 17) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_XFERf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 17)) | \
		((((buint32_t)f) & 0x1) << 17))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_INITf_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 18) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_INITf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 18)) | \
		((((buint32_t)f) & 0x1) << 18))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OINIf_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 19) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OINIf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 19)) | \
		((((buint32_t)f) & 0x1) << 19))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OLDPf_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 20) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OLDPf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 20)) | \
		((((buint32_t)f) & 0x1) << 20))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_POIf_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 21) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_POIf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 21)) | \
		((((buint32_t)f) & 0x1) << 21))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OINI_CLSf_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 22) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_OINI_CLSf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 22)) | \
		((((buint32_t)f) & 0x1) << 22))

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_RELSf_GET(c,r)         \
	((((r).fcm_fcmac_fcfg[0]) >> 23) & 0x1)

#define bcm84756_a0_FCM_FCMAC_FCFGr_CFG_FORCE_RELSf_SET(c,r,f)       \
	(r).fcm_fcmac_fcfg[0]=(((r).fcm_fcmac_fcfg[0] & ~((buint32_t)0x1 << 23)) | \
		((((buint32_t)f) & 0x1) << 23))


/*
 * These macros can be used to access FCM_FCMAC_FCFG.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_FCFGr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_FCFGr((c)),&((r)._fcm_fcmac_fcfg))

#define bcm84756_a0_WRITE_FCM_FCMAC_FCFGr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_FCFGr((c)),&((r)._fcm_fcmac_fcfg))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_FCFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_FRXB0
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR FRXB0 7'h07 // Free RX Buffer Counter reg R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FRXB_FREE_RXB_CNT :
 *     Free receiver buffer count. NOTE : The programmed values of FRXB FREE
 *     RXB CNT and FCM FCMAC MAXFRMLEN CONFIG must be consistent with each
 *     other, and must also be consistent with the hard-coded size of the RX
 *     Frame Buffer (0x2000 32-bit words). As a guideline : Program the FRXB
 *     FREE RXB CNT = 0x2000 / FCM FCMAC MAXFRMLEN CONFIG; i.e. with FCM FCMAC
 *     MAXFRMLEN CONFIG programmed to (default) 0x217, FRXB FREE RXB CNT
 *     should be programmed to (default) 0xf. This field should be loaded with
 *     the maximum number of available receive buffers This value is
 *     incremented and decremented as frames arrive at the ingress pipeline,
 *     and as buffers are made available as calculated by the BB Credit shim.
 *
 *  FRXB_R_RDY_TX_PEND_CNT :
 *     RRDY transmit pending count. Displays the contents of the R RDY
 *     Transmit Pending Counter. If the value of R RDY Tx CNT is greater than
 *     zero then an R RDY Primitive Signal should be transmitted. The counter
 *     is incremented once for each occurrence of the CREDIT# input signal
 *     being detected asserted. It is decremented whenever an R RDY is
 *     transmitted.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_FRXB0r(c) \
		(0x1310006c + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_FRXB0r_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_FRXB0.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_FRXB0r_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_frxb0[1];
	buint32_t _fcm_fcmac_frxb0;
} bcm84756_a0_FCM_FCMAC_FRXB0r_t;

#define bcm84756_a0_FCM_FCMAC_FRXB0r_CLR(r)   \
            (r).fcm_fcmac_frxb0[0] = 0

#define bcm84756_a0_FCM_FCMAC_FRXB0r_SET(r,d) \
            (r).fcm_fcmac_frxb0[0] = d

#define bcm84756_a0_FCM_FCMAC_FRXB0r_GET(r)   \
            (r).fcm_fcmac_frxb0[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_FRXB0r_FRXB_FREE_RXB_CNTf_GET(c,r)         \
	(((r).fcm_fcmac_frxb0[0]) & 0x1f)

#define bcm84756_a0_FCM_FCMAC_FRXB0r_FRXB_FREE_RXB_CNTf_SET(c,r,f)       \
	(r).fcm_fcmac_frxb0[0]=(((r).fcm_fcmac_frxb0[0] & ~((buint32_t)0x1f)) | \
		(((buint32_t)f) & 0x1f))

#define bcm84756_a0_FCM_FCMAC_FRXB0r_FRXB_R_RDY_TX_PEND_CNTf_GET(c,r)         \
	((((r).fcm_fcmac_frxb0[0]) >> 5) & 0x1f)

#define bcm84756_a0_FCM_FCMAC_FRXB0r_FRXB_R_RDY_TX_PEND_CNTf_SET(c,r,f)       \
	(r).fcm_fcmac_frxb0[0]=(((r).fcm_fcmac_frxb0[0] & ~((buint32_t)0x1f << 5)) | \
		((((buint32_t)f) & 0x1f) << 5))


/*
 * These macros can be used to access FCM_FCMAC_FRXB0.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_FRXB0r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_FRXB0r((c)),&((r)._fcm_fcmac_frxb0))

#define bcm84756_a0_WRITE_FCM_FCMAC_FRXB0r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_FRXB0r((c)),&((r)._fcm_fcmac_frxb0))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_FRXB0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_FRXB1
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Unused.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FRXB_FREE_RXB_CNT :
 *     Free receiver buffer count.
 *
 *  FRXB_R_RDY_TX_PEND_CNT :
 *     RRDY transmit pending count.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_FRXB1r(c) \
		(0x1310007f + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_FRXB1r_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_FRXB1.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_FRXB1r_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_frxb1[1];
	buint32_t _fcm_fcmac_frxb1;
} bcm84756_a0_FCM_FCMAC_FRXB1r_t;

#define bcm84756_a0_FCM_FCMAC_FRXB1r_CLR(r)   \
            (r).fcm_fcmac_frxb1[0] = 0

#define bcm84756_a0_FCM_FCMAC_FRXB1r_SET(r,d) \
            (r).fcm_fcmac_frxb1[0] = d

#define bcm84756_a0_FCM_FCMAC_FRXB1r_GET(r)   \
            (r).fcm_fcmac_frxb1[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_FRXB1r_FRXB_FREE_RXB_CNTf_GET(c,r)         \
	(((r).fcm_fcmac_frxb1[0]) & 0x1f)

#define bcm84756_a0_FCM_FCMAC_FRXB1r_FRXB_FREE_RXB_CNTf_SET(c,r,f)       \
	(r).fcm_fcmac_frxb1[0]=(((r).fcm_fcmac_frxb1[0] & ~((buint32_t)0x1f)) | \
		(((buint32_t)f) & 0x1f))

#define bcm84756_a0_FCM_FCMAC_FRXB1r_FRXB_R_RDY_TX_PEND_CNTf_GET(c,r)         \
	((((r).fcm_fcmac_frxb1[0]) >> 5) & 0x1f)

#define bcm84756_a0_FCM_FCMAC_FRXB1r_FRXB_R_RDY_TX_PEND_CNTf_SET(c,r,f)       \
	(r).fcm_fcmac_frxb1[0]=(((r).fcm_fcmac_frxb1[0] & ~((buint32_t)0x1f << 5)) | \
		((((buint32_t)f) & 0x1f) << 5))


/*
 * These macros can be used to access FCM_FCMAC_FRXB1.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_FRXB1r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_FRXB1r((c)),&((r)._fcm_fcmac_frxb1))

#define bcm84756_a0_WRITE_FCM_FCMAC_FRXB1r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_FRXB1r((c)),&((r)._fcm_fcmac_frxb1))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_FRXB1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_LPCM
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Loop Port State Register. Reserved for diagnostics only.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  LPCM_LPRQ        :
 *     L port request.
 *
 *  LPCM_CBLF        :
 *     Clear Blocking LISM frame.
 *
 *  LPCM_LPST        :
 *     Loop port LPSM state.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_LPCMr(c) \
		(0x13100066 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_LPCMr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_LPCM.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_LPCMr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_lpcm[1];
	buint32_t _fcm_fcmac_lpcm;
} bcm84756_a0_FCM_FCMAC_LPCMr_t;

#define bcm84756_a0_FCM_FCMAC_LPCMr_CLR(r)   \
            (r).fcm_fcmac_lpcm[0] = 0

#define bcm84756_a0_FCM_FCMAC_LPCMr_SET(r,d) \
            (r).fcm_fcmac_lpcm[0] = d

#define bcm84756_a0_FCM_FCMAC_LPCMr_GET(r)   \
            (r).fcm_fcmac_lpcm[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_LPCMr_LPCM_LPRQf_GET(c,r)         \
	(((r).fcm_fcmac_lpcm[0]) & 0x1f)

#define bcm84756_a0_FCM_FCMAC_LPCMr_LPCM_LPRQf_SET(c,r,f)       \
	(r).fcm_fcmac_lpcm[0]=(((r).fcm_fcmac_lpcm[0] & ~((buint32_t)0x1f)) | \
		(((buint32_t)f) & 0x1f))

#define bcm84756_a0_FCM_FCMAC_LPCMr_LPCM_CBLFf_GET(c,r)         \
	((((r).fcm_fcmac_lpcm[0]) >> 5) & 0x1)

#define bcm84756_a0_FCM_FCMAC_LPCMr_LPCM_CBLFf_SET(c,r,f)       \
	(r).fcm_fcmac_lpcm[0]=(((r).fcm_fcmac_lpcm[0] & ~((buint32_t)0x1 << 5)) | \
		((((buint32_t)f) & 0x1) << 5))

#define bcm84756_a0_FCM_FCMAC_LPCMr_LPCM_LPSTf_GET(c,r)         \
	((((r).fcm_fcmac_lpcm[0]) >> 8) & 0x1f)

#define bcm84756_a0_FCM_FCMAC_LPCMr_LPCM_LPSTf_SET(c,r,f)       \
	(r).fcm_fcmac_lpcm[0]=(((r).fcm_fcmac_lpcm[0] & ~((buint32_t)0x1f << 8)) | \
		((((buint32_t)f) & 0x1f) << 8))


/*
 * These macros can be used to access FCM_FCMAC_LPCM.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_LPCMr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_LPCMr((c)),&((r)._fcm_fcmac_lpcm))

#define bcm84756_a0_WRITE_FCM_FCMAC_LPCMr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_LPCMr((c)),&((r)._fcm_fcmac_lpcm))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_LPCMr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_LPSM_CFW
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR LPSM CFW 7'h1E // FC-AL CFW Debug Register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  CFW              :
 *     On write, loads the cfw data register to modify the CFW. Read returns
 *     current cfw data register content.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_LPSM_CFWr(c) \
		(0x13100083 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_LPSM_CFWr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_LPSM_CFW.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_LPSM_CFWr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_lpsm_cfw[1];
	buint32_t _fcm_fcmac_lpsm_cfw;
} bcm84756_a0_FCM_FCMAC_LPSM_CFWr_t;

#define bcm84756_a0_FCM_FCMAC_LPSM_CFWr_CLR(r)   \
            (r).fcm_fcmac_lpsm_cfw[0] = 0

#define bcm84756_a0_FCM_FCMAC_LPSM_CFWr_SET(r,d) \
            (r).fcm_fcmac_lpsm_cfw[0] = d

#define bcm84756_a0_FCM_FCMAC_LPSM_CFWr_GET(r)   \
            (r).fcm_fcmac_lpsm_cfw[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_LPSM_CFWr_CFWf_GET(c,r)         \
	((r).fcm_fcmac_lpsm_cfw[0])

#define bcm84756_a0_FCM_FCMAC_LPSM_CFWr_CFWf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsm_cfw[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_FCMAC_LPSM_CFW.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_LPSM_CFWr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_LPSM_CFWr((c)),&((r)._fcm_fcmac_lpsm_cfw))

#define bcm84756_a0_WRITE_FCM_FCMAC_LPSM_CFWr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_LPSM_CFWr((c)),&((r)._fcm_fcmac_lpsm_cfw))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_LPSM_CFWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_LPSR
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 L Port status reg. Reserved for diagnostics only.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  LPSR_XMIT2IDLES  :
 *     Transmit 2 idles flag.
 *
 *  LPSR_PARTICIPATE :
 *     Participate flag.
 *
 *  LPSR_ARBF_SENT   :
 *     ARB(ff) sent.
 *
 *  LPSR_ERR_INIT    :
 *     Error Init.
 *
 *  LPSR_DHD_RCV     :
 *     DHD Primitive Received.
 *
 *  LPSR_LP_BYPASS   :
 *     Loop Port Bypass.
 *
 *  LPSR_ARB_PEND    :
 *     Arbitration Pending.
 *
 *  LPSR_ARB_WON     :
 *     Arbitration Won.
 *
 *  LPSR_PBE         :
 *     Port bypass enabled.
 *
 *  LPSR_OS          :
 *     Open sent OS.
 *
 *  LPSR_D           :
 *     Duplex D.
 *
 *  LPSR_A           :
 *     Access A.
 *
 *  LPSR_RFLF        :
 *     Received FL Port LISM Frame.
 *
 *  LPSR_REP         :
 *     Replicate mode.
 *
 *  LPSR_RXLT        :
 *     Received LIP type.
 *
 *  LPSR_RX_AL_PS    :
 *     Received physical source addr.
 *
 *  LPSR_RX_OPN_PS   :
 *     Received open physical source addr.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_LPSRr(c) \
		(0x13100067 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_LPSRr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_LPSR.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_LPSRr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_lpsr[1];
	buint32_t _fcm_fcmac_lpsr;
} bcm84756_a0_FCM_FCMAC_LPSRr_t;

#define bcm84756_a0_FCM_FCMAC_LPSRr_CLR(r)   \
            (r).fcm_fcmac_lpsr[0] = 0

#define bcm84756_a0_FCM_FCMAC_LPSRr_SET(r,d) \
            (r).fcm_fcmac_lpsr[0] = d

#define bcm84756_a0_FCM_FCMAC_LPSRr_GET(r)   \
            (r).fcm_fcmac_lpsr[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_XMIT2IDLESf_GET(c,r)         \
	(((r).fcm_fcmac_lpsr[0]) & 0x1)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_XMIT2IDLESf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_PARTICIPATEf_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_PARTICIPATEf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_ARBF_SENTf_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 2) & 0x1)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_ARBF_SENTf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0x1 << 2)) | \
		((((buint32_t)f) & 0x1) << 2))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_ERR_INITf_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 3) & 0x1)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_ERR_INITf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0x1 << 3)) | \
		((((buint32_t)f) & 0x1) << 3))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_DHD_RCVf_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 4) & 0x1)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_DHD_RCVf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0x1 << 4)) | \
		((((buint32_t)f) & 0x1) << 4))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_LP_BYPASSf_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 5) & 0x1)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_LP_BYPASSf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0x1 << 5)) | \
		((((buint32_t)f) & 0x1) << 5))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_ARB_PENDf_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 6) & 0x1)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_ARB_PENDf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0x1 << 6)) | \
		((((buint32_t)f) & 0x1) << 6))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_ARB_WONf_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 7) & 0x1)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_ARB_WONf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0x1 << 7)) | \
		((((buint32_t)f) & 0x1) << 7))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_PBEf_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_PBEf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_OSf_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 9) & 0x1)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_OSf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0x1 << 9)) | \
		((((buint32_t)f) & 0x1) << 9))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_Df_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 10) & 0x1)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_Df_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0x1 << 10)) | \
		((((buint32_t)f) & 0x1) << 10))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_Af_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 11) & 0x1)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_Af_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0x1 << 11)) | \
		((((buint32_t)f) & 0x1) << 11))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_RFLFf_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 12) & 0x1)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_RFLFf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0x1 << 12)) | \
		((((buint32_t)f) & 0x1) << 12))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_REPf_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 13) & 0x1)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_REPf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0x1 << 13)) | \
		((((buint32_t)f) & 0x1) << 13))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_RXLTf_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 14) & 0x3)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_RXLTf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0x3 << 14)) | \
		((((buint32_t)f) & 0x3) << 14))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_RX_AL_PSf_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 16) & 0xff)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_RX_AL_PSf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0xff << 16)) | \
		((((buint32_t)f) & 0xff) << 16))

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_RX_OPN_PSf_GET(c,r)         \
	((((r).fcm_fcmac_lpsr[0]) >> 24) & 0xff)

#define bcm84756_a0_FCM_FCMAC_LPSRr_LPSR_RX_OPN_PSf_SET(c,r,f)       \
	(r).fcm_fcmac_lpsr[0]=(((r).fcm_fcmac_lpsr[0] & ~((buint32_t)0xff << 24)) | \
		((((buint32_t)f) & 0xff) << 24))


/*
 * These macros can be used to access FCM_FCMAC_LPSR.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_LPSRr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_LPSRr((c)),&((r)._fcm_fcmac_lpsr))

#define bcm84756_a0_WRITE_FCM_FCMAC_LPSRr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_LPSRr((c)),&((r)._fcm_fcmac_lpsr))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_LPSRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_LPTR
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR LPTR 7'h13 // L P TOV reload reigster R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  LPTR_L_P_TOV     :
 *     The LPTR value can be written, and also a write of any value to this
 *     reg clears the internal LPTC timer in reg set cntr.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_LPTRr(c) \
		(0x13100078 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_LPTRr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_LPTR.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_LPTRr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_lptr[1];
	buint32_t _fcm_fcmac_lptr;
} bcm84756_a0_FCM_FCMAC_LPTRr_t;

#define bcm84756_a0_FCM_FCMAC_LPTRr_CLR(r)   \
            (r).fcm_fcmac_lptr[0] = 0

#define bcm84756_a0_FCM_FCMAC_LPTRr_SET(r,d) \
            (r).fcm_fcmac_lptr[0] = d

#define bcm84756_a0_FCM_FCMAC_LPTRr_GET(r)   \
            (r).fcm_fcmac_lptr[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_LPTRr_LPTR_L_P_TOVf_GET(c,r)         \
	(((r).fcm_fcmac_lptr[0]) & 0xfff)

#define bcm84756_a0_FCM_FCMAC_LPTRr_LPTR_L_P_TOVf_SET(c,r,f)       \
	(r).fcm_fcmac_lptr[0]=(((r).fcm_fcmac_lptr[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))


/*
 * These macros can be used to access FCM_FCMAC_LPTR.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_LPTRr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_LPTRr((c)),&((r)._fcm_fcmac_lptr))

#define bcm84756_a0_WRITE_FCM_FCMAC_LPTRr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_LPTRr((c)),&((r)._fcm_fcmac_lptr))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_LPTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_MAXFRMLEN_CONFIG
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR MAXFRMLEN 7'h22 // RX Maximum frame length, default = 535 (0x217). rw
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  MAXLEN           :
 *     Maximum FC frame length including SOF and EOF, in units of 32-bit
 *     words. NOTE : The programmed values of FRXB FREE RXB CNT and FCM FCMAC
 *     MAXFRMLEN CONFIG must be consistent with each other, and must also be
 *     consistent with the hard-coded size of the RX Frame Buffer (0x2000
 *     32-bit words). As a guideline : Program the FRXB FREE RXB CNT = 0x2000
 *     / buf reserve; i.e. with FCM FCMAC MAXFRMLEN CONFIG programmed to
 *     (default) 0x217 (buf reserve = 0x218), FRXB FREE RXB CNT should be
 *     programmed to (default) 0xf. To calculate using a different FCM FCMAC
 *     MAXFRMLEN CONFIG value, the buf reserve value used as the divisor must
 *     be an exact 16-byte multiple, or else it must be rounded up to the next
 *     16 byte boundary, i.e. : if ((FCM FCMAC MAXFRMLEN CONFIG MOD 4) != 0)
 *     buf reserve = FCM FCMAC MAXFRMLEN CONFIG + 4 - (FCM FCMAC MAXFRMLEN
 *     CONFIG MOD 4)} else buf reserve = FCM FCMAC MAXFRMLEN CONFIG
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_MAXFRMLEN_CONFIGr(c) \
		(0x13100002 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_MAXFRMLEN_CONFIGr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_MAXFRMLEN_CONFIG.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_MAXFRMLEN_CONFIGr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_maxfrmlen_config[1];
	buint32_t _fcm_fcmac_maxfrmlen_config;
} bcm84756_a0_FCM_FCMAC_MAXFRMLEN_CONFIGr_t;

#define bcm84756_a0_FCM_FCMAC_MAXFRMLEN_CONFIGr_CLR(r)   \
            (r).fcm_fcmac_maxfrmlen_config[0] = 0

#define bcm84756_a0_FCM_FCMAC_MAXFRMLEN_CONFIGr_SET(r,d) \
            (r).fcm_fcmac_maxfrmlen_config[0] = d

#define bcm84756_a0_FCM_FCMAC_MAXFRMLEN_CONFIGr_GET(r)   \
            (r).fcm_fcmac_maxfrmlen_config[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_MAXFRMLEN_CONFIGr_MAXLENf_GET(c,r)         \
	(((r).fcm_fcmac_maxfrmlen_config[0]) & 0x3ff)

#define bcm84756_a0_FCM_FCMAC_MAXFRMLEN_CONFIGr_MAXLENf_SET(c,r,f)       \
	(r).fcm_fcmac_maxfrmlen_config[0]=(((r).fcm_fcmac_maxfrmlen_config[0] & ~((buint32_t)0x3ff)) | \
		(((buint32_t)f) & 0x3ff))


/*
 * These macros can be used to access FCM_FCMAC_MAXFRMLEN_CONFIG.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_MAXFRMLEN_CONFIGr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_MAXFRMLEN_CONFIGr((c)),&((r)._fcm_fcmac_maxfrmlen_config))

#define bcm84756_a0_WRITE_FCM_FCMAC_MAXFRMLEN_CONFIGr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_MAXFRMLEN_CONFIGr((c)),&((r)._fcm_fcmac_maxfrmlen_config))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_MAXFRMLEN_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_MINFRMLEN_CONFIG
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR MINFRMLEN 7'h21 // runt+1 word count, default = 9 words. rw
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  MINLEN           :
 *     Minimum FC frame length including SOF and EOF, in units of 32-bit
 *     words.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_MINFRMLEN_CONFIGr(c) \
		(0x13100001 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_MINFRMLEN_CONFIGr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_MINFRMLEN_CONFIG.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_MINFRMLEN_CONFIGr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_minfrmlen_config[1];
	buint32_t _fcm_fcmac_minfrmlen_config;
} bcm84756_a0_FCM_FCMAC_MINFRMLEN_CONFIGr_t;

#define bcm84756_a0_FCM_FCMAC_MINFRMLEN_CONFIGr_CLR(r)   \
            (r).fcm_fcmac_minfrmlen_config[0] = 0

#define bcm84756_a0_FCM_FCMAC_MINFRMLEN_CONFIGr_SET(r,d) \
            (r).fcm_fcmac_minfrmlen_config[0] = d

#define bcm84756_a0_FCM_FCMAC_MINFRMLEN_CONFIGr_GET(r)   \
            (r).fcm_fcmac_minfrmlen_config[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_MINFRMLEN_CONFIGr_MINLENf_GET(c,r)         \
	(((r).fcm_fcmac_minfrmlen_config[0]) & 0x3ff)

#define bcm84756_a0_FCM_FCMAC_MINFRMLEN_CONFIGr_MINLENf_SET(c,r,f)       \
	(r).fcm_fcmac_minfrmlen_config[0]=(((r).fcm_fcmac_minfrmlen_config[0] & ~((buint32_t)0x3ff)) | \
		(((buint32_t)f) & 0x3ff))


/*
 * These macros can be used to access FCM_FCMAC_MINFRMLEN_CONFIG.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_MINFRMLEN_CONFIGr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_MINFRMLEN_CONFIGr((c)),&((r)._fcm_fcmac_minfrmlen_config))

#define bcm84756_a0_WRITE_FCM_FCMAC_MINFRMLEN_CONFIGr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_MINFRMLEN_CONFIGr((c)),&((r)._fcm_fcmac_minfrmlen_config))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_MINFRMLEN_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_NPCS
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR NPCS 7'h01 // N Port command/status reg R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  NPCS_PSPRQ       :
 *     Write the corresponding command defined in the table below to initiate
 *     a Primitive Sequence Protocol or to continuously transmit a Primitive
 *     Sequence. When instructed to initiate a Primitive Sequence Protocol
 *     these bits remain set while the Primitive Sequence Protocol Engine
 *     (PSPE) is running the protocol. When the Protocol completes and the
 *     Primitive Sequence Protocol Engine enters the either the ACTIVE or
 *     INACTIVE states, all commands except the Req (Link Failure) and Req
 *     (Online-to- Offline) will be CLEARED automatically to indicate that the
 *     request has been serviced and that no protocol is running. The Req
 *     (Link Failure) request will not be cleared automatically as the PSPE
 *     will remain in the LF2 state for as long as the Req (Link Failure)
 *     request is pending. The Req (Online-to-Offline) is not cleared
 *     automatically as the PSPE will remain in the OL1 state and continue to
 *     transmit OLS as long as the Req (Online-to-Offline) request is pending.
 *     Additionally, the Link Failure and Link Reset Primitive Sequence
 *     Protocols may be initiated internally by the FCMAC when certain
 *     internal conditions arise and the protocol that is running is indicated
 *     by the N Port State bits in the previous field. 4'b00xx Req (No
 *     Protocol) / No Protocol Running 4'b0100 Req (Link Initialization)
 *     Protocol 4'b0101 Req (Online-to-Offline) Protocol (not auto cleared)
 *     4'b0110 Req (Link Failure) Protocol (not auto cleared) 4'b0111 Req
 *     (Link Reset) Protocol 4'b1100 Req (Active) 4'b11xx Reserved THE
 *     FOLLOWING COMMANDS ARE FOR DIAGNOSTIC PURPOSES ONLY AND SHOULD NOT BE
 *     USED BY FIRMWARE : In the ACTIVE state, the FCMAC can be instructed to
 *     continuously transmit a Primitive Sequence using the Req (TxLR), Req
 *     (Tx LRR), Req (Tx OLS), or Req (Tx NOS) requests. 4'b1000 Req (Tx LR)
 *     4'b1001 Req (TxLRR) 4'b1010 Req (Tx OLS) 4'b1011 Req (Tx NOS)
 *
 *  NPCS_NPST        :
 *     N Port state: 4'b0000 - Active AC 4'b0001 - Link Recovery LRl : LR
 *     Transmit State 4'b0010 - Link Recovery LR2 : LR Receive State 4'b0011 -
 *     Link Recovery LR3 : LRR Receive State 4'b0100 - Link Failure LF 1: NOS
 *     Receive State 4'b0101 - Link Failure LF2 : NOS Transmit State 4'b0110 -
 *     Reserved 4'b0111 - Reserved 4'b1000 - Reserved 4'b1001 - Reserved
 *     4'b1010 - Offline 0L3 : Wait for OLS State 4'b1011 - Offline 0L2 : OLS
 *     Receive State 4'b1100 - Offline OL1D : 5ms delay state 4'b1101 -
 *     Offline OLlC : OLS Transmit State C 4'b1110 - Reserved 4'b1111 -
 *     Reserved
 *
 *  NPCS_LS          :
 *     FC-0 link status.
 *
 *  NPCS_ARXLOSP     :
 *     Alternate RXLOS Polarity ID.
 *
 *  NPCS_RXS         :
 *     RX state: 2'b00 - Reset 2'b01 - Loss of Word Sync 2'b10 - Word Sync
 *     Acquired 2'b11 - Reserved
 *
 *  NPCS_TXOPCST     :
 *     Transmit output controller state: 0001 - CFW 0010 - TX DATA 0011 - TX
 *     PRIM all others undefined
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_NPCSr(c) \
		(0x13100065 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_NPCSr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_NPCS.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_NPCSr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_npcs[1];
	buint32_t _fcm_fcmac_npcs;
} bcm84756_a0_FCM_FCMAC_NPCSr_t;

#define bcm84756_a0_FCM_FCMAC_NPCSr_CLR(r)   \
            (r).fcm_fcmac_npcs[0] = 0

#define bcm84756_a0_FCM_FCMAC_NPCSr_SET(r,d) \
            (r).fcm_fcmac_npcs[0] = d

#define bcm84756_a0_FCM_FCMAC_NPCSr_GET(r)   \
            (r).fcm_fcmac_npcs[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_NPCSr_NPCS_PSPRQf_GET(c,r)         \
	(((r).fcm_fcmac_npcs[0]) & 0xf)

#define bcm84756_a0_FCM_FCMAC_NPCSr_NPCS_PSPRQf_SET(c,r,f)       \
	(r).fcm_fcmac_npcs[0]=(((r).fcm_fcmac_npcs[0] & ~((buint32_t)0xf)) | \
		(((buint32_t)f) & 0xf))

#define bcm84756_a0_FCM_FCMAC_NPCSr_NPCS_NPSTf_GET(c,r)         \
	((((r).fcm_fcmac_npcs[0]) >> 4) & 0xf)

#define bcm84756_a0_FCM_FCMAC_NPCSr_NPCS_NPSTf_SET(c,r,f)       \
	(r).fcm_fcmac_npcs[0]=(((r).fcm_fcmac_npcs[0] & ~((buint32_t)0xf << 4)) | \
		((((buint32_t)f) & 0xf) << 4))

#define bcm84756_a0_FCM_FCMAC_NPCSr_NPCS_LSf_GET(c,r)         \
	((((r).fcm_fcmac_npcs[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_FCMAC_NPCSr_NPCS_LSf_SET(c,r,f)       \
	(r).fcm_fcmac_npcs[0]=(((r).fcm_fcmac_npcs[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))

#define bcm84756_a0_FCM_FCMAC_NPCSr_NPCS_ARXLOSPf_GET(c,r)         \
	((((r).fcm_fcmac_npcs[0]) >> 10) & 0x1)

#define bcm84756_a0_FCM_FCMAC_NPCSr_NPCS_ARXLOSPf_SET(c,r,f)       \
	(r).fcm_fcmac_npcs[0]=(((r).fcm_fcmac_npcs[0] & ~((buint32_t)0x1 << 10)) | \
		((((buint32_t)f) & 0x1) << 10))

#define bcm84756_a0_FCM_FCMAC_NPCSr_NPCS_RXSf_GET(c,r)         \
	((((r).fcm_fcmac_npcs[0]) >> 12) & 0x3)

#define bcm84756_a0_FCM_FCMAC_NPCSr_NPCS_RXSf_SET(c,r,f)       \
	(r).fcm_fcmac_npcs[0]=(((r).fcm_fcmac_npcs[0] & ~((buint32_t)0x3 << 12)) | \
		((((buint32_t)f) & 0x3) << 12))

#define bcm84756_a0_FCM_FCMAC_NPCSr_NPCS_TXOPCSTf_GET(c,r)         \
	((((r).fcm_fcmac_npcs[0]) >> 16) & 0xf)

#define bcm84756_a0_FCM_FCMAC_NPCSr_NPCS_TXOPCSTf_SET(c,r,f)       \
	(r).fcm_fcmac_npcs[0]=(((r).fcm_fcmac_npcs[0] & ~((buint32_t)0xf << 16)) | \
		((((buint32_t)f) & 0xf) << 16))


/*
 * These macros can be used to access FCM_FCMAC_NPCS.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_NPCSr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_NPCSr((c)),&((r)._fcm_fcmac_npcs))

#define bcm84756_a0_WRITE_FCM_FCMAC_NPCSr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_NPCSr((c)),&((r)._fcm_fcmac_npcs))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_NPCSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_PAID
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR PAID 7'h08 // My Port Address ID Register R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  PAID_ID          :
 *     Source ID.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_PAIDr(c) \
		(0x1310006d + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_PAIDr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_PAID.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_PAIDr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_paid[1];
	buint32_t _fcm_fcmac_paid;
} bcm84756_a0_FCM_FCMAC_PAIDr_t;

#define bcm84756_a0_FCM_FCMAC_PAIDr_CLR(r)   \
            (r).fcm_fcmac_paid[0] = 0

#define bcm84756_a0_FCM_FCMAC_PAIDr_SET(r,d) \
            (r).fcm_fcmac_paid[0] = d

#define bcm84756_a0_FCM_FCMAC_PAIDr_GET(r)   \
            (r).fcm_fcmac_paid[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_PAIDr_PAID_IDf_GET(c,r)         \
	(((r).fcm_fcmac_paid[0]) & 0xffffff)

#define bcm84756_a0_FCM_FCMAC_PAIDr_PAID_IDf_SET(c,r,f)       \
	(r).fcm_fcmac_paid[0]=(((r).fcm_fcmac_paid[0] & ~((buint32_t)0xffffff)) | \
		(((buint32_t)f) & 0xffffff))


/*
 * These macros can be used to access FCM_FCMAC_PAID.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_PAIDr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_PAIDr((c)),&((r)._fcm_fcmac_paid))

#define bcm84756_a0_WRITE_FCM_FCMAC_PAIDr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_PAIDr((c)),&((r)._fcm_fcmac_paid))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_PAIDr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_PCFG
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR PCFG 7'h00 // Port configuration reg R/W
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  PCFG_RXE         :
 *     RX enable/RX reset.
 *
 *  PCFG_RXFF        :
 *     RX frame buffer flush. Goes to Frame Buffer flush logic.
 *
 *  PCFG_FFCA        :
 *     Use internal FCMAC free rxbuf cnt counter instead of RXB. Read returns
 *     0.
 *
 *  PCFG_PC          :
 *     Pass CRC. Read returns 0.
 *
 *  PCFG_ECLSD       :
 *     Enable CLS Delay.
 *
 *  PCFG_DLP         :
 *     Disable LISM Frame filtering.
 *
 *  PCFG_ABFF        :
 *     Send ARBff enable.
 *
 *  PCFG_LBE         :
 *     Loopback enable. Read returns 0.
 *
 *  PCFG_PSD         :
 *     Primitive sequence disable.
 *
 *  PCFG_FFCB        :
 *     Default to original free rxbuf cnt logic. Read returns 0.
 *
 *  PCFG_LDHD        :
 *     Login dynamic half-duplex feature enable. Read returns 0.
 *
 *  PCFG_SNTO        :
 *     Skip N Port 5ms timeout.
 *
 *  PCFG_TME         :
 *     Arbitrated loop Transfer Mode Enable.
 *
 *  PCFG_ALF         :
 *     Arbitrated loop fairness mode select.
 *
 *  PCFG_LPD         :
 *     L Port disable.
 *
 *  PCFG_FOPND       :
 *     Full-Duplex Open Disabled.
 *
 *  PCFG_TXE         :
 *     Transmit enable.
 *
 *  PCFG_TXFE        :
 *     TXFIFO enable.
 *
 *  PCFG_TXFF        :
 *     TX Frame buffer flush. Goes to Frame Buffer flush logic.
 *
 *  PCFG_LAC         :
 *     Loop auto close mode enable.
 *
 *  PCFG_LAO         :
 *     Loop auto open mode enable.
 *
 *  PCFG_ABM         :
 *     Alternate BB credit management mode.
 *
 *  PCFG_LPRV        :
 *     NL Priv mode only. If bit is 0, allow NL OPN(00) if DDAA mismatch. Read
 *     returns 0.
 *
 *  PCFG_DOSC        :
 *     Disable Unsupported OS Check.
 *
 *  PCFG_DBB0LR      :
 *     When set, disable RX BBCredit Underflow link-reset response
 *     (diagnositic mode). Read returns 0.
 *
 *  PCFG_NLP         :
 *     Configure as NL Port, disable FL Port behavior.
 *
 *  PCFG_ICRC        :
 *     Ignore Rx CRC Check Result.
 *
 *  PCFG_FSID        :
 *     Force SID.
 *
 *  PCFG_CLIP        :
 *     Transfer continuous LIP in INIT and OINI states.
 *
 *  PCFG_RCLSMONI    :
 *     Config bit to activate REQUEST CLS in MONI state. Read returns 0.
 *
 *  PCFG_LIP60       :
 *      Send 60 LIPs in INIT and OPEN INIT instead of 12. Read returns 0.
 *
 *  PCFG_LACOPND_DIS :
 *     LAC disabled during OPENED state
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_PCFGr(c) \
		(0x13100064 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_PCFGr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_PCFG.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_PCFGr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_pcfg[1];
	buint32_t _fcm_fcmac_pcfg;
} bcm84756_a0_FCM_FCMAC_PCFGr_t;

#define bcm84756_a0_FCM_FCMAC_PCFGr_CLR(r)   \
            (r).fcm_fcmac_pcfg[0] = 0

#define bcm84756_a0_FCM_FCMAC_PCFGr_SET(r,d) \
            (r).fcm_fcmac_pcfg[0] = d

#define bcm84756_a0_FCM_FCMAC_PCFGr_GET(r)   \
            (r).fcm_fcmac_pcfg[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_RXEf_GET(c,r)         \
	(((r).fcm_fcmac_pcfg[0]) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_RXEf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_RXFFf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_RXFFf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_FFCAf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 2) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_FFCAf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 2)) | \
		((((buint32_t)f) & 0x1) << 2))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_PCf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 3) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_PCf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 3)) | \
		((((buint32_t)f) & 0x1) << 3))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_ECLSDf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 4) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_ECLSDf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 4)) | \
		((((buint32_t)f) & 0x1) << 4))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_DLPf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 5) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_DLPf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 5)) | \
		((((buint32_t)f) & 0x1) << 5))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_ABFFf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 6) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_ABFFf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 6)) | \
		((((buint32_t)f) & 0x1) << 6))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LBEf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 7) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LBEf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 7)) | \
		((((buint32_t)f) & 0x1) << 7))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_PSDf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_PSDf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_FFCBf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 9) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_FFCBf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 9)) | \
		((((buint32_t)f) & 0x1) << 9))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LDHDf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 10) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LDHDf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 10)) | \
		((((buint32_t)f) & 0x1) << 10))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_SNTOf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 11) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_SNTOf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 11)) | \
		((((buint32_t)f) & 0x1) << 11))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_TMEf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 12) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_TMEf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 12)) | \
		((((buint32_t)f) & 0x1) << 12))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_ALFf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 13) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_ALFf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 13)) | \
		((((buint32_t)f) & 0x1) << 13))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LPDf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 14) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LPDf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 14)) | \
		((((buint32_t)f) & 0x1) << 14))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_FOPNDf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 15) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_FOPNDf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 15)) | \
		((((buint32_t)f) & 0x1) << 15))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_TXEf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 16) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_TXEf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 16)) | \
		((((buint32_t)f) & 0x1) << 16))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_TXFEf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 17) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_TXFEf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 17)) | \
		((((buint32_t)f) & 0x1) << 17))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_TXFFf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 18) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_TXFFf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 18)) | \
		((((buint32_t)f) & 0x1) << 18))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LACf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 19) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LACf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 19)) | \
		((((buint32_t)f) & 0x1) << 19))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LAOf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 20) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LAOf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 20)) | \
		((((buint32_t)f) & 0x1) << 20))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_ABMf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 21) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_ABMf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 21)) | \
		((((buint32_t)f) & 0x1) << 21))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LPRVf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 22) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LPRVf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 22)) | \
		((((buint32_t)f) & 0x1) << 22))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_DOSCf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 23) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_DOSCf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 23)) | \
		((((buint32_t)f) & 0x1) << 23))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_DBB0LRf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 24) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_DBB0LRf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 24)) | \
		((((buint32_t)f) & 0x1) << 24))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_NLPf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 25) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_NLPf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 25)) | \
		((((buint32_t)f) & 0x1) << 25))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_ICRCf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 26) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_ICRCf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 26)) | \
		((((buint32_t)f) & 0x1) << 26))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_FSIDf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 27) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_FSIDf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 27)) | \
		((((buint32_t)f) & 0x1) << 27))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_CLIPf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 28) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_CLIPf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 28)) | \
		((((buint32_t)f) & 0x1) << 28))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_RCLSMONIf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 29) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_RCLSMONIf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 29)) | \
		((((buint32_t)f) & 0x1) << 29))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LIP60f_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 30) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LIP60f_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 30)) | \
		((((buint32_t)f) & 0x1) << 30))

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LACOPND_DISf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg[0]) >> 31) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFGr_PCFG_LACOPND_DISf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg[0]=(((r).fcm_fcmac_pcfg[0] & ~((buint32_t)0x1 << 31)) | \
		((((buint32_t)f) & 0x1) << 31))


/*
 * These macros can be used to access FCM_FCMAC_PCFG.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_PCFGr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_PCFGr((c)),&((r)._fcm_fcmac_pcfg))

#define bcm84756_a0_WRITE_FCM_FCMAC_PCFGr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_PCFGr((c)),&((r)._fcm_fcmac_pcfg))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_PCFGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_PCFG1
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR PCFG1 7'h19 // Port configuration reg 1 R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  PCFG1_EFF        :
 *     EFIFO bias insert/delete marks.
 *
 *  PCFG1_EOFNI      :
 *     EOFni is used instead of EOFa for error frames. Set this bit to replace
 *     EOFn and EOFt when CRC error detected. If CRC is bad and option EOFni
 *     is set, changes EOFn and EOFt to EOFni, else if CRC is bad and option
 *     EOFni is not set, changes EOF to EOFa.
 *
 *  PCFG1_FWCRRDY0   :
 *     BBCredit recovery hook -- Firmware increment of VC0 TX RRDY0 pending
 *     counter.
 *
 *  PCFG1_FWCRRDY1   :
 *     BBCredit recovery hook -- Firmware increment of VC0 TX RRDY1 pending
 *     counter.
 *
 *  PCFG1_ARBFFI     :
 *     Firmware option to ignore ARB(ff).
 *
 *  PCFG1_DFR        :
 *     Firmware option to disable TXB frame read.
 *
 *  PCFG1_ACF_S      :
 *     Access flag set for debugging purpose.
 *
 *  PCFG1_ACF_C      :
 *     Access flag clear for debugging purpose.
 *
 *  PCFG1_ARBW_S     :
 *     Arbitration won set for debugging purpose.
 *
 *  PCFG1_ARBW_C     :
 *     Arbitration won clear for debugging purpose.
 *
 *  PCFG1_ARBP_S     :
 *     Arbitration pending set for debugging purpose.
 *
 *  PCFG1_ARBP_C     :
 *     Arbitration pending clear for debugging purpose.
 *
 *  PCFG1_DPLX_S     :
 *     DUPLEX flag set for debugging purpose.
 *
 *  PCFG1_DPLX_C     :
 *     DUPLEX flag clear for debugging purpose.
 *
 *  PCFG1_RPL_S      :
 *     REPLICATE flag set for debugging purpose.
 *
 *  PCFG1_RPL_C      :
 *     REPLICATE flag clear for debugging purpose.
 *
 *  PCFG1_BP_S       :
 *     BYPASS flag set for debugging purpose.
 *
 *  PCFG1_BP_C       :
 *     BYPASS flag clear for debugging purpose.
 *
 *  PCFG1_DHD_S      :
 *     DHD flag set for debugging purpose.
 *
 *  PCFG1_DHD_C      :
 *     DHD flag clear for debugging purpose.
 *
 *  PCFG1_ERRI_S     :
 *     ERR INIT flag set for debugging purpose.
 *
 *  PCFG1_ERRI_C     :
 *     ERR INIT flag clear for debugging purpose.
 *
 *  PCFG1_ARBFS_S    :
 *     ARBF SENT flag set for debugging purpose.
 *
 *  PCFG1_ARBFS_C    :
 *     ARBF SENT flag clear for debugging purpos.
 *
 *  PCFG1_PRT_S      :
 *     PARTICIPATE flag set for debugging purpose.
 *
 *  PCFG1_PRT_C      :
 *     PARTICIPATE flag clear for debugging purpose.
 *
 *  PCFG1_LIM_S      :
 *     LIM flag set for debugging purpose.
 *
 *  PCFG1_LIM_C      :
 *     LIM flag clear for debugging purpose.
 *
 *  PCFG1_X2IC       :
 *     Xmit 2 idles clear after xmitted 2 idles (no prim det(idle) required).
 *     Read returns 0.
 *
 *  PCFG1_TTM        :
 *     Timer test mode. Read returns 0.
 *
 *  PCFG1_SLP        :
 *     Suppress loop primitives. Read returns 0.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_PCFG1r(c) \
		(0x1310007e + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_PCFG1.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_PCFG1r_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_pcfg1[1];
	buint32_t _fcm_fcmac_pcfg1;
} bcm84756_a0_FCM_FCMAC_PCFG1r_t;

#define bcm84756_a0_FCM_FCMAC_PCFG1r_CLR(r)   \
            (r).fcm_fcmac_pcfg1[0] = 0

#define bcm84756_a0_FCM_FCMAC_PCFG1r_SET(r,d) \
            (r).fcm_fcmac_pcfg1[0] = d

#define bcm84756_a0_FCM_FCMAC_PCFG1r_GET(r)   \
            (r).fcm_fcmac_pcfg1[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_EFFf_GET(c,r)         \
	(((r).fcm_fcmac_pcfg1[0]) & 0x3)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_EFFf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x3)) | \
		(((buint32_t)f) & 0x3))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_EOFNIf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 2) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_EOFNIf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 2)) | \
		((((buint32_t)f) & 0x1) << 2))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_FWCRRDY0f_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 3) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_FWCRRDY0f_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 3)) | \
		((((buint32_t)f) & 0x1) << 3))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_FWCRRDY1f_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 4) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_FWCRRDY1f_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 4)) | \
		((((buint32_t)f) & 0x1) << 4))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ARBFFIf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 5) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ARBFFIf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 5)) | \
		((((buint32_t)f) & 0x1) << 5))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_DFRf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 6) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_DFRf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 6)) | \
		((((buint32_t)f) & 0x1) << 6))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ACF_Sf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 7) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ACF_Sf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 7)) | \
		((((buint32_t)f) & 0x1) << 7))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ACF_Cf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ACF_Cf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ARBW_Sf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 9) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ARBW_Sf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 9)) | \
		((((buint32_t)f) & 0x1) << 9))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ARBW_Cf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 10) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ARBW_Cf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 10)) | \
		((((buint32_t)f) & 0x1) << 10))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ARBP_Sf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 11) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ARBP_Sf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 11)) | \
		((((buint32_t)f) & 0x1) << 11))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ARBP_Cf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 12) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ARBP_Cf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 12)) | \
		((((buint32_t)f) & 0x1) << 12))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_DPLX_Sf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 13) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_DPLX_Sf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 13)) | \
		((((buint32_t)f) & 0x1) << 13))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_DPLX_Cf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 14) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_DPLX_Cf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 14)) | \
		((((buint32_t)f) & 0x1) << 14))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_RPL_Sf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 15) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_RPL_Sf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 15)) | \
		((((buint32_t)f) & 0x1) << 15))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_RPL_Cf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 16) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_RPL_Cf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 16)) | \
		((((buint32_t)f) & 0x1) << 16))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_BP_Sf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 17) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_BP_Sf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 17)) | \
		((((buint32_t)f) & 0x1) << 17))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_BP_Cf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 18) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_BP_Cf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 18)) | \
		((((buint32_t)f) & 0x1) << 18))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_DHD_Sf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 19) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_DHD_Sf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 19)) | \
		((((buint32_t)f) & 0x1) << 19))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_DHD_Cf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 20) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_DHD_Cf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 20)) | \
		((((buint32_t)f) & 0x1) << 20))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ERRI_Sf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 21) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ERRI_Sf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 21)) | \
		((((buint32_t)f) & 0x1) << 21))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ERRI_Cf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 22) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ERRI_Cf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 22)) | \
		((((buint32_t)f) & 0x1) << 22))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ARBFS_Sf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 23) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ARBFS_Sf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 23)) | \
		((((buint32_t)f) & 0x1) << 23))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ARBFS_Cf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 24) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_ARBFS_Cf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 24)) | \
		((((buint32_t)f) & 0x1) << 24))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_PRT_Sf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 25) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_PRT_Sf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 25)) | \
		((((buint32_t)f) & 0x1) << 25))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_PRT_Cf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 26) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_PRT_Cf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 26)) | \
		((((buint32_t)f) & 0x1) << 26))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_LIM_Sf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 27) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_LIM_Sf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 27)) | \
		((((buint32_t)f) & 0x1) << 27))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_LIM_Cf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 28) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_LIM_Cf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 28)) | \
		((((buint32_t)f) & 0x1) << 28))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_X2ICf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 29) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_X2ICf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 29)) | \
		((((buint32_t)f) & 0x1) << 29))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_TTMf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 30) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_TTMf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 30)) | \
		((((buint32_t)f) & 0x1) << 30))

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_SLPf_GET(c,r)         \
	((((r).fcm_fcmac_pcfg1[0]) >> 31) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PCFG1r_PCFG1_SLPf_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg1[0]=(((r).fcm_fcmac_pcfg1[0] & ~((buint32_t)0x1 << 31)) | \
		((((buint32_t)f) & 0x1) << 31))


/*
 * These macros can be used to access FCM_FCMAC_PCFG1.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_PCFG1r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_PCFG1r((c)),&((r)._fcm_fcmac_pcfg1))

#define bcm84756_a0_WRITE_FCM_FCMAC_PCFG1r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_PCFG1r((c)),&((r)._fcm_fcmac_pcfg1))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_PCFG1r'
 ******************************************************************************/


/*******************************************************************************
 * CHIP:  bcm84756_c0
 * REGISTER:  FCM_FCMAC_PCFG2
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR PCFG2 7'h13 // Port configuration reg 1 R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  RX_ALTFW        :
 *     ARBFF Config bits.
 *
 *
 ******************************************************************************/
#define bcm84756_c0_FCM_FCMAC_PCFG2r(c) \
		(0x13100077 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_c0_FCM_FCMAC_PCFG2r_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_PCFG1.
 *
 */
typedef union bcm84756_c0_FCM_FCMAC_PCFG2r_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_pcfg2[1];
	buint32_t _fcm_fcmac_pcfg2;
} bcm84756_c0_FCM_FCMAC_PCFG2r_t;

#define bcm84756_c0_FCM_FCMAC_PCFG2r_CLR(r)   \
            (r).fcm_fcmac_pcfg2[0] = 0

#define bcm84756_c0_FCM_FCMAC_PCFG2r_SET(r,d) \
            (r).fcm_fcmac_pcfg2[0] = d

#define bcm84756_c0_FCM_FCMAC_PCFG2r_GET(r)   \
            (r).fcm_fcmac_pcfg2[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_c0_FCM_FCMAC_PCFG2r_RX_ALTFW_GET(c,r)         \
	(((r).fcm_fcmac_pcfg2[0]) & 0x3)

#define bcm84756_c0_FCM_FCMAC_PCFG2r_RX_ALTFW_SET(c,r,f)       \
	(r).fcm_fcmac_pcfg2[0]=(((r).fcm_fcmac_pcfg2[0] & ~((buint32_t)0x3)) | \
		(((buint32_t)f) & 0x3))

/*
 * These macros can be used to access FCM_FCMAC_PCFG1.
 *
 */
#define bcm84756_c0_READ_FCM_FCMAC_PCFG2r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_c0_FCM_FCMAC_PCFG2r((c)),&((r)._fcm_fcmac_pcfg2))

#define bcm84756_c0_WRITE_FCM_FCMAC_PCFG2r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_c0_FCM_FCMAC_PCFG2r((c)),&((r)._fcm_fcmac_pcfg2))

/*******************************************************************************
 * End of 'bcm84756_c0_FCM_FCMAC_PCFG2r'
 ******************************************************************************/


/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_PMAPW
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR PMAPW 7'h0E // Proxy Map 1 register R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  PMAP_W           :
 *     Assigned prxymap[127:96].
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_PMAPWr(c) \
		(0x13100073 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_PMAPWr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_PMAPW.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_PMAPWr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_pmapw[1];
	buint32_t _fcm_fcmac_pmapw;
} bcm84756_a0_FCM_FCMAC_PMAPWr_t;

#define bcm84756_a0_FCM_FCMAC_PMAPWr_CLR(r)   \
            (r).fcm_fcmac_pmapw[0] = 0

#define bcm84756_a0_FCM_FCMAC_PMAPWr_SET(r,d) \
            (r).fcm_fcmac_pmapw[0] = d

#define bcm84756_a0_FCM_FCMAC_PMAPWr_GET(r)   \
            (r).fcm_fcmac_pmapw[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_PMAPWr_PMAP_Wf_GET(c,r)         \
	((r).fcm_fcmac_pmapw[0])

#define bcm84756_a0_FCM_FCMAC_PMAPWr_PMAP_Wf_SET(c,r,f)       \
	(r).fcm_fcmac_pmapw[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_FCMAC_PMAPW.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_PMAPWr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_PMAPWr((c)),&((r)._fcm_fcmac_pmapw))

#define bcm84756_a0_WRITE_FCM_FCMAC_PMAPWr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_PMAPWr((c)),&((r)._fcm_fcmac_pmapw))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_PMAPWr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_PMAPX
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR PMAPX 7'h0F // Proxy Map 2 register R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  PMAP_X           :
 *     Assigned prxymap[95:64].
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_PMAPXr(c) \
		(0x13100074 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_PMAPXr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_PMAPX.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_PMAPXr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_pmapx[1];
	buint32_t _fcm_fcmac_pmapx;
} bcm84756_a0_FCM_FCMAC_PMAPXr_t;

#define bcm84756_a0_FCM_FCMAC_PMAPXr_CLR(r)   \
            (r).fcm_fcmac_pmapx[0] = 0

#define bcm84756_a0_FCM_FCMAC_PMAPXr_SET(r,d) \
            (r).fcm_fcmac_pmapx[0] = d

#define bcm84756_a0_FCM_FCMAC_PMAPXr_GET(r)   \
            (r).fcm_fcmac_pmapx[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_PMAPXr_PMAP_Xf_GET(c,r)         \
	((r).fcm_fcmac_pmapx[0])

#define bcm84756_a0_FCM_FCMAC_PMAPXr_PMAP_Xf_SET(c,r,f)       \
	(r).fcm_fcmac_pmapx[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_FCMAC_PMAPX.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_PMAPXr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_PMAPXr((c)),&((r)._fcm_fcmac_pmapx))

#define bcm84756_a0_WRITE_FCM_FCMAC_PMAPXr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_PMAPXr((c)),&((r)._fcm_fcmac_pmapx))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_PMAPXr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_PMAPY
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR PMAPY 7'h10 // Proxy Map 3 register R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  PMAP_Y           :
 *     Assigned prxymap[63:32].
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_PMAPYr(c) \
		(0x13100075 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_PMAPYr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_PMAPY.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_PMAPYr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_pmapy[1];
	buint32_t _fcm_fcmac_pmapy;
} bcm84756_a0_FCM_FCMAC_PMAPYr_t;

#define bcm84756_a0_FCM_FCMAC_PMAPYr_CLR(r)   \
            (r).fcm_fcmac_pmapy[0] = 0

#define bcm84756_a0_FCM_FCMAC_PMAPYr_SET(r,d) \
            (r).fcm_fcmac_pmapy[0] = d

#define bcm84756_a0_FCM_FCMAC_PMAPYr_GET(r)   \
            (r).fcm_fcmac_pmapy[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_PMAPYr_PMAP_Yf_GET(c,r)         \
	((r).fcm_fcmac_pmapy[0])

#define bcm84756_a0_FCM_FCMAC_PMAPYr_PMAP_Yf_SET(c,r,f)       \
	(r).fcm_fcmac_pmapy[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_FCMAC_PMAPY.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_PMAPYr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_PMAPYr((c)),&((r)._fcm_fcmac_pmapy))

#define bcm84756_a0_WRITE_FCM_FCMAC_PMAPYr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_PMAPYr((c)),&((r)._fcm_fcmac_pmapy))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_PMAPYr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_PMAPZ
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR PMAPZ 7'h11 // Proxy Map 4 register R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  PMAP_Z           :
 *     Assigned prxymap[31:00].
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_PMAPZr(c) \
		(0x13100076 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_PMAPZr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_PMAPZ.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_PMAPZr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_pmapz[1];
	buint32_t _fcm_fcmac_pmapz;
} bcm84756_a0_FCM_FCMAC_PMAPZr_t;

#define bcm84756_a0_FCM_FCMAC_PMAPZr_CLR(r)   \
            (r).fcm_fcmac_pmapz[0] = 0

#define bcm84756_a0_FCM_FCMAC_PMAPZr_SET(r,d) \
            (r).fcm_fcmac_pmapz[0] = d

#define bcm84756_a0_FCM_FCMAC_PMAPZr_GET(r)   \
            (r).fcm_fcmac_pmapz[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_PMAPZr_PMAP_Zf_GET(c,r)         \
	((r).fcm_fcmac_pmapz[0])

#define bcm84756_a0_FCM_FCMAC_PMAPZr_PMAP_Zf_SET(c,r,f)       \
	(r).fcm_fcmac_pmapz[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_FCMAC_PMAPZ.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_PMAPZr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_PMAPZr((c)),&((r)._fcm_fcmac_pmapz))

#define bcm84756_a0_WRITE_FCM_FCMAC_PMAPZr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_PMAPZr((c)),&((r)._fcm_fcmac_pmapz))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_PMAPZr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_PRIMCTRL
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR PRIMCTRL 7'h1C // primitive generation control register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FC_PRIMCTRL_KC1  :
 *     Generate prim with K28.5 transmit signal asserted.
 *
 *  FC_PRIMCTRL_CNT  :
 *     Count of number of PRIMs to be sent when not in continuous mode.
 *
 *  FC_PRIMCTRL_CONTINUOUS :
 *     When set to 1, the primgen is continuous and the FC PRIMCTRL CNT field
 *     has no affect.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_PRIMCTRLr(c) \
		(0x13100081 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_PRIMCTRLr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_PRIMCTRL.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_PRIMCTRLr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_primctrl[1];
	buint32_t _fcm_fcmac_primctrl;
} bcm84756_a0_FCM_FCMAC_PRIMCTRLr_t;

#define bcm84756_a0_FCM_FCMAC_PRIMCTRLr_CLR(r)   \
            (r).fcm_fcmac_primctrl[0] = 0

#define bcm84756_a0_FCM_FCMAC_PRIMCTRLr_SET(r,d) \
            (r).fcm_fcmac_primctrl[0] = d

#define bcm84756_a0_FCM_FCMAC_PRIMCTRLr_GET(r)   \
            (r).fcm_fcmac_primctrl[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_PRIMCTRLr_FC_PRIMCTRL_KC1f_GET(c,r)         \
	(((r).fcm_fcmac_primctrl[0]) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PRIMCTRLr_FC_PRIMCTRL_KC1f_SET(c,r,f)       \
	(r).fcm_fcmac_primctrl[0]=(((r).fcm_fcmac_primctrl[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMAC_PRIMCTRLr_FC_PRIMCTRL_CNTf_GET(c,r)         \
	((((r).fcm_fcmac_primctrl[0]) >> 4) & 0xf)

#define bcm84756_a0_FCM_FCMAC_PRIMCTRLr_FC_PRIMCTRL_CNTf_SET(c,r,f)       \
	(r).fcm_fcmac_primctrl[0]=(((r).fcm_fcmac_primctrl[0] & ~((buint32_t)0xf << 4)) | \
		((((buint32_t)f) & 0xf) << 4))

#define bcm84756_a0_FCM_FCMAC_PRIMCTRLr_FC_PRIMCTRL_CONTINUOUSf_GET(c,r)         \
	((((r).fcm_fcmac_primctrl[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_FCMAC_PRIMCTRLr_FC_PRIMCTRL_CONTINUOUSf_SET(c,r,f)       \
	(r).fcm_fcmac_primctrl[0]=(((r).fcm_fcmac_primctrl[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))


/*
 * These macros can be used to access FCM_FCMAC_PRIMCTRL.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_PRIMCTRLr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_PRIMCTRLr((c)),&((r)._fcm_fcmac_primctrl))

#define bcm84756_a0_WRITE_FCM_FCMAC_PRIMCTRLr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_PRIMCTRLr((c)),&((r)._fcm_fcmac_primctrl))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_PRIMCTRLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_PRIMVAL
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR PRIM 7'h1D // primitive value generation register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VALUE            :
 *     32-bit primitive code to be generated.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_PRIMVALr(c) \
		(0x13100082 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_PRIMVALr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_PRIMVAL.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_PRIMVALr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_primval[1];
	buint32_t _fcm_fcmac_primval;
} bcm84756_a0_FCM_FCMAC_PRIMVALr_t;

#define bcm84756_a0_FCM_FCMAC_PRIMVALr_CLR(r)   \
            (r).fcm_fcmac_primval[0] = 0

#define bcm84756_a0_FCM_FCMAC_PRIMVALr_SET(r,d) \
            (r).fcm_fcmac_primval[0] = d

#define bcm84756_a0_FCM_FCMAC_PRIMVALr_GET(r)   \
            (r).fcm_fcmac_primval[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_PRIMVALr_VALUEf_GET(c,r)         \
	((r).fcm_fcmac_primval[0])

#define bcm84756_a0_FCM_FCMAC_PRIMVALr_VALUEf_SET(c,r,f)       \
	(r).fcm_fcmac_primval[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_FCMAC_PRIMVAL.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_PRIMVALr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_PRIMVALr((c)),&((r)._fcm_fcmac_primval))

#define bcm84756_a0_WRITE_FCM_FCMAC_PRIMVALr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_PRIMVALr((c)),&((r)._fcm_fcmac_primval))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_PRIMVALr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_RRDY0
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR RRDY0 7'h15 // Programmable RRDY VC0 value register R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  RRDY0_VALUE      :
 *     Programmable RRDY0 value.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_RRDY0r(c) \
		(0x1310007a + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_RRDY0r_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_RRDY0.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_RRDY0r_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_rrdy0[1];
	buint32_t _fcm_fcmac_rrdy0;
} bcm84756_a0_FCM_FCMAC_RRDY0r_t;

#define bcm84756_a0_FCM_FCMAC_RRDY0r_CLR(r)   \
            (r).fcm_fcmac_rrdy0[0] = 0

#define bcm84756_a0_FCM_FCMAC_RRDY0r_SET(r,d) \
            (r).fcm_fcmac_rrdy0[0] = d

#define bcm84756_a0_FCM_FCMAC_RRDY0r_GET(r)   \
            (r).fcm_fcmac_rrdy0[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_RRDY0r_RRDY0_VALUEf_GET(c,r)         \
	((r).fcm_fcmac_rrdy0[0])

#define bcm84756_a0_FCM_FCMAC_RRDY0r_RRDY0_VALUEf_SET(c,r,f)       \
	(r).fcm_fcmac_rrdy0[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_FCMAC_RRDY0.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_RRDY0r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_RRDY0r((c)),&((r)._fcm_fcmac_rrdy0))

#define bcm84756_a0_WRITE_FCM_FCMAC_RRDY0r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_RRDY0r((c)),&((r)._fcm_fcmac_rrdy0))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_RRDY0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_RRDY1
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR RRDY1 7'h16 // Programmable RRDY VC1 value register R/W.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  RRDY1_VALUE      :
 *     Programmable RRDY1 value.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_RRDY1r(c) \
		(0x1310007b + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_RRDY1r_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_RRDY1.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_RRDY1r_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_rrdy1[1];
	buint32_t _fcm_fcmac_rrdy1;
} bcm84756_a0_FCM_FCMAC_RRDY1r_t;

#define bcm84756_a0_FCM_FCMAC_RRDY1r_CLR(r)   \
            (r).fcm_fcmac_rrdy1[0] = 0

#define bcm84756_a0_FCM_FCMAC_RRDY1r_SET(r,d) \
            (r).fcm_fcmac_rrdy1[0] = d

#define bcm84756_a0_FCM_FCMAC_RRDY1r_GET(r)   \
            (r).fcm_fcmac_rrdy1[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_RRDY1r_RRDY1_VALUEf_GET(c,r)         \
	((r).fcm_fcmac_rrdy1[0])

#define bcm84756_a0_FCM_FCMAC_RRDY1r_RRDY1_VALUEf_SET(c,r,f)       \
	(r).fcm_fcmac_rrdy1[0]=((buint32_t)f)


/*
 * These macros can be used to access FCM_FCMAC_RRDY1.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_RRDY1r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_RRDY1r((c)),&((r)._fcm_fcmac_rrdy1))

#define bcm84756_a0_WRITE_FCM_FCMAC_RRDY1r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_RRDY1r((c)),&((r)._fcm_fcmac_rrdy1))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_RRDY1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_RTTR
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR RTTR 7'h14 // R T TOV reload register R/W. A write loads a new value
 *	 of r t tov
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  RTTR_R_T_TOV     :
 *     A write loads a new value of R T TOV for the FC timers.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_RTTRr(c) \
		(0x13100079 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_RTTRr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_RTTR.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_RTTRr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_rttr[1];
	buint32_t _fcm_fcmac_rttr;
} bcm84756_a0_FCM_FCMAC_RTTRr_t;

#define bcm84756_a0_FCM_FCMAC_RTTRr_CLR(r)   \
            (r).fcm_fcmac_rttr[0] = 0

#define bcm84756_a0_FCM_FCMAC_RTTRr_SET(r,d) \
            (r).fcm_fcmac_rttr[0] = d

#define bcm84756_a0_FCM_FCMAC_RTTRr_GET(r)   \
            (r).fcm_fcmac_rttr[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_RTTRr_RTTR_R_T_TOVf_GET(c,r)         \
	(((r).fcm_fcmac_rttr[0]) & 0xffff)

#define bcm84756_a0_FCM_FCMAC_RTTRr_RTTR_R_T_TOVf_SET(c,r,f)       \
	(r).fcm_fcmac_rttr[0]=(((r).fcm_fcmac_rttr[0] & ~((buint32_t)0xffff)) | \
		(((buint32_t)f) & 0xffff))


/*
 * These macros can be used to access FCM_FCMAC_RTTR.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_RTTRr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_RTTRr((c)),&((r)._fcm_fcmac_rttr))

#define bcm84756_a0_WRITE_FCM_FCMAC_RTTRr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_RTTRr((c)),&((r)._fcm_fcmac_rttr))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_RTTRr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_RXBBCR_MGR_CONFIG
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR BBCREDIT shim config 7'h20 // RX BBCREDIT shim configuration. rw
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  UNH2P1I_MODE     :
 *     RX K-char decode mode 1 = Kchar decodes only K28.5 (RD+ or RD-) as
 *     required by UNH testcase 2.1i. 0 = Kchar decodes any valid K char.
 *
 *  XGS_COUNTER_COMPAT_MODE :
 *     When 0, counters are cleared on read and saturated at maximum count.
 *     When 1 (XGS compatibility mode), counters maintain their values on read
 *     and roll over on maximum count.
 *
 *  CELL_SIZE        :
 *     Word size in frame buffers, units of bytes. Default is 16 bytes for
 *     128-bit wide buffer memory.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr(c) \
		(0x13100000 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_RXBBCR_MGR_CONFIG.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_rxbbcr_mgr_config[1];
	buint32_t _fcm_fcmac_rxbbcr_mgr_config;
} bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr_t;

#define bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr_CLR(r)   \
            (r).fcm_fcmac_rxbbcr_mgr_config[0] = 0

#define bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr_SET(r,d) \
            (r).fcm_fcmac_rxbbcr_mgr_config[0] = d

#define bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr_GET(r)   \
            (r).fcm_fcmac_rxbbcr_mgr_config[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr_UNH2P1I_MODEf_GET(c,r)         \
	(((r).fcm_fcmac_rxbbcr_mgr_config[0]) & 0x1)

#define bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr_UNH2P1I_MODEf_SET(c,r,f)       \
	(r).fcm_fcmac_rxbbcr_mgr_config[0]=(((r).fcm_fcmac_rxbbcr_mgr_config[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr_XGS_COUNTER_COMPAT_MODEf_GET(c,r)         \
	((((r).fcm_fcmac_rxbbcr_mgr_config[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr_XGS_COUNTER_COMPAT_MODEf_SET(c,r,f)       \
	(r).fcm_fcmac_rxbbcr_mgr_config[0]=(((r).fcm_fcmac_rxbbcr_mgr_config[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))

#define bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr_CELL_SIZEf_GET(c,r)         \
	((((r).fcm_fcmac_rxbbcr_mgr_config[0]) >> 16) & 0xffff)

#define bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr_CELL_SIZEf_SET(c,r,f)       \
	(r).fcm_fcmac_rxbbcr_mgr_config[0]=(((r).fcm_fcmac_rxbbcr_mgr_config[0] & ~((buint32_t)0xffff << 16)) | \
		((((buint32_t)f) & 0xffff) << 16))


/*
 * These macros can be used to access FCM_FCMAC_RXBBCR_MGR_CONFIG.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_RXBBCR_MGR_CONFIGr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr((c)),&((r)._fcm_fcmac_rxbbcr_mgr_config))

#define bcm84756_a0_WRITE_FCM_FCMAC_RXBBCR_MGR_CONFIGr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr((c)),&((r)._fcm_fcmac_rxbbcr_mgr_config))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_RXBBCR_MGR_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMAC_TXOPNDCLS_TOV
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 ADDR TXOPNDCLS TOV 7'h1F // Loop Port OPENED Auto CLS register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  TOV              :
 *     Units in microseconds. Set timeout to send CLS when in OPENED state
 *     with a frame to send. Timer is started if there is a frame to send to a
 *     different ALPA than the opened ALPA.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMAC_TXOPNDCLS_TOVr(c) \
		(0x13100084 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMAC_TXOPNDCLS_TOVr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMAC_TXOPNDCLS_TOV.
 *
 */
typedef union bcm84756_a0_FCM_FCMAC_TXOPNDCLS_TOVr_s {
	buint32_t v[1];
	buint32_t fcm_fcmac_txopndcls_tov[1];
	buint32_t _fcm_fcmac_txopndcls_tov;
} bcm84756_a0_FCM_FCMAC_TXOPNDCLS_TOVr_t;

#define bcm84756_a0_FCM_FCMAC_TXOPNDCLS_TOVr_CLR(r)   \
            (r).fcm_fcmac_txopndcls_tov[0] = 0

#define bcm84756_a0_FCM_FCMAC_TXOPNDCLS_TOVr_SET(r,d) \
            (r).fcm_fcmac_txopndcls_tov[0] = d

#define bcm84756_a0_FCM_FCMAC_TXOPNDCLS_TOVr_GET(r)   \
            (r).fcm_fcmac_txopndcls_tov[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMAC_TXOPNDCLS_TOVr_TOVf_GET(c,r)         \
	(((r).fcm_fcmac_txopndcls_tov[0]) & 0xfff)

#define bcm84756_a0_FCM_FCMAC_TXOPNDCLS_TOVr_TOVf_SET(c,r,f)       \
	(r).fcm_fcmac_txopndcls_tov[0]=(((r).fcm_fcmac_txopndcls_tov[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))


/*
 * These macros can be used to access FCM_FCMAC_TXOPNDCLS_TOV.
 *
 */
#define bcm84756_a0_READ_FCM_FCMAC_TXOPNDCLS_TOVr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMAC_TXOPNDCLS_TOVr((c)),&((r)._fcm_fcmac_txopndcls_tov))

#define bcm84756_a0_WRITE_FCM_FCMAC_TXOPNDCLS_TOVr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMAC_TXOPNDCLS_TOVr((c)),&((r)._fcm_fcmac_txopndcls_tov))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMAC_TXOPNDCLS_TOVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCME_CONFIG
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 This register allows general configuation of the FCM Mapper in the egress
 *	 direction.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FCS_REGEN_MODE   :
 *     This mode allows the FC frame within the FCoE packet to be modified by
 *     an external switch with FCM Mapper handling the CRC recomputation. 1 -
 *     No CRC Check Mode; Mapper checks FCS and if it's good generate a good
 *     CRC regardless of the inner CRC. If FCS is bad generate a bad CRC.
 *     Applies to all frames whether FC frame is modified by the FCM Mapper or
 *     not. 0 - Normal; FCS and CRC checked before regenerating CRC. If FCS or
 *     CRC is bad, a bad FCS and/or CRC is regenerated.
 *
 *  FCS_EOF_MODE     :
 *     Enables FCS to be forcibly corrupted based on EOF. Applies only to FCoE
 *     packets when fcs field present is set. 1 - Receiving a packet with
 *     EOFni or EOFa forces a bad FCS word on encapsulation. 0 - FCS is not
 *     modified based on EOF type.
 *
 *  FCS_FIELD_PRESENT :
 *     Indicates format of packets between the switch MAC and line MAC. 1 -
 *     FCS is present and generated as necessary on all packets. 0 - FCS field
 *     is not present on input packets and is not generated on output packets.
 *
 *  DBG_IGNORE_CRC   :
 *     Ignore CRC debug mode. 1 - CRC is not checked by mapper, value is
 *     always considered good. 0 - Normal operating mode.
 *
 *  MAP_TABLE_INPUT  :
 *     Map table input can be from VFT Header or from VLAN tag. Determines
 *     what field is used as map table input : 1 = VFT Header VFID field. 0 =
 *     VLAN tag VID field.
 *
 *  MAP_TABLE_DIRECTION :
 *     Determines which table output is used for the mapped result : 1 = VSAN
 *     entry maps to VLAN output. 0 = VLAN entry maps to VSAN output.
 *
 *  DISCARD_BADPKT_DISABLE :
 *     Disable auto discard of bad packets due to parsed invalid fields : 1 =
 *     Mapper forwards packets parsed as bad. 0 = Mapper discards packets
 *     parsed as bad.
 *
 *  MAPPER_BYPASS_ENABLE :
 *     Disable auto discard of runt packets : 1 = Mapper datapath is bypassed.
 *     0 = Normal mode.
 *
 *  DECAP_FCOE2FC_ENABLE :
 *     FCoE decap enable bit. This bit should be 1 for FC to FCoE operation,
 *     and it should be 0 for FCoE to FCoE operation. 1 - Enable FCoE
 *     decapsulation (FC/FCoE deployment model), 0 - FCoE decapsulation not
 *     done (FCoE/FCoE deployment model).
 *
 *  DBG_CURRENTSTATE :
 *     FCME Mapper FSM state.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCME_CONFIGr(c) \
		(0x1310000b + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCME_CONFIGr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCME_CONFIG.
 *
 */
typedef union bcm84756_a0_FCM_FCME_CONFIGr_s {
	buint32_t v[1];
	buint32_t fcm_fcme_config[1];
	buint32_t _fcm_fcme_config;
} bcm84756_a0_FCM_FCME_CONFIGr_t;

#define bcm84756_a0_FCM_FCME_CONFIGr_CLR(r)   \
            (r).fcm_fcme_config[0] = 0

#define bcm84756_a0_FCM_FCME_CONFIGr_SET(r,d) \
            (r).fcm_fcme_config[0] = d

#define bcm84756_a0_FCM_FCME_CONFIGr_GET(r)   \
            (r).fcm_fcme_config[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCME_CONFIGr_FCS_REGEN_MODEf_GET(c,r)         \
	(((r).fcm_fcme_config[0]) & 0x1)

#define bcm84756_a0_FCM_FCME_CONFIGr_FCS_REGEN_MODEf_SET(c,r,f)       \
	(r).fcm_fcme_config[0]=(((r).fcm_fcme_config[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCME_CONFIGr_FCS_EOF_MODEf_GET(c,r)         \
	((((r).fcm_fcme_config[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCME_CONFIGr_FCS_EOF_MODEf_SET(c,r,f)       \
	(r).fcm_fcme_config[0]=(((r).fcm_fcme_config[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))

#define bcm84756_a0_FCM_FCME_CONFIGr_FCS_FIELD_PRESENTf_GET(c,r)         \
	((((r).fcm_fcme_config[0]) >> 2) & 0x1)

#define bcm84756_a0_FCM_FCME_CONFIGr_FCS_FIELD_PRESENTf_SET(c,r,f)       \
	(r).fcm_fcme_config[0]=(((r).fcm_fcme_config[0] & ~((buint32_t)0x1 << 2)) | \
		((((buint32_t)f) & 0x1) << 2))

#define bcm84756_a0_FCM_FCME_CONFIGr_DBG_IGNORE_CRCf_GET(c,r)         \
	((((r).fcm_fcme_config[0]) >> 3) & 0x1)

#define bcm84756_a0_FCM_FCME_CONFIGr_DBG_IGNORE_CRCf_SET(c,r,f)       \
	(r).fcm_fcme_config[0]=(((r).fcm_fcme_config[0] & ~((buint32_t)0x1 << 3)) | \
		((((buint32_t)f) & 0x1) << 3))

#define bcm84756_a0_FCM_FCME_CONFIGr_MAP_TABLE_INPUTf_GET(c,r)         \
	((((r).fcm_fcme_config[0]) >> 4) & 0x1)

#define bcm84756_a0_FCM_FCME_CONFIGr_MAP_TABLE_INPUTf_SET(c,r,f)       \
	(r).fcm_fcme_config[0]=(((r).fcm_fcme_config[0] & ~((buint32_t)0x1 << 4)) | \
		((((buint32_t)f) & 0x1) << 4))

#define bcm84756_a0_FCM_FCME_CONFIGr_MAP_TABLE_DIRECTIONf_GET(c,r)         \
	((((r).fcm_fcme_config[0]) >> 5) & 0x1)

#define bcm84756_a0_FCM_FCME_CONFIGr_MAP_TABLE_DIRECTIONf_SET(c,r,f)       \
	(r).fcm_fcme_config[0]=(((r).fcm_fcme_config[0] & ~((buint32_t)0x1 << 5)) | \
		((((buint32_t)f) & 0x1) << 5))

#define bcm84756_a0_FCM_FCME_CONFIGr_DISCARD_BADPKT_DISABLEf_GET(c,r)         \
	((((r).fcm_fcme_config[0]) >> 6) & 0x1)

#define bcm84756_a0_FCM_FCME_CONFIGr_DISCARD_BADPKT_DISABLEf_SET(c,r,f)       \
	(r).fcm_fcme_config[0]=(((r).fcm_fcme_config[0] & ~((buint32_t)0x1 << 6)) | \
		((((buint32_t)f) & 0x1) << 6))

#define bcm84756_a0_FCM_FCME_CONFIGr_MAPPER_BYPASS_ENABLEf_GET(c,r)         \
	((((r).fcm_fcme_config[0]) >> 7) & 0x1)

#define bcm84756_a0_FCM_FCME_CONFIGr_MAPPER_BYPASS_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcme_config[0]=(((r).fcm_fcme_config[0] & ~((buint32_t)0x1 << 7)) | \
		((((buint32_t)f) & 0x1) << 7))

#define bcm84756_a0_FCM_FCME_CONFIGr_DECAP_FCOE2FC_ENABLEf_GET(c,r)         \
	((((r).fcm_fcme_config[0]) >> 14) & 0x1)

#define bcm84756_a0_FCM_FCME_CONFIGr_DECAP_FCOE2FC_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcme_config[0]=(((r).fcm_fcme_config[0] & ~((buint32_t)0x1 << 14)) | \
		((((buint32_t)f) & 0x1) << 14))

#define bcm84756_a0_FCM_FCME_CONFIGr_DBG_CURRENTSTATEf_GET(c,r)         \
	((((r).fcm_fcme_config[0]) >> 16) & 0x3f)

#define bcm84756_a0_FCM_FCME_CONFIGr_DBG_CURRENTSTATEf_SET(c,r,f)       \
	(r).fcm_fcme_config[0]=(((r).fcm_fcme_config[0] & ~((buint32_t)0x3f << 16)) | \
		((((buint32_t)f) & 0x3f) << 16))


/*
 * These macros can be used to access FCM_FCME_CONFIG.
 *
 */
#define bcm84756_a0_READ_FCM_FCME_CONFIGr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCME_CONFIGr((c)),&((r)._fcm_fcme_config))

#define bcm84756_a0_WRITE_FCM_FCME_CONFIGr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCME_CONFIGr((c)),&((r)._fcm_fcme_config))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCME_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCME_MAC_SRC
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Configures how the mapper creates the Dest MAC and Src MAC fields for an
 *	 encapsulated packet.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FCOE_SA_MODE     :
 *     SrcMAC address construction mode: 2'b00 - FPMA Source Mode; SA is the
 *     concatenation of a per-port 24-bit prefix with the 24-bit FC SID 2'b01
 *     - Null Source Mode; SA is all zeroes 2'b10 - Register Source Mode; All
 *     48-bits of the SA are from the SrcMAC default register. 2'b11 -
 *     Reserved
 *
 *  FCOE_DA_MODE     :
 *     DestMAC address construction mode: 2'b00 - FPMA Destination Mode; DA is
 *     the concatenation of a per-port 24-bit prefix with the 24-bit FC DID
 *     2'b01 - Null Destination Mode; DA is all zeroes. 2'b10 - Register
 *     Destination Mode; All 48-bits of the DA are from the DestMAC default
 *     register. 2'b11 - Reserved
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCME_MAC_SRCr(c) \
		(0x1310000e + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCME_MAC_SRCr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCME_MAC_SRC.
 *
 */
typedef union bcm84756_a0_FCM_FCME_MAC_SRCr_s {
	buint32_t v[1];
	buint32_t fcm_fcme_mac_src[1];
	buint32_t _fcm_fcme_mac_src;
} bcm84756_a0_FCM_FCME_MAC_SRCr_t;

#define bcm84756_a0_FCM_FCME_MAC_SRCr_CLR(r)   \
            (r).fcm_fcme_mac_src[0] = 0

#define bcm84756_a0_FCM_FCME_MAC_SRCr_SET(r,d) \
            (r).fcm_fcme_mac_src[0] = d

#define bcm84756_a0_FCM_FCME_MAC_SRCr_GET(r)   \
            (r).fcm_fcme_mac_src[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCME_MAC_SRCr_FCOE_SA_MODEf_GET(c,r)         \
	(((r).fcm_fcme_mac_src[0]) & 0x3)

#define bcm84756_a0_FCM_FCME_MAC_SRCr_FCOE_SA_MODEf_SET(c,r,f)       \
	(r).fcm_fcme_mac_src[0]=(((r).fcm_fcme_mac_src[0] & ~((buint32_t)0x3)) | \
		(((buint32_t)f) & 0x3))

#define bcm84756_a0_FCM_FCME_MAC_SRCr_FCOE_DA_MODEf_GET(c,r)         \
	((((r).fcm_fcme_mac_src[0]) >> 2) & 0x3)

#define bcm84756_a0_FCM_FCME_MAC_SRCr_FCOE_DA_MODEf_SET(c,r,f)       \
	(r).fcm_fcme_mac_src[0]=(((r).fcm_fcme_mac_src[0] & ~((buint32_t)0x3 << 2)) | \
		((((buint32_t)f) & 0x3) << 2))


/*
 * These macros can be used to access FCM_FCME_MAC_SRC.
 *
 */
#define bcm84756_a0_READ_FCM_FCME_MAC_SRCr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCME_MAC_SRCr((c)),&((r)._fcm_fcme_mac_src))

#define bcm84756_a0_WRITE_FCM_FCME_MAC_SRCr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCME_MAC_SRCr((c)),&((r)._fcm_fcme_mac_src))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCME_MAC_SRCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCME_VFTHDR_PROC_MODE
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Configures how the mapper creates, removes, or modifies the VFT Header
 *	 field of a FCoE packet or FC-2 frame.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  HOPCOUNT_DISCARD_ENABLE :
 *     Hop count discard enable and mode. If Hopcnt == 1, discard (or EOFni)
 *     on ingress OR egress, else do not discard. 2'b00, 2'b01 - Disable hop
 *     count based discard. 2'b10 - Enable hop count based discard. drop
 *     packet and increment corresponding MIB drop counter, 2'b11 - Enable hop
 *     count based discard, change EOF to EOFni, do not drop packet.
 *
 *  HOPCOUNT_DECR_ENABLE :
 *     Enable VFT HopCount field auto decrement. (HopCnt discard is checked
 *     before the decrement is done). 1 - Enable hop count decrement in VFT
 *     Header, 0 - Disable hop count decrement. When HopCnt Auto-Decrement
 *     mode is enabled, if Hopcnt > 1 decrement on egress.
 *
 *  VFID_MAPSRC      :
 *     Define source of post-mapper VFID field when VFTHdr exists at
 *     post-mapper. 3'b000 - Disable VFID field processing. 3'b001 - Pass thru
 *     VFID field else use port default if not exist. 3'b010 - Apply Port
 *     default to VFID field. 3'b011 - Apply VLAN VID field directly to VFID
 *     field, else use port default if 802.1Q tag does not exist at VLAN.
 *     3'b100 - Apply Map result (as defined in map table input and map table
 *     direction) to VFID field. else use port default if 802.1Q tag does not
 *     exist. Other - Reserved
 *
 *  VFTHDR_PRESENCE  :
 *     Preserve/Insert/Drop setting of the post-mapper packet or frame. 2'b00
 *     - Preserve VFT Header -- an existing VFT header is preserved and mapped
 *     according to VFID mapsrc. If a VFT Header does not exist, VFT
 *     processing is skipped . 2'b01 - In this mode the frame will be
 *     forwarded with a VFT header. If a VFT header does not exist, the mapper
 *     will create and insert a VFT header based on the VFID mapsrc setting.
 *     Otherwise if a VFT header does exist, the mapper will process the
 *     existing VFT header as programmed in VFID mapsrc. If VFT header does
 *     not exist, a VFT header will be inserted and the programmed VFID mapsrc
 *     will be applied to this inserted VFT header. If VFT header does already
 *     exist, the programmed VFID mapsrc will be applied to existing VFT
 *     header. 2'b10 - Drop VFTHdr if exists, otherwise do nothing if VFTHdr
 *     does not exist. 2'b11 - Reserved
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr(c) \
		(0x1310000c + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCME_VFTHDR_PROC_MODE.
 *
 */
typedef union bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr_s {
	buint32_t v[1];
	buint32_t fcm_fcme_vfthdr_proc_mode[1];
	buint32_t _fcm_fcme_vfthdr_proc_mode;
} bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr_t;

#define bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr_CLR(r)   \
            (r).fcm_fcme_vfthdr_proc_mode[0] = 0

#define bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr_SET(r,d) \
            (r).fcm_fcme_vfthdr_proc_mode[0] = d

#define bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr_GET(r)   \
            (r).fcm_fcme_vfthdr_proc_mode[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr_HOPCOUNT_DISCARD_ENABLEf_GET(c,r)         \
	(((r).fcm_fcme_vfthdr_proc_mode[0]) & 0x3)

#define bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr_HOPCOUNT_DISCARD_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcme_vfthdr_proc_mode[0]=(((r).fcm_fcme_vfthdr_proc_mode[0] & ~((buint32_t)0x3)) | \
		(((buint32_t)f) & 0x3))

#define bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr_HOPCOUNT_DECR_ENABLEf_GET(c,r)         \
	((((r).fcm_fcme_vfthdr_proc_mode[0]) >> 2) & 0x1)

#define bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr_HOPCOUNT_DECR_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcme_vfthdr_proc_mode[0]=(((r).fcm_fcme_vfthdr_proc_mode[0] & ~((buint32_t)0x1 << 2)) | \
		((((buint32_t)f) & 0x1) << 2))

#define bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr_VFID_MAPSRCf_GET(c,r)         \
	((((r).fcm_fcme_vfthdr_proc_mode[0]) >> 4) & 0x7)

#define bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr_VFID_MAPSRCf_SET(c,r,f)       \
	(r).fcm_fcme_vfthdr_proc_mode[0]=(((r).fcm_fcme_vfthdr_proc_mode[0] & ~((buint32_t)0x7 << 4)) | \
		((((buint32_t)f) & 0x7) << 4))

#define bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr_VFTHDR_PRESENCEf_GET(c,r)         \
	((((r).fcm_fcme_vfthdr_proc_mode[0]) >> 8) & 0x3)

#define bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr_VFTHDR_PRESENCEf_SET(c,r,f)       \
	(r).fcm_fcme_vfthdr_proc_mode[0]=(((r).fcm_fcme_vfthdr_proc_mode[0] & ~((buint32_t)0x3 << 8)) | \
		((((buint32_t)f) & 0x3) << 8))


/*
 * These macros can be used to access FCM_FCME_VFTHDR_PROC_MODE.
 *
 */
#define bcm84756_a0_READ_FCM_FCME_VFTHDR_PROC_MODEr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr((c)),&((r)._fcm_fcme_vfthdr_proc_mode))

#define bcm84756_a0_WRITE_FCM_FCME_VFTHDR_PROC_MODEr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr((c)),&((r)._fcm_fcme_vfthdr_proc_mode))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCME_VFTHDR_PROC_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCME_VLANTAG_PROC_MODE
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Configures how the mapper creates, removes, or modifies the 802.1Q tag
 *	 field of a FCoE packet.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  PRI_MAP_MODE     :
 *     Post-Mapper VLAN tag PRI Field Processing; VLAN PRI to VLAN PRI mapping
 *     mode. 1 - Pass thru PRI if VLAN tag exists else use port default. 0 -
 *     Use PRI port default.
 *
 *  VLANTAG_MAPSRC   :
 *     Define source of post-mapper VLAN tag field when a VLAN tag exists at
 *     post-mapper. 2'b00 - Pass thru VLANtag field from VFID else use port
 *     default if not exist. 2'b01 - Pass thru VLANtag field from VLANtag else
 *     use port default if not exist. 2'b10 - Apply Port default to VLANtag
 *     field. 2'b11 - Apply Map result (as defined inport mode) to VLANtag
 *     field, else use port default. if 802.1Q tag does not exist at VLAN.
 *
 *  VLANTAG_PRESENCE :
 *     Drop/Insert/Pass setting of the post-mapper packet. 2'b00 - Disable
 *     VLANtag processing -- No change. 2'b01 - Insert VLANtag if it does not
 *     exist, else pass thru if it does exist. 2'b10 - Remove VLANtag if
 *     exists, otherwise do nothing if VFTHdr does not exist. 2'b11 - reserved
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr(c) \
		(0x1310000d + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCME_VLANTAG_PROC_MODE.
 *
 */
typedef union bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr_s {
	buint32_t v[1];
	buint32_t fcm_fcme_vlantag_proc_mode[1];
	buint32_t _fcm_fcme_vlantag_proc_mode;
} bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr_t;

#define bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr_CLR(r)   \
            (r).fcm_fcme_vlantag_proc_mode[0] = 0

#define bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr_SET(r,d) \
            (r).fcm_fcme_vlantag_proc_mode[0] = d

#define bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr_GET(r)   \
            (r).fcm_fcme_vlantag_proc_mode[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr_PRI_MAP_MODEf_GET(c,r)         \
	(((r).fcm_fcme_vlantag_proc_mode[0]) & 0x1)

#define bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr_PRI_MAP_MODEf_SET(c,r,f)       \
	(r).fcm_fcme_vlantag_proc_mode[0]=(((r).fcm_fcme_vlantag_proc_mode[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr_VLANTAG_MAPSRCf_GET(c,r)         \
	((((r).fcm_fcme_vlantag_proc_mode[0]) >> 3) & 0x3)

#define bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr_VLANTAG_MAPSRCf_SET(c,r,f)       \
	(r).fcm_fcme_vlantag_proc_mode[0]=(((r).fcm_fcme_vlantag_proc_mode[0] & ~((buint32_t)0x3 << 3)) | \
		((((buint32_t)f) & 0x3) << 3))

#define bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr_VLANTAG_PRESENCEf_GET(c,r)         \
	((((r).fcm_fcme_vlantag_proc_mode[0]) >> 5) & 0x3)

#define bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr_VLANTAG_PRESENCEf_SET(c,r,f)       \
	(r).fcm_fcme_vlantag_proc_mode[0]=(((r).fcm_fcme_vlantag_proc_mode[0] & ~((buint32_t)0x3 << 5)) | \
		((((buint32_t)f) & 0x3) << 5))


/*
 * These macros can be used to access FCM_FCME_VLANTAG_PROC_MODE.
 *
 */
#define bcm84756_a0_READ_FCM_FCME_VLANTAG_PROC_MODEr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr((c)),&((r)._fcm_fcme_vlantag_proc_mode))

#define bcm84756_a0_WRITE_FCM_FCME_VLANTAG_PROC_MODEr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr((c)),&((r)._fcm_fcme_vlantag_proc_mode))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCME_VLANTAG_PROC_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMI_CONFIG
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 This register allows general configuation of the FCM Mapper in the ingress
 *	 direction.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FCS_REGEN_MODE   :
 *     This mode allows the FC frame within the FCoE packet to be modified by
 *     an external switch with FCM Mapper handling the CRC recomputation. 1 -
 *     No CRC Check Mode; Mapper checks FCS and if it's good generate a good
 *     CRC regardless of the inner CRC. If FCS is bad generate a bad CRC.
 *     Applies to all frames whether FC frame is modified by the FCM Mapper or
 *     not. 0 - Normal; FCS and CRC checked before regenerating CRC. If FCS or
 *     CRC is bad, a bad FCS and/or CRC is regenerated.
 *
 *  FCS_EOF_MODE     :
 *     Enables FCS to be forcibly corrupted based on EOF. Applies only to FCoE
 *     packets when fcs field present is set. 1 - Receiving a packet with
 *     EOFni or EOFa forces a bad FCS word on encapsulation. 0 - FCS is not
 *     modified based on EOF type.
 *
 *  FCS_FIELD_PRESENT :
 *     Indicates format of packets between the switch MAC and line MAC. 1 -
 *     FCS is present and generated as necessary on all packets. 0 - FCS field
 *     is not present on input packets and is not generated on output packets.
 *
 *  DBG_IGNORE_CRC   :
 *     Ignore CRC debug mode. 1 - CRC is not checked by mapper, value is
 *     always considered good. 0 - Normal operating mode.
 *
 *  MAP_TABLE_INPUT  :
 *     Map table input can be from VFT Header or from VLAN tag. Determines
 *     what field is used as map table input : 1 = VLAN tag VID field. 0 = VFT
 *     Header VFID field.
 *
 *  MAP_TABLE_DIRECTION :
 *     Determines which table output is used for the mapped result : 1 = VLAN
 *     entry maps to VSAN output. 0 = VSAN entry maps to VLAN output.
 *
 *  DISCARD_BADPKT_DISABLE :
 *     Disable auto discard of bad packets due to parsed invalid fields : 1 =
 *     Mapper forwards packets parsed as bad. 0 = Mapper discards packets
 *     parsed as bad.
 *
 *  MAPPER_BYPASS_ENABLE :
 *     Disable auto discard of runt packets : 1 = Mapper datapath is bypassed.
 *     0 = Normal mode.
 *
 *  ENCAP_FC2FCOE_EN :
 *     FCoE Encap enable bit. This bit should be 1 for FC to FCoE operation,
 *     and it should be 0 for FCoE to FCoE operation. 1 - Enable FCoE
 *     encapsulation (FC/FCoE deployment model), 0 - FCoE encapsulation not
 *     done (FCoE/FCoE deployment model).
 *
 *  DBG_CURRENTSTATE :
 *     FCMI Mapper FSM state.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMI_CONFIGr(c) \
		(0x13100007 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMI_CONFIGr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMI_CONFIG.
 *
 */
typedef union bcm84756_a0_FCM_FCMI_CONFIGr_s {
	buint32_t v[1];
	buint32_t fcm_fcmi_config[1];
	buint32_t _fcm_fcmi_config;
} bcm84756_a0_FCM_FCMI_CONFIGr_t;

#define bcm84756_a0_FCM_FCMI_CONFIGr_CLR(r)   \
            (r).fcm_fcmi_config[0] = 0

#define bcm84756_a0_FCM_FCMI_CONFIGr_SET(r,d) \
            (r).fcm_fcmi_config[0] = d

#define bcm84756_a0_FCM_FCMI_CONFIGr_GET(r)   \
            (r).fcm_fcmi_config[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMI_CONFIGr_FCS_REGEN_MODEf_GET(c,r)         \
	(((r).fcm_fcmi_config[0]) & 0x1)

#define bcm84756_a0_FCM_FCMI_CONFIGr_FCS_REGEN_MODEf_SET(c,r,f)       \
	(r).fcm_fcmi_config[0]=(((r).fcm_fcmi_config[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMI_CONFIGr_FCS_EOF_MODEf_GET(c,r)         \
	((((r).fcm_fcmi_config[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCMI_CONFIGr_FCS_EOF_MODEf_SET(c,r,f)       \
	(r).fcm_fcmi_config[0]=(((r).fcm_fcmi_config[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))

#define bcm84756_a0_FCM_FCMI_CONFIGr_FCS_FIELD_PRESENTf_GET(c,r)         \
	((((r).fcm_fcmi_config[0]) >> 2) & 0x1)

#define bcm84756_a0_FCM_FCMI_CONFIGr_FCS_FIELD_PRESENTf_SET(c,r,f)       \
	(r).fcm_fcmi_config[0]=(((r).fcm_fcmi_config[0] & ~((buint32_t)0x1 << 2)) | \
		((((buint32_t)f) & 0x1) << 2))

#define bcm84756_a0_FCM_FCMI_CONFIGr_DBG_IGNORE_CRCf_GET(c,r)         \
	((((r).fcm_fcmi_config[0]) >> 3) & 0x1)

#define bcm84756_a0_FCM_FCMI_CONFIGr_DBG_IGNORE_CRCf_SET(c,r,f)       \
	(r).fcm_fcmi_config[0]=(((r).fcm_fcmi_config[0] & ~((buint32_t)0x1 << 3)) | \
		((((buint32_t)f) & 0x1) << 3))

#define bcm84756_a0_FCM_FCMI_CONFIGr_MAP_TABLE_INPUTf_GET(c,r)         \
	((((r).fcm_fcmi_config[0]) >> 4) & 0x1)

#define bcm84756_a0_FCM_FCMI_CONFIGr_MAP_TABLE_INPUTf_SET(c,r,f)       \
	(r).fcm_fcmi_config[0]=(((r).fcm_fcmi_config[0] & ~((buint32_t)0x1 << 4)) | \
		((((buint32_t)f) & 0x1) << 4))

#define bcm84756_a0_FCM_FCMI_CONFIGr_MAP_TABLE_DIRECTIONf_GET(c,r)         \
	((((r).fcm_fcmi_config[0]) >> 5) & 0x1)

#define bcm84756_a0_FCM_FCMI_CONFIGr_MAP_TABLE_DIRECTIONf_SET(c,r,f)       \
	(r).fcm_fcmi_config[0]=(((r).fcm_fcmi_config[0] & ~((buint32_t)0x1 << 5)) | \
		((((buint32_t)f) & 0x1) << 5))

#define bcm84756_a0_FCM_FCMI_CONFIGr_DISCARD_BADPKT_DISABLEf_GET(c,r)         \
	((((r).fcm_fcmi_config[0]) >> 6) & 0x1)

#define bcm84756_a0_FCM_FCMI_CONFIGr_DISCARD_BADPKT_DISABLEf_SET(c,r,f)       \
	(r).fcm_fcmi_config[0]=(((r).fcm_fcmi_config[0] & ~((buint32_t)0x1 << 6)) | \
		((((buint32_t)f) & 0x1) << 6))

#define bcm84756_a0_FCM_FCMI_CONFIGr_MAPPER_BYPASS_ENABLEf_GET(c,r)         \
	((((r).fcm_fcmi_config[0]) >> 7) & 0x1)

#define bcm84756_a0_FCM_FCMI_CONFIGr_MAPPER_BYPASS_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcmi_config[0]=(((r).fcm_fcmi_config[0] & ~((buint32_t)0x1 << 7)) | \
		((((buint32_t)f) & 0x1) << 7))

#define bcm84756_a0_FCM_FCMI_CONFIGr_ENCAP_FC2FCOE_ENf_GET(c,r)         \
	((((r).fcm_fcmi_config[0]) >> 15) & 0x1)

#define bcm84756_a0_FCM_FCMI_CONFIGr_ENCAP_FC2FCOE_ENf_SET(c,r,f)       \
	(r).fcm_fcmi_config[0]=(((r).fcm_fcmi_config[0] & ~((buint32_t)0x1 << 15)) | \
		((((buint32_t)f) & 0x1) << 15))

#define bcm84756_a0_FCM_FCMI_CONFIGr_DBG_CURRENTSTATEf_GET(c,r)         \
	((((r).fcm_fcmi_config[0]) >> 16) & 0x3f)

#define bcm84756_a0_FCM_FCMI_CONFIGr_DBG_CURRENTSTATEf_SET(c,r,f)       \
	(r).fcm_fcmi_config[0]=(((r).fcm_fcmi_config[0] & ~((buint32_t)0x3f << 16)) | \
		((((buint32_t)f) & 0x3f) << 16))


/*
 * These macros can be used to access FCM_FCMI_CONFIG.
 *
 */
#define bcm84756_a0_READ_FCM_FCMI_CONFIGr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMI_CONFIGr((c)),&((r)._fcm_fcmi_config))

#define bcm84756_a0_WRITE_FCM_FCMI_CONFIGr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMI_CONFIGr((c)),&((r)._fcm_fcmi_config))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMI_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMI_MAC_SRC
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Configures how the mapper creates the Dest MAC and Src MAC fields for an
 *	 encapsulated packet.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FCOE_SA_MODE     :
 *     SrcMAC address construction mode: 2'b00 - FPMA Source Mode; SA is the
 *     concatenation of a per-port 24-bit prefix with the 24-bit FC SID 2'b01
 *     - Null Source Mode; SA is all zeroes 2'b10 - Register Source Mode; All
 *     48-bits of the SA are from the SrcMAC default register. 2'b11 -
 *     Reserved
 *
 *  FCOE_DA_MODE     :
 *     DestMAC address construction mode: 2'b00 - FPMA Destination Mode; DA is
 *     the concatenation of a per-port 24-bit prefix with the 24-bit FC DID
 *     2'b01 - Null Destination Mode; DA is all zeroes. 2'b10 - Register
 *     Destination Mode; All 48-bits of the DA are from the DestMAC default
 *     register. 2'b11 - Reserved
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMI_MAC_SRCr(c) \
		(0x1310000a + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMI_MAC_SRCr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMI_MAC_SRC.
 *
 */
typedef union bcm84756_a0_FCM_FCMI_MAC_SRCr_s {
	buint32_t v[1];
	buint32_t fcm_fcmi_mac_src[1];
	buint32_t _fcm_fcmi_mac_src;
} bcm84756_a0_FCM_FCMI_MAC_SRCr_t;

#define bcm84756_a0_FCM_FCMI_MAC_SRCr_CLR(r)   \
            (r).fcm_fcmi_mac_src[0] = 0

#define bcm84756_a0_FCM_FCMI_MAC_SRCr_SET(r,d) \
            (r).fcm_fcmi_mac_src[0] = d

#define bcm84756_a0_FCM_FCMI_MAC_SRCr_GET(r)   \
            (r).fcm_fcmi_mac_src[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMI_MAC_SRCr_FCOE_SA_MODEf_GET(c,r)         \
	(((r).fcm_fcmi_mac_src[0]) & 0x3)

#define bcm84756_a0_FCM_FCMI_MAC_SRCr_FCOE_SA_MODEf_SET(c,r,f)       \
	(r).fcm_fcmi_mac_src[0]=(((r).fcm_fcmi_mac_src[0] & ~((buint32_t)0x3)) | \
		(((buint32_t)f) & 0x3))

#define bcm84756_a0_FCM_FCMI_MAC_SRCr_FCOE_DA_MODEf_GET(c,r)         \
	((((r).fcm_fcmi_mac_src[0]) >> 2) & 0x3)

#define bcm84756_a0_FCM_FCMI_MAC_SRCr_FCOE_DA_MODEf_SET(c,r,f)       \
	(r).fcm_fcmi_mac_src[0]=(((r).fcm_fcmi_mac_src[0] & ~((buint32_t)0x3 << 2)) | \
		((((buint32_t)f) & 0x3) << 2))


/*
 * These macros can be used to access FCM_FCMI_MAC_SRC.
 *
 */
#define bcm84756_a0_READ_FCM_FCMI_MAC_SRCr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMI_MAC_SRCr((c)),&((r)._fcm_fcmi_mac_src))

#define bcm84756_a0_WRITE_FCM_FCMI_MAC_SRCr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMI_MAC_SRCr((c)),&((r)._fcm_fcmi_mac_src))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMI_MAC_SRCr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMI_VFTHDR_PROC_MODE
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Configures how the mapper creates, removes, or modifies the VFT Header
 *	 field of a FCoE packet or FC-2 frame.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  HOPCOUNT_DISCARD_ENABLE :
 *     Hop count discard enable and mode. If Hopcnt == 1, discard (or EOFni)
 *     on ingress OR egress, else do not discard. 2'b00, 2'b01 - Disable hop
 *     count based discard. 2'b10 - Enable hop count based discard. drop
 *     packet and increment corresponding MIB drop counter, 2'b11 - Enable hop
 *     count based discard, change EOF to EOFni, do not drop packet.
 *
 *  HOPCOUNT_DECR_ENABLE :
 *     Enable VFT HopCount field auto decrement. (HopCnt discard is checked
 *     before the decrement is done). 1 - Enable hop count decrement in VFT
 *     Header, 0 - Disable hop count decrement. When HopCnt Auto-Decrement
 *     mode is enabled, if Hopcnt > 1 decrement on egress.
 *
 *  VFID_MAPSRC      :
 *     Define source of post-mapper VFID field when VFTHdr exists at
 *     post-mapper. 3'b000 - Disable VFID field processing. 3'b001 - Pass thru
 *     VFID field else use port default if not exist. 3'b010 - Apply Port
 *     default to VFID field. 3'b011 - Apply VLAN VID field directly to VFID
 *     field, else use port default if 802.1Q tag does not exist at VLAN.
 *     3'b100 - Apply Map result (as defined in map table input and map table
 *     direction) to VFID field. else use port default if 802.1Q tag does not
 *     exist. Other - Reserved
 *
 *  VFTHDR_PRESENCE  :
 *     Preserve/Insert/Drop setting of the post-mapper packet or frame. 2'b00
 *     - Preserve VFT Header -- an existing VFT header is preserved and mapped
 *     according to VFID mapsrc. If a VFT Header does not exist, VFT
 *     processing is skipped . 2'b01 - In this mode the frame will be
 *     forwarded with a VFT header. If a VFT header does not exist, the mapper
 *     will create and insert a VFT header based on the VFID mapsrc setting.
 *     Otherwise if a VFT header does exist, the mapper will process the
 *     existing VFT header as programmed in VFID mapsrc. If VFT header does
 *     not exist, a VFT header will be inserted and the programmed VFID mapsrc
 *     will be applied to this inserted VFT header. If VFT header does already
 *     exist, the programmed VFID mapsrc will be applied to existing VFT
 *     header. 2'b10 - Drop VFTHdr if exists, otherwise do nothing if VFTHdr
 *     does not exist. 2'b11 - reserved
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr(c) \
		(0x13100008 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMI_VFTHDR_PROC_MODE.
 *
 */
typedef union bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr_s {
	buint32_t v[1];
	buint32_t fcm_fcmi_vfthdr_proc_mode[1];
	buint32_t _fcm_fcmi_vfthdr_proc_mode;
} bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr_t;

#define bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr_CLR(r)   \
            (r).fcm_fcmi_vfthdr_proc_mode[0] = 0

#define bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr_SET(r,d) \
            (r).fcm_fcmi_vfthdr_proc_mode[0] = d

#define bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr_GET(r)   \
            (r).fcm_fcmi_vfthdr_proc_mode[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr_HOPCOUNT_DISCARD_ENABLEf_GET(c,r)         \
	(((r).fcm_fcmi_vfthdr_proc_mode[0]) & 0x3)

#define bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr_HOPCOUNT_DISCARD_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcmi_vfthdr_proc_mode[0]=(((r).fcm_fcmi_vfthdr_proc_mode[0] & ~((buint32_t)0x3)) | \
		(((buint32_t)f) & 0x3))

#define bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr_HOPCOUNT_DECR_ENABLEf_GET(c,r)         \
	((((r).fcm_fcmi_vfthdr_proc_mode[0]) >> 2) & 0x1)

#define bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr_HOPCOUNT_DECR_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcmi_vfthdr_proc_mode[0]=(((r).fcm_fcmi_vfthdr_proc_mode[0] & ~((buint32_t)0x1 << 2)) | \
		((((buint32_t)f) & 0x1) << 2))

#define bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr_VFID_MAPSRCf_GET(c,r)         \
	((((r).fcm_fcmi_vfthdr_proc_mode[0]) >> 4) & 0x7)

#define bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr_VFID_MAPSRCf_SET(c,r,f)       \
	(r).fcm_fcmi_vfthdr_proc_mode[0]=(((r).fcm_fcmi_vfthdr_proc_mode[0] & ~((buint32_t)0x7 << 4)) | \
		((((buint32_t)f) & 0x7) << 4))

#define bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr_VFTHDR_PRESENCEf_GET(c,r)         \
	((((r).fcm_fcmi_vfthdr_proc_mode[0]) >> 8) & 0x3)

#define bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr_VFTHDR_PRESENCEf_SET(c,r,f)       \
	(r).fcm_fcmi_vfthdr_proc_mode[0]=(((r).fcm_fcmi_vfthdr_proc_mode[0] & ~((buint32_t)0x3 << 8)) | \
		((((buint32_t)f) & 0x3) << 8))


/*
 * These macros can be used to access FCM_FCMI_VFTHDR_PROC_MODE.
 *
 */
#define bcm84756_a0_READ_FCM_FCMI_VFTHDR_PROC_MODEr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr((c)),&((r)._fcm_fcmi_vfthdr_proc_mode))

#define bcm84756_a0_WRITE_FCM_FCMI_VFTHDR_PROC_MODEr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr((c)),&((r)._fcm_fcmi_vfthdr_proc_mode))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMI_VFTHDR_PROC_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMI_VLANTAG_PROC_MODE
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Configures how the mapper creates, removes, or modifies the 802.1Q tag
 *	 field of a FCoE packet.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  PRI_MAP_MODE     :
 *     Post-Mapper VLAN tag PRI Field Processing; VLAN PRI to VLAN PRI mapping
 *     mode. 1 - Pass thru PRI if VLAN tag exists else use port default. 0 -
 *     Use PRI port default.
 *
 *  VLANTAG_MAPSRC   :
 *     Define source of post-mapper VLAN tag field when a VLAN tag exists at
 *     post-mapper. 2'b00 - Pass thru VLANtag field from VFID else use port
 *     default if not exist. 2'b01 - Pass thru VLANtag field from VLANtag else
 *     use port default if not exist. 2'b10 - Apply Port default to VLANtag
 *     field. 2'b11 - Apply Map result (as defined inport mode) to VLANtag
 *     field, else use port default. if 802.1Q tag does not exist at VLAN.
 *
 *  VLANTAG_PRESENCE :
 *     Drop/Insert/Pass setting of the post-mapper packet. 2'b00 - Disable
 *     VLANtag processing -- No change. 2'b01 - Insert VLANtag if it does not
 *     exist, else pass thru if it does exist. 2'b10 - Remove VLANtag if
 *     exists, otherwise do nothing if VLANtag does not exist. 2'b11 -
 *     reserved
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr(c) \
		(0x13100009 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMI_VLANTAG_PROC_MODE.
 *
 */
typedef union bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr_s {
	buint32_t v[1];
	buint32_t fcm_fcmi_vlantag_proc_mode[1];
	buint32_t _fcm_fcmi_vlantag_proc_mode;
} bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr_t;

#define bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr_CLR(r)   \
            (r).fcm_fcmi_vlantag_proc_mode[0] = 0

#define bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr_SET(r,d) \
            (r).fcm_fcmi_vlantag_proc_mode[0] = d

#define bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr_GET(r)   \
            (r).fcm_fcmi_vlantag_proc_mode[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr_PRI_MAP_MODEf_GET(c,r)         \
	(((r).fcm_fcmi_vlantag_proc_mode[0]) & 0x1)

#define bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr_PRI_MAP_MODEf_SET(c,r,f)       \
	(r).fcm_fcmi_vlantag_proc_mode[0]=(((r).fcm_fcmi_vlantag_proc_mode[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr_VLANTAG_MAPSRCf_GET(c,r)         \
	((((r).fcm_fcmi_vlantag_proc_mode[0]) >> 3) & 0x3)

#define bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr_VLANTAG_MAPSRCf_SET(c,r,f)       \
	(r).fcm_fcmi_vlantag_proc_mode[0]=(((r).fcm_fcmi_vlantag_proc_mode[0] & ~((buint32_t)0x3 << 3)) | \
		((((buint32_t)f) & 0x3) << 3))

#define bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr_VLANTAG_PRESENCEf_GET(c,r)         \
	((((r).fcm_fcmi_vlantag_proc_mode[0]) >> 5) & 0x3)

#define bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr_VLANTAG_PRESENCEf_SET(c,r,f)       \
	(r).fcm_fcmi_vlantag_proc_mode[0]=(((r).fcm_fcmi_vlantag_proc_mode[0] & ~((buint32_t)0x3 << 5)) | \
		((((buint32_t)f) & 0x3) << 5))


/*
 * These macros can be used to access FCM_FCMI_VLANTAG_PROC_MODE.
 *
 */
#define bcm84756_a0_READ_FCM_FCMI_VLANTAG_PROC_MODEr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr((c)),&((r)._fcm_fcmi_vlantag_proc_mode))

#define bcm84756_a0_WRITE_FCM_FCMI_VLANTAG_PROC_MODEr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr((c)),&((r)._fcm_fcmi_vlantag_proc_mode))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMI_VLANTAG_PROC_MODEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMON_INTR_MASK
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 FCMON Interrupt pin mask register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  HOSTM            :
 *     Mask the FCMON interrupt from asserting the o int host signal.
 *
 *  LOCALM           :
 *     Mask the FCMON interrupt from asserting the o int local signal.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMON_INTR_MASKr(c) \
		(0x1310001b + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMON_INTR_MASKr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMON_INTR_MASK.
 *
 */
typedef union bcm84756_a0_FCM_FCMON_INTR_MASKr_s {
	buint32_t v[1];
	buint32_t fcm_fcmon_intr_mask[1];
	buint32_t _fcm_fcmon_intr_mask;
} bcm84756_a0_FCM_FCMON_INTR_MASKr_t;

#define bcm84756_a0_FCM_FCMON_INTR_MASKr_CLR(r)   \
            (r).fcm_fcmon_intr_mask[0] = 0

#define bcm84756_a0_FCM_FCMON_INTR_MASKr_SET(r,d) \
            (r).fcm_fcmon_intr_mask[0] = d

#define bcm84756_a0_FCM_FCMON_INTR_MASKr_GET(r)   \
            (r).fcm_fcmon_intr_mask[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMON_INTR_MASKr_HOSTMf_GET(c,r)         \
	(((r).fcm_fcmon_intr_mask[0]) & 0x1)

#define bcm84756_a0_FCM_FCMON_INTR_MASKr_HOSTMf_SET(c,r,f)       \
	(r).fcm_fcmon_intr_mask[0]=(((r).fcm_fcmon_intr_mask[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMON_INTR_MASKr_LOCALMf_GET(c,r)         \
	((((r).fcm_fcmon_intr_mask[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCMON_INTR_MASKr_LOCALMf_SET(c,r,f)       \
	(r).fcm_fcmon_intr_mask[0]=(((r).fcm_fcmon_intr_mask[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))


/*
 * These macros can be used to access FCM_FCMON_INTR_MASK.
 *
 */
#define bcm84756_a0_READ_FCM_FCMON_INTR_MASKr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMON_INTR_MASKr((c)),&((r)._fcm_fcmon_intr_mask))

#define bcm84756_a0_WRITE_FCM_FCMON_INTR_MASKr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMON_INTR_MASKr((c)),&((r)._fcm_fcmon_intr_mask))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMON_INTR_MASKr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMON_RX_AUTO_SPEED_CONFIG
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 FCMON RX Auto Speed Config.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FC_OPER_RATE     :
 *     Configures the Fiber Channel Rx block speed. 3'b000 - auto-speed
 *     detection 3'b001 - reserved 3'b010 - 2.125 Gb/s 3'b011 - 4.25 Gb/s
 *     3'b100 - 8.5 Gb/s others - reserved
 *
 *  FC_AUTO_SPEED_RESET :
 *     Writing 1 will re-initialize the auto-speed detection process fc auto
 *     speed reset is self-clearing.
 *
 *  FC_AUTO_SPEED_SYNC_TEST_START :
 *     Writing 1 will re-initialize the auto-speed sync test at the current
 *     speed. The speed won't change once this process is done. The fc auto
 *     speed sync test start bit is self-clearing., 0 - The Fiber Channel 8GFC
 *     sync test interrupt is masked at the interrupt pin. 1 - The Fiber
 *     Channel 8GFC sync test interrupt is enabled.
 *
 *  FC_AUTO_SPEED_DELAY :
 *     Configure the auto-speed detect delay. (TBD: write-only?) 0 - The delay
 *     in the auto-speed detection is 25 usec 1 - The delay in the auto-speed
 *     detection is 50 usec
 *
 *  FC_AUTO_SPEED_SELF_RESTART :
 *     fc auto speed self restart. (TBD: write-only?) 0 - The auto-speed
 *     detection does not restart on a loss of word synchronization. 1 - The
 *     auto-speed detection does restart on a loss of word synchronization.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr(c) \
		(0x13100089 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMON_RX_AUTO_SPEED_CONFIG.
 *
 */
typedef union bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_s {
	buint32_t v[1];
	buint32_t fcm_fcmon_rx_auto_speed_config[1];
	buint32_t _fcm_fcmon_rx_auto_speed_config;
} bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_t;

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_CLR(r)   \
            (r).fcm_fcmon_rx_auto_speed_config[0] = 0

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_SET(r,d) \
            (r).fcm_fcmon_rx_auto_speed_config[0] = d

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_GET(r)   \
            (r).fcm_fcmon_rx_auto_speed_config[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_FC_OPER_RATEf_GET(c,r)         \
	(((r).fcm_fcmon_rx_auto_speed_config[0]) & 0x7)

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_FC_OPER_RATEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_auto_speed_config[0]=(((r).fcm_fcmon_rx_auto_speed_config[0] & ~((buint32_t)0x7)) | \
		(((buint32_t)f) & 0x7))

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_FC_AUTO_SPEED_RESETf_GET(c,r)         \
	((((r).fcm_fcmon_rx_auto_speed_config[0]) >> 6) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_FC_AUTO_SPEED_RESETf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_auto_speed_config[0]=(((r).fcm_fcmon_rx_auto_speed_config[0] & ~((buint32_t)0x1 << 6)) | \
		((((buint32_t)f) & 0x1) << 6))

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_FC_AUTO_SPEED_SYNC_TEST_STARTf_GET(c,r)         \
	((((r).fcm_fcmon_rx_auto_speed_config[0]) >> 7) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_FC_AUTO_SPEED_SYNC_TEST_STARTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_auto_speed_config[0]=(((r).fcm_fcmon_rx_auto_speed_config[0] & ~((buint32_t)0x1 << 7)) | \
		((((buint32_t)f) & 0x1) << 7))

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_FC_AUTO_SPEED_DELAYf_GET(c,r)         \
	((((r).fcm_fcmon_rx_auto_speed_config[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_FC_AUTO_SPEED_DELAYf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_auto_speed_config[0]=(((r).fcm_fcmon_rx_auto_speed_config[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_FC_AUTO_SPEED_SELF_RESTARTf_GET(c,r)         \
	((((r).fcm_fcmon_rx_auto_speed_config[0]) >> 9) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr_FC_AUTO_SPEED_SELF_RESTARTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_auto_speed_config[0]=(((r).fcm_fcmon_rx_auto_speed_config[0] & ~((buint32_t)0x1 << 9)) | \
		((((buint32_t)f) & 0x1) << 9))


/*
 * These macros can be used to access FCM_FCMON_RX_AUTO_SPEED_CONFIG.
 *
 */
#define bcm84756_a0_READ_FCM_FCMON_RX_AUTO_SPEED_CONFIGr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr((c)),&((r)._fcm_fcmon_rx_auto_speed_config))

#define bcm84756_a0_WRITE_FCM_FCMON_RX_AUTO_SPEED_CONFIGr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr((c)),&((r)._fcm_fcmon_rx_auto_speed_config))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMON_RX_AUTO_SPEED_STATUS
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 FCMON RX Auto Speed Status.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FC_RX_LINK_SPEED :
 *     Speed in operation: 3'b010 - 2.125 Gb/s 3'b011 - 4.25 Gb/s 3'b100 - 8.5
 *     Gb/s
 *
 *  FC_AUTO_SPEED_SYNC_TEST_END :
 *     Indicates that the auto-speed sync test has completed.
 *
 *  FC_AUTO_SPEED_SYNC_TEST_FAIL :
 *     Indicates that the auto-speed sync test has failed for the current link
 *     speed.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr(c) \
		(0x1310008a + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMON_RX_AUTO_SPEED_STATUS.
 *
 */
typedef union bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr_s {
	buint32_t v[1];
	buint32_t fcm_fcmon_rx_auto_speed_status[1];
	buint32_t _fcm_fcmon_rx_auto_speed_status;
} bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr_t;

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr_CLR(r)   \
            (r).fcm_fcmon_rx_auto_speed_status[0] = 0

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr_SET(r,d) \
            (r).fcm_fcmon_rx_auto_speed_status[0] = d

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr_GET(r)   \
            (r).fcm_fcmon_rx_auto_speed_status[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr_FC_RX_LINK_SPEEDf_GET(c,r)         \
	(((r).fcm_fcmon_rx_auto_speed_status[0]) & 0x7)

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr_FC_RX_LINK_SPEEDf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_auto_speed_status[0]=(((r).fcm_fcmon_rx_auto_speed_status[0] & ~((buint32_t)0x7)) | \
		(((buint32_t)f) & 0x7))

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr_FC_AUTO_SPEED_SYNC_TEST_ENDf_GET(c,r)         \
	((((r).fcm_fcmon_rx_auto_speed_status[0]) >> 7) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr_FC_AUTO_SPEED_SYNC_TEST_ENDf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_auto_speed_status[0]=(((r).fcm_fcmon_rx_auto_speed_status[0] & ~((buint32_t)0x1 << 7)) | \
		((((buint32_t)f) & 0x1) << 7))

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr_FC_AUTO_SPEED_SYNC_TEST_FAILf_GET(c,r)         \
	((((r).fcm_fcmon_rx_auto_speed_status[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr_FC_AUTO_SPEED_SYNC_TEST_FAILf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_auto_speed_status[0]=(((r).fcm_fcmon_rx_auto_speed_status[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))


/*
 * These macros can be used to access FCM_FCMON_RX_AUTO_SPEED_STATUS.
 *
 */
#define bcm84756_a0_READ_FCM_FCMON_RX_AUTO_SPEED_STATUSr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr((c)),&((r)._fcm_fcmon_rx_auto_speed_status))

#define bcm84756_a0_WRITE_FCM_FCMON_RX_AUTO_SPEED_STATUSr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr((c)),&((r)._fcm_fcmon_rx_auto_speed_status))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMON_RX_AUTO_SPEED_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMON_RX_CONTROL
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 FCMON Control Reg.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FC_PWR_DWN       :
 *     FCMON powerdown. 0 - The Fiber Channel Rx block in alive 1 - The Fiber
 *     Channel Rx block is powered down (except the configuration registers)
 *
 *  FC_SW_RST        :
 *     FCMON RX reset. 0 - The Fiber Channel Rx block is functional 1 - The
 *     Fiber Channel Rx block is in reset
 *
 *  WSYNC_MODE       :
 *     Word sync state machine mode. 0 - The Fiber Channel synchronizes on any
 *     comma word 1 - The Fiber Channel synchronizes only on K28.5 character
 *
 *  WSYNC_RST        :
 *     Word sync state machine reset. 0 - The Fiber Channel Word
 *     Synchronization funtions normally 1 - The Fiber Channel Word
 *     Synchronization is in reset state.
 *
 *  COMMA_DETECT_WINDOW :
 *     Comma detection mode. An interrupt is declared if a comma character is
 *     not detected within the window. 000 : 25 usec 001 : 50 usec 010 : 100
 *     usec 011 : 200 usec 100 : 400 usec 101 : 800 usec 110 : 1600 usec 111 :
 *     3200 usec
 *
 *  RX10B_BIT_ORDER  :
 *     Receive data bit order reversal. 0 - Normal bit order. 1 - Reverse RX
 *     10b word bit order.
 *
 *  CDR_REQ_SEQSTART :
 *     Word sync state machine mode.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMON_RX_CONTROLr(c) \
		(0x13100085 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMON_RX_CONTROL.
 *
 */
typedef union bcm84756_a0_FCM_FCMON_RX_CONTROLr_s {
	buint32_t v[1];
	buint32_t fcm_fcmon_rx_control[1];
	buint32_t _fcm_fcmon_rx_control;
} bcm84756_a0_FCM_FCMON_RX_CONTROLr_t;

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_CLR(r)   \
            (r).fcm_fcmon_rx_control[0] = 0

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_SET(r,d) \
            (r).fcm_fcmon_rx_control[0] = d

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_GET(r)   \
            (r).fcm_fcmon_rx_control[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_FC_PWR_DWNf_GET(c,r)         \
	(((r).fcm_fcmon_rx_control[0]) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_FC_PWR_DWNf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_control[0]=(((r).fcm_fcmon_rx_control[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_FC_SW_RSTf_GET(c,r)         \
	((((r).fcm_fcmon_rx_control[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_FC_SW_RSTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_control[0]=(((r).fcm_fcmon_rx_control[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_WSYNC_MODEf_GET(c,r)         \
	((((r).fcm_fcmon_rx_control[0]) >> 3) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_WSYNC_MODEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_control[0]=(((r).fcm_fcmon_rx_control[0] & ~((buint32_t)0x1 << 3)) | \
		((((buint32_t)f) & 0x1) << 3))

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_WSYNC_RSTf_GET(c,r)         \
	((((r).fcm_fcmon_rx_control[0]) >> 4) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_WSYNC_RSTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_control[0]=(((r).fcm_fcmon_rx_control[0] & ~((buint32_t)0x1 << 4)) | \
		((((buint32_t)f) & 0x1) << 4))

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_COMMA_DETECT_WINDOWf_GET(c,r)         \
	((((r).fcm_fcmon_rx_control[0]) >> 5) & 0x7)

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_COMMA_DETECT_WINDOWf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_control[0]=(((r).fcm_fcmon_rx_control[0] & ~((buint32_t)0x7 << 5)) | \
		((((buint32_t)f) & 0x7) << 5))

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_RX10B_BIT_ORDERf_GET(c,r)         \
	((((r).fcm_fcmon_rx_control[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_RX10B_BIT_ORDERf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_control[0]=(((r).fcm_fcmon_rx_control[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_CDR_REQ_SEQSTARTf_GET(c,r)         \
	((((r).fcm_fcmon_rx_control[0]) >> 9) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_CONTROLr_CDR_REQ_SEQSTARTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_control[0]=(((r).fcm_fcmon_rx_control[0] & ~((buint32_t)0x1 << 9)) | \
		((((buint32_t)f) & 0x1) << 9))


/*
 * These macros can be used to access FCM_FCMON_RX_CONTROL.
 *
 */
#define bcm84756_a0_READ_FCM_FCMON_RX_CONTROLr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMON_RX_CONTROLr((c)),&((r)._fcm_fcmon_rx_control))

#define bcm84756_a0_WRITE_FCM_FCMON_RX_CONTROLr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMON_RX_CONTROLr((c)),&((r)._fcm_fcmon_rx_control))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMON_RX_CONTROLr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMON_RX_INTERRUPTS
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 FCMON Status Reg.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FC_WORD_SYNC_ACQ_INT :
 *     Word Sync status change. 0 - The Fiber Channel word synchronization
 *     status did not changed since the last read of this register. 1 - The
 *     Fiber Channel word synchronization status changed since the last read
 *     of this register.
 *
 *  FC_LINK_FAIL_INT :
 *     A link failure is declared when the port is in the loss of sync state
 *     for r t tov. 0 - The Fiber Channel word link did not failed since the
 *     last read of this register. 1 - The Fiber Channel word link failed
 *     since the last read of this register.
 *
 *  FC_SPEED_ACQ_INT :
 *     Auto speed acquired. 0 - The Fiber Channel Auto-Speed Detection did not
 *     acquire a speed since the last read of this register. 1 - The Fiber
 *     Channel Auto-Speed Detection acquired a speed since the last read of
 *     this register.
 *
 *  FC_8B10B_CODE_ERROR_INT :
 *     8b10b code error. 0 - The Fiber Channel 8B/10B decoder did not detect
 *     any code error since the last read of this register. 1 - The Fiber
 *     Channel 8B/10B decoder detected a code error since the last read of
 *     this register.
 *
 *  FC_8B10B_DISPARITY_ERROR_INT :
 *     8b10b disparity error. 0 - The Fiber Channel 8B/10B decoder did not
 *     detect any disparity error since the last read of this register. 1 -
 *     The Fiber Channel 8B/10B decoder detected a disparity error since the
 *     last read of this register.
 *
 *  FC_40B_CODE_ERROR_INT :
 *     RX 40b code error. 0 - The Fiber Channel word decoder did not detect
 *     any error since the last read of this register. 1 - The Fiber Channel
 *     word decoder detected an error since the last read of this register.
 *
 *  FC_COMMA_DETECT_INT :
 *     comma detect. 0 - The Fiber Channel word synchronizer did detect within
 *     the specified window (comma detect window). 1 - The Fiber Channel word
 *     synchronizer did not detect within the specified window (comma detect
 *     window).
 *
 *  FC_2G_SYNC_TEST_FAILED_INT :
 *     2g sync test failed. 0 - The Fiber Channel 2GFC sync test did not
 *     failed since the last read of this register. 1 - The Fiber Channel 2GFC
 *     sync test did failed since the last read of this register.
 *
 *  FC_4G_SYNC_TEST_FAILED_INT :
 *     4g sync test failed. 0 - The Fiber Channel 4GFC sync test did not
 *     failed since the last read of this register. 1 - The Fiber Channel 4GFC
 *     sync test did failed since the last read of this register.
 *
 *  FC_8G_SYNC_TEST_FAILED_INT :
 *     8g sync test failed. 0 - The Fiber Channel 8GFC sync test did not
 *     failed since the last read of this register. 1 - The Fiber Channel 8GFC
 *     sync test did failed since the last read of this register.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr(c) \
		(0x13100087 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMON_RX_INTERRUPTS.
 *
 */
typedef union bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_s {
	buint32_t v[1];
	buint32_t fcm_fcmon_rx_interrupts[1];
	buint32_t _fcm_fcmon_rx_interrupts;
} bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_t;

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_CLR(r)   \
            (r).fcm_fcmon_rx_interrupts[0] = 0

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_SET(r,d) \
            (r).fcm_fcmon_rx_interrupts[0] = d

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_GET(r)   \
            (r).fcm_fcmon_rx_interrupts[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_WORD_SYNC_ACQ_INTf_GET(c,r)         \
	(((r).fcm_fcmon_rx_interrupts[0]) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_WORD_SYNC_ACQ_INTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupts[0]=(((r).fcm_fcmon_rx_interrupts[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_LINK_FAIL_INTf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupts[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_LINK_FAIL_INTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupts[0]=(((r).fcm_fcmon_rx_interrupts[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_SPEED_ACQ_INTf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupts[0]) >> 2) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_SPEED_ACQ_INTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupts[0]=(((r).fcm_fcmon_rx_interrupts[0] & ~((buint32_t)0x1 << 2)) | \
		((((buint32_t)f) & 0x1) << 2))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_8B10B_CODE_ERROR_INTf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupts[0]) >> 3) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_8B10B_CODE_ERROR_INTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupts[0]=(((r).fcm_fcmon_rx_interrupts[0] & ~((buint32_t)0x1 << 3)) | \
		((((buint32_t)f) & 0x1) << 3))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_8B10B_DISPARITY_ERROR_INTf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupts[0]) >> 4) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_8B10B_DISPARITY_ERROR_INTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupts[0]=(((r).fcm_fcmon_rx_interrupts[0] & ~((buint32_t)0x1 << 4)) | \
		((((buint32_t)f) & 0x1) << 4))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_40B_CODE_ERROR_INTf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupts[0]) >> 5) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_40B_CODE_ERROR_INTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupts[0]=(((r).fcm_fcmon_rx_interrupts[0] & ~((buint32_t)0x1 << 5)) | \
		((((buint32_t)f) & 0x1) << 5))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_COMMA_DETECT_INTf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupts[0]) >> 6) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_COMMA_DETECT_INTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupts[0]=(((r).fcm_fcmon_rx_interrupts[0] & ~((buint32_t)0x1 << 6)) | \
		((((buint32_t)f) & 0x1) << 6))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_2G_SYNC_TEST_FAILED_INTf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupts[0]) >> 7) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_2G_SYNC_TEST_FAILED_INTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupts[0]=(((r).fcm_fcmon_rx_interrupts[0] & ~((buint32_t)0x1 << 7)) | \
		((((buint32_t)f) & 0x1) << 7))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_4G_SYNC_TEST_FAILED_INTf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupts[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_4G_SYNC_TEST_FAILED_INTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupts[0]=(((r).fcm_fcmon_rx_interrupts[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_8G_SYNC_TEST_FAILED_INTf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupts[0]) >> 9) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr_FC_8G_SYNC_TEST_FAILED_INTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupts[0]=(((r).fcm_fcmon_rx_interrupts[0] & ~((buint32_t)0x1 << 9)) | \
		((((buint32_t)f) & 0x1) << 9))


/*
 * These macros can be used to access FCM_FCMON_RX_INTERRUPTS.
 *
 */
#define bcm84756_a0_READ_FCM_FCMON_RX_INTERRUPTSr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr((c)),&((r)._fcm_fcmon_rx_interrupts))

#define bcm84756_a0_WRITE_FCM_FCMON_RX_INTERRUPTSr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr((c)),&((r)._fcm_fcmon_rx_interrupts))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMON_RX_INTERRUPTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMON_RX_INTERRUPT_ENABLE
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 FCMON Interrupt Enable Reg.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FC_WORD_SYNC_ACQ_ENABLE :
 *     Word Sync status interrupt enable. 0 - The Fiber Channel word
 *     synchronization status is masked at the interrupt pin. 1 - The Fiber
 *     Channel word synchronization status interrupt enable.
 *
 *  FC_LINK_FAIL_ENABLE :
 *     Link failure interrupt enable. 0 - The Fiber Channel word link failed
 *     status is masked at the interrupt pin. 1 - The Fiber Channel word link
 *     failed interrupt enable.
 *
 *  FC_SPEED_ACQ_ENABLE :
 *     Auto speed acquired interrupt enable. 0 - The Fiber Channel Auto-Speed
 *     Detection is masked at the interrupt pin. 1 - The Fiber Channel
 *     Auto-Speed Detection interrupt enable.
 *
 *  FC_8B10B_CODE_ERROR_ENABLE :
 *     8b10b code error interrupt enable. 0 - The Fiber Channel 8B/10B decoder
 *     is masked at the interrupt pin. 1 - The Fiber Channel 8B/10B decoder
 *     interrupt enable.
 *
 *  FC_8B10B_DISPARITY_ERROR_ENABLE :
 *     8b10b disparity error interrupt enable. 0 - The Fiber Channel 8B/10B
 *     decoder is masked at the interrupt pin. 1 - The Fiber Channel 8B/10B
 *     decoder interrupt enable.
 *
 *  FC_40B_CODE_ERROR_ENABLE :
 *     RX 40b code error interrupt enable. 0 - The Fiber Channel word decoder
 *     is masked at the interrupt pin. 1 - The Fiber Channel word decoder
 *     interrupt enable.
 *
 *  FC_COMMA_DETECT_ENABLE :
 *     comma detect interrupt enable. 0 - The Fiber Channel word synchronizer
 *     is masked at the interrupt pin. 1 - The Fiber Channel word synchronizer
 *     interrupt enable.
 *
 *  FC_2G_SYNC_TEST_FAILED_ENABLE :
 *     2g sync test failed interrupt enable. 0 - The Fiber Channel 2GFC sync
 *     test is masked at the interrupt pin. 1 - The Fiber Channel 2GFC sync
 *     test interrupt enable.
 *
 *  FC_4G_SYNC_TEST_FAILED_ENABLE :
 *     4g sync test failed interrupt enable. 0 - The Fiber Channel 4GFC sync
 *     test interrupt is masked at the interrupt pin. 1 - The Fiber Channel
 *     4GFC sync test is enabled.
 *
 *  FC_8G_SYNC_TEST_FAILED_ENABLE :
 *     8g sync test failed interrupt enable. 0 - The Fiber Channel 8GFC sync
 *     test interrupt is masked at the interrupt pin. 1 - The Fiber Channel
 *     8GFC sync test interrupt is enabled.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr(c) \
		(0x13100088 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMON_RX_INTERRUPT_ENABLE.
 *
 */
typedef union bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_s {
	buint32_t v[1];
	buint32_t fcm_fcmon_rx_interrupt_enable[1];
	buint32_t _fcm_fcmon_rx_interrupt_enable;
} bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_t;

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_CLR(r)   \
            (r).fcm_fcmon_rx_interrupt_enable[0] = 0

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_SET(r,d) \
            (r).fcm_fcmon_rx_interrupt_enable[0] = d

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_GET(r)   \
            (r).fcm_fcmon_rx_interrupt_enable[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_WORD_SYNC_ACQ_ENABLEf_GET(c,r)         \
	(((r).fcm_fcmon_rx_interrupt_enable[0]) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_WORD_SYNC_ACQ_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupt_enable[0]=(((r).fcm_fcmon_rx_interrupt_enable[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_LINK_FAIL_ENABLEf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupt_enable[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_LINK_FAIL_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupt_enable[0]=(((r).fcm_fcmon_rx_interrupt_enable[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_SPEED_ACQ_ENABLEf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupt_enable[0]) >> 2) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_SPEED_ACQ_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupt_enable[0]=(((r).fcm_fcmon_rx_interrupt_enable[0] & ~((buint32_t)0x1 << 2)) | \
		((((buint32_t)f) & 0x1) << 2))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_8B10B_CODE_ERROR_ENABLEf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupt_enable[0]) >> 3) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_8B10B_CODE_ERROR_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupt_enable[0]=(((r).fcm_fcmon_rx_interrupt_enable[0] & ~((buint32_t)0x1 << 3)) | \
		((((buint32_t)f) & 0x1) << 3))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_8B10B_DISPARITY_ERROR_ENABLEf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupt_enable[0]) >> 4) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_8B10B_DISPARITY_ERROR_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupt_enable[0]=(((r).fcm_fcmon_rx_interrupt_enable[0] & ~((buint32_t)0x1 << 4)) | \
		((((buint32_t)f) & 0x1) << 4))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_40B_CODE_ERROR_ENABLEf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupt_enable[0]) >> 5) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_40B_CODE_ERROR_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupt_enable[0]=(((r).fcm_fcmon_rx_interrupt_enable[0] & ~((buint32_t)0x1 << 5)) | \
		((((buint32_t)f) & 0x1) << 5))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_COMMA_DETECT_ENABLEf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupt_enable[0]) >> 6) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_COMMA_DETECT_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupt_enable[0]=(((r).fcm_fcmon_rx_interrupt_enable[0] & ~((buint32_t)0x1 << 6)) | \
		((((buint32_t)f) & 0x1) << 6))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_2G_SYNC_TEST_FAILED_ENABLEf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupt_enable[0]) >> 7) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_2G_SYNC_TEST_FAILED_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupt_enable[0]=(((r).fcm_fcmon_rx_interrupt_enable[0] & ~((buint32_t)0x1 << 7)) | \
		((((buint32_t)f) & 0x1) << 7))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_4G_SYNC_TEST_FAILED_ENABLEf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupt_enable[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_4G_SYNC_TEST_FAILED_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupt_enable[0]=(((r).fcm_fcmon_rx_interrupt_enable[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_8G_SYNC_TEST_FAILED_ENABLEf_GET(c,r)         \
	((((r).fcm_fcmon_rx_interrupt_enable[0]) >> 9) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr_FC_8G_SYNC_TEST_FAILED_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_interrupt_enable[0]=(((r).fcm_fcmon_rx_interrupt_enable[0] & ~((buint32_t)0x1 << 9)) | \
		((((buint32_t)f) & 0x1) << 9))


/*
 * These macros can be used to access FCM_FCMON_RX_INTERRUPT_ENABLE.
 *
 */
#define bcm84756_a0_READ_FCM_FCMON_RX_INTERRUPT_ENABLEr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr((c)),&((r)._fcm_fcmon_rx_interrupt_enable))

#define bcm84756_a0_WRITE_FCM_FCMON_RX_INTERRUPT_ENABLEr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr((c)),&((r)._fcm_fcmon_rx_interrupt_enable))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMON_RX_INTERRUPT_ENABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMON_RX_R_T_TOV
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 R T TOV value register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  R_T_TOV          :
 *     FCMON RX time-out of word synchronization required to declare a link
 *     failure. Units are increments of 1.6384 usec; this default sets the
 *     timeout to 100 milliseconds. Note -- Other suggested test values to
 *     speed up simulation time : 0x3d = 100us 0x06 = 9.8us
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMON_RX_R_T_TOVr(c) \
		(0x1310008b + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMON_RX_R_T_TOVr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMON_RX_R_T_TOV.
 *
 */
typedef union bcm84756_a0_FCM_FCMON_RX_R_T_TOVr_s {
	buint32_t v[1];
	buint32_t fcm_fcmon_rx_r_t_tov[1];
	buint32_t _fcm_fcmon_rx_r_t_tov;
} bcm84756_a0_FCM_FCMON_RX_R_T_TOVr_t;

#define bcm84756_a0_FCM_FCMON_RX_R_T_TOVr_CLR(r)   \
            (r).fcm_fcmon_rx_r_t_tov[0] = 0

#define bcm84756_a0_FCM_FCMON_RX_R_T_TOVr_SET(r,d) \
            (r).fcm_fcmon_rx_r_t_tov[0] = d

#define bcm84756_a0_FCM_FCMON_RX_R_T_TOVr_GET(r)   \
            (r).fcm_fcmon_rx_r_t_tov[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMON_RX_R_T_TOVr_R_T_TOVf_GET(c,r)         \
	(((r).fcm_fcmon_rx_r_t_tov[0]) & 0xffff)

#define bcm84756_a0_FCM_FCMON_RX_R_T_TOVr_R_T_TOVf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_r_t_tov[0]=(((r).fcm_fcmon_rx_r_t_tov[0] & ~((buint32_t)0xffff)) | \
		(((buint32_t)f) & 0xffff))


/*
 * These macros can be used to access FCM_FCMON_RX_R_T_TOV.
 *
 */
#define bcm84756_a0_READ_FCM_FCMON_RX_R_T_TOVr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMON_RX_R_T_TOVr((c)),&((r)._fcm_fcmon_rx_r_t_tov))

#define bcm84756_a0_WRITE_FCM_FCMON_RX_R_T_TOVr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMON_RX_R_T_TOVr((c)),&((r)._fcm_fcmon_rx_r_t_tov))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMON_RX_R_T_TOVr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMON_RX_STATUS
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 FCMON Status Reg.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FC_WORD_SYNC_ACQ :
 *     FCMON powerdown. 0 - The Fiber Channel word synchronization is not
 *     acquired. 1 - The Fiber Channel word synchronization is acquired.
 *
 *  FC_SPEED_ACQ     :
 *     FCMON RX reset. 0 - The Fiber Channel Auto-Speed Detection did not
 *     acquired a speed. 1 - The Fiber Channel Auto-Speed Detection acquired a
 *     speed.
 *
 *  FC_SPEED_DETECTION_ACTIVE :
 *     Word sync state machine mode. 0 - The Fiber Channel Auto-Speed
 *     Detection is not running. 1 - The Fiber Channel Auto-Speed Detection is
 *     running.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMON_RX_STATUSr(c) \
		(0x13100086 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMON_RX_STATUSr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMON_RX_STATUS.
 *
 */
typedef union bcm84756_a0_FCM_FCMON_RX_STATUSr_s {
	buint32_t v[1];
	buint32_t fcm_fcmon_rx_status[1];
	buint32_t _fcm_fcmon_rx_status;
} bcm84756_a0_FCM_FCMON_RX_STATUSr_t;

#define bcm84756_a0_FCM_FCMON_RX_STATUSr_CLR(r)   \
            (r).fcm_fcmon_rx_status[0] = 0

#define bcm84756_a0_FCM_FCMON_RX_STATUSr_SET(r,d) \
            (r).fcm_fcmon_rx_status[0] = d

#define bcm84756_a0_FCM_FCMON_RX_STATUSr_GET(r)   \
            (r).fcm_fcmon_rx_status[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMON_RX_STATUSr_FC_WORD_SYNC_ACQf_GET(c,r)         \
	(((r).fcm_fcmon_rx_status[0]) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_STATUSr_FC_WORD_SYNC_ACQf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_status[0]=(((r).fcm_fcmon_rx_status[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMON_RX_STATUSr_FC_SPEED_ACQf_GET(c,r)         \
	((((r).fcm_fcmon_rx_status[0]) >> 1) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_STATUSr_FC_SPEED_ACQf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_status[0]=(((r).fcm_fcmon_rx_status[0] & ~((buint32_t)0x1 << 1)) | \
		((((buint32_t)f) & 0x1) << 1))

#define bcm84756_a0_FCM_FCMON_RX_STATUSr_FC_SPEED_DETECTION_ACTIVEf_GET(c,r)         \
	((((r).fcm_fcmon_rx_status[0]) >> 2) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_STATUSr_FC_SPEED_DETECTION_ACTIVEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_status[0]=(((r).fcm_fcmon_rx_status[0] & ~((buint32_t)0x1 << 2)) | \
		((((buint32_t)f) & 0x1) << 2))


/*
 * These macros can be used to access FCM_FCMON_RX_STATUS.
 *
 */
#define bcm84756_a0_READ_FCM_FCMON_RX_STATUSr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMON_RX_STATUSr((c)),&((r)._fcm_fcmon_rx_status))

#define bcm84756_a0_WRITE_FCM_FCMON_RX_STATUSr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMON_RX_STATUSr((c)),&((r)._fcm_fcmon_rx_status))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMON_RX_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMON_RX_tpat_mon_config
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 RX Test Pattern Monitor Configuration register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FC_TPAT_MON_ENABLE :
 *     Tpat monitor enable: 0 - The Fiber Channel Test Pattern Monitor is
 *     disabled. 1 - The Fiber Channel Test Pattern Monitor is enabled.
 *
 *  FC_TPAT_MODE     :
 *     Fiber Channel Test Pattern Type: 2'b00 - JSPAT 2'b01 - JTSPAT 2'b10 -
 *     CJTPAT 2'b11 - CRPAT
 *
 *  FC_TPAD_IDLE     :
 *     Number of IDLE ordered sets to monitor between each test pattern.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr(c) \
		(0x1310008c + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMON_RX_tpat_mon_config.
 *
 */
typedef union bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr_s {
	buint32_t v[1];
	buint32_t fcm_fcmon_rx_tpat_mon_config[1];
	buint32_t _fcm_fcmon_rx_tpat_mon_config;
} bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr_t;

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr_CLR(r)   \
            (r).fcm_fcmon_rx_tpat_mon_config[0] = 0

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr_SET(r,d) \
            (r).fcm_fcmon_rx_tpat_mon_config[0] = d

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr_GET(r)   \
            (r).fcm_fcmon_rx_tpat_mon_config[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr_FC_TPAT_MON_ENABLEf_GET(c,r)         \
	(((r).fcm_fcmon_rx_tpat_mon_config[0]) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr_FC_TPAT_MON_ENABLEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_tpat_mon_config[0]=(((r).fcm_fcmon_rx_tpat_mon_config[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr_FC_TPAT_MODEf_GET(c,r)         \
	((((r).fcm_fcmon_rx_tpat_mon_config[0]) >> 1) & 0x3)

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr_FC_TPAT_MODEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_tpat_mon_config[0]=(((r).fcm_fcmon_rx_tpat_mon_config[0] & ~((buint32_t)0x3 << 1)) | \
		((((buint32_t)f) & 0x3) << 1))

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr_FC_TPAD_IDLEf_GET(c,r)         \
	((((r).fcm_fcmon_rx_tpat_mon_config[0]) >> 3) & 0xf)

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr_FC_TPAD_IDLEf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_tpat_mon_config[0]=(((r).fcm_fcmon_rx_tpat_mon_config[0] & ~((buint32_t)0xf << 3)) | \
		((((buint32_t)f) & 0xf) << 3))


/*
 * These macros can be used to access FCM_FCMON_RX_tpat_mon_config.
 *
 */
#define bcm84756_a0_READ_FCM_FCMON_RX_TPAT_MON_CONFIGr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr((c)),&((r)._fcm_fcmon_rx_tpat_mon_config))

#define bcm84756_a0_WRITE_FCM_FCMON_RX_TPAT_MON_CONFIGr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr((c)),&((r)._fcm_fcmon_rx_tpat_mon_config))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMON_RX_TPAT_MON_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMON_RX_tpat_mon_counter
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Tpat monitor pattern counter.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FC_TPAT_MON_CNT  :
 *     Number of Fiber Channel test patterns received since the last read of
 *     this register.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_COUNTERr(c) \
		(0x1310008e + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_COUNTERr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMON_RX_tpat_mon_counter.
 *
 */
typedef union bcm84756_a0_FCM_FCMON_RX_TPAT_MON_COUNTERr_s {
	buint32_t v[1];
	buint32_t fcm_fcmon_rx_tpat_mon_counter[1];
	buint32_t _fcm_fcmon_rx_tpat_mon_counter;
} bcm84756_a0_FCM_FCMON_RX_TPAT_MON_COUNTERr_t;

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_COUNTERr_CLR(r)   \
            (r).fcm_fcmon_rx_tpat_mon_counter[0] = 0

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_COUNTERr_SET(r,d) \
            (r).fcm_fcmon_rx_tpat_mon_counter[0] = d

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_COUNTERr_GET(r)   \
            (r).fcm_fcmon_rx_tpat_mon_counter[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_COUNTERr_FC_TPAT_MON_CNTf_GET(c,r)         \
	(((r).fcm_fcmon_rx_tpat_mon_counter[0]) & 0xffff)

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_COUNTERr_FC_TPAT_MON_CNTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_tpat_mon_counter[0]=(((r).fcm_fcmon_rx_tpat_mon_counter[0] & ~((buint32_t)0xffff)) | \
		(((buint32_t)f) & 0xffff))


/*
 * These macros can be used to access FCM_FCMON_RX_tpat_mon_counter.
 *
 */
#define bcm84756_a0_READ_FCM_FCMON_RX_TPAT_MON_COUNTERr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMON_RX_TPAT_MON_COUNTERr((c)),&((r)._fcm_fcmon_rx_tpat_mon_counter))

#define bcm84756_a0_WRITE_FCM_FCMON_RX_TPAT_MON_COUNTERr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMON_RX_TPAT_MON_COUNTERr((c)),&((r)._fcm_fcmon_rx_tpat_mon_counter))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMON_RX_TPAT_MON_COUNTERr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMON_RX_tpat_mon_errcnt
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Tpat monitor pattern error counter.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FC_TPAT_MON_ERRCNT :
 *     Number of Fiber Channel 40-bit words containing errors while the Test
 *     Pattern Monitor is locked.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_ERRCNTr(c) \
		(0x1310008f + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_ERRCNTr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMON_RX_tpat_mon_errcnt.
 *
 */
typedef union bcm84756_a0_FCM_FCMON_RX_TPAT_MON_ERRCNTr_s {
	buint32_t v[1];
	buint32_t fcm_fcmon_rx_tpat_mon_errcnt[1];
	buint32_t _fcm_fcmon_rx_tpat_mon_errcnt;
} bcm84756_a0_FCM_FCMON_RX_TPAT_MON_ERRCNTr_t;

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_ERRCNTr_CLR(r)   \
            (r).fcm_fcmon_rx_tpat_mon_errcnt[0] = 0

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_ERRCNTr_SET(r,d) \
            (r).fcm_fcmon_rx_tpat_mon_errcnt[0] = d

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_ERRCNTr_GET(r)   \
            (r).fcm_fcmon_rx_tpat_mon_errcnt[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_ERRCNTr_FC_TPAT_MON_ERRCNTf_GET(c,r)         \
	(((r).fcm_fcmon_rx_tpat_mon_errcnt[0]) & 0xffff)

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_ERRCNTr_FC_TPAT_MON_ERRCNTf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_tpat_mon_errcnt[0]=(((r).fcm_fcmon_rx_tpat_mon_errcnt[0] & ~((buint32_t)0xffff)) | \
		(((buint32_t)f) & 0xffff))


/*
 * These macros can be used to access FCM_FCMON_RX_tpat_mon_errcnt.
 *
 */
#define bcm84756_a0_READ_FCM_FCMON_RX_TPAT_MON_ERRCNTr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMON_RX_TPAT_MON_ERRCNTr((c)),&((r)._fcm_fcmon_rx_tpat_mon_errcnt))

#define bcm84756_a0_WRITE_FCM_FCMON_RX_TPAT_MON_ERRCNTr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMON_RX_TPAT_MON_ERRCNTr((c)),&((r)._fcm_fcmon_rx_tpat_mon_errcnt))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMON_RX_TPAT_MON_ERRCNTr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FCMON_RX_tpat_mon_status
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Tpat monitor status register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  FC_TPAT_MON_LOCK :
 *     Test pattern monitor lock status: 0 - The Fiber Channel Test Pattern
 *     Monitor is not locked to the data. 1 - The Fiber Channel Test Pattern
 *     Monitor is locked to the data.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_STATUSr(c) \
		(0x1310008d + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_STATUSr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FCMON_RX_tpat_mon_status.
 *
 */
typedef union bcm84756_a0_FCM_FCMON_RX_TPAT_MON_STATUSr_s {
	buint32_t v[1];
	buint32_t fcm_fcmon_rx_tpat_mon_status[1];
	buint32_t _fcm_fcmon_rx_tpat_mon_status;
} bcm84756_a0_FCM_FCMON_RX_TPAT_MON_STATUSr_t;

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_STATUSr_CLR(r)   \
            (r).fcm_fcmon_rx_tpat_mon_status[0] = 0

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_STATUSr_SET(r,d) \
            (r).fcm_fcmon_rx_tpat_mon_status[0] = d

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_STATUSr_GET(r)   \
            (r).fcm_fcmon_rx_tpat_mon_status[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_STATUSr_FC_TPAT_MON_LOCKf_GET(c,r)         \
	(((r).fcm_fcmon_rx_tpat_mon_status[0]) & 0x1)

#define bcm84756_a0_FCM_FCMON_RX_TPAT_MON_STATUSr_FC_TPAT_MON_LOCKf_SET(c,r,f)       \
	(r).fcm_fcmon_rx_tpat_mon_status[0]=(((r).fcm_fcmon_rx_tpat_mon_status[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))


/*
 * These macros can be used to access FCM_FCMON_RX_tpat_mon_status.
 *
 */
#define bcm84756_a0_READ_FCM_FCMON_RX_TPAT_MON_STATUSr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FCMON_RX_TPAT_MON_STATUSr((c)),&((r)._fcm_fcmon_rx_tpat_mon_status))

#define bcm84756_a0_WRITE_FCM_FCMON_RX_TPAT_MON_STATUSr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FCMON_RX_TPAT_MON_STATUSr((c)),&((r)._fcm_fcmon_rx_tpat_mon_status))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FCMON_RX_TPAT_MON_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_FLUSH
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Frame buffer flush status and control register
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  TXBUF_SPACE_FILLED :
 *     Space filled in TX frame buffer, units of 128-bit words. Empty = 0,
 *     Full = 0x800.
 *
 *  TXBUF_EMPTY      :
 *     This bit is set when TX Frame buffer is empty.
 *
 *  TXBUF_FULL       :
 *     This bit is set when RX Frame buffer is full.
 *
 *  FLUSH_TX_DONE    :
 *     Single frame flush done, TX frame buffer.
 *
 *  FLUSH_TX_REQ     :
 *     Single frame flush request, TX frame buffer. Set this bit to flush a
 *     single TX frame at the FCMAC TX frame interface. When the flush tx done
 *     bit is polled set, clear the flush tx req bit.
 *
 *  RXBUF_SPACE_FILLED :
 *     Space filled in RX frame buffer, units of 128-bit words. Empty = 0,
 *     Full = 0x800.
 *
 *  RXBUF_EMPTY      :
 *     This bit is set when RX Frame buffer is empty.
 *
 *  RXBUF_FULL       :
 *     This bit is set when RX Frame buffer is full.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_FLUSHr(c) \
		(0x13100003 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_FLUSHr_SIZE 1

/*
 * This structure should be used to declare and program FCM_FLUSH.
 *
 */
typedef union bcm84756_a0_FCM_FLUSHr_s {
	buint32_t v[1];
	buint32_t fcm_flush[1];
	buint32_t _fcm_flush;
} bcm84756_a0_FCM_FLUSHr_t;

#define bcm84756_a0_FCM_FLUSHr_CLR(r)   \
            (r).fcm_flush[0] = 0

#define bcm84756_a0_FCM_FLUSHr_SET(r,d) \
            (r).fcm_flush[0] = d

#define bcm84756_a0_FCM_FLUSHr_GET(r)   \
            (r).fcm_flush[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_FLUSHr_TXBUF_SPACE_FILLEDf_GET(c,r)         \
	(((r).fcm_flush[0]) & 0xfff)

#define bcm84756_a0_FCM_FLUSHr_TXBUF_SPACE_FILLEDf_SET(c,r,f)       \
	(r).fcm_flush[0]=(((r).fcm_flush[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_FCM_FLUSHr_TXBUF_EMPTYf_GET(c,r)         \
	((((r).fcm_flush[0]) >> 12) & 0x1)

#define bcm84756_a0_FCM_FLUSHr_TXBUF_EMPTYf_SET(c,r,f)       \
	(r).fcm_flush[0]=(((r).fcm_flush[0] & ~((buint32_t)0x1 << 12)) | \
		((((buint32_t)f) & 0x1) << 12))

#define bcm84756_a0_FCM_FLUSHr_TXBUF_FULLf_GET(c,r)         \
	((((r).fcm_flush[0]) >> 13) & 0x1)

#define bcm84756_a0_FCM_FLUSHr_TXBUF_FULLf_SET(c,r,f)       \
	(r).fcm_flush[0]=(((r).fcm_flush[0] & ~((buint32_t)0x1 << 13)) | \
		((((buint32_t)f) & 0x1) << 13))

#define bcm84756_a0_FCM_FLUSHr_FLUSH_TX_DONEf_GET(c,r)         \
	((((r).fcm_flush[0]) >> 14) & 0x1)

#define bcm84756_a0_FCM_FLUSHr_FLUSH_TX_DONEf_SET(c,r,f)       \
	(r).fcm_flush[0]=(((r).fcm_flush[0] & ~((buint32_t)0x1 << 14)) | \
		((((buint32_t)f) & 0x1) << 14))

#define bcm84756_a0_FCM_FLUSHr_FLUSH_TX_REQf_GET(c,r)         \
	((((r).fcm_flush[0]) >> 15) & 0x1)

#define bcm84756_a0_FCM_FLUSHr_FLUSH_TX_REQf_SET(c,r,f)       \
	(r).fcm_flush[0]=(((r).fcm_flush[0] & ~((buint32_t)0x1 << 15)) | \
		((((buint32_t)f) & 0x1) << 15))

#define bcm84756_a0_FCM_FLUSHr_RXBUF_SPACE_FILLEDf_GET(c,r)         \
	((((r).fcm_flush[0]) >> 16) & 0xfff)

#define bcm84756_a0_FCM_FLUSHr_RXBUF_SPACE_FILLEDf_SET(c,r,f)       \
	(r).fcm_flush[0]=(((r).fcm_flush[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))

#define bcm84756_a0_FCM_FLUSHr_RXBUF_EMPTYf_GET(c,r)         \
	((((r).fcm_flush[0]) >> 28) & 0x1)

#define bcm84756_a0_FCM_FLUSHr_RXBUF_EMPTYf_SET(c,r,f)       \
	(r).fcm_flush[0]=(((r).fcm_flush[0] & ~((buint32_t)0x1 << 28)) | \
		((((buint32_t)f) & 0x1) << 28))

#define bcm84756_a0_FCM_FLUSHr_RXBUF_FULLf_GET(c,r)         \
	((((r).fcm_flush[0]) >> 29) & 0x1)

#define bcm84756_a0_FCM_FLUSHr_RXBUF_FULLf_SET(c,r,f)       \
	(r).fcm_flush[0]=(((r).fcm_flush[0] & ~((buint32_t)0x1 << 29)) | \
		((((buint32_t)f) & 0x1) << 29))


/*
 * These macros can be used to access FCM_FLUSH.
 *
 */
#define bcm84756_a0_READ_FCM_FLUSHr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_FLUSHr((c)),&((r)._fcm_flush))

#define bcm84756_a0_WRITE_FCM_FLUSHr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_FLUSHr((c)),&((r)._fcm_flush))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_FLUSHr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_LINK_RATE
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Set link rates of FCMAC. For use by speed autonegotiation firmware.
 *	 Overrides hardware autospeed detect.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  RX_RATE          :
 *     Configure RX link rate of FCMAC. 2'b00 - Set as 2Gig 2'b01 - Set as
 *     4Gig 2'b10 - Set as 8Gig 2'b11 - Enable hardware autospeed detect mode
 *     (FCMON)
 *
 *  TX_RATE          :
 *     Configure TX link rate of FCMAC. 2'b00 - Set as 2Gig 2'b01 - Set as
 *     4Gig 2'b10 - Set as 8Gig 2'b11 - Enable hardware autospeed detect mode
 *     (FCGEN)
 *
 *  FW_LINKRATE_DONE :
 *     This bit qualifies the o fcm rx lock sts status. This bit should be set
 *     by firware after speed negotiation is complete.
 *
 *  RX_LOCK_PIN_STS  :
 *     This bit reflects the o fcm rx lock sts pin state; o fcm rx lock sts =
 *     !wsyn loss sync && !serdes rx los && rx lock ready.
 *
 *  WSYN_LOSS_SYNC   :
 *     State of loss of word-sync status signal (intended for
 *     debug/diagnostics).
 *
 *  SERDES_RX_LOS    :
 *     State of serdes RX LOS input to FCMAC (intended for debug/diagnostics).
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_LINK_RATEr(c) \
		(0x13100063 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_LINK_RATEr_SIZE 1

/*
 * This structure should be used to declare and program FCM_LINK_RATE.
 *
 */
typedef union bcm84756_a0_FCM_LINK_RATEr_s {
	buint32_t v[1];
	buint32_t fcm_link_rate[1];
	buint32_t _fcm_link_rate;
} bcm84756_a0_FCM_LINK_RATEr_t;

#define bcm84756_a0_FCM_LINK_RATEr_CLR(r)   \
            (r).fcm_link_rate[0] = 0

#define bcm84756_a0_FCM_LINK_RATEr_SET(r,d) \
            (r).fcm_link_rate[0] = d

#define bcm84756_a0_FCM_LINK_RATEr_GET(r)   \
            (r).fcm_link_rate[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_LINK_RATEr_RX_RATEf_GET(c,r)         \
	(((r).fcm_link_rate[0]) & 0x3)

#define bcm84756_a0_FCM_LINK_RATEr_RX_RATEf_SET(c,r,f)       \
	(r).fcm_link_rate[0]=(((r).fcm_link_rate[0] & ~((buint32_t)0x3)) | \
		(((buint32_t)f) & 0x3))

#define bcm84756_a0_FCM_LINK_RATEr_TX_RATEf_GET(c,r)         \
	((((r).fcm_link_rate[0]) >> 4) & 0x3)

#define bcm84756_a0_FCM_LINK_RATEr_TX_RATEf_SET(c,r,f)       \
	(r).fcm_link_rate[0]=(((r).fcm_link_rate[0] & ~((buint32_t)0x3 << 4)) | \
		((((buint32_t)f) & 0x3) << 4))

#define bcm84756_a0_FCM_LINK_RATEr_FW_LINKRATE_DONEf_GET(c,r)         \
	((((r).fcm_link_rate[0]) >> 8) & 0x1)

#define bcm84756_a0_FCM_LINK_RATEr_FW_LINKRATE_DONEf_SET(c,r,f)       \
	(r).fcm_link_rate[0]=(((r).fcm_link_rate[0] & ~((buint32_t)0x1 << 8)) | \
		((((buint32_t)f) & 0x1) << 8))

#define bcm84756_a0_FCM_LINK_RATEr_RX_LOCK_PIN_STSf_GET(c,r)         \
	((((r).fcm_link_rate[0]) >> 9) & 0x1)

#define bcm84756_a0_FCM_LINK_RATEr_RX_LOCK_PIN_STSf_SET(c,r,f)       \
	(r).fcm_link_rate[0]=(((r).fcm_link_rate[0] & ~((buint32_t)0x1 << 9)) | \
		((((buint32_t)f) & 0x1) << 9))

#define bcm84756_a0_FCM_LINK_RATEr_WSYN_LOSS_SYNCf_GET(c,r)         \
	((((r).fcm_link_rate[0]) >> 10) & 0x1)

#define bcm84756_a0_FCM_LINK_RATEr_WSYN_LOSS_SYNCf_SET(c,r,f)       \
	(r).fcm_link_rate[0]=(((r).fcm_link_rate[0] & ~((buint32_t)0x1 << 10)) | \
		((((buint32_t)f) & 0x1) << 10))

#define bcm84756_a0_FCM_LINK_RATEr_SERDES_RX_LOSf_GET(c,r)         \
	((((r).fcm_link_rate[0]) >> 11) & 0x1)

#define bcm84756_a0_FCM_LINK_RATEr_SERDES_RX_LOSf_SET(c,r,f)       \
	(r).fcm_link_rate[0]=(((r).fcm_link_rate[0] & ~((buint32_t)0x1 << 11)) | \
		((((buint32_t)f) & 0x1) << 11))


/*
 * These macros can be used to access FCM_LINK_RATE.
 *
 */
#define bcm84756_a0_READ_FCM_LINK_RATEr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_LINK_RATEr((c)),&((r)._fcm_link_rate))

#define bcm84756_a0_WRITE_FCM_LINK_RATEr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_LINK_RATEr((c)),&((r)._fcm_link_rate))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_LINK_RATEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_LOOPBACK_CONFIG
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Enable loopback path at 16-bit TX to RX 8B data interfaces of FCMAC.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  LTR1             :
 *     Enable loopback path; FCM AC loopback at 16b interface. TXCLK drives
 *     RXCLK (no fiber necessary).
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_LOOPBACK_CONFIGr(c) \
		(0x13100006 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_LOOPBACK_CONFIGr_SIZE 1

/*
 * This structure should be used to declare and program FCM_LOOPBACK_CONFIG.
 *
 */
typedef union bcm84756_a0_FCM_LOOPBACK_CONFIGr_s {
	buint32_t v[1];
	buint32_t fcm_loopback_config[1];
	buint32_t _fcm_loopback_config;
} bcm84756_a0_FCM_LOOPBACK_CONFIGr_t;

#define bcm84756_a0_FCM_LOOPBACK_CONFIGr_CLR(r)   \
            (r).fcm_loopback_config[0] = 0

#define bcm84756_a0_FCM_LOOPBACK_CONFIGr_SET(r,d) \
            (r).fcm_loopback_config[0] = d

#define bcm84756_a0_FCM_LOOPBACK_CONFIGr_GET(r)   \
            (r).fcm_loopback_config[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_LOOPBACK_CONFIGr_LTR1f_GET(c,r)         \
	(((r).fcm_loopback_config[0]) & 0x1)

#define bcm84756_a0_FCM_LOOPBACK_CONFIGr_LTR1f_SET(c,r,f)       \
	(r).fcm_loopback_config[0]=(((r).fcm_loopback_config[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))


/*
 * These macros can be used to access FCM_LOOPBACK_CONFIG.
 *
 */
#define bcm84756_a0_READ_FCM_LOOPBACK_CONFIGr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_LOOPBACK_CONFIGr((c)),&((r)._fcm_loopback_config))

#define bcm84756_a0_WRITE_FCM_LOOPBACK_CONFIGr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_LOOPBACK_CONFIGr((c)),&((r)._fcm_loopback_config))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_LOOPBACK_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_LOS_STATUS
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 RX LOS status flag.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  LOS              :
 *     Sticky RX LOS Loss-of-word-sync status register. Clear on read.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_LOS_STATUSr(c) \
		(0x13100061 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_LOS_STATUSr_SIZE 1

/*
 * This structure should be used to declare and program FCM_LOS_STATUS.
 *
 */
typedef union bcm84756_a0_FCM_LOS_STATUSr_s {
	buint32_t v[1];
	buint32_t fcm_los_status[1];
	buint32_t _fcm_los_status;
} bcm84756_a0_FCM_LOS_STATUSr_t;

#define bcm84756_a0_FCM_LOS_STATUSr_CLR(r)   \
            (r).fcm_los_status[0] = 0

#define bcm84756_a0_FCM_LOS_STATUSr_SET(r,d) \
            (r).fcm_los_status[0] = d

#define bcm84756_a0_FCM_LOS_STATUSr_GET(r)   \
            (r).fcm_los_status[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_LOS_STATUSr_LOSf_GET(c,r)         \
	(((r).fcm_los_status[0]) & 0x1)

#define bcm84756_a0_FCM_LOS_STATUSr_LOSf_SET(c,r,f)       \
	(r).fcm_los_status[0]=(((r).fcm_los_status[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))


/*
 * These macros can be used to access FCM_LOS_STATUS.
 *
 */
#define bcm84756_a0_READ_FCM_LOS_STATUSr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_LOS_STATUSr((c)),&((r)._fcm_los_status))

#define bcm84756_a0_WRITE_FCM_LOS_STATUSr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_LOS_STATUSr((c)),&((r)._fcm_los_status))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_LOS_STATUSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_PCS_CONFIG
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Front-End TX and RX Configuration.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  PCS_SCRAMBLING_EN :
 *     Enable scrambled data in 8GFC.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_PCS_CONFIGr(c) \
		(0x1310001a + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_PCS_CONFIGr_SIZE 1

/*
 * This structure should be used to declare and program FCM_PCS_CONFIG.
 *
 */
typedef union bcm84756_a0_FCM_PCS_CONFIGr_s {
	buint32_t v[1];
	buint32_t fcm_pcs_config[1];
	buint32_t _fcm_pcs_config;
} bcm84756_a0_FCM_PCS_CONFIGr_t;

#define bcm84756_a0_FCM_PCS_CONFIGr_CLR(r)   \
            (r).fcm_pcs_config[0] = 0

#define bcm84756_a0_FCM_PCS_CONFIGr_SET(r,d) \
            (r).fcm_pcs_config[0] = d

#define bcm84756_a0_FCM_PCS_CONFIGr_GET(r)   \
            (r).fcm_pcs_config[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_PCS_CONFIGr_PCS_SCRAMBLING_ENf_GET(c,r)         \
	(((r).fcm_pcs_config[0]) & 0x1)

#define bcm84756_a0_FCM_PCS_CONFIGr_PCS_SCRAMBLING_ENf_SET(c,r,f)       \
	(r).fcm_pcs_config[0]=(((r).fcm_pcs_config[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))


/*
 * These macros can be used to access FCM_PCS_CONFIG.
 *
 */
#define bcm84756_a0_READ_FCM_PCS_CONFIGr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_PCS_CONFIGr((c)),&((r)._fcm_pcs_config))

#define bcm84756_a0_WRITE_FCM_PCS_CONFIGr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_PCS_CONFIGr((c)),&((r)._fcm_pcs_config))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_PCS_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_TX_DISABLE
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Front-end TX DISABLE output signal control bit.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  TX_DISABLE       :
 *     Provides direct control of the TX DISABLE output signal. 1= high, 0 =
 *     low.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_TX_DISABLEr(c) \
		(0x13100062 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_TX_DISABLEr_SIZE 1

/*
 * This structure should be used to declare and program FCM_TX_DISABLE.
 *
 */
typedef union bcm84756_a0_FCM_TX_DISABLEr_s {
	buint32_t v[1];
	buint32_t fcm_tx_disable[1];
	buint32_t _fcm_tx_disable;
} bcm84756_a0_FCM_TX_DISABLEr_t;

#define bcm84756_a0_FCM_TX_DISABLEr_CLR(r)   \
            (r).fcm_tx_disable[0] = 0

#define bcm84756_a0_FCM_TX_DISABLEr_SET(r,d) \
            (r).fcm_tx_disable[0] = d

#define bcm84756_a0_FCM_TX_DISABLEr_GET(r)   \
            (r).fcm_tx_disable[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_TX_DISABLEr_TX_DISABLEf_GET(c,r)         \
	(((r).fcm_tx_disable[0]) & 0x1)

#define bcm84756_a0_FCM_TX_DISABLEr_TX_DISABLEf_SET(c,r,f)       \
	(r).fcm_tx_disable[0]=(((r).fcm_tx_disable[0] & ~((buint32_t)0x1)) | \
		(((buint32_t)f) & 0x1))


/*
 * These macros can be used to access FCM_TX_DISABLE.
 *
 */
#define bcm84756_a0_READ_FCM_TX_DISABLEr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_TX_DISABLEr((c)),&((r)._fcm_tx_disable))

#define bcm84756_a0_WRITE_FCM_TX_DISABLEr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_TX_DISABLEr((c)),&((r)._fcm_tx_disable))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_TX_DISABLEr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_rxfrmbuf
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 RX (line to switch) Frame Buffer FIFO Write Pointer load register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  WRPTR            :
 *     RX Frame Buffer wrptr load register. Frame should be loaded starting at
 *     offset of rdptr. The wrptr register should be loaded with the location
 *     at the end of packet offset + 1. Units are 128-bit quad-words. MSbit
 *     indicates buffer wrap-around.
 *
 *  RDPTR            :
 *     RX Frame Buffer rdptr. Units are 128-bit quad-words. MSbit indicates
 *     buffer wrap-around.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_RXFRMBUFr(c) \
		(0x13100098 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_RXFRMBUFr_SIZE 1

/*
 * This structure should be used to declare and program FCM_rxfrmbuf.
 *
 */
typedef union bcm84756_a0_FCM_RXFRMBUFr_s {
	buint32_t v[1];
	buint32_t fcm_rxfrmbuf[1];
	buint32_t _fcm_rxfrmbuf;
} bcm84756_a0_FCM_RXFRMBUFr_t;

#define bcm84756_a0_FCM_RXFRMBUFr_CLR(r)   \
            (r).fcm_rxfrmbuf[0] = 0

#define bcm84756_a0_FCM_RXFRMBUFr_SET(r,d) \
            (r).fcm_rxfrmbuf[0] = d

#define bcm84756_a0_FCM_RXFRMBUFr_GET(r)   \
            (r).fcm_rxfrmbuf[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_RXFRMBUFr_WRPTRf_GET(c,r)         \
	(((r).fcm_rxfrmbuf[0]) & 0xfff)

#define bcm84756_a0_FCM_RXFRMBUFr_WRPTRf_SET(c,r,f)       \
	(r).fcm_rxfrmbuf[0]=(((r).fcm_rxfrmbuf[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_FCM_RXFRMBUFr_RDPTRf_GET(c,r)         \
	((((r).fcm_rxfrmbuf[0]) >> 16) & 0xfff)

#define bcm84756_a0_FCM_RXFRMBUFr_RDPTRf_SET(c,r,f)       \
	(r).fcm_rxfrmbuf[0]=(((r).fcm_rxfrmbuf[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access FCM_rxfrmbuf.
 *
 */
#define bcm84756_a0_READ_FCM_RXFRMBUFr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_RXFRMBUFr((c)),&((r)._fcm_rxfrmbuf))

#define bcm84756_a0_WRITE_FCM_RXFRMBUFr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_RXFRMBUFr((c)),&((r)._fcm_rxfrmbuf))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_RXFRMBUFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  FCM_txfrmbuf
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 TX (switch to line) Frame Buffer FIFO Write Pointer load register.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  WRPTR            :
 *     TX Frame Buffer wrptr load register. Frame should be loaded starting at
 *     offset of rdptr. The wrptr register should be loaded with the location
 *     at the end of packet offset + 1. Units are 128-bit quad-words. MSbit
 *     indicates buffer wrap-around.
 *
 *  RDPTR            :
 *     TX Frame Buffer rdptr. Units are 128-bit quad-words. MSbit indicates
 *     buffer wrap-around.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_FCM_TXFRMBUFr(c) \
		(0x13100099 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_FCM_TXFRMBUFr_SIZE 1

/*
 * This structure should be used to declare and program FCM_txfrmbuf.
 *
 */
typedef union bcm84756_a0_FCM_TXFRMBUFr_s {
	buint32_t v[1];
	buint32_t fcm_txfrmbuf[1];
	buint32_t _fcm_txfrmbuf;
} bcm84756_a0_FCM_TXFRMBUFr_t;

#define bcm84756_a0_FCM_TXFRMBUFr_CLR(r)   \
            (r).fcm_txfrmbuf[0] = 0

#define bcm84756_a0_FCM_TXFRMBUFr_SET(r,d) \
            (r).fcm_txfrmbuf[0] = d

#define bcm84756_a0_FCM_TXFRMBUFr_GET(r)   \
            (r).fcm_txfrmbuf[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_FCM_TXFRMBUFr_WRPTRf_GET(c,r)         \
	(((r).fcm_txfrmbuf[0]) & 0xfff)

#define bcm84756_a0_FCM_TXFRMBUFr_WRPTRf_SET(c,r,f)       \
	(r).fcm_txfrmbuf[0]=(((r).fcm_txfrmbuf[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_FCM_TXFRMBUFr_RDPTRf_GET(c,r)         \
	((((r).fcm_txfrmbuf[0]) >> 16) & 0xfff)

#define bcm84756_a0_FCM_TXFRMBUFr_RDPTRf_SET(c,r,f)       \
	(r).fcm_txfrmbuf[0]=(((r).fcm_txfrmbuf[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access FCM_txfrmbuf.
 *
 */
#define bcm84756_a0_READ_FCM_TXFRMBUFr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_FCM_TXFRMBUFr((c)),&((r)._fcm_txfrmbuf))

#define bcm84756_a0_WRITE_FCM_TXFRMBUFr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_FCM_TXFRMBUFr((c)),&((r)._fcm_txfrmbuf))

/*******************************************************************************
 * End of 'bcm84756_a0_FCM_TXFRMBUFr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  RX_BUFFER_CONFIG
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 RX Frame Buffer Configuration. Configures buffer used in FCMAC to Switch
 *	 direction.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  THRESHOLD        :
 *     Measured from SOF of first frame in the queue. Threshold required to
 *     prevent underrun at read port. In units of 128-bit words. Recommended
 *     settings per link rate : 8G = 0x2c 4G = 0x5a 2G = 0x72
 *
 *  HEADROOM         :
 *     Space required for buffer full latency to FC MAC. Typically set to zero
 *     for a BBCredit managed RX. In units of 128-bit words.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_RX_BUFFER_CONFIGr(c) \
		(0x1310005d + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_RX_BUFFER_CONFIGr_SIZE 1

/*
 * This structure should be used to declare and program RX_BUFFER_CONFIG.
 *
 */
typedef union bcm84756_a0_RX_BUFFER_CONFIGr_s {
	buint32_t v[1];
	buint32_t rx_buffer_config[1];
	buint32_t _rx_buffer_config;
} bcm84756_a0_RX_BUFFER_CONFIGr_t;

#define bcm84756_a0_RX_BUFFER_CONFIGr_CLR(r)   \
            (r).rx_buffer_config[0] = 0

#define bcm84756_a0_RX_BUFFER_CONFIGr_SET(r,d) \
            (r).rx_buffer_config[0] = d

#define bcm84756_a0_RX_BUFFER_CONFIGr_GET(r)   \
            (r).rx_buffer_config[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_RX_BUFFER_CONFIGr_THRESHOLDf_GET(c,r)         \
	(((r).rx_buffer_config[0]) & 0x7ff)

#define bcm84756_a0_RX_BUFFER_CONFIGr_THRESHOLDf_SET(c,r,f)       \
	(r).rx_buffer_config[0]=(((r).rx_buffer_config[0] & ~((buint32_t)0x7ff)) | \
		(((buint32_t)f) & 0x7ff))

#define bcm84756_a0_RX_BUFFER_CONFIGr_HEADROOMf_GET(c,r)         \
	((((r).rx_buffer_config[0]) >> 16) & 0x7ff)

#define bcm84756_a0_RX_BUFFER_CONFIGr_HEADROOMf_SET(c,r,f)       \
	(r).rx_buffer_config[0]=(((r).rx_buffer_config[0] & ~((buint32_t)0x7ff << 16)) | \
		((((buint32_t)f) & 0x7ff) << 16))


/*
 * These macros can be used to access RX_BUFFER_CONFIG.
 *
 */
#define bcm84756_a0_READ_RX_BUFFER_CONFIGr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_RX_BUFFER_CONFIGr((c)),&((r)._rx_buffer_config))

#define bcm84756_a0_WRITE_RX_BUFFER_CONFIGr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_RX_BUFFER_CONFIGr((c)),&((r)._rx_buffer_config))

/*******************************************************************************
 * End of 'bcm84756_a0_RX_BUFFER_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  RX_BUFFER_ECCSTS
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Ingress RX Frame Buffer ECC Status.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  ECC_ERR_ADDR     :
 *     ECC error address.
 *
 *  ECC_ERR_1BIT     :
 *     Correctable ECC error status bit.
 *
 *  ECC_ERR_2BIT     :
 *     Uncorrectable ECC error status bit.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_RX_BUFFER_ECCSTSr(c) \
		(0x1310005f + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_RX_BUFFER_ECCSTSr_SIZE 1

/*
 * This structure should be used to declare and program RX_BUFFER_ECCSTS.
 *
 */
typedef union bcm84756_a0_RX_BUFFER_ECCSTSr_s {
	buint32_t v[1];
	buint32_t rx_buffer_eccsts[1];
	buint32_t _rx_buffer_eccsts;
} bcm84756_a0_RX_BUFFER_ECCSTSr_t;

#define bcm84756_a0_RX_BUFFER_ECCSTSr_CLR(r)   \
            (r).rx_buffer_eccsts[0] = 0

#define bcm84756_a0_RX_BUFFER_ECCSTSr_SET(r,d) \
            (r).rx_buffer_eccsts[0] = d

#define bcm84756_a0_RX_BUFFER_ECCSTSr_GET(r)   \
            (r).rx_buffer_eccsts[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_RX_BUFFER_ECCSTSr_ECC_ERR_ADDRf_GET(c,r)         \
	(((r).rx_buffer_eccsts[0]) & 0x7ff)

#define bcm84756_a0_RX_BUFFER_ECCSTSr_ECC_ERR_ADDRf_SET(c,r,f)       \
	(r).rx_buffer_eccsts[0]=(((r).rx_buffer_eccsts[0] & ~((buint32_t)0x7ff)) | \
		(((buint32_t)f) & 0x7ff))

#define bcm84756_a0_RX_BUFFER_ECCSTSr_ECC_ERR_1BITf_GET(c,r)         \
	((((r).rx_buffer_eccsts[0]) >> 16) & 0x1)

#define bcm84756_a0_RX_BUFFER_ECCSTSr_ECC_ERR_1BITf_SET(c,r,f)       \
	(r).rx_buffer_eccsts[0]=(((r).rx_buffer_eccsts[0] & ~((buint32_t)0x1 << 16)) | \
		((((buint32_t)f) & 0x1) << 16))

#define bcm84756_a0_RX_BUFFER_ECCSTSr_ECC_ERR_2BITf_GET(c,r)         \
	((((r).rx_buffer_eccsts[0]) >> 17) & 0x1)

#define bcm84756_a0_RX_BUFFER_ECCSTSr_ECC_ERR_2BITf_SET(c,r,f)       \
	(r).rx_buffer_eccsts[0]=(((r).rx_buffer_eccsts[0] & ~((buint32_t)0x1 << 17)) | \
		((((buint32_t)f) & 0x1) << 17))


/*
 * These macros can be used to access RX_BUFFER_ECCSTS.
 *
 */
#define bcm84756_a0_READ_RX_BUFFER_ECCSTSr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_RX_BUFFER_ECCSTSr((c)),&((r)._rx_buffer_eccsts))

#define bcm84756_a0_WRITE_RX_BUFFER_ECCSTSr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_RX_BUFFER_ECCSTSr((c)),&((r)._rx_buffer_eccsts))

/*******************************************************************************
 * End of 'bcm84756_a0_RX_BUFFER_ECCSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  TX_BUFFER_CONFIG
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 TX Frame Buffer Configuration. Configures buffer used in Switch to FCMAC
 *	 direction..
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  THRESHOLD        :
 *     Transfer threshold required to prevent underrun at read port. In units
 *     of 128-bit words.
 *
 *  HEADROOM         :
 *     Space required for buffer full (Eth PAUSE) latency to switch MAC. In
 *     units of 128-bit words.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_TX_BUFFER_CONFIGr(c) \
		(0x1310005c + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_TX_BUFFER_CONFIGr_SIZE 1

/*
 * This structure should be used to declare and program TX_BUFFER_CONFIG.
 *
 */
typedef union bcm84756_a0_TX_BUFFER_CONFIGr_s {
	buint32_t v[1];
	buint32_t tx_buffer_config[1];
	buint32_t _tx_buffer_config;
} bcm84756_a0_TX_BUFFER_CONFIGr_t;

#define bcm84756_a0_TX_BUFFER_CONFIGr_CLR(r)   \
            (r).tx_buffer_config[0] = 0

#define bcm84756_a0_TX_BUFFER_CONFIGr_SET(r,d) \
            (r).tx_buffer_config[0] = d

#define bcm84756_a0_TX_BUFFER_CONFIGr_GET(r)   \
            (r).tx_buffer_config[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_TX_BUFFER_CONFIGr_THRESHOLDf_GET(c,r)         \
	(((r).tx_buffer_config[0]) & 0x7ff)

#define bcm84756_a0_TX_BUFFER_CONFIGr_THRESHOLDf_SET(c,r,f)       \
	(r).tx_buffer_config[0]=(((r).tx_buffer_config[0] & ~((buint32_t)0x7ff)) | \
		(((buint32_t)f) & 0x7ff))

#define bcm84756_a0_TX_BUFFER_CONFIGr_HEADROOMf_GET(c,r)         \
	((((r).tx_buffer_config[0]) >> 16) & 0x7ff)

#define bcm84756_a0_TX_BUFFER_CONFIGr_HEADROOMf_SET(c,r,f)       \
	(r).tx_buffer_config[0]=(((r).tx_buffer_config[0] & ~((buint32_t)0x7ff << 16)) | \
		((((buint32_t)f) & 0x7ff) << 16))


/*
 * These macros can be used to access TX_BUFFER_CONFIG.
 *
 */
#define bcm84756_a0_READ_TX_BUFFER_CONFIGr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_TX_BUFFER_CONFIGr((c)),&((r)._tx_buffer_config))

#define bcm84756_a0_WRITE_TX_BUFFER_CONFIGr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_TX_BUFFER_CONFIGr((c)),&((r)._tx_buffer_config))

/*******************************************************************************
 * End of 'bcm84756_a0_TX_BUFFER_CONFIGr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  TX_BUFFER_ECCSTS
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress TX Frame Buffer ECC Status.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  ECC_ERR_ADDR     :
 *     ECC error address.
 *
 *  ECC_ERR_1BIT     :
 *     Correctable ECC error status bit.
 *
 *  ECC_ERR_2BIT     :
 *     Uncorrectable ECC error status bit.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_TX_BUFFER_ECCSTSr(c) \
		(0x1310005e + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_TX_BUFFER_ECCSTSr_SIZE 1

/*
 * This structure should be used to declare and program TX_BUFFER_ECCSTS.
 *
 */
typedef union bcm84756_a0_TX_BUFFER_ECCSTSr_s {
	buint32_t v[1];
	buint32_t tx_buffer_eccsts[1];
	buint32_t _tx_buffer_eccsts;
} bcm84756_a0_TX_BUFFER_ECCSTSr_t;

#define bcm84756_a0_TX_BUFFER_ECCSTSr_CLR(r)   \
            (r).tx_buffer_eccsts[0] = 0

#define bcm84756_a0_TX_BUFFER_ECCSTSr_SET(r,d) \
            (r).tx_buffer_eccsts[0] = d

#define bcm84756_a0_TX_BUFFER_ECCSTSr_GET(r)   \
            (r).tx_buffer_eccsts[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_TX_BUFFER_ECCSTSr_ECC_ERR_ADDRf_GET(c,r)         \
	(((r).tx_buffer_eccsts[0]) & 0x7ff)

#define bcm84756_a0_TX_BUFFER_ECCSTSr_ECC_ERR_ADDRf_SET(c,r,f)       \
	(r).tx_buffer_eccsts[0]=(((r).tx_buffer_eccsts[0] & ~((buint32_t)0x7ff)) | \
		(((buint32_t)f) & 0x7ff))

#define bcm84756_a0_TX_BUFFER_ECCSTSr_ECC_ERR_1BITf_GET(c,r)         \
	((((r).tx_buffer_eccsts[0]) >> 16) & 0x1)

#define bcm84756_a0_TX_BUFFER_ECCSTSr_ECC_ERR_1BITf_SET(c,r,f)       \
	(r).tx_buffer_eccsts[0]=(((r).tx_buffer_eccsts[0] & ~((buint32_t)0x1 << 16)) | \
		((((buint32_t)f) & 0x1) << 16))

#define bcm84756_a0_TX_BUFFER_ECCSTSr_ECC_ERR_2BITf_GET(c,r)         \
	((((r).tx_buffer_eccsts[0]) >> 17) & 0x1)

#define bcm84756_a0_TX_BUFFER_ECCSTSr_ECC_ERR_2BITf_SET(c,r,f)       \
	(r).tx_buffer_eccsts[0]=(((r).tx_buffer_eccsts[0] & ~((buint32_t)0x1 << 17)) | \
		((((buint32_t)f) & 0x1) << 17))


/*
 * These macros can be used to access TX_BUFFER_ECCSTS.
 *
 */
#define bcm84756_a0_READ_TX_BUFFER_ECCSTSr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_TX_BUFFER_ECCSTSr((c)),&((r)._tx_buffer_eccsts))

#define bcm84756_a0_WRITE_TX_BUFFER_ECCSTSr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_TX_BUFFER_ECCSTSr((c)),&((r)._tx_buffer_eccsts))

/*******************************************************************************
 * End of 'bcm84756_a0_TX_BUFFER_ECCSTSr'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_0
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 0.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_0r(c) \
		(0x1310001c + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_0r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_0.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_0r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_0[1];
	buint32_t _vlan_maptable_0;
} bcm84756_a0_VLAN_MAPTABLE_0r_t;

#define bcm84756_a0_VLAN_MAPTABLE_0r_CLR(r)   \
            (r).vlan_maptable_0[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_0r_SET(r,d) \
            (r).vlan_maptable_0[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_0r_GET(r)   \
            (r).vlan_maptable_0[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_0r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_0[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_0r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_0[0]=(((r).vlan_maptable_0[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_0r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_0[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_0r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_0[0]=(((r).vlan_maptable_0[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_0.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_0r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_0r((c)),&((r)._vlan_maptable_0))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_0r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_0r((c)),&((r)._vlan_maptable_0))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_0r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_1
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 1.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_1r(c) \
		(0x1310001d + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_1r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_1.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_1r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_1[1];
	buint32_t _vlan_maptable_1;
} bcm84756_a0_VLAN_MAPTABLE_1r_t;

#define bcm84756_a0_VLAN_MAPTABLE_1r_CLR(r)   \
            (r).vlan_maptable_1[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_1r_SET(r,d) \
            (r).vlan_maptable_1[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_1r_GET(r)   \
            (r).vlan_maptable_1[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_1r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_1[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_1r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_1[0]=(((r).vlan_maptable_1[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_1r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_1[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_1r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_1[0]=(((r).vlan_maptable_1[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_1.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_1r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_1r((c)),&((r)._vlan_maptable_1))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_1r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_1r((c)),&((r)._vlan_maptable_1))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_1r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_10
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 10.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_10r(c) \
		(0x13100026 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_10r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_10.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_10r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_10[1];
	buint32_t _vlan_maptable_10;
} bcm84756_a0_VLAN_MAPTABLE_10r_t;

#define bcm84756_a0_VLAN_MAPTABLE_10r_CLR(r)   \
            (r).vlan_maptable_10[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_10r_SET(r,d) \
            (r).vlan_maptable_10[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_10r_GET(r)   \
            (r).vlan_maptable_10[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_10r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_10[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_10r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_10[0]=(((r).vlan_maptable_10[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_10r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_10[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_10r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_10[0]=(((r).vlan_maptable_10[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_10.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_10r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_10r((c)),&((r)._vlan_maptable_10))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_10r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_10r((c)),&((r)._vlan_maptable_10))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_10r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_11
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 11.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_11r(c) \
		(0x13100027 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_11r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_11.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_11r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_11[1];
	buint32_t _vlan_maptable_11;
} bcm84756_a0_VLAN_MAPTABLE_11r_t;

#define bcm84756_a0_VLAN_MAPTABLE_11r_CLR(r)   \
            (r).vlan_maptable_11[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_11r_SET(r,d) \
            (r).vlan_maptable_11[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_11r_GET(r)   \
            (r).vlan_maptable_11[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_11r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_11[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_11r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_11[0]=(((r).vlan_maptable_11[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_11r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_11[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_11r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_11[0]=(((r).vlan_maptable_11[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_11.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_11r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_11r((c)),&((r)._vlan_maptable_11))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_11r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_11r((c)),&((r)._vlan_maptable_11))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_11r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_12
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 12.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_12r(c) \
		(0x13100028 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_12r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_12.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_12r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_12[1];
	buint32_t _vlan_maptable_12;
} bcm84756_a0_VLAN_MAPTABLE_12r_t;

#define bcm84756_a0_VLAN_MAPTABLE_12r_CLR(r)   \
            (r).vlan_maptable_12[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_12r_SET(r,d) \
            (r).vlan_maptable_12[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_12r_GET(r)   \
            (r).vlan_maptable_12[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_12r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_12[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_12r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_12[0]=(((r).vlan_maptable_12[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_12r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_12[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_12r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_12[0]=(((r).vlan_maptable_12[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_12.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_12r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_12r((c)),&((r)._vlan_maptable_12))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_12r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_12r((c)),&((r)._vlan_maptable_12))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_12r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_13
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 13.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_13r(c) \
		(0x13100029 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_13r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_13.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_13r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_13[1];
	buint32_t _vlan_maptable_13;
} bcm84756_a0_VLAN_MAPTABLE_13r_t;

#define bcm84756_a0_VLAN_MAPTABLE_13r_CLR(r)   \
            (r).vlan_maptable_13[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_13r_SET(r,d) \
            (r).vlan_maptable_13[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_13r_GET(r)   \
            (r).vlan_maptable_13[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_13r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_13[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_13r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_13[0]=(((r).vlan_maptable_13[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_13r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_13[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_13r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_13[0]=(((r).vlan_maptable_13[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_13.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_13r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_13r((c)),&((r)._vlan_maptable_13))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_13r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_13r((c)),&((r)._vlan_maptable_13))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_13r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_14
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 14.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_14r(c) \
		(0x1310002a + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_14r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_14.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_14r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_14[1];
	buint32_t _vlan_maptable_14;
} bcm84756_a0_VLAN_MAPTABLE_14r_t;

#define bcm84756_a0_VLAN_MAPTABLE_14r_CLR(r)   \
            (r).vlan_maptable_14[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_14r_SET(r,d) \
            (r).vlan_maptable_14[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_14r_GET(r)   \
            (r).vlan_maptable_14[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_14r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_14[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_14r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_14[0]=(((r).vlan_maptable_14[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_14r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_14[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_14r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_14[0]=(((r).vlan_maptable_14[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_14.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_14r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_14r((c)),&((r)._vlan_maptable_14))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_14r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_14r((c)),&((r)._vlan_maptable_14))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_14r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_15
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 15.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_15r(c) \
		(0x1310002b + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_15r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_15.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_15r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_15[1];
	buint32_t _vlan_maptable_15;
} bcm84756_a0_VLAN_MAPTABLE_15r_t;

#define bcm84756_a0_VLAN_MAPTABLE_15r_CLR(r)   \
            (r).vlan_maptable_15[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_15r_SET(r,d) \
            (r).vlan_maptable_15[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_15r_GET(r)   \
            (r).vlan_maptable_15[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_15r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_15[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_15r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_15[0]=(((r).vlan_maptable_15[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_15r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_15[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_15r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_15[0]=(((r).vlan_maptable_15[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_15.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_15r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_15r((c)),&((r)._vlan_maptable_15))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_15r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_15r((c)),&((r)._vlan_maptable_15))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_15r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_16
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 16.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_16r(c) \
		(0x1310002c + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_16r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_16.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_16r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_16[1];
	buint32_t _vlan_maptable_16;
} bcm84756_a0_VLAN_MAPTABLE_16r_t;

#define bcm84756_a0_VLAN_MAPTABLE_16r_CLR(r)   \
            (r).vlan_maptable_16[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_16r_SET(r,d) \
            (r).vlan_maptable_16[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_16r_GET(r)   \
            (r).vlan_maptable_16[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_16r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_16[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_16r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_16[0]=(((r).vlan_maptable_16[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_16r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_16[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_16r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_16[0]=(((r).vlan_maptable_16[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_16.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_16r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_16r((c)),&((r)._vlan_maptable_16))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_16r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_16r((c)),&((r)._vlan_maptable_16))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_16r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_17
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 17.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_17r(c) \
		(0x1310002d + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_17r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_17.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_17r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_17[1];
	buint32_t _vlan_maptable_17;
} bcm84756_a0_VLAN_MAPTABLE_17r_t;

#define bcm84756_a0_VLAN_MAPTABLE_17r_CLR(r)   \
            (r).vlan_maptable_17[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_17r_SET(r,d) \
            (r).vlan_maptable_17[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_17r_GET(r)   \
            (r).vlan_maptable_17[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_17r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_17[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_17r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_17[0]=(((r).vlan_maptable_17[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_17r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_17[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_17r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_17[0]=(((r).vlan_maptable_17[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_17.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_17r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_17r((c)),&((r)._vlan_maptable_17))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_17r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_17r((c)),&((r)._vlan_maptable_17))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_17r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_18
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 18.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_18r(c) \
		(0x1310002e + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_18r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_18.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_18r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_18[1];
	buint32_t _vlan_maptable_18;
} bcm84756_a0_VLAN_MAPTABLE_18r_t;

#define bcm84756_a0_VLAN_MAPTABLE_18r_CLR(r)   \
            (r).vlan_maptable_18[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_18r_SET(r,d) \
            (r).vlan_maptable_18[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_18r_GET(r)   \
            (r).vlan_maptable_18[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_18r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_18[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_18r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_18[0]=(((r).vlan_maptable_18[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_18r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_18[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_18r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_18[0]=(((r).vlan_maptable_18[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_18.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_18r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_18r((c)),&((r)._vlan_maptable_18))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_18r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_18r((c)),&((r)._vlan_maptable_18))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_18r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_19
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 19.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_19r(c) \
		(0x1310002f + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_19r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_19.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_19r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_19[1];
	buint32_t _vlan_maptable_19;
} bcm84756_a0_VLAN_MAPTABLE_19r_t;

#define bcm84756_a0_VLAN_MAPTABLE_19r_CLR(r)   \
            (r).vlan_maptable_19[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_19r_SET(r,d) \
            (r).vlan_maptable_19[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_19r_GET(r)   \
            (r).vlan_maptable_19[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_19r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_19[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_19r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_19[0]=(((r).vlan_maptable_19[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_19r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_19[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_19r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_19[0]=(((r).vlan_maptable_19[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_19.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_19r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_19r((c)),&((r)._vlan_maptable_19))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_19r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_19r((c)),&((r)._vlan_maptable_19))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_19r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_2
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 2.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_2r(c) \
		(0x1310001e + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_2r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_2.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_2r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_2[1];
	buint32_t _vlan_maptable_2;
} bcm84756_a0_VLAN_MAPTABLE_2r_t;

#define bcm84756_a0_VLAN_MAPTABLE_2r_CLR(r)   \
            (r).vlan_maptable_2[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_2r_SET(r,d) \
            (r).vlan_maptable_2[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_2r_GET(r)   \
            (r).vlan_maptable_2[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_2r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_2[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_2r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_2[0]=(((r).vlan_maptable_2[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_2r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_2[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_2r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_2[0]=(((r).vlan_maptable_2[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_2.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_2r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_2r((c)),&((r)._vlan_maptable_2))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_2r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_2r((c)),&((r)._vlan_maptable_2))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_2r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_20
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 20.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_20r(c) \
		(0x13100030 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_20r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_20.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_20r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_20[1];
	buint32_t _vlan_maptable_20;
} bcm84756_a0_VLAN_MAPTABLE_20r_t;

#define bcm84756_a0_VLAN_MAPTABLE_20r_CLR(r)   \
            (r).vlan_maptable_20[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_20r_SET(r,d) \
            (r).vlan_maptable_20[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_20r_GET(r)   \
            (r).vlan_maptable_20[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_20r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_20[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_20r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_20[0]=(((r).vlan_maptable_20[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_20r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_20[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_20r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_20[0]=(((r).vlan_maptable_20[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_20.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_20r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_20r((c)),&((r)._vlan_maptable_20))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_20r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_20r((c)),&((r)._vlan_maptable_20))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_20r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_21
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 21.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_21r(c) \
		(0x13100031 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_21r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_21.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_21r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_21[1];
	buint32_t _vlan_maptable_21;
} bcm84756_a0_VLAN_MAPTABLE_21r_t;

#define bcm84756_a0_VLAN_MAPTABLE_21r_CLR(r)   \
            (r).vlan_maptable_21[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_21r_SET(r,d) \
            (r).vlan_maptable_21[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_21r_GET(r)   \
            (r).vlan_maptable_21[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_21r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_21[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_21r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_21[0]=(((r).vlan_maptable_21[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_21r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_21[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_21r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_21[0]=(((r).vlan_maptable_21[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_21.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_21r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_21r((c)),&((r)._vlan_maptable_21))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_21r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_21r((c)),&((r)._vlan_maptable_21))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_21r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_22
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 22.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_22r(c) \
		(0x13100032 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_22r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_22.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_22r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_22[1];
	buint32_t _vlan_maptable_22;
} bcm84756_a0_VLAN_MAPTABLE_22r_t;

#define bcm84756_a0_VLAN_MAPTABLE_22r_CLR(r)   \
            (r).vlan_maptable_22[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_22r_SET(r,d) \
            (r).vlan_maptable_22[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_22r_GET(r)   \
            (r).vlan_maptable_22[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_22r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_22[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_22r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_22[0]=(((r).vlan_maptable_22[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_22r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_22[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_22r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_22[0]=(((r).vlan_maptable_22[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_22.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_22r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_22r((c)),&((r)._vlan_maptable_22))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_22r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_22r((c)),&((r)._vlan_maptable_22))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_22r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_23
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 23.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_23r(c) \
		(0x13100033 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_23r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_23.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_23r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_23[1];
	buint32_t _vlan_maptable_23;
} bcm84756_a0_VLAN_MAPTABLE_23r_t;

#define bcm84756_a0_VLAN_MAPTABLE_23r_CLR(r)   \
            (r).vlan_maptable_23[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_23r_SET(r,d) \
            (r).vlan_maptable_23[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_23r_GET(r)   \
            (r).vlan_maptable_23[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_23r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_23[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_23r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_23[0]=(((r).vlan_maptable_23[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_23r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_23[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_23r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_23[0]=(((r).vlan_maptable_23[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_23.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_23r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_23r((c)),&((r)._vlan_maptable_23))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_23r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_23r((c)),&((r)._vlan_maptable_23))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_23r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_24
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 24.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_24r(c) \
		(0x13100034 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_24r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_24.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_24r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_24[1];
	buint32_t _vlan_maptable_24;
} bcm84756_a0_VLAN_MAPTABLE_24r_t;

#define bcm84756_a0_VLAN_MAPTABLE_24r_CLR(r)   \
            (r).vlan_maptable_24[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_24r_SET(r,d) \
            (r).vlan_maptable_24[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_24r_GET(r)   \
            (r).vlan_maptable_24[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_24r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_24[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_24r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_24[0]=(((r).vlan_maptable_24[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_24r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_24[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_24r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_24[0]=(((r).vlan_maptable_24[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_24.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_24r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_24r((c)),&((r)._vlan_maptable_24))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_24r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_24r((c)),&((r)._vlan_maptable_24))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_24r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_25
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 25.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_25r(c) \
		(0x13100035 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_25r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_25.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_25r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_25[1];
	buint32_t _vlan_maptable_25;
} bcm84756_a0_VLAN_MAPTABLE_25r_t;

#define bcm84756_a0_VLAN_MAPTABLE_25r_CLR(r)   \
            (r).vlan_maptable_25[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_25r_SET(r,d) \
            (r).vlan_maptable_25[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_25r_GET(r)   \
            (r).vlan_maptable_25[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_25r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_25[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_25r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_25[0]=(((r).vlan_maptable_25[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_25r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_25[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_25r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_25[0]=(((r).vlan_maptable_25[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_25.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_25r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_25r((c)),&((r)._vlan_maptable_25))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_25r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_25r((c)),&((r)._vlan_maptable_25))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_25r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_26
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 26.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_26r(c) \
		(0x13100036 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_26r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_26.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_26r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_26[1];
	buint32_t _vlan_maptable_26;
} bcm84756_a0_VLAN_MAPTABLE_26r_t;

#define bcm84756_a0_VLAN_MAPTABLE_26r_CLR(r)   \
            (r).vlan_maptable_26[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_26r_SET(r,d) \
            (r).vlan_maptable_26[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_26r_GET(r)   \
            (r).vlan_maptable_26[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_26r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_26[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_26r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_26[0]=(((r).vlan_maptable_26[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_26r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_26[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_26r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_26[0]=(((r).vlan_maptable_26[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_26.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_26r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_26r((c)),&((r)._vlan_maptable_26))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_26r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_26r((c)),&((r)._vlan_maptable_26))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_26r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_27
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 27.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_27r(c) \
		(0x13100037 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_27r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_27.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_27r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_27[1];
	buint32_t _vlan_maptable_27;
} bcm84756_a0_VLAN_MAPTABLE_27r_t;

#define bcm84756_a0_VLAN_MAPTABLE_27r_CLR(r)   \
            (r).vlan_maptable_27[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_27r_SET(r,d) \
            (r).vlan_maptable_27[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_27r_GET(r)   \
            (r).vlan_maptable_27[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_27r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_27[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_27r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_27[0]=(((r).vlan_maptable_27[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_27r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_27[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_27r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_27[0]=(((r).vlan_maptable_27[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_27.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_27r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_27r((c)),&((r)._vlan_maptable_27))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_27r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_27r((c)),&((r)._vlan_maptable_27))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_27r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_28
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 28.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_28r(c) \
		(0x13100038 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_28r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_28.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_28r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_28[1];
	buint32_t _vlan_maptable_28;
} bcm84756_a0_VLAN_MAPTABLE_28r_t;

#define bcm84756_a0_VLAN_MAPTABLE_28r_CLR(r)   \
            (r).vlan_maptable_28[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_28r_SET(r,d) \
            (r).vlan_maptable_28[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_28r_GET(r)   \
            (r).vlan_maptable_28[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_28r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_28[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_28r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_28[0]=(((r).vlan_maptable_28[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_28r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_28[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_28r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_28[0]=(((r).vlan_maptable_28[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_28.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_28r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_28r((c)),&((r)._vlan_maptable_28))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_28r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_28r((c)),&((r)._vlan_maptable_28))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_28r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_29
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 29.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_29r(c) \
		(0x13100039 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_29r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_29.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_29r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_29[1];
	buint32_t _vlan_maptable_29;
} bcm84756_a0_VLAN_MAPTABLE_29r_t;

#define bcm84756_a0_VLAN_MAPTABLE_29r_CLR(r)   \
            (r).vlan_maptable_29[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_29r_SET(r,d) \
            (r).vlan_maptable_29[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_29r_GET(r)   \
            (r).vlan_maptable_29[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_29r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_29[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_29r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_29[0]=(((r).vlan_maptable_29[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_29r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_29[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_29r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_29[0]=(((r).vlan_maptable_29[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_29.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_29r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_29r((c)),&((r)._vlan_maptable_29))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_29r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_29r((c)),&((r)._vlan_maptable_29))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_29r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_3
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 3.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_3r(c) \
		(0x1310001f + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_3r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_3.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_3r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_3[1];
	buint32_t _vlan_maptable_3;
} bcm84756_a0_VLAN_MAPTABLE_3r_t;

#define bcm84756_a0_VLAN_MAPTABLE_3r_CLR(r)   \
            (r).vlan_maptable_3[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_3r_SET(r,d) \
            (r).vlan_maptable_3[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_3r_GET(r)   \
            (r).vlan_maptable_3[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_3r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_3[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_3r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_3[0]=(((r).vlan_maptable_3[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_3r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_3[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_3r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_3[0]=(((r).vlan_maptable_3[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_3.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_3r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_3r((c)),&((r)._vlan_maptable_3))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_3r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_3r((c)),&((r)._vlan_maptable_3))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_3r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_30
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 30.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_30r(c) \
		(0x1310003a + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_30r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_30.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_30r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_30[1];
	buint32_t _vlan_maptable_30;
} bcm84756_a0_VLAN_MAPTABLE_30r_t;

#define bcm84756_a0_VLAN_MAPTABLE_30r_CLR(r)   \
            (r).vlan_maptable_30[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_30r_SET(r,d) \
            (r).vlan_maptable_30[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_30r_GET(r)   \
            (r).vlan_maptable_30[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_30r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_30[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_30r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_30[0]=(((r).vlan_maptable_30[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_30r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_30[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_30r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_30[0]=(((r).vlan_maptable_30[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_30.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_30r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_30r((c)),&((r)._vlan_maptable_30))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_30r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_30r((c)),&((r)._vlan_maptable_30))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_30r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_31
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 31.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_31r(c) \
		(0x1310003b + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_31r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_31.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_31r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_31[1];
	buint32_t _vlan_maptable_31;
} bcm84756_a0_VLAN_MAPTABLE_31r_t;

#define bcm84756_a0_VLAN_MAPTABLE_31r_CLR(r)   \
            (r).vlan_maptable_31[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_31r_SET(r,d) \
            (r).vlan_maptable_31[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_31r_GET(r)   \
            (r).vlan_maptable_31[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_31r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_31[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_31r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_31[0]=(((r).vlan_maptable_31[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_31r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_31[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_31r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_31[0]=(((r).vlan_maptable_31[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_31.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_31r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_31r((c)),&((r)._vlan_maptable_31))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_31r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_31r((c)),&((r)._vlan_maptable_31))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_31r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_32
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 32.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_32r(c) \
		(0x1310003c + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_32r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_32.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_32r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_32[1];
	buint32_t _vlan_maptable_32;
} bcm84756_a0_VLAN_MAPTABLE_32r_t;

#define bcm84756_a0_VLAN_MAPTABLE_32r_CLR(r)   \
            (r).vlan_maptable_32[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_32r_SET(r,d) \
            (r).vlan_maptable_32[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_32r_GET(r)   \
            (r).vlan_maptable_32[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_32r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_32[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_32r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_32[0]=(((r).vlan_maptable_32[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_32r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_32[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_32r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_32[0]=(((r).vlan_maptable_32[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_32.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_32r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_32r((c)),&((r)._vlan_maptable_32))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_32r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_32r((c)),&((r)._vlan_maptable_32))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_32r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_33
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 33.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_33r(c) \
		(0x1310003d + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_33r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_33.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_33r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_33[1];
	buint32_t _vlan_maptable_33;
} bcm84756_a0_VLAN_MAPTABLE_33r_t;

#define bcm84756_a0_VLAN_MAPTABLE_33r_CLR(r)   \
            (r).vlan_maptable_33[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_33r_SET(r,d) \
            (r).vlan_maptable_33[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_33r_GET(r)   \
            (r).vlan_maptable_33[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_33r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_33[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_33r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_33[0]=(((r).vlan_maptable_33[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_33r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_33[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_33r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_33[0]=(((r).vlan_maptable_33[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_33.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_33r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_33r((c)),&((r)._vlan_maptable_33))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_33r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_33r((c)),&((r)._vlan_maptable_33))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_33r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_34
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 34.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_34r(c) \
		(0x1310003e + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_34r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_34.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_34r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_34[1];
	buint32_t _vlan_maptable_34;
} bcm84756_a0_VLAN_MAPTABLE_34r_t;

#define bcm84756_a0_VLAN_MAPTABLE_34r_CLR(r)   \
            (r).vlan_maptable_34[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_34r_SET(r,d) \
            (r).vlan_maptable_34[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_34r_GET(r)   \
            (r).vlan_maptable_34[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_34r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_34[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_34r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_34[0]=(((r).vlan_maptable_34[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_34r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_34[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_34r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_34[0]=(((r).vlan_maptable_34[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_34.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_34r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_34r((c)),&((r)._vlan_maptable_34))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_34r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_34r((c)),&((r)._vlan_maptable_34))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_34r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_35
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 35.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_35r(c) \
		(0x1310003f + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_35r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_35.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_35r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_35[1];
	buint32_t _vlan_maptable_35;
} bcm84756_a0_VLAN_MAPTABLE_35r_t;

#define bcm84756_a0_VLAN_MAPTABLE_35r_CLR(r)   \
            (r).vlan_maptable_35[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_35r_SET(r,d) \
            (r).vlan_maptable_35[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_35r_GET(r)   \
            (r).vlan_maptable_35[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_35r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_35[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_35r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_35[0]=(((r).vlan_maptable_35[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_35r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_35[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_35r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_35[0]=(((r).vlan_maptable_35[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_35.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_35r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_35r((c)),&((r)._vlan_maptable_35))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_35r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_35r((c)),&((r)._vlan_maptable_35))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_35r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_36
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 36.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_36r(c) \
		(0x13100040 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_36r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_36.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_36r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_36[1];
	buint32_t _vlan_maptable_36;
} bcm84756_a0_VLAN_MAPTABLE_36r_t;

#define bcm84756_a0_VLAN_MAPTABLE_36r_CLR(r)   \
            (r).vlan_maptable_36[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_36r_SET(r,d) \
            (r).vlan_maptable_36[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_36r_GET(r)   \
            (r).vlan_maptable_36[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_36r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_36[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_36r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_36[0]=(((r).vlan_maptable_36[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_36r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_36[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_36r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_36[0]=(((r).vlan_maptable_36[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_36.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_36r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_36r((c)),&((r)._vlan_maptable_36))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_36r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_36r((c)),&((r)._vlan_maptable_36))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_36r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_37
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 37.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_37r(c) \
		(0x13100041 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_37r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_37.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_37r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_37[1];
	buint32_t _vlan_maptable_37;
} bcm84756_a0_VLAN_MAPTABLE_37r_t;

#define bcm84756_a0_VLAN_MAPTABLE_37r_CLR(r)   \
            (r).vlan_maptable_37[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_37r_SET(r,d) \
            (r).vlan_maptable_37[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_37r_GET(r)   \
            (r).vlan_maptable_37[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_37r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_37[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_37r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_37[0]=(((r).vlan_maptable_37[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_37r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_37[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_37r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_37[0]=(((r).vlan_maptable_37[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_37.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_37r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_37r((c)),&((r)._vlan_maptable_37))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_37r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_37r((c)),&((r)._vlan_maptable_37))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_37r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_38
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 38.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_38r(c) \
		(0x13100042 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_38r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_38.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_38r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_38[1];
	buint32_t _vlan_maptable_38;
} bcm84756_a0_VLAN_MAPTABLE_38r_t;

#define bcm84756_a0_VLAN_MAPTABLE_38r_CLR(r)   \
            (r).vlan_maptable_38[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_38r_SET(r,d) \
            (r).vlan_maptable_38[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_38r_GET(r)   \
            (r).vlan_maptable_38[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_38r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_38[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_38r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_38[0]=(((r).vlan_maptable_38[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_38r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_38[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_38r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_38[0]=(((r).vlan_maptable_38[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_38.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_38r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_38r((c)),&((r)._vlan_maptable_38))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_38r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_38r((c)),&((r)._vlan_maptable_38))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_38r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_39
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 39.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_39r(c) \
		(0x13100043 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_39r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_39.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_39r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_39[1];
	buint32_t _vlan_maptable_39;
} bcm84756_a0_VLAN_MAPTABLE_39r_t;

#define bcm84756_a0_VLAN_MAPTABLE_39r_CLR(r)   \
            (r).vlan_maptable_39[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_39r_SET(r,d) \
            (r).vlan_maptable_39[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_39r_GET(r)   \
            (r).vlan_maptable_39[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_39r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_39[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_39r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_39[0]=(((r).vlan_maptable_39[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_39r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_39[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_39r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_39[0]=(((r).vlan_maptable_39[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_39.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_39r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_39r((c)),&((r)._vlan_maptable_39))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_39r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_39r((c)),&((r)._vlan_maptable_39))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_39r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_4
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 4.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_4r(c) \
		(0x13100020 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_4r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_4.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_4r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_4[1];
	buint32_t _vlan_maptable_4;
} bcm84756_a0_VLAN_MAPTABLE_4r_t;

#define bcm84756_a0_VLAN_MAPTABLE_4r_CLR(r)   \
            (r).vlan_maptable_4[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_4r_SET(r,d) \
            (r).vlan_maptable_4[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_4r_GET(r)   \
            (r).vlan_maptable_4[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_4r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_4[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_4r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_4[0]=(((r).vlan_maptable_4[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_4r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_4[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_4r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_4[0]=(((r).vlan_maptable_4[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_4.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_4r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_4r((c)),&((r)._vlan_maptable_4))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_4r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_4r((c)),&((r)._vlan_maptable_4))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_4r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_40
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 40.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_40r(c) \
		(0x13100044 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_40r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_40.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_40r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_40[1];
	buint32_t _vlan_maptable_40;
} bcm84756_a0_VLAN_MAPTABLE_40r_t;

#define bcm84756_a0_VLAN_MAPTABLE_40r_CLR(r)   \
            (r).vlan_maptable_40[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_40r_SET(r,d) \
            (r).vlan_maptable_40[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_40r_GET(r)   \
            (r).vlan_maptable_40[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_40r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_40[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_40r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_40[0]=(((r).vlan_maptable_40[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_40r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_40[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_40r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_40[0]=(((r).vlan_maptable_40[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_40.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_40r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_40r((c)),&((r)._vlan_maptable_40))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_40r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_40r((c)),&((r)._vlan_maptable_40))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_40r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_41
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 41.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_41r(c) \
		(0x13100045 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_41r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_41.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_41r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_41[1];
	buint32_t _vlan_maptable_41;
} bcm84756_a0_VLAN_MAPTABLE_41r_t;

#define bcm84756_a0_VLAN_MAPTABLE_41r_CLR(r)   \
            (r).vlan_maptable_41[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_41r_SET(r,d) \
            (r).vlan_maptable_41[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_41r_GET(r)   \
            (r).vlan_maptable_41[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_41r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_41[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_41r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_41[0]=(((r).vlan_maptable_41[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_41r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_41[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_41r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_41[0]=(((r).vlan_maptable_41[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_41.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_41r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_41r((c)),&((r)._vlan_maptable_41))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_41r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_41r((c)),&((r)._vlan_maptable_41))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_41r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_42
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 42.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_42r(c) \
		(0x13100046 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_42r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_42.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_42r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_42[1];
	buint32_t _vlan_maptable_42;
} bcm84756_a0_VLAN_MAPTABLE_42r_t;

#define bcm84756_a0_VLAN_MAPTABLE_42r_CLR(r)   \
            (r).vlan_maptable_42[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_42r_SET(r,d) \
            (r).vlan_maptable_42[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_42r_GET(r)   \
            (r).vlan_maptable_42[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_42r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_42[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_42r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_42[0]=(((r).vlan_maptable_42[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_42r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_42[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_42r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_42[0]=(((r).vlan_maptable_42[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_42.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_42r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_42r((c)),&((r)._vlan_maptable_42))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_42r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_42r((c)),&((r)._vlan_maptable_42))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_42r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_43
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 43.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_43r(c) \
		(0x13100047 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_43r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_43.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_43r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_43[1];
	buint32_t _vlan_maptable_43;
} bcm84756_a0_VLAN_MAPTABLE_43r_t;

#define bcm84756_a0_VLAN_MAPTABLE_43r_CLR(r)   \
            (r).vlan_maptable_43[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_43r_SET(r,d) \
            (r).vlan_maptable_43[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_43r_GET(r)   \
            (r).vlan_maptable_43[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_43r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_43[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_43r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_43[0]=(((r).vlan_maptable_43[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_43r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_43[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_43r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_43[0]=(((r).vlan_maptable_43[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_43.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_43r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_43r((c)),&((r)._vlan_maptable_43))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_43r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_43r((c)),&((r)._vlan_maptable_43))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_43r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_44
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 44.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_44r(c) \
		(0x13100048 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_44r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_44.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_44r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_44[1];
	buint32_t _vlan_maptable_44;
} bcm84756_a0_VLAN_MAPTABLE_44r_t;

#define bcm84756_a0_VLAN_MAPTABLE_44r_CLR(r)   \
            (r).vlan_maptable_44[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_44r_SET(r,d) \
            (r).vlan_maptable_44[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_44r_GET(r)   \
            (r).vlan_maptable_44[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_44r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_44[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_44r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_44[0]=(((r).vlan_maptable_44[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_44r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_44[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_44r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_44[0]=(((r).vlan_maptable_44[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_44.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_44r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_44r((c)),&((r)._vlan_maptable_44))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_44r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_44r((c)),&((r)._vlan_maptable_44))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_44r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_45
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 45.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_45r(c) \
		(0x13100049 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_45r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_45.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_45r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_45[1];
	buint32_t _vlan_maptable_45;
} bcm84756_a0_VLAN_MAPTABLE_45r_t;

#define bcm84756_a0_VLAN_MAPTABLE_45r_CLR(r)   \
            (r).vlan_maptable_45[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_45r_SET(r,d) \
            (r).vlan_maptable_45[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_45r_GET(r)   \
            (r).vlan_maptable_45[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_45r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_45[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_45r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_45[0]=(((r).vlan_maptable_45[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_45r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_45[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_45r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_45[0]=(((r).vlan_maptable_45[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_45.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_45r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_45r((c)),&((r)._vlan_maptable_45))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_45r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_45r((c)),&((r)._vlan_maptable_45))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_45r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_46
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 46.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_46r(c) \
		(0x1310004a + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_46r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_46.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_46r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_46[1];
	buint32_t _vlan_maptable_46;
} bcm84756_a0_VLAN_MAPTABLE_46r_t;

#define bcm84756_a0_VLAN_MAPTABLE_46r_CLR(r)   \
            (r).vlan_maptable_46[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_46r_SET(r,d) \
            (r).vlan_maptable_46[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_46r_GET(r)   \
            (r).vlan_maptable_46[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_46r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_46[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_46r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_46[0]=(((r).vlan_maptable_46[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_46r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_46[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_46r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_46[0]=(((r).vlan_maptable_46[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_46.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_46r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_46r((c)),&((r)._vlan_maptable_46))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_46r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_46r((c)),&((r)._vlan_maptable_46))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_46r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_47
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 47.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_47r(c) \
		(0x1310004b + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_47r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_47.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_47r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_47[1];
	buint32_t _vlan_maptable_47;
} bcm84756_a0_VLAN_MAPTABLE_47r_t;

#define bcm84756_a0_VLAN_MAPTABLE_47r_CLR(r)   \
            (r).vlan_maptable_47[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_47r_SET(r,d) \
            (r).vlan_maptable_47[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_47r_GET(r)   \
            (r).vlan_maptable_47[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_47r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_47[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_47r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_47[0]=(((r).vlan_maptable_47[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_47r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_47[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_47r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_47[0]=(((r).vlan_maptable_47[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_47.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_47r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_47r((c)),&((r)._vlan_maptable_47))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_47r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_47r((c)),&((r)._vlan_maptable_47))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_47r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_48
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 48.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_48r(c) \
		(0x1310004c + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_48r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_48.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_48r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_48[1];
	buint32_t _vlan_maptable_48;
} bcm84756_a0_VLAN_MAPTABLE_48r_t;

#define bcm84756_a0_VLAN_MAPTABLE_48r_CLR(r)   \
            (r).vlan_maptable_48[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_48r_SET(r,d) \
            (r).vlan_maptable_48[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_48r_GET(r)   \
            (r).vlan_maptable_48[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_48r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_48[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_48r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_48[0]=(((r).vlan_maptable_48[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_48r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_48[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_48r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_48[0]=(((r).vlan_maptable_48[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_48.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_48r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_48r((c)),&((r)._vlan_maptable_48))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_48r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_48r((c)),&((r)._vlan_maptable_48))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_48r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_49
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 49.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_49r(c) \
		(0x1310004d + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_49r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_49.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_49r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_49[1];
	buint32_t _vlan_maptable_49;
} bcm84756_a0_VLAN_MAPTABLE_49r_t;

#define bcm84756_a0_VLAN_MAPTABLE_49r_CLR(r)   \
            (r).vlan_maptable_49[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_49r_SET(r,d) \
            (r).vlan_maptable_49[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_49r_GET(r)   \
            (r).vlan_maptable_49[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_49r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_49[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_49r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_49[0]=(((r).vlan_maptable_49[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_49r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_49[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_49r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_49[0]=(((r).vlan_maptable_49[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_49.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_49r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_49r((c)),&((r)._vlan_maptable_49))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_49r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_49r((c)),&((r)._vlan_maptable_49))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_49r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_5
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 5.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_5r(c) \
		(0x13100021 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_5r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_5.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_5r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_5[1];
	buint32_t _vlan_maptable_5;
} bcm84756_a0_VLAN_MAPTABLE_5r_t;

#define bcm84756_a0_VLAN_MAPTABLE_5r_CLR(r)   \
            (r).vlan_maptable_5[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_5r_SET(r,d) \
            (r).vlan_maptable_5[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_5r_GET(r)   \
            (r).vlan_maptable_5[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_5r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_5[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_5r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_5[0]=(((r).vlan_maptable_5[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_5r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_5[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_5r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_5[0]=(((r).vlan_maptable_5[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_5.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_5r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_5r((c)),&((r)._vlan_maptable_5))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_5r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_5r((c)),&((r)._vlan_maptable_5))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_5r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_50
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 50.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_50r(c) \
		(0x1310004e + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_50r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_50.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_50r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_50[1];
	buint32_t _vlan_maptable_50;
} bcm84756_a0_VLAN_MAPTABLE_50r_t;

#define bcm84756_a0_VLAN_MAPTABLE_50r_CLR(r)   \
            (r).vlan_maptable_50[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_50r_SET(r,d) \
            (r).vlan_maptable_50[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_50r_GET(r)   \
            (r).vlan_maptable_50[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_50r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_50[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_50r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_50[0]=(((r).vlan_maptable_50[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_50r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_50[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_50r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_50[0]=(((r).vlan_maptable_50[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_50.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_50r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_50r((c)),&((r)._vlan_maptable_50))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_50r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_50r((c)),&((r)._vlan_maptable_50))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_50r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_51
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 51.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_51r(c) \
		(0x1310004f + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_51r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_51.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_51r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_51[1];
	buint32_t _vlan_maptable_51;
} bcm84756_a0_VLAN_MAPTABLE_51r_t;

#define bcm84756_a0_VLAN_MAPTABLE_51r_CLR(r)   \
            (r).vlan_maptable_51[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_51r_SET(r,d) \
            (r).vlan_maptable_51[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_51r_GET(r)   \
            (r).vlan_maptable_51[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_51r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_51[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_51r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_51[0]=(((r).vlan_maptable_51[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_51r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_51[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_51r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_51[0]=(((r).vlan_maptable_51[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_51.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_51r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_51r((c)),&((r)._vlan_maptable_51))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_51r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_51r((c)),&((r)._vlan_maptable_51))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_51r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_52
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 52.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_52r(c) \
		(0x13100050 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_52r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_52.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_52r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_52[1];
	buint32_t _vlan_maptable_52;
} bcm84756_a0_VLAN_MAPTABLE_52r_t;

#define bcm84756_a0_VLAN_MAPTABLE_52r_CLR(r)   \
            (r).vlan_maptable_52[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_52r_SET(r,d) \
            (r).vlan_maptable_52[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_52r_GET(r)   \
            (r).vlan_maptable_52[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_52r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_52[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_52r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_52[0]=(((r).vlan_maptable_52[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_52r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_52[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_52r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_52[0]=(((r).vlan_maptable_52[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_52.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_52r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_52r((c)),&((r)._vlan_maptable_52))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_52r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_52r((c)),&((r)._vlan_maptable_52))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_52r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_53
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 53.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_53r(c) \
		(0x13100051 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_53r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_53.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_53r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_53[1];
	buint32_t _vlan_maptable_53;
} bcm84756_a0_VLAN_MAPTABLE_53r_t;

#define bcm84756_a0_VLAN_MAPTABLE_53r_CLR(r)   \
            (r).vlan_maptable_53[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_53r_SET(r,d) \
            (r).vlan_maptable_53[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_53r_GET(r)   \
            (r).vlan_maptable_53[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_53r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_53[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_53r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_53[0]=(((r).vlan_maptable_53[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_53r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_53[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_53r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_53[0]=(((r).vlan_maptable_53[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_53.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_53r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_53r((c)),&((r)._vlan_maptable_53))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_53r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_53r((c)),&((r)._vlan_maptable_53))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_53r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_54
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 54.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_54r(c) \
		(0x13100052 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_54r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_54.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_54r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_54[1];
	buint32_t _vlan_maptable_54;
} bcm84756_a0_VLAN_MAPTABLE_54r_t;

#define bcm84756_a0_VLAN_MAPTABLE_54r_CLR(r)   \
            (r).vlan_maptable_54[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_54r_SET(r,d) \
            (r).vlan_maptable_54[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_54r_GET(r)   \
            (r).vlan_maptable_54[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_54r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_54[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_54r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_54[0]=(((r).vlan_maptable_54[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_54r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_54[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_54r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_54[0]=(((r).vlan_maptable_54[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_54.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_54r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_54r((c)),&((r)._vlan_maptable_54))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_54r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_54r((c)),&((r)._vlan_maptable_54))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_54r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_55
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 55.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_55r(c) \
		(0x13100053 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_55r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_55.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_55r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_55[1];
	buint32_t _vlan_maptable_55;
} bcm84756_a0_VLAN_MAPTABLE_55r_t;

#define bcm84756_a0_VLAN_MAPTABLE_55r_CLR(r)   \
            (r).vlan_maptable_55[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_55r_SET(r,d) \
            (r).vlan_maptable_55[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_55r_GET(r)   \
            (r).vlan_maptable_55[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_55r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_55[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_55r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_55[0]=(((r).vlan_maptable_55[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_55r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_55[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_55r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_55[0]=(((r).vlan_maptable_55[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_55.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_55r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_55r((c)),&((r)._vlan_maptable_55))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_55r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_55r((c)),&((r)._vlan_maptable_55))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_55r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_56
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 56.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_56r(c) \
		(0x13100054 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_56r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_56.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_56r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_56[1];
	buint32_t _vlan_maptable_56;
} bcm84756_a0_VLAN_MAPTABLE_56r_t;

#define bcm84756_a0_VLAN_MAPTABLE_56r_CLR(r)   \
            (r).vlan_maptable_56[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_56r_SET(r,d) \
            (r).vlan_maptable_56[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_56r_GET(r)   \
            (r).vlan_maptable_56[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_56r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_56[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_56r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_56[0]=(((r).vlan_maptable_56[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_56r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_56[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_56r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_56[0]=(((r).vlan_maptable_56[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_56.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_56r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_56r((c)),&((r)._vlan_maptable_56))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_56r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_56r((c)),&((r)._vlan_maptable_56))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_56r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_57
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 57.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_57r(c) \
		(0x13100055 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_57r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_57.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_57r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_57[1];
	buint32_t _vlan_maptable_57;
} bcm84756_a0_VLAN_MAPTABLE_57r_t;

#define bcm84756_a0_VLAN_MAPTABLE_57r_CLR(r)   \
            (r).vlan_maptable_57[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_57r_SET(r,d) \
            (r).vlan_maptable_57[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_57r_GET(r)   \
            (r).vlan_maptable_57[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_57r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_57[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_57r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_57[0]=(((r).vlan_maptable_57[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_57r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_57[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_57r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_57[0]=(((r).vlan_maptable_57[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_57.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_57r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_57r((c)),&((r)._vlan_maptable_57))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_57r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_57r((c)),&((r)._vlan_maptable_57))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_57r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_58
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 58.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_58r(c) \
		(0x13100056 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_58r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_58.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_58r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_58[1];
	buint32_t _vlan_maptable_58;
} bcm84756_a0_VLAN_MAPTABLE_58r_t;

#define bcm84756_a0_VLAN_MAPTABLE_58r_CLR(r)   \
            (r).vlan_maptable_58[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_58r_SET(r,d) \
            (r).vlan_maptable_58[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_58r_GET(r)   \
            (r).vlan_maptable_58[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_58r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_58[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_58r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_58[0]=(((r).vlan_maptable_58[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_58r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_58[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_58r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_58[0]=(((r).vlan_maptable_58[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_58.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_58r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_58r((c)),&((r)._vlan_maptable_58))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_58r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_58r((c)),&((r)._vlan_maptable_58))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_58r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_59
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 59.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_59r(c) \
		(0x13100057 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_59r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_59.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_59r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_59[1];
	buint32_t _vlan_maptable_59;
} bcm84756_a0_VLAN_MAPTABLE_59r_t;

#define bcm84756_a0_VLAN_MAPTABLE_59r_CLR(r)   \
            (r).vlan_maptable_59[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_59r_SET(r,d) \
            (r).vlan_maptable_59[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_59r_GET(r)   \
            (r).vlan_maptable_59[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_59r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_59[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_59r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_59[0]=(((r).vlan_maptable_59[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_59r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_59[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_59r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_59[0]=(((r).vlan_maptable_59[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_59.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_59r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_59r((c)),&((r)._vlan_maptable_59))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_59r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_59r((c)),&((r)._vlan_maptable_59))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_59r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_6
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 6.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_6r(c) \
		(0x13100022 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_6r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_6.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_6r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_6[1];
	buint32_t _vlan_maptable_6;
} bcm84756_a0_VLAN_MAPTABLE_6r_t;

#define bcm84756_a0_VLAN_MAPTABLE_6r_CLR(r)   \
            (r).vlan_maptable_6[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_6r_SET(r,d) \
            (r).vlan_maptable_6[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_6r_GET(r)   \
            (r).vlan_maptable_6[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_6r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_6[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_6r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_6[0]=(((r).vlan_maptable_6[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_6r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_6[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_6r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_6[0]=(((r).vlan_maptable_6[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_6.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_6r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_6r((c)),&((r)._vlan_maptable_6))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_6r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_6r((c)),&((r)._vlan_maptable_6))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_6r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_60
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 60.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_60r(c) \
		(0x13100058 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_60r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_60.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_60r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_60[1];
	buint32_t _vlan_maptable_60;
} bcm84756_a0_VLAN_MAPTABLE_60r_t;

#define bcm84756_a0_VLAN_MAPTABLE_60r_CLR(r)   \
            (r).vlan_maptable_60[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_60r_SET(r,d) \
            (r).vlan_maptable_60[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_60r_GET(r)   \
            (r).vlan_maptable_60[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_60r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_60[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_60r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_60[0]=(((r).vlan_maptable_60[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_60r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_60[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_60r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_60[0]=(((r).vlan_maptable_60[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_60.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_60r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_60r((c)),&((r)._vlan_maptable_60))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_60r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_60r((c)),&((r)._vlan_maptable_60))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_60r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_61
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 61.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_61r(c) \
		(0x13100059 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_61r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_61.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_61r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_61[1];
	buint32_t _vlan_maptable_61;
} bcm84756_a0_VLAN_MAPTABLE_61r_t;

#define bcm84756_a0_VLAN_MAPTABLE_61r_CLR(r)   \
            (r).vlan_maptable_61[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_61r_SET(r,d) \
            (r).vlan_maptable_61[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_61r_GET(r)   \
            (r).vlan_maptable_61[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_61r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_61[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_61r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_61[0]=(((r).vlan_maptable_61[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_61r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_61[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_61r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_61[0]=(((r).vlan_maptable_61[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_61.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_61r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_61r((c)),&((r)._vlan_maptable_61))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_61r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_61r((c)),&((r)._vlan_maptable_61))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_61r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_62
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 62.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_62r(c) \
		(0x1310005a + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_62r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_62.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_62r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_62[1];
	buint32_t _vlan_maptable_62;
} bcm84756_a0_VLAN_MAPTABLE_62r_t;

#define bcm84756_a0_VLAN_MAPTABLE_62r_CLR(r)   \
            (r).vlan_maptable_62[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_62r_SET(r,d) \
            (r).vlan_maptable_62[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_62r_GET(r)   \
            (r).vlan_maptable_62[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_62r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_62[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_62r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_62[0]=(((r).vlan_maptable_62[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_62r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_62[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_62r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_62[0]=(((r).vlan_maptable_62[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_62.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_62r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_62r((c)),&((r)._vlan_maptable_62))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_62r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_62r((c)),&((r)._vlan_maptable_62))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_62r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_63
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 63.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_63r(c) \
		(0x1310005b + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_63r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_63.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_63r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_63[1];
	buint32_t _vlan_maptable_63;
} bcm84756_a0_VLAN_MAPTABLE_63r_t;

#define bcm84756_a0_VLAN_MAPTABLE_63r_CLR(r)   \
            (r).vlan_maptable_63[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_63r_SET(r,d) \
            (r).vlan_maptable_63[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_63r_GET(r)   \
            (r).vlan_maptable_63[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_63r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_63[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_63r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_63[0]=(((r).vlan_maptable_63[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_63r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_63[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_63r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_63[0]=(((r).vlan_maptable_63[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_63.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_63r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_63r((c)),&((r)._vlan_maptable_63))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_63r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_63r((c)),&((r)._vlan_maptable_63))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_63r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_7
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 7.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_7r(c) \
		(0x13100023 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_7r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_7.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_7r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_7[1];
	buint32_t _vlan_maptable_7;
} bcm84756_a0_VLAN_MAPTABLE_7r_t;

#define bcm84756_a0_VLAN_MAPTABLE_7r_CLR(r)   \
            (r).vlan_maptable_7[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_7r_SET(r,d) \
            (r).vlan_maptable_7[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_7r_GET(r)   \
            (r).vlan_maptable_7[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_7r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_7[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_7r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_7[0]=(((r).vlan_maptable_7[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_7r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_7[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_7r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_7[0]=(((r).vlan_maptable_7[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_7.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_7r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_7r((c)),&((r)._vlan_maptable_7))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_7r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_7r((c)),&((r)._vlan_maptable_7))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_7r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_8
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 8.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_8r(c) \
		(0x13100024 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_8r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_8.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_8r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_8[1];
	buint32_t _vlan_maptable_8;
} bcm84756_a0_VLAN_MAPTABLE_8r_t;

#define bcm84756_a0_VLAN_MAPTABLE_8r_CLR(r)   \
            (r).vlan_maptable_8[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_8r_SET(r,d) \
            (r).vlan_maptable_8[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_8r_GET(r)   \
            (r).vlan_maptable_8[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_8r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_8[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_8r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_8[0]=(((r).vlan_maptable_8[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_8r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_8[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_8r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_8[0]=(((r).vlan_maptable_8[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_8.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_8r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_8r((c)),&((r)._vlan_maptable_8))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_8r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_8r((c)),&((r)._vlan_maptable_8))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_8r'
 ******************************************************************************/




/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  VLAN_MAPTABLE_9
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Egress Mapping Table Entry, entry 9.
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  VSAN_VFID        :
 *     Lookup table entry.
 *
 *  VLAN_VID         :
 *     Lookup table entry.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_VLAN_MAPTABLE_9r(c) \
		(0x13100025 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_VLAN_MAPTABLE_9r_SIZE 1

/*
 * This structure should be used to declare and program VLAN_MAPTABLE_9.
 *
 */
typedef union bcm84756_a0_VLAN_MAPTABLE_9r_s {
	buint32_t v[1];
	buint32_t vlan_maptable_9[1];
	buint32_t _vlan_maptable_9;
} bcm84756_a0_VLAN_MAPTABLE_9r_t;

#define bcm84756_a0_VLAN_MAPTABLE_9r_CLR(r)   \
            (r).vlan_maptable_9[0] = 0

#define bcm84756_a0_VLAN_MAPTABLE_9r_SET(r,d) \
            (r).vlan_maptable_9[0] = d

#define bcm84756_a0_VLAN_MAPTABLE_9r_GET(r)   \
            (r).vlan_maptable_9[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_VLAN_MAPTABLE_9r_VSAN_VFIDf_GET(c,r)         \
	(((r).vlan_maptable_9[0]) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_9r_VSAN_VFIDf_SET(c,r,f)       \
	(r).vlan_maptable_9[0]=(((r).vlan_maptable_9[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

#define bcm84756_a0_VLAN_MAPTABLE_9r_VLAN_VIDf_GET(c,r)         \
	((((r).vlan_maptable_9[0]) >> 16) & 0xfff)

#define bcm84756_a0_VLAN_MAPTABLE_9r_VLAN_VIDf_SET(c,r,f)       \
	(r).vlan_maptable_9[0]=(((r).vlan_maptable_9[0] & ~((buint32_t)0xfff << 16)) | \
		((((buint32_t)f) & 0xfff) << 16))


/*
 * These macros can be used to access VLAN_MAPTABLE_9.
 *
 */
#define bcm84756_a0_READ_VLAN_MAPTABLE_9r(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_VLAN_MAPTABLE_9r((c)),&((r)._vlan_maptable_9))

#define bcm84756_a0_WRITE_VLAN_MAPTABLE_9r(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_VLAN_MAPTABLE_9r((c)),&((r)._vlan_maptable_9))

/*******************************************************************************
 * End of 'bcm84756_a0_VLAN_MAPTABLE_9r'
 ******************************************************************************/

#define IS_C0_CHIP(c) (BFCMAP_PORT_DEVICE_CONTROL(c)->core_type == BFCMAP_CORE_BCM84756_C0)


/*******************************************************************************
 * CHIP:  bcm84756_c0
 * REGISTER:  MPORT_EGRESS_DATA_TRUNCATION_THD
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Mport Egress data FIFO truncation Threshold
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  MPORT_EGRESS_DATA_TRUNCATION_THD :
 *     Mport Egress data FIFO truncation Threshold in terms of 128-bit block.
 *     There is a 32KB egress SAF packet buffer. If the egress SAF buffer
 *     usage is more than this threshold, the current transmitting packet will
 *     be truncated. The rest of the packets will be dropped.
 *
 *
 ******************************************************************************/
#define bcm84756_c0_MPORT_EGRESS_DATA_TRUNCATION_THDr(c) \
		(0x02100008 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_c0_MPORT_EGRESS_DATA_TRUNCATION_THDr_SIZE 1

/*
 * This structure should be used to declare and program MPORT_EGRESS_DATA_TRUNCATION_THD.
 *
 */
typedef union bcm84756_c0_MPORT_EGRESS_DATA_TRUNCATION_THDr_s {
	buint32_t v[1];
	buint32_t mport_egress_data_truncation_thd[1];
	buint32_t _mport_egress_data_truncation_thd;
} bcm84756_c0_MPORT_EGRESS_DATA_TRUNCATION_THDr_t;

#define bcm84756_c0_MPORT_EGRESS_DATA_TRUNCATION_THDr_CLR(r)   \
            (r).mport_egress_data_truncation_thd[0] = 0

#define bcm84756_c0_MPORT_EGRESS_DATA_TRUNCATION_THDr_SET(r,d) \
            (r).mport_egress_data_truncation_thd[0] = d

#define bcm84756_c0_MPORT_EGRESS_DATA_TRUNCATION_THDr_GET(r)   \
            (r).mport_egress_data_truncation_thd[0]

/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_c0_MPORT_EGRESS_DATA_TRUNCATION_THDr_MPORT_EGRESS_DATA_TRUNCATION_THDf_GET(c,r)         \
	(((r).mport_egress_data_truncation_thd[0]) & 0xfff)

#define bcm84756_c0_MPORT_EGRESS_DATA_TRUNCATION_THDr_MPORT_EGRESS_DATA_TRUNCATION_THDf_SET(c,r,f)       \
	(r).mport_egress_data_truncation_thd[0]=(((r).mport_egress_data_truncation_thd[0] & ~((buint32_t)0xfff)) | \
		(((buint32_t)f) & 0xfff))

/*
 * These macros can be used to access MPORT_EGRESS_DATA_TRUNCATION_THD.
 *
 */
#define bcm84756_c0_READ_MPORT_EGRESS_DATA_TRUNCATION_THDr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_c0_MPORT_EGRESS_DATA_TRUNCATION_THDr((c)),&((r)._mport_egress_data_truncation_thd))

#define bcm84756_c0_WRITE_MPORT_EGRESS_DATA_TRUNCATION_THDr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_c0_MPORT_EGRESS_DATA_TRUNCATION_THDr((c)),&((r)._mport_egress_data_truncation_thd))

/*******************************************************************************
 * End of 'bcm84756_c0_MPORT_EGRESS_DATA_TRUNCATION_THDr'
 ******************************************************************************/

/*******************************************************************************
 * CHIP:  bcm84756_c0
 * REGISTER:  MPORT_EGRESS_HDR_TRUNCATION_THD
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Mport Egress header FIFO truncation Threshold
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  MPORT_EGRESS_HDR_TRUNCATION_THD :
 *     Mport Egress header FIFO truncation Threshold. There is a 512-entry
 *     egress SAF header buffer. If the egress SAF header buffer usage is more
 *     than this threshold, the current transmitting packet will be truncated.
 *     The rest of the packets will be dropped.
 *
 *
 ******************************************************************************/
#define bcm84756_c0_MPORT_EGRESS_HDR_TRUNCATION_THDr(c) \
		(0x0210000a + (BFCMAP_PORT((c)) << 12))

#define bcm84756_c0_MPORT_EGRESS_HDR_TRUNCATION_THDr_SIZE 1

/*
 * This structure should be used to declare and program MPORT_EGRESS_HDR_TRUNCATION_THD.
 *
 */
typedef union bcm84756_c0_MPORT_EGRESS_HDR_TRUNCATION_THDr_s {
	buint32_t v[1];
	buint32_t mport_egress_hdr_truncation_thd[1];
	buint32_t _mport_egress_hdr_truncation_thd;
} bcm84756_c0_MPORT_EGRESS_HDR_TRUNCATION_THDr_t;

#define bcm84756_c0_MPORT_EGRESS_HDR_TRUNCATION_THDr_CLR(r)   \
            (r).mport_egress_hdr_truncation_thd[0] = 0

#define bcm84756_c0_MPORT_EGRESS_HDR_TRUNCATION_THDr_SET(r,d) \
            (r).mport_egress_hdr_truncation_thd[0] = d

#define bcm84756_c0_MPORT_EGRESS_HDR_TRUNCATION_THDr_GET(r)   \
            (r).mport_egress_hdr_truncation_thd[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_c0_MPORT_EGRESS_HDR_TRUNCATION_THDr_MPORT_EGRESS_HDR_TRUNCATION_THDf_GET(c,r)         \
	(((r).mport_egress_hdr_truncation_thd[0]) & 0x3ff)

#define bcm84756_c0_MPORT_EGRESS_HDR_TRUNCATION_THDr_MPORT_EGRESS_HDR_TRUNCATION_THDf_SET(c,r,f)       \
	(r).mport_egress_hdr_truncation_thd[0]=(((r).mport_egress_hdr_truncation_thd[0] & ~((buint32_t)0x3ff)) | \
		(((buint32_t)f) & 0x3ff))


/*
 * These macros can be used to access MPORT_EGRESS_HDR_TRUNCATION_THD.
 *
 */
#define bcm84756_c0_READ_MPORT_EGRESS_HDR_TRUNCATION_THDr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_c0_MPORT_EGRESS_HDR_TRUNCATION_THDr((c)),&((r)._mport_egress_hdr_truncation_thd))

#define bcm84756_c0_WRITE_MPORT_EGRESS_HDR_TRUNCATION_THDr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_c0_MPORT_EGRESS_HDR_TRUNCATION_THDr((c)),&((r)._mport_egress_hdr_truncation_thd))

/*******************************************************************************
 * End of 'bcm84756_c0_MPORT_EGRESS_HDR_TRUNCATION_THDr'
 ******************************************************************************/

/*******************************************************************************
 * CHIP:  bcm84756_a0
 * REGISTER:  MPORT_SW_XPORT_RSV_MASK
 * BLOCKS:   SECPORT
 * DESCRIPTION :
 *	 Switch side MAC packet rx error mask
 *
 * SIZE:     32
 *
 * FIELDS DESCRIPTION:
 *  XPORT_RSV_MASK   :
 *     Mask bits for UniMAC RSV[33:16] and XMAC RSV[37:16]. 1 indicates purge
 *     is enabled for the respective error condition if (XPORT RSV MASK[21:0]
 *     & RSV[37:16]) == 1. It's recommended to program 0x1045d for UniMAC at
 *     non-10G link speed, and 0x10054 for XMAC at 10G link speed.
 *
 *
 ******************************************************************************/
#define bcm84756_a0_MPORT_SW_XPORT_RSV_MASKr(c) \
		(0x02100037 + (BFCMAP_PORT((c)) << 12))

#define bcm84756_a0_MPORT_SW_XPORT_RSV_MASKr_SIZE 1

/*
 * This structure should be used to declare and program MPORT_SW_XPORT_RSV_MASK.
 *
 */
typedef union bcm84756_a0_MPORT_SW_XPORT_RSV_MASKr_s {
	buint32_t v[1];
	buint32_t mport_sw_xport_rsv_mask[1];
	buint32_t _mport_sw_xport_rsv_mask;
} bcm84756_a0_MPORT_SW_XPORT_RSV_MASKr_t;

#define bcm84756_a0_MPORT_SW_XPORT_RSV_MASKr_CLR(r)   \
            (r).mport_sw_xport_rsv_mask[0] = 0

#define bcm84756_a0_MPORT_SW_XPORT_RSV_MASKr_SET(r,d) \
            (r).mport_sw_xport_rsv_mask[0] = d

#define bcm84756_a0_MPORT_SW_XPORT_RSV_MASKr_GET(r)   \
            (r).mport_sw_xport_rsv_mask[0]


/*
 * These macros can be used to access individual fields.
 *
 */
#define bcm84756_a0_MPORT_SW_XPORT_RSV_MASKr_XPORT_RSV_MASKf_GET(c,r)         \
	(((r).mport_sw_xport_rsv_mask[0]) & 0x3fffff)

#define bcm84756_a0_MPORT_SW_XPORT_RSV_MASKr_XPORT_RSV_MASKf_SET(c,r,f)       \
	(r).mport_sw_xport_rsv_mask[0]=(((r).mport_sw_xport_rsv_mask[0] & ~((buint32_t)0x3fffff)) | \
		(((buint32_t)f) & 0x3fffff))


/*
 * These macros can be used to access MPORT_SW_XPORT_RSV_MASK.
 *
 */
#define bcm84756_a0_READ_MPORT_SW_XPORT_RSV_MASKr(c,r)         \
        BFCMAP_REG32_READ((c),bcm84756_a0_MPORT_SW_XPORT_RSV_MASKr((c)),&((r)._mport_sw_xport_rsv_mask))

#define bcm84756_a0_WRITE_MPORT_SW_XPORT_RSV_MASKr(c,r)       \
        BFCMAP_REG32_WRITE((c),bcm84756_a0_MPORT_SW_XPORT_RSV_MASKr((c)),&((r)._mport_sw_xport_rsv_mask))

/*******************************************************************************
 * End of 'bcm84756_a0_MPORT_SW_XPORT_RSV_MASKr'
 ******************************************************************************/


#endif /* __bcm84756_a0_DEFS_H__ */
