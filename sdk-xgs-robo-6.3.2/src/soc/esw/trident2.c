/*
 * $Id: trident2.c 1.282.2.10 Broadcom SDK $
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * File:        trident2.c
 * Purpose:
 * Requires:
 */


#include <sal/core/boot.h>

#include <soc/trident2.h>
#include <soc/bradley.h>
#include <soc/drv.h>
#include <soc/error.h>
#include <soc/debug.h>
#include <soc/mem.h>
#include <soc/mspi.h>
#include <soc/l2x.h>

#ifdef BCM_TRIDENT2_SUPPORT

#ifdef ALPM_ENABLE
#include <soc/lpm.h>
#include <soc/alpm.h>
#include <soc/esw/alpm_int.h>
#endif /* ALPM_ENABLE */

#include <soc/mmu_config.h>
#include <soc/trident2.h>
#include <soc/post.h>

#define _TD2_PORTS_PER_XLP         4
#define _TD2_XLPS_PER_PGW          4
#define _TD2_PGWS_PER_QUAD         2
#define _TD2_QUADS_PER_PIPE        2
#define _TD2_PIPES_PER_DEV         2

#define _TD2_QUADS_PER_DEV         (_TD2_QUADS_PER_PIPE * _TD2_PIPES_PER_DEV)

#define _TD2_PGWS_PER_PIPE         (_TD2_PGWS_PER_QUAD * _TD2_QUADS_PER_PIPE)
#define _TD2_PGWS_PER_DEV          (_TD2_PGWS_PER_PIPE * _TD2_PIPES_PER_DEV)

#define _TD2_PORTS_PER_PGW         (_TD2_PORTS_PER_XLP * _TD2_XLPS_PER_PGW)
#define _TD2_PORTS_PER_QUAD        (_TD2_PORTS_PER_PGW * _TD2_PGWS_PER_QUAD)
#define _TD2_PORTS_PER_PIPE        (_TD2_PORTS_PER_QUAD * _TD2_QUADS_PER_PIPE) 

#define _TD2_BYTES_PER_OBM_CELL    16
#define _TD2_CELLS_PER_OBM         1020

#define _TD2_LOG_PORTS_PER_PIPE    53
#define _TD2_MMU_PORTS_PER_PIPE    53

#define _TD2_MMU_MAX_PACKET_BYTES    10240 /* bytes */
#define _TD2_MMU_PACKET_HEADER_BYTES 64    /* bytes */
#define _TD2_MMU_JUMBO_FRAME_BYTES   9216  /* bytes */
#define _TD2_MMU_DEFAULT_MTU_BYTES   1536  /* bytes */

#define _TD2_MMU_PHYSICAL_CELLS      65536 /* cells */
#define _TD2_MMU_TOTAL_CELLS         60495 /* 60494.76 cells (12Mbytes) */
#define _TD2_MMU_RSVD_CELLS_CFAP     608   /* cells */

#define _TD2_MMU_BYTES_PER_CELL      208   /* bytes (1664 bits) */
#define _TD2_MMU_NUM_PG              8
#define _TD2_MMU_NUM_POOL            4

#define SOC_TD2_MMU_CFG_QGROUP_MAX   128

#define SOC_TD2_MMU_MCQ_ENTRY        49152
#define SOC_TD2_MMU_RQE_ENTRY        4096

#define _TD2_MMU_TOTAL_MCQ_ENTRY(unit)  SOC_TD2_MMU_MCQ_ENTRY

#define _TD2_MMU_TOTAL_RQE_ENTRY(unit)  SOC_TD2_MMU_RQE_ENTRY

#define _SOC_TD2_DEFIP_MAX_TCAMS   8
#define _SOC_TD2_DEFIP_TCAM_DEPTH 1024

typedef enum {
    _SOC_PARITY_TYPE_NONE,
    _SOC_PARITY_TYPE_GENERIC,
    _SOC_PARITY_TYPE_PARITY,
    _SOC_PARITY_TYPE_ECC,
    _SOC_PARITY_TYPE_CPORT,
    _SOC_PARITY_TYPE_MMU_SER,
    _SOC_PARITY_TYPE_START_ERR,
    _SOC_PARITY_TYPE_SER,
    _SOC_PARITY_TYPE_BST
} _soc_td2_ser_info_type_t;

typedef struct _soc_td2_fifo_ser_info_s {
    soc_reg_t   enable_reg;
    soc_field_t enable_field;
    uint8       type; /* 0: mem, 1: reg, 2: bus */
    soc_mem_t   mem;
    soc_reg_t   reg;
    char        *name_str; /* Used when mem == INVALIDm or reg == INVALIDr or type == bus 
                              (either not accessible or multiple) */
} _soc_td2_fifo_ser_info_t;

typedef struct _soc_td2_ser_block_info_s {
    soc_block_t              blocktype;
    soc_reg_t                fifo_reset_reg;
    _soc_td2_fifo_ser_info_t *info;
} _soc_td2_ser_block_info_t;

typedef struct _soc_td2_ser_reg_s {
    soc_reg_t reg;
    char      *mem_str;
} _soc_td2_ser_reg_t;

typedef struct _soc_td2_ser_info_s {
    _soc_td2_ser_info_type_t   type;
    struct _soc_td2_ser_info_s *info;
    int                        id;
    soc_field_t                group_reg_enable_field;
    soc_field_t                group_reg_status_field;
    soc_mem_t                  mem;
    char                       *mem_str;
    soc_reg_t                  enable_reg;
    soc_field_t                enable_field;
    soc_reg_t                  intr_status_reg;
    _soc_td2_ser_reg_t         *intr_status_reg_list;
} _soc_td2_ser_info_t;

typedef struct _soc_td2_ser_route_block_s {
    uint32              cmic_bit;
    soc_block_t         blocktype;
    int                 pipe;
    soc_reg_t           enable_reg;
    soc_reg_t           status_reg;
    soc_field_t         enable_field;
    _soc_td2_ser_info_t *info;
    uint8               id;
} _soc_td2_ser_route_block_t;

STATIC
_soc_td2_fifo_ser_info_t _soc_td2_ep_ser_info[] = {
    { EFP_PARITY_CONTROLr, EFP_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "EFP BUS" },
    { EFP_PARITY_CONTROLr, PW_INIT_COUNTERS_PARITY_ENf, 0, EGR_PW_INIT_COUNTERSm, INVALIDr, "" },
    { EFP_PARITY_CONTROLr, METER_PARITY_ENf, 0, EFP_METER_TABLEm, INVALIDr, "" },
    { EFP_PARITY_CONTROLr, POLICY_PARITY_ENf, 0, EFP_POLICY_TABLEm, INVALIDr, "" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP15_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP15 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP14_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP14 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP13_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP13 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP12_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP12 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP11_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP11 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP10_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP10 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP9_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP9 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP8_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP8 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP7_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP7 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP6_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP6 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP5_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP5 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP4_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP4 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP3_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP3 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP2_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP2 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP1_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP1 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, XLP0_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP0 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, CLP3_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP3 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, CLP2_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP2 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, CLP1_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP1 CELL DATABUF" },
    { EGR_EDATABUF_PARITY_CONTROLr, CLP0_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP0 CELL DATABUF" },
    /*{ EGR_EDATABUF_PARITY_CONTROLr, XLP_RESI_BUFFER_PAR_ENf, 0, INVALIDm, INVALIDr, "EP RESIDUE BUF" },*/
    { EGR_EDATABUF_PARITY_CONTROLr, CM_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CM" },
    { EGR_EDATABUF_PARITY_CONTROLr, FCOE_DELIMITER_ERR_CNTR_PAR_ENf, 1, INVALIDm, EGR_FCOE_DELIMITER_ERROR_FRAMESr, "" },
    { EGR_EDATABUF_PARITY_CONTROLr, FCOE_INVALID_CNTR_PAR_ENf, 1, INVALIDm, EGR_FCOE_INVALID_CRC_FRAMESr, "" },
    { EGR_EDATABUF_PARITY_CONTROLr, PERQ_PAR_ENf, 0, EGR_PERQ_XMT_COUNTERSm, INVALIDr, "" },
    { EGR_EDATABUF_PARITY_CONTROLr, EFPCTR_PAR_ENf, 0, EFP_COUNTER_TABLEm, INVALIDr, "" },
    { EGR_EDATABUF_PARITY_CONTROLr, STATS_PAR_ENf, 0, INVALIDm, INVALIDr, "TX DEBUG COUNTER" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP15_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP15 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP14_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP14 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP13_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP13 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP12_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP12 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP11_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP11 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP10_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP10 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP9_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP9 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP8_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP8 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP7_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP7 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP6_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP6 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP5_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP5 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP4_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP4 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP3_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP3 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP2_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP2 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP1_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP1 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, XLP0_ECC_ENf, 0, INVALIDm, INVALIDr, "EP XLP0 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, CLP3_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP3 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, CLP2_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP2 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, CLP1_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP1 DATABUF CONTROL INFO" },
    { EGR_EDB_CTRL_PARITY_ENr, CLP0_ECC_ENf, 0, INVALIDm, INVALIDr, "EP CLP0 DATABUF CONTROL INFO" },
    { EGR_EFPPARS_PARITY_CONTROLr, EGR_1588_LINK_DELAY_PARITY_ENf, 1, INVALIDm, EGR_1588_LINK_DELAY_64r, "" },
    { EGR_EFPPARS_PARITY_CONTROLr, EGR_1588_SA_PARITY_ENf, 0, EGR_1588_SAm, INVALIDr, "" },
    { EGR_EFPPARS_SER_CONTROLr, EFPPARS_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "EFPPARS BUS" },
    { EGR_EHCPM_ECC_PARITY_CONTROLr, SF_SRC_MODID_CHECK_PARITY_ENf, 1, INVALIDm, EGR_SF_SRC_MODID_CHECKr, "" },
    { EGR_EHCPM_ECC_PARITY_CONTROLr, MOD_MAP_PARITY_ENf, 0, EGR_MOD_MAP_TABLEm, INVALIDr, "" },
    { EGR_EHCPM_SER_CONTROLr, EHCPM_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "EHCPM BUS" },
    { EGR_EL3_ECC_PARITY_CONTROLr, INITBUF_ECC_ENf, 0, INVALIDm, INVALIDr, "INIT BUFF" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_NAT_PACKET_EDIT_INFO_PARITY_ENf, 0, EGR_NAT_PACKET_EDIT_INFOm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_MAP_MH_PARITY_ENf, 0, EGR_MAP_MHm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_MPB_ECC_ENf, 0, INVALIDm, INVALIDr, "EGR MPB" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_PORT_PARITY_ENf, 0, EGR_PORTm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_IPMC_PARITY_ENf, 0, EGR_IPMCm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_VFI_PARITY_ENf, 0, EGR_VFIm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_DVP_ATTRIBUTE_PARITY_ENf, 0, EGR_DVP_ATTRIBUTEm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_MAC_DA_PROFILE_PARITY_ENf, 0, EGR_MAC_DA_PROFILEm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PARITY_ENf, 0, EGR_MPLS_VC_AND_SWAP_LABEL_TABLEm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_L3_INTF_PARITY_ENf, 0, EGR_L3_INTFm, INVALIDr, "" },
    { EGR_EL3_ECC_PARITY_CONTROLr, EGR_L3_NEXT_HOP_PARITY_ENf, 0, EGR_L3_NEXT_HOPm, INVALIDr, "" },
    { EGR_EPMOD_SER_CONTROLr, EPMOD_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "EPMOD BUS" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_XLATE_PARITY_EN_LPf, 0, EGR_VLAN_XLATE_LPm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EVLAN_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "EVLAN BUS" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_TAG_ACTION_PROFILE_PARITY_ENf, 0, EGR_VLAN_TAG_ACTION_PROFILEm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_ETAG_PCP_MAPPING_PARITY_ENf, 0, EGR_ETAG_PCP_MAPPINGm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_CONTROL_3_PARITY_ENf, 1, INVALIDm, EGR_VLAN_CONTROL_3r, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_CONTROL_2_PARITY_ENf, 1, INVALIDm, EGR_VLAN_CONTROL_2r, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_PVLAN_EPORT_CONTROL_PARITY_ENf, 1, INVALIDm, EGR_PVLAN_EPORT_CONTROLr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VP_VLAN_MEMBERSHIP_PARITY_ENf, 0, EGR_VP_VLAN_MEMBERSHIPm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VPLAG_MEMBER_PARITY_ENf, 0, EGR_VPLAG_MEMBERm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VPLAG_GROUP_PARITY_ENf, 0, EGR_VPLAG_GROUPm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_MPLS_EXP_MAPPING_1_PARITY_ENf, 0, EGR_MPLS_EXP_MAPPING_1m, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_GPP_ATTRIBUTES_PARITY_ENf, 0, EGR_GPP_ATTRIBUTESm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_GPP_ATTRIBUTES_MODBASE_PARITY_ENf, 0, EGR_GPP_ATTRIBUTES_MODBASEm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_FRAGMENT_ID_TABLE_PARITY_ENf, 0, EGR_FRAGMENT_ID_TABLEm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_DSCP_TABLE_PARITY_ENf, 0, EGR_DSCP_TABLEm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_PRI_CNG_MAP_PARITY_ENf, 0, EGR_PRI_CNG_MAPm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_MPLS_PRI_MAPPING_PARITY_ENf, 0, EGR_MPLS_PRI_MAPPINGm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_MPLS_EXP_MAPPING_2_PARITY_ENf, 0, EGR_MPLS_EXP_MAPPING_2m, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_IP_TUNNEL_PARITY_ENf, 0, EGR_IP_TUNNELm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_XLATE_PARITY_ENf, 0, EGR_VLAN_XLATEm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_STG_PARITY_ENf, 0, EGR_VLAN_STGm, INVALIDr, "" },
    { EGR_VLAN_SER_CONTROLr, EGR_VLAN_PARITY_ENf, 0, EGR_VLANm, INVALIDr, "" },
    { INVALIDr }
};

STATIC
_soc_td2_fifo_ser_info_t _soc_td2_ip_ser_info[] = {
    { CFG_SER_CONTROLr, PORT_TABLE_ECC_ENf, 0, PORT_TABm, INVALIDr, "" },
    { CFG_SER_CONTROLr, SYSTEM_CONFIG_TABLE_PAR_ENf, 0, SYSTEM_CONFIG_TABLEm, INVALIDr, "" },
    { CFG_SER_CONTROLr, SYSTEM_CONFIG_TABLE_MODBASE_PAR_ENf, 0, SYSTEM_CONFIG_TABLE_MODBASEm, INVALIDr, "" },
    { CFG_SER_CONTROLr, SOURCE_TRUNK_MAP_MODBASE_PAR_ENf, 0, SOURCE_TRUNK_MAP_MODBASEm, INVALIDr, "" },
    /* NOTE: Read does not get the correct value for this reg */
    { DLB_HGT_SER_CONTROLr, DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PARITY_ENf, 0, DLB_HGT_FLOWSET_TIMESTAMP_PAGEm, INVALIDr, "" }, 
    { DLB_HGT_SER_CONTROLr, DLB_HGT_FLOWSET_PARITY_ENf, 0, DLB_HGT_FLOWSETm, INVALIDr, "" },
    { IARB_SER_CONTROLr, LEARN_FIFO_ECC_ENf, 0, INVALIDm, INVALIDr, "IARB LEARN FIFO" },
    { IARB_SER_CONTROLr, CMIC_BUF_ECC_ENf, 0, INVALIDm, INVALIDr, "CMIC BUFFER" },
    { IFP_PARITY_CONTROLr, IFP_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "IFP BUS" },
    /*{ IFP_PARITY_CONTROLr, COUNTER_MUX_DATA_STAGING_PARITY_ENf, 0, INVALIDm, INVALIDr, "COUNTER MUX DATA STAGING" }, HOW TO CLEAR */
    /*{ IFP_PARITY_CONTROLr, METER_MUX_DATA_STAGING_PARITY_ENf, 0, INVALIDm, INVALIDr, "METER MUX DATA STAGING" }, HOW TO CLEAR */
    { IFP_PARITY_CONTROLr, PORT_METER_MAP_PARITY_ENf, 0, FP_PORT_METER_MAPm, INVALIDr, "" },
    { IFP_PARITY_CONTROLr, ING_DVP_2_PARITY_ENf, 0, ING_DVP_2_TABLEm, INVALIDr, "" },
    { IFP_PARITY_CONTROLr, STORM_PARITY_ENf, 0, FP_STORM_CONTROL_METERSm, INVALIDr, "" },
    { IFP_PARITY_CONTROLr, COUNTER_PARITY_ENf, 0, FP_COUNTER_TABLEm, INVALIDr, "" },
    { IFP_PARITY_CONTROLr, METER_PARITY_ENf, 0, FP_METER_TABLEm, INVALIDr, "" },
    { IFP_PARITY_CONTROLr, POLICY_PARITY_ENf, 0, FP_POLICY_TABLEm, INVALIDr, "" },
    { IL2L3_BUS_SER_CONTROLr, PARITY_ENf, 2, INVALIDm, INVALIDr, "IL2L3 BUS" },
    /*{ ILPM_SER_CONTROLr, L3_DEFIP_ALPM_PARITY_ENf, 0, INVALIDm, INVALIDr, "L3 DEFIP ALPM IPV4/_1/IPV6_64/_64_1/_128" },
    { ILPM_SER_CONTROLr, L3_DEFIP_AUX_PARITY_ENf, 0, L3_DEFIP_AUX_TABLEm, INVALIDr, "" },*/
    { ILPM_SER_CONTROLr, L3_DEFIP_DATA_PARITY_ENf, 0, L3_DEFIP_DATA_ONLYm, INVALIDr, "" },
    { ILPM_SER_CONTROL_1r, RTAG7_PORT_BASED_HASH_PARITY_ENf, 0, RTAG7_PORT_BASED_HASHm, INVALIDr, "" },
    { ILPM_SER_CONTROL_1r, RTAG7_FLOW_BASED_HASH_PARITY_ENf, 0, RTAG7_FLOW_BASED_HASHm, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_0r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_0m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_1r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_1m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_2r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_2m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_3r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_3m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_4r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_4m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_5r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_5m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_6r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_6m, INVALIDr, "" },
    { ING_FLEX_CTR_OFFSET_TABLE_CONTROL_7r, PARITY_ENf, 0, ING_FLEX_CTR_OFFSET_TABLE_7m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_0r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_0m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_1r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_1m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_2r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_2m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_3r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_3m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_4r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_4m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_5r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_5m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_6r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_6m, INVALIDr, "" },
    { ING_FLEX_CTR_COUNTER_TABLE_CONTROL_7r, PARITY_ENf, 0, ING_FLEX_CTR_COUNTER_TABLE_7m, INVALIDr, "" },
    { IPARS_SER_CONTROLr, IPARS_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "IARS BUS" },
    { IPARS_SER_CONTROLr, SRC_VP_2_PARITY_ENf, 0, SOURCE_VP_2m, INVALIDr, "" },
    { IPARS_SER_CONTROLr, SRC_TRUNK_ECC_ENf, 0, SOURCE_TRUNK_MAP_TABLEm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, L3_TUNNEL_PARITY_ENf, 0, L3_TUNNELm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, FP_UDF_PARITY_ENf, 0, UDF_OFFSETm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, MOD_MAP_PARITY_ENf, 0, ING_MOD_MAP_TABLEm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, LPORT_TABLE_ECC_ENf, 0, LPORT_TABm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, CPU_TS_PARITY_ENf, 0, CPU_TS_MAPm, INVALIDr, "" },
    { IPARS_SER_CONTROLr, VLAN_RANGE_PARITY_ENf, 0, ING_VLAN_RANGEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, INITIAL_ING_L3_NEXT_HOP_PARITY_ENf, 0, INITIAL_ING_L3_NEXT_HOPm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, INITIAL_L3_ECMP_GROUP_PARITY_ENf, 0, INITIAL_L3_ECMP_GROUPm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, INITIAL_L3_ECMP_PARITY_ENf, 0, INITIAL_L3_ECMPm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, OAM_OPCODE_CONTROL_PROFILE_PARITY_ENf, 0, OAM_OPCODE_CONTROL_PROFILEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, INITIAL_PROT_NHI_TABLE_PARITY_ENf, 0, INITIAL_PROT_NHI_TABLEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, PORT_CBL_TABLE_PARITY_ENf, 0, PORT_CBL_TABLEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, TRUNK_CBL_TABLE_PARITY_ENf, 0, TRUNK_CBL_TABLEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, PORT_CBL_TABLE_MODBASE_PARITY_ENf, 0, PORT_CBL_TABLE_MODBASEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, L3_IPMC_1_PARITY_ENf, 0, L3_IPMC_1m, INVALIDr, "" },
/*    { IRSEL1_SER_CONTROLr, MAID_REDUCTION_PARITY_ENf, 0, MAID_REDUCTIONm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, MA_INDEX_PARITY_ENf, 0, MA_INDEXm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, MA_STATE_PARITY_ENf, 0, MA_STATEm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, RMEP_PARITY_ENf, 0, RMEPm, INVALIDr, "" },*/
    { IRSEL1_SER_CONTROLr, ING_1588_INGRESS_CTRL_PARITY_ENf, 0, ING_1588_INGRESS_CTRLm, INVALIDr, "" },
    { IRSEL1_SER_CONTROLr, IRSEL1_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "IRSEL1 BUS" },
    { IRSEL2_SER_CONTROLr, ING_L3_NEXT_HOP_PARITY_ENf, 0, ING_L3_NEXT_HOPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, L2MC_PARITY_ENf, 0, L2MCm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, L3_IPMC_PARITY_ENf, 0, L3_IPMCm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, L3_IPMC_REMAP_PARITY_ENf, 0, L3_IPMC_REMAPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, L3_ECMP_GROUP_PARITY_ENf, 0, L3_ECMP_COUNTm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, L3_ECMP_PARITY_ENf, 0, L3_ECMPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, IFP_REDIRECTION_PROFILE_PARITY_ENf, 0, IFP_REDIRECTION_PROFILEm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, ICONTROL_OPCODE_BITMAP_PARITY_ENf, 0, ICONTROL_OPCODE_BITMAPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, EGR_MASK_MODBASE_PARITY_ENf, 0, EGR_MASK_MODBASEm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, DEST_TRUNK_BITMAP_PARITY_ENf, 0, DEST_TRUNK_BITMAPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, TRUNK_GROUP_PARITY_ENf, 0, TRUNK_GROUPm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, RH_ECMP_FLOWSET_PARITY_ENf, 0, RH_ECMP_FLOWSETm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, RH_LAG_FLOWSET_PARITY_ENf, 0, RH_LAG_FLOWSETm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, ING_SNAT_DATA_ONLY_PARITY_ENf, 0, ING_SNATm, INVALIDr, "" },
    { IRSEL2_SER_CONTROLr, IRSEL2_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "IRSEL2 BUS" },
    { ISW1_SER_CONTROLr, FP_PORT_FIELD_SEL_PARITY_ENf, 0, FP_PORT_FIELD_SELm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, TTL_FN_PARITY_ENf, 0, TTL_FNm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, TOS_FN_PARITY_ENf, 0, TOS_FNm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, ING_PRI_CNG_MAP_PARITY_ENf, 0, ING_PRI_CNG_MAPm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, ING_UNTAGGED_PHB_PARITY_ENf, 0, ING_UNTAGGED_PHBm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, DSCP_TABLE_PARITY_ENf, 0, DSCP_TABLEm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, STORM_CONTROL_METER_CONFIG_PARITY_ENf, 1, INVALIDm, STORM_CONTROL_METER_CONFIGr, "" },
    { ISW1_SER_CONTROLr, FCOE_HOP_COUNT_FN_PARITY_ENf, 0, FCOE_HOP_COUNT_FNm, INVALIDr, "" },
    { ISW1_SER_CONTROLr, ISW1_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "ISW1 BUS" },
    { ISW2_SER_CONTROL_0r, VOQ_PORT_MAP_PARITY_ENf, 0, VOQ_PORT_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, VOQ_MOD_MAP_PARITY_ENf, 0, VOQ_MOD_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, TRUNK_MEMBER_PARITY_ENf, 0, TRUNK_MEMBERm, INVALIDr, "" },
    /*{ ISW2_SER_CONTROL_0r, DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PARITY_ENf, 0, DLB_HGT_FLOWSET_TIMESTAMP_PAGEm, 
      INVALIDr, "" }, DUPLICATE */
    { ISW2_SER_CONTROL_0r, UNKNOWN_HGI_BITMAP_PARITY_ENf, 0, UNKNOWN_HGI_BITMAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, IMIRROR_BITMAP_PARITY_ENf, 0, IMIRROR_BITMAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, KNOWN_MCAST_BLOCK_MASK_PARITY_ENf, 0, KNOWN_MCAST_BLOCK_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, ING_EGRMSKBMAP_PARITY_ENf, 0, ING_EGRMSKBMAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, BCAST_BLOCK_MASK_PARITY_ENf, 0, BCAST_BLOCK_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, UNKNOWN_MCAST_BLOCK_MASK_PARITY_ENf, 0, UNKNOWN_MCAST_BLOCK_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, UNKNOWN_UCAST_BLOCK_MASK_PARITY_ENf, 0, UNKNOWN_UCAST_BLOCK_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PARITY_ENf, 0, LOCAL_SW_DISABLE_DEFAULT_PBM_MIRRm, 
      INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, LOCAL_SW_DISABLE_DEFAULT_PBM_PARITY_ENf, 0, LOCAL_SW_DISABLE_DEFAULT_PBMm, INVALIDr, "" },
    /*{ ISW2_SER_CONTROL_0r, VOQ_COS_MAP_PARITY_ENf, 0, VOQ_COS_MAPm, INVALIDr, "" }, NA */
    { ISW2_SER_CONTROL_0r, NUM_QCN_CNM_RECEIVED_PARITY_ENf, 0, NUM_QCN_CNM_RECEIVEDm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, OAM_LM_COUNTERS_PARITY_ENf, 0, OAM_LM_COUNTERSm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, SRC_MODID_EGRESS_PARITY_ENf, 0, SRC_MODID_EGRESSm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, SRC_MODID_INGRESS_BLOCK_PARITY_ENf, 0, SRC_MODID_INGRESS_BLOCKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, E2E_HOL_STATUS_1_PARITY_ENf, 0, E2E_HOL_STATUS_1m, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, E2E_HOL_STATUS_PARITY_ENf, 0, E2E_HOL_STATUSm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, VLAN_PROFILE_2_PARITY_ENf, 0, VLAN_PROFILE_2m, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, MAC_BLOCK_TABLE_PARITY_ENf, 0, MAC_BLOCKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, ING_PW_TERM_SEQ_NUM_PARITY_ENf, 0, ING_PW_TERM_SEQ_NUMm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, ALTERNATE_EMIRROR_BITMAP_PARITY_ENf, 0, ALTERNATE_EMIRROR_BITMAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, MODPORT_MAP_MIRROR_PARITY_ENf, 0, MODPORT_MAP_MIRRORm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, PORT_LAG_FAILOVER_SET_PARITY_ENf, 0, PORT_LAG_FAILOVER_SETm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, ING_HIGIG_TRUNK_OVERRIDE_PROFILE_PARITY_ENf, 0, ING_HIGIG_TRUNK_OVERRIDE_PROFILEm, 
      INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, MODPORT_MAP_SW_PARITY_ENf, 0, MODPORT_MAP_SWm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, NONUCAST_TRUNK_BLOCK_MASK_PARITY_ENf, 0, NONUCAST_TRUNK_BLOCK_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, TRUNK_BITMAP_TABLE_PARITY_ENf, 0, TRUNK_BITMAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_0r, EGR_MASK_PARITY_ENf, 0, EGR_MASKm, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, SERVICE_PORT_MAP_PARITY_ENf, 0, SERVICE_PORT_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, SERVICE_QUEUE_MAP_PARITY_ENf, 0, SERVICE_QUEUE_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, MODPORT_MAP_M3_PARITY_ENf, 0, MODPORT_MAP_M3m, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, MODPORT_MAP_M2_PARITY_ENf, 0, MODPORT_MAP_M2m, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, MODPORT_MAP_M1_PARITY_ENf, 0, MODPORT_MAP_M1m, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, ING_MISC_PORT_CONFIG_PARITY_ENf, 1, INVALIDm, ING_MISC_PORT_CONFIGr, "" },
    { ISW2_SER_CONTROL_1r, SFLOW_EGR_THRESHOLD_PARITY_ENf, 1, INVALIDm, SFLOW_EGR_THRESHOLDr, "" },
    { ISW2_SER_CONTROL_1r, SFLOW_ING_THRESHOLD_PARITY_ENf, 1, INVALIDm, SFLOW_ING_THRESHOLDr, "" },
    /*{ ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_VLAN_TAGGED_PARITY_ENf, 1, INVALIDm,
      ING_NIV_RX_FRAMES_VLAN_TAGGEDr, "" },
    { ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_FORWARDING_DROP_PARITY_ENf, 1, INVALIDm, 
      ING_NIV_RX_FRAMES_FORWARDING_DROPr, "" },
    { ISW2_SER_CONTROL_1r, ING_NIV_RX_FRAMES_ERROR_DROP_PARITY_ENf, 1, INVALIDm,
      ING_NIV_RX_FRAMES_ERROR_DROPr, "" },*/
    
    
    { ISW2_SER_CONTROL_1r, L3_MTU_VALUES_PARITY_ENf, 0, L3_MTU_VALUESm, INVALIDr, "" },
    /*{ ISW2_SER_CONTROL_1r, ING_TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PARITY_ENf, 1, INVALIDm, 
      ING_TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDEDr, "" },
    { ISW2_SER_CONTROL_1r, ING_TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PARITY_ENf, 1, INVALIDm, 
      ING_TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDEDr, "" },
    { ISW2_SER_CONTROL_1r, ING_TRILL_RX_PKTS_PARITY_ENf, 1, INVALIDm, ING_TRILL_RX_PKTSr, "" },*/
    { ISW2_SER_CONTROL_1r, HG_COUNTERS_PARITY_ENf, 1, INVALIDm, INVALIDr, "HG STATS COUNTERS" },
    { ISW2_SER_CONTROL_1r, RDBGC_MEM_INST2_PARITY_ENf, 1, INVALIDm, INVALIDr, "RDBGC5/RDBGC6/RDBGC7/RDBGC8" },
    { ISW2_SER_CONTROL_1r, RDBGC_MEM_INST1_PARITY_ENf, 1, INVALIDm, INVALIDr, "RDBGC1/RDBGC2/RDBGC3/RDBGC4" },
    { ISW2_SER_CONTROL_1r, RDBGC_MEM_INST0_PARITY_ENf, 1, INVALIDm, INVALIDr, "RDISC/RUC/RPORTD/RDBGC0" },
    { ISW2_SER_CONTROL_1r, IP_COUNTERS_PARITY_ENf, 1, INVALIDm, INVALIDr, "IP STATS COUNTERS" },
    { ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_C_PARITY_ENf, 0, INVALIDm, INVALIDr, "SW2 EOP BUFFER C" },
    { ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_B_PARITY_ENf, 0, INVALIDm, INVALIDr, "SW2 EOP BUFFER B" },
    { ISW2_SER_CONTROL_1r, SW2_EOP_BUFFER_A_PARITY_ENf, 0, INVALIDm, INVALIDr, "SW2 EOP BUFFER A" },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL3_PARITY_ENf, 0, EMIRROR_CONTROL3m, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL2_PARITY_ENf, 0, EMIRROR_CONTROL2m, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL1_PARITY_ENf, 0, EMIRROR_CONTROL1m, INVALIDr, "" },
    { ISW2_SER_CONTROL_1r, EMIRROR_CONTROL_PARITY_ENf, 0, EMIRROR_CONTROLm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ENDPOINT_COS_MAP_PARITY_ENf, 0, ENDPOINT_COS_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, PHB2_COS_MAP_PARITY_ENf, 0, PHB2_COS_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ENDPOINT_QUEUE_MAP_PARITY_ENf, 0, ENDPOINT_QUEUE_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_FLEX_CTR_PKT_PRI_MAP_PARITY_ENf, 0, ING_FLEX_CTR_PKT_PRI_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_FLEX_CTR_PRI_CNG_MAP_PARITY_ENf, 0, ING_FLEX_CTR_PRI_CNG_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_FLEX_CTR_PORT_MAP_PARITY_ENf, 0, ING_FLEX_CTR_PORT_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_FLEX_CTR_TOS_MAP_PARITY_ENf, 0, ING_FLEX_CTR_TOS_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_FLEX_CTR_PKT_RES_MAP_PARITY_ENf, 0, ING_FLEX_CTR_PKT_RES_MAPm, INVALIDr, "" },
    { ISW2_SER_CONTROL_2r, ING_SERVICE_PRI_MAP_PARITY_ENf, 0, ING_SERVICE_PRI_MAPm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VLAN_XLATE_PARITY_EN_LPf, 0, VLAN_XLATE_LPm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, ING_ETAG_PCP_MAPPING_PARITY_ENf, 0, ING_VLAN_TAG_ACTION_PROFILEm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VLAN_PROTOCOL_DATA_PARITY_ENf, 0, VLAN_PROTOCOL_DATAm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, ING_VLAN_TAG_ACTION_PROFILE_PARITY_ENf, 0, ING_VLAN_TAG_ACTION_PROFILEm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, MPLS_ENTRY_PARITY_ENf, 0, MPLS_ENTRYm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VLAN_SUBNET_PARITY_ENf, 0, VLAN_SUBNETm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VLAN_PROT_PARITY_ENf, 0, VLAN_PROTOCOLm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VLAN_XLATE_PARITY_ENf, 0, VLAN_XLATEm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, VFP_POLICY_PARITY_ENf, 0, VFP_POLICY_TABLEm, INVALIDr, "" },
    { IVXLT_SER_CONTROLr, IVXLT_BUS_PARITY_ENf, 2, INVALIDm, INVALIDr, "IVXLT BUS" },
    { L2_ENTRY_PARITY_CONTROLr, PARITY_ENf, 0, L2Xm, INVALIDr, "" },
    { L2_ENTRY_PARITY_CONTROLr, ING_DVP_TABLE_PARITY_ENf, 0, ING_DVP_TABLEm, INVALIDr, "" },
    { L2_ENTRY_PARITY_CONTROLr, L2_ENDPOINT_ID_PARITY_ENf, 0, L2_ENDPOINT_IDm, INVALIDr, "" },
    { L2_ENTRY_PARITY_CONTROLr, PARITY_EN_LPf, 0, L2_ENTRY_LPm, INVALIDr, "" },
    { L2_MOD_FIFO_PARITY_CONTROLr, PARITY_ENf, 0, L2_MOD_FIFOm, INVALIDr, "" },
    { L2_USER_ENTRY_DATA_PARITY_CONTROLr, PARITY_ENf, 0, L2_USER_ENTRY_DATA_ONLYm, INVALIDr, "" },
    { L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, 0, L3_ENTRY_ONLYm, INVALIDr, "" },
    { L3_ENTRY_PARITY_CONTROLr, ING_ACTIVE_L3_IIF_PROFILE_PARITY_ENf, 0, ING_ACTIVE_L3_IIF_PROFILEm, INVALIDr, "" },
    { L3_ENTRY_PARITY_CONTROLr, PARITY_EN_LPf, 0, L3_ENTRY_LPm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, ING_VP_VLAN_MEMBERSHIP_PAR_ENf, 0, ING_VP_VLAN_MEMBERSHIPm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, L3_IIF_PAR_ENf, 0, L3_IIFm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, ING_MPLS_EXP_MAPPING_PAR_ENf, 0, ING_MPLS_EXP_MAPPINGm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, VRF_PAR_ENf, 0, VRFm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, VLAN_PAR_ENf, 0, VLAN_TABm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, VLAN_STG_PAR_ENf, 0, STG_TABm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, VLAN_PROFILE_PAR_ENf, 0, VLAN_PROFILE_TABm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, ING_OUTER_DOT1P_MAPPING_TABLE_PAR_ENf, 0, ING_OUTER_DOT1P_MAPPING_TABLEm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, IP_OPTION_CONTROL_PROFILE_TABLE_PAR_ENf, 0, IP_OPTION_CONTROL_PROFILE_TABLEm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, L3_IIF_PROFILE_PAR_ENf, 0, L3_IIF_PROFILEm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, ING_DNAT_ADDRESS_TYPE_PAR_ENf, 0, ING_DNAT_ADDRESS_TYPEm, INVALIDr, "" },
    { MPLS_SER_CONTROLr, MPLS_BUS_PAR_ENf, 2, INVALIDm, INVALIDr, "MPLS BUS" },
    { VP_SER_CONTROLr, VLAN_MPLS_PAR_ENf, 0, VLAN_MPLSm, INVALIDr, "" },
    { VP_SER_CONTROLr, MY_STATION_TCAM_DATA_ONLY_PAR_ENf, 0, MY_STATION_TCAMm, INVALIDr, "" },
    { VP_SER_CONTROLr, SOURCE_VP_PAR_ENf, 0, SOURCE_VPm, INVALIDr, "" },
    { VP_SER_CONTROLr, VFI_PAR_ENf, 0, VFIm, INVALIDr, "" },
    { VP_SER_CONTROLr, VFI_1_PAR_ENf, 0, VFI_1m, INVALIDr, "" },
    { VP_SER_CONTROLr, ING_VSAN_PAR_ENf, 0, ING_VSANm, INVALIDr, "" },
    { VP_SER_CONTROLr, ING_TRILL_ADJACENCY_PAR_ENf, 1, INVALIDm, ING_TRILL_ADJACENCYr, "" },
    { VP_SER_CONTROLr, VP_BUS_PAR_ENf, 2, INVALIDm, INVALIDr, "VP BUS" },
    { INVALIDr }
};

STATIC const
_soc_td2_ser_block_info_t _soc_td2_ser_block_info[] = {
    { SOC_BLK_IPIPE, ING_SER_FIFO_CTRLr, _soc_td2_ip_ser_info },
    { SOC_BLK_EPIPE, EGR_SER_FIFO_CTRLr, _soc_td2_ep_ser_info },
    { 0 }
};

STATIC _soc_td2_ser_info_t _soc_td2_mmu_ser_info[] = {
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0,
        DEQ_NOT_IP_ERR_ENf,
        DEQ_NOT_IP_ERRf,
        INVALIDm, "MMU DEQ NOT IP",
        INVALIDr, INVALIDf,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_START_ERR, NULL, 0,
        START_BY_START_ERR_ENf,
        START_BY_START_ERRf,
        INVALIDm, "MMU START BY START",
        INVALIDr, INVALIDf,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_MMU_SER, NULL, 0,
        MEM_PAR_ERR_ENf,
        MEM_PAR_ERRf,
        INVALIDm, "MMU MEM PAR",
        INVALIDr, INVALIDf,
        MEM_FAIL_INT_STATr, NULL },
    { _SOC_PARITY_TYPE_BST, NULL, 0,
        INVALIDf,
        BST_THDI_INTf,
        INVALIDm, NULL, 
        INVALIDr, INVALIDf,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_BST, NULL, 0,
        INVALIDf,
        BST_THDO_INTf,
        INVALIDm, NULL, 
        INVALIDr, INVALIDf,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_BST, NULL, 0,
        INVALIDf,
        BST_CFAP_INTf,
        INVALIDm, NULL, 
        INVALIDr, INVALIDf,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_td2_ser_info_t _soc_td2_cport_ser_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        TXFIFO0_MEM_ERRf,
        TXFIFO0_MEM_ERRf,
        INVALIDm, "CDC RX FIFO MEMORY ECC",
        CPORT_ECC_CONTROLr, CDC_RXFIFO_MEM_ENf,
        CPORT_TXFIFO0_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        CDC_TXFIFO_MEM_ERRf,
        CDC_TXFIFO_MEM_ERRf,
        INVALIDm, "CDC TX FIFO MEMORY ECC",
        CPORT_ECC_CONTROLr, CDC_TXFIFO_MEM_ENf,
        CPORT_CDC_TXFIFO_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        TXFIFO0_MEM_ERRf,
        TXFIFO0_MEM_ERRf,
        INVALIDm, "TX FIFO ECC - XPORT CORE0 OR CPORT CORE",
        CPORT_ECC_CONTROLr, TXFIFO_MEM_ENf,
        CPORT_TXFIFO0_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_td2_ser_reg_t _soc_td2_pg_bod_status_reg[] = {
    { PGW_BOD_XLP0_ECC_STATUSr, "PGW BOD XLP0 ECC" },
    { PGW_BOD_XLP1_ECC_STATUSr, "PGW BOD XLP1 ECC" },
    { PGW_BOD_XLP2_ECC_STATUSr, "PGW BOD XLP2 ECC" },
    { PGW_BOD_XLP3_ECC_STATUSr, "PGW BOD XLP3 ECC" },
    { INVALIDr }
};

STATIC _soc_td2_ser_info_t _soc_td2_pg_ser_info[] = {
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0,
        PGW_OBM_PERR_INTRf,
        PGW_OBM_PERR_INTRf,
        INVALIDm, "PGW OBM",
        PGW_OBM0_ECC_ENABLEr, ECC_ENABLEf,
        PGW_OBM0_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_GENERIC, NULL, 0,
        PGW_BOD_PERR_INTRf,
        PGW_BOD_PERR_INTRf,
        INVALIDm, "PGW BOD",
        PGW_BOD_ECC_ENABLEr, BOD_ECC_ENABLEf,
        INVALIDr, _soc_td2_pg_bod_status_reg },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC1_MEM_ERRf,
        MIB_RSC1_MEM_ERRf,
        INVALIDm, "PGW MIB RX CTR Instance 1",
        INVALIDr, INVALIDf,
        PGW_MIB_RSC1_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC0_MEM_ERRf,
        MIB_RSC0_MEM_ERRf,
        INVALIDm, "PGW MIB RX CTR Instance 0",
        PGW_ECC_CONTROLr, MIB_RSC_MEM_ENf,
        PGW_MIB_RSC0_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC1_MEM_ERRf,
        MIB_RSC1_MEM_ERRf,
        INVALIDm, "PGW MIB TX CTR Instance 1",
        INVALIDr, INVALIDf,
        PGW_MIB_TSC1_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC0_MEM_ERRf,
        MIB_RSC0_MEM_ERRf,
        INVALIDm, "PGW MIB TX CTR Instance 0",
        PGW_ECC_CONTROLr, MIB_TSC_MEM_ENf,
        PGW_MIB_TSC0_ECC_STATUSr, NULL },
    { _SOC_PARITY_TYPE_CPORT, _soc_td2_cport_ser_info, 0,
        CPORT_ERRf,
        CPORT_ERRf,
        INVALIDm, "CPORT",
        CPORT_INTR_ENABLEr, INVALIDf, /* group enable */
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC const
_soc_td2_ser_route_block_t  _soc_td2_ser_route_blocks[] = {
    { 0x00000001, /* MMU_TO_CMIC_MEMFAIL_INTR */
      SOC_BLK_MMU, -1, MEM_FAIL_INT_ENr, MEM_FAIL_INT_STATr, INVALIDf, 
      _soc_td2_mmu_ser_info, 0 },
    { 0x00000002, /* X_EP1_TO_CMIC_PERR_INTR */
      SOC_BLK_EPIPE, 0, EGR_INTR_ENABLEr, INVALIDr, SER_FIFO_NON_EMPTYf,
      NULL, 0 },
    { 0x00000004, /* Y_EP1_TO_CMIC_PERR_INTR */
      SOC_BLK_EPIPE, 1, EGR_INTR_ENABLEr, INVALIDr, SER_FIFO_NON_EMPTYf,
      NULL, 0 },
    { 0x00000008, /* X_EP2_TO_CMIC_PERR_INTR */
      SOC_BLK_EPIPE, 0, EGR_INTR_ENABLEr, INVALIDr, SER_FIFO_NON_EMPTYf,
      NULL, 0 },
    { 0x00000010, /* Y_EP2_TO_CMIC_PERR_INTR */
      SOC_BLK_EPIPE, 1, EGR_INTR_ENABLEr, INVALIDr, SER_FIFO_NON_EMPTYf,
      NULL, 0 },
    { 0x00000020, /* X_IP0_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000040, /* Y_IP0_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000080, /* X_IP1_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000100, /* Y_IP1_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000200, /* X_IP2_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000400, /* Y_IP2_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00000800, /* X_IP3_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00001000, /* Y_IP3_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00002000, /* X_IP4_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00004000, /* Y_IP4_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00008000, /* X_IP5_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 0, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00010000, /* Y_IP5_TO_CMIC_PERR_INTR */
      SOC_BLK_IPIPE, 1, INVALIDr, INVALIDr, INVALIDf, NULL, 0 },
    { 0x00040000, /* PGW_0_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 0, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 0 },
    { 0x00080000, /* PGW_1_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 0, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 1 },
    { 0x00100000, /* PGW_2_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 0, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 2 },
    { 0x00200000, /* PGW_3_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 0, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 3 },
    { 0x00400000, /* PGW_4_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 1, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 4 },
    { 0x00800000, /* PGW_5_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 1, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 5 },
    { 0x01000000, /* PGW_6_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 1, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 6 },
    { 0x02000000, /* PGW_7_TO_CMIC_PERR_INTR */
      SOC_BLK_PGW_CL, 1, PGW_INTR_ENABLEr, PGW_INTR_STATUSr, INVALIDf,
      _soc_td2_pg_ser_info, 7 },
    { 0 } /* table terminator */
};

static soc_ser_functions_t _td2_ser_functions;

int
soc_trident2_pipe_select(int unit, int egress, int pipe)
{
    soc_reg_t reg;

    reg = egress ? EGR_SBS_CONTROLr : SBS_CONTROLr;
    return soc_reg_field32_modify(unit, reg, REG_PORT_ANY, PIPE_SELECTf, pipe);
}

STATIC int
_soc_trident2_ser_enable_info(int unit, int block_info_idx, int inst, int port,
                              soc_reg_t group_reg, uint64 *group_rval,
                              const _soc_td2_ser_info_t *info_list,
                              soc_mem_t mem, int enable);
STATIC int
_soc_trident2_ser_enable_cport(int unit, int inst, const _soc_td2_ser_info_t *info,
                               soc_mem_t mem, int enable)
{
    soc_reg_t port_reg;
    uint64 port_rval;
    int block_info_idx, port;

    port = -1;
    SOC_BLOCK_ITER(unit, block_info_idx, SOC_BLK_CPORT) {
        if (SOC_BLOCK_INFO(unit, block_info_idx).number == inst) {
            port = SOC_BLOCK_PORT(unit, block_info_idx);
            break;
        }
    }

    if (port < 0) {
        return SOC_E_NONE;
    }

    port_reg = info->enable_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg_get(unit, port_reg, port, 0, &port_rval));

    SOC_IF_ERROR_RETURN
        (_soc_trident2_ser_enable_info(unit, block_info_idx, inst, port,
                                       port_reg, &port_rval,
                                       info->info, mem, enable));

    SOC_IF_ERROR_RETURN(soc_reg_set(unit, port_reg, port, 0, port_rval));

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_ser_enable_lls(int unit, int enable)
{
    int i, f, fc;
    uint32 rval;
    soc_reg_t reg[][2] = {
        { ES_PIPE0_LLS_EN_COR_ERR_RPT_1r, ES_PIPE0_LLS_EN_COR_ERR_RPT_2r },
        { ES_PIPE1_LLS_EN_COR_ERR_RPT_1r, ES_PIPE1_LLS_EN_COR_ERR_RPT_2r }
    };
    soc_field_t _1b_err_rpt_1[] = {
        PORT_MEM_CONFIGf,
        PORT_PARENT_STATEf,
        PORT_HEADS_TAILSf,
        PORT_WERR_MAX_SCf,
        L0_MEM_CONFIGf,
        L0_PARENT_STATEf,
        L0_HEADS_TAILSf,
        L0_WERR_MAX_SCf,
        L0_ERRORf,
        L0_CHILD_STATE1f,
        L0_CHILD_WEIGHT_CFGf,
        L0_CHILD_WEIGHT_WORKINGf,
        L0_MIN_NEXTf,
        L0_WERR_NEXTf,
        L0_EF_NEXTf,
        L0_XOFFf,
        L0_PARENTf
    };
    soc_field_t _1b_err_rpt_2[] = {
        L1_MEM_CONFIGf,
        L1_PARENT_STATEf,
        L1_HEADS_TAILSf,
        L1_WERR_MAX_SCf,
        L1_ERRORf,
        L1_CHILD_STATE1f,
        L1_CHILD_WEIGHT_CFGf,
        L1_CHILD_WEIGHT_WORKINGf,
        L1_MIN_NEXTf,
        L1_WERR_NEXTf,
        L1_EF_NEXTf,
        L1_XOFFf,
        L1_PARENTf,
        L2_ERRORf,
        L2_CHILD_STATE1f,
        L2_CHILD_WEIGHT_CFGf,
        L2_CHILD_WEIGHT_WORKINGf,
        L2_MIN_NEXTf,
        L2_WERR_NEXTf,
        L2_XOFFf,
        L2_PARENTf
    };

    for (i = 0; i < 2; i++) {
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg[i][0], REG_PORT_ANY, 0, &rval));
        fc = COUNTOF(_1b_err_rpt_1);        
        for (f = 0; f < fc; f++) {
            soc_reg_field_set(unit, reg[i][0], &rval, _1b_err_rpt_1[f],
                              enable ? 1 : 0);
        }
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, reg[i][0], REG_PORT_ANY, 0, rval));
            
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg[i][1], REG_PORT_ANY, 0, &rval));
        fc = COUNTOF(_1b_err_rpt_2);        
        for (f = 0; f < fc; f++) {
            soc_reg_field_set(unit, reg[i][1], &rval, _1b_err_rpt_2[f],
                              enable ? 1 : 0);
        }
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, reg[i][1], REG_PORT_ANY, 0, rval));
            
    }
    
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_ser_enable_info(int unit, int block_info_idx, int inst, int port,
                              soc_reg_t group_reg, uint64 *group_rval,
                              const _soc_td2_ser_info_t *info_list,
                              soc_mem_t mem, int enable)
{
    const _soc_td2_ser_info_t *info;
    int info_index, rv, rv1;
    soc_reg_t reg;
    uint32 rval;
    uint64 rval64;

    rv = SOC_E_NOT_FOUND;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }

        if (mem != INVALIDm && info->mem != mem) {
            continue;
        }

        rv = SOC_E_NONE;

        /* Enable the info entry in the group register */
        if (info->group_reg_enable_field != INVALIDf) {
            soc_reg64_field32_set(unit, group_reg, group_rval,
                                  info->group_reg_enable_field, enable ? 1 : 0);
        }

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_PARITY:
        case _SOC_PARITY_TYPE_ECC:
            reg = info->enable_reg;
            if (!SOC_REG_IS_VALID(unit, reg)) {
                break;
            }
            if (SOC_REG_IS_64(unit, reg)) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_get(unit, reg, port, 0, &rval64));
                soc_reg64_field32_set(unit, reg, &rval64, info->enable_field,
                                      enable ? 1 : 0);
                SOC_IF_ERROR_RETURN
                    (soc_reg_set(unit, reg, port, 0, rval64));
            } else {
                SOC_IF_ERROR_RETURN
                    (soc_reg32_get(unit, reg, port, 0, &rval));
                soc_reg_field_set(unit, reg, &rval, info->enable_field,
                                  enable ? 1 : 0);
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, port, 0, rval));
            }
            soc_cm_debug(DK_VERBOSE+DK_SOCMEM, "SER enable for: %s\n", 
                         (info->mem == INVALIDm) ? info->mem_str : 
                         SOC_MEM_NAME(unit, info->mem));
            break;
        case _SOC_PARITY_TYPE_CPORT:
            /* One more level of enable tree structure */
            rv1 = _soc_trident2_ser_enable_cport(unit, inst, info, mem, enable);
            if (SOC_FAILURE(rv1) && rv1 != SOC_E_NOT_FOUND) {
                return rv;
            }
            soc_cm_debug(DK_VERBOSE+DK_SOCMEM, "SER enable for: %s\n", 
                         (info->mem == INVALIDm) ? info->mem_str : 
                         SOC_MEM_NAME(unit, info->mem));
            break;
        case _SOC_PARITY_TYPE_MMU_SER:
            rv1 = _soc_trident2_ser_enable_lls(unit, enable);
            if (SOC_FAILURE(rv1) && rv1 != SOC_E_NOT_FOUND) {
                return rv;
            }
            soc_cm_debug(DK_VERBOSE+DK_SOCMEM, "SER enable for: %s\n", 
                         (info->mem == INVALIDm) ? info->mem_str : 
                         SOC_MEM_NAME(unit, info->mem));
            break;
        case _SOC_PARITY_TYPE_GENERIC:
        case _SOC_PARITY_TYPE_START_ERR:
        case _SOC_PARITY_TYPE_BST:
            soc_cm_debug(DK_VERBOSE+DK_SOCMEM, "SER enable for: %s\n", 
                         (info->mem == INVALIDm) ? info->mem_str : 
                         SOC_MEM_NAME(unit, info->mem));
        default:
            break;
        } /* Handle different parity error reporting style */
        if (mem != INVALIDm) {
            break;
        }

    } /* Loop through each info entry in the route block */

    return rv;
}

STATIC int
_soc_trident2_ser_enable_all(int unit, int enable)
{
    int         rv, block_info_idx;
    int         port = REG_PORT_ANY;
    uint8       rbi, bcount;
    uint16      pcount;
    uint32      rval, cmic_bit, cmic_rval;
    uint64      rb_rval64;
    soc_reg_t   reg;
    soc_field_t field;
    const       _soc_td2_ser_route_block_t *rb;
    
    SOC_IF_ERROR_RETURN(READ_CMIC_CMC0_PCIE_IRQ_MASK2r(unit, &cmic_rval));

    /* Enable new fifo mechanism based SER stuff */
    for (bcount = 0; _soc_td2_ser_block_info[bcount].blocktype; bcount++) {
        for (pcount = 0;
             _soc_td2_ser_block_info[bcount].info[pcount].enable_reg != INVALIDr;
             pcount++) {
            reg = _soc_td2_ser_block_info[bcount].info[pcount].enable_reg;
            field = _soc_td2_ser_block_info[bcount].info[pcount].enable_field;
            /* NOTE: Do not use the field modify routine in the following as
                     some regs do not return the correct value due to which the 
                     modify routine skips the write */
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, reg, port, 0, &rval));
            soc_reg_field_set(unit, reg, &rval, field, enable ? 1 : 0);
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, port, 0, rval));
            switch (_soc_td2_ser_block_info[bcount].info[pcount].type) {
            case 0: soc_cm_debug(DK_VERBOSE+DK_SOCMEM, "SER enable for mem: %s\n", 
                    _soc_td2_ser_block_info[bcount].info[pcount].mem != INVALIDm ?
                    SOC_MEM_NAME(unit, _soc_td2_ser_block_info[bcount].info[pcount].mem) :
                    _soc_td2_ser_block_info[bcount].info[pcount].name_str); 
                    break;
            case 1: soc_cm_debug(DK_VERBOSE+DK_SOCMEM, "SER enable for reg: %s\n", 
                    _soc_td2_ser_block_info[bcount].info[pcount].reg != INVALIDr ?
                    SOC_REG_NAME(unit, _soc_td2_ser_block_info[bcount].info[pcount].reg) :
                    _soc_td2_ser_block_info[bcount].info[pcount].name_str); 
                    break;
            case 2: soc_cm_debug(DK_VERBOSE+DK_SOCMEM, "SER enable for bus: %s\n", 
                    _soc_td2_ser_block_info[bcount].info[pcount].name_str); 
                    break;
            default: break;
            }
        }

        /* Loop through each place-and-route block entry */
        for (rbi = 0; ; rbi++) {
            rb = &_soc_td2_ser_route_blocks[rbi];
            cmic_bit = rb->cmic_bit;
            if (cmic_bit == 0) {
                /* End of table */
                break;
            }
            if (rb->blocktype == _soc_td2_ser_block_info[bcount].blocktype) {
                /* New SER mechanism */
                cmic_rval |= cmic_bit;
                if (rb->enable_reg != INVALIDr) {
                    SOC_IF_ERROR_RETURN
                        (soc_reg_field32_modify(unit, rb->enable_reg,
                            REG_PORT_ANY, rb->enable_field, enable ? 1 : 0));
                }
            }
        }

        /* reset (toggle) fifo if applicable */
        if (_soc_td2_ser_block_info[bcount].fifo_reset_reg != INVALIDr) {
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     _soc_td2_ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 1));
            SOC_IF_ERROR_RETURN
                 (soc_reg_field32_modify(unit,
                     _soc_td2_ser_block_info[bcount].fifo_reset_reg,
                                         REG_PORT_ANY, FIFO_RESETf, 0));
        }
    }
    
    /* Enable 1B error reporting for some special items */
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IPARS_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, LPORT_TABLEf, enable ? 1 : 0));
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IPARS_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, SRC_TRUNKf, enable ? 1 : 0));
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IARB_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, CMIC_BUFFER_1BIT_ERROR_REPORTf, enable ? 1 : 0));
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, IARB_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, LEARN_FIFO_1BIT_ERROR_REPORTf, enable ? 1 : 0));
    SOC_IF_ERROR_RETURN
         (soc_reg_field32_modify(unit, ICFG_EN_COR_ERR_RPTr, 
                                 REG_PORT_ANY, PORT_TABLEf, enable ? 1 : 0));
    
    /* Loop through each place-and-route block entry to enable legacy style SER stuff */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_td2_ser_route_blocks[rbi];
        cmic_bit = rb->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        if (rb->info == NULL) {
            continue;
        }
        if (enable) {
            cmic_rval |= cmic_bit;
        }
        
        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                port = SOC_BLOCK_PORT(unit, block_info_idx);
                break;
            }
        }
        if (SOC_BLOCK_IN_LIST(SOC_REG_INFO(unit, rb->enable_reg).block, 
            SOC_BLK_PORT) && (port == REG_PORT_ANY)) {
                /* This port block is not configured */
                continue;
        }
        SOC_IF_ERROR_RETURN
            (soc_reg_get(unit, rb->enable_reg, port, 0, &rb_rval64));        
        rv = _soc_trident2_ser_enable_info(unit, block_info_idx, rb->id, port,
                                           rb->enable_reg, &rb_rval64,
                                           rb->info, INVALIDm, enable);
        if (rv == SOC_E_NOT_FOUND) {
            continue;
        } else if (SOC_FAILURE(rv)) {
            return rv;
        }

        /* Write per route block parity enable register */
        SOC_IF_ERROR_RETURN
            (soc_reg_set(unit, rb->enable_reg, port, 0, rb_rval64));
    }
    if (enable) {
        /* MMU enables */
        /* TD-3384 */
        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_ENf, 0); /* 1 */
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_PARITY_ENr(unit, 0x1FFFFE));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, INIT_MEMf, 0);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, INIT_MEMf, 1);
        sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Allow things to stabalize */
        /* Write CMIC enable register */
        (void)soc_cmicm_intr2_enable(unit, cmic_rval);
    } else {
        /* MMU disables */
        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_ENf, 0);
        /* TD-3384 */
        SOC_IF_ERROR_RETURN(WRITE_PARITY_ENr(unit, 0));
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        /* Write CMIC disable register */
        (void)soc_cmicm_intr2_disable(unit, cmic_rval);
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_clear_mmu_memory(int unit, soc_mem_t mem)
{
    int i, count;
    static soc_mem_t mmu_mems[] = {
        MMU_CFAP_BANK0m,
        MMU_CFAP_BANK1m,
        MMU_CFAP_BANK2m,
        MMU_CFAP_BANK3m,
        MMU_CFAP_BANK4m,
        MMU_CFAP_BANK5m,
        MMU_CFAP_BANK6m,
        MMU_CFAP_BANK7m,
        MMU_CFAP_BANK8m,
        MMU_CFAP_BANK9m,
        MMU_CFAP_BANK10m,
        MMU_CFAP_BANK11m,
        MMU_CFAP_BANK12m,
        MMU_CFAP_BANK13m,
        MMU_CFAP_BANK14m,
        MMU_CFAP_BANK15m,
        MMU_INTFI_XPIPE_FC_MAP_TBL2m,
        MMU_INTFI_YPIPE_FC_MAP_TBL2m,
        MMU_THDU_XPIPE_BST_PORTm,
        MMU_THDU_XPIPE_BST_QGROUPm,
        MMU_THDU_XPIPE_BST_QUEUEm,
        MMU_THDU_XPIPE_CONFIG_PORTm,
        MMU_THDU_XPIPE_CONFIG_QGROUPm,
        MMU_THDU_XPIPE_CONFIG_QUEUEm,
        MMU_THDU_XPIPE_COUNTER_PORTm,
        MMU_THDU_XPIPE_COUNTER_QGROUPm,
        MMU_THDU_XPIPE_COUNTER_QUEUEm,
        MMU_THDU_XPIPE_OFFSET_QGROUPm,
        MMU_THDU_XPIPE_OFFSET_QUEUEm,
        MMU_THDU_XPIPE_Q_TO_QGRP_MAPm,
        MMU_THDU_XPIPE_Q_TO_QGRP_MAP_0m,
        MMU_THDU_XPIPE_Q_TO_QGRP_MAP_1m,
        MMU_THDU_XPIPE_RESUME_PORTm,
        MMU_THDU_XPIPE_RESUME_PORT_0m,
        MMU_THDU_XPIPE_RESUME_PORT_1m,
        MMU_THDU_XPIPE_RESUME_QGROUPm,
        MMU_THDU_XPIPE_RESUME_QUEUEm,
        MMU_THDU_YPIPE_BST_PORTm,
        MMU_THDU_YPIPE_BST_QGROUPm,
        MMU_THDU_YPIPE_BST_QUEUEm,
        MMU_THDU_YPIPE_CONFIG_PORTm,
        MMU_THDU_YPIPE_CONFIG_QGROUPm,
        MMU_THDU_YPIPE_CONFIG_QUEUEm,
        MMU_THDU_YPIPE_COUNTER_PORTm,
        MMU_THDU_YPIPE_COUNTER_QGROUPm,
        MMU_THDU_YPIPE_COUNTER_QUEUEm,
        MMU_THDU_YPIPE_OFFSET_QGROUPm,
        MMU_THDU_YPIPE_OFFSET_QUEUEm,
        MMU_THDU_YPIPE_Q_TO_QGRP_MAPm,
        MMU_THDU_YPIPE_Q_TO_QGRP_MAP_0m,
        MMU_THDU_YPIPE_Q_TO_QGRP_MAP_1m,
        MMU_THDU_YPIPE_RESUME_PORTm,
        MMU_THDU_YPIPE_RESUME_PORT_0m,
        MMU_THDU_YPIPE_RESUME_PORT_1m,
        MMU_THDU_YPIPE_RESUME_QGROUPm,
        MMU_THDU_YPIPE_RESUME_QUEUEm
    };

    count = COUNTOF(mmu_mems);
    /* MMU mem clear to avoid SER issue */
    for (i = 0; i < count; i++) {
        if (mem != INVALIDm) {
            if (mem == mmu_mems[i]) {
                SOC_IF_ERROR_RETURN
                    (soc_mem_clear(unit, mmu_mems[i], COPYNO_ALL, TRUE));
                break;
            }
        } else {
            SOC_IF_ERROR_RETURN
                (soc_mem_clear(unit, mmu_mems[i], COPYNO_ALL, TRUE));
        }
    }
    return SOC_E_NONE;
}

int
_soc_trident2_mem_ser_control(int unit, soc_mem_t mem, int copyno,
                              int enable)
{
    if (enable) {
        SOC_IF_ERROR_RETURN(_soc_trident2_clear_mmu_memory(unit, mem));
    }
    if (soc_property_get(unit, spn_PARITY_ENABLE, TRUE)) {
        (void)_soc_trident2_ser_enable_all(unit, enable);
    }
    sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Allow things to stabalize */
    return SOC_E_NONE;
}

STATIC void
_soc_td2_mem_parity_info(int unit, int block_info_idx, int pipe,
                         soc_field_t field_enum, uint32 *minfo)
{
    *minfo = (SOC_BLOCK2SCH(unit, block_info_idx) << SOC_ERROR_BLK_BP)
        | ((pipe & 0xff) << SOC_ERROR_PIPE_BP)
        | (field_enum & SOC_ERROR_FIELD_ENUM_MASK);
}

STATIC int
_soc_trident2_ser_process_parity(int unit, int block_info_idx, int pipe, int port,
                                 const _soc_td2_ser_info_t *info,
                                 int schan, char *prefix_str, char *mem_str)
{
    _soc_td2_ser_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    uint32 rval, minfo;
    uint32 multiple, entry_idx, idx, has_error;
    char *mem_str_ptr;
    _soc_ser_correct_info_t spci;

    if (schan) {
        /* Some table does not have NACK register */
        return SOC_E_NONE;
    } else {
        if (info->intr_status_reg != INVALIDr) {
            reg_entry[0].reg = info->intr_status_reg;
            reg_entry[0].mem_str = NULL;
            reg_entry[1].reg = INVALIDr;
            reg_ptr = reg_entry;
        } else if (info->intr_status_reg_list != NULL) {
            reg_ptr = info->intr_status_reg_list;
        } else {
            return SOC_E_NONE;
        }
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = reg_ptr[idx].mem_str != NULL ?
            reg_ptr[idx].mem_str : mem_str;
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, port, 0, &rval));

        if (soc_reg_field_get(unit, reg, rval, PARITY_ERRf)) {
            has_error = TRUE;
            multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
            entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDXf);
            _soc_td2_mem_parity_info(unit, block_info_idx, pipe,
                                     info->group_reg_status_field, &minfo);
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                               SOC_SWITCH_EVENT_DATA_ERROR_PARITY, 
                               entry_idx, minfo);
            soc_cm_debug(DK_ERR,
                         "%s %s entry %d parity error\n",
                         prefix_str, mem_str_ptr, entry_idx);
            if (multiple) {
                soc_cm_debug(DK_ERR,
                             "%s %s has multiple parity errors\n",
                             prefix_str, mem_str_ptr);
            }
            if (idx == 0 && info->mem != INVALIDm) {
                sal_memset(&spci, 0, sizeof(spci));
                spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
                spci.reg = INVALIDr;
                spci.mem = info->mem;
                spci.blk_type = -1;
                spci.index = entry_idx;
                (void)soc_ser_correction(unit, &spci);
            }
        }

        /* Clear parity status */
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, reg, port, 0, 0));
    }

    if (!has_error) {
        soc_cm_debug(DK_ERR,
                     "%s %s parity hardware inconsistency\n",
                     prefix_str, mem_str);
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_ser_process_ecc(int unit, int block_info_idx, int pipe, int port,
                              const _soc_td2_ser_info_t *info,
                              int schan, char *prefix_str, char *mem_str)
{
    _soc_td2_ser_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    uint32 rval, minfo;
    uint32 multiple, double_bit, entry_idx, idx, has_error;
    char *mem_str_ptr;
    _soc_ser_correct_info_t spci;

    if (schan) {
        /* Some table does not have NACK register */
        return SOC_E_NONE;
    } else {
        if (info->intr_status_reg != INVALIDr) {
            reg_entry[0].reg = info->intr_status_reg;
            reg_entry[0].mem_str = NULL;
            reg_entry[1].reg = INVALIDr;
            reg_ptr = reg_entry;
        } else if (info->intr_status_reg_list != NULL) {
            reg_ptr = info->intr_status_reg_list;
        } else {
            return SOC_E_NONE;
        }
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = reg_ptr[idx].mem_str != NULL ?
            reg_ptr[idx].mem_str : mem_str;
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, port, 0, &rval));

        if (soc_reg_field_get(unit, reg, rval, ECC_ERRf)) {
            has_error = TRUE;
            multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
            double_bit = soc_reg_field_get(unit, reg, rval, DOUBLE_BIT_ERRf);
            entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDXf);
            _soc_td2_mem_parity_info(unit, block_info_idx, pipe,
                                     info->group_reg_status_field, &minfo);
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                               SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                               entry_idx, minfo);
            sal_memset(&spci, 0, sizeof(spci));
            if (double_bit) {
                spci.double_bit = 1;
                soc_cm_debug(DK_ERR,
                             "%s %s entry %d double-bit ECC error\n",
                             prefix_str, mem_str_ptr, entry_idx);
            } else {
                soc_cm_debug(DK_ERR,
                             "%s %s entry %d ECC error\n",
                             prefix_str, mem_str_ptr, entry_idx);
            }
            if (multiple) {
                soc_cm_debug(DK_ERR,
                             "%s %s has multiple ECC errors\n",
                             prefix_str, mem_str_ptr);
            }
            if (idx == 0 && info->mem != INVALIDm) {
                spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
                spci.reg = INVALIDr;
                spci.mem = info->mem;
                spci.blk_type = -1;
                spci.index = entry_idx;
                (void)soc_ser_correction(unit, &spci);
            }
        }

        /* Clear parity status */
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, reg, port, 0, 0));
    }

    if (!has_error) {
        soc_cm_debug(DK_ERR,
                     "%s %s ECC hardware inconsistency\n",
                     prefix_str, mem_str);
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_ser_process_mmu_err(int unit, int block_info_idx,
                                  const _soc_td2_ser_info_t *info,
                                  char *prefix_str)
{
    uint32 rval, err, addr, bidx;
    uint64 rval64;
    soc_reg_t reg = MMU_MEM_FAIL_ADDR_64r;
    
    SOC_IF_ERROR_RETURN(READ_MEM_SER_FIFO_STSr(unit, &rval));
    if (soc_reg_field_get(unit, MEM_SER_FIFO_STSr, rval, EMPTYf)) {
        soc_cm_debug(DK_ERR, "unit %d MMU SER interrupt with empty fifo !!\n",
                     unit);
        SOC_IF_ERROR_RETURN(READ_MEM_FAIL_INT_STATr(unit, &rval));
        soc_cm_debug(DK_ERR, "unit %d MMU ERR status: 0x%08x\n", unit, rval);
        SOC_IF_ERROR_RETURN(WRITE_MEM_FAIL_INT_STATr(unit, 0));
        return SOC_E_NONE;
    }
    do {
        SOC_IF_ERROR_RETURN(READ_MMU_MEM_FAIL_ADDR_64r(unit, &rval64));
        err = soc_reg64_field32_get(unit, reg, rval64, ERR_TYPEf);
        addr = soc_reg64_field32_get(unit, reg, rval64, EADDRf);
        bidx = soc_reg64_field32_get(unit, reg, rval64, BIDXf);
        soc_cm_debug(DK_ERR, "unit %d MMU ERR Type: %s, Addr: 0x%08x, module: %d\n",
                     unit, (err == 1) ? "1B error" : "2B error", addr, bidx);
        SOC_IF_ERROR_RETURN(READ_MEM_FAIL_INT_CTRr(unit, &rval));
        soc_cm_debug(DK_ERR, "unit %d MMU ERR ctr: %d\n", unit, rval);
        SOC_IF_ERROR_RETURN(READ_MEM_SER_FIFO_STSr(unit, &rval));
    } while (!soc_reg_field_get(unit, MEM_SER_FIFO_STSr, rval, EMPTYf));
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, info->intr_status_reg, REG_PORT_ANY,
                                info->group_reg_status_field, 0));
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_ser_process_start_err(int unit, int block_info_idx,
                                    const _soc_td2_ser_info_t *info,
                                    char *prefix_str)
{
    soc_info_t *si;
    uint64 rval64;
    uint32 pbmp_31_0, pbmp_63_32, pbmp_96_64, pbmp_116_97;
    soc_pbmp_t pbmp;
    uint32 minfo;
    int port, mmu_port, phy_port;

    si = &SOC_INFO(unit);

    /* mmu port 52-0 */
    SOC_IF_ERROR_RETURN(READ_START_BY_START_ERROR_0r(unit, &rval64));
    pbmp_31_0 = COMPILER_64_LO(rval64);
    pbmp_63_32 = COMPILER_64_HI(rval64);
    /* mmu port 116-64 */
    SOC_IF_ERROR_RETURN(READ_START_BY_START_ERROR_1r(unit, &rval64));
    pbmp_96_64 = COMPILER_64_LO(rval64);
    pbmp_116_97 = COMPILER_64_HI(rval64);
    SOC_PBMP_CLEAR(pbmp);
    SOC_PBMP_WORD_SET(pbmp, 0, pbmp_31_0);
    SOC_PBMP_WORD_SET(pbmp, 1, pbmp_63_32);
    SOC_PBMP_WORD_SET(pbmp, 2, pbmp_96_64);
    SOC_PBMP_WORD_SET(pbmp, 3, pbmp_116_97);

    SOC_PBMP_ITER(pbmp, mmu_port) {
        phy_port = si->port_m2p_mapping[mmu_port];
        port = si->port_p2l_mapping[phy_port];
        _soc_td2_mem_parity_info(unit, block_info_idx, 0,
                                 info->group_reg_status_field, &minfo);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                           SOC_SWITCH_EVENT_DATA_ERROR_UNSPECIFIED, 0,
                           minfo);
        soc_cm_debug(DK_ERR, "%s port %d start error detected\n", prefix_str,
                     port);
    }

    /* Clear parity status */
    COMPILER_64_ZERO(rval64);
    SOC_IF_ERROR_RETURN(WRITE_START_BY_START_ERROR_0r(unit, rval64));
    SOC_IF_ERROR_RETURN(WRITE_START_BY_START_ERROR_1r(unit, rval64));

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_process_ser(int unit, int block_info_idx, int inst, int pipe, 
                          int port, soc_reg_t group_reg, uint64 group_rval,
                          const _soc_td2_ser_info_t *info_list,
                          char *prefix_str);
STATIC int
_soc_trident2_ser_process_cport(int unit, int inst, int pipe,
                                const _soc_td2_ser_info_t *info)
{
    soc_reg_t port_reg;
    uint64 port_rval;
    int block_info_idx, port;
    char prefix_str[24];

    if (info->intr_status_reg == INVALIDr) {
        return SOC_E_NONE;
    }

    port = -1;
    SOC_BLOCK_ITER(unit, block_info_idx, SOC_BLK_CPORT) {
        if (SOC_BLOCK_INFO(unit, block_info_idx).number == inst) {
            port = SOC_BLOCK_PORT(unit, block_info_idx);
            break;
        }
    }
    if (port < 0) {
        return SOC_E_NONE;
    }

    port_reg = info->intr_status_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg_get(unit, port_reg, port, 0, &port_rval));
    if (COMPILER_64_IS_ZERO(port_rval)) {
        return SOC_E_NONE;
    }

    sal_sprintf(prefix_str, "unit %d CPORT%d", unit, inst);
    SOC_IF_ERROR_RETURN
        (_soc_trident2_process_ser(unit, block_info_idx, inst, pipe, port,
                                   port_reg, port_rval, info->info, prefix_str));

    return SOC_E_NONE;
}

STATIC _soc_td2_bst_hw_cb td2_bst_cb;

STATIC int
_soc_td2_process_mmu_bst(int unit)
{
    int rv = SOC_E_NONE;
    if (td2_bst_cb) {
        rv = td2_bst_cb(unit);
    }
    return rv;
}

int soc_td2_set_bst_callback(int unit, _soc_td2_bst_hw_cb cb)
{
    td2_bst_cb = cb;
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_process_ser(int unit, int block_info_idx, int inst, int pipe,
                          int port, soc_reg_t group_reg, uint64 group_rval,
                          const _soc_td2_ser_info_t *info_list,
                          char *prefix_str)
{
    const _soc_td2_ser_info_t *info;
    int info_index;
    char *mem_str;
    uint32 minfo;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }

        /* Check status for the info entry in the group register */
        if (!soc_reg64_field32_get(unit, group_reg, group_rval,
                                   info->group_reg_status_field)) {
            continue;
        }

        if (info->mem_str) {
            mem_str = info->mem_str;
        } else if (info->mem != INVALIDm) {
            mem_str = SOC_MEM_NAME(unit, info->mem);
        } else {
            mem_str = SOC_FIELD_NAME(unit, info->group_reg_status_field);
        }

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_GENERIC:
            _soc_td2_mem_parity_info(unit, block_info_idx, 0,
                                     info->group_reg_status_field, &minfo);
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                               SOC_SWITCH_EVENT_DATA_ERROR_PARITY, 0,
                               minfo);
            soc_cm_debug(DK_ERR, "%s %s asserted\n", prefix_str, mem_str);
            break;
        case _SOC_PARITY_TYPE_PARITY:
            /* PARITY_ERRf, MULTIPLE_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_trident2_ser_process_parity(unit, block_info_idx,
                                                  pipe, port, info, FALSE,
                                                  prefix_str, mem_str));
            break;
        case _SOC_PARITY_TYPE_ECC:
            /* ECC_ERRf, MULTIPLE_ERRf, DOUBLE_BIT_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_trident2_ser_process_ecc(unit, block_info_idx, pipe,
                                               port, info, FALSE,
                                               prefix_str, mem_str));
            break;
        case _SOC_PARITY_TYPE_CPORT:
            /* One more level of report tree structure */
            SOC_IF_ERROR_RETURN
                (_soc_trident2_ser_process_cport(unit, inst, pipe, info));
            break;
        case _SOC_PARITY_TYPE_START_ERR:
            SOC_IF_ERROR_RETURN
                (_soc_trident2_ser_process_start_err(unit, block_info_idx,
                                                     info, prefix_str));
            break;
        case _SOC_PARITY_TYPE_MMU_SER:
            SOC_IF_ERROR_RETURN
                (_soc_trident2_ser_process_mmu_err(unit, block_info_idx,
                                                   info, prefix_str));
            break;
        case _SOC_PARITY_TYPE_BST:
            SOC_IF_ERROR_RETURN(_soc_td2_process_mmu_bst(unit));
            break;
        default:
            break;
        } /* Handle different parity error reporting style */
    } /* Loop through each info entry in the list */

    return SOC_E_NONE;
}

STATIC char *_soc_td2_ser_hwmem_base_info[] = {
    "CMIC PKT BUFFER - In Iarb",
    "CPU PKT BUFFER - In Iarb",
    "Invalid value",
    "EINITBUF_PACKET_BUFFER - In Iarb",
    "INGRESS PACKET BUFFER - In Ipars",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "EP MPB DATA - In El3",
    "EP INITBUF - In Ehcpm",
    "CM DATA BUFFER - In Edatabuf",
    "XLP0 DATA BUFFER - In Edatabuf",
    "XLP1 DATA BUFFER - In Edatabuf",
    "XLP2 DATA BUFFER - In Edatabuf",
    "XLP3 DATA BUFFER - In Edatabuf",
    "XLP4 DATA BUFFER - In Edatabuf",
    "XLP5 DATA BUFFER - In Edatabuf",
    "XLP6 DATA BUFFER - In Edatabuf",
    "XLP7 DATA BUFFER - In Edatabuf",
    "XLP8 DATA BUFFER - In Edatabuf",
    "XLP9 DATA BUFFER - In Edatabuf",
    "XLP10 DATA BUFFER - In Edatabuf",
    "XLP11 DATA BUFFER - In Edatabuf",
    "XLP12 DATA BUFFER - In Edatabuf",
    "XLP13 DATA BUFFER - In Edatabuf",
    "XLP14 DATA BUFFER - In Edatabuf",
    "XLP15 DATA BUFFER - In Edatabuf",
    "CLP0 DATA BUFFER - In Edatabuf",
    "CLP1 DATA BUFFER - In Edatabuf",
    "CLP2 DATA BUFFER - In Edatabuf",
    "CLP3 DATA BUFFER - In Edatabuf",
    "XLP RESI0 DATA BUFFER - In Edatabuf",
    "XLP RESI1 DATA BUFFER - In Edatabuf",
    "XLP RESI2 DATA BUFFER - In Edatabuf",
    "XLP RESI3 DATA BUFFER - In Edatabuf",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "XLP0 EDB CTRL BUFFER - In Edatabuf",
    "XLP1 EDB CTRL BUFFER - In Edatabuf",
    "XLP2 EDB CTRL BUFFER - In Edatabuf",
    "XLP3 EDB CTRL BUFFER - In Edatabuf",
    "XLP4 EDB CTRL BUFFER - In Edatabuf",
    "XLP5 EDB CTRL BUFFER - In Edatabuf",
    "XLP6 EDB CTRL BUFFER - In Edatabuf",
    "XLP7 EDB CTRL BUFFER - In Edatabuf",
    "XLP8 EDB CTRL BUFFER - In Edatabuf",
    "XLP9 EDB CTRL BUFFER - In Edatabuf",
    "XLP10 EDB CTRL BUFFER - In Edatabuf",
    "XLP11 EDB CTRL BUFFER - In Edatabuf",
    "XLP12 EDB CTRL BUFFER - In Edatabuf",
    "XLP13 EDB CTRL BUFFER - In Edatabuf",
    "XLP14 EDB CTRL BUFFER - In Edatabuf",
    "XLP15 EDB CTRL BUFFER - In Edatabuf",
    "CLP0 EDB CTRL BUFFER - In Edatabuf",
    "CLP1 EDB CTRL BUFFER - In Edatabuf",
    "CLP2 EDB CTRL BUFFER - In Edatabuf",
    "CLP3 EDB CTRL BUFFER - In Edatabuf",
    "LEARN FIFO - In IARB",
    "EGR VLAN BUS",
    "EGR HCPM BUS",
    "EGR PMOD BUS",
    "EGR FPPARS BUS",
    "EFP BUS",
    "IVP BUS",
    "ICFG BUS",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "Invalid value",
    "IPARS BUS",
    "IVXLT BUS",
    "IMPLS BUS",
    "IL2L3 BUS",
    "Invalid value",
    "IFP BUS",
    "IRSEL1 BUS",
    "ISW1 BUS",
    "IRSEL2 BUS"
};

#define _SOC_TD2_SER_REG 1
#define _SOC_TD2_SER_MEM 0

STATIC void
_soc_trident2_print_ser_fifo_details(int unit, uint8 regmem, soc_block_t blk, 
                                     uint32 sblk, int pipe, uint32 address, 
                                     uint32 stage, uint32 base, uint32 index, 
                                     uint32 hwmbase, uint32 type, uint8 drop, 
                                     uint8 non_sbus)
{
    if (soc_cm_debug_check(DK_ERR)) {
        switch (type) {
        case 0: soc_cm_debug(DK_ERR, "Error in: SOP cell.\n"); break;
        case 1: soc_cm_debug(DK_ERR, "Error in: MOP cell.\n"); break;
        case 2: soc_cm_debug(DK_ERR, "Error in: EOP cell.\n"); break;
        case 3: soc_cm_debug(DK_ERR, "Error in: SBUS transaction.\n"); break;
        case 4: soc_cm_debug(DK_ERR, "Error in: miscellaneous transaction.\n"); break;
        default: soc_cm_debug(DK_ERR, "Invalid error reported !!\n");
        }
        soc_cm_debug(DK_ERR, "Blk: %d, Pipe: %d, Address: 0x%08x, base: 0x%x, stage: %d, index: %d\n", 
                     sblk, pipe, address, base, stage, index);
        if (regmem == _SOC_TD2_SER_MEM) {
            if (hwmbase >= 0x80) {
                hwmbase -= 0x38; /* handle the gap */
            }
            if (non_sbus) {
                soc_cm_debug(DK_ERR, "Mem hwbase: 0x%x [%s]\n", hwmbase,
                             (hwmbase < 0x60) ? _soc_td2_ser_hwmem_base_info[hwmbase] : "--");
            }
        }
        if (drop) {
            soc_cm_debug(DK_ERR, "SER caused packet drop.\n");
        }
    }
}

STATIC int
_soc_trident2_process_ser_fifo(int unit, soc_block_t blk, int pipe, char *prefix_str)
{
    int i, rv;
    uint8 bidx;
    soc_mem_t mem;
    char blk_str[10];
    int *acc_type_ptr;
    soc_reg_t reg = INVALIDr;
    _soc_ser_correct_info_t spci;
    static int acc_type1[] = { 3, 2, 6, 0, -1 };
    static int acc_type0[] = { 1, 3, 6, 4, 0, -1 };
    uint32 reg_val, mask, entry[SOC_MAX_MEM_WORDS];
    uint32 stage = 0, addrbase = 0, index = 0, hwmbase = 0, type = 0;
    uint32 sblk = 0, regmem = 0, non_sbus = 0, drop = 0, ecc_parity = 0, address = 0;


    switch (blk) {
    case SOC_BLK_IPIPE:
        mem = pipe ? ING_SER_FIFO_Ym : ING_SER_FIFO_Xm;
        mask = 0x0001FFE0; /* All IP bits */
        sal_sprintf(blk_str, "IPIPE");
        break;
    case SOC_BLK_EPIPE:
        mem = pipe ? EGR_SER_FIFO_Ym : EGR_SER_FIFO_Xm;
        mask = 0x00000001; /* SER_FIFO_NON_EMPTYf */
        reg = EGR_INTR_STATUSr;
        sal_sprintf(blk_str, "EPIPE");
        break;
    default: return SOC_E_PARAM;
    }

    do {
        SOC_IF_ERROR_RETURN
            (soc_mem_pop(unit, mem, MEM_BLOCK_ANY, entry));
        /* process entry */
        if (soc_mem_field32_get(unit, mem, entry, VALIDf)) {
            ecc_parity = soc_mem_field32_get(unit, mem, entry, ECC_PARITYf);
            regmem = soc_mem_field32_get(unit, mem, entry, MEM_TYPEf);
            address = soc_mem_field32_get(unit, mem, entry, ADDRESSf);
            stage = soc_mem_field32_get(unit, mem, entry, PIPE_STAGEf);
            type = soc_mem_field32_get(unit, mem, entry, INSTRUCTION_TYPEf);
            drop = soc_mem_field32_get(unit, mem, entry, DROPf);
            SOC_BLOCK_ITER(unit, bidx, blk) {
                sblk = SOC_BLOCK2SCH(unit, bidx);
                break;
            }
            soc_cm_debug(DK_ERR, "%s\n", prefix_str);
            if (soc_mem_field32_get(unit, mem, entry, MULTIPLEf)) {
                soc_cm_debug(DK_ERR, "Multiple: ");
            }
            regmem == _SOC_TD2_SER_REG ? 
                      soc_cm_debug(DK_ERR, "Reg: ") : soc_cm_debug(DK_ERR, "Mem: ");
            spci.double_bit = 0;
            switch (ecc_parity) {
            case 0: soc_cm_debug(DK_ERR, "Parity error..\n"); 
                break;
            case 1: soc_cm_debug(DK_ERR, "Corrected single bit ECC error..\n"); 
                break;
            case 2: soc_cm_debug(DK_ERR, "Double or Multiple bit ECC error..\n"); 
                spci.double_bit = 1;
                break;
            default: soc_cm_debug(DK_ERR, "Invalid SER issue !!\n");
            return SOC_E_INTERNAL;
            }
            if (regmem == _SOC_TD2_SER_MEM) {
                /* process mem */
                non_sbus = soc_mem_field32_get(unit, mem, entry, NON_SBUSf);
                addrbase = soc_mem_field32_get(unit, mem, entry, MEMBASEf);
                index = soc_mem_field32_get(unit, mem, entry, MEMINDEXf);
                hwmbase = soc_mem_field32_get(unit, mem, entry, HWMEMBASEf);
                if (non_sbus == 0) {
                    acc_type_ptr = pipe ? acc_type1 : acc_type0;
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                       ecc_parity == 0 ? 
                                       SOC_SWITCH_EVENT_DATA_ERROR_PARITY :
                                       SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                                       sblk | (pipe << SOC_SER_ERROR_PIPE_BP) |
                                       SOC_SER_ERROR_DATA_BLK_ADDR_SET, address);
                    _soc_trident2_print_ser_fifo_details(unit, 0, blk, sblk, pipe, address, 
                                                         stage, addrbase, index, hwmbase,
                                                         type, drop, non_sbus);
                    sal_memset(&spci, 0, sizeof(spci));
                    spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_UNKNOWN;
                    spci.reg = INVALIDr;
                    spci.mem = INVALIDm;
                    spci.pipe_num = pipe;
                    spci.blk_type = blk;
                    spci.sblk = sblk;
                    spci.addr = address - index;
                    spci.index = index;
                    spci.stage = stage;
                    for (i = 0; acc_type_ptr[i] != -1; i++) {
                        spci.acc_type = acc_type_ptr[i];
                        rv = soc_ser_correction(unit, &spci);
                        if (SOC_FAILURE(rv)) {
                            if (rv == SOC_E_NOT_FOUND) {
                                continue;
                            }
                            return rv;
                        }
                        break;
                    }
                } else {
                    soc_cm_debug(DK_ERR, "%s SER mem address un-accessable !!\n", blk_str);
                    _soc_trident2_print_ser_fifo_details(unit, 0, blk, sblk, pipe, address, 
                                                         stage, addrbase, index, hwmbase,
                                                         type, drop, non_sbus);
                }
            } else {
                /* process reg */
                non_sbus = soc_mem_field32_get(unit, mem, entry, NON_SBUSf);
                addrbase = soc_mem_field32_get(unit, mem, entry, REGBASEf);
                index = soc_mem_field32_get(unit, mem, entry, REGINDEXf);
                if (non_sbus == 0) {
                    acc_type_ptr = pipe ? acc_type1 : acc_type0;
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                       ecc_parity == 0 ? 
                                       SOC_SWITCH_EVENT_DATA_ERROR_PARITY :
                                       SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                                       sblk | (pipe << SOC_SER_ERROR_PIPE_BP) |
                                       SOC_SER_ERROR_DATA_BLK_ADDR_SET, address);
                    _soc_trident2_print_ser_fifo_details(unit, 1, blk, sblk, pipe, address, 
                                                         stage, addrbase, index, 0, type, 
                                                         drop, non_sbus);
                    sal_memset(&spci, 0, sizeof(spci));
                    spci.flags = SOC_SER_SRC_REG | SOC_SER_REG_MEM_UNKNOWN;
                    spci.reg = INVALIDr;
                    spci.mem = INVALIDm;
                    spci.blk_type = blk;
                    spci.sblk = sblk;
                    spci.addr = address;
                    spci.index = index;
                    spci.stage = stage;
                    for (i = 0; acc_type_ptr[i] != -1; i++) {
                        spci.acc_type = acc_type_ptr[i];
                        rv = soc_ser_correction(unit, &spci);
                        if (SOC_FAILURE(rv)) {
                            if (rv == SOC_E_NOT_FOUND) {
                                continue;
                            }
                            return rv;
                        }
                        break;
                    }
                } else {
                    soc_cm_debug(DK_ERR, "%s SER reg address un-accessable !!\n", blk_str);
                    _soc_trident2_print_ser_fifo_details(unit, 0, blk, sblk, pipe, address, 
                                                         stage, addrbase, index, hwmbase,
                                                         type, drop, non_sbus);
                }
            }
        } else {
            soc_cm_debug(DK_ERR, "unit %d Got invalid mem pop from %s !!\n",
                         unit, SOC_MEM_NAME(unit, mem));
        }
        /* check if any more pending */
        if (reg == INVALIDr) {
            SOC_IF_ERROR_RETURN
                (READ_CMIC_CMC0_IRQ_STAT2r(unit, &reg_val));
        } else {
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &reg_val));
        }
    } while (reg_val & mask);
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_ser_process_all(int unit)
{
    uint8      rbi;
    int        port = REG_PORT_ANY;
    uint32     cmic_rval, cmic_bit;
    uint64     rb_enable64, rb_rval64, tmp64;
    const      _soc_td2_ser_route_block_t *rb;
    char       prefix_str[10];
    int        block_info_idx;
    soc_stat_t *stat = SOC_STAT(unit);

    sal_sprintf(prefix_str, "Unit: %d \n", unit);

    /* Read CMIC parity status register */
    SOC_IF_ERROR_RETURN
        (READ_CMIC_CMC0_IRQ_STAT2r(unit, &cmic_rval));
    if (cmic_rval == 0) {
        return SOC_E_NONE;
    }
    /* Loop through each place-and-route block entry */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_td2_ser_route_blocks[rbi];
        cmic_bit = rb->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        if (!(cmic_rval & cmic_bit)) {
            /* No interrupt bit asserted for the route block */
            continue;
        }
        if (rb->blocktype == SOC_BLK_IPIPE || rb->blocktype == SOC_BLK_EPIPE) {
            /* New fifo style processing */
            (void)_soc_trident2_process_ser_fifo(unit, rb->blocktype, rb->pipe, prefix_str);
            stat->ser_err_fifo++;
        } else {
            /* Legacy processing */
            SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
                if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                    port = SOC_BLOCK_PORT(unit, block_info_idx);
                    break;
                }
            }
            if (SOC_BLOCK_IN_LIST(SOC_REG_INFO(unit, rb->enable_reg).block, 
                SOC_BLK_PORT) && (port == REG_PORT_ANY)) {
                    /* This port block is not configured */
                    soc_cm_debug(DK_ERR, "unit %d SER error on disabled port block %d !!\n",
                                 unit, block_info_idx);
                    sal_usleep(SAL_BOOT_QUICKTURN ? 10000000 : 1000000); /* Don't reenable too soon */
                    continue;
            }
            /* Read per route block parity status register */
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, rb->status_reg, port, 0, &rb_rval64));
            if (COMPILER_64_IS_ZERO(rb_rval64)) {
                continue;
            }
            SOC_IF_ERROR_RETURN
                (_soc_trident2_process_ser(unit, block_info_idx, rb->id, rb->pipe,
                                           port, rb->status_reg, rb_rval64,
                                           rb->info, prefix_str));
            
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, rb->enable_reg, port, 0, &rb_enable64));
            COMPILER_64_SET(tmp64, COMPILER_64_HI(rb_rval64), COMPILER_64_LO(rb_rval64));
            COMPILER_64_NOT(tmp64);
            COMPILER_64_AND(rb_enable64, tmp64);
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, rb->enable_reg, port, 0, rb_enable64));
            COMPILER_64_OR(rb_enable64, rb_rval64);
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, rb->enable_reg, port, 0, rb_enable64));
            
            stat->ser_err_int++;
        }
    }
    return SOC_E_NONE;
}

void
soc_trident2_ser_error(void *unit_vp, void *d1, void *d2, void *d3,
                       void *d4)
{
    int unit = PTR_TO_INT(unit_vp);

    (void)_soc_trident2_ser_process_all(unit);
    sal_usleep(SAL_BOOT_QUICKTURN ? 10000000 : 10000000); /* Don't reenable too soon */
    if (d2 != NULL) {
        (void)soc_cmicm_intr2_enable(unit, PTR_TO_INT(d2));
    }
    /* soc_intr_enable(unit, IRQ_MEM_FAIL); */
}

/* SER processing for TCAMs */
static _soc_generic_ser_info_t _soc_td2_tcam_ser_info_template[] = {
    /* HW SER engine protection */
    { L3_DEFIPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 95}, {1, 95}, {96, 189}, {97, 189} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ},
    { L3_DEFIPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 95}, {1, 95}, {96, 189}, {97, 189} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y |
      _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ},
    { L3_DEFIP_PAIR_128m, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_8BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 95}, {96, 189}, {190, 285}, {286, 379} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ},
    { L3_DEFIP_PAIR_128m, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_8BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 95}, {96, 189}, {190, 285}, {286, 379} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y |
      _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ},
    { FP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 165}, {1, 165}, {166, 329}, {167, 329} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { FP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_1BIT,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 165}, {1, 165}, {166, 329}, {167, 329} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { EFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 237}, {1, 237}, {238, 473}, {239, 473} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { EFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 237}, {1, 237}, {238, 473}, {239, 473} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { VFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2, 
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { VFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2, 
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { ING_SNATm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { ING_SNATm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { L3_TUNNELm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 105}, {1, 105}, {106, 210}, {107, 210} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { L3_TUNNELm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { L2_USER_ENTRYm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { L2_USER_ENTRYm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { VLAN_SUBNETm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { VLAN_SUBNETm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { MY_STATION_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { MY_STATION_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { FP_UDF_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { FP_UDF_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { CPU_COS_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 140}, {1, 140}, {141, 280}, {142, 280} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { CPU_COS_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 140}, {1, 140}, {141, 280}, {142, 280} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { IP_MULTICAST_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 140}, {1, 140}, {141, 280}, {142, 280} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ},
    { IP_MULTICAST_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 140}, {1, 140}, {141, 280}, {142, 280} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},

    /* SW memscan SER engine protection */
    { FP_GLOBAL_MASK_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      -1, -1,
      { {0, 436}, {0, 0}, {0, 0}, {0, 0} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_SW_COMPARE | _SOC_SER_FLAG_OVERLAY},
    { FP_GLOBAL_MASK_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      -1, -1,
      { {0, 436}, {0, 0}, {0, 0}, {0, 0} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_SW_COMPARE | _SOC_SER_FLAG_OVERLAY |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { FP_GM_FIELDSm, INVALIDm, _SOC_SER_TYPE_PARITY,
      -1, -1,
      { {0, 330}, {0, 0}, {0, 0}, {0, 0} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_SW_COMPARE |
      _SOC_SER_FLAG_OVERLAY | _SOC_SER_FLAG_OVERLAY_CASE},
    { FP_GM_FIELDSm, INVALIDm, _SOC_SER_TYPE_PARITY,
      -1, -1,
      { {0, 330}, {0, 0}, {0, 0}, {0, 0} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_MULTI_PIPE | _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_SW_COMPARE |
      _SOC_SER_FLAG_OVERLAY | _SOC_SER_FLAG_OVERLAY_CASE |
      _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y},
    { INVALIDm },
};

static _soc_generic_ser_info_t *_soc_td2_tcam_ser_info[SOC_MAX_NUM_DEVICES];

STATIC int
_soc_trident2_tcam_ser_init(int unit)
{
    int alloc_size;

    /* First, make per-unit copy of the master TCAM list */
    alloc_size = sizeof(_soc_td2_tcam_ser_info_template);
    if (NULL == _soc_td2_tcam_ser_info[unit]) {
        if ((_soc_td2_tcam_ser_info[unit] =
             sal_alloc(alloc_size, "td2 tcam list")) == NULL) {
            return SOC_E_MEMORY;
        }
    }
    /* Make a fresh copy of the TCAM template info */
    sal_memcpy(_soc_td2_tcam_ser_info[unit],
               &(_soc_td2_tcam_ser_info_template),
               alloc_size);

    return soc_generic_ser_init(unit, _soc_td2_tcam_ser_info[unit]);
}

void
soc_trident2_ser_fail(int unit)

{
    soc_generic_ser_process_error(unit, _soc_td2_tcam_ser_info[unit],
                                  _SOC_PARITY_TYPE_SER);
}

#ifdef ALPM_ENABLE
int
soc_trident2_alpm_scrub(int unit)
{
    int ipv6;                   /* Iterate over ipv6 only flag. */
    int idx;                    /* Iteration index.             */
    int tmp_idx;                /* ipv4 entries iterator.       */
    int alloc_size;             /* Allocation size.             */
    int tbl_size;               /* HW table size.               */
    int rv = SOC_E_FAIL;        /* Operation return status.     */
    char *lpm_tbl_ptr = NULL;   /* Dma table pointer.           */
    int vrf, vrf_id, step_count;
    int idx_end, bkt_idx, bkt_ptr = 0, bkt_addr;
    int bank_num = 0, entry_num = 0, entry_count, bank_count;
    void *alpm_entry;
    uint32 rval;
    soc_mem_t alpm_mem;
    defip_entry_t *lpm_entry;   /* Hw entry buffer.             */
    defip_pair_128_entry_t *lpm_128_entry; /* Hw entry buffer.  */
    defip_alpm_ipv4_entry_t alpm_entry_v4;
    defip_alpm_ipv6_64_entry_t alpm_entry_v6_64;
    defip_alpm_ipv6_128_entry_t alpm_entry_v6_128;
    
    SOC_IF_ERROR_RETURN(READ_L3_DEFIP_RPF_CONTROLr(unit, &rval));
    if (0 == soc_reg_field_get(unit, L3_DEFIP_RPF_CONTROLr, rval, LPM_MODEf)) {
        return (SOC_E_NONE);
    }
        
    /* DMA the LPM table to software copy. Calculate table size. */
    tbl_size =  soc_mem_index_count(unit, L3_DEFIPm);
    if (!tbl_size) {
        return (SOC_E_NONE);
    }
    alloc_size = tbl_size * sizeof(defip_entry_t);

    /* Allocate memory buffer. */
    lpm_tbl_ptr = soc_cm_salloc(unit, alloc_size, "lpm scrub");
    if (lpm_tbl_ptr == NULL) {
        return (SOC_E_MEMORY);
    }

    /* Reset allocated buffer. */
    sal_memset(lpm_tbl_ptr, 0, alloc_size);

    /* Read table to the buffer. */
    if (soc_mem_read_range(unit, L3_DEFIPm, MEM_BLOCK_ANY,
                           soc_mem_index_min(unit, L3_DEFIPm),
                           soc_mem_index_max(unit, L3_DEFIPm), lpm_tbl_ptr) < 0) {
        soc_cm_sfree(unit, lpm_tbl_ptr);
        return (SOC_E_INTERNAL);
    }

    if (SOC_URPF_STATUS_GET(unit)) {
        tbl_size >>= 1;
    }

    idx_end = tbl_size;
    
    if (soc_reg_field_get(unit, L3_DEFIP_RPF_CONTROLr, rval, LOOKUP_MODEf)) {
        /* parallel search mode */
        if (SOC_URPF_STATUS_GET(unit)) {
            bank_count = 2;
        } else {
            bank_count = 4;
        }
    } else {
        bank_count = 4;
    }
    
    /* Walk all lpm entries */
    for (idx = 0; idx < idx_end; idx++) {
        /* Calculate entry offset */
        lpm_entry =
            soc_mem_table_idx_to_pointer(unit, L3_DEFIPm,
                                         defip_entry_t *, lpm_tbl_ptr, idx);
       
        ipv6 = soc_mem_field32_get(unit, L3_DEFIPm, lpm_entry, MODE0f);

        /* Each LPM index has two IPv4 entries */
        for (tmp_idx = 0; tmp_idx < 2; tmp_idx++) {
            
            if (tmp_idx) {  /* If index == 1*/
                if (ipv6) {
                    /* IPv6 LPM index has only one entry, skip processing */ 
                    continue;
                } else {   
                    /* Copy upper half of lpm entry to lower half */
                    soc_alpm_lpm_ip4entry1_to_0(unit, lpm_entry, lpm_entry, TRUE);
                }
            }
    
            /* Make sure entry is valid. */
            if (!soc_L3_DEFIPm_field32_get(unit, lpm_entry, VALID0f)) {
                continue;
            }
            
            /* Get VRF */
            if (SOC_FAILURE(soc_alpm_lpm_vrf_get
                            (unit, lpm_entry, &vrf_id, &vrf))) {
                goto free_lpm_table;
            }

            /* VRF_OVERRIDE (Global High) entries, prefix resides in TCAM */
            if (vrf_id == SOC_L3_VRF_OVERRIDE) {
                continue;
            }
                
            if (ipv6 && tmp_idx) {
                bkt_ptr++;
            } else {
                bkt_ptr = soc_mem_field32_get(unit, L3_DEFIPm, lpm_entry, 
                                              ALG_BKT_PTR0f);
            }

            if (ipv6) {
                /* IPv6 */
                alpm_mem    = L3_DEFIP_ALPM_IPV6_64m;
                alpm_entry  = &alpm_entry_v6_64;
                entry_count = 4;
            } else {
                /* IPv4 */
                alpm_mem    = L3_DEFIP_ALPM_IPV4m;
                alpm_entry  = &alpm_entry_v4;
                entry_count = 6;
            }

            entry_num = 0;
            bank_num = 0;

            /* Get the bucket pointer from lpm entry */
            for (bkt_idx = 0; bkt_idx < (entry_count * bank_count); bkt_idx++) {
                /* Calculate bucket memory address */
                /* Increment so next bucket address can be calculated */
                bkt_addr = (entry_num << 16) | (bkt_ptr << 2) | 
                           (bank_num & 0x3);
                entry_num++; 
                if (entry_num == entry_count) {
                    entry_num = 0;
                    bank_num++;
                    if (bank_num == bank_count) {
                        bank_num = 0;
                    }
                }

                /* Read entry from bucket memory */
                if (SOC_FAILURE(soc_mem_read(unit, alpm_mem, MEM_BLOCK_ANY,
                                             bkt_addr, alpm_entry))) {
                    goto free_lpm_table;
                }
                if (SOC_URPF_STATUS_GET(unit)) {
                    /* Read the other copy */
                    if (SOC_FAILURE(soc_mem_read(unit, alpm_mem, MEM_BLOCK_ANY,
                                                 _soc_alpm_rpf_entry(unit, bkt_addr),
                                                 alpm_entry))) {
                        goto free_lpm_table;
                    }
                }
            } /* End of bucket walk loop*/
        } /* End of lpm entry upper/lower half traversal */
    } /* End of lpm table traversal */
    soc_cm_sfree(unit, lpm_tbl_ptr);

    /* DMA the LPM_PAIR_128 table to software copy. Calculate table size. */
    tbl_size =  soc_mem_index_count(unit, L3_DEFIP_PAIR_128m);
    if (!tbl_size) {
        return (SOC_E_NONE);
    }
    alloc_size = tbl_size * sizeof(defip_entry_t);

    /* Allocate memory buffer. */
    lpm_tbl_ptr = soc_cm_salloc(unit, alloc_size, "lpm scrub");
    if (lpm_tbl_ptr == NULL) {
        return (SOC_E_MEMORY);
    }

    /* Reset allocated buffer. */
    sal_memset(lpm_tbl_ptr, 0, alloc_size);

    /* Read table to the buffer. */
    if (soc_mem_read_range(unit, L3_DEFIP_PAIR_128m, MEM_BLOCK_ANY,
                           soc_mem_index_min(unit, L3_DEFIP_PAIR_128m),
                           soc_mem_index_max(unit, L3_DEFIP_PAIR_128m), lpm_tbl_ptr) < 0) {
        soc_cm_sfree(unit, lpm_tbl_ptr);
        return (SOC_E_INTERNAL);
    }

    /* bkt_count = ALPM_IPV6_128_BKT_COUNT; ?? */
    
    if (SOC_URPF_STATUS_GET(unit)) {
        tbl_size >>= 1;
        /* bucket size halves for parallel search mode */
        if (soc_alpm_mode_get(unit)) {
            /* bkt_count >>= 1; ?? */
        }
    }

    idx_end = tbl_size;
    entry_count = 2;
    alpm_entry = &alpm_entry_v6_128;

    if (SOC_ALPM_V6_SCALE_CHECK(unit, 1)) {
        step_count = 2;
    } else {
        step_count = 1;
    }
    
    /* Walk all lpm_pair_128 entries */
    for (idx = 0; idx < idx_end; idx++) {
        /* Calculate entry ofset. */
        lpm_128_entry =
            soc_mem_table_idx_to_pointer(unit, L3_DEFIP_PAIR_128m,
                                         defip_pair_128_entry_t *, lpm_tbl_ptr, idx);

        /* Each lpm entry contains upto 24 IPV4 entries. Check all */           
        for (tmp_idx = 0; tmp_idx < step_count; tmp_idx++) {

            /* Make sure entry is valid. */
            if (!soc_mem_field32_get(unit, L3_DEFIP_PAIR_128m, lpm_128_entry, 
                                     VALID0_LWRf)) {
                continue;
            }

            /* Get VRF */
            if (SOC_FAILURE(soc_alpm_128_lpm_vrf_get
                            (unit, lpm_128_entry, &vrf_id, &vrf))) {
                goto free_lpm_table;
            }

            /* VRF_OVERRIDE (Global High) entries, prefix resides in TCAM */
            if (vrf_id == SOC_L3_VRF_OVERRIDE) {
                continue;
            }
            if (tmp_idx) {
                bkt_ptr++;
            } else {
                bkt_ptr = soc_mem_field32_get(unit, L3_DEFIP_PAIR_128m, lpm_128_entry, 
                                              ALG_BKT_PTRf);
            }    
                                          
            entry_num = 0;
            bank_num = 0;

            /* Get the bucket pointer from lpm entry */
            for (bkt_idx = 0; bkt_idx < (entry_count * bank_count); bkt_idx++) {
                /* Calculate bucket memory address */
                /* Increment so next bucket address can be calculated */
                bkt_addr = (entry_num << 16) | (bkt_ptr << 2) | 
                           (bank_num & 0x3);
                entry_num++; 
                if (entry_num == entry_count) {
                    entry_num = 0;
                    bank_num++;
                    if (bank_num == bank_count) {
                        bank_num = 0;
                    }
                }

                /* Read entry from bucket memory */
                if (SOC_FAILURE(soc_mem_read(unit, L3_DEFIP_ALPM_IPV6_128m, 
                                MEM_BLOCK_ANY, bkt_addr, alpm_entry))) {
                    goto free_lpm_table;
                }
                if (SOC_URPF_STATUS_GET(unit)) {
                    /* Read the other copy */
                    if (SOC_FAILURE(soc_mem_read(unit, L3_DEFIP_ALPM_IPV6_128m, 
                                                 MEM_BLOCK_ANY,
                                                 _soc_alpm_rpf_entry(unit, bkt_addr),
                                                 alpm_entry))) {
                        goto free_lpm_table;
                    }
                }
            } /* End of bucket walk loop*/
        } /* End of lpm entry upper/lower half traversal */
    } /* End of lpm table traversal */

    rv = SOC_E_NONE;

free_lpm_table:
    soc_cm_sfree(unit, lpm_tbl_ptr);

    return (rv);
}
#endif /* ALPM_ENABLE */

int
soc_trident2_mem_config(int unit)
{
    soc_persist_t *sop;
    int l2_entries, cfg_l2_entries, shared_l2_banks;
    int l3_entries, cfg_l3_entries, shared_l3_banks;
    int alpm_enable;
    int num_ecmp_rh_flowset_entries;
    int num_ipv6_128b_entries = 0;
    int defip_config = 0;

    sop = SOC_PERSIST(unit);

    /*
     * bank 0-1 are dedicated L2 banks (16k entries per bank)
     * bank 6-9 are dedicated L3 banks (4k entries per bank)
     * bank 5-8 are shared banks (64k entres per bank)
     * These dedicated/shared banks can be configured to one of the following
     * mode:
     *     mode 0: 288k L2 (bank 0-5),  16k L3 (bank 6-9),   no ALPM (default)
     *     mode 1: 224k L2 (bank 0-4),  80k L3 (bank 5-9),   no ALPM
     *     mode 2: 160k L2 (bank 0-3), 144k L3 (bank 4-9),   no ALPM
     *     mode 3:  96k L2 (bank 0-2), 208k L3 (bank 3-9),   no ALPM
     *     mode 4:  32k L2 (bank 0-1),  16k L3 (bank 6-9), 128k ALPM (bank 2-5)
     */
    cfg_l2_entries = soc_property_get(unit, spn_L2_MEM_ENTRIES, -1);
    l2_entries = cfg_l2_entries == -1 ? 288 * 1024 : cfg_l2_entries;
    if (l2_entries <= 32 * 1024) { /* 32k dedicated L2 entries */
        l2_entries = 32 * 1024;
        shared_l2_banks = 0;
    } else if (l2_entries <= 288 * 1024) {
        l2_entries -= 32 * 1024;
        shared_l2_banks = (l2_entries + (64 * 1024 - 1)) / (64 * 1024);
        l2_entries = 32 * 1024 + shared_l2_banks * 64 * 1024;
    } else {
        soc_cm_print("The specified l2_mem_entries (%d) exceeds 288K\n",
                     cfg_l2_entries);
        return SOC_E_PARAM;
    }

    cfg_l3_entries = soc_property_get(unit, spn_L3_MEM_ENTRIES, -1);
    l3_entries = cfg_l3_entries == -1 ? 16384 : cfg_l3_entries;
    if (l3_entries <= 16 * 1024) { /* 16k dedicated L3 entries */
        l3_entries = 16 * 1024;
        shared_l3_banks = 0;
    } else if (l3_entries <= 208 * 1024) {
        l3_entries -= 16 * 1024;
        shared_l3_banks = (l3_entries + (64 * 1024 - 1)) / (64 * 1024);
        l3_entries = 16 * 1024 + shared_l3_banks * 64 * 1024;
    } else {
        soc_cm_print("The specified l3_mem_entries (%d) exceeds 208K\n",
                     cfg_l3_entries);
        return SOC_E_PARAM;
    }

    alpm_enable = soc_property_get(unit, spn_L3_ALPM_ENABLE, 0);

    if (alpm_enable) {
        if (shared_l2_banks + shared_l3_banks != 0) {
            soc_cm_print("Shared banks can not be used for L2 or L3 when "
                         "ALPM is enabled\n");
            return SOC_E_PARAM;
        }
    } else if (shared_l2_banks + shared_l3_banks > 4) {
        if (cfg_l2_entries == -1) {
            soc_cm_print("Default L2 size (294912) and the specified "
                         "l3_mem_entries (%d) require more than 4 shared "
                         "banks\n",
                         cfg_l3_entries);
        } else {
            soc_cm_print("The specified l2_mem_entries (%d) and "
                         "l3_mem_entries (%d) require more than 4 shared "
                         "banks\n",
                         cfg_l2_entries, cfg_l3_entries);
        }
        return SOC_E_PARAM;
    }

    /* Adjust table size to match L2_TABLE_HASH_CONTROL.MODE setting*/
    sop->memState[L2Xm].index_max = l2_entries - 1;
    sop->memState[L2_ENTRY_ONLYm].index_max = l2_entries - 1;
    sop->memState[L2_HITDA_ONLYm].index_max = l2_entries / 4 - 1;
    sop->memState[L2_HITDA_ONLY_Xm].index_max = l2_entries / 4 - 1;
    sop->memState[L2_HITDA_ONLY_Ym].index_max = l2_entries / 4 - 1;
    sop->memState[L2_HITSA_ONLYm].index_max = l2_entries / 4 - 1;
    sop->memState[L2_HITSA_ONLY_Xm].index_max = l2_entries / 4 - 1;
    sop->memState[L2_HITSA_ONLY_Ym].index_max = l2_entries / 4 - 1;
    sop->memState[L2_ENTRY_LPm].index_max = l2_entries / 4 - 1;

    /* Adjust table size to match L3_TABLE_HASH_CONTROL.MODE setting */
    sop->memState[L3_ENTRY_ONLYm].index_max = l3_entries - 1;
    sop->memState[L3_ENTRY_IPV4_UNICASTm].index_max = l3_entries - 1;
    sop->memState[L3_ENTRY_IPV4_MULTICASTm].index_max = l3_entries / 2 - 1;
    sop->memState[L3_ENTRY_IPV6_UNICASTm].index_max = l3_entries/ 2 - 1;
    sop->memState[L3_ENTRY_IPV6_MULTICASTm].index_max = l3_entries / 4 - 1;
    sop->memState[L3_ENTRY_HIT_ONLYm].index_max = l3_entries / 4 - 1;
    sop->memState[L3_ENTRY_HIT_ONLY_Xm].index_max = l3_entries / 4 - 1;
    sop->memState[L3_ENTRY_HIT_ONLY_Ym].index_max = l3_entries / 4 - 1;
    sop->memState[L3_ENTRY_LPm].index_max = l3_entries / 4 - 1;

    /* Adjust table size to match L2/L3_TABLE_HASH_CONTROL.MODE setting */
    if (!alpm_enable) {
        sop->memState[L3_DEFIP_ALPM_RAWm].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_IPV4m].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_IPV4_1m].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_IPV6_64m].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_IPV6_64_1m].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_IPV6_128m].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_HIT_ONLYm].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_HIT_ONLY_Xm].index_max = -1;
        sop->memState[L3_DEFIP_ALPM_HIT_ONLY_Ym].index_max = -1;
    }

    /* LAG and ECMP resilient hashing features share the same flow set table.
     * The table can be configured in one of 3 modes:
     * - dedicated to LAG resilient hashing,
     * - dedicated to ECMP resilient hashing,
     * - split evenly between LAG and ECMP resilient hashing.
     */
    num_ecmp_rh_flowset_entries = soc_property_get(unit,
            spn_ECMP_RESILIENT_HASH_SIZE, 32768);
    switch (num_ecmp_rh_flowset_entries) {
        case 0:
            sop->memState[RH_ECMP_FLOWSETm].index_max = -1;
            break;
        case 32768:
            sop->memState[RH_LAG_FLOWSETm].index_max /= 2;
            sop->memState[RH_ECMP_FLOWSETm].index_max /= 2;
            break;
        case 65536:
            sop->memState[RH_LAG_FLOWSETm].index_max = -1;
            break;
        default:
            return SOC_E_CONFIG;
    }

    SOC_CONTROL(unit)->l3_defip_max_tcams = _SOC_TD2_DEFIP_MAX_TCAMS;
    SOC_CONTROL(unit)->l3_defip_tcam_size = _SOC_TD2_DEFIP_TCAM_DEPTH; 

    if (soc_property_get(unit, "l3_defip_sizing", TRUE)) {
        if (!soc_property_get(unit, spn_L3_ALPM_ENABLE, 0)) {
            defip_config = soc_property_get(unit, spn_IPV6_LPM_128B_ENABLE, 1);

            num_ipv6_128b_entries = soc_property_get(unit, 
                                        spn_NUM_IPV6_LPM_128B_ENTRIES, 
                                        (defip_config ? 2048 : 0));  
            num_ipv6_128b_entries = num_ipv6_128b_entries + 
                                    (num_ipv6_128b_entries % 2);
            sop->memState[L3_DEFIP_PAIR_128m].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_ONLYm].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_DATA_ONLYm].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_HIT_ONLYm].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_HIT_ONLY_Xm].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_HIT_ONLY_Ym].index_max = 
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIPm].index_max = 
                                     (SOC_CONTROL(unit)->l3_defip_max_tcams * 
                                     SOC_CONTROL(unit)->l3_defip_tcam_size) - 
                                     (num_ipv6_128b_entries * 2) - 1;

            sop->memState[L3_DEFIP_ONLYm].index_max = 
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_DATA_ONLYm].index_max = 
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_HIT_ONLYm].index_max = 
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_HIT_ONLY_Xm].index_max = 
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_HIT_ONLY_Ym].index_max = 
                                          sop->memState[L3_DEFIPm].index_max;
            SOC_CONTROL(unit)->l3_defip_index_remap = num_ipv6_128b_entries;
            soc_l3_defip_indexes_init(unit); 
        } else {
            /* only for combined search mode for now */
            if ((soc_property_get(unit, spn_IPV6_LPM_128B_ENABLE, 0)) &&
               (soc_property_get(unit, spn_L3_ALPM_ENABLE, 0) == 2)) {
                    sop->memState[L3_DEFIP_PAIR_128m].index_max = 2047;
                    sop->memState[L3_DEFIPm].index_max = 4095;
                    sop->memState[L3_DEFIP_ONLYm].index_max = 4095;
                    sop->memState[L3_DEFIP_DATA_ONLYm].index_max = 4095;
                    sop->memState[L3_DEFIP_HIT_ONLYm].index_max = 4095;
                    sop->memState[L3_DEFIP_HIT_ONLY_Xm].index_max = 4095;
                    sop->memState[L3_DEFIP_HIT_ONLY_Ym].index_max = 4095;
                    SOC_CONTROL(unit)->l3_defip_index_remap = 4096;
            } else {
                sop->memState[L3_DEFIP_PAIR_128m].index_max = -1;
            }
        }
    }

    return SOC_E_NONE;
}

#define _TD2_INDEX_1K_ENTRIES  1023
#define _TD2_INDEX_2K_ENTRIES  2047
#define _TD2_OFFSET_2K_ENTRIES 2048
#define _TD2_INDEX_4K_ENTRIES  4095
#define _TD2_INDEX_6K_ENTRIES  6143
#define _TD2_OFFSET_6K_ENTRIES 6144

/* Map logical (always starts from 0 and contiguous) index to physical index 
   which can have a starting offset and/or holes.
   Input  : logical index
   Returns: physical index */
int
soc_trident2_l3_defip_index_map(int unit, soc_mem_t mem, int index)
{
    int wide = 0;

    /* don't remap for ALPM */
    if (SOC_CONTROL(unit)->l3_defip_index_remap == 0) {
        return index;
    }

    if (mem == L3_DEFIP_PAIR_128m ||
        mem == L3_DEFIP_PAIR_128_ONLYm ||
        mem == L3_DEFIP_PAIR_128_DATA_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLY_Xm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLY_Ym) {
        wide = 1;
    }

    if (soc_mem_index_count(unit, L3_DEFIP_ALPM_IPV6_128m)) {
        if (SOC_CONTROL(unit)->l3_defip_urpf) { /* URPF mode */
            if (wide == 0) {
                if (index > _TD2_INDEX_2K_ENTRIES) {
                    return index + SOC_CONTROL(unit)->l3_defip_index_remap;
                }
                return index + SOC_CONTROL(unit)->l3_defip_index_remap/2;
            } else {
                if (index > _TD2_INDEX_1K_ENTRIES) {
                    return index + SOC_CONTROL(unit)->l3_defip_index_remap/4;
                }
                return index;
            }
        }
        return (wide) ? index : index + SOC_CONTROL(unit)->l3_defip_index_remap;
    } 
    if (SOC_CONTROL(unit)->l3_defip_urpf) { /* URPF mode */
        return soc_l3_defip_urpf_index_map(unit, wide, index);
    }

    return soc_l3_defip_index_map(unit, wide, index);
}

/* Reverse map physical index to logical index.
   Input  : physical index
   Returns: logical index */
int
soc_trident2_l3_defip_index_remap(int unit, soc_mem_t mem, int index)
{
    int wide = 0;

    /* don't remap for ALPM */
    if (SOC_CONTROL(unit)->l3_defip_index_remap == 0) {
        return index;
    }

    if (mem == L3_DEFIP_PAIR_128m ||
        mem == L3_DEFIP_PAIR_128_ONLYm ||
        mem == L3_DEFIP_PAIR_128_DATA_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLY_Xm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLY_Ym) {
        wide = 1;
    }

    if (soc_mem_index_count(unit, L3_DEFIP_ALPM_IPV6_128m)) {
        if (SOC_CONTROL(unit)->l3_defip_urpf) { /* URPF mode */
            if (wide == 0) {
                if (index > _TD2_INDEX_6K_ENTRIES) {
                    return index - SOC_CONTROL(unit)->l3_defip_index_remap;
                }
                return index - SOC_CONTROL(unit)->l3_defip_index_remap/2;
            } else {
                if (index > _TD2_INDEX_1K_ENTRIES) {
                    return index - SOC_CONTROL(unit)->l3_defip_index_remap/4;
                }
                return index;
            }
        }
        return (wide) ? index : index - SOC_CONTROL(unit)->l3_defip_index_remap;
    } 
    if (SOC_CONTROL(unit)->l3_defip_urpf) { /* URPF mode */
        return soc_l3_defip_urpf_index_remap(unit, wide, index);
    }

    return soc_l3_defip_index_remap(unit, wide, index);
}

/* Given a physical index (always in terms of the narrow entry) 
   return the logical index and memory type */
int
soc_trident2_l3_defip_mem_index_get(int unit, int pindex, soc_mem_t *mem)
{
    return soc_l3_defip_index_mem_map(unit, pindex, mem);
}

void
_soc_trident2_alpm_bkt_view_set(int unit, int index, soc_mem_t view)
{
    return;
}

soc_mem_t
_soc_trident2_alpm_bkt_view_get(int unit, int index)
{
    return 0;
}

int
_soc_trident2_mem_sram_info_get(int unit, soc_mem_t mem, int index, 
                                _soc_ser_sram_info_t *sram_info)
{
    int i, base, entries_per_ram = 0, base_index, entries_per_bank, contiguous = 0;
    
    switch (mem) {
    case L2Xm:
        sram_info->disable_reg = L2_ENTRY_PARITY_CONTROLr;
        sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
        sram_info->force_field = FORCE_XOR_GENERATIONf;
        if (index < SOC_TD2_NUM_ENTRIES_L2_BANK) {
            sram_info->force_reg = L2_ENTRY_CONTROL_6r;
            sram_info->ram_count = SOC_TD2_NUM_EL_L2;
            sram_info->bank_index = 0;
            entries_per_ram = SOC_TD2_RAM_OFFSET_L2_BANK;
            base = index % entries_per_ram;
            if (index >= SOC_TD2_NUM_ENTRIES_PER_L2_BANK) {
                sram_info->bank_index++;
                base += SOC_TD2_NUM_ENTRIES_PER_L2_BANK;
            }
        } else {
            sram_info->force_reg = ISS_MEMORY_CONTROL_84r;
            sram_info->ram_count = SOC_TD2_NUM_EL_SHARED;
            sram_info->bank_index = 0;
            entries_per_ram = SOC_TD2_RAM_OFFSET_L2_SHARED_BANK;
            base_index = SOC_TD2_NUM_ENTRIES_L2_BANK;
            entries_per_bank = entries_per_ram * sram_info->ram_count;
            base = base_index + (index % entries_per_ram);            
            for (i=1; i < SOC_TD2_NUM_EL_L2; i++) {
                if (index >= (base_index + (entries_per_bank * i))) {
                    base += (entries_per_bank * i);
                    sram_info->bank_index++;
                }
            }
        }
        break;
    case L3_ENTRY_ONLYm:
    case L3_ENTRY_IPV4_UNICASTm:
    case L3_ENTRY_IPV4_MULTICASTm:
    case L3_ENTRY_IPV6_UNICASTm:
    case L3_ENTRY_IPV6_MULTICASTm:
        if (soc_mem_index_count(unit, L3_ENTRY_ONLYm) <= SOC_TD2_NUM_ENTRIES_L3_BANK) {
            /* No SRAM XOR RAM in L3 banks */
            return SOC_E_UNAVAIL;
        }
        sram_info->disable_reg = L3_ENTRY_PARITY_CONTROLr;
        sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
        sram_info->force_reg = ISS_MEMORY_CONTROL_84r;
        sram_info->force_field = FORCE_XOR_GENERATIONf;
        sram_info->ram_count = SOC_TD2_NUM_EL_SHARED;
        sram_info->bank_index = 3;
        entries_per_ram = ((mem == L3_ENTRY_ONLYm || mem == L3_ENTRY_IPV4_UNICASTm) ? 
                           SOC_TD2_RAM_OFFSET_L3_NARROW : (mem == L3_ENTRY_IPV6_MULTICASTm) ?
                           SOC_TD2_RAM_OFFSET_L3_DOUBLE_WIDE :
                           SOC_TD2_RAM_OFFSET_L3_WIDE);
        base_index = ((mem == L3_ENTRY_ONLYm || mem == L3_ENTRY_IPV4_UNICASTm) ?
                      SOC_TD2_NUM_ENTRIES_L3_BANK : (mem == L3_ENTRY_IPV6_MULTICASTm) ?
                      SOC_TD2_NUM_ENTRIES_L3_BANK_DOUBLE_WIDE :
                      SOC_TD2_NUM_ENTRIES_L3_BANK_WIDE);
        entries_per_bank = entries_per_ram * sram_info->ram_count;
        base = base_index + (index % entries_per_ram);
        for (i=1; i < SOC_TD2_NUM_EL_ALPM; i++) {
            if (index >= (base_index + (entries_per_bank * i))) {
                base += (entries_per_bank * i);
                sram_info->bank_index--;
            }
        }
        break;
    case L3_DEFIP_ALPM_IPV4m:
    case L3_DEFIP_ALPM_IPV4_1m:
    case L3_DEFIP_ALPM_IPV6_64m:
    case L3_DEFIP_ALPM_IPV6_64_1m:
    case L3_DEFIP_ALPM_IPV6_128m:
    case L3_DEFIP_ALPM_RAWm:
        sram_info->disable_reg = ILPM_SER_CONTROLr;
        sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
        sram_info->force_reg = ISS_MEMORY_CONTROL_84r;
        sram_info->force_field = FORCE_XOR_GENERATIONf;
        sram_info->ram_count = SOC_TD2_NUM_EL_SHARED;
        sram_info->bank_index = 0;
        switch (mem) {
        case L3_DEFIP_ALPM_RAWm:
            entries_per_ram = SOC_TD2_RAM_OFFSET_L3_DEFIP_ALPM_RAW;
            entries_per_bank = entries_per_ram * sram_info->ram_count;
            break;
        case L3_DEFIP_ALPM_IPV6_128m:
            entries_per_ram = SOC_TD2_RAM_OFFSET_L3_DEFIP_ALPM_IPV6_128;
            entries_per_bank = entries_per_ram * sram_info->ram_count;
            break;
        case L3_DEFIP_ALPM_IPV6_64_1m:
            entries_per_ram = SOC_TD2_RAM_OFFSET_L3_DEFIP_ALPM_IPV6_64_1;
            entries_per_bank = entries_per_ram * sram_info->ram_count;
            break;
        case L3_DEFIP_ALPM_IPV4m:
            entries_per_ram = SOC_TD2_RAM_OFFSET_L3_DEFIP_ALPM_IPV4;
            entries_per_bank = entries_per_ram * sram_info->ram_count;
            break;
        case L3_DEFIP_ALPM_IPV4_1m:
        case L3_DEFIP_ALPM_IPV6_64m:
        default:
            entries_per_ram = SOC_TD2_RAM_OFFSET_L3_DEFIP_ALPM_IPV4_1;
            entries_per_bank = entries_per_ram * sram_info->ram_count;
        }
        base = (index % entries_per_ram);
        for (i=1; i < SOC_TD2_NUM_EL_ALPM; i++) {
            if (index >= (entries_per_bank * i)) {
                base += (entries_per_bank * i);
                sram_info->bank_index++;
            }
        }
        break;
    case VLAN_XLATEm:
        contiguous = 1;
        sram_info->disable_reg = VLAN_XLATE_DBGCTRL_0r;
        sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
        sram_info->force_reg = VLAN_XLATE_DBGCTRL_0r;
        sram_info->force_field = FORCE_XOR_GENf;
        sram_info->ram_count = SOC_TD2_NUM_EL_VLAN_XLATE;
        sram_info->bank_index = 0;
        base = (index/4) * 4;
        break;
    case EGR_VLAN_XLATEm:
        contiguous = 1;
        sram_info->disable_reg = EGR_VLAN_XLATE_CONTROLr;
        sram_info->disable_field = DISABLE_SBUS_MEMWR_PARITY_CHECKf;
        sram_info->force_reg = EGR_VLAN_XLATE_CONTROLr;
        sram_info->force_field = FORCE_XOR_GENf;
        sram_info->ram_count = SOC_TD2_NUM_EL_EGR_VLAN_XLATE;
        sram_info->bank_index = 0;
        base = (index/4) * 4;
        break;
    case ING_L3_NEXT_HOPm:
        sram_info->ram_count = SOC_TD2_NUM_EL_ING_L3_NEXT_HOP;
        sram_info->bank_index = 0;
        entries_per_ram = SOC_TD2_RAM_OFFSET_ING_L3_NEXT_HOP;
        base = index % entries_per_ram;
        break;
    case L3_IPMCm:
        sram_info->ram_count = SOC_TD2_NUM_EL_L3_IPMC;
        sram_info->bank_index = 0;
        entries_per_ram = SOC_TD2_RAM_OFFSET_L3_IPMC;
        base = index % entries_per_ram;
        break;
    case L2MCm:
        sram_info->ram_count = SOC_TD2_NUM_EL_L2MC;
        sram_info->bank_index = 0;
        entries_per_ram = SOC_TD2_RAM_OFFSET_L2MC;
        base = index % entries_per_ram;
        break;
    default: return SOC_E_PARAM;
    }
    sram_info->mem_indexes[0] = base;
    if (contiguous) {
        for (i=1; i < sram_info->ram_count; i++) {
            sram_info->mem_indexes[i] = sram_info->mem_indexes[i-1] + 1;
        }
    } else {
        for (i=1; i < sram_info->ram_count; i++) {
            sram_info->mem_indexes[i] =  sram_info->mem_indexes[i-1] + entries_per_ram;
        }
    }
    return SOC_E_NONE;
}

int
_soc_trident2_mem_cpu_write_control(int unit, soc_mem_t mem, int copyno,
                                    int enable, int *orig_enable)
{
    soc_reg_t reg;
    soc_field_t field;
    int blk, port;
    uint32 rval, fval, orig_fval, enable_fval, disable_fval;

    enable_fval = 1;
    disable_fval = 0;

    switch (mem) {
    case XLPORT_WC_UCMEM_DATAm:
        reg = XLPORT_WC_UCMEM_CTRLr;
        field = ACCESS_MODEf;
        SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
            port = SOC_BLOCK_PORT(unit, blk);
            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));
            /* It will use the setting from the last block */
            *orig_enable = soc_reg_field_get(unit, reg, rval, field);
            soc_reg_field_set(unit, reg, &rval, field, enable ? 1 : 0);
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
        }
        return SOC_E_NONE;
    case L3_DEFIP_ALPM_RAWm:
    case L3_DEFIP_ALPM_IPV4m:
    case L3_DEFIP_ALPM_IPV4_1m:
    case L3_DEFIP_ALPM_IPV6_64m:
    case L3_DEFIP_ALPM_IPV6_64_1m:
    case L3_DEFIP_ALPM_IPV6_128m:
        reg = ISS_MEMORY_CONTROL_84r;
        field = BYPASS_ISS_MEMORY_LPf;
        enable_fval = 0xf;
        break;
    case MMU_INTFI_PFC_ST_TBLm:
        reg = INTFI_CFGr;
        field = PFC_ST_TBL_DISABLEf;
        break;
    case LINK_STATUSm:
        reg = SW2_HW_CONTROLr;
        field = LINK_STATUS_UPDATE_ENABLEf;
        break;
    case MMU_INTFO_QCN_CNM_TIMER_TBLm:
        reg = MISCCONFIGr;
        field = REFRESH_ENf;
        enable_fval = 0;
        disable_fval = 1;
        break;
    default:
        return SOC_E_NONE;
    }

    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
    orig_fval = soc_reg_field_get(unit, reg, rval, field);
    fval = enable ? enable_fval : disable_fval;

    *orig_enable = orig_fval == enable_fval;
    if (fval != orig_fval) {
        soc_reg_field_set(unit, reg, &rval, field, fval);
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));
    }

    return SOC_E_NONE;
}

/*
 * cpu port (mmu port 0): 48 queues (2000-2047)
 * loopback port (mmu port 116): 8 queues (4048-4055)
 */
int
soc_trident2_num_cosq_init(int unit)
{
    soc_info_t *si;
    int port, phy_port, mmu_port, mmu_port_offset, pipe;
    int uc_cosq_base, mc_cosq_base, uc_cosq_per_port;

    si = &SOC_INFO(unit);

    if (soc_feature(unit, soc_feature_cmic_reserved_queues)) {
        si->port_num_cosq[CMIC_PORT(unit)] = 44;
    } else {
        si->port_num_cosq[CMIC_PORT(unit)] = 48;
    }
    si->port_cosq_base[CMIC_PORT(unit)] = 520;
    si->port_num_cosq[LB_PORT(unit)] = 8;
    si->port_cosq_base[LB_PORT(unit)] = 1088;

    for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
        if (pipe) { /* Y-pipe */
            uc_cosq_base = 1480;
            mc_cosq_base = 568;
        } else { /* X-pipe */
            uc_cosq_base = 0;
            mc_cosq_base = 0;
        }
        for (mmu_port_offset = 0; mmu_port_offset < _TD2_MMU_PORTS_PER_PIPE;
             mmu_port_offset++) {
            mmu_port = si->mmu_port_base[pipe] + mmu_port_offset;
            phy_port = si->port_m2p_mapping[mmu_port];
            if (phy_port == -1) {
                continue;
            }
            port = si->port_p2l_mapping[phy_port];

            if (IS_CPU_PORT(unit, port) || IS_LB_PORT(unit, port)) {
                continue;
            }

            if (SOC_PBMP_MEMBER(si->eq_pbm, port)) { /* VBS (HSP) port */
                si->port_num_cosq[port] = 10;
                si->port_cosq_base[port] = mc_cosq_base;
                mc_cosq_base += si->port_num_cosq[port];
                si->port_num_uc_cosq[port] = 10;
                si->port_uc_cosq_base[port] = uc_cosq_base;
                uc_cosq_base += si->port_num_uc_cosq[port];
            } else {
                uc_cosq_per_port =
                    soc_property_port_get(unit, port, spn_LLS_NUM_L2UC, 10);
                if (uc_cosq_per_port < 10 || uc_cosq_per_port > 16) {
                    uc_cosq_per_port = 10;
                }
                uc_cosq_per_port = (uc_cosq_per_port + 3) & ~3;

                si->port_num_cosq[port] = 10;
                si->port_cosq_base[port] = mc_cosq_base;
                mc_cosq_base += si->port_num_cosq[port];
                si->port_num_uc_cosq[port] = uc_cosq_per_port;
                si->port_uc_cosq_base[port] = uc_cosq_base;
                uc_cosq_base += si->port_num_uc_cosq[port];
            }
        }
    }

    return SOC_E_NONE;
}

STATIC int
soc_trident2_max_frequency_get(int unit,  uint16 dev_id, uint8 rev_id,
                               int skew_id, int *frequency)
{
    switch (dev_id) {
    case BCM56850_DEVICE_ID:
    case BCM56852_DEVICE_ID:
    case BCM56853_DEVICE_ID:
    case BCM56855_DEVICE_ID:
    case BCM56750_DEVICE_ID:
    case BCM56830_DEVICE_ID:
        *frequency = rev_id < BCM56850_A2_REV_ID ? 760 : 793;
        break;
    case BCM56851_DEVICE_ID: /* Cannot handle 56851P */
        if (skew_id == 2) { /* 56851P */
            *frequency = rev_id < BCM56851_A2_REV_ID ? 518 : 537;
        } else {
            *frequency = rev_id < BCM56851_A2_REV_ID ? 608 : 635;
        }
        break;
    case BCM56854_DEVICE_ID:
        *frequency = rev_id < BCM56854_A2_REV_ID ? 608 : 635;
        break;
    default:
        return SOC_E_INTERNAL;
    }

    return SOC_E_NONE;
}

int
soc_trident2_tsc_map_get(int unit, uint32 *tsc_map)
{
    uint16 dev_id;
    uint8 rev_id;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    switch (dev_id) {
    case BCM56850_DEVICE_ID:
    case BCM56851_DEVICE_ID:
    case BCM56853_DEVICE_ID:
    case BCM56750_DEVICE_ID:
    case BCM56830_DEVICE_ID:
        *tsc_map = 0xffffffff;
        break;
    case BCM56852_DEVICE_ID:
        *tsc_map = 0xe7e7e7ef;
        break;
    case BCM56854_DEVICE_ID:
    case BCM56855_DEVICE_ID:
        *tsc_map = 0x0f1ff8e8;
        break;
    default:
        return SOC_E_INTERNAL;
    }

    return SOC_E_NONE;
}

/*
 * Trident2 port mapping
 *     130 physical ports: port 0-64 in X pipe, port 65-129 in Y pipe
 *     106 logical ports
 *     108 mmu ports: port 0-53 in X pipe, port 64-117 in Y pipe
 *     cpu port number is fixed: physical 0, logical 0, mmu 52
 *     loopback port number is fixed: physical 129, logical 105, mmu 116
 *     mmu port 53 and mmu port 117 are purge port
 *     mmu port can only map to physical port ID in the same pipe
 *     XLPORT3 (physical port 13-16) can be configured as management port(s)
 *     management port can be:
 *     - one 10G port
 *     - one to four ports with speed up to 2.5G each
 * Physical port number in eacc port group
 *     PGW_CL0: CPORT0   TSC 0-2   port 1
 *              XLPORT0  TSC 0     port 1-4
 *              XLPORT1  TSC 1     port 5-8
 *              XLPORT2  TSC 2     port 9-12
 *              XLPORT3  TSC 3     port 13-16
 *     PGW_CL1: CPORT1   TSC 5-7   port 21
 *              XLPORT7  TSC 4     port 17-20
 *              XLPORT6  TSC 5     port 21-24
 *              XLPORT5  TSC 6     port 25-28
 *              XLPORT4  TSC 7     port 29-32
 *     PGW_CL2: CPORT2   TSC 8-10  port 33
 *              XLPORT8  TSC 8     port 33-36
 *              XLPORT9  TSC 9     port 37-40
 *              XLPORT10 TSC 10    port 41-44
 *              XLPORT11 TSC 11    port 45-48
 *     PGW_CL3: CPORT3   TSC 13-15 port 53
 *              XLPORT15 TSC 12    port 49-52
 *              XLPORT14 TSC 13    port 53-56
 *              XLPORT13 TSC 14    port 57-60
 *              XLPORT12 TSC 15    port 61-64
 *     PGW_CL4: CPORT4   TSC 16-18 port 65
 *              XLPORT16 TSC 16    port 65-68
 *              XLPORT17 TSC 17    port 69-72
 *              XLPORT18 TSC 18    port 73-76
 *              XLPORT19 TSC 19    port 77-80
 *     PGW_CL5: CPORT5   TSC 21-23 port 85
 *              XLPORT23 TSC 20    port 81-84
 *              XLPORT22 TSC 21    port 85-88
 *              XLPORT21 TSC 22    port 89-92
 *              XLPORT20 TSC 23    port 93-96
 *     PGW_CL6: CPORT6   TSC 24-26 port 97
 *              XLPORT24 TSC 24    port 97-100
 *              XLPORT25 TSC 25    port 101-104
 *              XLPORT26 TSC 26    port 105-108
 *              XLPORT27 TSC 27    port 109-112
 *     PGW_CL7: CPORT7   TSC 29-31 port 117
 *              XLPORT31 TSC 28    port 113-116
 *              XLPORT30 TSC 29    port 117-120
 *              XLPORT29 TSC 30    port 121-124
 *              XLPORT28 TSC 31    port 125-128
 * This routine will setup:
 *     SOC_INFO(unit).port_p2l_mapping[]
 *     SOC_INFO(unit).port_l2p_mapping[]
 *     SOC_INFO(unit).port_p2m_mapping[]
 *     SOC_INFO(unit).port_m2p_mapping[]
 *     SOC_INFO(unit).port_speed_max[]
 *     SOC_INFO(unit).port_group[]
 *     SOC_INFO(unit).port_serdes[]
 *     SOC_INFO(unit).port_num_lanes[]
 *     SOC_INFO(unit).phy_port_base[]
 *     SOC_INFO(unit).mmu_port_base[]
 * 100+G port:
 *     - can only be @ 760MHz
 *     - needs to be HSP
 *     - cannot be in oversubscribe mode
 * 40/42G port:
 *     - needs to be HSP except @ 760MHz
 *     - oversubscribe mode can support both cut-through and store-and-forward
 * sub-40G port:
 *     - oversubscribe mode can only support store-and-forward
 */
int
soc_trident2_port_config_init(int unit, uint16 dev_id, uint8 rev_id)
{
    soc_info_t *si;
    char *config_str, *sub_str, *sub_str_end;
    static const char str_2p5[] = "2.5";
    char str_buf[8];
    int rv;
    int num_port, num_phy_port, num_mmu_port;
    int port, phy_port, mmu_port;
    int port_cpu, phy_port_cpu, mmu_port_cpu;
    int port_lb, phy_port_lb, mmu_port_lb;
    int pipe, quad, pgw, blk;
    int port_bandwidth, frequency;
    int blk_linerate_bandwidth, blk_oversub_bandwidth;
    int pgw_linerate_bandwidth, pgw_oversub_bandwidth;
    int quad_linerate_bandwidth, quad_oversub_bandwidth;
    int index, tsc_id;
    int port_count[_TD2_PIPES_PER_DEV], lane_count;
    int pgw_port[_TD2_PORTS_PER_PGW], *blk_port;
    int pgw_port_bandwidth[_TD2_PORTS_PER_PGW], *blk_port_bandwidth;
    int max_quad_core_bandwidth[_TD2_QUADS_PER_DEV];
    soc_pbmp_t pbmp;
    uint32 tsc_map;
    uint32 blk_configured_map;
    uint32 blk_management_map, blk_inactive_map, blk_oversub_map;
    char option;
    int freq_list_len;
    int const *freq_list;
    static const int a1_freq_list[] = { 760, 660, 608, 518, 415 };
    static const int a2_793_freq_list[] = { 793, 760, 635, 537, 415 };
    static const int a2_635_freq_list[] = { 635, 608, 537, 518, 415 };

    si = &SOC_INFO(unit);

    num_port = 106;
    num_phy_port = 130;
    num_mmu_port = 117; /* mmu port 53 to 63 are not used */

    /* cpu port is logical port 0, physical port 0, mmu port 0 */
    port_cpu = 0;
    phy_port_cpu = 0;
    mmu_port_cpu = 52;

    /* loopback port is logical port 105, physical port 129, mmu port 65 */
    port_lb = 105;
    phy_port_lb = 129;
    mmu_port_lb = 116;

    /* Can't read skew_id from TOP register at this point */
    soc_trident2_max_frequency_get(unit, dev_id, rev_id, -1, &si->frequency);
    frequency = rev_id == BCM56850_A0_REV_ID ? 415 : -1;
    if (frequency != -1 && frequency != si->frequency) {
        if (rev_id <= BCM56850_A1_REV_ID) {
            freq_list = a1_freq_list;
            freq_list_len = sizeof(a1_freq_list) / sizeof(int);
        } else {
            if (si->frequency == 793) {
                freq_list = a2_793_freq_list;
                freq_list_len = sizeof(a2_793_freq_list) / sizeof(int);
            } else {
                freq_list = a2_635_freq_list;
                freq_list_len = sizeof(a2_635_freq_list) / sizeof(int);
            }
        }
        for (index = 1; index < freq_list_len; index++) { /* skip index 0 */
            if (freq_list[index] < si->frequency &&
                frequency == freq_list[index]) {
                break;
            }
        }
        if (index < freq_list_len) {
            si->frequency = frequency;
        }
    }

    /* Setup max I/O bandwidth */
    switch (dev_id) {
    case BCM56850_DEVICE_ID:
    case BCM56851_DEVICE_ID:
    case BCM56853_DEVICE_ID:
    case BCM56750_DEVICE_ID:
    case BCM56830_DEVICE_ID:
        si->io_bandwidth = 1280000;
        break;
    case BCM56852_DEVICE_ID:
        si->io_bandwidth = 960000;
        break;
    case BCM56854_DEVICE_ID:
    case BCM56855_DEVICE_ID:
        si->io_bandwidth = 720000;
        break;
    default:
        return SOC_E_INTERNAL;
    }

    /* Setup max core bandwidth */
    if (si->frequency >= 760) {
        si->bandwidth = 960000;
    } else if (si->frequency >= 608) {
        si->bandwidth = 720000;
    } else if (si->frequency >= 518) {
        si->bandwidth = 640000;
    } else {
        si->bandwidth = 480000;
    }

    /* Setup max bandwidth for each per quadrant */
    if (si->bandwidth == 720000) {
        max_quad_core_bandwidth[0] = max_quad_core_bandwidth[3] = 160000;
        max_quad_core_bandwidth[1] = max_quad_core_bandwidth[2] = 200000;
    } else {
        for (quad = 0; quad < _TD2_QUADS_PER_DEV; quad++) {
            max_quad_core_bandwidth[quad] = si->bandwidth / 4;
        }
    }

    if (si->io_bandwidth > si->bandwidth) {
        si->oversub_pbm =
            soc_property_get_pbmp(unit, spn_PBMP_OVERSUBSCRIBE, 0);
    }

    SOC_IF_ERROR_RETURN(soc_trident2_tsc_map_get(unit, &tsc_map));

    for (phy_port = 0; phy_port < num_phy_port; phy_port++) {
        si->port_p2l_mapping[phy_port] = -1;
        si->port_p2m_mapping[phy_port] = -1;
    }
    for (port = 0; port < num_port; port++) {
        si->port_l2p_mapping[port] = -1;
        si->port_speed_max[port] = -1;
        si->port_group[port] = -1;
        si->port_serdes[port] = -1;
        si->port_num_lanes[port] = -1;
    }
    for (mmu_port = 0; mmu_port < num_mmu_port; mmu_port++) {
        si->port_m2p_mapping[mmu_port] = -1;
    }

    si->port_p2l_mapping[phy_port_cpu] = port_cpu;
    si->port_p2m_mapping[phy_port_cpu] = mmu_port_cpu;
    si->port_p2l_mapping[phy_port_lb] = port_lb;
    si->port_p2m_mapping[phy_port_lb] = mmu_port_lb;
    SOC_PBMP_PORT_SET(si->xpipe_pbm, port_cpu);
    SOC_PBMP_PORT_SET(si->ypipe_pbm, port_lb);
    SOC_PBMP_CLEAR(si->management_pbm);
    SOC_PBMP_CLEAR(si->all.disabled_bitmap);

    si->phy_port_base[0] = 0;               /* First physical port in X pipe */
    si->phy_port_base[1] = num_phy_port / 2;/* First physical port in Y pipe */
    si->mmu_port_base[0] = 0;               /* First mmu port in X pipe */
    si->mmu_port_base[1] = 64;              /* First mmu port in Y pipe */

    port_count[0] = 0; /* X pipe */
    port_count[1] = 0; /* Y pipe */

    rv = SOC_E_NONE;
    for (port = 0; port < num_port; port++) {
        if (port == port_cpu || port == port_lb) {
            continue;
        }
        config_str = soc_property_port_get_str(unit, port, spn_PORTMAP);
        if (config_str == NULL) {
            continue;
        }

        /*
         * portmap.<port>=<physical port number>:<bandwidth in Gb>
         */
        sub_str = config_str;

        /* Parse physical port number */
        phy_port = sal_ctoi(sub_str, &sub_str_end);
        if (sub_str == sub_str_end) {
            soc_cm_print("Port %d: Missing physical port information \"%s\"\n",
                         port, config_str);
            rv = SOC_E_FAIL;
            continue;
        }
        if (phy_port < 1 || phy_port > (num_phy_port - 2)) {
            soc_cm_print("Port %d: Invalid physical port number %d\n",
                         port, phy_port);
            rv = SOC_E_FAIL;
            continue;
        }
        tsc_id = (phy_port - 1) / 4;
        if (!(tsc_map & (1 << tsc_id))) {
            soc_cm_print("Port %d: Physical port %d is in disabled TSC %d\n",
                         port, phy_port, tsc_id);
            rv = SOC_E_FAIL;
            continue;
        }
        if (si->port_p2l_mapping[phy_port] != -1) {
            soc_cm_print("Port %d: Physical port %d is used by port %d\n",
                         port, phy_port, si->port_p2l_mapping[phy_port]);
            rv = SOC_E_FAIL;
            continue;
        }
        pipe = phy_port < si->phy_port_base[1] ? 0 : 1;
        if (port_count[pipe] >= num_port / 2 - 1) {
            soc_cm_print("Can not configure more than %d port in "
                         "%c pipeline\n", num_port / 2 - 1,
                         pipe ? 'Y' : 'X');
            rv = SOC_E_FAIL;
            continue;
        }

        /* Skip ':' between physical port number and bandwidth */
        sub_str = sub_str_end;
        if (*sub_str != '\0') {
            if (*sub_str != ':') {
                soc_cm_print("Port %d: Bad config string \"%s\"\n",
                             port, config_str);
                rv = SOC_E_FAIL;
                continue;
            }
            sub_str++;
        }

        /* Parse bandwidth */
        for (index = 0; index < sizeof(str_2p5) - 1; index++) {
            if (sub_str[index] == '\0') {
                break;
            }
            str_buf[index] = sub_str[index];
        }
        str_buf[index] = '\0';
        if (!sal_strcmp(str_buf, str_2p5)) {
            port_bandwidth = 2500;
            sub_str_end = &sub_str[sizeof(str_2p5) - 1];
        } else {
            port_bandwidth = sal_ctoi(sub_str, &sub_str_end) * 1000;
            if (sub_str == sub_str_end) {
                soc_cm_print("Port %d: Missing bandwidth information \"%s\"\n",
                             port, config_str);
                rv = SOC_E_FAIL;
                continue;
            }
            if (port_bandwidth != 1000 && port_bandwidth != 10000 &&
                port_bandwidth != 15000 && port_bandwidth != 20000 &&
                port_bandwidth != 30000 && port_bandwidth != 40000 &&
                port_bandwidth != 100000) {
                soc_cm_print("Port %d: Invalid bandwidth %d Gb\n",
                             port, port_bandwidth / 1000);
                rv = SOC_E_FAIL;
                continue;
            }
        }

        /* Check if option presents */
        option = 0;
        sub_str = sub_str_end;
        if (*sub_str != '\0') {
            /* Skip ':' between bandwidth and options */
            if (*sub_str != ':') {
                soc_cm_print("Port %d: Bad config string \"%s\"\n",
                             port, config_str);
                rv = SOC_E_FAIL;
                continue;
            }
            sub_str++;

            if (*sub_str != '\0') {
                if (*sub_str == 'm') {
                    if (phy_port < 13 || phy_port > 16) {
                        soc_cm_print("Port %d: Physical port %d can not be "
                                     "configured as management port\n",
                                     port, phy_port);
                        rv = SOC_E_FAIL;
                        continue;
                    }
                } else if (*sub_str != 'i') {
                    soc_cm_print("Port %d: Bad config string \"%s\"\n",
                                 port, config_str);
                    rv = SOC_E_FAIL;
                    continue;
                }
                option = *sub_str;
                sub_str++;
            }
        }

        /* Check trailing string */
        if (*sub_str != '\0') {
            soc_cm_print("Port %d: Bad config string \"%s\"\n",
                         port, config_str);
            rv = SOC_E_FAIL;
            continue;
        }

        /* Update soc_info */
        si->port_p2l_mapping[phy_port] = port;
        si->port_l2p_mapping[port] = phy_port;
        si->port_speed_max[port] = port_bandwidth;
        if (option == 'i') {
            SOC_PBMP_PORT_ADD(si->all.disabled_bitmap, port);
        } else if (option == 'm') {
            SOC_PBMP_PORT_ADD(si->management_pbm, port);
        }
        port_count[pipe]++;
    }

    if (port_count[0] == 0 && port_count[1] == 0) {
        if (SOC_CONTROL(unit)->soc_flags & SOC_F_ATTACHED) { /* not for PCID */
            rv = SOC_E_FAIL;
        }
    }

    /* Bandwidth check for ports in each XLPORT/CPORT block */
    for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
        for (quad = 0; quad < _TD2_QUADS_PER_PIPE; quad++) {
            quad_linerate_bandwidth = 0;
            quad_oversub_bandwidth = 0;
            for (pgw = 0; pgw < _TD2_PGWS_PER_QUAD; pgw++) {
                pgw_linerate_bandwidth = 0;
                pgw_oversub_bandwidth = 0;

                /* Prepare per PGW local variables for ease of processing */
                for (index = 0; index < _TD2_PORTS_PER_PGW; index++) {
                    phy_port = 1 + pipe * _TD2_PORTS_PER_PIPE +
                        quad * _TD2_PORTS_PER_QUAD +
                        pgw * _TD2_PORTS_PER_PGW + index;
                    port = si->port_p2l_mapping[phy_port];
                    pgw_port[index] = port;
                    if (port == -1) {
                        pgw_port_bandwidth[index] = 0;
                    } else if (si->port_speed_max[port] < 2500) {
                        pgw_port_bandwidth[index] = 2500;
                    } else {
                        pgw_port_bandwidth[index] = si->port_speed_max[port];
                    }
                }

                for (blk = 0; blk < _TD2_XLPS_PER_PGW; blk++) {
                    blk_port = &pgw_port[blk * _TD2_PORTS_PER_XLP];
                    blk_port_bandwidth =
                        &pgw_port_bandwidth[blk * _TD2_PORTS_PER_XLP];
                    blk_configured_map = 0;
                    for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                        if (blk_port[index] != -1) {
                            blk_configured_map |= 1 << index;
                        }
                    }
                    if (blk_configured_map == 0) {
                        continue;
                    }

                    /* Management port block (XLPORT3) handling */
                    if (pipe == 0 && quad == 0 && pgw == 0 && blk == 3 &&
                        SOC_PBMP_NOT_NULL(si->management_pbm)) {
                        blk_management_map = 0;
                        for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                            port = blk_port[index];
                            if (port == -1) {
                                continue;
                            }
                            if (SOC_PBMP_MEMBER(si->management_pbm, port)) {
                                blk_management_map |= 1 << index;
                            }
                        }
                        if (blk_management_map != blk_configured_map) {
                            soc_cm_print("Port");
                            for (index = 0; index < _TD2_PORTS_PER_XLP;
                                 index++) {
                                if (blk_port[index] != -1) {
                                    soc_cm_print(" %d", blk_port[index]);
                                }
                            }
                            soc_cm_print(": Can not be configured to "
                                         "different management port status\n");
                            rv = SOC_E_FAIL;
                            continue;
                        }

                        for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                            port = blk_port[index];
                            if (port == -1) {
                                continue;
                            }
                            phy_port = si->port_l2p_mapping[port];
                            port_bandwidth = blk_port_bandwidth[index];
                            if (port_bandwidth > 10000 ||
                                (port_bandwidth > 2500 && index != 0)) {
                                soc_cm_print("Management port %d: "
                                             "Physical port %d can not be "
                                             "configured to %d Gb\n",
                                             port, phy_port,
                                             port_bandwidth / 1000);
                                rv = SOC_E_FAIL;
                                continue;
                            }
                        }
                        port_bandwidth = blk_port_bandwidth[0];
                        if (port_bandwidth > 2500) {
                            for (index = 1; index < _TD2_PORTS_PER_XLP;
                                 index++) {
                                port = blk_port[index];
                                if (port == -1) {
                                    continue;
                                }
                                soc_cm_print("Management port %d bandwidth %d "
                                             "Gb and port %d can not be both "
                                             "configured\n",
                                             blk_port[0],
                                             port_bandwidth / 1000, port);
                                rv = SOC_E_FAIL;
                            }
                        }
                        continue;
                    }

                    /* Normal port block handling */
                    blk_inactive_map = 0;
                    blk_oversub_map = 0;
                    blk_linerate_bandwidth = 0;
                    blk_oversub_bandwidth = 0;
                    for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                        port = blk_port[index];
                        if (port == -1) {
                            continue;
                        }
                        port_bandwidth = blk_port_bandwidth[index];
                        if (SOC_PBMP_MEMBER(si->oversub_pbm, port)) {
                            blk_oversub_map |= 1 << index;
                        }
                        if (SOC_PBMP_MEMBER(si->all.disabled_bitmap, port)) {
                            blk_inactive_map |= 1 << index;
                        } else {
                            if (blk_oversub_map & (1 << index)) {
                                blk_oversub_bandwidth += port_bandwidth;
                            } else {
                                blk_linerate_bandwidth += port_bandwidth;
                            }
                        }
                        if ((port_bandwidth > 42000 &&
                             (index != 0 || blk != (pgw & 1))) ||
                            (port_bandwidth > 21000 && index != 0) ||
                            (port_bandwidth > 10000 && (index & 1))) {
                            soc_cm_print("Port %d: Physical port %d can not "
                                         "be configured to %d Gb\n",
                                         port, si->port_l2p_mapping[port],
                                         port_bandwidth / 1000);
                            rv = SOC_E_FAIL;
                        }
                    }

                    /* Check if any the lanes used by first port of block is
                     * not used by other port */
                    port_bandwidth = blk_port_bandwidth[0];
                    if (port_bandwidth > 42000) {
                        lane_count = 12;
                    } else if (port_bandwidth > 21000) {
                        lane_count = 4;
                    } else if (port_bandwidth > 10000) {
                        lane_count = 2;
                    } else {
                        lane_count = 1;
                    }
                    for (index = 1; index < lane_count; index++) {
                        port = blk_port[index];
                        if (port == -1 ||
                            SOC_PBMP_MEMBER(si->all.disabled_bitmap, port)) {
                            continue;
                        }
                        soc_cm_print("Port %d bandwidth %d Gb and "
                                     "port %d can not be both configured\n",
                                     blk_port[0], port_bandwidth / 1000, port);
                        rv = SOC_E_FAIL;
                    }

                    /* Check if any the lanes used by third port of block is
                     * not used by other port */
                    port_bandwidth = blk_port_bandwidth[2];
                    if (port_bandwidth > 10000) {
                        port = blk_port[3];
                        if (port != -1 &&
                            !SOC_PBMP_MEMBER(si->all.disabled_bitmap, port)) {
                            soc_cm_print("Port %d bandwidth %d Gb and port %d "
                                         "can not be both configured\n",
                                         blk_port[2], port_bandwidth / 1000,
                                         port);
                            rv = SOC_E_FAIL;
                        }
                        if (blk_port[0] == -1) {
                            soc_cm_print("Physical port %d needs to be "
                                         "configured in order to work with "
                                         "port %d\n",
                                         1 + pipe * _TD2_PORTS_PER_PIPE +
                                         pgw * _TD2_PORTS_PER_PGW +
                                         blk * _TD2_PORTS_PER_XLP,
                                         blk_port[2]);
                            rv = SOC_E_FAIL;
                        }
                    }

                    if (blk_inactive_map == blk_configured_map) {
                        soc_cm_print("Flex port");
                        for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                            if (blk_port[index] != -1) {
                                soc_cm_print(" %d", blk_port[index]);
                            }
                        }
                        soc_cm_print(": Can not be all inactive\n");
                        rv = SOC_E_FAIL;
                        continue;
                    }

                    if (blk_inactive_map != 0) {
                        if (blk_oversub_map != 0 &&
                            blk_oversub_map != blk_configured_map) {
                            soc_cm_print("Flex port");
                            for (index = 0; index < _TD2_PORTS_PER_XLP;
                                 index++) {
                                if (blk_port[index] != -1) {
                                    soc_cm_print(" %d", blk_port[index]);
                                }
                            }
                            soc_cm_print(": Can not be configured to "
                                         "different oversubscription "
                                         "status\n");
                            rv = SOC_E_FAIL;
                            continue;
                        }
                    }

                    port = blk_port[2];
                    if (port != -1) {
                        /* Check reserved bandwidth if lane 3 is inactive flex
                         * port and lane 2 is active */
                        if ((blk_inactive_map & 0x0c) == 0x08 &&
                            blk_port_bandwidth[2] <
                            blk_port_bandwidth[3] * 2) {
                            soc_cm_print("Port %d bandwidth %d Gb is not "
                                         "enough to cover flex port for "
                                         "port %d\n",
                                         port, si->port_speed_max[port] / 1000,
                                         blk_port[3]);
                            rv = SOC_E_FAIL;
                        }
                    }

                    port = blk_port[0];
                    if (port != -1) {
                        /* Check reserved bandwidth if lane 3 is inactive flex
                         * port and lane 0 is active */
                        if ((blk_inactive_map & 0x09) == 0x08 &&
                            blk_port_bandwidth[0] <
                            blk_port_bandwidth[3] * 4) {
                            soc_cm_print("Port %d bandwidth %d Gb is not "
                                         "enough to cover flex port for "
                                         "port %d\n",
                                         port, si->port_speed_max[port] / 1000,
                                         blk_port[3]);
                            rv = SOC_E_FAIL;
                        }

                        /* Check reserved bandwidth if lane 2 is inactive flex
                         * port and lane 0 is active */
                        if ((blk_inactive_map & 0x05) == 0x04 &&
                            blk_port_bandwidth[0] <
                            blk_port_bandwidth[2] * 2) {
                            soc_cm_print("Port %d bandwidth %d Gb is not "
                                         "enough to cover flex port for "
                                         "port %d\n",
                                         port, si->port_speed_max[port] / 1000,
                                         blk_port[2]);
                            rv = SOC_E_FAIL;
                        }

                        /* Check reserved bandwidth if lane 1 is inactive flex
                         * port and lane 0 is active */
                        if ((blk_inactive_map & 0x03) == 0x02 &&
                            blk_port_bandwidth[0] <
                            blk_port_bandwidth[1] * 4) {
                            soc_cm_print("Port %d bandwidth %d Gb is not "
                                         "enough to cover flex port for "
                                         "port %d\n",
                                         port, si->port_speed_max[port] / 1000,
                                         blk_port[1]);
                            rv = SOC_E_FAIL;
                        }
                    }
                    pgw_linerate_bandwidth += blk_linerate_bandwidth;
                    pgw_oversub_bandwidth += blk_oversub_bandwidth;
                } /* for (blk = 0; blk < _TD2_XLPS_PER_PGW; blk++) */
                quad_linerate_bandwidth += pgw_linerate_bandwidth;
                quad_oversub_bandwidth += pgw_oversub_bandwidth;
            } /* for (pgw = 0; pgw < _TD2_PGWS_PER_QUAD; pgw++) */

            index = pipe * _TD2_QUADS_PER_PIPE + quad;
            if (quad_linerate_bandwidth > max_quad_core_bandwidth[index]) {
                soc_cm_print("PGW_CL%d and PGW_CL%d total line rate bandwidth "
                             "(%d Gb) exceeds %d Gb\n",
                             pipe * _TD2_PGWS_PER_PIPE +
                             quad * _TD2_PGWS_PER_QUAD,
                             pipe * _TD2_PGWS_PER_PIPE +
                             quad * _TD2_PGWS_PER_QUAD + 1,
                             quad_linerate_bandwidth / 1000,
                             max_quad_core_bandwidth[index] / 1000);
                rv = SOC_E_FAIL;
            } else if (quad_linerate_bandwidth ==
                       max_quad_core_bandwidth[index] &&
                       quad_oversub_bandwidth != 0) {
                soc_cm_print("PGW_CL%d and PGW_CL%d total line rate bandwidth "
                             "(%d Gb) equals to max core bandwidth, no extra "
                             "bandwidth for oversubscription ports\n",
                             pipe * _TD2_PGWS_PER_PIPE +
                             quad * _TD2_PGWS_PER_QUAD,
                             pipe * _TD2_PGWS_PER_PIPE +
                             quad * _TD2_PGWS_PER_QUAD + 1,
                             quad_linerate_bandwidth / 1000);
                rv = SOC_E_FAIL;
            } else if (quad_oversub_bandwidth >
                       (max_quad_core_bandwidth[index] -
                        quad_linerate_bandwidth) * 2) {
                soc_cm_print("PGW_CL%d and PGW_CL%d total I/O "
                             "oversubscription bandwidth (%d Gb) is more than "
                             "2 times of core oversubscription bandwidth "
                             "(2 * %d Gb)\n",
                             pipe * _TD2_PGWS_PER_PIPE +
                             quad * _TD2_PGWS_PER_QUAD,
                             pipe * _TD2_PGWS_PER_PIPE +
                             quad * _TD2_PGWS_PER_QUAD + 1,
                             quad_oversub_bandwidth / 1000,
                             (max_quad_core_bandwidth[index] -
                              quad_linerate_bandwidth) / 1000);
                rv = SOC_E_FAIL;
            }
        } /* for (quad = 0; quad < _TD2_QUADS_PER_PIPE; quad++) */
    } /* for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) */

    if (SOC_FAILURE(rv)) {
        for (phy_port = 1; phy_port < 129; phy_port++) {
            si->port_p2l_mapping[phy_port] = -1;
        }
        return rv;
    }

    if (soc_cm_debug_check(DK_VERBOSE)) {
        soc_cm_print("physical to logical mapping:");
        for (index = 0; index < num_phy_port; index++) {
            if (index % 16 == 0) {
                soc_cm_print("\n    ");
            }
            soc_cm_print(" %3d", si->port_p2l_mapping[index]);
        }
        soc_cm_print("\n");
        soc_cm_print("physical port bandwidth:");
        for (index = 0; index < num_phy_port; index++) {
            if (index % 16 == 0) {
                soc_cm_print("\n    ");
            }
            port = si->port_p2l_mapping[index];
            if (port == -1) {
                soc_cm_print("  -1");
            } else if (si->port_speed_max[port] == 2500) {
                soc_cm_print(" 2.5");
            } else {
                soc_cm_print(" %3d", si->port_speed_max[port] / 1000);
            }
        }
        soc_cm_print("\n");
    }

    /* Setup port_group, num_lanes, xpipe_pbm and ypipe_pbm */
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_l2p_mapping[port];
        if (phy_port == -1) { /* cpu, loopback, or unused port */
            continue;
        }
        /* 16 ports per PGW_CL */
        si->port_group[port] = (phy_port - 1) / _TD2_PORTS_PER_PGW;
        si->port_serdes[port] = (phy_port - 1) / _TD2_PORTS_PER_XLP;
        if (si->port_speed_max[port] > 20000) {
            si->port_num_lanes[port] =  4;
        } else if (si->port_speed_max[port] > 10000) {
            si->port_num_lanes[port] =  2;
        } else {
            si->port_num_lanes[port] =  1;
        }
        if (phy_port < si->phy_port_base[1]) { /* X-pipe */
            SOC_PBMP_PORT_ADD(si->xpipe_pbm, port);
        } else { /* Y-pipe */
            SOC_PBMP_PORT_ADD(si->ypipe_pbm, port);
        }
    }

    /* Setup vector-based scheduler (VBS)
     * a.k.a high speed port scheduler (HSP) pbm */
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_l2p_mapping[port];
        if (phy_port == -1) { /* cpu, loopback, or unused port */
            continue;
        }
        if (si->port_speed_max[port] >= 100000 ||
            (si->port_speed_max[port] >= 40000 && si->frequency < 760) ||
            soc_property_port_get(unit, port, spn_PORT_SCHED_HSP, 0)) {
            SOC_PBMP_PORT_ADD(si->eq_pbm, port);
        }
    }

    /* Assign MMU port */
    for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
        mmu_port = pipe * _TD2_PORTS_PER_PIPE;
        /* First assign the lowest MMU port number for VBS (HSP) ports */
        pbmp = pipe ? si->ypipe_pbm : si->xpipe_pbm;
        SOC_PBMP_AND(pbmp, si->eq_pbm);
        SOC_PBMP_ITER(pbmp, port) {
            phy_port = si->port_l2p_mapping[port];
            si->port_p2m_mapping[phy_port] = mmu_port;
            mmu_port++;
        }
        /* Then assign the next lowest MMU port number for 40+G ports */
        for (index = 0; index < _TD2_PORTS_PER_PIPE; index += 4) {
            phy_port = 1 + pipe * _TD2_PORTS_PER_PIPE + index;
            port = si->port_p2l_mapping[phy_port];
            if (si->port_p2m_mapping[phy_port] == -1 &&
                si->port_speed_max[port] > 20000) {
                si->port_p2m_mapping[phy_port] = mmu_port;
                mmu_port++;
            }
        }
        /* Then assign the next lowest MMU port number for 20+G ports */
        for (index = 0; index < _TD2_PORTS_PER_PIPE; index += 2) {
            phy_port = 1 + pipe * _TD2_PORTS_PER_PIPE + index;
            port = si->port_p2l_mapping[phy_port];
            if (si->port_p2m_mapping[phy_port] == -1 &&
                si->port_speed_max[port] > 10000) {
                si->port_p2m_mapping[phy_port] = mmu_port;
                mmu_port++;
            }
        }
        /* Finally assign MMU port number for all other ports */
        for (index = 0; index < _TD2_PORTS_PER_PIPE; index++) {
            phy_port = 1 + pipe * _TD2_PORTS_PER_PIPE + index;
            port = si->port_p2l_mapping[phy_port];
            if (si->port_p2m_mapping[phy_port] == -1 &&
                si->port_speed_max[port] > 0) {
                si->port_p2m_mapping[phy_port] = mmu_port;
                mmu_port++;
            }
        }
    }

    if (soc_cm_debug_check(DK_VERBOSE)) {
        soc_cm_print("physical to mmu mapping:");
        for (index = 0; index < num_phy_port; index++) {
            if (index % 16 == 0) {
                soc_cm_print("\n    ");
            }
            soc_cm_print(" %3d", si->port_p2m_mapping[index]);
        }
        soc_cm_print("\n");
    }

    return SOC_E_NONE;
}

int
soc_trident2_chip_reset(int unit)
{
    soc_info_t *si;
    uint16 dev_id;
    uint8 rev_id;
    int skew_id;
    int max_frequency;
    uint32 rval, to_usec;
    soc_reg_t reg;
    int index;
    int l2_banks, l3_banks, l2_mode, l3_mode;
    int shared_l2_banks, shared_l3_banks;
    uint32 uft_bank_enable_bitmap;    
    int num_ecmp_rh_flowset_entries;
    int rh_table_config_encoding;
    soc_field_t fields[4];
    uint32 values[4];
    int freq_list_len, sel;
    int const *freq_list;
    static const int a1_freq_list[] = { 760, 660, 608, 518, 415 };
    static const int a2_793_freq_list[] = { 793, 760, 635, 537, 415 };
    static const int a2_635_freq_list[] = { 635, 608, 537, 518, 415 };
    static const soc_reg_t lcpll_ctrl1_reg[] = {
        TOP_XG_PLL0_CTRL_1r, TOP_XG_PLL1_CTRL_1r,
        TOP_XG_PLL2_CTRL_1r, TOP_XG_PLL3_CTRL_1r
    };
    static const soc_reg_t lcpll_ctrl3_reg[] = {
        TOP_XG_PLL0_CTRL_3r, TOP_XG_PLL1_CTRL_3r,
        TOP_XG_PLL2_CTRL_3r, TOP_XG_PLL3_CTRL_3r
    };
    static const soc_reg_t lcpll_ctrl4_reg[] = {
        TOP_XG_PLL0_CTRL_4r, TOP_XG_PLL1_CTRL_4r,
        TOP_XG_PLL2_CTRL_4r, TOP_XG_PLL3_CTRL_4r
    };
    static const soc_reg_t lcpll_status_reg[] = {
        TOP_XG_PLL0_STATUSr, TOP_XG_PLL1_STATUSr,
        TOP_XG_PLL2_STATUSr, TOP_XG_PLL3_STATUSr
    };

    si = &SOC_INFO(unit);

    soc_cm_get_id(unit, &dev_id, &rev_id);

    to_usec = SAL_BOOT_QUICKTURN ? (250 * MILLISECOND_USEC) :
                                   (10 * MILLISECOND_USEC);

    /*
     * SBUS ring and block number:
     * ring 0: IP(1)
     * ring 1: EP(2)
     * ring 2: MMU(3)
     * ring 3: PGW_CL0(6), CPORT0(14), XLPORT0(15)-XLPORT3(18)
     *         PGW_CL1(7), CPORT1(19), XLPORT4(20)-XLPORT7(23)
     * ring 4: PGW_CL2(8), CPORT2(24), XLPORT8(25)-XLPORT11(28)
     *         PGW_CL3(9), CPORT3(29), XLPORT12(30)-XLPORT15(33)
     * ring 5: OTPC(5), TOP(57), SER(58)
     * ring 6: PGW_CL4(10), CPORT4(34), XLPORT16(35)-XLPORT19(38)
     *         PGW_CL5(11), CPORT5(39), XLPORT20(40)-XLPORT23(43)
     * ring 7: PGW_CL6(12), CPORT6(44), XLPORT24(45)-XLPORT27(48)
     *         PGW_CL7(13), CPORT7(49), XLPORT28(50)-XLPORT31(53)
     */
    WRITE_CMIC_SBUS_RING_MAP_0_7r(unit, 0x33052100);
    WRITE_CMIC_SBUS_RING_MAP_8_15r(unit, 0x33776644);
    WRITE_CMIC_SBUS_RING_MAP_16_23r(unit, 0x33333333);
    WRITE_CMIC_SBUS_RING_MAP_24_31r(unit, 0x44444444);
    WRITE_CMIC_SBUS_RING_MAP_32_39r(unit, 0x66666644);
    WRITE_CMIC_SBUS_RING_MAP_40_47r(unit, 0x77776666);
    WRITE_CMIC_SBUS_RING_MAP_48_55r(unit, 0x00777777);
    WRITE_CMIC_SBUS_RING_MAP_56_63r(unit, 0x00000550);

    WRITE_CMIC_SBUS_TIMEOUTr(unit, 0x7d0);

    sal_usleep(to_usec);

    SOC_IF_ERROR_RETURN(READ_TOP_DEV_REV_IDr(unit, &rval));
    skew_id = soc_reg_field_get(unit, TOP_DEV_REV_IDr, rval, DEVICE_SKEWf);
    SOC_IF_ERROR_RETURN
        (soc_trident2_max_frequency_get(unit, dev_id, rev_id, skew_id,
                                        &max_frequency));

    if (si->frequency != max_frequency) {
        if (rev_id <= BCM56850_A1_REV_ID) {
            freq_list = a1_freq_list;
            freq_list_len = sizeof(a1_freq_list) / sizeof(int);
        } else {
            if (max_frequency == 793) {
                freq_list = a2_793_freq_list;
                freq_list_len = sizeof(a2_793_freq_list) / sizeof(int);
            } else {
                freq_list = a2_635_freq_list;
                freq_list_len = sizeof(a2_635_freq_list) / sizeof(int);
            }
        }
        for (sel = 1; sel < freq_list_len; sel++) { /* skip index 0 */
            if (si->frequency == freq_list[sel]) {
                break;
            }
        }
        if (sel < freq_list_len) {
            soc_cm_print("*** change CORE_CLK_FREQ_SEL to %d\n", sel);
            SOC_IF_ERROR_RETURN(READ_TOP_CORE_CLK_FREQ_SELr(unit, &rval));
            soc_reg_field_set(unit, TOP_CORE_CLK_FREQ_SELr, &rval,
                              SW_CORE_CLK_SEL_ENf, 1);
            SOC_IF_ERROR_RETURN(WRITE_TOP_CORE_CLK_FREQ_SELr(unit, rval));
            soc_reg_field_set(unit, TOP_CORE_CLK_FREQ_SELr, &rval,
                              CORE_CLK_FREQ_SELf, sel);
            SOC_IF_ERROR_RETURN(WRITE_TOP_CORE_CLK_FREQ_SELr(unit, rval));
            soc_reg_field_set(unit, TOP_CORE_CLK_FREQ_SELr, &rval, LOAD_ENf,
                              1);
            SOC_IF_ERROR_RETURN(WRITE_TOP_CORE_CLK_FREQ_SELr(unit, rval));
            soc_reg_field_set(unit, TOP_CORE_CLK_FREQ_SELr, &rval, LOAD_ENf,
                              0);
            SOC_IF_ERROR_RETURN(WRITE_TOP_CORE_CLK_FREQ_SELr(unit, rval));

            sal_usleep(to_usec);
        }
    }

    /* Program LCPLL frequency */
    for (index = 0; index < 4; index++) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, lcpll_ctrl1_reg[index],
                                    REG_PORT_ANY, PDIVf, 7));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, lcpll_ctrl3_reg[index],
                                    REG_PORT_ANY, CML_BYP_ENf, 1));
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, lcpll_ctrl4_reg[index],
                                    REG_PORT_ANY, NDIV_INTf, 140));
    }
    fields[0] = CMIC_TO_XG_PLL0_SW_OVWRf;
    values[0] = 1;
    fields[1] = CMIC_TO_XG_PLL1_SW_OVWRf;
    values[1] = 1;
    fields[2] = CMIC_TO_XG_PLL2_SW_OVWRf;
    values[2] = 1;
    fields[3] = CMIC_TO_XG_PLL3_SW_OVWRf;
    values[3] = 1;
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, TOP_MISC_CONTROLr, REG_PORT_ANY, 4,
                                 fields, values));

    rval = 0;

    /* Configure TS PLL */ 
    SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_2r(unit,&rval));
    soc_reg_field_set(unit, TOP_TS_PLL_CTRL_2r, &rval, PDIVf,
                      soc_property_get(unit, spn_PTP_TS_PLL_PDIV, 1));
    soc_reg_field_set(unit, TOP_TS_PLL_CTRL_2r, &rval, CH0_MDIVf,
                      soc_property_get(unit, spn_PTP_TS_PLL_MNDIV, 14));
    WRITE_TOP_TS_PLL_CTRL_2r(unit, rval);
    
    SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_3r(unit,&rval));    
    soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, NDIV_INTf,
                      soc_property_get(unit, spn_PTP_TS_PLL_N, 140));
    soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, NDIV_FRACf, 0);
    WRITE_TOP_TS_PLL_CTRL_3r(unit, rval);
    
    SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_4r(unit,&rval));
    soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, KAf,
                      soc_property_get(unit, spn_PTP_TS_KA, 2));
    soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, KIf,
                      soc_property_get(unit, spn_PTP_TS_KI, 4));
    soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, KPf,
                      soc_property_get(unit, spn_PTP_TS_KP, 9));
    soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, REFCLK_SELf, 1);
    WRITE_TOP_TS_PLL_CTRL_4r(unit, rval);
    
    /* Set 250Mhz (implies 4ns resolution) default timesync clock to 
       calculate assymentric delays */
    SOC_TIMESYNC_PLL_CLOCK_NS(unit) = (1/250 * 1000); /* clock period in nanoseconds */
     
    /* Configure BS PLL */
    SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_0r(unit,&rval));
    soc_reg_field_set(unit, TOP_BS_PLL_CTRL_0r, &rval, VCO_DIV2f,
                      1);  /* soc_property_get(unit, spn_BROAD_SYNC_VCO_DIV2, 1)); */
    WRITE_TOP_BS_PLL_CTRL_0r(unit, rval);

    SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_2r(unit,&rval));
    soc_reg_field_set(unit, TOP_BS_PLL_CTRL_2r, &rval, PDIVf,
                      soc_property_get(unit, spn_PTP_BS_PDIV, 1));
    soc_reg_field_set(unit, TOP_BS_PLL_CTRL_2r, &rval, CH0_MDIVf,
                      soc_property_get(unit, spn_PTP_BS_MNDIV, 175));
    WRITE_TOP_BS_PLL_CTRL_2r(unit, rval);

    SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_3r(unit,&rval));
    soc_reg_field_set(unit, TOP_BS_PLL_CTRL_3r, &rval, NDIV_INTf, 140);
    soc_reg_field_set(unit, TOP_BS_PLL_CTRL_3r, &rval, NDIV_FRACf, 0);
    WRITE_TOP_BS_PLL_CTRL_3r(unit, rval);

    SOC_IF_ERROR_RETURN(READ_TOP_BS_PLL_CTRL_4r(unit,&rval));
    soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, KAf,
                      soc_property_get(unit, spn_PTP_BS_KA, 2));
    soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, KIf,
                      soc_property_get(unit, spn_PTP_BS_KI, 4));
    soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, KPf,
                      soc_property_get(unit, spn_PTP_BS_KP, 9));
    soc_reg_field_set(unit, TOP_BS_PLL_CTRL_4r, &rval, REFCLK_SELf, 1);
    WRITE_TOP_BS_PLL_CTRL_4r(unit, rval);

    /* Bring LCPLL, time sync PLL, BroadSync PLL out of reset */
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_XG_PLL0_RST_Lf,
                      1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_XG_PLL1_RST_Lf,
                      1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_XG_PLL2_RST_Lf,
                      1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_XG_PLL3_RST_Lf,
                      1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_TS_PLL_RST_Lf,
                      1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL_RST_Lf,
                      1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    sal_usleep(to_usec);

    if (!SAL_BOOT_SIMULATION) {
        /* Check LCPLL lock status */
        for (index = 0; index < 4; index++) {
            reg = lcpll_status_reg[index];
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
            if (!soc_reg_field_get(unit, reg, rval, TOP_XGPLL_LOCKf)) {
                SOC_ERROR_PRINT((DK_ERR, "LCPLL %d not locked on unit %d "
                                 "status = 0x%08x\n", index, unit, rval));
            }
        }
        /* Check time sync lock status */
        reg = TOP_TS_PLL_STATUSr;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        if (!soc_reg_field_get(unit, reg, rval, PLL_LOCKf)) {
            SOC_ERROR_PRINT((DK_ERR, "TS_PLL %d not locked on unit %d "
                             "status = 0x%08x\n", index, unit, rval));
        }
        /* Check BroadSync lock status */
        reg = TOP_BS_PLL_STATUSr;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        if (!soc_reg_field_get(unit, reg, rval, PLL_LOCKf)) {
            SOC_ERROR_PRINT((DK_ERR, "BS_PLL %d not locked on unit %d "
                             "status = 0x%08x\n", index, unit, rval));
        }
    }

    /* De-assert LCPLL's post reset */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_XG_PLL0_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_XG_PLL1_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_XG_PLL2_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_XG_PLL3_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TS_PLL_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_BS_PLL_POST_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TEMP_MON_PEAK_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    sal_usleep(to_usec);

    /* Bring port blocks out of reset */
    rval = 0;
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP0_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP1_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP2_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP3_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP4_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP5_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP6_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_CLP7_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_TS_RST_Lf, 1);
    WRITE_TOP_SOFT_RESET_REGr(unit, rval);

    sal_usleep(to_usec);

    /* Bring IP, EP, and MMU blocks out of reset */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REGr(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_IP_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_EP_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_MMU_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REGr(unit, rval));

    sal_usleep(to_usec);

    SOC_IF_ERROR_RETURN
        (soc_trident2_hash_bank_count_get(unit, L2Xm, &l2_banks));
    SOC_IF_ERROR_RETURN
        (soc_trident2_hash_bank_count_get(unit, L3_ENTRY_ONLYm, &l3_banks));
    switch (l2_banks) {
    case 2: l2_mode = 4;
        break;
    case 3: l2_mode = 3;
        break;
    case 4: l2_mode = 2;
        break;
    case 5: l2_mode = 1;
        break;
    case 6: l2_mode = 0;
        break;
    default:
        return SOC_E_INTERNAL;
    }
    switch (l3_banks) {
    case 4: l3_mode = 4;
        break;
    case 5: l3_mode = 1;
        break;
    case 6: l3_mode = 2;
        break;
    case 7: l3_mode = 3;
        break;
    default:
        return SOC_E_INTERNAL;
    }
    SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, L2_TABLE_HASH_CONTROLr,
                                               REG_PORT_ANY, MODEf, l2_mode));
    SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, L3_TABLE_HASH_CONTROLr,
                                               REG_PORT_ANY, MODEf, l3_mode));

    if (soc_property_get(unit, spn_LOW_POWER, 0) && 
        soc_mem_index_max(unit, L3_DEFIP_ALPM_RAWm) == -1 ) {
        shared_l2_banks = l2_banks - 2;
        shared_l3_banks = l3_banks - 4;
        uft_bank_enable_bitmap = ((0x70 >> shared_l3_banks)&0xf) | ((1 << shared_l2_banks) - 1);
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, SHARED_TABLE_HASH_CONTROLr, 
                                                   REG_PORT_ANY, UFT_BANK_ENABLEf, 
                                                   uft_bank_enable_bitmap));
    }

    num_ecmp_rh_flowset_entries = soc_property_get(unit,
            spn_ECMP_RESILIENT_HASH_SIZE, 32768);
    switch (num_ecmp_rh_flowset_entries) {
        case 0:
            rh_table_config_encoding = 2;
            break;
        case 32768:
            rh_table_config_encoding = 0;
            break;
        case 65536:
            rh_table_config_encoding = 1;
            break;
        default:
            return SOC_E_CONFIG;
    }
    SOC_IF_ERROR_RETURN(soc_reg_field32_modify(unit, ENHANCED_HASHING_CONTROLr,
                REG_PORT_ANY, RH_FLOWSET_TABLE_CONFIG_ENCODINGf,
                rh_table_config_encoding));

    READ_TOP_PVTMON_CTRL_1r(unit, &rval);
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RESET_Nf, 1);
    WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RESET_Nf, 0);
    WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RESET_Nf, 1);
    WRITE_TOP_PVTMON_CTRL_1r(unit, rval);

    sal_usleep(1000);

    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TEMP_MON_PEAK_RST_Lf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TEMP_MON_PEAK_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    return SOC_E_NONE;
}

int
soc_trident2_tsc_reset(int unit)
{
    int blk, port;
    uint32 rval;

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        SOC_IF_ERROR_RETURN(soc_tsc_xgxs_reset(unit, port, 0));
    }

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);

        SOC_IF_ERROR_RETURN(READ_XLPORT_MAC_CONTROLr(unit, port, &rval));
        soc_reg_field_set(unit, XLPORT_MAC_CONTROLr, &rval, XMAC0_RESETf, 1);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MAC_CONTROLr(unit, port, rval));
        sal_udelay(10);
        soc_reg_field_set(unit, XLPORT_MAC_CONTROLr, &rval, XMAC0_RESETf, 0);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MAC_CONTROLr(unit, port, rval));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_clear_enabled_port_data(int unit)
{
    uint32 rval;
    uint64 rval64;
    int port, block, pgw;
    
    /* Some registers are implemented in memory, need to clear them in order
     * to have correct parity value */
    COMPILER_64_ZERO(rval64);
    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1r(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_2r(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_3r(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_EGR_PVLAN_EPORT_CONTROLr(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_EGR_SF_SRC_MODID_CHECKr(unit, port, rval64));
        SOC_IF_ERROR_RETURN(WRITE_EGR_1588_LINK_DELAY_64r(unit, port, rval64));
        SOC_IF_ERROR_RETURN(WRITE_EGR_FCOE_INVALID_CRC_FRAMESr(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_EGR_FCOE_DELIMITER_ERROR_FRAMESr(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_EGR_IPMC_CFG2r(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_ING_TRILL_ADJACENCYr(unit, port, rval64));
        SOC_IF_ERROR_RETURN(WRITE_STORM_CONTROL_METER_CONFIGr(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_SFLOW_ING_THRESHOLDr(unit, port, 0));
    }
    rval = 0;
    soc_reg_field_set(unit, PGW_MIB_RESETr, &rval, CLR_CNTf, 0xffff);
    for (pgw = 0; pgw < 8; pgw++) {
        block = PGW_CL_BLOCK(unit, pgw);
        port = SOC_BLOCK_PORT(unit, block);
        if (port < 0) { /* the PGW_CL block is not in use */
            continue;
        }
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, PGW_MIB_RESETr, port, 0, rval));
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, PGW_MIB_RESETr, port, 0, 0));
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_clear_all_port_data(int unit)
{
    int r, p;
    uint32 addr;
    
    SOC_IF_ERROR_RETURN(_soc_trident2_clear_enabled_port_data(unit));
    
    /* Clear TDBGCn regs for all indexes */
    for (r = 0; r < 12; r++) {
        addr = 0x28000000 + r*0x100;
        for (p = 0; p < 106; p++) {
            _soc_reg32_set(unit, 0x2, 1, addr+p, 0);
            _soc_reg32_set(unit, 0x2, 2, addr+p, 0);
        }
    }

    /* Clear EGR_TRILL_TX_PKTS */
    addr = 0x28000c00;
    for (p = 0; p < 106; p++) {
        _soc_reg32_set(unit, 0x2, 1, addr+p, 0);
        _soc_reg32_set(unit, 0x2, 2, addr+p, 0);
    }
    /* Clear EGR_TRILL_TX_ACCESS_PORT_TRILL_PKTS_DISCARDED */
    addr = 0x28000d00;
    for (p = 0; p < 106; p++) {
        _soc_reg32_set(unit, 0x2, 1, addr+p, 0);
        _soc_reg32_set(unit, 0x2, 2, addr+p, 0);
    }
    /* Clear EGR_TRILL_TX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED */
    addr = 0x28000e00;
    for (p = 0; p < 106; p++) {
        _soc_reg32_set(unit, 0x2, 1, addr+p, 0);
        _soc_reg32_set(unit, 0x2, 2, addr+p, 0);
    }
    /* Clear TPCE */
    addr = 0x28000f00;
    for (p = 0; p < 106; p++) {
        _soc_reg32_set(unit, 0x2, 1, addr+p, 0);
        _soc_reg32_set(unit, 0x2, 2, addr+p, 0);
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_mmu_init_default_val(int unit)
{
    soc_mem_t           mem0, mem1;
    uint32              entry[SOC_MAX_MEM_WORDS];
    int                 index, unused_idx;

    /* Set LLS_Port memory. Point to Un-used L0 node.*/
    mem0 = ES_PIPE0_LLS_PORT_HEADS_TAILSm;
    mem1 = ES_PIPE1_LLS_PORT_HEADS_TAILSm;
    sal_memset(entry, 0, sizeof(entry));
    unused_idx = 267;
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_EF_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_EF_TAILf, unused_idx);
    for (index = 0; index < soc_mem_index_count(unit, mem0); index++) {
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem0, MEM_BLOCK_ALL, index, entry));
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, index, entry));
    }
    
    /* Set LLS_L0 memory. Point to Un-used L1 node.*/
    mem0 = ES_PIPE0_LLS_L0_HEADS_TAILSm;
    mem1 = ES_PIPE1_LLS_L0_HEADS_TAILSm;
    sal_memset(entry, 0, sizeof(entry));
    unused_idx = 1023;
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_EF_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_EF_TAILf, unused_idx);
    for (index = 0; index < soc_mem_index_count(unit, mem0); index++) {
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem0, MEM_BLOCK_ALL, index, entry));
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, index, entry));
    }
    
    /* Set LLS_L1 memory. Point to Un-used L2 child.*/
    mem0 = ES_PIPE0_LLS_L1_HEADS_TAILSm;
    mem1 = ES_PIPE1_LLS_L1_HEADS_TAILSm;
    sal_memset(entry, 0, sizeof(entry));
    unused_idx = 1479;
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_LIST_HEADf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST0_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_WRR_LIST1_TAILf, unused_idx);
    soc_mem_field32_set(unit, mem0, entry, P_MIN_LIST_TAILf, unused_idx);
    for (index = 0; index < soc_mem_index_count(unit, mem0); index++) {
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem0, MEM_BLOCK_ALL, index, entry));
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, index, entry));
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_clear_all_memory(int unit)
{
    uint32              rval, in_progress;
    int                 pipe_init_usec, index, count;
    soc_timeout_t       to;
    static const struct {
        soc_mem_t mem;
        uint32 skip_flags; /* always skip on QUICKTURN or XGSSIM */
    } cam_list[] = {
        { CPU_COS_MAPm,                     BOOT_F_PLISIM },
        { EFP_TCAMm,                        BOOT_F_PLISIM },
        { FP_GLOBAL_MASK_TCAMm,             BOOT_F_PLISIM },
        { FP_TCAMm,                         BOOT_F_PLISIM },
        { FP_UDF_TCAMm,                     BOOT_F_PLISIM },
        { ING_SNATm,                        BOOT_F_PLISIM },
        { IP_MULTICAST_TCAMm,               BOOT_F_PLISIM },
        { L2_USER_ENTRYm,                   BOOT_F_PLISIM },
        { L3_DEFIPm,                        BOOT_F_PLISIM },
        { L3_DEFIP_PAIR_128m,               BOOT_F_PLISIM },
        { L3_TUNNELm,                       BOOT_F_PLISIM },
        { MY_STATION_TCAMm,                 BOOT_F_PLISIM },
        { UDF_CONDITIONAL_CHECK_TABLE_CAMm, BOOT_F_PLISIM },
        { VFP_TCAMm,                        BOOT_F_PLISIM },
        { VLAN_SUBNETm,                     0 },/* VLAN API needs all 0 mask */
#ifdef PLISIM
        /* In HW, these are the same as FP_GLOBAL_MASK_TCAM.
         * In simulation, they are separate instances.
         */
        { FP_GM_FIELDSm,                    BOOT_F_PLISIM },
        { FP_GLOBAL_MASK_TCAM_Xm,           BOOT_F_PLISIM },
        { FP_GLOBAL_MASK_TCAM_Ym,           BOOT_F_PLISIM }
#endif
    };

    /* Start MMU memory initialization */
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, MISCCONFIGr, REG_PORT_ANY, INIT_MEMf, 1));
    
    SOC_IF_ERROR_RETURN
        (_soc_trident2_mmu_init_default_val(unit));

    /*
     * Reset the IPIPE and EPIPE block
     */
    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_1r(unit, rval));
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, VALIDf, 1);
    /* Set count to # entries of largest IPIPE table */
    count = soc_mem_index_count(unit, RH_HGT_FLOWSETm);
    if (count < soc_mem_index_count(unit, L2Xm)) {
        count = soc_mem_index_count(unit, L2Xm);
    }
    if (count < soc_mem_index_count(unit, L3_ENTRY_ONLYm)) {
        count = soc_mem_index_count(unit, L3_ENTRY_ONLYm);
    }
    if (count < soc_mem_index_count(unit, L3_DEFIP_ALPM_IPV4m)) {
        count = soc_mem_index_count(unit, L3_DEFIP_ALPM_IPV4m);
    }
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, COUNTf, count);
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_0r(unit, rval));
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, VALIDf, 1);
    /* Set count to # entries of largest EPIPE table (EGR_L3_NEXT_HOP) */
    count = soc_mem_index_count(unit, EGR_L3_NEXT_HOPm);
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, COUNTf, count);
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    /* For simulation, set timeout to 10 sec.  Otherwise, timeout = 50 ms */
    if (SAL_BOOT_SIMULATION) {
        pipe_init_usec = 10000000;
    } else {
        pipe_init_usec = 50000;
    }
    soc_timeout_init(&to, pipe_init_usec, 0);

    /* Wait for IPIPE memory initialization done. */
    in_progress = 3;
    do {
        if (in_progress & 0x1) { /* X pipe not done yet */
            SOC_IF_ERROR_RETURN(READ_ING_HW_RESET_CONTROL_2_Xr(unit, &rval));
            if (soc_reg_field_get(unit, ING_HW_RESET_CONTROL_2_Xr, rval,
                                  DONEf)) {
                in_progress &= ~0x1;
            }
        }
        if (in_progress & 0x2) { /* Y pipe not done yet */
            SOC_IF_ERROR_RETURN(READ_ING_HW_RESET_CONTROL_2_Yr(unit, &rval));
            if (soc_reg_field_get(unit, ING_HW_RESET_CONTROL_2_Yr, rval,
                                  DONEf)) {
                in_progress &= ~0x2;
            }
        }
        if (soc_timeout_check(&to)) {
            soc_cm_debug(DK_WARN, "unit %d : ING_HW_RESET timeout\n", unit);
            break;
        }
    } while (in_progress != 0);

    /* Wait for EPIPE memory initialization done. */
    in_progress = 3;
    do {
        if (in_progress & 0x1) { /* X pipe not done yet */
            SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1_Xr(unit, &rval));
            if (soc_reg_field_get(unit, EGR_HW_RESET_CONTROL_1_Xr, rval,
                                  DONEf)) {
                in_progress &= ~0x1;
            }
        }
        if (in_progress & 0x2) { /* Y pipe not done yet */
            SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1_Yr(unit, &rval));
            if (soc_reg_field_get(unit, EGR_HW_RESET_CONTROL_1_Yr, rval,
                                  DONEf)) {
                in_progress &= ~0x2;
            }
        }
        if (soc_timeout_check(&to)) {
            soc_cm_debug(DK_WARN, "unit %d : EGR_HW_RESET timeout\n", unit);
            break;
        }
    } while (in_progress != 0);

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    /* TCAM tables are not handled by hardware reset control */
    if (!SAL_BOOT_QUICKTURN && !SAL_BOOT_XGSSIM) {
        for (index = 0; index < sizeof(cam_list) / sizeof(cam_list[0]);
             index++) {
            if (sal_boot_flags_get() & cam_list[index].skip_flags) {
                continue;
            }
            SOC_IF_ERROR_RETURN
                (soc_mem_clear(unit, cam_list[index].mem, COPYNO_ALL, TRUE));
        }
    }
    return SOC_E_NONE;
}

STATIC int
_soc_trident2_port_mapping_init(int unit)
{
    soc_info_t *si;
    soc_mem_t mem;
    uint32 rval;
    ing_physical_to_logical_port_number_mapping_table_entry_t entry;
    int port, phy_port;
    int num_port, num_phy_port;

    si = &SOC_INFO(unit);

    /* Ingress physical to logical port mapping */
    mem = ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm;
    num_phy_port = soc_mem_index_count(unit, mem);
    sal_memset(&entry, 0, sizeof(entry));
    for (phy_port = 0; phy_port < num_phy_port; phy_port++) {
        port = si->port_p2l_mapping[phy_port];
        soc_mem_field32_set(unit, mem, &entry, LOGICAL_PORT_NUMBERf,
                            port == -1 ? 0x7f : port);
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem, MEM_BLOCK_ALL, phy_port, &entry));
    }

    /* Ingress logical to physical port mapping */
    num_port = soc_mem_index_count(unit, PORT_TABm) - 1;
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_l2p_mapping[port];
        rval = 0;
        if (phy_port != -1) {
            soc_reg_field_set(unit, IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr, &rval,
                              VALIDf, 1);
            if (SOC_PBMP_MEMBER(si->ypipe_pbm, port)) { /* Y pipe */
                soc_reg_field_set(unit, IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr,
                                  &rval, Y_PIPEf, 1);
            }
            /* IFP_GM_LOGICAL_TO_PHYSICAL_MAPP?ING.PHYSICAL_PORT_NUM is
             * merely a unique stream ID, it's not physical port number */
            soc_reg_field_set(unit, IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr, &rval,
                              PHYSICAL_PORT_NUMf,
                              si->port_p2m_mapping[phy_port] & 0x3f);
        }
        SOC_IF_ERROR_RETURN
            (WRITE_IFP_GM_LOGICAL_TO_PHYSICAL_MAPPINGr(unit, port, rval));
    }

    /* Egress logical to physical port mapping */
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_l2p_mapping[port];
        rval = 0;
        soc_reg_field_set(unit, EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr,
                          &rval, PHYSICAL_PORT_NUMBERf,
                          phy_port == -1 ? 0xff : phy_port);
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr(unit, port,
                                                                rval));
    }

    /* MMU to physical port mapping and MMU to logical port mapping */
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_l2p_mapping[port];
        if (phy_port == -1) {
            continue;
        }
        rval = 0;
        soc_reg_field_set(unit, MMU_PORT_TO_PHY_PORT_MAPPINGr, &rval,
                          PHY_PORTf, phy_port);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, MMU_PORT_TO_PHY_PORT_MAPPINGr, port, 0,
                           rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_PORT_TO_LOGIC_PORT_MAPPINGr, &rval,
                          LOGIC_PORTf, port);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, MMU_PORT_TO_LOGIC_PORT_MAPPINGr, port, 0,
                           rval));
    }

    return SOC_E_NONE;
}

#define _PGW_MASTER_COUNT               4
#define _PGW_TDM_LENGTH                 32
#define _PGW_TDM_SLOTS_PER_REG          4
#define _MMU_TDM_LENGTH                 256
#define _MMU_OVS_GROUP_COUNT            4
#define _MMU_OVS_GROUP_TDM_LENGTH       16
#define _IARB_TDM_LENGTH                512

#define NUM_EXT_PORTS 130
#define OVS_TOKEN (NUM_EXT_PORTS+1)
#define IDL_TOKEN (NUM_EXT_PORTS+2)
#define MGM_TOKEN (NUM_EXT_PORTS+3)

#define PORT_STATE_UNUSED              0
#define PORT_STATE_LINERATE            1
#define PORT_STATE_OVERSUB             2
#define PORT_STATE_SUBPORT             3 /* part of other port */

typedef struct _soc_trident2_tdm_s {
    int speed[NUM_EXT_PORTS];
    int tdm_bw;
    int port_state[NUM_EXT_PORTS]; /* 0-unused, 1-line rate, 2-oversub,
                                    * 3-part of other port */
    int pipe_ovs_state[2];
    int manage_port_type; /* 0-none, 1-4x1g, 2-4x2.5g, 3-1x10g */

    int pgw_tdm[_PGW_MASTER_COUNT][_PGW_TDM_LENGTH];
    int pgw_ovs_tdm[_PGW_MASTER_COUNT][_PGW_TDM_LENGTH];
    int pgw_ovs_spacing[_PGW_MASTER_COUNT][_PGW_TDM_LENGTH];
    int mmu_tdm[2][_MMU_TDM_LENGTH + 1];
    int mmu_ovs_group_tdm[2][_MMU_OVS_GROUP_COUNT][_MMU_OVS_GROUP_TDM_LENGTH];
    int iarb_tdm_wrap_ptr[2];
    int iarb_tdm[2][_IARB_TDM_LENGTH];
} _soc_trident2_tdm_t;
_soc_trident2_tdm_t _soc_td2_tdm;

STATIC int
_soc_trident2_tdm_init(int unit)
{
    soc_info_t *si;
    int rv;
    soc_pbmp_t pbmp;
    int port, phy_port, mmu_port, block, obm_inst;
    int pipe, pgw, xlp, tsc, group, slot, base, index, count, id;
    int lossless;
    int speed_max, weight;
    int mtu_cells, res_cells, port_cells;
    uint32 xlport_map;
    soc_reg_t reg;
    soc_mem_t mem;
    uint64 rval64, ctrl_rval64;
    uint32 rval;
    uint32 entry[SOC_MAX_MEM_WORDS];
    soc_field_t fields[4];
    uint32 values[4];
    int bandwidth, max_quad_core_bandwidth, quad_oversub_core_bandwidth;
    int quad_linerate_bandwidth, quad_oversub_bandwidth;
    uint16 dev_id;
    uint8 rev_id;
    int obm_setting_idx, oversub_ratio_idx;
    int min_threshold, xoff_threshold, xon_threshold, xon_threshold_offset;
    static const struct _obm_setting_s {
        int max_threshold;
        int xoff_threshold[3]; /* for oversub ratio 1.27, 1.43, and above */
    } obm_settings[] = {
        { _TD2_CELLS_PER_OBM / 4, { 79, 26, 37 } },      /* 10G */
        { _TD2_CELLS_PER_OBM / 2, { 315, 242, 86 } },    /* 20G */
        { _TD2_CELLS_PER_OBM, { 707, 584, 339 } }        /* 40G */
    };
    static const struct _obm_setting_a1_s {
        int xoff_threshold[3]; /* for oversub ratio 1.33, 1.5, and above */
        int mtu_cells[3];      /* for oversub ratio 1.33, 1.5, and above */
    } obm_settings_a1[] = {
        { /* 10G */
            { 56, 40, 23 },
            { 5 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              3 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              2 * 1024 / _TD2_BYTES_PER_OBM_CELL }
        },
        { /* 20G */
            { 215, 115, 60 },
            { 9 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              9 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              6 * 1024 / _TD2_BYTES_PER_OBM_CELL }
        },
        { /* 40G */
            { 661, 543, 306 },
            { 9 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              9 * 1024 / _TD2_BYTES_PER_OBM_CELL,
              9 * 1024 / _TD2_BYTES_PER_OBM_CELL }
        }
    };
    static const soc_reg_t pgw_tdm_regs[] = {
        PGW_LR_TDM_REG_0r, PGW_LR_TDM_REG_1r,
        PGW_LR_TDM_REG_2r, PGW_LR_TDM_REG_3r,
        PGW_LR_TDM_REG_4r, PGW_LR_TDM_REG_5r,
        PGW_LR_TDM_REG_6r, PGW_LR_TDM_REG_7r
    };
    static const soc_reg_t pgw_ovs_tdm_regs[] = {
        PGW_OS_TDM_REG_0r, PGW_OS_TDM_REG_1r,
        PGW_OS_TDM_REG_2r, PGW_OS_TDM_REG_3r,
        PGW_OS_TDM_REG_4r, PGW_OS_TDM_REG_5r,
        PGW_OS_TDM_REG_6r, PGW_OS_TDM_REG_7r
    };
    static const soc_reg_t pgw_ovs_spacing_regs[] = {
        PGW_OS_PORT_SPACING_REG_0r, PGW_OS_PORT_SPACING_REG_1r,
        PGW_OS_PORT_SPACING_REG_2r, PGW_OS_PORT_SPACING_REG_3r,
        PGW_OS_PORT_SPACING_REG_4r, PGW_OS_PORT_SPACING_REG_5r,
        PGW_OS_PORT_SPACING_REG_6r, PGW_OS_PORT_SPACING_REG_7r
    };
    static const soc_reg_t pgw_obm_ctrl_regs[] = {
        PGW_OBM0_CONTROLr, PGW_OBM1_CONTROLr,
        PGW_OBM2_CONTROLr, PGW_OBM3_CONTROLr
    };
    static const soc_reg_t pgw_obm_priority_map_regs[] = {
        PGW_OBM0_PRIORITY_MAPr, PGW_OBM1_PRIORITY_MAPr,
        PGW_OBM2_PRIORITY_MAPr, PGW_OBM3_PRIORITY_MAPr
    };
    static const soc_reg_t pgw_obm_shared_config_regs[] = {
        PGW_OBM0_SHARED_CONFIGr, PGW_OBM1_SHARED_CONFIGr,
        PGW_OBM2_SHARED_CONFIGr, PGW_OBM3_SHARED_CONFIGr
    };
    static const soc_reg_t pgw_obm_threshold_regs[] = {
        PGW_OBM0_THRESHOLDr, PGW_OBM1_THRESHOLDr,
        PGW_OBM2_THRESHOLDr, PGW_OBM3_THRESHOLDr
    };
    static const soc_reg_t pgw_obm_fc_config_regs[] = {
        PGW_OBM_PORT0_FC_CONFIGr, PGW_OBM_PORT1_FC_CONFIGr,
        PGW_OBM_PORT2_FC_CONFIGr, PGW_OBM_PORT3_FC_CONFIGr,
        PGW_OBM_PORT4_FC_CONFIGr, PGW_OBM_PORT5_FC_CONFIGr,
        PGW_OBM_PORT6_FC_CONFIGr, PGW_OBM_PORT7_FC_CONFIGr,
        PGW_OBM_PORT8_FC_CONFIGr, PGW_OBM_PORT9_FC_CONFIGr,
        PGW_OBM_PORT10_FC_CONFIGr, PGW_OBM_PORT11_FC_CONFIGr,
        PGW_OBM_PORT12_FC_CONFIGr, PGW_OBM_PORT13_FC_CONFIGr,
        PGW_OBM_PORT14_FC_CONFIGr, PGW_OBM_PORT15_FC_CONFIGr
    };
    static const soc_field_t pgw_tdm_fields[] = {
        TDM_ENTRY0_PORT_IDf, TDM_ENTRY1_PORT_IDf,
        TDM_ENTRY2_PORT_IDf, TDM_ENTRY3_PORT_IDf,
        TDM_ENTRY4_PORT_IDf, TDM_ENTRY5_PORT_IDf,
        TDM_ENTRY6_PORT_IDf, TDM_ENTRY7_PORT_IDf,
        TDM_ENTRY8_PORT_IDf, TDM_ENTRY9_PORT_IDf,
        TDM_ENTRY10_PORT_IDf, TDM_ENTRY11_PORT_IDf,
        TDM_ENTRY12_PORT_IDf, TDM_ENTRY13_PORT_IDf,
        TDM_ENTRY14_PORT_IDf, TDM_ENTRY15_PORT_IDf,
        TDM_ENTRY16_PORT_IDf, TDM_ENTRY17_PORT_IDf,
        TDM_ENTRY18_PORT_IDf, TDM_ENTRY19_PORT_IDf,
        TDM_ENTRY20_PORT_IDf, TDM_ENTRY21_PORT_IDf,
        TDM_ENTRY22_PORT_IDf, TDM_ENTRY23_PORT_IDf,
        TDM_ENTRY24_PORT_IDf, TDM_ENTRY25_PORT_IDf,
        TDM_ENTRY26_PORT_IDf, TDM_ENTRY27_PORT_IDf,
        TDM_ENTRY28_PORT_IDf, TDM_ENTRY29_PORT_IDf,
        TDM_ENTRY30_PORT_IDf, TDM_ENTRY31_PORT_IDf
    };
    static const soc_field_t pgw_spacing_fields[] = {
        SLOT0f, SLOT1f, SLOT2f, SLOT3f, SLOT4f, SLOT5f, SLOT6f, SLOT7f,
        SLOT8f, SLOT9f, SLOT10f, SLOT11f, SLOT12f, SLOT13f, SLOT14f, SLOT15f,
        SLOT16f, SLOT17f, SLOT18f, SLOT19f, SLOT20f, SLOT21f, SLOT22f, SLOT23f,
        SLOT24f, SLOT25f, SLOT26f, SLOT27f, SLOT28f, SLOT29f, SLOT30f, SLOT31f
    };
    static const soc_field_t pgw_obm_bypass_fields[] = {
        PORT0_BYPASS_ENABLEf, PORT1_BYPASS_ENABLEf,
        PORT2_BYPASS_ENABLEf, PORT3_BYPASS_ENABLEf
    };
    static const soc_field_t pgw_obm_oversub_fields[] = {
        PORT0_OVERSUB_ENABLEf, PORT1_OVERSUB_ENABLEf,
        PORT2_OVERSUB_ENABLEf, PORT3_OVERSUB_ENABLEf
    };
    static const soc_mem_t mmu_tdm_regs[2] ={
        ES_PIPE0_TDM_CONFIGr, ES_PIPE1_TDM_CONFIGr
    };
    static const soc_mem_t mmu_tdm_mems[2] ={
        ES_PIPE0_TDM_TABLE_0m, ES_PIPE1_TDM_TABLE_0m
    };
    static const soc_reg_t mmu_ovs_group_cfg_regs[] = {
        ES_PIPE0_OVR_SUB_GRP_CFGr, ES_PIPE1_OVR_SUB_GRP_CFGr
    };
    static const soc_reg_t mmu_ovs_group_regs[2][_MMU_OVS_GROUP_COUNT] = {
        {
            ES_PIPE0_OVR_SUB_GRP0_TBLr, ES_PIPE0_OVR_SUB_GRP1_TBLr,
            ES_PIPE0_OVR_SUB_GRP2_TBLr, ES_PIPE0_OVR_SUB_GRP3_TBLr
        },
        {
            ES_PIPE1_OVR_SUB_GRP0_TBLr, ES_PIPE1_OVR_SUB_GRP1_TBLr,
            ES_PIPE1_OVR_SUB_GRP2_TBLr, ES_PIPE1_OVR_SUB_GRP3_TBLr
        }
    };
    static const soc_reg_t mmu_ovs_group_wt_regs[2][_MMU_OVS_GROUP_COUNT] = {
        {
            ES_PIPE0_OVR_SUB_GRP0_WTr, ES_PIPE0_OVR_SUB_GRP1_WTr,
            ES_PIPE0_OVR_SUB_GRP2_WTr, ES_PIPE0_OVR_SUB_GRP3_WTr
        },
        {
            ES_PIPE1_OVR_SUB_GRP0_WTr, ES_PIPE1_OVR_SUB_GRP1_WTr,
            ES_PIPE1_OVR_SUB_GRP2_WTr, ES_PIPE1_OVR_SUB_GRP3_WTr
        }
    };
    static const soc_field_t xlp_cell_asf_thresh_fields[] = {
        XLP0_CELL_ASM_CUT_THRU_THRESHOLDf, XLP1_CELL_ASM_CUT_THRU_THRESHOLDf,
        XLP2_CELL_ASM_CUT_THRU_THRESHOLDf, XLP3_CELL_ASM_CUT_THRU_THRESHOLDf
    };
    static const soc_mem_t iarb_tdm_mems[2] ={
        IARB_MAIN_TDM_Xm, IARB_MAIN_TDM_Ym
    };

    soc_cm_get_id(unit, &dev_id, &rev_id);

    lossless = soc_property_get(unit, spn_MMU_LOSSLESS, 1);

    sal_memset(&_soc_td2_tdm, 0, sizeof(_soc_td2_tdm));

    si = &SOC_INFO(unit);

    PBMP_PORT_ITER(unit, port) {
        if (SOC_PBMP_MEMBER(si->all.disabled_bitmap, port)) {
            continue;
        }
        phy_port = si->port_l2p_mapping[port];
        _soc_td2_tdm.speed[phy_port] = si->port_speed_max[port];
        _soc_td2_tdm.port_state[phy_port] =
            SOC_PBMP_MEMBER(si->oversub_pbm, port) ?
            PORT_STATE_OVERSUB : PORT_STATE_LINERATE;
        if (_soc_td2_tdm.speed[phy_port] >= 40000) {
            _soc_td2_tdm.port_state[phy_port + 1] = PORT_STATE_SUBPORT;
            _soc_td2_tdm.port_state[phy_port + 2] = PORT_STATE_SUBPORT;
            _soc_td2_tdm.port_state[phy_port + 3] = PORT_STATE_SUBPORT;
        } else if (_soc_td2_tdm.speed[phy_port] >= 20000) {
            _soc_td2_tdm.port_state[phy_port + 1] = PORT_STATE_SUBPORT;
        }
    }

    _soc_td2_tdm.speed[0] = 1000;
    _soc_td2_tdm.speed[129] = 1000;
    _soc_td2_tdm.tdm_bw = si->bandwidth / 1000;
    SOC_PBMP_ASSIGN(pbmp, si->oversub_pbm);
    SOC_PBMP_AND(pbmp, si->xpipe_pbm);
    if (_soc_td2_tdm.tdm_bw == 720) { /* 720g special handling */
        /* tell tdm code the pipe is oversub only if all ports are oversub */
        SOC_PBMP_PORT_ADD(pbmp, 0); /* cpu port */
        _soc_td2_tdm.pipe_ovs_state[0] = SOC_PBMP_EQ(pbmp, si->xpipe_pbm);
    } else {
        /* tell tdm code the pipe is oversub if any ports is oversub */
        _soc_td2_tdm.pipe_ovs_state[0] = SOC_PBMP_NOT_NULL(pbmp);
    }
    SOC_PBMP_ASSIGN(pbmp, si->oversub_pbm);
    SOC_PBMP_AND(pbmp, si->ypipe_pbm);
    if (_soc_td2_tdm.tdm_bw == 720) { /* 720g special handling */
        /* tell tdm code the pipe is oversub only if all ports are oversub */
        SOC_PBMP_PORT_ADD(pbmp, 105); /* loopback port */
        _soc_td2_tdm.pipe_ovs_state[1] = SOC_PBMP_EQ(pbmp, si->ypipe_pbm);
    } else {
        /* tell tdm code the pipe is oversub if any ports is oversub */
        _soc_td2_tdm.pipe_ovs_state[1] = SOC_PBMP_NOT_NULL(pbmp);
    }
    _soc_td2_tdm.manage_port_type = 0;
    if (SOC_PBMP_NOT_NULL(si->management_pbm)) {
        speed_max = 0;
        for (phy_port = 13; phy_port <= 16; phy_port++) {
            port = si->port_p2l_mapping[phy_port];
            if (port == -1) {
                continue;
            }
            if (speed_max < si->port_speed_max[port]) {
                speed_max = si->port_speed_max[port];
            }
        }
        if (speed_max <= 1000) {
            _soc_td2_tdm.manage_port_type = 1; /* 4 x 1g */
        } else if (speed_max <= 2500) {
            _soc_td2_tdm.manage_port_type = 2; /* 4 * 2.5g */
        } else {
            _soc_td2_tdm.manage_port_type = 3; /* 1 x 10g */
        }
        if (_soc_td2_tdm.manage_port_type > 0) {
            _soc_td2_tdm.pgw_tdm[0][0] = 1234; /* magic number used by
                                                * tdm code */
        }
    }
    _soc_td2_tdm.mmu_tdm[0][_MMU_TDM_LENGTH] = NUM_EXT_PORTS;
    _soc_td2_tdm.mmu_tdm[1][_MMU_TDM_LENGTH] = NUM_EXT_PORTS;

    if (SOC_DEBUG_CHECK(SOC_DBG_TDM)) {
        soc_cm_print("tdm_bw: %dG\n", _soc_td2_tdm.tdm_bw);
        soc_cm_print("port speed:");
        for (index = 0; index < NUM_EXT_PORTS; index++) {
            if (index % 8 == 0) {
                soc_cm_print("\n    ");
            }
            soc_cm_print(" %6d", _soc_td2_tdm.speed[index]);
        }
        soc_cm_print("\n");
        soc_cm_print("port state map:");
        for (index = 0; index < NUM_EXT_PORTS; index++) {
            if (index % 16 == 0) {
                soc_cm_print("\n    ");
            }
            if (index == 0 || index == (NUM_EXT_PORTS - 1)) {
                soc_cm_print(" ---");
            } else {
                soc_cm_print(" %3d", _soc_td2_tdm.port_state[index]);
            }
        }
        soc_cm_print("\n");
    }

    rv = set_tdm_tbl(_soc_td2_tdm.speed, _soc_td2_tdm.tdm_bw,
                     _soc_td2_tdm.pgw_tdm[0],
                     _soc_td2_tdm.pgw_ovs_tdm[0],
                     _soc_td2_tdm.pgw_ovs_spacing[0],
                     _soc_td2_tdm.pgw_tdm[1],
                     _soc_td2_tdm.pgw_ovs_tdm[1],
                     _soc_td2_tdm.pgw_ovs_spacing[1],
                     _soc_td2_tdm.pgw_tdm[2],
                     _soc_td2_tdm.pgw_ovs_tdm[2],
                     _soc_td2_tdm.pgw_ovs_spacing[2],
                     _soc_td2_tdm.pgw_tdm[3],
                     _soc_td2_tdm.pgw_ovs_tdm[3],
                     _soc_td2_tdm.pgw_ovs_spacing[3],
                     _soc_td2_tdm.mmu_tdm[0],
                     _soc_td2_tdm.mmu_ovs_group_tdm[0][0],
                     _soc_td2_tdm.mmu_ovs_group_tdm[0][1],
                     _soc_td2_tdm.mmu_ovs_group_tdm[0][2],
                     _soc_td2_tdm.mmu_ovs_group_tdm[0][3],
                     _soc_td2_tdm.mmu_tdm[1],
                     _soc_td2_tdm.mmu_ovs_group_tdm[1][0],
                     _soc_td2_tdm.mmu_ovs_group_tdm[1][1],
                     _soc_td2_tdm.mmu_ovs_group_tdm[1][2],
                     _soc_td2_tdm.mmu_ovs_group_tdm[1][3],
                     &_soc_td2_tdm.port_state[1], /* skip cpu port */
                     _soc_td2_tdm.iarb_tdm[0],
                     _soc_td2_tdm.iarb_tdm[1]);
    if (rv == 0) {
        soc_cm_print("Unable to configure TDM, please contact your "
                     "Field Applications Engineer or Sales Manager for "
                     "additional assistance.\n");
        return SOC_E_FAIL;
    }

    if (SOC_DEBUG_CHECK(SOC_DBG_TDM)) {
        for (pgw = 0; pgw < _TD2_PGWS_PER_DEV; pgw += _TD2_PGWS_PER_QUAD) {
            soc_cm_print("PGW_CL%d pgw_tdm:", pgw);
            for (index = 0; index < _PGW_TDM_LENGTH; index++) {
                if (index % 16 == 0) {
                    soc_cm_print("\n    ");
                }
                soc_cm_print(" %3d", _soc_td2_tdm.pgw_tdm[pgw / 2][index]);
            }
            soc_cm_print("\n");
            soc_cm_print("PGW_CL%d pgw_ovs_tdm:", pgw);
            for (index = 0; index < _PGW_TDM_LENGTH; index++) {
                if (index % 16 == 0) {
                    soc_cm_print("\n    ");
                }
                soc_cm_print(" %3d", _soc_td2_tdm.pgw_ovs_tdm[pgw / 2][index]);
            }
            soc_cm_print("\n");
            soc_cm_print("PGW_CL%d pgw_ovs_spacing:", pgw);
            for (index = 0; index < _PGW_TDM_LENGTH; index++) {
                if (index % 16 == 0) {
                    soc_cm_print("\n    ");
                }
                soc_cm_print(" %3d",
                             _soc_td2_tdm.pgw_ovs_spacing[pgw / 2][index]);
            }
            soc_cm_print("\n");
        }
        for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
            soc_cm_print("Pipe %c mmu_tdm:", pipe ? 'y' : 'x');
            for (index = 0; index < _MMU_TDM_LENGTH; index++) {
                if (index % 16 == 0) {
                    soc_cm_print("\n    ");
                }
                soc_cm_print(" %3d", _soc_td2_tdm.mmu_tdm[pipe][index]);
            }
            soc_cm_print("\n");
            for (group = 0; group < _MMU_OVS_GROUP_COUNT; group++) {
                soc_cm_print("Pipe %c group %d ovs_group_tdm",
                             pipe ? 'y' : 'x', group);
                for (index = 0; index < _MMU_OVS_GROUP_TDM_LENGTH;
                     index++) {
                    if (index % 16 == 0) {
                        soc_cm_print("\n    ");
                    }
                    soc_cm_print(" %3d",
                                 _soc_td2_tdm.mmu_ovs_group_tdm[pipe][group][index]);
                }
                soc_cm_print("\n");
            }
        }
    }

    if (SOC_DEBUG_CHECK(SOC_DBG_TDM)) {
        soc_cm_print("tdm_bw: %dG\n", _soc_td2_tdm.tdm_bw);
        soc_cm_print("x pipe ovs state: %d\n", _soc_td2_tdm.pipe_ovs_state[0]);
        soc_cm_print("y pipe ovs state: %d\n", _soc_td2_tdm.pipe_ovs_state[1]);
        soc_cm_print("manage port type: %d\n", _soc_td2_tdm.manage_port_type);
    }
    rv = set_iarb_tdm_table(_soc_td2_tdm.tdm_bw,
                            _soc_td2_tdm.pipe_ovs_state[0],
                            _soc_td2_tdm.pipe_ovs_state[1],
                            _soc_td2_tdm.manage_port_type == 1,
                            _soc_td2_tdm.manage_port_type == 2,
                            _soc_td2_tdm.manage_port_type == 3,
                            &_soc_td2_tdm.iarb_tdm_wrap_ptr[0],
                            &_soc_td2_tdm.iarb_tdm_wrap_ptr[1],
                            _soc_td2_tdm.iarb_tdm[0],
                            _soc_td2_tdm.iarb_tdm[1]);
    if (rv == 0) {
        soc_cm_print("Unable to configure IARB TDM, please contact your "
                     "Field Applications Engineer or Sales Manager for "
                     "additional assistance.\n");
        return SOC_E_FAIL;
    }

    if (SOC_DEBUG_CHECK(SOC_DBG_TDM)) {
        for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
            soc_cm_print("Pipe %c iarb_tdm: (wrap_ptr %d)",
                         pipe ? 'y' : 'x',
                         _soc_td2_tdm.iarb_tdm_wrap_ptr[pipe]);
            for (index = 0; index < _IARB_TDM_LENGTH; index++) {
                if (index > _soc_td2_tdm.iarb_tdm_wrap_ptr[pipe]) {
                    break;
                }
                if (index % 16 == 0) {
                    soc_cm_print("\n    ");
                }
                soc_cm_print(" %3d", _soc_td2_tdm.iarb_tdm[pipe][index]);
            }
            soc_cm_print("\n");
        }
    }

    /* Configure PGW TDM, only need to program master PGWs (PGW_CL0/2/4/6) */
    for (pgw = 0; pgw < _TD2_PGWS_PER_DEV; pgw += _TD2_PGWS_PER_QUAD) {
        /* coverity[negative_returns : FALSE] */
        if (!si->block_valid[PGW_CL_BLOCK(unit, pgw)] &&
            !si->block_valid[PGW_CL_BLOCK(unit, pgw + 1)]) {
            /* Both master and slave are not in use */
            continue;
        }

        obm_inst = pgw | SOC_REG_ADDR_INSTANCE_MASK;

        SOC_IF_ERROR_RETURN(soc_reg_get(unit, PGW_TDM_CONTROLr, obm_inst, 0,
                                        &ctrl_rval64));

        /* Configure PGW line rate ports TDM */
        count = 0;
        for (base = 0; base < _PGW_TDM_LENGTH;
             base += _PGW_TDM_SLOTS_PER_REG) {
            reg = pgw_tdm_regs[base / _PGW_TDM_SLOTS_PER_REG];
            COMPILER_64_ZERO(rval64);
            for (index = 0; index < _PGW_TDM_SLOTS_PER_REG; index++) {
                slot = base + index;
                phy_port = _soc_td2_tdm.pgw_tdm[pgw / 2][slot];
                if (phy_port == NUM_EXT_PORTS) {
                    break;
                }
                soc_reg64_field32_set(unit, reg, &rval64, pgw_tdm_fields[slot],
                                      phy_port);
                count++;
            }
            if (index != 0) {
                SOC_IF_ERROR_RETURN
                    (soc_reg_set(unit, reg, obm_inst, 0, rval64));
            }
            if (index != _PGW_TDM_SLOTS_PER_REG) {
                break;
            }
        }
        if (count > 0) {
            soc_reg64_field32_set(unit, PGW_TDM_CONTROLr, &ctrl_rval64,
                                  LR_TDM_WRAP_PTRf, count - 1);
        }
        soc_reg64_field32_set(unit, PGW_TDM_CONTROLr, &ctrl_rval64,
                              LR_TDM_ENABLEf, count ? 1 : 0);

        /* Configure PGW oversubscription ports TDM */
        count = 0;
        for (base = 0; base < _PGW_TDM_LENGTH;
             base += _PGW_TDM_SLOTS_PER_REG) {
            reg = pgw_ovs_tdm_regs[base / _PGW_TDM_SLOTS_PER_REG];
            COMPILER_64_ZERO(rval64);
            for (index = 0; index < _PGW_TDM_SLOTS_PER_REG; index++) {
                slot = base + index;
                phy_port = _soc_td2_tdm.pgw_ovs_tdm[pgw / 2][slot];
                if (phy_port == NUM_EXT_PORTS) {
                    phy_port = 0xff;
                } else {
                    count++;
                }
                soc_reg64_field32_set(unit, reg, &rval64, pgw_tdm_fields[slot],
                                      phy_port);
            }
            SOC_IF_ERROR_RETURN(soc_reg_set(unit, reg, obm_inst, 0, rval64));
        }
        /* OS_TDM_WRAP_PTR is always 31 (reset value) */
        soc_reg64_field32_set(unit, PGW_TDM_CONTROLr, &ctrl_rval64,
                              OS_TDM_ENABLEf, count ? 1 : 0);

        /* Configure PGW oversubscription port spacing */
        for (base = 0; base < _PGW_TDM_LENGTH;
             base += _PGW_TDM_SLOTS_PER_REG) {
            reg = pgw_ovs_spacing_regs[base / _PGW_TDM_SLOTS_PER_REG];
            COMPILER_64_ZERO(rval64);
            for (index = 0; index < _PGW_TDM_SLOTS_PER_REG; index++) {
                slot = base + index;
                phy_port = _soc_td2_tdm.pgw_ovs_spacing[pgw / 2][slot];
                soc_reg64_field32_set(unit, reg, &rval64,
                                      pgw_spacing_fields[slot], phy_port);
            }
            SOC_IF_ERROR_RETURN(soc_reg_set(unit, reg, obm_inst, 0, rval64));
        }

        SOC_IF_ERROR_RETURN
            (soc_reg_set(unit, PGW_TDM_CONTROLr, obm_inst, 0, ctrl_rval64));
    }

    /* Configure PGW TDM oversubscription buffer manager (OBM) */
    xlport_map = 0;
    SOC_BLOCK_ITER(unit, block, SOC_BLK_XLPORT) {
        xlport_map |= 1 << SOC_BLOCK_NUMBER(unit, block);
    }
    quad_oversub_bandwidth = 0; /* to eliminate false compiler warning */
    quad_oversub_core_bandwidth = 0; /* to eliminate false compiler warning */
    for (pgw = 0; pgw < _TD2_PGWS_PER_DEV; pgw++) {
        /* Calculate per quadrant line rate and oversub bandwidth */
        if (!(pgw & 1)) {
            if (si->bandwidth == 720000) {
                max_quad_core_bandwidth =
                    pgw == 0 || pgw == 6 ? 160000 : 200000;
            } else {
                max_quad_core_bandwidth = si->bandwidth / 4;
            }
            quad_linerate_bandwidth = 0;
            quad_oversub_bandwidth = 0;
            quad_oversub_core_bandwidth = 0;
            if (!si->block_valid[PGW_CL_BLOCK(unit, pgw)] &&
                !si->block_valid[PGW_CL_BLOCK(unit, pgw + 1)]) {
                /* Both master and slave are not in use */
                pgw++;
                continue;
            }
            for (index = 0; index < _TD2_PORTS_PER_QUAD; index++) {
                phy_port = 1 + pgw * _TD2_PORTS_PER_PGW + index;
                port = si->port_p2l_mapping[phy_port];
                if (port == -1) {
                    continue;
                }
                if (si->port_speed_max[port] > 20000) {
                    bandwidth = 40000;
                } else if (si->port_speed_max[port] > 10000) {
                    bandwidth = 20000;
                } else {
                    bandwidth = 10000;
                }
                if (SOC_PBMP_MEMBER(si->oversub_pbm, port)) {
                    quad_oversub_bandwidth += bandwidth;
                } else {
                    quad_linerate_bandwidth += bandwidth;
                }
            }
            quad_oversub_core_bandwidth =
                max_quad_core_bandwidth - quad_linerate_bandwidth;
        }

        block = PGW_CL_BLOCK(unit, pgw);
        if (SOC_BLOCK_PORT(unit, block) < 0) { /* PGW is not in use */
            continue;
        }

        obm_inst = pgw | SOC_REG_ADDR_INSTANCE_MASK;

        COMPILER_64_ZERO(rval64);
        for (xlp = 0; xlp < _TD2_XLPS_PER_PGW; xlp++){
            if (!(xlport_map & (1 << (pgw * _TD2_XLPS_PER_PGW + xlp)))) {
                continue;
            }
            index = pgw & 1 ? _TD2_XLPS_PER_PGW - 1 - xlp : xlp;
            soc_reg64_field32_set(unit, CELL_ASM_CUT_THRU_THRESHOLDr, &rval64,
                                  xlp_cell_asf_thresh_fields[index], 6);
        }
        SOC_IF_ERROR_RETURN(soc_reg_set(unit, CELL_ASM_CUT_THRU_THRESHOLDr,
                                        obm_inst, 0, rval64));

        for (xlp = 0; xlp < _TD2_XLPS_PER_PGW; xlp++) {
            if (!(xlport_map & (1 << (pgw * _TD2_XLPS_PER_PGW + xlp)))) {
                continue;
            }
            /* XLP number is reversed (mirrored) in odd number PGW block */
            tsc = pgw * _TD2_XLPS_PER_PGW +
                ((pgw & 1) ? (_TD2_XLPS_PER_PGW - 1 - xlp) : xlp);

            /* Count number of oversub ports in the OBM (XLPORT) */
            count = 0;
            for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                if (_soc_td2_tdm.port_state[phy_port] == PORT_STATE_OVERSUB) {
                    count++;
                }
            }
            if (count == 0) { /* the XLPORT is not in oversub mode */
                continue;
            }

            reg = pgw_obm_ctrl_regs[xlp];
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, reg, obm_inst, 0, &ctrl_rval64));
            for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                if (si->port_p2l_mapping[phy_port] == -1) {
                    continue;
                }
                soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                      pgw_obm_oversub_fields[index], 1);
                if (count > 1) {
                    /* Do not allow OBM bypass if the oversubscribed
                     * XLPORT block has more than 1 port configured */
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          pgw_obm_bypass_fields[index], 0);
                }
            }
            if (rev_id > BCM56850_A1_REV_ID) {
                soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                      OVERSUB_HEADROOM_ENABLEf, 0);
            }
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, reg, obm_inst, 0, ctrl_rval64));

            if (rev_id <= BCM56850_A1_REV_ID) {
                /* Do not map to low priority on A0/A1 */
                reg = pgw_obm_priority_map_regs[xlp];
                for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                    phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                    if (si->port_p2l_mapping[phy_port] == -1) {
                        continue;
                    }

                    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index,
                                                    &ctrl_rval64));
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          PCP_MAPf, 0xffff);
                    SOC_IF_ERROR_RETURN
                        (soc_reg_set(unit, reg, obm_inst, index, ctrl_rval64));
                }

                reg = pgw_obm_shared_config_regs[xlp];
                SOC_IF_ERROR_RETURN
                    (soc_reg_get(unit, reg, obm_inst, 0, &ctrl_rval64));
                soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                      SHARED_POOL_SIZEf, 0);
                SOC_IF_ERROR_RETURN
                    (soc_reg_set(unit, reg, obm_inst, 0, ctrl_rval64));

                reg = pgw_obm_threshold_regs[xlp];
                for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                    phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                    port = si->port_p2l_mapping[phy_port];
                    if (port == -1) {
                        continue;
                    }

                    if (si->port_speed_max[port] > 20000) {
                        obm_setting_idx = 2; /* entry 2 in the lookup table */
                        xon_threshold_offset = 24; /* xon = xoff - 24 */
                    } else if (si->port_speed_max[port] > 10000) {
                        obm_setting_idx = 1; /* entry 1 in the lookup table */
                        xon_threshold_offset = 12; /* xon = xoff - 12 */
                    } else {
                        obm_setting_idx = 0; /* entry 0 in the lookup table */
                        xon_threshold_offset = 6; /* xon = xoff - 6 */
                    }
                    if (quad_oversub_bandwidth * 2 >
                        quad_oversub_core_bandwidth * 3) {
                        /* oversub ratio greater than 1.5 (3/2) */
                        oversub_ratio_idx = 1;
                    } else if (quad_oversub_bandwidth * 3 >
                        quad_oversub_core_bandwidth * 4) {
                        /* oversub ratio greater than 1.33 (4/3) */
                        oversub_ratio_idx = 1;
                    } else {
                        oversub_ratio_idx = 0;
                    }

                    if (lossless) {
                        xoff_threshold = obm_settings_a1[obm_setting_idx].
                            xoff_threshold[oversub_ratio_idx];
                        xon_threshold = xoff_threshold - xon_threshold_offset;
                        mtu_cells = obm_settings_a1[obm_setting_idx].
                            mtu_cells[oversub_ratio_idx];
                    } else {
                        xoff_threshold = 1020;
                        xon_threshold = 1020;
                        mtu_cells = 9 * 1024 / _TD2_BYTES_PER_OBM_CELL;
                    }
                    if (count > 1 &&
                        quad_oversub_bandwidth > quad_oversub_core_bandwidth) {
                        /*
                         * packet_completion_reserved cells =
                         *  (num_ports - 1) * mtu * (1 - 1 / oversub_ratio) + 4
                         */
                        res_cells = (count - 1) * mtu_cells *
                            (quad_oversub_bandwidth -
                             quad_oversub_core_bandwidth) /
                            quad_oversub_bandwidth  + 4;
                    } else {
                        res_cells = 4;
                    }
                    /*
                     * port_cells =
                     *  (1020 - packet_completion_reserved_cells) / num_ports
                     */
                    port_cells = (_TD2_CELLS_PER_OBM - res_cells) / count;

                    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index,
                                                    &ctrl_rval64));
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          MIN_THRESHOLDf, port_cells);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          LOW_PRI_THRESHOLDf, 0);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          MAX_THRESHOLDf, port_cells);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          FLOW_CTRL_XONf, xon_threshold);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          FLOW_CTRL_XOFFf, xoff_threshold);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          CUT_THROUGH_OKf, 2);
                    SOC_IF_ERROR_RETURN
                        (soc_reg_set(unit, reg, obm_inst, index, ctrl_rval64));
                }
            } else {
                reg = pgw_obm_priority_map_regs[xlp];
                for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                    phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                    if (si->port_p2l_mapping[phy_port] == -1) {
                        continue;
                    }

                    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index,
                                                    &ctrl_rval64));
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          PCP_MAPf, lossless ? 0xffff : 0);
                    SOC_IF_ERROR_RETURN
                        (soc_reg_set(unit, reg, obm_inst, index, ctrl_rval64));
                }

                reg = pgw_obm_shared_config_regs[xlp];
                SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index,
                                                &ctrl_rval64));
                soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                      SHARED_POOL_SIZEf, _TD2_CELLS_PER_OBM);
                SOC_IF_ERROR_RETURN
                    (soc_reg_set(unit, reg, obm_inst, index, ctrl_rval64));

                reg = pgw_obm_threshold_regs[xlp];
                for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                    phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                    port = si->port_p2l_mapping[phy_port];
                    if (port == -1) {
                        continue;
                    }

                    if (si->port_speed_max[port] > 20000) {
                        obm_setting_idx = 2; /* entry 2 in the lookup table */
                        xon_threshold_offset = 24; /* xon = xoff - 24 */
                    } else if (si->port_speed_max[port] > 10000) {
                        obm_setting_idx = 1; /* entry 1 in the lookup table */
                        xon_threshold_offset = 12; /* xon = xoff - 12 */
                    } else {
                        obm_setting_idx = 0; /* entry 0 in the lookup table */
                        xon_threshold_offset = 6; /* xon = xoff - 6 */
                    }
                    if (lossless) {
                        if (quad_oversub_bandwidth * 2 >
                            quad_oversub_core_bandwidth * 3) {
                            /* oversub ratio greater than 1.5 (3/2) */
                            oversub_ratio_idx = 2;
                        } else if (quad_oversub_bandwidth * 3 >
                            quad_oversub_core_bandwidth * 4) {
                            /* oversub ratio greater than 1.33 (4/3) */
                            oversub_ratio_idx = 1;
                        } else {
                            oversub_ratio_idx = 0;
                        }

                        xoff_threshold = obm_settings[obm_setting_idx].
                            xoff_threshold[oversub_ratio_idx];
                        xon_threshold = xoff_threshold - xon_threshold_offset;
                        min_threshold = xon_threshold + 3;
                    } else {
                        xoff_threshold = 1023;
                        xon_threshold = 1023;
                        min_threshold = obm_settings[obm_setting_idx].
                            max_threshold;
                    }

                    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, obm_inst, index,
                                                    &ctrl_rval64));
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          MIN_THRESHOLDf, min_threshold);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          LOW_PRI_THRESHOLDf, 0);
                    soc_reg64_field32_set
                        (unit, reg, &ctrl_rval64, MAX_THRESHOLDf,
                         obm_settings[obm_setting_idx].max_threshold);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          FLOW_CTRL_XONf, xon_threshold);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          FLOW_CTRL_XOFFf, xoff_threshold);
                    soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                          CUT_THROUGH_OKf, 2);
                    SOC_IF_ERROR_RETURN
                        (soc_reg_set(unit, reg, obm_inst, index, ctrl_rval64));
                }

                if (!lossless) {
                    continue;
                }

                COMPILER_64_ZERO(rval64);
                reg = pgw_obm_fc_config_regs[0];
                soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                      PORT_FC_ENABLEf, 1);
                soc_reg64_field32_set(unit, reg, &ctrl_rval64,
                                      PRIORITY_PROFILE_FCf, 0xffff);
                for (index = 0; index < _TD2_PORTS_PER_XLP; index++) {
                    phy_port = 1 + tsc * _TD2_PORTS_PER_XLP + index;
                    if (si->port_p2l_mapping[phy_port] == -1) {
                        continue;
                    }

                    reg = pgw_obm_fc_config_regs[xlp * _TD2_PORTS_PER_XLP +
                                                 index];
                    SOC_IF_ERROR_RETURN
                        (soc_reg_set(unit, reg, obm_inst, 0, ctrl_rval64));
                }
            }
        }
    }

    /* Configure MMU TDM */
    for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
        reg = mmu_tdm_regs[pipe];
        mem = mmu_tdm_mems[pipe];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        sal_memset(entry, 0, soc_mem_entry_words(unit, mem) * sizeof(uint32));
        for (slot = 0; slot < _MMU_TDM_LENGTH; slot += 2) {
            phy_port = _soc_td2_tdm.mmu_tdm[pipe][slot];
            if (phy_port == OVS_TOKEN) {
                mmu_port = 57; /* oppurtunist port */
            } else if (phy_port == IDL_TOKEN) {
                mmu_port = 58; /* scheduler will not pick anything */
            } else if (phy_port >= NUM_EXT_PORTS) {
                mmu_port = 0x3f;
            } else {
                mmu_port = si->port_p2m_mapping[phy_port];
            }
            soc_mem_field32_set(unit, mem, entry, PORT_NUM_EVENf,
                                mmu_port & 0x3f);
            phy_port = _soc_td2_tdm.mmu_tdm[pipe][slot + 1];
            if (phy_port == OVS_TOKEN) {
                mmu_port = 57; /* oppurtunist port */
            } else if (phy_port == IDL_TOKEN) {
                mmu_port = 58; /* scheduler will not pick anything */
            } else if (phy_port >= NUM_EXT_PORTS) {
                mmu_port = 0x3f;
            } else {
                mmu_port = si->port_p2m_mapping[phy_port];
            }
            soc_mem_field32_set(unit, mem, entry, PORT_NUM_ODDf,
                                mmu_port & 0x3f);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, slot / 2, entry));
            if (_soc_td2_tdm.mmu_tdm[pipe][slot + 2] == NUM_EXT_PORTS) {
                soc_reg_field_set(unit, reg, &rval, CAL0_ENDf, slot / 2);
                if (_soc_td2_tdm.mmu_tdm[pipe][slot + 1] == NUM_EXT_PORTS) {
                    soc_reg_field_set(unit, reg, &rval, CAL0_END_SINGLEf, 1);
                }
                break;
            }
        }
        soc_reg_field_set(unit, reg, &rval, OPP_CPULB_ENf, 1);
        soc_reg_field_set(unit, reg, &rval, ENABLEf, 1);
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));

        if (si->frequency < 760) {
            reg = mmu_ovs_group_cfg_regs[pipe];
            for (group = 0; group < _MMU_OVS_GROUP_COUNT; group++) {
                phy_port = _soc_td2_tdm.mmu_ovs_group_tdm[pipe][group][0];
                if (phy_port >= NUM_EXT_PORTS) {
                    continue;
                }
                port = si->port_p2l_mapping[phy_port];
                if (si->port_speed_max[port] < 30000) {
                    continue;
                }
                SOC_IF_ERROR_RETURN
                    (soc_reg32_get(unit, reg, REG_PORT_ANY, group, &rval));
                soc_reg_field_set(unit, reg, &rval, SAME_SPACINGf,
                                  si->frequency < 500 ? 6 : 8);
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, REG_PORT_ANY, group, rval));
            }
        }

        for (group = 0; group < _MMU_OVS_GROUP_COUNT; group++) {
            reg = mmu_ovs_group_regs[pipe][group];
            rval = 0;
            for (slot = 0; slot < _MMU_OVS_GROUP_TDM_LENGTH; slot++) {
                phy_port = _soc_td2_tdm.mmu_ovs_group_tdm[pipe][group][slot];
                if (phy_port >= NUM_EXT_PORTS) {
                    mmu_port = 0x3f;
                    id = 0;
                } else {
                    mmu_port = si->port_p2m_mapping[phy_port];
                    id = si->port_serdes[si->port_p2l_mapping[phy_port]];
                }
                soc_reg_field_set(unit, reg, &rval, PHY_PORT_IDf, id & 0xf);
                soc_reg_field_set(unit, reg, &rval, MMU_PORTf,
                                  mmu_port & 0x3f);
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, REG_PORT_ANY, slot, rval));
            }
            reg = mmu_ovs_group_wt_regs[pipe][group];
            rval = 0;
            phy_port = _soc_td2_tdm.mmu_ovs_group_tdm[pipe][group][0];
            if (phy_port >= NUM_EXT_PORTS) {
                weight = 0;
            } else {
                port = si->port_p2l_mapping[phy_port];
                speed_max = si->port_speed_max[port];
                /* use 2500M as weight unit */
                weight = (speed_max > 2500 ? speed_max : 2500) / 2500;
            }
            for (index = 0; index < _MMU_OVS_GROUP_TDM_LENGTH; index++) {
                soc_reg_field_set(unit, reg, &rval, WEIGHTf,
                                  weight * (index + 1));
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, REG_PORT_ANY, index, rval));
            }
        }
    }

    /* Configure IARB TDM */
    for (pipe = 0; pipe < _TD2_PIPES_PER_DEV; pipe++) {
        mem = iarb_tdm_mems[pipe];
        sal_memset(entry, 0, soc_mem_entry_words(unit, mem) * sizeof(uint32));
        for (slot = 0; slot < _IARB_TDM_LENGTH; slot++) {
            if (slot > _soc_td2_tdm.iarb_tdm_wrap_ptr[pipe]) {
                break;
            }
            soc_mem_field32_set(unit, mem, entry, TDM_SLOTf,
                                _soc_td2_tdm.iarb_tdm[pipe][slot]);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, slot, entry));
        }
    }
    /* Both pipe are expected to have same IARB TDM table length */
    fields[0] = TDM_WRAP_PTRf;
    values[0] = _soc_td2_tdm.iarb_tdm_wrap_ptr[0];
    fields[1] = DISABLEf;
    values[1] = 0;
    fields[2] = AUX_CMICM_SLOT_ENf;
    values[2] = 1;
    fields[3] = AUX_EP_LB_SLOT_ENf;
    values[3] = 1;
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, IARB_TDM_CONTROLr, REG_PORT_ANY, 4,
                                 fields, values));

    /* Configure oversubscription port with WAIT_FOR_2ND_MOP */
    sal_memset(entry, 0, sizeof(egr_edb_xmit_ctrl_entry_t));
    soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, entry, WAIT_FOR_2ND_MOPf, 1);
    soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, entry, START_CNTf,
                        si->frequency >= 760 ? 12 :
                        (si->frequency >= 608 ? 14 : 15));
    SOC_PBMP_ASSIGN(pbmp, PBMP_PORT_ALL(unit));
    SOC_PBMP_AND(pbmp, si->oversub_pbm);
    SOC_PBMP_ITER(pbmp, port) {
        phy_port = si->port_l2p_mapping[port];
        SOC_IF_ERROR_RETURN(soc_mem_write(unit, EGR_EDB_XMIT_CTRLm,
                                          MEM_BLOCK_ALL, phy_port, &entry));
    }

    /* Configure linerate port with WAIT_FOR_MOP */
    sal_memset(entry, 0, sizeof(egr_edb_xmit_ctrl_entry_t));
    soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, entry, WAIT_FOR_MOPf, 1);
    soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, entry, START_CNTf, 7);
    SOC_PBMP_ASSIGN(pbmp, PBMP_PORT_ALL(unit));
    SOC_PBMP_XOR(pbmp, si->oversub_pbm);
    SOC_PBMP_ITER(pbmp, port) {
        phy_port = si->port_l2p_mapping[port];
        if (si->frequency <= 415) {
            soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, entry, START_CNTf,
                                si->port_speed_max[port] > 11000 ? 8 : 7);
        }
        SOC_IF_ERROR_RETURN(soc_mem_write(unit, EGR_EDB_XMIT_CTRLm,
                                          MEM_BLOCK_ALL, phy_port, &entry));
    }

    rval = 0;
    soc_reg_field_set(unit, ENQ_CONFIGr, &rval,
                      ASF_ENABLE_HS_PORT_EP_CREDIT_CHKf, 1);
    soc_reg_field_set(unit, ENQ_CONFIGr, &rval, ASF_CFAP_FULL_DROP_ENf, 1);
    soc_reg_field_set(unit, ENQ_CONFIGr, &rval, ASF_FIFO_THRESHOLDf, 3);
    soc_reg_field_set(unit, ENQ_CONFIGr, &rval, ASF_HS_FIFO_THRESHOLDf, 13);
    SOC_IF_ERROR_RETURN(WRITE_ENQ_CONFIGr(unit, rval));

    /*
     * bcmsim: C model cannot support cell based flow
     */
    if (SAL_BOOT_BCMSIM) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, IARB_TDM_CONTROLr, REG_PORT_ANY, 
                                    DISABLEf, 1));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_hash_init(int unit)
{
    soc_field_t fields[4];
    uint32 values[4];

    /* L2 dedicated banks */
    fields[0] = BANK0_HASH_OFFSETf;
    values[0] = 0;  /* CRC32_LOWER */
    fields[1] = BANK1_HASH_OFFSETf;
    values[1] = 16; /* CRC32_UPPER */
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, L2_TABLE_HASH_CONTROLr, REG_PORT_ANY, 2,
                                 fields, values));

    /* L3 dedicated banks */
    fields[0] = BANK6_HASH_OFFSETf;
    values[0] = 0;  /* CRC32_LOWER */
    fields[1] = BANK7_HASH_OFFSETf;
    values[1] = 8;  /* CRC32 >> 8 */
    fields[2] = BANK8_HASH_OFFSETf;
    values[2] = 16; /* CRC32_UPPER */
    fields[3] = BANK9_HASH_OFFSETf;
    values[3] = 32; /* CRC16 */
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, L3_TABLE_HASH_CONTROLr, REG_PORT_ANY, 4,
                                 fields, values));

    /* L2/L3/ALPM shared banks */
    fields[0] = BANK2_HASH_OFFSETf;
    values[0] = 4;  /* CRC32 >> 4 */
    fields[1] = BANK3_HASH_OFFSETf;
    values[1] = 12; /* CRC32 >> 12 */
    fields[2] = BANK4_HASH_OFFSETf;
    values[2] = 20; /* CRC32 >> 20 */
    fields[3] = BANK5_HASH_OFFSETf;
    values[3] = 24; /* CRC32 >> 24 */
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, SHARED_TABLE_HASH_CONTROLr,
                                 REG_PORT_ANY, 4, fields, values));

    return SOC_E_NONE;
}

STATIC int
_soc_td2_ledup_init(int unit)
{
    uint32 rval = 0, ix, skip_count = 0;
    int uP1_off;
    soc_info_t *si;
    uint8 skip_slot[SOC_MAX_NUM_PORTS];

    si = &SOC_INFO(unit);
    /* configure the LED scan delay cycles */
    SOC_IF_ERROR_RETURN(READ_CMIC_LEDUP0_CTRLr(unit, &rval));
    soc_reg_field_set(unit, CMIC_LEDUP0_CTRLr, &rval, LEDUP_SCAN_START_DELAYf, 14);
    soc_reg_field_set(unit, CMIC_LEDUP0_CTRLr, &rval, LEDUP_SCAN_INTRA_PORT_DELAYf, 1);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_CTRLr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_CMIC_LEDUP1_CTRLr(unit, &rval));
    soc_reg_field_set(unit, CMIC_LEDUP1_CTRLr, &rval, LEDUP_SCAN_START_DELAYf, 24);
    soc_reg_field_set(unit, CMIC_LEDUP1_CTRLr, &rval, LEDUP_SCAN_INTRA_PORT_DELAYf, 1);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_CTRLr(unit, rval));

    rval =0;
    /* Initialize LED Port remap registers */

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r(unit, rval));

    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r(unit, rval));

    for (ix=1; ix <129; ix++) {
        if (si->port_p2l_mapping[ix] == -1)
            skip_count++;
        if (ix == 65)
            skip_count = 0;
        skip_slot[ix] = skip_count;
    }
    #define P2L_VALUE(i,x) ((si->port_p2l_mapping[i] == -1)? 0 : \
                            (i - uP1_off - skip_slot[i]))

    /* Configure LED Port remap registers */
    ix = 1;
    rval = 0;
    uP1_off = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_63f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_62f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_61f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_60f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_59f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_58f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_57f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_56f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_55f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_54f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_53f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_52f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_51f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_50f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_49f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_48f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_35f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_34f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_33f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_32f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_39f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_38f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_37f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_36f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_43f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_42f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_41f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_40f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_47f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_46f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_45f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_44f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_31f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_30f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_29f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_28f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_27f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_26f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_25f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_24f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_23f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_22f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_21f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_20f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_19f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_18f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_17f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_16f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_3f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_2f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_1f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_0f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_7f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_6f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_5f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_4f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_11f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_10f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_9f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_8f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_15f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_14f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_13f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_12f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r(unit, rval));


    /* Configure LED Port remap registers - LED uP1*/

    uP1_off = 64;
    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_63f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_62f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_61f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r, &rval, REMAP_PORT_60f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_60_63r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_59f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_58f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_57f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r, &rval, REMAP_PORT_56f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_56_59r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_55f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_54f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_53f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r, &rval, REMAP_PORT_52f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_52_55r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_51f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_50f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_49f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r, &rval, REMAP_PORT_48f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_48_51r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_35f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_34f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_33f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r, &rval, REMAP_PORT_32f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_32_35r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_39f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_38f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_37f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r, &rval, REMAP_PORT_36f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_36_39r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_43f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_42f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_41f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r, &rval, REMAP_PORT_40f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_40_43r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_47f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_46f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_45f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r, &rval, REMAP_PORT_44f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_44_47r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_31f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_30f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_29f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r, &rval, REMAP_PORT_28f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_28_31r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_27f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_26f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_25f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r, &rval, REMAP_PORT_24f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_24_27r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_23f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_22f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_21f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r, &rval, REMAP_PORT_20f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_20_23r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_19f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_18f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_17f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r, &rval, REMAP_PORT_16f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_16_19r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_3f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_2f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_1f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r, &rval, REMAP_PORT_0f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_0_3r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_7f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_6f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_5f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r, &rval, REMAP_PORT_4f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_4_7r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_11f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_10f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_9f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r, &rval, REMAP_PORT_8f, P2L_VALUE(ix,uP1_off)); ++ix;
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_8_11r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_15f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_14f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_13f, P2L_VALUE(ix,uP1_off)); ++ix;
    soc_reg_field_set(unit, CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r, &rval, REMAP_PORT_12f, P2L_VALUE(ix,uP1_off));
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_PORT_ORDER_REMAP_12_15r(unit, rval));

    #undef P2L_VALUE

    /* Raw SCHAN ops due to missing blocks */
    {
        _soc_reg32_set(unit, 15, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 16, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 17, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 18, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 20, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 21, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 22, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 23, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 25, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 26, 0, (0x2021700), (0x00000002));

        _soc_reg32_set(unit, 27, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 28, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 30, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 31, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 32, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 33, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 35, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 36, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 37, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 38, 0, (0x2021700), (0x00000002));

        _soc_reg32_set(unit, 40, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 41, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 42, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 43, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 45, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 46, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 47, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 48, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 50, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 51, 0, (0x2021700), (0x00000002));

        _soc_reg32_set(unit, 52, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 53, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 55, 0, (0x2021700), (0x00000002));
        _soc_reg32_set(unit, 56, 0, (0x2021700), (0x00000002));
    }

    /* initialize the UP0, UP1 data ram */
    rval = 0;
    for (ix = 0; ix < 256; ix++) {
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_DATA_RAMr(unit,ix, rval));
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP1_DATA_RAMr(unit,ix, rval));
    }

    return SOC_E_NONE;
}


extern int (*_phy_tscmod_firmware_set_helper[SOC_MAX_NUM_DEVICES])
    (int, int, uint8 *, int);
STATIC int
_soc_trident2_tsc_firmware_set(int unit, int port, uint8 *array, int datalen)
{
    return soc_warpcore_firmware_set(unit, port, array, datalen, 0,
                                     XLPORT_WC_UCMEM_DATAm,
                                     XLPORT_WC_UCMEM_CTRLr);
}

#if defined(SER_TR_TEST_SUPPORT)
soc_ser_test_functions_t ser_trident2_test_fun;
#endif

STATIC int
_soc_trident2_misc_init(int unit)
{
    static const soc_field_t port_field[] = {
        PORT0f, PORT1f, PORT2f, PORT3f
    };
    static int rtag7_field_width[] = { 16, 16, 4, 16, 8, 8, 16, 16 };
    soc_info_t *si;
    uint32 rval = 0;
    uint64 rval64;
    uint32 entry[SOC_MAX_MEM_WORDS];
    soc_pbmp_t pbmp;
    int port, phy_port;
    int subport0, subport2, phy_port_base;
    int blk, bindex, mode;
    int index, count, sub_sel, offset;
    int l2_banks;
    int freq, divisor, dividend, delay;
    int parity_enable, cache_fpgm;
    soc_field_t fields[2];
    uint32 values[2];

    si = &SOC_INFO(unit);

    /* Stop the mem scan task before all of the parity init takes place */
    SOC_IF_ERROR_RETURN(soc_generic_ser_mem_scan_stop(unit));

    parity_enable = soc_property_get(unit, spn_PARITY_ENABLE, TRUE);
    if (parity_enable) {
        if ((!SAL_BOOT_SIMULATION || SAL_BOOT_QUICKTURN) &&
            !SOC_WARM_BOOT(unit)) {
            /* Certain mems/regs need to be cleared before enabling SER */
            SOC_IF_ERROR_RETURN(_soc_trident2_clear_mmu_memory(unit, INVALIDm));
            SOC_IF_ERROR_RETURN(_soc_trident2_clear_all_port_data(unit));
        }
        (void)_soc_trident2_tcam_ser_init(unit);
        (void)_soc_trident2_ser_enable_all(unit, TRUE);
#ifdef INCLUDE_MEM_SCAN
        soc_mem_scan_ser_list_register(unit, TRUE,
                                       _soc_td2_tcam_ser_info[unit]);
#endif
        memset(&_td2_ser_functions, 0, sizeof(soc_ser_functions_t));
        _td2_ser_functions._soc_ser_fail_f = &soc_trident2_ser_fail;
        _td2_ser_functions._soc_ser_parity_error_cmicm_intr_f = 
            &soc_trident2_ser_error;
        soc_ser_function_register(unit, &_td2_ser_functions);
#if defined(SER_TR_TEST_SUPPORT)
        /*Initialize chip-specific functions for SER testing*/
        memset(&ser_trident2_test_fun, 0, sizeof(soc_ser_test_functions_t));
        ser_trident2_test_fun.inject_error_f = &soc_td2_ser_inject_error;
        ser_trident2_test_fun.test_mem = &soc_td2_ser_test_mem;
        ser_trident2_test_fun.test = &soc_td2_ser_test;
        ser_trident2_test_fun.parity_control = &_ser_test_parity_control_reg_set;
        soc_ser_test_functions_register(unit, &ser_trident2_test_fun);
#endif /*defined(SER_TR_TEST_SUPPORT*/
    }
    if (!SOC_IS_RELOADING(unit) && !SOC_WARM_BOOT(unit)) {
        SOC_IF_ERROR_RETURN(_soc_trident2_clear_all_memory(unit));
        if (!parity_enable) {
            /* Clear enabled port's regs if not done above */
            SOC_IF_ERROR_RETURN(_soc_trident2_clear_enabled_port_data(unit));
        }
    }

    _soc_trident2_port_mapping_init(unit);
    _soc_trident2_tdm_init(unit);

    sal_memset(entry, 0, sizeof(cpu_pbm_entry_t));
    soc_mem_pbmp_field_set(unit, CPU_PBMm, entry, BITMAPf, &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, CPU_PBMm, MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(cpu_pbm_2_entry_t));
    soc_mem_pbmp_field_set(unit, CPU_PBM_2m, entry, BITMAPf, &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, CPU_PBM_2m, MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(multipass_loopback_bitmap_entry_t));
    soc_mem_pbmp_field_set(unit, MULTIPASS_LOOPBACK_BITMAPm, entry, BITMAPf,
                           &PBMP_LB(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, MULTIPASS_LOOPBACK_BITMAPm, MEM_BLOCK_ALL, 0,
                       entry));

    sal_memset(entry, 0, sizeof(isbs_port_to_pipe_mapping_entry_t));
    soc_mem_pbmp_field_set(unit, ISBS_PORT_TO_PIPE_MAPPINGm, entry, BITMAPf,
                           &PBMP_YPIPE(unit));
    SOC_IF_ERROR_RETURN(soc_mem_write(unit, ISBS_PORT_TO_PIPE_MAPPINGm,
                                      MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(esbs_port_to_pipe_mapping_entry_t));
    soc_mem_pbmp_field_set(unit, ESBS_PORT_TO_PIPE_MAPPINGm, entry, BITMAPf,
                           &PBMP_YPIPE(unit));
    SOC_IF_ERROR_RETURN(soc_mem_write(unit, ESBS_PORT_TO_PIPE_MAPPINGm,
                                      MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(egr_ing_port_entry_t));
    soc_mem_field32_set(unit, EGR_ING_PORTm, entry, PORT_TYPEf, 1);
    PBMP_HG_ITER(unit, port) {
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, EGR_ING_PORTm, MEM_BLOCK_ALL, port, entry));
    }
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, EGR_ING_PORTm, MEM_BLOCK_ALL, si->cpu_hg_index,
                       entry));
    soc_mem_field32_set(unit, EGR_ING_PORTm, entry, PORT_TYPEf, 2);
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, EGR_ING_PORTm, MEM_BLOCK_ALL, LB_PORT(unit),
                       entry));

    /* For FP_GLOBAL_MASK_TCAM, we don't have the pbmp's necessary to
     * initialize the cache until now.  This is the time to check for
     * the cache permission of this table.
     */
    cache_fpgm = soc_feature(unit, soc_feature_mem_cache) && 
            soc_property_get(unit, spn_MEM_CACHE_ENABLE, 
                             (SAL_BOOT_RTLSIM || SAL_BOOT_XGSSIM) ? 0 : 1);
    if (soc_property_get(unit, spn_MEM_CHECK_NOCACHE_OVERRIDE, 0)) {
        char mem_name[100];
        char *mptr;

        sal_strcpy(mem_name, "mem_nocache_");
        mptr = &mem_name[sal_strlen(mem_name)];
        sal_strcpy(mptr, SOC_MEM_NAME(unit, FP_GLOBAL_MASK_TCAMm));
        if (soc_property_get(unit, mem_name, 0)) {
            cache_fpgm = 0;
        }
    }

    if (cache_fpgm) {
        SOC_MEM_INFO(unit, FP_GLOBAL_MASK_TCAMm).flags |=
            SOC_MEM_FLAG_CACHABLE;
        SOC_IF_ERROR_RETURN
            (soc_mem_cache_set(unit, FP_GLOBAL_MASK_TCAMm,
                               MEM_BLOCK_ALL, TRUE));
    }

    if (!SOC_IS_RELOADING(unit) && !SOC_WARM_BOOT(unit)) {
        /* Must clear FP_GLOBAL_MASK_TCAM after port to pipe mappings
         * are initialized. */
        SOC_IF_ERROR_RETURN
            (soc_mem_clear(unit, FP_GLOBAL_MASK_TCAMm, COPYNO_ALL, TRUE));
    }

    PBMP_PORT_ITER(unit, port) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, XLPORT_SPARE0_REGr, port, RSVDf, 1));

        if (!IS_HG_PORT(unit, port)) {
            continue;
        }
        SOC_IF_ERROR_RETURN(READ_XLPORT_CONFIGr(unit, port, &rval));
        soc_reg_field_set(unit, XLPORT_CONFIGr, &rval, HIGIG_MODEf, 1);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_CONFIGr(unit, port, rval));
    }

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        if (port == -1) {
            continue;
        }
        phy_port_base = ((si->port_l2p_mapping[port] - 1) & ~0x3) + 1;

        /* Assert XLPORT soft reset */
        rval = 0;
        for (bindex = 0; bindex < _TD2_PORTS_PER_XLP; bindex++) {
            if (si->port_p2l_mapping[phy_port_base + bindex] != -1) {
                soc_reg_field_set(unit, XLPORT_SOFT_RESETr, &rval,
                                  port_field[bindex], 1);
            }
        }
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_SOFT_RESETr(unit, port, rval));

        if (si->port_speed_max[port] > 20000) {
            mode = SOC_TD2_PORT_MODE_SINGLE;
        } else {
            subport0 = si->port_p2l_mapping[phy_port_base];
            subport2 = si->port_p2l_mapping[phy_port_base + 2];
            if (subport0 >= 0 && si->port_speed_max[subport0] > 10000) {
                if (subport2 < 0 || si->port_speed_max[subport2] <= 10000) {
                    mode = SOC_TD2_PORT_MODE_TRI_023;
                } else {
                    mode = SOC_TD2_PORT_MODE_DUAL;
                }
            } else if (subport2 >= 0 && si->port_speed_max[subport2] > 10000) {
                if (subport0 < 0 || si->port_speed_max[subport0] <= 10000) {
                    mode = SOC_TD2_PORT_MODE_TRI_012;
                } else {
                    mode = SOC_TD2_PORT_MODE_DUAL;
                }
            } else {
                mode = SOC_TD2_PORT_MODE_QUAD;
            }
        }
        rval = 0;
        soc_reg_field_set(unit, XLPORT_MODE_REGr, &rval,
                          XPORT0_CORE_PORT_MODEf, mode);
        soc_reg_field_set(unit, XLPORT_MODE_REGr, &rval,
                          XPORT0_PHY_PORT_MODEf, mode);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MODE_REGr(unit, port, rval));

        /* De-assert XLPORT soft reset */
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_SOFT_RESETr(unit, port, 0));

        /* Enable XLPORT */
        rval = 0;
        for (bindex = 0; bindex < _TD2_PORTS_PER_XLP; bindex++) {
            if (si->port_p2l_mapping[phy_port_base + bindex] != -1) {
                soc_reg_field_set(unit, XLPORT_ENABLE_REGr, &rval,
                                  port_field[bindex], 1);
            }
        }
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_ENABLE_REGr(unit, port, rval));
    }

    /* Enable QGPORT in XLPORT3 block (if present) */
    SOC_PBMP_ITER(si->management_pbm, port) {
        COMPILER_64_ZERO(rval64);
        soc_reg64_field32_set(unit, CELL_ASM_0_CONTROLr, &rval64,
                              QGPORT_ENABLEf, 1);
        SOC_IF_ERROR_RETURN
            (soc_reg_set(unit, CELL_ASM_0_CONTROLr, port, 0, rval64));
        break;
    }

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, MISCCONFIGr, &rval, METERING_CLK_ENf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));

    /* Enable dual hash tables */
    SOC_IF_ERROR_RETURN(_soc_trident2_hash_init(unit));
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, L2_ENTRY_CONTROL_6r, REG_PORT_ANY,
                                DISABLE_L2_ENTRY_LPf, 1));
    if (soc_mem_index_count(unit, L3_DEFIP_ALPM_RAWm) > 0) {
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, ISS_MEMORY_CONTROL_84r, REG_PORT_ANY,
                                    BYPASS_ISS_MEMORY_LPf, 0xf));
    } else {
        SOC_IF_ERROR_RETURN
            (soc_trident2_hash_bank_count_get(unit, L2Xm, &l2_banks));
        if (l2_banks > 2) {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, ISS_MEMORY_CONTROL_84r,
                                        REG_PORT_ANY, DISABLE_ISS_MEMORY_LPf,
                                        (1 << (l2_banks - 2)) - 1));
        }
    }

    rval = 0;
    soc_reg_field_set(unit, L2_AGE_DEBUGr, &rval, AGE_COUNTf,
                      soc_mem_index_max(unit, L2Xm));
    SOC_IF_ERROR_RETURN(WRITE_L2_AGE_DEBUGr(unit, rval));

    /*
     * Egress Enable
     */
    sal_memset(entry, 0, sizeof(egr_enable_entry_t));
    soc_mem_field32_set(unit, EGR_ENABLEm, entry, PRT_ENABLEf, 1);
    PBMP_ALL_ITER(unit, port) {
        phy_port = si->port_l2p_mapping[port];
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, phy_port, entry));
    }

    sal_memset(entry, 0, sizeof(epc_link_bmap_entry_t));
    soc_mem_pbmp_field_set(unit, EPC_LINK_BMAPm, entry, PORT_BITMAPf,
                           &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN(WRITE_EPC_LINK_BMAPm(unit, MEM_BLOCK_ALL, 0, entry));

    SOC_IF_ERROR_RETURN(READ_ING_CONFIG_64r(unit, &rval64));
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          L3SRC_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          L2DST_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          APPLY_EGR_MASK_ON_L2f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          APPLY_EGR_MASK_ON_L3f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          ARP_RARP_TO_FPf, 0x3); /* enable both ARP & RARP */
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                          ARP_VALIDATION_ENf, 1);
    if (soc_feature(unit, soc_feature_port_lag_failover)) {
        soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                IGNORE_HG_HDR_LAG_FAILOVERf, 0);
    } else {
        soc_reg64_field32_set(unit, ING_CONFIG_64r, &rval64,
                IGNORE_HG_HDR_LAG_FAILOVERf, 1);
    }
    SOC_IF_ERROR_RETURN(WRITE_ING_CONFIG_64r(unit, rval64));

    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EGR_CONFIG_1r, REG_PORT_ANY, RING_MODEf,
                                1));

    /* The HW defaults for EGR_VLAN_CONTROL_1.VT_MISS_UNTAG == 1, which
     * causes the outer tag to be removed from packets that don't have
     * a hit in the egress vlan tranlation table. Set to 0 to disable this.
     */
    rval = 0;
    soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, VT_MISS_UNTAGf, 0);

    /* Enable pri/cfi remarking on egress ports. */
    soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, REMARK_OUTER_DOT1Pf,
                      1);
    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1r(unit, port, rval));
    }

    SOC_PBMP_ASSIGN(pbmp, PBMP_ALL(unit));
    SOC_PBMP_REMOVE(pbmp, PBMP_LB(unit));
    SOC_IF_ERROR_RETURN(soc_mem_read(unit, ING_EN_EFILTER_BITMAPm,
                                     MEM_BLOCK_ANY, 0, &entry));
    soc_mem_pbmp_field_set(unit, ING_EN_EFILTER_BITMAPm, &entry, BITMAPf,
                           &pbmp);
    SOC_IF_ERROR_RETURN(soc_mem_write(unit, ING_EN_EFILTER_BITMAPm,
                                      MEM_BLOCK_ANY, 0, &entry));

    /* Multicast range initialization */
    SOC_IF_ERROR_RETURN
        (soc_hbx_higig2_mcast_sizes_set(unit,
             soc_property_get(unit, spn_HIGIG2_MULTICAST_VLAN_RANGE,
                              SOC_HBX_MULTICAST_RANGE_DEFAULT),
             soc_property_get(unit, spn_HIGIG2_MULTICAST_L2_RANGE,
                              soc_mem_index_count(unit, L2MCm) / 2),
             soc_property_get(unit, spn_HIGIG2_MULTICAST_L3_RANGE,
                              soc_mem_index_count(unit, L2MCm) / 2)));
    SOC_IF_ERROR_RETURN
        (soc_hbx_mcast_size_set(unit, soc_property_get(unit,
             spn_MULTICAST_L2_RANGE, soc_mem_index_count(unit, L2MCm) / 2)));
    SOC_IF_ERROR_RETURN
        (soc_hbx_ipmc_size_set(unit, soc_property_get(unit,
             spn_MULTICAST_L3_RANGE, soc_mem_index_count(unit, L2MCm) / 2)));

    /* Setup SW2_FP_DST_ACTION_CONTROL */
    fields[0] = HGTRUNK_RES_ENf;
    values[0] = 1;
    fields[1] = LAG_RES_ENf;
    values[1] = 1;
    SOC_IF_ERROR_RETURN(soc_reg_fields32_modify(unit,
                SW2_FP_DST_ACTION_CONTROLr, REG_PORT_ANY, 2, fields, values));

    /* Populate and enable RTAG7 Macro flow offset table */
    if (soc_mem_is_valid(unit, RTAG7_FLOW_BASED_HASHm)) {
        count = soc_mem_index_max(unit, RTAG7_FLOW_BASED_HASHm);
        sal_memset(entry, 0, sizeof(rtag7_flow_based_hash_entry_t));
        for (index = 0; index < count; ) {
            for (sub_sel = 0; sub_sel < 8 && index < count; sub_sel++) {
                for (offset = 0;
                     offset < rtag7_field_width[sub_sel] && index < count;
                     offset++) {
                    soc_mem_field32_set(unit, RTAG7_FLOW_BASED_HASHm, &entry,
                                        SUB_SEL_ECMPf, sub_sel);
                    soc_mem_field32_set(unit, RTAG7_FLOW_BASED_HASHm, &entry,
                                        OFFSET_ECMPf, offset);
                    SOC_IF_ERROR_RETURN
                        (soc_mem_write(unit, RTAG7_FLOW_BASED_HASHm,
                                       MEM_BLOCK_ANY, index, &entry));
                    index++;
                }
            }
        }
        rval = 0;
        soc_reg_field_set(unit, RTAG7_HASH_SELr, &rval, USE_FLOW_SEL_ECMPf, 1);
        soc_reg_field_set(unit, RTAG7_HASH_SELr, &rval, 
                                                USE_FLOW_SEL_TRILL_ECMPf, 1);
        SOC_IF_ERROR_RETURN(WRITE_RTAG7_HASH_SELr(unit, rval));
    }

    freq = si->frequency;

    /*
     * Set external MDIO freq to around 6MHz
     * target_freq = core_clock_freq * DIVIDEND / DIVISOR / 2
     */
    divisor = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVISOR, freq / 6 / 2);
    dividend = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVIDEND, 1);
    rval = 0;
    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval, DIVISORf, divisor);
    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval, DIVIDENDf, dividend);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUSTr(unit, rval));

    /*
     * Set internal MDIO freq to around 16MHz
     * Valid range is from 2.5MHz to 20MHz
     * target_freq = core_clock_freq * DIVIDEND / DIVISOR / 2
     * or
     * DIVISOR = core_clock_freq * DIVIDENT / (target_freq * 2)
     */
    rval = 0;
    soc_reg_field_set (unit, CMIC_RATE_ADJUST_INT_MDIOr, &rval, DIVISORf,
                       (freq + (16 * 2 - 1)) / (16 * 2)); /* round it up */
    soc_reg_field_set (unit, CMIC_RATE_ADJUST_INT_MDIOr, &rval, DIVIDENDf, 1);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUST_INT_MDIOr(unit, rval));

    delay = soc_property_get(unit, spn_MDIO_OUTPUT_DELAY, -1);
    if (delay >= 1  && delay <= 15) {
        SOC_IF_ERROR_RETURN(READ_CMIC_MIIM_CONFIGr(unit, &rval));
        soc_reg_field_set(unit, CMIC_MIIM_CONFIGr, &rval, MDIO_OUT_DELAYf,
                          delay);
        SOC_IF_ERROR_RETURN(WRITE_CMIC_MIIM_CONFIGr(unit, rval));
    }

    SOC_IF_ERROR_RETURN(_soc_td2_ledup_init(unit));

    if (soc_mspi_init(unit) != SOC_E_NONE) {
        soc_cm_debug(DK_WARN, "unit %d : MSPI Init Failed\n", unit);
    }

    _phy_tscmod_firmware_set_helper[unit] = _soc_trident2_tsc_firmware_set;

    if (parity_enable) {
        SOC_IF_ERROR_RETURN(soc_generic_ser_mem_scan_start(unit));
    }

    return SOC_E_NONE;
}


soc_mem_t
_soc_trident2_pmem(int unit, int port, soc_mem_t memx, soc_mem_t memy)
{
    soc_info_t *si = &SOC_INFO(unit);
    return (SOC_PBMP_MEMBER(si->xpipe_pbm, port)) ? memx : memy;
}

soc_reg_t
_soc_trident2_preg(int unit, int port, soc_reg_t regx, soc_reg_t regy)
{
    soc_info_t *si = &SOC_INFO(unit);
    return (SOC_PBMP_MEMBER(si->xpipe_pbm, port)) ? regx : regy;
}

uint32 _soc_trident2_mmu_port(int unit, int port)
{
    soc_info_t *si = &SOC_INFO(unit);
    return si->port_p2m_mapping[si->port_l2p_mapping[port]];
}

uint32 _soc_trident2_piped_mem_index(int unit, soc_port_t port,
                                     soc_mem_t mem, int arr_off)
{
    int     mmu_port;

    mmu_port = SOC_TD2_MMU_PORT(unit, port);

    switch (mem) {
    case MMU_THDM_DB_PORTSP_CONFIG_0m:
    case MMU_THDM_DB_PORTSP_CONFIG_1m:
    case MMU_THDM_MCQE_PORTSP_CONFIG_0m:
    case MMU_THDM_MCQE_PORTSP_CONFIG_1m:
        return (mmu_port & 0x3f) + _TD2_MMU_PORTS_PER_PIPE * arr_off;
    case THDI_PORT_SP_CONFIG_Xm:
    case THDI_PORT_SP_CONFIG_Ym:
    case MMU_THDU_XPIPE_CONFIG_PORTm:
    case MMU_THDU_YPIPE_CONFIG_PORTm:
    case MMU_THDU_XPIPE_RESUME_PORTm:
    case MMU_THDU_YPIPE_RESUME_PORTm:
        return (mmu_port & 0x3f) * _TD2_MMU_NUM_POOL + arr_off;
    case THDI_PORT_PG_CONFIG_Xm:
    case THDI_PORT_PG_CONFIG_Ym: 
        return (mmu_port & 0x3f) * _TD2_MMU_NUM_PG + arr_off;
   default:
        return 0xffffffff;
    }
}

#define _TD2_MMU_BYTES_TO_CELLS(_byte_)  \
    (((_byte_) + _TD2_MMU_BYTES_PER_CELL - 1) / _TD2_MMU_BYTES_PER_CELL)
    
STATIC void
_soc_td2_mmu_init_dev_config(int unit, _soc_mmu_device_info_t *devcfg,
                             int lossless)
{
    soc_info_t *si;
    int fifo_entry_count;
    soc_pbmp_t pbmp;
    int port;

    si = &SOC_INFO(unit);

    sal_memset(devcfg, 0, sizeof(_soc_mmu_device_info_t));

    devcfg->max_pkt_byte = _TD2_MMU_MAX_PACKET_BYTES;
    devcfg->mmu_hdr_byte = _TD2_MMU_PACKET_HEADER_BYTES;
    devcfg->jumbo_pkt_size = _TD2_MMU_JUMBO_FRAME_BYTES;
    devcfg->default_mtu_size = _TD2_MMU_DEFAULT_MTU_BYTES;
    devcfg->mmu_cell_size = _TD2_MMU_BYTES_PER_CELL;
    /*
     * Reserve 1 cell for each cut-through fifo entry
     * Assume each port use 1 QCN queue, reserve 1 cell for each QCN queue
     * Reserve 10 cells for ingress pool overshoot for lossless setting
     */
    fifo_entry_count = 0;
    SOC_PBMP_ASSIGN(pbmp, si->port.bitmap);
    SOC_PBMP_REMOVE(pbmp, si->all.disabled_bitmap);
    SOC_PBMP_ITER(pbmp, port) {
        fifo_entry_count += si->port_speed_max[port] <= 11000 ? 4 : 16;
    }
    devcfg->mmu_total_cell = _TD2_MMU_TOTAL_CELLS - fifo_entry_count -
        NUM_PORT(unit) - (lossless ? 10 : 0);
    devcfg->num_pg = _TD2_MMU_NUM_PG;
    devcfg->num_service_pool = _TD2_MMU_NUM_POOL;
    devcfg->flags = SOC_MMU_CFG_F_PORT_MIN | SOC_MMU_CFG_F_PORT_POOL_MIN |
                    SOC_MMU_CFG_F_RQE | SOC_MMU_CFG_F_EGR_MCQ_ENTRY;
    devcfg->total_mcq_entry = _TD2_MMU_TOTAL_MCQ_ENTRY(unit);
    devcfg->rqe_queue_num = 11;
}

STATIC int
_soc_td2_default_lossless_pg_headroom(int unit, soc_port_t port)
{
    soc_info_t *si;

    if (IS_CPU_PORT(unit, port) || IS_LB_PORT(unit, port)) {
        return 0;
    }

    si = &SOC_INFO(unit);
    if (SOC_PBMP_MEMBER(si->oversub_pbm, port)) {
        if (si->port_speed_max[port] >= 40000) {
            return 461;
        } else if (si->port_speed_max[port] >= 20000) {
            return 262;
        } else {
            return 182;
        }
    } else {
        if (si->port_speed_max[port] >= 100000) {
            return 558;
        } else if (si->port_speed_max[port] >= 40000) {
            return 284;
        } else if (si->port_speed_max[port] >= 20000) {
            return 183;
        } else {
            return 162;
        }
    }

    return 0;
}

STATIC int
_soc_td2_min_cell_rsvd_per_mcq(int unit, int port, int default_val)
{
    int freq, speed, osub;
    soc_info_t *si;

    si = &SOC_INFO(unit);
    speed = si->port_speed_max[port];
    osub = (SOC_PBMP_MEMBER(si->oversub_pbm, port)) ? 1 : 0;

    if (speed <= 10000) {
        return (osub) ? 6 : 3;
    } else if (speed <= 40000) {
        if (osub) {
            return 11;
        }
        
        freq = si->frequency;
        if (freq >= 750) {
            return 6;
        } else if (freq >= 625) {
            return 7;
        } else if (freq >= 495) {
            return 9;
        } else if (freq >= 414) {
            return 11;
        }
    }
    return default_val;
}

STATIC void
_soc_td2_mmu_config_buf_default(int unit, _soc_mmu_cfg_buf_t *buf,
                                _soc_mmu_device_info_t *devcfg, int lossless)
{
    soc_info_t *si;
    _soc_mmu_cfg_buf_pool_t *buf_pool;
    _soc_mmu_cfg_buf_port_t *buf_port;
    _soc_mmu_cfg_buf_port_pool_t *buf_port_pool;
    _soc_mmu_cfg_buf_prigroup_t *buf_prigroup;
    _soc_mmu_cfg_buf_queue_t *buf_queue;
    _soc_mmu_cfg_buf_mcengine_queue_t *buf_rqe_queue;
    int max_packet_cells, jumbo_frame_cells, default_mtu_cells;
    int port, idx, per_q_guarentee;
    int total_pool_size = 0, egr_shared_total = 0;
    int q_reserved = 0, in_reserved = 0;
    int mcq_entry_reserved = 0, per_q_mcq_entry_guarantee = 0;
    /*
    int mcq_entry_shared_total;
    */
    int rqe_entry_shared_total, min_cell_per_mcq;
    _soc_mmu_cfg_buf_qgroup_t *queue_grp;

    si = &SOC_INFO(unit);

    min_cell_per_mcq = soc_feature(unit, soc_feature_min_cell_per_queue) ? 1 : 0;
    soc_cm_debug(DK_VERBOSE, "Initializing default MMU config (u=%d)\n", unit);
    max_packet_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->max_pkt_byte +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);
    jumbo_frame_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->jumbo_pkt_size +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);
    default_mtu_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->default_mtu_size +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);

    total_pool_size = devcfg->mmu_total_cell;

    buf->headroom = 2 * jumbo_frame_cells;

    in_reserved += buf->headroom;

    per_q_guarentee = (lossless) ? 0 : default_mtu_cells;
    per_q_mcq_entry_guarantee = default_mtu_cells;

    PBMP_ALL_ITER(unit, port) {
        mcq_entry_reserved += si->port_num_cosq[port] *
            per_q_mcq_entry_guarantee;
        q_reserved += (si->port_num_cosq[port] + si->port_num_uc_cosq[port]) *
            per_q_guarentee;            
    }
    
    egr_shared_total = total_pool_size - q_reserved;
    
    /*
    mcq_entry_shared_total = _TD2_MMU_TOTAL_MCQ_ENTRY(unit) - mcq_entry_reserved;
    */

    rqe_entry_shared_total = _TD2_MMU_TOTAL_RQE_ENTRY(unit) - ((lossless) ? 0 : 88);

    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];

        if (idx == 0) {  /* 100% scale up by 100 */
            buf_pool->size = 10000 | _MMU_CFG_BUF_PERCENT_FLAG;
            buf_pool->yellow_size = 10000 | _MMU_CFG_BUF_PERCENT_FLAG;
            buf_pool->red_size = 10000 | _MMU_CFG_BUF_PERCENT_FLAG;
            buf_pool->total_mcq_entry = 10000 | _MMU_CFG_BUF_PERCENT_FLAG;
            buf_pool->total_rqe_entry = rqe_entry_shared_total;
        } else {
            buf_pool->size = 0;
            buf_pool->yellow_size = 0;
            buf_pool->red_size = 0;
            buf_pool->total_mcq_entry = 0;
            buf_pool->total_rqe_entry = 0;
        }
    }

    for (idx = 0; idx < SOC_TD2_MMU_CFG_QGROUP_MAX; idx++) {
        queue_grp = &buf->qgroups[idx];
        queue_grp->guarantee = 0;
        queue_grp->pool_limit = total_pool_size;
        queue_grp->discard_enable = (lossless) ? 0 : 1;
        queue_grp->pool_scale = -1;
        queue_grp->pool_resume = default_mtu_cells * 2;
        queue_grp->red_limit = 7 | _MMU_CFG_BUF_DYNAMIC_FLAG;
        queue_grp->yellow_limit = 7 | _MMU_CFG_BUF_DYNAMIC_FLAG;
        queue_grp->yellow_resume = default_mtu_cells * 2;
        queue_grp->red_resume = default_mtu_cells * 2;
    }

    PBMP_ALL_ITER(unit, port) {
        buf_port = &buf->ports[port];

        /* internal priority to priority group mapping */
        for (idx = 0; idx < 16; idx++) {
            buf_port->pri_to_prigroup[idx] = 7;
        }

        /* priority group to pool mapping */
        for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
            buf_port->prigroups[idx].pool_idx = 0;
        }

        for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
            buf_port_pool = &buf_port->pools[idx];
            buf_port_pool->guarantee = 0;
            buf_port_pool->pool_limit = 0;
            buf_port_pool->pool_resume = 0;
            if (idx == 0) {
                buf_port_pool->pool_limit = total_pool_size;
                buf_port_pool->pool_resume = 
                            total_pool_size - (default_mtu_cells * 2);
            }
            in_reserved += buf_port_pool->guarantee;
        }

        buf_port->pkt_size = max_packet_cells;
        
        /* priority group */
        for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
            buf_prigroup = &buf_port->prigroups[idx];
            buf_prigroup->guarantee = 0;
            buf_prigroup->user_delay = -1;
            buf_prigroup->switch_delay = -1;
            buf_prigroup->pkt_size = max_packet_cells;
            buf_prigroup->device_headroom_enable = 0;
            buf_prigroup->pool_limit = 0;
            buf_prigroup->pool_floor = 0;
            buf_prigroup->pool_scale = -1;
            buf_prigroup->headroom = 0;
            buf_prigroup->pool_resume = 0;
            buf_prigroup->flow_control_enable = 0;
            if (idx == 7) {
                buf_prigroup->device_headroom_enable = 1;
                buf_prigroup->flow_control_enable = lossless;
                if (lossless) {
                    buf_prigroup->guarantee = jumbo_frame_cells;
                    buf_prigroup->headroom = 
                        _soc_td2_default_lossless_pg_headroom(unit, port);
                    buf_prigroup->pool_scale = 7;
                    buf_prigroup->pool_resume = default_mtu_cells * 2;
                }
            }
            in_reserved += buf_prigroup->guarantee + buf_prigroup->headroom;
        }

        /* multicast queue */
        for (idx = 0; idx < si->port_num_cosq[port]; idx++) {
            buf_queue = &buf_port->queues[idx];
            buf_queue->qgroup_id = -1;
            buf_queue->mcq_entry_guarantee = default_mtu_cells;
            if (lossless) {
                buf_queue->guarantee = min_cell_per_mcq ?
                    _soc_td2_min_cell_rsvd_per_mcq(unit, port, 0) : 0;
                buf_queue->discard_enable = 0;
                buf_queue->pool_scale = -1;
                buf_queue->pool_limit = egr_shared_total;
                buf_queue->red_limit = egr_shared_total;
                buf_queue->color_discard_enable = 0;
                buf_queue->pool_resume = 16;
            } else {
                buf_queue->guarantee = min_cell_per_mcq ?  _soc_td2_min_cell_rsvd_per_mcq(unit, port, default_mtu_cells) : default_mtu_cells;
                buf_queue->discard_enable = 1;
                buf_queue->pool_scale = 7;
                buf_queue->pool_limit = 0;
                buf_queue->red_limit = 7 | _MMU_CFG_BUF_DYNAMIC_FLAG;
                buf_queue->color_discard_enable = 1;
                buf_queue->pool_resume = 16;
            }
        }

        /* unicast queue */
        for (idx = 0; idx < si->port_num_uc_cosq[port]; idx++) {
            buf_queue = &buf_port->queues[si->port_num_cosq[port] + idx];
            buf_queue->qgroup_id = -1;
            if (lossless) {
                buf_queue->guarantee = 0;
                buf_queue->discard_enable = 0;
                buf_queue->pool_scale = -1;
                buf_queue->pool_limit = egr_shared_total;
                buf_queue->red_limit = egr_shared_total;
                buf_queue->yellow_limit = egr_shared_total;
                buf_queue->color_discard_enable = 0;
                buf_queue->pool_resume = default_mtu_cells * 2;
                buf_queue->yellow_resume = default_mtu_cells * 2;
                buf_queue->red_resume = default_mtu_cells * 2;
            } else {
                buf_queue->guarantee = default_mtu_cells;
                buf_queue->discard_enable = 1;
                buf_queue->pool_scale = 7;
                buf_queue->pool_limit = 0;
                buf_queue->red_limit = 7 | _MMU_CFG_BUF_DYNAMIC_FLAG;
                buf_queue->yellow_limit = 7 | _MMU_CFG_BUF_DYNAMIC_FLAG;
                buf_queue->color_discard_enable = 1;
                buf_queue->pool_resume = default_mtu_cells * 2;
                buf_queue->yellow_resume = default_mtu_cells * 2;
                buf_queue->red_resume = default_mtu_cells * 2;
            }
        }

        /* queue to pool mapping */
        for (idx = 0; 
             idx < si->port_num_cosq[port] + si->port_num_uc_cosq[port]; idx++) {
            buf_port->queues[idx].pool_idx = 0;
        }
    }

    PBMP_ALL_ITER(unit, port) {
        buf_port = &buf->ports[port];
        buf_prigroup = &buf_port->prigroups[7];
        if (!lossless) {
            buf_prigroup->pool_limit = total_pool_size - in_reserved;
        }
    }

    /* extended queue profiles */
    for (idx = 0; idx < SOC_MMU_CFG_EQUEUE_MAX; idx++) {
        buf_queue = &buf->equeues[idx];
        buf_queue->numq = 0;
        buf_queue->guarantee = 0;
        buf_queue->pool_limit = 0;
        buf_queue->discard_enable = 1;
        buf_queue->pool_scale = -1;
        buf_queue->pool_resume = default_mtu_cells * 2;
        buf_queue->red_limit = 7 | _MMU_CFG_BUF_DYNAMIC_FLAG;
        buf_queue->yellow_limit = 7 | _MMU_CFG_BUF_DYNAMIC_FLAG;
        buf_queue->yellow_resume = default_mtu_cells * 2;
        buf_queue->red_resume = default_mtu_cells * 2;
    }

    /* RQE */
    for (idx = 0; idx < 11; idx++) {
        buf_rqe_queue = &buf->rqe_queues[idx];
        buf_rqe_queue->pool_idx = 0;
        buf_rqe_queue->red_limit = egr_shared_total;
        buf_rqe_queue->yellow_limit = egr_shared_total;
        if (lossless) {
            buf_rqe_queue->guarantee = 0;
            buf_rqe_queue->discard_enable = 0;
            buf_rqe_queue->pool_scale = -1;
            buf_rqe_queue->pool_limit = egr_shared_total;
        } else {
            buf_rqe_queue->guarantee = default_mtu_cells;
            buf_rqe_queue->discard_enable = 1;
            buf_rqe_queue->pool_scale = 7;
            buf_rqe_queue->pool_limit = 0;
        }
    }

}

STATIC int
_soc_td2_pool_scale_to_limit(int size, int scale)
{
    int factor = 1000;

    switch (scale) {
        case 7: factor = 875; break;
        case 6: factor = 750; break;
        case 5: factor = 625; break;
        case 4: factor = 500; break;
        case 3: factor = 375; break;
        case 2: factor = 250; break;
        case 1: factor = 125; break;
        case 0:
        default:
            factor = 1000; break;
    }
    return (size * factor)/1000;
}

STATIC int
_soc_td2_mmu_config_buf_set_hw(int unit, _soc_mmu_cfg_buf_t *buf,
                               _soc_mmu_device_info_t *devcfg, int lossless)
{
    soc_info_t *si;
    _soc_mmu_cfg_buf_pool_t *buf_pool;
    _soc_mmu_cfg_buf_port_t *buf_port;
    _soc_mmu_cfg_buf_prigroup_t *buf_prigroup;
    _soc_mmu_cfg_buf_queue_t *buf_queue;
    _soc_mmu_cfg_buf_port_pool_t *buf_port_pool;
    _soc_mmu_cfg_buf_mcengine_queue_t *buf_rqe_queue;
    soc_reg_t reg = INVALIDr;
    soc_mem_t mem, mem1, mem2, mem3;
    uint32 rval, fval, rval2, rval3;
    uint32 entry0[SOC_MAX_MEM_WORDS], entry1[SOC_MAX_MEM_WORDS];
    thdi_port_pg_config_entry_t pg_config_mem;
    thdi_port_sp_config_entry_t thdi_sp_config;
    mmu_thdo_config_qgroup_entry_t cfg_qgrp;
    int default_mtu_cells, limit, midx, pri, rlimit, min_resume_limit;
    int port, base, numq, idx;
    int jumbo_frame_cells, pval, rqlen, qbase;
    _soc_mmu_cfg_buf_qgroup_t *queue_grp;
    static const soc_field_t prigroup_reg[] = {
        THDI_PORT_PRI_GRP0r, THDI_PORT_PRI_GRP1r
    };
    static const soc_field_t prigroup_field[] = {
        PRI0_GRPf, PRI1_GRPf, PRI2_GRPf, PRI3_GRPf,
        PRI4_GRPf, PRI5_GRPf, PRI6_GRPf, PRI7_GRPf,
        PRI8_GRPf, PRI9_GRPf, PRI10_GRPf, PRI11_GRPf,
        PRI12_GRPf, PRI13_GRPf, PRI14_GRPf, PRI15_GRPf
    };
    static const soc_field_t prigroup_spid_field[] = {
        PG0_SPIDf, PG1_SPIDf, PG2_SPIDf, PG3_SPIDf,
        PG4_SPIDf, PG5_SPIDf, PG6_SPIDf, PG7_SPIDf
    };
    int index1;
    int pool_resume = 0;
    uint16      dev_id;
    uint8       rev_id;
    
    soc_cm_get_id(unit, &dev_id, &rev_id);

    min_resume_limit = soc_feature(unit, soc_feature_min_resume_limit_1) ? 8 : 0;

    PBMP_ALL_ITER(unit, port) {
        pool_resume += 4;
    }

    si = &SOC_INFO(unit);

    jumbo_frame_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->jumbo_pkt_size +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);
    default_mtu_cells = _MMU_CFG_MMU_BYTES_TO_CELLS(devcfg->default_mtu_size +
                                                   devcfg->mmu_hdr_byte,
                                                   devcfg->mmu_cell_size);

    rval = 0;
    fval = _TD2_MMU_PHYSICAL_CELLS - _TD2_MMU_RSVD_CELLS_CFAP;
    soc_reg_field_set(unit, CFAPFULLTHRESHOLDSETr, &rval, CFAPFULLSETPOINTf,
                      fval);
    SOC_IF_ERROR_RETURN(WRITE_CFAPFULLTHRESHOLDSETr(unit, rval));
    rval = 0;
    soc_reg_field_set(unit, CFAPFULLTHRESHOLDRESETr, &rval,
                      CFAPFULLRESETPOINTf, fval - 2 * jumbo_frame_cells);
    SOC_IF_ERROR_RETURN(WRITE_CFAPFULLTHRESHOLDRESETr(unit, rval));
    rval = 0;
    soc_reg_field_set(unit, CFAPBANKFULLr, &rval, LIMITf, 2046);
    for (idx = 0; idx < 16; idx++) {
        SOC_IF_ERROR_RETURN(WRITE_CFAPBANKFULLr(unit, idx, rval));
    }

    if (rev_id == BCM56850_A0_REV_ID || rev_id == BCM56850_A1_REV_ID) {
        rval = 0;
        soc_reg_field_set(unit, CFAP_ARBITER_MASKr, &rval, MASKf, 0xA);
        SOC_IF_ERROR_RETURN(WRITE_CFAP_ARBITER_MASKr(unit, rval));
    }

    /* internal priority to priority group mapping */
    PBMP_ALL_ITER(unit, port) {
        buf_port = &buf->ports[port];

        for (idx = 0; idx < 16; idx++) {
            if (idx % 8 == 0) { /* 8 fields per register */
                reg = prigroup_reg[idx / 8];
                rval = 0;
            }
            soc_reg_field_set(unit, reg, &rval, prigroup_field[idx],
                              buf_port->pri_to_prigroup[idx]);
            if (idx % 8 == 7) { /* 8 fields per register */
                SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
            }
        }
    }

    /* Input thresholds */
    rval = 0;
    soc_reg_field_set(unit, THDI_GLOBAL_HDRM_LIMIT_PIPEXr, 
                      &rval, GLOBAL_HDRM_LIMITf, buf->headroom/2);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, THDI_GLOBAL_HDRM_LIMIT_PIPEXr, 
                                        REG_PORT_ANY, 0, rval));
    
    soc_reg_field_set(unit, THDI_GLOBAL_HDRM_LIMIT_PIPEYr, 
                      &rval, GLOBAL_HDRM_LIMITf, buf->headroom/2);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, THDI_GLOBAL_HDRM_LIMIT_PIPEYr, 
                                        REG_PORT_ANY, 0, rval));
    
    fval = 0;
    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        if ((buf->pools[idx].size & ~_MMU_CFG_BUF_PERCENT_FLAG) != 0) {
            fval |= 1 << idx;
        }
    }

    rval = 0;
    fval = 0;
    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];
        if ((buf_pool->size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 0) {
            continue;
        }

        if (buf_pool->yellow_size & _MMU_CFG_BUF_PERCENT_FLAG) {
            if ((buf_pool->yellow_size & ~_MMU_CFG_BUF_PERCENT_FLAG) < 10000) {
                fval |= 1 << idx;
            }
        } else {
            if (buf->pools[idx].size != buf->pools[idx].yellow_size) {
                fval |= 1 << idx;
            }
        }
    }
    soc_reg_field_set(unit, THDI_POOL_CONFIGr, &rval, COLOR_AWAREf, fval);
    soc_reg_field_set(unit, THDI_POOL_CONFIGr, &rval, PUBLIC_ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_THDI_POOL_CONFIGr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, THDI_BYPASSr, &rval, INPUT_THRESHOLD_BYPASSf, 0);
    SOC_IF_ERROR_RETURN(WRITE_THDI_BYPASSr(unit, rval));

    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];
        if ((buf_pool->size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 0) {
            continue;
        }

        limit = buf_pool->total - (buf_pool->prigroup_headroom +
                                   buf_pool->prigroup_guarantee + 
                                   buf->headroom);

        rval = 0;
        soc_reg_field_set(unit, THDI_BUFFER_CELL_LIMIT_SPr, &rval, LIMITf, limit);
        SOC_IF_ERROR_RETURN(WRITE_THDI_BUFFER_CELL_LIMIT_SPr(unit, idx, rval));
        
        rval = 0;
        soc_reg_field_set(unit, THDI_CELL_RESET_LIMIT_OFFSET_SPr, &rval, 
                            OFFSETf, pool_resume);
        SOC_IF_ERROR_RETURN(WRITE_THDI_CELL_RESET_LIMIT_OFFSET_SPr(unit, idx, rval));
    }

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_THDI_BUFFER_CELL_LIMIT_PUBLIC_POOLr(unit, rval));

    /* output thresholds */
    SOC_IF_ERROR_RETURN(READ_OP_THDU_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, OP_THDU_CONFIGr, &rval, ENABLE_QUEUE_AND_GROUP_TICKETf, 1);
    soc_reg_field_set(unit, OP_THDU_CONFIGr, &rval, ENABLE_UPDATE_COLOR_RESUMEf, 1);
    soc_reg_field_set(unit, OP_THDU_CONFIGr, &rval, MOP_POLICY_1Bf, 1);
    soc_reg_field_set(unit, OP_THDU_CONFIGr, &rval, MOP_POLICY_1Af, 0);
    SOC_IF_ERROR_RETURN(WRITE_OP_THDU_CONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_MMU_THDM_DB_DEVICE_THR_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, MMU_THDM_DB_DEVICE_THR_CONFIGr, &rval, MOP_POLICYf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_DEVICE_THR_CONFIGr(unit, rval));

    #if 0
    SOC_IF_ERROR_RETURN(READ_MMU_THDM_DB_DEVICE_THR_CONFIG_PLUSr(unit, &rval));
    soc_reg_field_set(unit, MMU_THDM_DB_DEVICE_THR_CONFIG_PLUSr, &rval, ENABLE_UPDATE_COLOR_RESUMEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_DEVICE_THR_CONFIG_PLUSr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, MMU_THDM_MCQE_DEVICE_THR_CONFIG_PLUSr, &rval, 
                                        ENABLE_UPDATE_COLOR_RESUMEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_DEVICE_THR_CONFIG_PLUSr(unit, rval));
    #endif

    /* per service pool settings */
    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        buf_pool = &buf->pools[idx];
        if ((buf_pool->size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 0) {
            continue;
        }

        limit = buf_pool->total - buf_pool->queue_guarantee +
            (lossless ? 10 : 0);

        if (limit <= 0) {
            limit = 0;
        }

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_SHARED_LIMITr, &rval, 
                                                SHARED_LIMITf, limit);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_SHARED_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_YELLOW_SHARED_LIMITr, 
                                    &rval, YELLOW_SHARED_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_YELLOW_SHARED_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_RED_SHARED_LIMITr, 
                            &rval, RED_SHARED_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_RED_SHARED_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_RESUME_LIMITr, 
                            &rval, RESUME_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_RESUME_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_YELLOW_RESUME_LIMITr, 
                            &rval, YELLOW_RESUME_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_YELLOW_RESUME_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_DB_POOL_RED_RESUME_LIMITr, 
                            &rval, RED_RESUME_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_POOL_RED_RESUME_LIMITr(unit, idx, rval));

        /* mcq entries */
        limit = buf_pool->total_mcq_entry - buf_pool->mcq_entry_reserved;

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_SHARED_LIMITr, 
                            &rval, SHARED_LIMITf, limit/4);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_SHARED_LIMITr(unit, 
                                                                   idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_YELLOW_SHARED_LIMITr, 
                            &rval, YELLOW_SHARED_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_YELLOW_SHARED_LIMITr(unit, 
                                                                   idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_RED_SHARED_LIMITr, 
                            &rval, RED_SHARED_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_RED_SHARED_LIMITr(unit, 
                                                                   idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_RESUME_LIMITr, 
                                                &rval, RESUME_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_RESUME_LIMITr(unit, 
                                                                   idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_YELLOW_RESUME_LIMITr, 
                                       &rval, YELLOW_RESUME_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_YELLOW_RESUME_LIMITr(unit, 
                                                                   idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDM_MCQE_POOL_RED_RESUME_LIMITr, 
                                       &rval, RED_RESUME_LIMITf, limit/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_POOL_RED_RESUME_LIMITr(unit, 
                                                                   idx, rval));
    }

    rval = 0;
    soc_reg_field_set(unit, MMU_THDR_DB_CONFIGr, &rval, 
                                    CLEAR_DROP_STATE_ON_CONFIG_UPDATEf, 1);
    soc_reg_field_set(unit, MMU_THDR_DB_CONFIGr, &rval, MOP_POLICY_1Bf, 1);
    soc_reg_field_set(unit, MMU_THDR_DB_CONFIGr, &rval, MOP_POLICY_1Af, 0);
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_CONFIGr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, MMU_THDR_QE_CONFIGr, &rval, 
                                    CLEAR_DROP_STATE_ON_CONFIG_UPDATEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_CONFIGr(unit, rval));

    /* configure Q-groups */
    for (idx = 0; idx < SOC_TD2_MMU_CFG_QGROUP_MAX; idx++) {
        queue_grp = &buf->qgroups[idx];
    
        mem = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_CONFIG_QGROUPm, 
                                       MMU_THDU_YPIPE_CONFIG_QGROUPm);
        sal_memset(&cfg_qgrp, 0, sizeof(cfg_qgrp));

        soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                            Q_MIN_LIMIT_CELLf, queue_grp->guarantee);

        if (queue_grp->pool_scale != -1) {
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                               Q_SHARED_ALPHA_CELLf, queue_grp->pool_scale);
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    Q_LIMIT_DYNAMIC_CELLf, 1);
        } else {
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                Q_SHARED_LIMIT_CELLf, queue_grp->pool_limit);
        }
        
        if ((queue_grp->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
            (queue_grp->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    Q_COLOR_LIMIT_DYNAMIC_CELLf, 1);
        }

        if (queue_grp->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) {
            pval = _soc_td2_pool_scale_to_limit(queue_grp->pool_limit,
                          queue_grp->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG);
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    LIMIT_RED_CELLf, pval/8);

        } else {
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    LIMIT_RED_CELLf, queue_grp->red_limit);
        }

        if (queue_grp->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) {
            pval = _soc_td2_pool_scale_to_limit(queue_grp->pool_limit,
                          queue_grp->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG);
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    LIMIT_YELLOW_CELLf, pval/8);

        } else {
            soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    LIMIT_YELLOW_CELLf, queue_grp->yellow_limit);
        }

        SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, idx, &cfg_qgrp));
    }

    /* Input port per port settings */
    PBMP_ALL_ITER(unit, port) {
        buf_port = &buf->ports[port];

        rval = 0;
        for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
            soc_reg_field_set(unit, THDI_PORT_PG_SPIDr, &rval,
                              prigroup_spid_field[idx],
                              buf_port->prigroups[idx].pool_idx);
        }
        SOC_IF_ERROR_RETURN(WRITE_THDI_PORT_PG_SPIDr(unit, port, rval));

        mem = SOC_TD2_PMEM(unit, port, THDI_PORT_SP_CONFIG_Xm, 
                                       THDI_PORT_SP_CONFIG_Ym);
        /* Per port per pool settings */
        for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
            buf_port_pool = &buf_port->pools[idx];
            midx = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem, idx);
            sal_memset(&thdi_sp_config, 0, sizeof(thdi_sp_config));
            soc_mem_field32_set(unit, mem, &thdi_sp_config, 
                                PORT_SP_MIN_LIMITf, buf_port_pool->guarantee);
            soc_mem_field32_set(unit, mem, &thdi_sp_config, 
                           PORT_SP_RESUME_LIMITf, buf_port_pool->pool_resume);
            soc_mem_field32_set(unit, mem, &thdi_sp_config, 
                               PORT_SP_MAX_LIMITf, buf_port_pool->pool_limit);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, midx, &thdi_sp_config));
        }

        fval = 0;
        for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
            if (buf_port->prigroups[idx].flow_control_enable != 0) {
                for (pri=0; pri < 16; pri++) {
                    if (buf_port->pri_to_prigroup[pri] == idx) {
                        fval |= 1 << pri;
                    }
                }
            }
        }

        rval = 0;
        soc_reg_field_set(unit, THDI_INPUT_PORT_XON_ENABLESr, &rval,
                                          INPUT_PORT_RX_ENABLEf, 1);
        soc_reg_field_set(unit, THDI_INPUT_PORT_XON_ENABLESr, &rval,
                          PORT_PRI_XON_ENABLEf, fval);
        soc_reg_field_set(unit, THDI_INPUT_PORT_XON_ENABLESr, &rval,
                          PORT_PAUSE_ENABLEf, fval ? 1 : 0);
        SOC_IF_ERROR_RETURN(WRITE_THDI_INPUT_PORT_XON_ENABLESr(unit, port, rval));

        rval = 0;
        soc_reg_field_set(unit, THDI_PORT_MAX_PKT_SIZEr, &rval, 
                            PORT_MAX_PKT_SIZEf, buf_port->pkt_size);
        SOC_IF_ERROR_RETURN(WRITE_THDI_PORT_MAX_PKT_SIZEr(unit, rval));

        /* Input port per port per priority group settings */
        mem = SOC_TD2_PMEM(unit, port, THDI_PORT_PG_CONFIG_Xm, 
                                       THDI_PORT_PG_CONFIG_Ym);
        for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
            buf_prigroup = &buf->ports[port].prigroups[idx];

            midx = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem, idx);
            sal_memset(&pg_config_mem, 0, sizeof(pg_config_mem));
            soc_mem_field32_set(unit, mem, &pg_config_mem, 
                                PG_MIN_LIMITf, buf_prigroup->guarantee);

            if (buf_prigroup->pool_scale != -1) {
                soc_mem_field32_set(unit, mem, &pg_config_mem, PG_SHARED_DYNAMICf, 1);
                soc_mem_field32_set(unit, mem, &pg_config_mem, 
                                    PG_SHARED_LIMITf, buf_prigroup->pool_scale);
            } else {
                soc_mem_field32_set(unit, mem, &pg_config_mem, 
                                   PG_SHARED_LIMITf, buf_prigroup->pool_limit);
            }

            soc_mem_field32_set(unit, mem, &pg_config_mem, 
                         PG_GBL_HDRM_ENf, buf_prigroup->device_headroom_enable);
            soc_mem_field32_set(unit, mem, &pg_config_mem, 
                                       PG_HDRM_LIMITf, buf_prigroup->headroom);

            soc_mem_field32_set(unit, mem, &pg_config_mem, 
                                 PG_RESET_OFFSETf, buf_prigroup->pool_resume);

            soc_mem_field32_set(unit, mem, &pg_config_mem, 
                                  PG_RESET_FLOORf, buf_prigroup->pool_floor);
                                        
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem, 
                                           MEM_BLOCK_ALL, midx, &pg_config_mem));
        }
    }

    /***********************************
     * THDO 
     ***********************************/
    /* Output port per port per queue setting for regular multicast queue */
    PBMP_ALL_ITER(unit, port) {
        numq = si->port_num_cosq[port];
        qbase = si->port_cosq_base[port];
#if 0
        soc_cm_print("MC Qbase=%d numq=%d port=%s,%d\n", qbase, 
                            numq, SOC_PORT_NAME(unit, port), port);
#endif
        if (numq == 0) {
            continue;
        }

        mem = SOC_TD2_PMEM(unit, port, MMU_THDM_DB_QUEUE_CONFIG_0m, 
                                       MMU_THDM_DB_QUEUE_CONFIG_1m);
        base = soc_td2_l2_hw_index(unit, qbase, 0) - 1480;

        mem1 = SOC_TD2_PMEM(unit, port, MMU_THDM_DB_QUEUE_OFFSET_0m, 
                                        MMU_THDM_DB_QUEUE_OFFSET_1m);
        for (idx = 0; idx < numq; idx++) {
            buf_queue = &buf->ports[port].queues[idx];

            sal_memset(entry0, 0, sizeof(mmu_thdm_db_queue_config_0_entry_t));

            soc_mem_field32_set(unit, mem, entry0, 
                                Q_MIN_LIMITf, buf_queue->guarantee);
            if (buf_queue->discard_enable) {
                soc_mem_field32_set(unit, mem, entry0, Q_LIMIT_ENABLEf, 1);
            }
            if (buf_queue->color_discard_enable) {
                soc_mem_field32_set(unit, mem, entry0, Q_COLOR_LIMIT_ENABLEf, 1);
            } 
            if (buf_queue->pool_scale != -1) {
                soc_mem_field32_set(unit, mem, entry0, Q_LIMIT_DYNAMICf, 1);
                soc_mem_field32_set(unit, mem, entry0,
                           Q_SHARED_ALPHAf, buf_queue->pool_scale);
            } else {
                /* Q_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0,
                               Q_SHARED_LIMITf, buf_queue->pool_limit);
            }
            if ((buf_queue->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
                (buf_queue->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
                soc_mem_field32_set(unit, mem, entry0,
                                    Q_COLOR_LIMIT_DYNAMICf, 1);
                soc_mem_field32_set(unit, mem, entry0, YELLOW_SHARED_LIMITf,
                     buf_queue->yellow_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
                soc_mem_field32_set(unit, mem, entry0, RED_SHARED_LIMITf,
                     buf_queue->red_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
            } else {
                /* Q_COLOR_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0, YELLOW_SHARED_LIMITf,
                     buf_queue->yellow_limit / 8);
                soc_mem_field32_set(unit, mem, entry0, RED_SHARED_LIMITf,
                     buf_queue->red_limit / 8);
            }

            soc_mem_field32_set(unit, mem, entry0, 
                                Q_SPIDf, buf_queue->pool_idx);

            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx,
                               entry0));

            sal_memset(entry0, 0, sizeof(mmu_thdm_db_queue_offset_0_entry_t));

            soc_mem_field32_set(unit, mem1, entry0, 
                                RESUME_OFFSETf, (default_mtu_cells * 2)/8);
            soc_mem_field32_set(unit, mem1, entry0, 
                                YELLOW_RESUME_OFFSET_PROFILE_SELf, 0);
            soc_mem_field32_set(unit, mem1, entry0, 
                                RED_RESUME_OFFSET_PROFILE_SELf, 0);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, base + idx,
                               entry0));

            rval = 0;
            SOC_IF_ERROR_RETURN(
                    WRITE_MMU_THDM_DB_QUEUE_RESUME_OFFSET_PROFILE_YELLOWr(unit, 0, 
                        (buf_queue->yellow_limit - buf_queue->yellow_resume) / 8));

            rval = 0;
            SOC_IF_ERROR_RETURN(
                    WRITE_MMU_THDM_DB_QUEUE_RESUME_OFFSET_PROFILE_REDr(unit, 0, 
                        (buf_queue->red_limit - buf_queue->red_resume) / 8));
        }

        mem = SOC_TD2_PMEM(unit, port, MMU_THDM_MCQE_QUEUE_CONFIG_0m, 
                                           MMU_THDM_MCQE_QUEUE_CONFIG_1m);
        for (idx = 0; idx < numq; idx++) {
            buf_queue = &buf->ports[port].queues[idx];

            sal_memset(entry0, 0, sizeof(mmu_thdm_mcqe_queue_config_0_entry_t));

            soc_mem_field32_set(unit, mem, entry0, 
                                Q_MIN_LIMITf, buf_queue->guarantee/4);
            if (buf_queue->discard_enable) {
                soc_mem_field32_set(unit, mem, entry0, Q_LIMIT_ENABLEf, 1);
            }
            if (buf_queue->color_discard_enable) {
                soc_mem_field32_set(unit, mem, entry0, Q_COLOR_LIMIT_ENABLEf, 1);
            } 
            if (buf_queue->pool_scale != -1) {
                soc_mem_field32_set(unit, mem, entry0, Q_LIMIT_DYNAMICf, 1);
                soc_mem_field32_set(unit, mem, entry0,
                           Q_SHARED_ALPHAf, buf_queue->pool_scale);
            } else {
                /* Q_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0,
                               Q_SHARED_LIMITf, buf_queue->pool_limit/4);
            }
            if ((buf_queue->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
                (buf_queue->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
                soc_mem_field32_set(unit, mem, entry0,
                                    Q_COLOR_LIMIT_DYNAMICf, 1);
                soc_mem_field32_set(unit, mem, entry0, YELLOW_SHARED_LIMITf,
                     buf_queue->yellow_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
                soc_mem_field32_set(unit, mem, entry0, RED_SHARED_LIMITf,
                     buf_queue->red_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
            } else {
                /* Q_COLOR_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0, YELLOW_SHARED_LIMITf,
                     buf_queue->yellow_limit / 8);
                soc_mem_field32_set(unit, mem, entry0, RED_SHARED_LIMITf,
                     buf_queue->red_limit / 8);
            }

            soc_mem_field32_set(unit, mem, entry0, 
                                Q_SPIDf, buf_queue->pool_idx);

            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx,
                               entry0));

            sal_memset(entry0, 0, sizeof(mmu_thdm_db_queue_offset_0_entry_t));

            soc_mem_field32_set(unit, mem1, entry0, 
                                RESUME_OFFSETf, (default_mtu_cells * 2)/8);
            soc_mem_field32_set(unit, mem1, entry0, 
                                YELLOW_RESUME_OFFSET_PROFILE_SELf, 0);
            soc_mem_field32_set(unit, mem1, entry0, 
                                RED_RESUME_OFFSET_PROFILE_SELf, 0);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, base + idx,
                               entry0));

            rval = 0;
            SOC_IF_ERROR_RETURN(
                WRITE_MMU_THDM_MCQE_QUEUE_RESUME_OFFSET_PROFILE_YELLOWr(unit, 0, 
                    (buf_queue->yellow_limit - buf_queue->yellow_resume) / 8));
            
            rval = 0;
            SOC_IF_ERROR_RETURN(
                WRITE_MMU_THDM_MCQE_QUEUE_RESUME_OFFSET_PROFILE_REDr(unit, 0, 
                    (buf_queue->red_limit - buf_queue->red_resume) / 8));
        }

        /* Per  port per pool */
        for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
            buf_pool = &buf->pools[idx];
            if (buf_pool->total == 0) {
                continue;
            }

            limit = buf_pool->total - buf_pool->queue_guarantee;
            rlimit = (limit < min_resume_limit) ? min_resume_limit : limit;
            mem2 = SOC_TD2_PMEM(unit, port, MMU_THDM_DB_PORTSP_CONFIG_0m, 
                                            MMU_THDM_DB_PORTSP_CONFIG_1m);
            index1 = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem2, idx);
            sal_memset(entry0, 0, sizeof(mmu_thdm_db_portsp_config_0_entry_t));

            soc_mem_field32_set(unit, mem2, entry0, SHARED_LIMITf, limit);
            soc_mem_field32_set(unit, mem2, entry0, RED_SHARED_LIMITf, limit/8);
            soc_mem_field32_set(unit, mem2, entry0, YELLOW_SHARED_LIMITf, limit/8);

            soc_mem_field32_set(unit, mem2, entry0, 
                                            SHARED_LIMIT_ENABLEf, !lossless);

            soc_mem_field32_set(unit, mem2, entry0, SHARED_RESUME_LIMITf, rlimit/8);
            soc_mem_field32_set(unit, mem2, entry0, YELLOW_RESUME_LIMITf, rlimit/8);
            soc_mem_field32_set(unit, mem2, entry0, RED_RESUME_LIMITf, rlimit/8);
            
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem2, MEM_BLOCK_ALL, 
                                index1, entry0));

            mem2 = SOC_TD2_PMEM(unit, port, MMU_THDM_MCQE_PORTSP_CONFIG_0m, 
                                            MMU_THDM_MCQE_PORTSP_CONFIG_1m);
            sal_memset(entry0, 0, sizeof(mmu_thdm_mcqe_portsp_config_0_entry_t));

            limit = buf_pool->total_mcq_entry - buf_pool->mcq_entry_reserved;
            rlimit = (limit < min_resume_limit) ? min_resume_limit : limit;

            soc_mem_field32_set(unit, mem2, entry0, SHARED_LIMITf, limit/4);
            soc_mem_field32_set(unit, mem2, entry0, SHARED_RESUME_LIMITf, rlimit/8);
            soc_mem_field32_set(unit, mem2, entry0, SHARED_LIMIT_ENABLEf, !lossless);
            soc_mem_field32_set(unit, mem2, entry0, RED_SHARED_LIMITf, limit/8);
            soc_mem_field32_set(unit, mem2, entry0, RED_RESUME_LIMITf, rlimit/8);
            soc_mem_field32_set(unit, mem2, entry0, YELLOW_SHARED_LIMITf, limit/8);
            soc_mem_field32_set(unit, mem2, entry0, YELLOW_RESUME_LIMITf, rlimit/8);

            
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem2, MEM_BLOCK_ALL, 
                                index1, entry0));
        }
    }

    /* Output port per port per queue setting for regular unicast queue */
    PBMP_PORT_ITER(unit, port) {
        /* per port regular unicast queue */
        numq = si->port_num_uc_cosq[port];
        qbase = si->port_uc_cosq_base[port];
        #if 0
        soc_cm_print("UC Qbase=%d numq=%d port=%s, %d\n", qbase, numq, 
                                                SOC_PORT_NAME(unit, port), port);
        #endif

        if (numq == 0) {
            continue;
        }
        base = soc_td2_l2_hw_index(unit, qbase, 1);
        mem = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_CONFIG_QUEUEm, 
                                       MMU_THDU_YPIPE_CONFIG_QUEUEm);
        mem1 = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_OFFSET_QUEUEm, 
                                        MMU_THDU_YPIPE_OFFSET_QUEUEm);
        mem2 = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_Q_TO_QGRP_MAPm, 
                                           MMU_THDU_YPIPE_Q_TO_QGRP_MAPm);
        for (idx = 0; idx < numq; idx++) {
            buf_queue = &buf->ports[port].queues[si->port_num_cosq[port] + idx];

            sal_memset(entry0, 0, sizeof(mmu_thdu_xpipe_config_queue_entry_t));
            sal_memset(entry1, 0, sizeof(mmu_thdu_xpipe_offset_queue_entry_t));

            soc_mem_field32_set(unit, mem, entry0, 
                                Q_MIN_LIMIT_CELLf, buf_queue->guarantee);
            if (buf_queue->pool_scale != -1) {
                soc_mem_field32_set(unit, mem, entry0, Q_LIMIT_DYNAMIC_CELLf, 1);
                soc_mem_field32_set(unit, mem, entry0,
                           Q_SHARED_ALPHA_CELLf, buf_queue->pool_scale);
            } else {
                /* Q_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0,
                               Q_SHARED_LIMIT_CELLf, buf_queue->pool_limit);
            }
            soc_mem_field32_set(unit, mem1, 
                entry1, RESET_OFFSET_CELLf, buf_queue->pool_resume / 8);

            if ((buf_queue->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
                (buf_queue->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
                soc_mem_field32_set(unit, mem, entry0,
                                    Q_COLOR_LIMIT_DYNAMIC_CELLf, 1);
                soc_mem_field32_set(unit, mem, entry0, LIMIT_YELLOW_CELLf,
                     buf_queue->yellow_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
                soc_mem_field32_set(unit, mem, entry0, LIMIT_RED_CELLf,
                     buf_queue->red_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
            } else {
                /* Q_COLOR_LIMIT_DYNAMIC_CELLf is 0 */
                soc_mem_field32_set(unit, mem, entry0, LIMIT_YELLOW_CELLf,
                                         buf_queue->yellow_limit / 8);
                soc_mem_field32_set(unit, mem, entry0, LIMIT_RED_CELLf,
                                         buf_queue->red_limit / 8);
            }
            soc_mem_field32_set(unit, mem1, entry1, RESET_OFFSET_YELLOW_CELLf,
                                buf_queue->yellow_resume / 8);
            soc_mem_field32_set(unit, mem1, entry1, RESET_OFFSET_RED_CELLf,
                                buf_queue->red_resume / 8);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx, entry0));

            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem1, MEM_BLOCK_ALL, base + idx, entry1));

            sal_memset(entry0, 0, sizeof(mmu_thdo_q_to_qgrp_map_entry_t));
            soc_mem_field32_set(unit, mem2, 
                    entry0, Q_SPIDf, buf_queue->pool_idx);
            if (buf_queue->discard_enable) {
                soc_mem_field32_set(unit, mem2, entry0, Q_LIMIT_ENABLEf, 1);
            }
            if (buf_queue->color_discard_enable) {
                soc_mem_field32_set(unit, mem2, entry0, Q_COLOR_ENABLE_CELLf, 1);
            }


            if (buf_queue->qgroup_id >= 0) {
                soc_mem_field32_set(unit, mem2, entry0, QGROUP_VALIDf, 1);
                soc_mem_field32_set(unit, mem2, entry0, QGROUPf, buf_queue->qgroup_id);
                if (buf_queue->qgroup_min_enable) {
                    soc_mem_field32_set(unit, mem2, entry0, USE_QGROUP_MINf, 1);
                }
            }
            
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem2, MEM_BLOCK_ALL, 
                                base + idx, entry0));
        }
        
        /* Per  port per pool unicast */
        for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
            buf_pool = &buf->pools[idx];

            if (buf_pool->total == 0) {
                continue;
            }

            limit = buf_pool->total - buf_pool->queue_guarantee;
            mem2 = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_CONFIG_PORTm, 
                                           MMU_THDU_YPIPE_CONFIG_PORTm);
            index1 = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem2, idx);
            mem3 = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_RESUME_PORTm, 
                                            MMU_THDU_YPIPE_RESUME_PORTm);
            sal_memset(entry0, 0, sizeof(mmu_thdu_xpipe_config_port_entry_t));
            sal_memset(entry1, 0, sizeof(mmu_thdu_xpipe_resume_port_entry_t));

            soc_mem_field32_set(unit, mem2, entry0, SHARED_LIMITf, limit);
            soc_mem_field32_set(unit, mem3, entry1,
                         SHARED_RESUMEf, (limit - (default_mtu_cells * 2))/8);

            soc_mem_field32_set(unit, mem2, entry0, YELLOW_LIMITf, limit/8);
            soc_mem_field32_set(unit, mem3, entry1,
                            YELLOW_RESUMEf, (limit - (default_mtu_cells*2))/8);

            soc_mem_field32_set(unit, mem2, entry0, RED_LIMITf, limit/8);
            soc_mem_field32_set(unit, mem3, entry1,
                              RED_RESUMEf, (limit - (default_mtu_cells * 2))/8);
            
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem2, MEM_BLOCK_ALL, 
                                index1, entry0));
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem3, MEM_BLOCK_ALL, 
                                index1, entry1));
        }
    }

    /* RQE */
    for (idx = 0; idx < 11; idx++) {
        buf_rqe_queue = &buf->rqe_queues[idx];

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_LIMIT_MIN_PRIQr, 
                            &rval, MIN_LIMITf, buf_rqe_queue->guarantee);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_LIMIT_MIN_PRIQr(unit, idx, rval));

        rval = 0;
        rval2 = 0;
        rval3 = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_CONFIG1_PRIQr, 
                            &rval, SPIDf, buf_rqe_queue->pool_idx);

        if ((buf_rqe_queue->red_limit & _MMU_CFG_BUF_DYNAMIC_FLAG) ||
            (buf_rqe_queue->yellow_limit & _MMU_CFG_BUF_DYNAMIC_FLAG)) {
            soc_reg_field_set(unit, MMU_THDR_DB_CONFIG1_PRIQr, 
                                        &rval, COLOR_LIMIT_DYNAMICf, 1);
            soc_reg_field_set(unit, MMU_THDR_DB_LIMIT_COLOR_PRIQr, &rval3, 
                SHARED_RED_LIMITf, buf_rqe_queue->red_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
            soc_reg_field_set(unit, MMU_THDR_DB_LIMIT_COLOR_PRIQr, &rval3, 
                SHARED_YELLOW_LIMITf, buf_rqe_queue->yellow_limit & ~_MMU_CFG_BUF_DYNAMIC_FLAG);
        } else {
            soc_reg_field_set(unit, MMU_THDR_DB_LIMIT_COLOR_PRIQr, &rval3, 
                SHARED_RED_LIMITf, buf_rqe_queue->red_limit / 8);

            soc_reg_field_set(unit, MMU_THDR_DB_LIMIT_COLOR_PRIQr, &rval3, 
                SHARED_YELLOW_LIMITf, buf_rqe_queue->yellow_limit / 8);
        }

        soc_reg_field_set(unit, MMU_THDR_DB_CONFIG1_PRIQr, &rval, LIMIT_ENABLEf, 
                            (buf_rqe_queue->discard_enable ? 1 : 0));

        if (buf_rqe_queue->pool_scale != -1) {
            soc_reg_field_set(unit, MMU_THDR_DB_CONFIG1_PRIQr, 
                                            &rval, DYNAMIC_ENABLEf, 1);
            soc_reg_field_set(unit, MMU_THDR_DB_CONFIG_PRIQr, &rval2, 
                           SHARED_ALPHAf, buf_rqe_queue->pool_scale);
        } else {
            soc_reg_field_set(unit, MMU_THDR_DB_CONFIG_PRIQr, &rval2, 
                           SHARED_LIMITf, buf_rqe_queue->pool_limit);
        }
        soc_reg_field_set(unit, MMU_THDR_DB_CONFIG_PRIQr, &rval2, RESET_OFFSETf, 2);
    
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_CONFIG1_PRIQr(unit, idx, rval));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_CONFIG_PRIQr(unit, idx, rval2));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_LIMIT_COLOR_PRIQr(unit, idx, rval3));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_RESET_OFFSET_COLOR_PRIQr, 
                          &rval, RESET_OFFSET_REDf, (default_mtu_cells * 2)/8);
        soc_reg_field_set(unit, MMU_THDR_DB_RESET_OFFSET_COLOR_PRIQr, 
                       &rval, RESET_OFFSET_YELLOWf, (default_mtu_cells * 2)/8);
        SOC_IF_ERROR_RETURN(
                  WRITE_MMU_THDR_DB_RESET_OFFSET_COLOR_PRIQr(unit, idx, rval));

        /* queue entry */
        buf_pool = &buf->pools[buf_rqe_queue->pool_idx];
        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_LIMIT_MIN_PRIQr, 
                            &rval, MIN_LIMITf, buf_rqe_queue->guarantee/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_LIMIT_MIN_PRIQr(unit, idx, rval));

        rval = 0;
        rval2 = 0;
        rval3 = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG1_PRIQr, 
                            &rval, SPIDf, buf_rqe_queue->pool_idx);

        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG1_PRIQr, 
                                        &rval, COLOR_LIMIT_DYNAMICf, 0);
        soc_reg_field_set(unit, MMU_THDR_QE_LIMIT_COLOR_PRIQr, 
               &rval3, SHARED_RED_LIMITf, (buf_pool->total_rqe_entry)/(8*11));
        soc_reg_field_set(unit, MMU_THDR_QE_LIMIT_COLOR_PRIQr, 
           &rval3, SHARED_YELLOW_LIMITf, (buf_pool->total_rqe_entry)/(8*11));

        #if 0
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG1_PRIQr, 
                       &rval, LIMIT_ENABLEf, buf_rqe_queue->discard_enable);
        #else
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG1_PRIQr, &rval, LIMIT_ENABLEf, 1);
        #endif

        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG_PRIQr, &rval2, 
                          SHARED_LIMITf, (buf_pool->total_rqe_entry)/(8*11));
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG_PRIQr, &rval2, RESET_OFFSETf, 1);
    
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_CONFIG1_PRIQr(unit, idx, rval));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_CONFIG_PRIQr(unit, idx, rval2));
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_LIMIT_COLOR_PRIQr(unit, idx, rval3));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_RESET_OFFSET_COLOR_PRIQr, 
                          &rval, RESET_OFFSET_REDf, default_mtu_cells/8);
        soc_reg_field_set(unit, MMU_THDR_QE_RESET_OFFSET_COLOR_PRIQr, 
                       &rval, RESET_OFFSET_YELLOWf, default_mtu_cells/8);
        SOC_IF_ERROR_RETURN(
                  WRITE_MMU_THDR_QE_RESET_OFFSET_COLOR_PRIQr(unit, idx, rval));

    }

    /* per pool RQE settings */
    for (idx = 0; idx < 4; idx++) {
        buf_pool = &buf->pools[idx];
        if (((buf_pool->size & ~_MMU_CFG_BUF_PERCENT_FLAG) == 0) ||
            (buf_pool->total == 0)) {
            continue;
        }

        limit = buf_pool->total - buf_pool->queue_guarantee;
        
        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_CONFIG_SPr, 
                                &rval, SHARED_LIMITf, limit);
        soc_reg_field_set(unit, MMU_THDR_DB_CONFIG_SPr, &rval, RESUME_LIMITf, 
                                    (limit - (default_mtu_cells * 2))/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_CONFIG_SPr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_SP_SHARED_LIMITr, &rval, 
                     SHARED_RED_LIMITf, (limit - (default_mtu_cells * 2))/8);
        soc_reg_field_set(unit, MMU_THDR_DB_SP_SHARED_LIMITr, &rval, 
                  SHARED_YELLOW_LIMITf, (limit - (default_mtu_cells * 2))/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_SP_SHARED_LIMITr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_DB_RESUME_COLOR_LIMIT_SPr, &rval, 
                     RESUME_RED_LIMITf, (limit - (default_mtu_cells * 2))/8);
        soc_reg_field_set(unit, MMU_THDR_DB_RESUME_COLOR_LIMIT_SPr, &rval, 
                  RESUME_YELLOW_LIMITf, (limit - (default_mtu_cells * 2))/8);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_DB_RESUME_COLOR_LIMIT_SPr(unit, 
                                                                     idx, rval));

        rqlen = buf_pool->total_rqe_entry/8 - 1;
        if (rqlen == 0) {
            continue;
        }

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG_SPr, &rval, SHARED_LIMITf, rqlen);
        soc_reg_field_set(unit, MMU_THDR_QE_CONFIG_SPr, &rval, RESUME_LIMITf, rqlen - 1);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_CONFIG_SPr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_SHARED_COLOR_LIMIT_SPr, &rval, 
                                                    SHARED_RED_LIMITf, rqlen);
        soc_reg_field_set(unit, MMU_THDR_QE_SHARED_COLOR_LIMIT_SPr, &rval, 
                                                    SHARED_YELLOW_LIMITf, rqlen);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_SHARED_COLOR_LIMIT_SPr(unit, idx, rval));

        rval = 0;
        soc_reg_field_set(unit, MMU_THDR_QE_RESUME_COLOR_LIMIT_SPr, &rval, 
                                                RESUME_RED_LIMITf, rqlen - 1);
        soc_reg_field_set(unit, MMU_THDR_QE_RESUME_COLOR_LIMIT_SPr, &rval, 
                                                RESUME_YELLOW_LIMITf, rqlen - 1);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDR_QE_RESUME_COLOR_LIMIT_SPr(unit, 
                                                                     idx, rval));
    }

    /* Device level config setting */
    if (soc_property_get(unit, spn_PORT_UC_MC_ACCOUNTING_COMBINE, 0)) {
        SOC_IF_ERROR_RETURN(READ_MMU_THDM_DB_DEVICE_THR_CONFIGr(unit, &rval));
        soc_reg_field_set(unit, MMU_THDM_DB_DEVICE_THR_CONFIGr, &rval,
                          UC_MC_PORTSP_COMB_ACCT_ENABLEf, 1);
        SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_DEVICE_THR_CONFIGr(unit, rval));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_td2_mmu_config_shared_update_check(int unit, int val1, int val2, int flags)
{
    int rv = 0;
    if (flags == 1) {
        if (val1 > val2) {
            rv = 1;
        }
    } else {
        if (val1 < val2) {
            rv = 1;
        }
    }
    return rv;
}

int
soc_td2_mmu_config_shared_buf_recalc(int unit, int shared_size, int flags)
{
    soc_info_t *si;
    soc_mem_t mem, mem2;
    soc_reg_t reg = INVALIDr;
    soc_field_t field = INVALIDf;
    uint32 rval, rval2;
    uint32 entry0[SOC_MAX_MEM_WORDS];
    thdi_port_pg_config_entry_t pg_config_mem;
    mmu_thdo_config_qgroup_entry_t cfg_qgrp;
    int port, base, qbase, numq, idx;
    int cur_limit, midx, index1;
    int granularity;
    uint16      dev_id;
    uint8       rev_id;
    
    soc_cm_get_id(unit, &dev_id, &rev_id);

    si = &SOC_INFO(unit);

    /* per service pool settings */
    for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
        rval = 0;
        reg = MMU_THDM_DB_POOL_SHARED_LIMITr;
        field = SHARED_LIMITf;
        granularity = 1;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval));
        cur_limit = soc_reg_field_get(unit, reg, rval, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval, field, (shared_size/granularity)); 
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval));
        }

        rval = 0;
        reg = MMU_THDM_DB_POOL_YELLOW_SHARED_LIMITr;
        field = YELLOW_SHARED_LIMITf;
        granularity = 8;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval));
        cur_limit = soc_reg_field_get(unit, reg, rval, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval, field, (shared_size/granularity)); 
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval));
        }

        rval = 0;
        reg = MMU_THDM_DB_POOL_RED_SHARED_LIMITr;
        field = RED_SHARED_LIMITf;
        granularity = 8;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval));
        cur_limit = soc_reg_field_get(unit, reg, rval, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval, field, (shared_size/granularity)); 
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval));
        }

        /* mcq entries */
        rval = 0;
        reg = MMU_THDM_MCQE_POOL_SHARED_LIMITr;
        field = SHARED_LIMITf;
        granularity = 4;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval));
        cur_limit = soc_reg_field_get(unit, reg, rval, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval, field, (shared_size/granularity)); 
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval));
        }

        rval = 0;
        reg = MMU_THDM_MCQE_POOL_YELLOW_SHARED_LIMITr;
        field = YELLOW_SHARED_LIMITf;
        granularity = 8;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval));
        cur_limit = soc_reg_field_get(unit, reg, rval, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval, field, (shared_size/granularity)); 
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval));
        }

        rval = 0;
        reg = MMU_THDM_MCQE_POOL_RED_SHARED_LIMITr;
        field = RED_SHARED_LIMITf;
        granularity = 8;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval));
        cur_limit = soc_reg_field_get(unit, reg, rval, field);
        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval, field, (shared_size/granularity)); 
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval));
        }
    }

    /* configure Q-groups */
    mem = MMU_THDU_XPIPE_CONFIG_QGROUPm;
    for (idx = 0; idx < SOC_TD2_MMU_CFG_QGROUP_MAX; idx++) {
        sal_memset(&cfg_qgrp, 0, sizeof(cfg_qgrp));

        SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, mem, MEM_BLOCK_ALL, idx, &cfg_qgrp));

        field = Q_SHARED_LIMIT_CELLf;
        granularity = 1;
        if (!soc_mem_field32_get(unit, mem, &cfg_qgrp, Q_LIMIT_DYNAMIC_CELLf)) {
            cur_limit = soc_mem_field32_get(unit, mem, &cfg_qgrp, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    field, shared_size/granularity);
            }
        }
        
        granularity = 8;
        if (!soc_mem_field32_get(unit, mem, &cfg_qgrp,
                                 Q_COLOR_LIMIT_DYNAMIC_CELLf)) {
            field = LIMIT_RED_CELLf;
            cur_limit = soc_mem_field32_get(unit, mem, &cfg_qgrp, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    field, shared_size/granularity);
            }

            field = LIMIT_YELLOW_CELLf;
            cur_limit = soc_mem_field32_get(unit, mem, &cfg_qgrp, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, &cfg_qgrp, 
                                    field, shared_size/granularity);
            }
        }

        SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, idx, &cfg_qgrp));

        /* Y pipe */
        if ((mem == MMU_THDU_XPIPE_CONFIG_QGROUPm) &&
            (idx == (SOC_TD2_MMU_CFG_QGROUP_MAX -1))) {
            idx = 0;
            mem = MMU_THDU_YPIPE_CONFIG_QGROUPm;
        }
    }

    /* Input port per port settings */
    PBMP_ALL_ITER(unit, port) {
        rval = 0;
        /* Input port per port per priority group settings */
        mem = SOC_TD2_PMEM(unit, port, THDI_PORT_PG_CONFIG_Xm, 
                                       THDI_PORT_PG_CONFIG_Ym);
        field = PG_SHARED_LIMITf;
        granularity = 1;
        for (idx = 0; idx < _TD2_MMU_NUM_PG; idx++) {
            midx = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem, idx);
            sal_memset(&pg_config_mem, 0, sizeof(pg_config_mem));
            SOC_IF_ERROR_RETURN(soc_mem_read(unit, mem, 
                                             MEM_BLOCK_ALL, midx, &pg_config_mem));
            if (!soc_mem_field32_get(unit, mem, &pg_config_mem, PG_SHARED_DYNAMICf)) {
                cur_limit = soc_mem_field32_get(unit, mem, &pg_config_mem, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, &pg_config_mem, 
                                        field, shared_size/granularity);
                }
            }
        
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem, 
                                           MEM_BLOCK_ALL, midx, &pg_config_mem));
        }
    }

    /***********************************
     * THDO 
     ***********************************/
    /* Output port per port per queue setting for regular multicast queue */
    PBMP_PORT_ITER(unit, port) {
        numq = si->port_num_cosq[port];
        qbase = si->port_cosq_base[port];
        if (numq == 0) {
            continue;
        }

        mem = SOC_TD2_PMEM(unit, port, MMU_THDM_DB_QUEUE_CONFIG_0m, 
                                       MMU_THDM_DB_QUEUE_CONFIG_1m);
        base = soc_td2_l2_hw_index(unit, qbase, 0) - 1480;

        for (idx = 0; idx < numq; idx++) {
            sal_memset(entry0, 0, sizeof(mmu_thdm_db_queue_config_0_entry_t));

            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, mem, MEM_BLOCK_ALL, base + idx, entry0));

            field = Q_SHARED_LIMITf;
            granularity = 1;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_LIMIT_DYNAMICf)) {
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }

            granularity = 8;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_COLOR_LIMIT_DYNAMICf)) {
                field = YELLOW_SHARED_LIMITf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
                field = RED_SHARED_LIMITf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx,
                               entry0));
        }

        mem = SOC_TD2_PMEM(unit, port, MMU_THDM_MCQE_QUEUE_CONFIG_0m, 
                                           MMU_THDM_MCQE_QUEUE_CONFIG_1m);
        for (idx = 0; idx < numq; idx++) {
            sal_memset(entry0, 0, sizeof(mmu_thdm_mcqe_queue_config_0_entry_t));

            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, mem, MEM_BLOCK_ALL, base + idx, entry0));

            field = Q_SHARED_LIMITf;
            granularity = 4;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_LIMIT_DYNAMICf)) {
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }

            granularity = 8;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_COLOR_LIMIT_DYNAMICf)) {
                field = YELLOW_SHARED_LIMITf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
                field = RED_SHARED_LIMITf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx,
                               entry0));
        }

        /* Per  port per pool */
        for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
            mem = SOC_TD2_PMEM(unit, port, MMU_THDM_DB_PORTSP_CONFIG_0m, 
                                            MMU_THDM_DB_PORTSP_CONFIG_1m);
            index1 = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem, idx);
            sal_memset(entry0, 0, sizeof(mmu_thdm_db_portsp_config_0_entry_t));

            SOC_IF_ERROR_RETURN(soc_mem_read(unit, mem, MEM_BLOCK_ALL, 
                                index1, entry0));

            field = SHARED_LIMITf;
            granularity = 1;
            cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, entry0, 
                                    field, shared_size/granularity);
            }

            field = RED_SHARED_LIMITf;
            granularity = 8;
            cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, entry0, 
                                    field, shared_size/granularity);
            }

            field = YELLOW_SHARED_LIMITf;
            granularity = 8;
            cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, entry0, 
                                    field, shared_size/granularity);
            }

            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem, MEM_BLOCK_ALL, 
                                index1, entry0));

            /* MCQE */
            mem2 = SOC_TD2_PMEM(unit, port, MMU_THDM_MCQE_PORTSP_CONFIG_0m, 
                                            MMU_THDM_MCQE_PORTSP_CONFIG_1m);
            sal_memset(entry0, 0, sizeof(mmu_thdm_mcqe_portsp_config_0_entry_t));

            SOC_IF_ERROR_RETURN(soc_mem_read(unit, mem2, MEM_BLOCK_ALL, 
                                index1, entry0));
            field = SHARED_LIMITf;
            granularity = 4;
            cur_limit = soc_mem_field32_get(unit, mem2, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem2, entry0, 
                                    field, shared_size/granularity);
            }

            field = RED_SHARED_LIMITf;
            granularity = 8;
            cur_limit = soc_mem_field32_get(unit, mem2, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem2, entry0, 
                                    field, shared_size/granularity);
            }

            field = YELLOW_SHARED_LIMITf;
            granularity = 8;
            cur_limit = soc_mem_field32_get(unit, mem2, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem2, entry0, 
                                    field, shared_size/granularity);
            }
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem2, MEM_BLOCK_ALL, 
                                index1, entry0));

        }
    }

    /* Output port per port per queue setting for regular unicast queue */
    PBMP_PORT_ITER(unit, port) {
        /* per port regular unicast queue */
        numq = si->port_num_uc_cosq[port];
        qbase = si->port_uc_cosq_base[port];

        if (numq == 0) {
            continue;
        }
        base = soc_td2_l2_hw_index(unit, qbase, 1);
        mem = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_CONFIG_QUEUEm, 
                                       MMU_THDU_YPIPE_CONFIG_QUEUEm);
        for (idx = 0; idx < numq; idx++) {
            sal_memset(entry0, 0, sizeof(mmu_thdu_xpipe_config_queue_entry_t));

            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, mem, MEM_BLOCK_ALL, base + idx, entry0));

            field = Q_SHARED_LIMIT_CELLf;
            granularity = 1;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_LIMIT_DYNAMIC_CELLf)) {
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }

            granularity = 8;
            if (!soc_mem_field32_get(unit, mem, entry0, Q_COLOR_LIMIT_DYNAMIC_CELLf)) {
                field = LIMIT_YELLOW_CELLf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
                field = LIMIT_RED_CELLf;
                cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
                if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                    soc_mem_field32_set(unit, mem, entry0, 
                                        field, shared_size/granularity);
                }
            }
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, base + idx, entry0));
        }
        
        /* Per  port per pool unicast */
        for (idx = 0; idx < _TD2_MMU_NUM_POOL; idx++) {
            mem = SOC_TD2_PMEM(unit, port, MMU_THDU_XPIPE_CONFIG_PORTm, 
                                           MMU_THDU_YPIPE_CONFIG_PORTm);
            index1 = SOC_TD2_MMU_PIPED_MEM_INDEX(unit, port, mem, idx);
            sal_memset(entry0, 0, sizeof(mmu_thdu_xpipe_config_port_entry_t));

            SOC_IF_ERROR_RETURN(soc_mem_read(unit, mem, MEM_BLOCK_ALL, 
                                index1, entry0));

            field = SHARED_LIMITf;
            granularity = 1;
            cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, entry0, 
                                    field, shared_size/granularity);
            }

            granularity = 8;
            field = YELLOW_LIMITf;
            cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, entry0, 
                                    field, shared_size/granularity);
            }
            field = RED_LIMITf;
            cur_limit = soc_mem_field32_get(unit, mem, entry0, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_mem_field32_set(unit, mem, entry0, 
                                    field, shared_size/granularity);
            }
            
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, mem, MEM_BLOCK_ALL, 
                                index1, entry0));
        }
    }

    /* RQE */
    for (idx = 0; idx < 11; idx++) {
        rval = 0;
        rval2 = 0;

        SOC_IF_ERROR_RETURN(READ_MMU_THDR_DB_CONFIG1_PRIQr(unit, idx, &rval));

        reg = MMU_THDR_DB_CONFIG_PRIQr;
        field = SHARED_LIMITf;
        granularity = 1;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));
        if (!soc_reg_field_get(unit, MMU_THDR_DB_CONFIG1_PRIQr, rval,
                               DYNAMIC_ENABLEf)) {
            cur_limit = soc_reg_field_get(unit, reg, rval2, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
                SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));
            }
        }

        rval2 = 0;
        reg = MMU_THDR_DB_LIMIT_COLOR_PRIQr;
        granularity = 8;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));

        if (!soc_reg_field_get(unit, MMU_THDR_DB_CONFIG1_PRIQr, rval,
                               COLOR_LIMIT_DYNAMICf)) {
            field = SHARED_RED_LIMITf;
            cur_limit = soc_reg_field_get(unit, reg, rval2, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
            }

            field = SHARED_YELLOW_LIMITf;
            cur_limit = soc_reg_field_get(unit, reg, rval2, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
            }
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));
        }

        /* queue entry */
#if 0
        rval = 0;
        rval2 = 0;

        SOC_IF_ERROR_RETURN(READ_MMU_THDR_QE_CONFIG1_PRIQr(unit, idx, &rval));

        reg = MMU_THDR_QE_CONFIG_PRIQr;
        field = SHARED_LIMITf;
        granularity = 8 * 11;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));
        if (!soc_reg_field_get(unit, MMU_THDR_QE_CONFIG1_PRIQr, rval,
                               DYNAMIC_ENABLEf)) {
            cur_limit = soc_reg_field_get(unit, reg, rval2, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
                SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));
            }
        }

        rval2 = 0;
        reg = MMU_THDR_QE_LIMIT_COLOR_PRIQr;
        granularity = 8 * 11;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));

        if (!soc_reg_field_get(unit, MMU_THDR_QE_CONFIG1_PRIQr, rval,
                               COLOR_LIMIT_DYNAMICf)) {
            field = SHARED_RED_LIMITf;
            cur_limit = soc_reg_field_get(unit, reg, rval2, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
            }

            field = SHARED_YELLOW_LIMITf;
            cur_limit = soc_reg_field_get(unit, reg, rval2, field);
            if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
                soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
            }
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));
        }
#endif
    }

    /* per pool RQE settings */
    for (idx = 0; idx < 4; idx++) {
        reg = MMU_THDR_DB_CONFIG_SPr;
        field = SHARED_LIMITf;
        granularity = 1;

        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));
        cur_limit = soc_reg_field_get(unit, reg, rval, field);

        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));
        }

        reg = MMU_THDR_DB_SP_SHARED_LIMITr;
        granularity = 8;

        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));

        field = SHARED_YELLOW_LIMITf;
        cur_limit = soc_reg_field_get(unit, reg, rval, field);

        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
        }

        field = SHARED_RED_LIMITf;
        cur_limit = soc_reg_field_get(unit, reg, rval, field);

        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
        }
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));

#if 0
        reg = MMU_THDR_QE_CONFIG_SPr;
        field = SHARED_LIMITf;
        granularity = 1;

        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));
        cur_limit = soc_reg_field_get(unit, reg, rval, field);

        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));
        }

        reg = MMU_THDR_QE_SHARED_COLOR_LIMIT_SPr;
        granularity = 8;

        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, idx, &rval2));

        field = SHARED_YELLOW_LIMITf;
        cur_limit = soc_reg_field_get(unit, reg, rval, field);

        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
        }

        field = SHARED_RED_LIMITf;
        cur_limit = soc_reg_field_get(unit, reg, rval, field);

        if (_soc_td2_mmu_config_shared_update_check(unit, cur_limit, shared_size/granularity, flags)) {
            soc_reg_field_set(unit, reg, &rval2, field, (shared_size/granularity)); 
        }
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, idx, rval2));
#endif
    }

    return SOC_E_NONE;
}

STATIC int
soc_td2_mmu_config_init(int unit, int test_only)
{
    int rv;
    int lossless;
    _soc_mmu_cfg_buf_t *buf;
    _soc_mmu_device_info_t devcfg;

    buf = soc_mmu_cfg_alloc(unit);
    if (!buf) {
        return SOC_E_MEMORY;
    }

    lossless = soc_property_get(unit, spn_MMU_LOSSLESS, 1);

    _soc_td2_mmu_init_dev_config(unit, &devcfg, lossless);
    _soc_td2_mmu_config_buf_default(unit, buf, &devcfg, lossless);
    _soc_mmu_cfg_buf_read(unit, buf, &devcfg);
    rv = _soc_mmu_cfg_buf_check(unit, buf, &devcfg);
    if (!test_only) {
        if (SOC_FAILURE(rv)) {
            soc_cm_debug(DK_VERBOSE, "MMU config: Use default setting\n");
            _soc_td2_mmu_config_buf_default(unit, buf, &devcfg, lossless);
            _soc_mmu_cfg_buf_calculate(unit, buf, &devcfg);
        }
        rv = _soc_td2_mmu_config_buf_set_hw(unit, buf, &devcfg, lossless);
    }

    soc_mmu_cfg_free(unit, buf);

    soc_cm_debug(DK_VERBOSE, "MMU THDI/THDO init done\n");
    return rv;
}

STATIC int
_soc_trident2_mmu_init(int unit)
{
    uint32 rval;
    uint64 rval64;
    soc_info_t *si;
    soc_pbmp_t pbmp;
    int port, phy_port, mmu_port;    

    SOC_IF_ERROR_RETURN(soc_td2_mmu_config_init(unit, FALSE));

    SOC_IF_ERROR_RETURN(soc_td2_lls_init(unit));

    rval = 0;
    soc_reg_field_set(unit, ES_PIPE0_LLS_CONFIG0r, &rval, ENQUEUE_ENABLEf, 1);
    soc_reg_field_set(unit, ES_PIPE0_LLS_CONFIG0r, &rval, DEQUEUE_ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_ES_PIPE0_LLS_CONFIG0r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_ES_PIPE1_LLS_CONFIG0r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, PRIORITY_CONTROLr, &rval, USE_SC_FOR_MH_PRIf, 1);
    soc_reg_field_set(unit, PRIORITY_CONTROLr, &rval, USE_QM_FOR_MH_PRIf, 1);
    SOC_IF_ERROR_RETURN(WRITE_PRIORITY_CONTROLr(unit, rval));

    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, OOBFC_CHANNEL_BASE_64r, REG_PORT_ANY,
                                ENG_ENf, 1));

    /* Enable IP to CMICM credit transfer */
    rval = 0;
    soc_reg_field_set(unit, IP_TO_CMICM_CREDIT_TRANSFERr, &rval,
                      TRANSFER_ENABLEf, 1);
    soc_reg_field_set(unit, IP_TO_CMICM_CREDIT_TRANSFERr, &rval,
                      NUM_OF_CREDITSf, 32);
    SOC_IF_ERROR_RETURN(WRITE_IP_TO_CMICM_CREDIT_TRANSFERr(unit, rval));

    /* Enable all ports */
    COMPILER_64_ZERO(rval64);

    COMPILER_64_SET(rval64, 0x1fffff, 0xffffffff);
    SOC_IF_ERROR_RETURN(WRITE_THDU_OUTPUT_PORT_RX_ENABLE0_64r(unit, rval64));
    SOC_IF_ERROR_RETURN(WRITE_THDU_OUTPUT_PORT_RX_ENABLE1_64r(unit, rval64));
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_PORTSP_RX_ENABLE0_64r(unit, rval64));
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_DB_PORTSP_RX_ENABLE1_64r(unit, rval64));
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_PORTSP_RX_ENABLE0_64r(unit, rval64));
    SOC_IF_ERROR_RETURN(WRITE_MMU_THDM_MCQE_PORTSP_RX_ENABLE1_64r(unit, rval64));

    if (soc_feature(unit, soc_feature_post)) {
        SOC_IF_ERROR_RETURN(soc_mmu_post_init(unit));
    }

    rval = 0;
    si = &SOC_INFO(unit);      
    pbmp = si->eq_pbm;
    SOC_PBMP_AND(pbmp, si->oversub_pbm);
    SOC_PBMP_ITER(pbmp, port) {
        phy_port = si->port_l2p_mapping[port];
        mmu_port = si->port_p2m_mapping[phy_port];        
        if (mmu_port < si->mmu_port_base[1]) {
            rval |= 1 << mmu_port;
        } else {
            rval |= 1 << (mmu_port - si->mmu_port_base[1] + 16);
        }
    }
    SOC_IF_ERROR_RETURN(WRITE_ENQ_ASF_HS_OVERSUB_ENr(unit, rval));

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_age_timer_get(int unit, int *age_seconds, int *enabled)
{
    uint32 rval;

    SOC_IF_ERROR_RETURN(READ_L2_AGE_TIMERr(unit, &rval));
    *enabled = soc_reg_field_get(unit, L2_AGE_TIMERr, rval, AGE_ENAf);
    *age_seconds = soc_reg_field_get(unit, L2_AGE_TIMERr, rval, AGE_VALf);

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_age_timer_max_get(int unit, int *max_seconds)
{
    *max_seconds =
        soc_reg_field_get(unit, L2_AGE_TIMERr, 0xffffffff, AGE_VALf);

    return SOC_E_NONE;
}

STATIC int
_soc_trident2_age_timer_set(int unit, int age_seconds, int enable)
{
    uint32 rval;

    rval = 0;
    soc_reg_field_set(unit, L2_AGE_TIMERr, &rval, AGE_ENAf, enable);
    soc_reg_field_set(unit, L2_AGE_TIMERr, &rval, AGE_VALf, age_seconds);
    SOC_IF_ERROR_RETURN(WRITE_L2_AGE_TIMERr(unit, rval));

    return SOC_E_NONE;
}

/*
 * Trident2 chip driver functions.
 */
soc_functions_t soc_trident2_drv_funs = {
    _soc_trident2_misc_init,
    _soc_trident2_mmu_init,
    _soc_trident2_age_timer_get,
    _soc_trident2_age_timer_max_get,
    _soc_trident2_age_timer_set,
};

/*
 * Function:
 *      _soc_trident2_port_lanes_update_tdm
 * Description:
 *      Update PGW and MMU TDM programming for flex port
 * Parameters:
 *      unit          - Device number
 *      lanes_ctrl    - Control structure
 */
STATIC int
_soc_trident2_port_lanes_update_tdm(int unit, soc_td2_port_lanes_t *lanes_ctrl)
{
    soc_info_t *si = &SOC_INFO(unit);
    soc_reg_t reg, *reg_list;
    soc_mem_t mem;
    soc_field_t field;
    int port_base, phy_port_base, mmu_port_base, pgw_inst;
    int block_info_idx, bindex;
    int cur_ids[4], cur_ids_len;
    int ids[4], ids_len;
    int pipe, base, index, slot, slot_len, seq, count, i;
    uint64 rval64;
    uint32 entry[SOC_MAX_MEM_WORDS];
    uint32 rval, fval;
    static soc_reg_t pgw_tdm_regs[] = {
        PGW_LR_TDM_REG_0r, PGW_LR_TDM_REG_1r,
        PGW_LR_TDM_REG_2r, PGW_LR_TDM_REG_3r,
        PGW_LR_TDM_REG_4r, PGW_LR_TDM_REG_5r,
        PGW_LR_TDM_REG_6r, PGW_LR_TDM_REG_7r
    };
    static soc_reg_t pgw_ovs_tdm_regs[] = {
        PGW_OS_TDM_REG_0r, PGW_OS_TDM_REG_1r,
        PGW_OS_TDM_REG_2r, PGW_OS_TDM_REG_3r,
        PGW_OS_TDM_REG_4r, PGW_OS_TDM_REG_5r,
        PGW_OS_TDM_REG_6r, PGW_OS_TDM_REG_7r
    };
    static soc_reg_t pgw_obm_ctrl_regs[] = {
        PGW_OBM0_CONTROLr, PGW_OBM1_CONTROLr,
        PGW_OBM2_CONTROLr, PGW_OBM3_CONTROLr
    };
    static soc_field_t pgw_tdm_fields[] = {
        TDM_ENTRY0_PORT_IDf, TDM_ENTRY1_PORT_IDf,
        TDM_ENTRY2_PORT_IDf, TDM_ENTRY3_PORT_IDf,
        TDM_ENTRY4_PORT_IDf, TDM_ENTRY5_PORT_IDf,
        TDM_ENTRY6_PORT_IDf, TDM_ENTRY7_PORT_IDf,
        TDM_ENTRY8_PORT_IDf, TDM_ENTRY9_PORT_IDf,
        TDM_ENTRY10_PORT_IDf, TDM_ENTRY11_PORT_IDf,
        TDM_ENTRY12_PORT_IDf, TDM_ENTRY13_PORT_IDf,
        TDM_ENTRY14_PORT_IDf, TDM_ENTRY15_PORT_IDf,
        TDM_ENTRY16_PORT_IDf, TDM_ENTRY17_PORT_IDf,
        TDM_ENTRY18_PORT_IDf, TDM_ENTRY19_PORT_IDf,
        TDM_ENTRY20_PORT_IDf, TDM_ENTRY21_PORT_IDf,
        TDM_ENTRY22_PORT_IDf, TDM_ENTRY23_PORT_IDf,
        TDM_ENTRY24_PORT_IDf, TDM_ENTRY25_PORT_IDf,
        TDM_ENTRY26_PORT_IDf, TDM_ENTRY27_PORT_IDf,
        TDM_ENTRY28_PORT_IDf, TDM_ENTRY29_PORT_IDf,
        TDM_ENTRY30_PORT_IDf, TDM_ENTRY31_PORT_IDf
    };
    static soc_field_t pgw_obm_bypass_fields[] = {
        PORT0_BYPASS_ENABLEf, PORT1_BYPASS_ENABLEf,
        PORT2_BYPASS_ENABLEf, PORT3_BYPASS_ENABLEf
    };
    static soc_field_t pgw_obm_oversub_fields[] = {
        PORT0_OVERSUB_ENABLEf, PORT1_OVERSUB_ENABLEf,
        PORT2_OVERSUB_ENABLEf, PORT3_OVERSUB_ENABLEf
    };
    static soc_mem_t mmu_tdm_regs[2] ={
        ES_PIPE0_TDM_CONFIGr, ES_PIPE1_TDM_CONFIGr
    };
    static soc_mem_t mmu_tdm_mems[2] ={
        ES_PIPE0_TDM_TABLE_0m, ES_PIPE1_TDM_TABLE_0m
    };
    static soc_reg_t mmu_ovs_group_regs[2][_MMU_OVS_GROUP_COUNT] = {
        {
            ES_PIPE0_OVR_SUB_GRP0_TBLr, ES_PIPE0_OVR_SUB_GRP1_TBLr,
            ES_PIPE0_OVR_SUB_GRP2_TBLr, ES_PIPE0_OVR_SUB_GRP3_TBLr
        },
        {
            ES_PIPE1_OVR_SUB_GRP0_TBLr, ES_PIPE1_OVR_SUB_GRP1_TBLr,
            ES_PIPE1_OVR_SUB_GRP2_TBLr, ES_PIPE1_OVR_SUB_GRP3_TBLr
        }
    };
    static soc_reg_t mmu_ovs_group_wt_regs[2][_MMU_OVS_GROUP_COUNT] = {
        {
            ES_PIPE0_OVR_SUB_GRP0_WTr, ES_PIPE0_OVR_SUB_GRP1_WTr,
            ES_PIPE0_OVR_SUB_GRP2_WTr, ES_PIPE0_OVR_SUB_GRP3_WTr
        },
        {
            ES_PIPE1_OVR_SUB_GRP0_WTr, ES_PIPE1_OVR_SUB_GRP1_WTr,
            ES_PIPE1_OVR_SUB_GRP2_WTr, ES_PIPE1_OVR_SUB_GRP3_WTr
        }
    };
    static soc_mem_t mmu_tdm_fields[2] ={
        PORT_NUM_EVENf, PORT_NUM_ODDf
    };

    /* Construct new and old physical port list for calendar replacement */
    port_base = lanes_ctrl->port_base;
    phy_port_base = si->port_l2p_mapping[port_base];
    ids[0] = cur_ids[0] = phy_port_base;
    ids_len = cur_ids_len = 1;
    if (lanes_ctrl->lanes > lanes_ctrl->cur_lanes) {
        /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            cur_ids[1 + i] = lanes_ctrl->phy_ports[i];
        }
        cur_ids_len += lanes_ctrl->phy_ports_len;
    } else { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            ids[1 + i] = lanes_ctrl->phy_ports[i];
        }
        ids_len += lanes_ctrl->phy_ports_len;
    }

    /* Update PGW line rate ports or oversubscription ports TDM */
    reg_list = lanes_ctrl->oversub ? pgw_ovs_tdm_regs : pgw_tdm_regs;
    pgw_inst = (si->port_group[port_base] & 0x6) | SOC_REG_ADDR_INSTANCE_MASK;
    seq = 0;
    for (base = 0; base < _PGW_TDM_LENGTH; base += _PGW_TDM_SLOTS_PER_REG) {
        reg = reg_list[base / _PGW_TDM_SLOTS_PER_REG];
        SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, pgw_inst, 0, &rval64));
        count = 0;
        for (index = 0; index < _PGW_TDM_SLOTS_PER_REG; index++) {
            slot = base + index;
            fval = soc_reg64_field32_get(unit, reg, rval64,
                                         pgw_tdm_fields[slot]);
            for (i = 0; i < cur_ids_len; i++) {
                if (fval == cur_ids[i]) {
                    break;
                }
            }
            if (i == cur_ids_len) { /* no match */
                continue;
            }
            if (SOC_DEBUG_CHECK(SOC_DBG_TDM)) {
                soc_cm_print("set PGW_CL%d TDM slot %d from %d to %d\n",
                             pgw_inst & ~SOC_REG_ADDR_INSTANCE_MASK, slot,
                             fval, ids[seq % ids_len]);
            }
            if (i != 0 || (seq % ids_len) != 0) {
                soc_reg64_field32_set(unit, reg, &rval64, pgw_tdm_fields[slot],
                                      ids[seq % ids_len]);
                count++;
            }
            seq++;
        }
        if (count > 0) {
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, reg, pgw_inst, 0, rval64));
        }
    }

    /* Update oversubscription buffer manager (OBM) */
    bindex = -1;
    for (i = 0; i < SOC_DRIVER(unit)->port_num_blktype; i++) {
        block_info_idx = SOC_PORT_IDX_BLOCK(unit, phy_port_base, i);
        if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_PGW_CL) {
            bindex = SOC_PORT_IDX_BINDEX(unit, phy_port_base, i);
            break;
        }
    }
    reg = pgw_obm_ctrl_regs[bindex / _TD2_XLPS_PER_PGW];
    SOC_IF_ERROR_RETURN(soc_reg_get(unit, reg, port_base, 0, &rval64));
    if (soc_reg64_field32_get(unit, reg, rval64,
                              pgw_obm_oversub_fields[bindex & 3])) {
        fval = lanes_ctrl->lanes > lanes_ctrl->cur_lanes ? 0 : 1;
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            index = bindex % _TD2_XLPS_PER_PGW + lanes_ctrl->phy_ports[i] -
                phy_port_base;
            soc_reg64_field32_set(unit, reg, &rval64,
                                  pgw_obm_bypass_fields[index], fval);
            soc_reg64_field32_set(unit, reg, &rval64,
                                  pgw_obm_oversub_fields[index], fval);
        }
        SOC_IF_ERROR_RETURN(soc_reg_set(unit, reg, port_base, 0, rval64));
    }

    /* Construct new and old MMU port list for calendar replacement */
    mmu_port_base = si->port_p2m_mapping[phy_port_base];
    ids[0] = cur_ids[0] = mmu_port_base & 0x3f;
    ids_len = cur_ids_len = 1;
    if (lanes_ctrl->lanes > lanes_ctrl->cur_lanes) {
        /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            cur_ids[1 + i] =
                si->port_p2m_mapping[lanes_ctrl->phy_ports[i]] & 0x3f;
        }
        cur_ids_len += lanes_ctrl->phy_ports_len;
    } else { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            ids[1 + i] = si->port_p2m_mapping[lanes_ctrl->phy_ports[i]] & 0x3f;
        }
        ids_len += lanes_ctrl->phy_ports_len;
    }

    /* Update MMU TDM */
    pipe = SOC_PBMP_MEMBER(si->ypipe_pbm, port_base) ? 1 : 0;
    reg = mmu_tdm_regs[pipe];
    mem = mmu_tdm_mems[pipe];
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
    slot_len = (soc_reg_field_get(unit, reg, rval, CAL0_ENDf) + 1) * 2;
    slot_len -= soc_reg_field_get(unit, reg, rval, CAL0_END_SINGLEf);
    seq = 0;
    for (slot = 0; slot < slot_len; slot += 2) {
        count = 0;
        SOC_IF_ERROR_RETURN
            (soc_mem_read(unit, mem, MEM_BLOCK_ALL, slot / 2, entry));
        for (index = 0; index < 2; index++) {
            if (slot + index >= slot_len){
                break;
            }
            field = mmu_tdm_fields[index];
            fval = soc_mem_field32_get(unit, mem, entry, field);
            for (i = 0; i < cur_ids_len; i++) {
                if (fval == cur_ids[i]) {
                    break;
                }
            }
            if (i == cur_ids_len) { /* no match found */
                continue;
            }
            if (SOC_DEBUG_CHECK(SOC_DBG_TDM)) {
                soc_cm_print("set MMU pipe %d TDM slot %d from %d to %d\n",
                             pipe, slot + index, fval, ids[seq % ids_len]);
            }
            if (i != 0 || (seq % ids_len) != 0) {
                soc_mem_field32_set(unit, mem, entry, field,
                                    ids[seq % ids_len]);
                count++;
            }
            seq++;
        }
        if (count > 0) {
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, mem, MEM_BLOCK_ALL, slot / 2, entry));
        }
    }

    if (lanes_ctrl->oversub) {
        if (lanes_ctrl->slot == -1) { /* new group */
            reg = mmu_ovs_group_wt_regs[pipe][lanes_ctrl->group];
            rval = 0;
            for (index = 0; index < _MMU_OVS_GROUP_TDM_LENGTH; index++) {
                soc_reg_field_set(unit, reg, &rval, WEIGHTf,
                                  lanes_ctrl->weight * (index + 1));
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, reg, REG_PORT_ANY, index, rval));
            }
            lanes_ctrl->slot = 0;
        }
        if (lanes_ctrl->cur_empty) { /* last entry of the current group */
            reg = mmu_ovs_group_wt_regs[pipe][lanes_ctrl->cur_group];
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, 0));
        }
        /* Add into new group */
        reg = mmu_ovs_group_regs[pipe][lanes_ctrl->group];
        count = _MMU_OVS_GROUP_TDM_LENGTH /
            (_TD2_PORTS_PER_XLP / lanes_ctrl->lanes);
        rval = 0;
        soc_reg_field_set(unit, reg, &rval, PHY_PORT_IDf,
                          si->port_serdes[port_base] & 0xf);
        for (i = 0; i < ids_len; i++) {
            soc_reg_field_set(unit, reg, &rval, MMU_PORTf, ids[i]);
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, REG_PORT_ANY,
                               lanes_ctrl->slot + i * count, rval));
        }
        /* Remove from current group */
        reg = mmu_ovs_group_regs[pipe][lanes_ctrl->cur_group];
        count = _MMU_OVS_GROUP_TDM_LENGTH /
            (_TD2_PORTS_PER_XLP / lanes_ctrl->cur_lanes);
        rval = 0;
        for (i = 0; i < cur_ids_len; i++) {
            soc_reg_field_set(unit, reg, &rval, MMU_PORTf, 0x3f);
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, REG_PORT_ANY,
                               lanes_ctrl->cur_slot + i * count, rval));
        }
    }

    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_trident2_port_lanes_validate
 * Description:
 *      Validate if the specified number of lanes can be configured on a port,
 *      If the request can be done, fill in the control structure which will
 *      be used by the routines programming the hardware.
 * Parameters:
 *      unit          - Device number
 *      lanes_ctrl    - Control structure
 *
 * Each TSC can be configured into following 5 mode:
 *   Lane number    0    1    2    3
 *   ------------  ---  ---  ---  ---
 *    single port  40G   x    x    x
 *      dual port  20G   x   20G   x
 *   tri_023 port  20G   x   10G  10G
 *   tri_012 port  10G  10G  20G   x
 *      quad port  10G  10G  10G  10G
 *
 *          lanes                mode         valid lane index
 *       ------------      ----------------   ----------------
 *       new  current        new    current
 *       ---  -------      -------  -------
 * #1     4      1         single    quad            0
 * #2     4      1         single   tri_012          0
 * #3     4      2         single   tri_023          0
 * #4     4      2         single    dual            0
 * #5     2      1         tri_023   quad            0
 * #6     2      1         tri_012   quad            2
 * #7     2      1          dual    tri_023          2
 * #8     2      1          dual    tri_012          0
 * #9     2      4          dual    single           0
 * #10    1      2         tri_023   dual            2
 * #11    1      2         tri_012   dual            0
 * #12    1      2          quad    tri_023          0
 * #13    1      2          quad    tri_012          2
 * #14    1      4          quad    single           0
 * Following mode change requires 2 transition
 *   - from single to tri_023: #9 + #10
 *   - from single to tri_012: #9 + #11
 * Following mode change are the result of lane change on multiple ports
 *   - from quad to dual: #12 + #7 or #13 + #8
 *   - from dual to quad: #10 + #12 or #11 + # 13
 *   - from tri_023 to tri_012: #7 + #11 or #12 + #6
 *   - from tri_012 to tri_023: #8 + #10 or #13 + #5
 *
 * Logical port number will stay the same after conversion, for example
 *     converting single port to dual port, the logical port number of lane 0
 *     will be changed.
 */
int
soc_trident2_port_lanes_validate(int unit, soc_td2_port_lanes_t *lanes_ctrl)
{
    soc_info_t *si = &SOC_INFO(unit);
    soc_reg_t reg;
    int port_base, phy_port_base, mmu_port_base, id, i;
    int block_info_idx;
    uint32 rval, fval;
    int subport0, phy_subport0;
    int pipe, group, slot, count;
    int speed_max, cur_speed_max;
    static soc_reg_t mmu_ovs_group_regs[2][_MMU_OVS_GROUP_COUNT] = {
        {
            ES_PIPE0_OVR_SUB_GRP0_TBLr, ES_PIPE0_OVR_SUB_GRP1_TBLr,
            ES_PIPE0_OVR_SUB_GRP2_TBLr, ES_PIPE0_OVR_SUB_GRP3_TBLr
        },
        {
            ES_PIPE1_OVR_SUB_GRP0_TBLr, ES_PIPE1_OVR_SUB_GRP1_TBLr,
            ES_PIPE1_OVR_SUB_GRP2_TBLr, ES_PIPE1_OVR_SUB_GRP3_TBLr
        }
    };
    static soc_reg_t mmu_ovs_group_wt_regs[2][_MMU_OVS_GROUP_COUNT] = {
        {
            ES_PIPE0_OVR_SUB_GRP0_WTr, ES_PIPE0_OVR_SUB_GRP1_WTr,
            ES_PIPE0_OVR_SUB_GRP2_WTr, ES_PIPE0_OVR_SUB_GRP3_WTr
        },
        {
            ES_PIPE1_OVR_SUB_GRP0_WTr, ES_PIPE1_OVR_SUB_GRP1_WTr,
            ES_PIPE1_OVR_SUB_GRP2_WTr, ES_PIPE1_OVR_SUB_GRP3_WTr
        }
    };

    /* Find physical and mmu port number for the specified port */
    port_base = lanes_ctrl->port_base;
    phy_port_base = si->port_l2p_mapping[port_base];
    if (phy_port_base == -1) {
        return SOC_E_PORT;
    }
    lanes_ctrl->oversub = SOC_PBMP_MEMBER(si->oversub_pbm, port_base);

    if (lanes_ctrl->oversub && lanes_ctrl->lanes == 2) {
        /* Does not allow doing flex port to 2 lanes on oversub */
        return SOC_E_PARAM;
    }

    /* Find lane index for the specified port (base port) */
    for (i = 0; i < SOC_DRIVER(unit)->port_num_blktype; i++) {
        block_info_idx = SOC_PORT_IDX_BLOCK(unit, phy_port_base, i);
        if (si->port_speed_max[port_base] >= 1000000) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_CPORT) {
                break;
            }
        } else {
            if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_XLPORT) {
                break;
            }
        }
    }
    lanes_ctrl->bindex = SOC_PORT_IDX_BINDEX(unit, phy_port_base, i);

    /* Get the current mode */
    SOC_IF_ERROR_RETURN(READ_XLPORT_MODE_REGr(unit, port_base, &rval));
    lanes_ctrl->cur_mode = soc_reg_field_get(unit, XLPORT_MODE_REGr, rval,
                                             XPORT0_CORE_PORT_MODEf);

    /* Figure out the current number of lanes */
    switch (lanes_ctrl->cur_mode) {
    case SOC_TD2_PORT_MODE_QUAD:
        lanes_ctrl->cur_lanes = 1;
        break;
    case SOC_TD2_PORT_MODE_TRI_012:
        lanes_ctrl->cur_lanes = lanes_ctrl->bindex == 0 ? 1 : 2;
        break;
    case SOC_TD2_PORT_MODE_TRI_023:
        lanes_ctrl->cur_lanes = lanes_ctrl->bindex == 0 ? 2 : 1;
        break;
    case SOC_TD2_PORT_MODE_DUAL:
        lanes_ctrl->cur_lanes = 2;
        break;
    case SOC_TD2_PORT_MODE_SINGLE:
        lanes_ctrl->cur_lanes = 4;
        break;
    default:
        return SOC_E_FAIL;
    }

    /* Validate new number of lanes */
    if (lanes_ctrl->lanes == 4 || lanes_ctrl->cur_lanes == 4) {
        if (lanes_ctrl->bindex & 0x3) {
            return SOC_E_PARAM;
        }
    } else if (lanes_ctrl->lanes == 2 || lanes_ctrl->cur_lanes == 2) {
        if (lanes_ctrl->bindex & 0x1) {
            return SOC_E_PARAM;
        }
    } else if (lanes_ctrl->lanes != 1) {
        return SOC_E_PARAM;
    }

    /* No change to number of lanes */
    if (lanes_ctrl->lanes == lanes_ctrl->cur_lanes) {
        return SOC_E_NONE;
    }

    if (lanes_ctrl->oversub) {
        mmu_port_base = si->port_p2m_mapping[phy_port_base];
        phy_subport0 = ((phy_port_base - 1) & ~0x3) + 1;
        subport0 = si->port_p2l_mapping[phy_subport0];
        pipe = SOC_PBMP_MEMBER(si->ypipe_pbm, port_base) ? 1 : 0;

        /* Figure out the new speed group */
        speed_max = si->port_speed_max[subport0] * lanes_ctrl->lanes /
            _TD2_PORTS_PER_XLP;
        lanes_ctrl->weight = (speed_max > 2500 ? speed_max : 2500) / 2500;

        /* Figure out the current speed group */
        cur_speed_max = si->port_speed_max[subport0] * lanes_ctrl->cur_lanes /
            _TD2_PORTS_PER_XLP;
        lanes_ctrl->cur_weight =
            (cur_speed_max > 2500 ? cur_speed_max : 2500) / 2500;

        lanes_ctrl->group = -1;
        lanes_ctrl->slot = -1;
        lanes_ctrl->cur_slot = -1;
        for (group = 0; group < _MMU_OVS_GROUP_COUNT; group++) {
            reg = mmu_ovs_group_wt_regs[pipe][group];
            SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
            fval = soc_reg_field_get(unit, reg, rval, WEIGHTf);
            if (fval == 0) { /* unused group */
                if (lanes_ctrl->group == -1) {
                    lanes_ctrl->group = group;
                }
                continue;
            } else if (fval == lanes_ctrl->weight) {
                if (lanes_ctrl->slot == -1) {
                    /* Find a slot for new group */
                    reg = mmu_ovs_group_regs[pipe][group];
                    count = _MMU_OVS_GROUP_TDM_LENGTH /
                        (_TD2_PORTS_PER_XLP / lanes_ctrl->lanes);
                    for (slot = 0; slot < count; slot++) {
                        SOC_IF_ERROR_RETURN
                            (soc_reg32_get(unit, reg, REG_PORT_ANY, slot,
                                           &rval));
                        if (soc_reg_field_get(unit, reg, rval, MMU_PORTf) ==
                            0x3f) {
                            lanes_ctrl->group = group;
                            lanes_ctrl->slot = slot;
                            break;
                        }
                    }
                }
            } else if (fval == lanes_ctrl->cur_weight) {
                if (lanes_ctrl->cur_slot == -1) {
                    /* Find the slot used by the currnet group */
                    reg = mmu_ovs_group_regs[pipe][group];
                    count = _MMU_OVS_GROUP_TDM_LENGTH /
                        (_TD2_PORTS_PER_XLP / lanes_ctrl->cur_lanes);
                    lanes_ctrl->cur_empty = TRUE;
                    for (slot = 0; slot < count; slot++) {
                        SOC_IF_ERROR_RETURN
                            (soc_reg32_get(unit, reg, REG_PORT_ANY, slot,
                                           &rval));
                        id = soc_reg_field_get(unit, reg, rval, MMU_PORTf);
                        if (id == (mmu_port_base & 0x3f)) {
                            lanes_ctrl->cur_group = group;
                            lanes_ctrl->cur_slot = slot;
                        } else if (id != 0x3f) {
                            lanes_ctrl->cur_empty = FALSE;
                        }
                        if (lanes_ctrl->cur_slot != -1 &&
                            !lanes_ctrl->cur_empty) {
                            break;
                        }
                    }
                }
            }
            if (lanes_ctrl->slot != -1 && lanes_ctrl->cur_slot != -1) {
                break;
            }
        }

        if (lanes_ctrl->group == -1) {
            return SOC_E_FULL;
        }
    }

    /* Figure out new mode */
    if (lanes_ctrl->lanes == 4) {
        lanes_ctrl->mode = SOC_TD2_PORT_MODE_SINGLE;
    } else if (lanes_ctrl->lanes == 2) {
        if (lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_QUAD) {
            lanes_ctrl->mode = lanes_ctrl->bindex == 0 ?
                SOC_TD2_PORT_MODE_TRI_023 : SOC_TD2_PORT_MODE_TRI_012;
        } else {
            lanes_ctrl->mode = SOC_TD2_PORT_MODE_DUAL;
        }
    } else{
        if (lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_DUAL) {
            lanes_ctrl->mode = lanes_ctrl->bindex == 0 ?
                SOC_TD2_PORT_MODE_TRI_012 : SOC_TD2_PORT_MODE_TRI_023;
        } else {
            lanes_ctrl->mode = SOC_TD2_PORT_MODE_QUAD;
        }
    }

    lanes_ctrl->phy_ports_len = 0;
    if (lanes_ctrl->lanes > lanes_ctrl->cur_lanes) {
        /* Figure out which port(s) to be removed */
        if (lanes_ctrl->lanes == 4) {
            if (lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_TRI_012 ||
                lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_QUAD) {
                if (si->port_p2l_mapping[phy_port_base + 1] != -1) {
                    lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                        phy_port_base + 1;
                }
            }
            if (si->port_p2l_mapping[phy_port_base + 2] != -1) {
                lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                                      phy_port_base + 2;
            }
            if (lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_TRI_023 ||
                lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_QUAD) {
                if (si->port_p2l_mapping[phy_port_base + 3] != -1) {
                    lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                        phy_port_base + 3;
                }
            }
        } else {
            if (si->port_p2l_mapping[phy_port_base + 1] != -1) {
                lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                                      phy_port_base + 1;
            }
        }
    } else { /* Figure out which port(s) to be added */
        if (lanes_ctrl->lanes == 2) {
            if (si->port_p2l_mapping[phy_port_base + 2] != -1) {
                lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                                      phy_port_base + 2;
            }
        } else {
            if (si->port_p2l_mapping[phy_port_base + 1] != -1) {
                lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                    phy_port_base + 1;
            }
            if (lanes_ctrl->cur_mode == SOC_TD2_PORT_MODE_SINGLE) {
                if (si->port_p2l_mapping[phy_port_base + 2] != -1) {
                    lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                        phy_port_base + 2;
                }
                if (si->port_p2l_mapping[phy_port_base + 3] != -1) {
                    lanes_ctrl->phy_ports[lanes_ctrl->phy_ports_len++] =
                        phy_port_base + 3;
                }
            }
        }
    }

    if (soc_cm_debug_check(DK_VERBOSE)) {
        static char *mode_name[] = {
            "QUAD", "TRI_012", "TRI_023", "DUAL", "SINGLE"
        };
        soc_cm_print("port %d physical port %d bindex %d\n",
                     port_base, phy_port_base, lanes_ctrl->bindex);
        soc_cm_print("  mode (new:%s cur:%s) lanes (new:%d cur:%d)\n",
                     mode_name[lanes_ctrl->mode],
                     mode_name[lanes_ctrl->cur_mode],
                     lanes_ctrl->lanes, lanes_ctrl->cur_lanes);
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            soc_cm_print("  %s physical port %d (port %d)\n",
                         lanes_ctrl->lanes > lanes_ctrl->cur_lanes ?
                         "del" : "add",
                         lanes_ctrl->phy_ports[i],
                         si->port_p2l_mapping[lanes_ctrl->phy_ports[i]]);
        }
        if (lanes_ctrl->group != -1) {
            soc_cm_print("new group %d slot %d\n",
                         lanes_ctrl->group, lanes_ctrl->slot);
        }
        soc_cm_print("cur group %d slot %d\n",
                     lanes_ctrl->cur_group, lanes_ctrl->cur_slot);
    }

    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_trident2_port_lanes_set
 * Description:
 *      Configure number of lanes used by a port
 * Parameters:
 *      unit          - Device number
 *      lanes_ctrl    - Control structure
 * Notes: Caller needs to call soc_trident2_port_lanes_validate to fill
 *        in the control structure.
 */
int
soc_trident2_port_lanes_set(int unit, soc_td2_port_lanes_t *lanes_ctrl)
{
    soc_info_t *si = &SOC_INFO(unit);
    soc_reg_t reg;
    soc_field_t fields[2];
    uint32 values[2];
    int pipe, port_base, phy_port_base, port, mmu_port, i;
    uint32 rval;
    egr_enable_entry_t entry;
    static soc_reg_t mmu_port_credit_regs[] ={
        ES_PIPE0_MMU_PORT_CREDITr, ES_PIPE1_MMU_PORT_CREDITr
    };
    static soc_reg_t egr_reset_regs[] = {
        EGR_XLPORT_BUFFER_SFT_RESET_0_Xr, EGR_XLPORT_BUFFER_SFT_RESET_1_Xr,
        EGR_XLPORT_BUFFER_SFT_RESET_0_Yr, EGR_XLPORT_BUFFER_SFT_RESET_1_Yr
    };
    static soc_field_t egr_reset_fields[] = {
        XLP0_RESETf, XLP1_RESETf, XLP2_RESETf, XLP3_RESETf,
        XLP4_RESETf, XLP5_RESETf, XLP6_RESETf, XLP7_RESETf,
        XLP8_RESETf, XLP9_RESETf, XLP10_RESETf, XLP11_RESETf,
        XLP12_RESETf, XLP13_RESETf, XLP14_RESETf, XLP15_RESETf
    };

    /* Find physical port number and lane index of the specified port */
    port_base = lanes_ctrl->port_base;
    phy_port_base = si->port_l2p_mapping[port_base];
    if (phy_port_base == -1) {
        return SOC_E_PORT;
    }
    pipe = SOC_PBMP_MEMBER(si->ypipe_pbm, port_base) ? 1 : 0;

    /* Update soc_control information */
    SOC_CONTROL_LOCK(unit);
    if (lanes_ctrl->lanes > lanes_ctrl->cur_lanes) {
        /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            port = si->port_p2l_mapping[lanes_ctrl->phy_ports[i]];
            SOC_PBMP_PORT_ADD(si->all.disabled_bitmap, port);
        }
    } else { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            port = si->port_p2l_mapping[lanes_ctrl->phy_ports[i]];
            SOC_PBMP_PORT_REMOVE(si->all.disabled_bitmap, port);
        }
    }

    /* Update num of lanes info which is used by SerDes driver */
    SOC_PORT_NUM_LANES_SET(unit, port_base, lanes_ctrl->lanes);
    for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
        port = si->port_p2l_mapping[lanes_ctrl->phy_ports[i]];
        si->port_num_lanes[port] =
            lanes_ctrl->lanes > lanes_ctrl->cur_lanes ? 0 : lanes_ctrl->lanes;
    }
    SOC_CONTROL_UNLOCK(unit);

    /* De-assert EGR_ENABLE */
    sal_memset(&entry, 0, sizeof(entry));
    SOC_IF_ERROR_RETURN
        (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, phy_port_base, &entry));
    if (lanes_ctrl->lanes > lanes_ctrl->cur_lanes) {
        /* port(s) to be removed */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            SOC_IF_ERROR_RETURN
                (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL,
                                   lanes_ctrl->phy_ports[i], &entry));
        }
    }

    /* Change XLPROT mode */
    fields[0] = XPORT0_CORE_PORT_MODEf;
    values[0] = lanes_ctrl->mode;
    fields[1] = XPORT0_PHY_PORT_MODEf;
    values[1] = lanes_ctrl->mode;
    SOC_IF_ERROR_RETURN(soc_reg_fields32_modify(unit, XLPORT_MODE_REGr,
                                                port_base, 2, fields, values));

    if (lanes_ctrl->phy_ports_len > 0) {
        /* Update TDM */
        SOC_IF_ERROR_RETURN
            (_soc_trident2_port_lanes_update_tdm(unit, lanes_ctrl));
    }

    /* Clear MMU port credit before Resetting egress */
    reg = mmu_port_credit_regs[pipe];
    mmu_port = si->port_p2m_mapping[phy_port_base];
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, reg, REG_PORT_ANY, mmu_port & 0x3f, 0));
    if (lanes_ctrl->lanes < lanes_ctrl->cur_lanes) { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            mmu_port = si->port_p2m_mapping[lanes_ctrl->phy_ports[i]];
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, REG_PORT_ANY, mmu_port & 0x3f, 0));
        }
    }

    /* Reset egress hardware resource */
    reg = egr_reset_regs[si->port_serdes[port_base] / 8];
    fields[0] = egr_reset_fields[si->port_serdes[port_base] % 16];
    if (lanes_ctrl->lanes == 4 || lanes_ctrl->cur_lanes == 4) {
        /* reset all 4 lanes */
        values[0] = 4;
    } else if (lanes_ctrl->bindex == 0) { /* reset lanes 0 and 1 */
        values[0] = 1;
    } else { /* reset lanes 2 and 3 */
        values[0] = 2;
    }
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
    soc_reg_field_set(unit, reg, &rval, fields[0], values[0]);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));
    soc_reg_field_set(unit, reg, &rval, fields[0], 0);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));

    /* Assert EGR_ENABLE */
    soc_mem_field32_set(unit, EGR_ENABLEm, &entry, PRT_ENABLEf, 1);
    SOC_IF_ERROR_RETURN
        (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, phy_port_base, &entry));
    if (lanes_ctrl->lanes < lanes_ctrl->cur_lanes) { /* port(s) to be added */
        for (i = 0; i < lanes_ctrl->phy_ports_len; i++) {
            SOC_IF_ERROR_RETURN
                (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL,
                                   lanes_ctrl->phy_ports[i], &entry));
        }
    }

    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_trident2_port_lanes_get
 * Description:
 *      Get number of lanes currently used by a port
 * Parameters:
 *      unit          - Device number
 *      port_base     - Port number
 *      cur_lanes     - (OUT) Number of lanes current configured on the port
 */
int
soc_trident2_port_lanes_get(int unit, soc_port_t port_base, int *cur_lanes)
{
    soc_info_t *si = &SOC_INFO(unit);
    int cur_mode;
    int phy_port_base, i;
    int block_info_idx, bindex;
    uint32 rval;

    /* Find physical port number and lane index of the specified port */
    phy_port_base = si->port_l2p_mapping[port_base];
    if (phy_port_base == -1) {
        return SOC_E_PORT;
    }

    bindex = -1;
    for (i = 0; i < SOC_DRIVER(unit)->port_num_blktype; i++) {
        block_info_idx = SOC_PORT_IDX_BLOCK(unit, phy_port_base, i);
        if (si->port_speed_max[port_base] >= 1000000) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_CPORT) {
                bindex = SOC_PORT_IDX_BINDEX(unit, phy_port_base, i);
                break;
            }
        } else {
            if (SOC_BLOCK_INFO(unit, block_info_idx).type == SOC_BLK_XLPORT) {
                bindex = SOC_PORT_IDX_BINDEX(unit, phy_port_base, i);
                break;
            }
        }
    }

    /* Get the current mode */
    SOC_IF_ERROR_RETURN(READ_XLPORT_MODE_REGr(unit, port_base, &rval));
    cur_mode = soc_reg_field_get(unit, XLPORT_MODE_REGr, rval,
                                 XPORT0_CORE_PORT_MODEf);

    /* Figure out the current number of lane from current mode */
    switch (cur_mode) {
    case SOC_TD2_PORT_MODE_QUAD:
        *cur_lanes = 1;
        break;
    case SOC_TD2_PORT_MODE_TRI_012:
        *cur_lanes = bindex == 0 ? 1 : 2;
        break;
    case SOC_TD2_PORT_MODE_TRI_023:
        *cur_lanes = bindex == 0 ? 2 : 1;
        break;
    case SOC_TD2_PORT_MODE_DUAL:
        *cur_lanes = 2;
        break;
    case SOC_TD2_PORT_MODE_SINGLE:
        *cur_lanes = 4;
        break;
    default:
        return SOC_E_FAIL;
    }

    return SOC_E_NONE;
}

static const soc_reg_t pvtmon_result_reg[] = {
    TOP_PVTMON_RESULT_0r, TOP_PVTMON_RESULT_1r,
    TOP_PVTMON_RESULT_2r, TOP_PVTMON_RESULT_3r,
    TOP_PVTMON_RESULT_4r, TOP_PVTMON_RESULT_5r,
    TOP_PVTMON_RESULT_6r, TOP_PVTMON_RESULT_7r,
    TOP_PVTMON_RESULT_8r
};

int
soc_trident2_temperature_monitor_get(int unit, 
            int temperature_max,
            soc_switch_temperature_monitor_t *temperature_array,
            int *temperature_count)
{
    soc_reg_t reg;
    int index;
    uint32 rval;
    int fval, cur, peak;
    int num_entries_out;

    *temperature_count = 0;
    if (COUNTOF(pvtmon_result_reg) > temperature_max) {
        num_entries_out = temperature_max;
    } else {
        num_entries_out = COUNTOF(pvtmon_result_reg);
    }
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_1r, REG_PORT_ANY,
                                PVTMON_SELECTf, 0));
    sal_usleep(1000);

    for (index = 0; index < num_entries_out; index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));

        fval = soc_reg_field_get(unit, reg, rval, TEMP_DATAf);
        cur = (4100000 - (5424 * fval)) / 1000;
        fval = soc_reg_field_get(unit, reg, rval, PEAK_TEMP_DATAf);
        peak = (4100000 - (5424 * fval)) / 1000;
        (temperature_array + index)->curr = cur;
        (temperature_array + index)->peak    = peak;
    }
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TEMP_MON_PEAK_RST_Lf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TEMP_MON_PEAK_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    *temperature_count=num_entries_out;
    return SOC_E_NONE;
}

int
soc_trident2_show_material_process(int unit)
{
    soc_reg_t reg;
    int index;
    uint32 rval, fval, nmos[COUNTOF(pvtmon_result_reg)], n_avg, p_avg;

    READ_TOP_PVTMON_CTRL_1r(unit, &rval);
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RESET_Nf, 0);
    WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
    sal_usleep(1000);
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RESET_Nf, 1);
    WRITE_TOP_PVTMON_CTRL_1r(unit, rval);
    sal_usleep(1000);

    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_1r, REG_PORT_ANY,
                                PVTMON_SELECTf, 1));
    sal_usleep(1000);

    p_avg = 0;

    /* Read NMOS information */
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_0r, REG_PORT_ANY,
                                MEASUREMENT_CALLIBRATIONf, 5));

    sal_usleep(1000);

    n_avg = 0;
    for (index = 0; index < COUNTOF(pvtmon_result_reg); index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        nmos[index] = soc_reg_field_get(unit, reg, rval, TEMP_DATAf);
        n_avg += nmos[index];
    }

    /* Read PMOS information and print both NMOS and PMOS value */
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_0r, REG_PORT_ANY,
                                MEASUREMENT_CALLIBRATIONf, 7));

    sal_usleep(1000);

    p_avg = 0;
    for (index = 0; index < COUNTOF(pvtmon_result_reg); index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        fval = soc_reg_field_get(unit, reg, rval, TEMP_DATAf);
        p_avg += fval;

        soc_cm_print("Material process location %d: NMOS = %3d PMOS = %3d\n",
                     index, nmos[index], fval);
    }

    soc_cm_print("Average:                     NMOS = %3d PMOS = %3d\n",
                 n_avg / COUNTOF(pvtmon_result_reg),
                 p_avg / COUNTOF(pvtmon_result_reg));

    return SOC_E_NONE;
}

int
soc_trident2_show_ring_osc(int unit)
{
    static const struct {
        int osc_sel;
        soc_field_t field0;
        int value0;
        soc_field_t field1;
        int value1;
        char *name;
    } osc_tbl[] = {
        { 0, OSC_0_SELf, 0, INVALIDf, -1, "IO ring 0 HVT min" },
        { 0, OSC_0_SELf, 1, INVALIDf, -1, "IO ring 0 HVT mid" },
        { 0, OSC_0_SELf, 2, INVALIDf, -1, "IO ring 0 HVT max" },
        { 0, OSC_0_SELf, 3, INVALIDf, -1, "IO ring 0 SVT min" },
        { 1, OSC_1_SELf, 0, INVALIDf, -1, "IO ring 1 HVT min" },
        { 1, OSC_1_SELf, 1, INVALIDf, -1, "IO ring 1 HVT mid" },
        { 1, OSC_1_SELf, 2, INVALIDf, -1, "IO ring 1 HVT max" },
        { 1, OSC_1_SELf, 3, INVALIDf, -1, "IO ring 1 SVT min" },
        { 2, IROSC_SELf, 0, INVALIDf, -1, "Core ring 0 five stages" },
        { 2, IROSC_SELf, 1, INVALIDf, -1, "Core ring 0 nine stages" },
        { 3, IROSC_SELf, 0, INVALIDf, -1, "Core ring 1 five stages" },
        { 3, IROSC_SELf, 1, INVALIDf, -1, "Core ring 1 nine stages" },
        { 4, SRAM_OSC_0_PENf, 0, SRAM_OSC_0_NENf, 1, "SRAM ring 0 NMOS" },
        { 5, SRAM_OSC_0_PENf, 1, SRAM_OSC_0_NENf, 0, "SRAM ring 0 PMOS" },
        { 6, SRAM_OSC_1_PENf, 0, SRAM_OSC_1_NENf, 1, "SRAM ring 1 NMOS" },
        { 7, SRAM_OSC_1_PENf, 1, SRAM_OSC_1_NENf, 0, "SRAM ring 1 PMOS" },
        { 8, SRAM_OSC_2_PENf, 0, SRAM_OSC_2_NENf, 1, "SRAM ring 2 NMOS" },
        { 9, SRAM_OSC_2_PENf, 1, SRAM_OSC_2_NENf, 0, "SRAM ring 2 PMOS" },
        { 10, SRAM_OSC_3_PENf, 0, SRAM_OSC_3_NENf, 1, "SRAM ring 3 NMOS" },
        { 11, SRAM_OSC_3_PENf, 1, SRAM_OSC_3_NENf, 0, "SRAM ring 3 PMOS" },
        { 12, SRAM_OSC_4_PENf, 0, SRAM_OSC_4_NENf, 1, "SRAM ring 4 NMOS" },
        { 13, SRAM_OSC_4_PENf, 1, SRAM_OSC_4_NENf, 0, "SRAM ring 4 PMOS" },
        { 14, SRAM_OSC_5_PENf, 0, SRAM_OSC_5_NENf, 1, "SRAM ring 5 NMOS" },
        { 15, SRAM_OSC_5_PENf, 1, SRAM_OSC_5_NENf, 0, "SRAM ring 5 PMOS" },
    };
    soc_reg_t ctrl_reg, stat_reg;
    uint32 rval, fval;
    int index, core_clk, quo, rem, frac, retry;

    core_clk = SOC_INFO(unit).frequency * 1024;
    ctrl_reg = TOP_RING_OSC_CTRLr;
    stat_reg = TOP_OSC_COUNT_STATr;

    for (index = 0; index < COUNTOF(osc_tbl); index++) {
        rval = 0;
        /*
         * set OSC_CNT_RSTBf to 0 to do softreset
         * set OSC_CNT_START to 0 to hold the counter until it selects
         * the input signal
         */
        SOC_IF_ERROR_RETURN(WRITE_TOP_RING_OSC_CTRLr(unit, rval));
        soc_reg_field_set(unit, ctrl_reg, &rval, OSC_ENABLEf, 1);
        soc_reg_field_set(unit, ctrl_reg, &rval, IROSC_ENf, 1);
        soc_reg_field_set(unit, ctrl_reg, &rval, osc_tbl[index].field0,
                          osc_tbl[index].value0);
        if (osc_tbl[index].field1 != INVALIDf) {
            soc_reg_field_set(unit, ctrl_reg, &rval, osc_tbl[index].field1,
                              osc_tbl[index].value1);
        }
        soc_reg_field_set(unit, ctrl_reg, &rval, OSC_SELf,
                          osc_tbl[index].osc_sel);
        SOC_IF_ERROR_RETURN(WRITE_TOP_RING_OSC_CTRLr(unit, rval));
        soc_reg_field_set(unit, ctrl_reg, &rval, OSC_CNT_RSTBf, 1);
        SOC_IF_ERROR_RETURN(WRITE_TOP_RING_OSC_CTRLr(unit, rval));
        soc_reg_field_set(unit, ctrl_reg, &rval, OSC_CNT_STARTf, 1);
        SOC_IF_ERROR_RETURN(WRITE_TOP_RING_OSC_CTRLr(unit, rval));

        for (retry = 0; retry < 10; retry++) {
            sal_usleep(1000);
            SOC_IF_ERROR_RETURN(READ_TOP_OSC_COUNT_STATr(unit, &rval));
            if (!soc_reg_field_get(unit, stat_reg, rval, OSC_CNT_DONEf)) {
                continue;
            }

            fval = soc_reg_field_get(unit, stat_reg, rval, OSC_CNT_VALUEf);
            quo = core_clk / fval;
            rem = core_clk - quo * fval;
            frac = (rem * 10000) / fval;
            soc_cm_print("%s: %d.%04d Mhz\n",
                         osc_tbl[index].name, quo, frac);
            break;
        }
    }

    return SOC_E_NONE;
}

void
soc_td2_process_func_intr(void *unit_vp, void *d1, void *d2, void *d3, void *d4)
{
    int unit = PTR_TO_INT(unit_vp);
    uint32 rval;

    if (soc_feature(unit, soc_feature_l2_overflow)) {
        if (READ_IL2LU_INTR_STATUSr(unit, &rval)) {
            soc_cm_debug(DK_ERR, "unit %d: Error reading %s reg !!\n",
                         unit, SOC_REG_NAME(unit, IL2LU_INTR_STATUSr));
            return;
        }
        if (soc_reg_field_get(unit, IL2LU_INTR_STATUSr, rval, L2_LEARN_INSERT_FAILUREf)) {
            soc_td2_l2_overflow_interrupt_handler(unit);
        } 
    } 
    sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Don't reenable too soon */
    if (d1 != NULL) {
        (void)soc_cmicm_intr1_enable(unit, PTR_TO_INT(d1));
    }
}

int
soc_td2_port_asf_speed_set(int unit, soc_port_t port, int speed)
{
    uint32 asf_speed_mode;
    uint32 rval; 

    SOC_IF_ERROR_RETURN(READ_ASF_PORT_CFGr(unit, port, &rval));
    
    switch (speed) {
        case 10:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_10M_FULL;
            break;
        case 100:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_100M_FULL;
            break;
        case 1000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_1000M_FULL;
            break;
        case 2500:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_2500M_FULL;
            break;
        case 10000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_10000M_FULL;
            break;
        case 11000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_11000M_FULL;
            break;
        case 12000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_12000M_FULL;
            break;
        case 15000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_15000M_FULL;
            break;
        case 16000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_16000M_FULL;
            break;
        case 20000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_20000M_FULL;
            break;
        case 21000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_21000M_FULL;
            break;
        case 24000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_24000M_FULL;
            break;
        case 30000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_30000M_FULL;
            break;
        case 40000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_40000M_FULL;
            break;
        case 42000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_42000M_FULL;
            break;
        case 100000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_100000M_FULL;
            break;
        case 120000:
            asf_speed_mode = SOC_TD2_PORT_CT_SPEED_120000M_FULL;
            break;
        case 0:
            return SOC_E_NONE;
        default:
            return SOC_E_PARAM;
    }   
    
    soc_reg_field_set(unit, ASF_PORT_CFGr, &rval,
                      ASF_PORT_SPEEDf, asf_speed_mode);
    
    SOC_IF_ERROR_RETURN(WRITE_ASF_PORT_CFGr(unit, port, rval));  
    return SOC_E_NONE;
}

int
soc_trident2_port_speed_update(int unit, soc_port_t port, int speed)
{
    soc_info_t *si;
    soc_reg_t reg;
    soc_field_t field;
    uint32 rval, fval;
    int pipe, phy_port, mmu_port;
    int asf_credit_thresh_lo, asf_credit_thresh_hi;
    egr_edb_xmit_ctrl_entry_t entry;
    static soc_reg_t asf_credit_thresh_lo_regs[] = {
        ES_PIPE0_ASF_CREDIT_THRESH_LOr, ES_PIPE1_ASF_CREDIT_THRESH_LOr
    };
    static soc_reg_t asf_credit_thresh_hi_regs[] = {
        ES_PIPE0_ASF_CREDIT_THRESH_HIr, ES_PIPE1_ASF_CREDIT_THRESH_HIr
    };
    static soc_field_t t2oq_fields[] = {
        IS_MC_T2OQ_PORT0f, IS_MC_T2OQ_PORT1f
    };

    si = &SOC_INFO(unit);
    phy_port = si->port_l2p_mapping[port];
    mmu_port = si->port_p2m_mapping[phy_port];
    pipe = SOC_PBMP_MEMBER(si->ypipe_pbm, port) ? 1 : 0;

    /* Update Edatabuf transmit start count */
    if (si->frequency == 415 && !SOC_PBMP_MEMBER(si->oversub_pbm, port)) {
        SOC_IF_ERROR_RETURN(soc_mem_read(unit, EGR_EDB_XMIT_CTRLm,
                                         MEM_BLOCK_ALL, phy_port, &entry));
        soc_mem_field32_set(unit, EGR_EDB_XMIT_CTRLm, &entry, START_CNTf,
                            speed > 11000 ? 8 : 7);
        SOC_IF_ERROR_RETURN(soc_mem_write(unit, EGR_EDB_XMIT_CTRLm,
                                          MEM_BLOCK_ALL, phy_port, &entry));
    }

    /* Updtae VBS (HSP) port multicast T2OQ setting */
    if (SOC_PBMP_MEMBER(si->eq_pbm, port) && si->frequency < 500) {
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, TOQ_MC_CFG1r, REG_PORT_ANY, 0, &rval));
        field = t2oq_fields[pipe];
        fval = soc_reg_field_get(unit, TOQ_MC_CFG1r, rval, field);
        if (speed >= 30000) {
            fval |= 1 << (mmu_port & 0x3f);
        } else {
            fval &= ~(1 << (mmu_port & 0x3f));
        }
        soc_reg_field_set(unit, TOQ_MC_CFG1r, &rval, field, fval);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, TOQ_MC_CFG1r, REG_PORT_ANY, 0, rval));
    }

    /* Update cut through credit threshold */
    if (speed > 21000){
        asf_credit_thresh_lo = 18;
        asf_credit_thresh_hi = 36;
    } else if (speed > 11000) {
        asf_credit_thresh_lo = 9;
        asf_credit_thresh_hi = 18;
    } else {
        asf_credit_thresh_lo = 4;
        asf_credit_thresh_hi = 9;
    }
    reg = asf_credit_thresh_lo_regs[pipe];
    rval = 0;
    soc_reg_field_set(unit, reg, &rval, THRESHf, asf_credit_thresh_lo);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, reg, REG_PORT_ANY, mmu_port & 0x3f, rval));
    reg = asf_credit_thresh_hi_regs[pipe];
    rval = 0;
    soc_reg_field_set(unit, reg, &rval, THRESHf, asf_credit_thresh_hi);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, reg, REG_PORT_ANY, mmu_port & 0x3f, rval));

    SOC_IF_ERROR_RETURN(soc_td2_port_asf_speed_set(unit, port, speed));

    return SOC_E_NONE;
}


#if defined(SER_TR_TEST_SUPPORT)

#define MAX_HW_TCAMS 20
typedef struct ser_td2_skipped_mem_s {
    soc_mem_t mem;
    acc_type_t acc_type;
} ser_td2_skipped_mem_t;

const ser_td2_skipped_mem_t skipped_mems[] = {
    {FP_METER_TABLEm, _SOC_ACC_TYPE_PIPE_Y},
    {ING_L3_NEXT_HOPm, _SOC_ACC_TYPE_PIPE_Y},
    {L2MCm, _SOC_ACC_TYPE_PIPE_Y},
    {L3_IPMCm, _SOC_ACC_TYPE_PIPE_Y},
    {OAM_LM_COUNTERSm, _SOC_ACC_TYPE_PIPE_Y},
    {OAM_LM_COUNTERSm, _SOC_ACC_TYPE_PIPE_ANY},
    {MODPORT_MAP_M3m, _SOC_ACC_TYPE_PIPE_ANY},
    {MODPORT_MAP_M2m, _SOC_ACC_TYPE_PIPE_ANY},
    {MODPORT_MAP_M1m, _SOC_ACC_TYPE_PIPE_ANY},
    {ING_VLAN_TAG_ACTION_PROFILEm, _SOC_ACC_TYPE_PIPE_Y},
    {ING_VLAN_TAG_ACTION_PROFILEm, _SOC_ACC_TYPE_PIPE_ANY},
    {VLAN_PROTOCOL_DATAm, _SOC_ACC_TYPE_PIPE_Y},
    {VLAN_PROTOCOL_DATAm, _SOC_ACC_TYPE_PIPE_ANY},
    {L3_DEFIPm,_SOC_ACC_TYPE_PIPE_ANY},
    {L3_DEFIP_PAIR_128m,_SOC_ACC_TYPE_PIPE_ANY},
    {VLAN_SUBNETm, _SOC_ACC_TYPE_PIPE_ANY},
    {VLAN_SUBNETm, _SOC_ACC_TYPE_PIPE_Y},
    {INVALIDm}
};


STATIC acc_type_t
_soc_trident2_pipe_to_acc_type(int pipe)
{
    acc_type_t rv;
    switch (pipe) {
        case 0:
            rv = _SOC_ACC_TYPE_PIPE_GROUP;
            break;
        case 1:
            rv = _SOC_ACC_TYPE_PIPE_Y;
            break;
        default:
            rv =_SOC_ACC_TYPE_PIPE_ANY;
    };
    return rv;
}


/*
 * Function:
 *      _soc_trident2_perform_ser_test
 * Purpose:
 *      Performs test operations common to TCAM and FIFO memory tests before
 *      invoking common SER test.
 * Parameters:
 *      unit        - (IN) Device Number
 *      test_data   - (IN) Test data required for SER test
 *      test_type   - (IN) How many indices to test for each memory
 *      mem_failed  - (OUT) Incremented when memories fail the test.
 * Returns:
 *  SOC_E_NONE if test passes, an error otherwise (multiple types of errors are
 *      possible.)
 */
soc_error_t
_soc_trident2_perform_ser_test(int unit, ser_test_data_t *test_data,
                                   _soc_ser_test_t test_type,
                                   int *mem_skipped, int *mem_failed)
{
    int k, skip_mem = FALSE;
    soc_error_t rv = SOC_E_NONE;

    for (k = 0; skipped_mems[k].mem != INVALIDm; k++) {
        if ((skipped_mems[k].mem == test_data->mem) &&
            (skipped_mems[k].acc_type == test_data->acc_type)) {
            skip_mem = TRUE;
        }
    }
    if (!skip_mem) {
        soc_trident2_pipe_select(unit, TRUE,
                ((test_data->acc_type == _SOC_ACC_TYPE_PIPE_Y) ? 1 : 0));
        soc_trident2_pipe_select(unit, FALSE,
                ((test_data->acc_type == _SOC_ACC_TYPE_PIPE_Y) ? 1 : 0));
        rv = ser_test_mem(unit, test_data, test_type, mem_failed);
        soc_trident2_pipe_select(unit, TRUE, 0);
        soc_trident2_pipe_select(unit, FALSE, 0);
    } else {
        soc_cm_debug(DK_VERBOSE,
            "Memory %s skipped due to known issues.\n",
            SOC_MEM_NAME(unit,test_data->mem));
        (*mem_skipped)++;
    }
    return rv;
}

/*
 * Function:
 *      soc_td2_ser_test
 * Purpose:
 *      Tests that SER is working for all supported memories.
 * Parameters:
 *      unit        - (IN) Device Number
 *      test_type   - (IN) How many indices to test for each memory
 * Returns:
 *  SOC_E_NONE if test passes, an error otherwise (multiple types of errors are
 *      possible.)
 */
soc_error_t
soc_td2_ser_test (int unit, _soc_ser_test_t test_type) {
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], fieldData[SOC_MAX_REG_FIELD_WORDS];
    ser_test_data_t test_data;
    int mem_failed = 0, mem_tests = 0, mem_skipped = 0;
    _soc_td2_fifo_ser_info_t *fifo_parity = _soc_td2_ip_ser_info;
    _soc_generic_ser_info_t *tcams = _soc_td2_tcam_ser_info[unit];
    int i,j;
    acc_type_t acc_type;
    /*Test TCAM memories*/
    for (i = 0; tcams[i].mem != INVALIDm; i++) {
        mem_tests++;
        if ( i >= MAX_HW_TCAMS) {
            mem_skipped++;
            soc_cm_debug(DK_VERBOSE,
                        "Memory %s skipped due to lack of test mechanism \
                        for Software-protected TCAMS.\n",
                        SOC_MEM_NAME(unit,test_data.mem));
            continue;
        }
        if (tcams[i].ser_flags & _SOC_MEM_ADDR_ACC_TYPE_PIPE_Y) {
            acc_type = _SOC_ACC_TYPE_PIPE_Y;
        } else {
            acc_type = _SOC_ACC_TYPE_PIPE_ANY;
        }
        soc_ser_create_test_data(unit, tmp_entry, fieldData, SER_RANGE_ENABLEr, i, INVALIDf,
                                 tcams[i].mem, INVALIDf, MEM_BLOCK_ANY, REG_PORT_ANY,
                                 acc_type, &test_data);
        _soc_trident2_perform_ser_test(unit, &test_data, test_type, &mem_skipped, &mem_failed);
    }
    soc_cm_print("\nTCAM memories tested on unit %d: %d\n", unit, mem_tests);
    soc_cm_print("TCAM tests passed:\t%d\n", mem_tests - mem_failed - mem_skipped);
    soc_cm_print("TCAM tests skipped:\t%d (use verbose option to see skipped memories)\n",
                mem_skipped);
    soc_cm_print("TCAM tests failed:\t%d\n\n", mem_failed);
    mem_tests = 0;
    mem_failed = 0;
    mem_skipped = 0;
    /*Test for FIFO memories*/
    for (i = 0; _soc_td2_ser_block_info[i].blocktype != 0; i++) {
        fifo_parity = _soc_td2_ser_block_info[i].info;
        for (j = 0; fifo_parity[j].enable_reg != INVALIDr;j++) {
            if (fifo_parity[j].mem != INVALIDm) {
                mem_tests += 2;
                test_data.test_field = EVEN_PARITYf;
                acc_type = _SOC_ACC_TYPE_PIPE_Y;
                soc_ser_create_test_data(unit, tmp_entry, fieldData, fifo_parity[j].enable_reg,
                                         INVALID_TCAM_PARITY_BIT, fifo_parity[j].enable_field,
                                         fifo_parity[j].mem, test_data.test_field, MEM_BLOCK_ANY,
                                         REG_PORT_ANY, acc_type, &test_data);
                if (test_data.mem_info == NULL) {
                    mem_skipped += 2;
                    soc_cm_debug(DK_VERBOSE,
                                "Memory %s skipped due to lack of mem_info structure.\n",
                                SOC_MEM_NAME(unit,test_data.mem));
                    continue;
                }
                _soc_trident2_perform_ser_test(unit, &test_data, test_type,
                                               &mem_skipped, &mem_failed);
                test_data.acc_type = _SOC_ACC_TYPE_PIPE_ANY;
                _soc_trident2_perform_ser_test(unit, &test_data, test_type,
                                               &mem_skipped, &mem_failed);
            }
        }
    }
    soc_cm_print("\nH/W memories tested on unit %d: %d\n", unit, mem_tests);
    soc_cm_print("H/W tests passed:\t%d\n", mem_tests - mem_failed - mem_skipped);
    soc_cm_print("H/W tests skipped:\t%d (use verbose option to see skipped memories)\n",
                mem_skipped);
    soc_cm_print("H/W tests failed:\t%d\n\n", mem_failed);
    return SOC_E_NONE;
}


/*
 * Function:
 *      soc_ser_inject_or_test_mem
 * Purpose:
 *      Provide a common function for injecting errors and testing single
 *      single memories
 * Parameters:
 *      unit        - (IN) Device Number
 *      mem         - (IN) The memory into which an error will be injected
 *      pipeTarget  - (IN) The pipe (x/y) to use when injecting the error
 *      index       - (IN) The index into which the error will be injected.
 *      test_type   - (IN) How many indices to test in the passes memory
 *      cmd         - (IN) TRUE if a command-line test is desired.
 * Returns:
 *      SOC_E_NONE if test passes, an error otherwise (multiple types of errors
 *      are possible.)
 */
soc_error_t
soc_ser_inject_or_test_mem (int unit, soc_mem_t mem, int pipe_target, int block, int index,
                            _soc_ser_test_t test_type, int inject_only, int cmd)
{
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], fieldData[SOC_MAX_REG_FIELD_WORDS];
    ser_test_data_t test_data;
    _soc_td2_fifo_ser_info_t *fifo_parity = _soc_td2_ip_ser_info;
    _soc_generic_ser_info_t *tcams = _soc_td2_tcam_ser_info[unit];
    int i,j, error_count = 0, skip_count = 0;
    acc_type_t acc_type_target = _soc_trident2_pipe_to_acc_type(pipe_target);
    /*Search for TCAM memories*/
    for (i = 0; tcams[i].mem != INVALIDm; i++) {
        if (tcams[i].mem == mem) {
            soc_ser_create_test_data(unit, tmp_entry, fieldData,
                                     SER_RANGE_ENABLEr, i, INVALIDf, mem,
                                     INVALIDf, block, REG_PORT_ANY,
                                     acc_type_target, &test_data);
            break; /*A memory was found that matched, so we can stop searching.*/
        }
    }
    /*Search for FIFO memories*/
    for (i = 0; _soc_td2_ser_block_info[i].blocktype != 0; i++) {
        fifo_parity = _soc_td2_ser_block_info[i].info;
        for (j = 0; fifo_parity[j].enable_reg != INVALIDr;j++) {
            if (fifo_parity[j].mem != INVALIDm && fifo_parity[j].mem == mem) {
                soc_ser_create_test_data(unit, tmp_entry, fieldData,
                                         fifo_parity[j].enable_reg,
                                         INVALID_TCAM_PARITY_BIT,
                                         fifo_parity[j].enable_field,
                                         mem, EVEN_PARITYf, block,
                                         REG_PORT_ANY, acc_type_target,
                                         &test_data);
                break; /*A memory was found that matched, so we can stop searching.*/
            }
        }
    }
    if (inject_only) {
        /*Read the memory (required for successful injection)*/
        SOC_IF_ERROR_RETURN(ser_test_mem_read(unit, &test_data));
        /*Disable parity*/
        SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 0));
        /* set x/y pipe select*/
        soc_trident2_pipe_select(unit, TRUE,
                ((test_data.acc_type == _SOC_ACC_TYPE_PIPE_Y) ? 1 : 0));
        soc_trident2_pipe_select(unit, FALSE,
                ((test_data.acc_type == _SOC_ACC_TYPE_PIPE_Y) ? 1 : 0));
         /*Inject error*/
        SOC_IF_ERROR_RETURN(soc_ser_test_inject_error(unit, &test_data));
        soc_trident2_pipe_select(unit, TRUE, 0);
        soc_trident2_pipe_select(unit, FALSE, 0);
        /*Enable parity*/
        SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 1));
    } else {
        if (cmd) {
            test_data.acc_type = _SOC_ACC_TYPE_PIPE_ANY;
            ser_test_cmd_generate(unit, &test_data);
            test_data.acc_type = _SOC_ACC_TYPE_PIPE_Y;
            ser_test_cmd_generate(unit, &test_data);
        } else {
            _soc_trident2_perform_ser_test(unit, &test_data, test_type,
                                           &skip_count, &error_count);
            if (error_count == 0) {
                soc_cm_print("SER test PASSED for memory %s\n",
                             test_data.mem_name);
            }
            if (skip_count !=0) {
                soc_cm_print("Test skipped due to know issues with this memory.\n");
            }
        }
    }
    return SOC_E_NONE;
}


/*
 * Function:
 *      soc_td2_ser_inject_error
 * Purpose:
 *      Injects an error into a single td2 memory
 * Parameters:
 *      unit        - (IN) Device Number
 *      mem         - (IN) The memory into which an error will be injected
 *      pipeTarget  - (IN) The pipe (x/y) to use when injecting the error
 *      index       - (IN) The index into which the error will be injected.
 */
soc_error_t
soc_td2_ser_inject_error (int unit, soc_mem_t mem, int pipe_target,
                          int block, int index)
{
    return soc_ser_inject_or_test_mem(unit, mem, pipe_target, block, index,
                                      SER_SINGLE_INDEX, TRUE, FALSE);
}


/*
 * Function:
 *      soc_td2_ser_test_mem
 * Purpose:
 *      Perform SER test on a single memory, or generate a test the user can
 *      enter by the command line.
 * Parameters:
 *      unit        - (IN) Device Number
 *      mem         - (IN) The memory into which an error will be injected
 *      test_type   - (IN) How many indices to test in the passes memory
 *      cmd         - (IN) TRUE if a command-line test is desired.
 * Returns:
 *      SOC_E_NONE if test passes, an error otherwise (multiple types of errors
 *      are possible.)
 */
soc_error_t
soc_td2_ser_test_mem(int unit, soc_mem_t mem, _soc_ser_test_t test_type, int cmd)
{
    return soc_ser_inject_or_test_mem(unit, mem, -1, MEM_BLOCK_ANY, 0,
                                      test_type, FALSE, cmd);
}
#endif /*defined(SER_TR_TEST_SUPPORT)*/
#endif /* BCM_TRIDENT2_SUPPORT */
