/*
 * $Id: katana2.c 1.145.2.5 Broadcom SDK $
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 *
 * File:        katana2.c
 * Purpose:
 * Requires:
 */


#include <sal/core/boot.h>

#include <soc/katana2.h>
#include <soc/trident.h>
#include <soc/bradley.h>
#include <soc/drv.h>
#include <soc/error.h>
#include <soc/debug.h>
#include <soc/mem.h>
#include <soc/hash.h>
#include <soc/shmoo_ddr40.h>
#include <soc/phy/ddr40.h>
#include <soc/mspi.h>
#include <soc/phyreg.h>

#ifdef BCM_KATANA2_SUPPORT
#include <bcm_int/esw/katana2.h>

typedef enum {
    _SOC_PARITY_TYPE_NONE,
    _SOC_PARITY_TYPE_GENERIC,
    _SOC_PARITY_TYPE_PARITY,
    _SOC_PARITY_TYPE_ECC,
    _SOC_PARITY_TYPE_HASH,
    _SOC_PARITY_TYPE_EDATABUF,
    _SOC_PARITY_TYPE_COUNTER,
    _SOC_PARITY_TYPE_SER,
    _SOC_PARITY_INFO_TYPE_OAM
} _soc_kt2_parity_info_type_t;

typedef enum {
    _SOC_KT2_MMU_SUBBLOCK_IPCTR,
    _SOC_KT2_MMU_SUBBLOCK_ADM,
    _SOC_KT2_MMU_SUBBLOCK_RDE,
    _SOC_KT2_MMU_SUBBLOCK_CI5,
    _SOC_KT2_MMU_SUBBLOCK_CI4,
    _SOC_KT2_MMU_SUBBLOCK_CI3,
    _SOC_KT2_MMU_SUBBLOCK_MEM1,
    _SOC_KT2_MMU_SUBBLOCK_INTFI,
    _SOC_KT2_MMU_SUBBLOCK_INTFI_ECC,
    _SOC_KT2_MMU_SUBBLOCK_E2EFC,
    _SOC_KT2_MMU_SUBBLOCK_ITE,
    _SOC_KT2_MMU_SUBBLOCK_ITE_CFG,
    _SOC_KT2_MMU_SUBBLOCK_THDI,
    _SOC_KT2_MMU_SUBBLOCK_ENQ_CFG,
    _SOC_KT2_MMU_SUBBLOCK_ENQ,
    _SOC_KT2_MMU_SUBBLOCK_ENQ_FAP,
    _SOC_KT2_MMU_SUBBLOCK_CI2,
    _SOC_KT2_MMU_SUBBLOCK_CI1,
    _SOC_KT2_MMU_SUBBLOCK_CI0,
    _SOC_KT2_MMU_SUBBLOCK_WRED,
    _SOC_KT2_MMU_SUBBLOCK_THDO_STATUS1,
    _SOC_KT2_MMU_SUBBLOCK_THDO_STATUS2,
    _SOC_KT2_MMU_SUBBLOCK_RQE_SER,
    _SOC_KT2_MMU_SUBBLOCK_RQE_EXTQ,
    _SOC_KT2_MMU_SUBBLOCK_EMC,
    _SOC_KT2_MMU_SUBBLOCK_DEQ,
    _SOC_KT2_MMU_SUBBLOCK_CTR,
    _SOC_KT2_MMU_SUBBLOCK_CFAPI,
    _SOC_KT2_MMU_SUBBLOCK_CFAPE,
    _SOC_KT2_MMU_SUBBLOCK_CCP,
    _SOC_KT2_MMU_SUBBLOCK_AGING_INT,
    _SOC_KT2_MMU_SUBBLOCK_AGING_EXT,
    _SOC_KT2_MMU_SUBBLOCK_LLS,
    _SOC_KT2_MMU_SUBBLOCK_LLS_PORT,
    _SOC_KT2_MMU_SUBBLOCK_LLS_L0_ECC,
    _SOC_KT2_MMU_SUBBLOCK_LLS_UPD2,
    _SOC_KT2_MMU_SUBBLOCK_LLS_L1_ECC,
    _SOC_KT2_MMU_SUBBLOCK_LLS_L2_ECC,
    _SOC_KT2_MMU_SUBBLOCK_LLS_MISC_ECC,
    _SOC_KT2_MMU_SUBBLOCK_QSTRUCT,
    _SOC_KT2_MMU_SUBBLOCK_TOQ,
    _SOC_KT2_MMU_SUBBLOCK_MAX
} _soc_katana2_mmu_subblock_type_t;

typedef enum {
    _SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_0,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_1,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_2,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_3,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_0,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_1,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_2,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_3,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_4,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_QENTRY_U,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_QENTRY_L,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_QBLOCK,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_FAP,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_TOQ_ERROR_2,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_TOQ_ERROR_1,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_MAX
} _soc_katana2_mmu_lvl2_subblock_type_t;

typedef struct _soc_katana2_parity_reg_s {
    soc_reg_t          reg;
    char               *mem_str;
} _soc_katana2_parity_reg_t;

typedef struct _soc_katana2_parity_info_s {
    _soc_kt2_parity_info_type_t       type;
    struct _soc_katana2_parity_info_s *info;
    int                id;
    soc_field_t        group_reg_enable_field;
    soc_field_t        group_reg_status_field;
    soc_mem_t          mem;
    char               *mem_str;
    soc_reg_t          enable_reg;
    soc_field_t        enable_field;
    soc_reg_t          intr_status_reg;
    _soc_katana2_parity_reg_t         *intr_status_reg_list;
    soc_reg_t                         nack_status_reg;
    _soc_katana2_parity_reg_t         *nack_status_reg_list;
} _soc_katana2_parity_info_t;

typedef struct _soc_katana2_parity_route_block_s {
    uint32             cmic_bit;
    soc_block_t        blocktype;
    soc_reg_t          enable_reg;
    soc_reg_t          status_reg;
    _soc_katana2_parity_info_t *info;
    uint8              id;
} _soc_katana2_parity_route_block_t;

typedef struct _soc_katana2_mmu_sub_block_leaf_info_s {
    uint32             intr_bit; /* bit position in intr register of 
                                    sub block */
    soc_field_t        status_field; /* INTR field of a leaf block */
    soc_field_t        enable_field; /* MASK field of a leaf block */
} _soc_katana2_mmu_sub_block_leaf_info_t;

typedef struct _soc_katana2_mmu_sub_block_internal_info_s {
    uint32             intr_bit; /* bit position in level 1 sub block INTR and 
                                    INTR_MASK */
    _soc_katana2_mmu_lvl2_subblock_type_t lvl2_sub_block; /* level 2 sub block 
                                                           */
    soc_field_t        internal_enable_field; /* field in 1evel 1 sub block INTR 
                                                 MASK register */
    soc_field_t        internal_status_field; /* field in level 1 sub block INTR 
                                                 register */
    soc_reg_t          leaf_enable_reg;   /* intr mask register for level 2 sub 
                                             block */
    soc_reg_t          leaf_status_reg;   /* intr register for level 2 sub block 
                                           */
    _soc_katana2_mmu_sub_block_leaf_info_t *info;
} _soc_katana2_mmu_sub_block_internal_info_t;

typedef struct _soc_katana2_mmu_sub_block_one_level_s {
    uint32             mmu_bit;  /* bit position in MMU_INTR and MMU_INTR_MASK 
                                  */
    _soc_katana2_mmu_subblock_type_t mmu_sub_block; /* level 1 sub block */
    soc_field_t        mmu_enable_field; /* field in MMU_INTR_MASK */
    soc_field_t        mmu_status_field; /* field in MMU_INTR */
    soc_reg_t          leaf_enable_reg; /* intr mask register for sub block */
    soc_reg_t          leaf_status_reg; /* intr register for sub block */
    _soc_katana2_mmu_sub_block_leaf_info_t *info; /* list of memory instances */
} _soc_katana2_mmu_sub_block_one_level_t;

typedef struct _soc_katana2_mmu_sub_block_two_level_s {
    uint32             mmu_bit; /* bit position in MMU_INTR and MMU_INTR_MASK */
    _soc_katana2_mmu_subblock_type_t mmu_sub_block; /* level 1 sub block */
    soc_field_t        mmu_enable_field; /* field in MMU_INTR_MASK */
    soc_field_t        mmu_status_field; /* field in MMU_INTR */
    soc_reg_t          internal_enable_reg; /* intr mask for sub block */
    soc_reg_t          internal_status_reg; /* intr for sub block */
    _soc_katana2_mmu_sub_block_internal_info_t *info;
} _soc_katana2_mmu_sub_block_two_level_t;


STATIC _soc_katana2_parity_reg_t _soc_katana2_egr_vlan_xlate_intr_reg[] = {
    { EGR_VLAN_XLATE_PARITY_STATUS_INTR_0r, NULL },
    { EGR_VLAN_XLATE_PARITY_STATUS_INTR_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_egr_vlan_xlate_nack_reg[] = {
    { EGR_VLAN_XLATE_PARITY_STATUS_NACK_0r, NULL },
    { EGR_VLAN_XLATE_PARITY_STATUS_NACK_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_vlan_xlate_intr_reg[] = {
    { VLAN_XLATE_PARITY_STATUS_INTR_0r, NULL },
    { VLAN_XLATE_PARITY_STATUS_INTR_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_vlan_xlate_nack_reg[] = {
    { VLAN_XLATE_PARITY_STATUS_NACK_0r, NULL },
    { VLAN_XLATE_PARITY_STATUS_NACK_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_mpls_entry_intr_reg[] = {
    { MPLS_ENTRY_PARITY_STATUS_INTR_0r, NULL },
    { MPLS_ENTRY_PARITY_STATUS_INTR_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_mpls_entry_nack_reg[] = {
    { MPLS_ENTRY_PARITY_STATUS_NACK_0r, NULL },
    { MPLS_ENTRY_PARITY_STATUS_NACK_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_l3_entry_only_intr_reg[] = {
    { L3_ENTRY_PARITY_STATUS_INTR_0r, NULL },
    { L3_ENTRY_PARITY_STATUS_INTR_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_l3_entry_only_nack_reg[] = {
    { L3_ENTRY_PARITY_STATUS_NACK_0r, NULL },
    { L3_ENTRY_PARITY_STATUS_NACK_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_l2_entry_only_intr_reg[] = {
    { L2_ENTRY_PARITY_STATUS_INTR_0r, NULL },
    { L2_ENTRY_PARITY_STATUS_INTR_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_l2_entry_only_nack_reg[] = {
    { L2_ENTRY_PARITY_STATUS_NACK_0r, NULL },
    { L2_ENTRY_PARITY_STATUS_NACK_1r, NULL } };

STATIC _soc_katana2_parity_reg_t _soc_katana2_egr_mp_group_intr_reg[] = {
    { EGR_MP_GROUP_PARITY_STATUS_INTR_0r, NULL },
    { EGR_MP_GROUP_PARITY_STATUS_INTR_1r, NULL } };

STATIC _soc_katana2_parity_reg_t _soc_katana2_egr_mp_group_nack_reg[] = {
    { EGR_MP_GROUP_PARITY_STATUS_NACK_0r, NULL },
    { EGR_MP_GROUP_PARITY_STATUS_NACK_1r, NULL } };

STATIC _soc_katana2_parity_info_t _soc_katana2_xport_parity_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        TXFIFO_MEM_ERRf,
        TXFIFO_MEM_ERRf,
        INVALIDm, "TX FIFO",
        INVALIDr, INVALIDf,
        XPORT_TXFIFO_MEM_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_TSC_MEM0_ERRf,
        MIB_TSC_MEM0_ERRf,
        INVALIDm, "TX MIB MEM0",
        INVALIDr, INVALIDf,
        XPORT_MIB_TSC_MEM0_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_TSC_MEM1_ERRf,
        MIB_TSC_MEM1_ERRf,
        INVALIDm, "TX MIB MEM1",
        INVALIDr, INVALIDf,
        XPORT_MIB_TSC_MEM1_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_TSC_MEM2_ERRf,
        MIB_TSC_MEM2_ERRf,
        INVALIDm, "TX MIB MEM2",
        INVALIDr, INVALIDf,
        XPORT_MIB_TSC_MEM2_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_TSC_MEM3_ERRf,
        MIB_TSC_MEM3_ERRf,
        INVALIDm, "TX MIB MEM3",
        INVALIDr, INVALIDf,
        XPORT_MIB_TSC_MEM3_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC_MEM0_ERRf,
        MIB_RSC_MEM0_ERRf,
        INVALIDm, "RX MIB MEM0",
        INVALIDr, INVALIDf,
        XPORT_MIB_RSC_MEM0_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC_MEM1_ERRf,
        MIB_RSC_MEM1_ERRf,
        INVALIDm, "RX MIB MEM1",
        INVALIDr, INVALIDf,
        XPORT_MIB_RSC_MEM1_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC_MEM2_ERRf,
        MIB_RSC_MEM2_ERRf,
        INVALIDm, "RX MIB MEM2",
        INVALIDr, INVALIDf,
        XPORT_MIB_RSC_MEM2_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC_MEM3_ERRf,
        MIB_RSC_MEM3_ERRf,
        INVALIDm, "RX MIB MEM3",
        INVALIDr, INVALIDf,
        XPORT_MIB_RSC_MEM3_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC_MEM4_ERRf,
        MIB_RSC_MEM4_ERRf,
        INVALIDm, "RX MIB MEM4",
        INVALIDr, INVALIDf,
        XPORT_MIB_RSC_MEM4_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RXFIFO_MEM0_ERRf,
        RXFIFO_MEM0_ERRf,
        INVALIDm, "RX FIFO MEM0",
        INVALIDr, INVALIDf,
        XPORT_RXFIFO_MEM0_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RXFIFO_MEM1_ERRf,
        RXFIFO_MEM1_ERRf,
        INVALIDm, "RX FIFO MEM1",
        INVALIDr, INVALIDf,
        XPORT_RXFIFO_MEM1_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RXFIFO_MEM2_ERRf,
        RXFIFO_MEM2_ERRf,
        INVALIDm, "RX FIFO MEM2",
        INVALIDr, INVALIDf,
        XPORT_RXFIFO_MEM2_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RXFIFO_MEM3_ERRf,
        RXFIFO_MEM3_ERRf,
        INVALIDm, "RX FIFO MEM3",
        INVALIDr, INVALIDf,
        XPORT_RXFIFO_MEM3_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RXFIFO_MEM4_ERRf,
        RXFIFO_MEM4_ERRf,
        INVALIDm, "RX FIFO MEM4",
        INVALIDr, INVALIDf,
        XPORT_RXFIFO_MEM4_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_rxlp_parity_info[] = {
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MAIN_BUFF_ECC_INTR_ENABLEf,
        MAIN_BUFF_ECC_INTR_STATUSf,
        INVALIDm, "main data buffer",
        RXLP_ECC_PARITY_CONTROLr, DATABUF_ECC_ENf,
        RXLP_DATABUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
        
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        CTRL_BUFFER_ECC_INTR_ENABLEf,
        CTRL_BUFF_ECC_INTR_STATUSf,
        INVALIDm, "ctrl data buffer",
        RXLP_ECC_PARITY_CONTROLr, CTRLBUF_ECC_ENf,
        RXLP_CTRLBUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RESIDUAL_CRC_ECC_INTR_ENABLEf,
        RESIDUAL_CRC_ECC_INTR_STATUSf,
        INVALIDm, "Residual CRC Buffer ",
        RXLP_ECC_PARITY_CONTROLr, RESIDUALCRC_ECC_ENf,
        RXLP_RESIDUAL_CRC_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        IARB_BUF_ECC_INTR_ENABLEf,
        IARB_BUF_ECC_INTR_STATUSf,
        INVALIDm, "IARB Buffer",
        RXLP_ECC_PARITY_CONTROLr, IARBBUF_ECC_ENf,
        RXLP_IARBBUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        TRIGGER_MEM_PARITY_ERR_INTR_ENABLEf,
        TRIGGER_MEM_PARITY_ERRf,
        INVALIDm, "IARB Buffer",
        RXLP_ECC_PARITY_CONTROLr, TRIGGERS_MEM_PARITY_ENf,
        RXLP_TRIGGER_MEM_PARITY_STATUSr, NULL,
        RXLP_TRIGGER_MEM_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        COUNTER_MEM_PARITY_ERR_INTR_ENABLEf,
        COUNTER_MEM_PARITY_ERRf,
        INVALIDm, "IARB Buffer",
        RXLP_ECC_PARITY_CONTROLr, COUNTERS_MEM_PARITY_ENf,
        RXLP_COUNTER_MEM_PARITY_STATUSr, NULL,
        RXLP_COUNTER_MEM_PARITY_STATUS_NACKr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_txlp_parity_info[] = {
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        INT2EXT_PARITY_ERRf,
        INT2EXT_PARITY_ERRf,
        INVALIDm, "INT2EXT-MAP-TABLE",
        TXLP_ECC_PARITY_CONTROLr, INT2EXT_STREAM_MAP_PARITY_ENf,
        TXLP_DATABUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RESICRCBUF_PARITY_ERRf,
        RESICRCBUF_PARITY_ERRf,
        INVALIDm, "RESIDUAL-CRC-BUFFER",
        TXLP_ECC_PARITY_CONTROLr, RESICRCBUF_PARITY_ENf,
        TXLP_RESICRCBUF_PARITY_STATUSr, NULL,
        INVALIDr, NULL },    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RESIDATABUF_ECC_ERRf,
        RESIDATABUF_ECC_ERRf,
        INVALIDm, "RESIDUAL-DATA-BUFFER",
        TXLP_ECC_PARITY_CONTROLr, RESIDATABUF_ECC_ENf,
        TXLP_RESIDATABUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        DATABUF_ECC_ERRf,
        DATABUF_ECC_ERRf,
        INVALIDm, "MAIN-DATA-BUFFER.",
        TXLP_ECC_PARITY_CONTROLr, DATABUF_ECC_ENf,
        TXLP_DATABUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        CTRLBUF_ECC_ERRf,
        CTRLBUF_ECC_ERRf,
        INVALIDm, "MAIN-CTRL-BUFFER.",
        TXLP_ECC_PARITY_CONTROLr, CTRLBUF_ECC_ENf,
        TXLP_CTRLBUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TRIGGER_MEM_PARITY_ERRf,
        TRIGGER_MEM_PARITY_ERRf,
        INVALIDm, "TXLP_DEBUG_COUNTER[0-7]",
        TXLP_ECC_PARITY_CONTROLr, TRIGGERS_MEM_PARITY_ENf,
        TXLP_TRIGGER_MEM_PARITY_STATUSr, NULL,
        TXLP_TRIGGER_MEM_PARITY_STATUS_NACKr, NULL },
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        COUNTER_MEM_PARITY_ERRf,
        COUNTER_MEM_PARITY_ERRf,
        INVALIDm, "TXLP_DEBUG_COUNTER[8-11]",
        TXLP_ECC_PARITY_CONTROLr, COUNTERS_MEM_PARITY_ENf,
        TXLP_COUNTER_MEM_PARITY_STATUSr, NULL,
        TXLP_COUNTER_MEM_PARITY_STATUS_NACKr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};


STATIC 
_soc_katana2_mmu_sub_block_leaf_info_t _soc_katana2_mmu_sb_ipctr_parity_info[] = {
    /* MMU_IPCTR_ECC_ERROR_0 */
    { 0x0020, CTXT_COUNTER_0_CORRECTED_ERRORf,
	     CTXT_COUNTER_0_CORRECTED_ERROR_DISINTf},
    { 0x0010, CTXT_COUNTER_0_UNCORRECTED_ERRORf,
	     CTXT_COUNTER_0_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, PG_COUNTER_1_CORRECTED_ERRORf,
	     PG_COUNTER_1_CORRECTED_ERROR_DISINTf},
    { 0x0004, PG_COUNTER_1_UNCORRECTED_ERRORf,
	     PG_COUNTER_1_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, PG_COUNTER_0_CORRECTED_ERRORf,
	     PG_COUNTER_0_CORRECTED_ERROR_DISINTf},
    { 0x0001, PG_COUNTER_0_UNCORRECTED_ERRORf,
	     PG_COUNTER_0_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */ 
};

STATIC 
_soc_katana2_mmu_sub_block_leaf_info_t _soc_katana2_mmu_sb_adm_parity_info[] = {
    /* MMU_ADM_ECC_ERROR_0 */
    { 0x0008, SRC_CTXT_DB_CORRECTED_ERRORf,
	     SRC_CTXT_DB_CORRECTED_ERROR_DISINTf},
    { 0x0004, SRC_CTXT_DB_UNCORRECTED_ERRORf,
	     SRC_CTXT_DB_UNCORRECTED_ERROR_ERROR_DISINTf},
    { 0x0002, QUEUE_DB_CORRECTED_ERRORf,
	     QUEUE_DB_CORRECTED_ERROR_DISINTf},
    { 0x0001, QUEUE_DB_UNCORRECTED_ERRORf,
	     QUEUE_DB_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */ 
};

STATIC 
_soc_katana2_mmu_sub_block_leaf_info_t _soc_katana2_mmu_sb_rde_parity_info[] = {
    /* RDE_SER_STATUS */
    { 0x1000000, ITE_REL_FIFO_FULLf,
	     ITE_REL_FIFO_FULL_MASKf},
	  { 0x800000, PQE_CELL_FIFO_FULLf,
	     PQE_CELL_FIFO_FULL_MASKf},
	  { 0x400000, DEQ_CELL_FIFO_FULLf,
	     DEQ_CELL_FIFO_FULL_MASKf},
	  { 0x200000, RPFAP_DUPLICATE_PTRf,
	     RPFAP_DUPLICATE_PTR_MASKf},
	  { 0x100000, TXQ_FLL_EMPTYf,
	     TXQ_FLL_EMPTY_MASKf}, 
    { 0x0FFC00, ECC_1B_BITMAPf,
	     ECC_1B_MASKf},
    { 0x3FF, ECC_2B_BITMAPf,
	     ECC_2B_MASKf},
    { 0 } /* table terminator */ 
};

STATIC 
_soc_katana2_mmu_sub_block_leaf_info_t _soc_katana2_mmu_sb_lls_parity_info[] = {
    /* LLS_ERROR */
    { 0x80000000, VBS_ILLEGAL_CONFIG_INTERRUPTf,
       VBS_ILLEGAL_CONFIG_INTERRUPT_DISINTf},
    { 0x40000000, S1_MAX_SHAPER_REFRESH_CYCLE_INTERRUPTf,
       S1_MAX_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x20000000, ENQ_TO_ACTIVE_QUEUE_VIOL_INTERRUPTf,
       ENQ_TO_ACTIVE_QUEUE_VIOL_INTERRUPT_DISINTf},
    { 0x10000000, PORT_1_IN_4_DEQ_VIOL_INTERRUPTf,
       PORT_1_IN_4_DEQ_VIOL_INTERRUPT_DISINTf},
    { 0x8000000, S0_MAX_SHAPER_REFRESH_CYCLE_INTERRUPTf,
       S0_MAX_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x4000000, PORT_MAX_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     PORT_MAX_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x2000000, L0_MAX_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L0_MAX_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x1000000, L1_MAX_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L1_MAX_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x800000, L2_UPPER_MAX_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L2_UPPER_MAX_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x400000, L2_LOWER_MAX_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L2_LOWER_MAX_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x200000, L0_MIN_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L0_MIN_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x100000, L1_MIN_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L1_MIN_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x80000, L2_UPPER_MIN_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L2_UPPER_MIN_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x40000, L2_LOWER_MIN_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L2_LOWER_MIN_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x20000, MAX_SHAPER_BUCKET_UNDERFLOW_PORTf,
	     MAX_SHAPER_BUCKET_UNDERFLOW_PORT_DISINTf},
    { 0x10000, MAX_SHAPER_BUCKET_UNDERFLOW_L0f,
	     MAX_SHAPER_BUCKET_UNDERFLOW_L0_DISINTf},
    { 0x8000, MAX_SHAPER_BUCKET_UNDERFLOW_L1f,
	     MAX_SHAPER_BUCKET_UNDERFLOW_L1_DISINTf},
    { 0x4000, MAX_SHAPER_BUCKET_UNDERFLOW_L2_UPPERf,
	     MAX_SHAPER_BUCKET_UNDERFLOW_L2_UPPER_DISINTf},
    { 0x2000, MAX_SHAPER_BUCKET_UNDERFLOW_L2_LOWERf,
	     MAX_SHAPER_BUCKET_UNDERFLOW_L2_LOWER_DISINTf},
    { 0x1000, MIN_SHAPER_BUCKET_UNDERFLOW_L0f,
	     MIN_SHAPER_BUCKET_UNDERFLOW_L0_DISINTf},
    { 0x0800, MIN_SHAPER_BUCKET_UNDERFLOW_L1f,
	     MIN_SHAPER_BUCKET_UNDERFLOW_L1_DISINTf},
    { 0x0400, MIN_SHAPER_BUCKET_UNDERFLOW_L2_UPPERf,
	     MIN_SHAPER_BUCKET_UNDERFLOW_L2_UPPER_DISINTf},
    { 0x0200, MIN_SHAPER_BUCKET_UNDERFLOW_L2_LOWERf,
	     MIN_SHAPER_BUCKET_UNDERFLOW_L2_LOWER_DISINTf},
    { 0x0100, MAX_SHAPER_BUCKET_OVERFLOW_PORTf,
	     MAX_SHAPER_BUCKET_OVERFLOW_PORT_DISINTf},
    { 0x0080, MAX_SHAPER_BUCKET_OVERFLOW_L0f,
	     MAX_SHAPER_BUCKET_OVERFLOW_L0_DISINTf},
    { 0x0040, MAX_SHAPER_BUCKET_OVERFLOW_L1f,
	     MAX_SHAPER_BUCKET_OVERFLOW_L1_DISINTf},
    { 0x0020, MAX_SHAPER_BUCKET_OVERFLOW_L2_UPPERf,
	     MAX_SHAPER_BUCKET_OVERFLOW_L2_UPPER_DISINTf},
    { 0x0010, MAX_SHAPER_BUCKET_OVERFLOW_L2_LOWERf,
	     MAX_SHAPER_BUCKET_OVERFLOW_L2_LOWER_DISINTf},
    { 0x0008, MIN_SHAPER_BUCKET_OVERFLOW_L0f,
	     MIN_SHAPER_BUCKET_OVERFLOW_L0_DISINTf},
    { 0x0004, MIN_SHAPER_BUCKET_OVERFLOW_L1f,
	     MIN_SHAPER_BUCKET_OVERFLOW_L1_DISINTf},
    { 0x0002, MIN_SHAPER_BUCKET_OVERFLOW_L2_UPPERf,
	     MIN_SHAPER_BUCKET_OVERFLOW_L2_UPPER_DISINTf},
    { 0x0001, MIN_SHAPER_BUCKET_OVERFLOW_L2_LOWERf,
	     MIN_SHAPER_BUCKET_OVERFLOW_L2_LOWER_DISINTf},
    { 0 } /* table terminator */ 
};

STATIC 
_soc_katana2_mmu_sub_block_leaf_info_t _soc_katana2_mmu_sb_lls2_parity_info[] = {
    /* LLS_ERROR2 */
    { 0x0080, ENQ_PORT_FROM_S1_ID_MULTIPLE_MATCH_ERRORf,
	     ENQ_PORT_FROM_S1_ID_MULTIPLE_MATCH_ERRORf},
    { 0x0040, ENQ_PORT_FROM_S1_ID_S1_NOT_ON_PORT_ERRORf,
	     ENQ_PORT_FROM_S1_ID_S1_NOT_ON_PORT_ERROR_DISINTf},
    { 0x0020, PORT_L2_COUNT_OVERFLOWf,
	     PORT_L2_COUNT_OVERFLOW_DISINTf},
    { 0x0010, PORT_L2_COUNT_UNDERRUNf,
	     PORT_L2_COUNT_UNDERRUN_DISINTf},
    { 0x0008, MAX_SHAPER_BUCKET_OVERFLOW_S1f,
	     MAX_SHAPER_BUCKET_OVERFLOW_S1f},
    { 0x0004, MAX_SHAPER_BUCKET_UNDERFLOW_S1f,
	     MAX_SHAPER_BUCKET_UNDERFLOW_S1f},
    { 0x0002, MAX_SHAPER_BUCKET_OVERFLOW_S0f,
	     MAX_SHAPER_BUCKET_OVERFLOW_S0_DISINTf},
    { 0x0001, MAX_SHAPER_BUCKET_UNDERFLOW_S0f,
	     MAX_SHAPER_BUCKET_UNDERFLOW_S0_DISINTf},
    { 0 } /* table terminator */ 
};

/* LLS_ERROR_UPD2 */
STATIC _soc_katana2_mmu_sub_block_leaf_info_t 
                  _soc_katana2_mmu_sb_lls_upd2_parity_info [] = {
    { 0x1000, UPD2_PORT_1_IN_4_VIOLATED_INTERRUPTf,
	     UPD2_PORT_1_IN_4_VIOLATED_INTERRUPT_DISINTf},
	  { 0x0800, UPD2_S1_ERROR_UNDERRUN_INTERRUPTf,
	     UPD2_S1_ERROR_UNDERRUN_INTERRUPT_DISINTf},
	  { 0x0400, UPD2_S1_ERROR_OVERFLOW_INTERRUPTf,
	     UPD2_S1_ERROR_OVERFLOW_INTERRUPT_DISINTf},
	  { 0x0200, UPD2_S0_ERROR_UNDERRUN_INTERRUPTf,
	     UPD2_S0_ERROR_UNDERRUN_INTERRUPT_DISINTf},
    { 0x0100, UPD2_S0_ERROR_OVERFLOW_INTERRUPTf,
	     UPD2_S0_ERROR_OVERFLOW_INTERRUPT_DISINTf},
    { 0x0080, UPD2_PORT_ERROR_UNDERRUN_INTERRUPTf,
	     UPD2_PORT_ERROR_UNDERRUN_INTERRUPT_DISINTf},
    { 0x0040, UPD2_PORT_ERROR_OVERFLOW_INTERRUPTf,
	     UPD2_PORT_ERROR_OVERFLOW_INTERRUPT_DISINTf},
    { 0x0020, UPD2_L0_ERROR_UNDERRUN_INTERRUPTf,
	     UPD2_L0_ERROR_UNDERRUN_INTERRUPT_DISINTf},
    { 0x0010, UPD2_L0_ERROR_OVERFLOW_INTERRUPTf,
	     UPD2_L0_ERROR_OVERFLOW_INTERRUPT_DISINTf},
    { 0x0008, UPD2_L1_ERROR_UNDERRUN_INTERRUPTf,
	     UPD2_L1_ERROR_UNDERRUN_INTERRUPT_DISINTf},
    { 0x0004, UPD2_L1_ERROR_OVERFLOW_INTERRUPTf,
	     UPD2_L1_ERROR_OVERFLOW_INTERRUPT_DISINTf},
    { 0x0002, UPD2_L2_ERROR_UNDERRUN_INTERRUPTf,
	     UPD2_L2_ERROR_UNDERRUN_INTERRUPT_DISINTf},
    { 0x0001, UPD2_L2_ERROR_OVERFLOW_INTERRUPTf,
	     UPD2_L2_ERROR_OVERFLOW_INTERRUPT_DISINTf},
    { 0 } /* table terminator */
};

STATIC _soc_katana2_mmu_sub_block_leaf_info_t 
                  _soc_katana2_mmu_sb_lls_port_parity_info [] = {
       /* LLS_PORT_ECC_ERROR */
    { 0x8000, DB_S1_TAILS_CORRECTED_ERRORf,
  	      DB_S1_TAILS_CORRECTED_ERROR_DISINTf},
    { 0x4000, DB_S1_TAILS_UNCORRECTED_ERRORf,
  	      DB_S1_TAILS_UNCORRECTED_ERROR_DISINTf},
  	{ 0x2000, DB_S1_SHAPER_BUCKET_CORRECTED_ERRORf,
  	      DB_S1_SHAPER_BUCKET_CORRECTED_ERROR_DISINTf},
  	{ 0x1000, DB_S1_SHAPER_BUCKET_UNCORRECTED_ERRORf,
  	      DB_S1_SHAPER_BUCKET_UNCORRECTED_ERROR_DISINTf},
  	{ 0x0800, DB_S1_SHAPER_CONFIG_C_CORRECTED_ERRORf,
  	      DB_S1_SHAPER_CONFIG_C_CORRECTED_ERROR_DISINTf},
  	{ 0x0400, DB_S1_SHAPER_CONFIG_C_UNCORRECTED_ERRORf,
  	      DB_S1_SHAPER_CONFIG_C_UNCORRECTED_ERROR_DISINTf},
  	{ 0x0200, DB_S0_SHAPER_BUCKET_CORRECTED_ERRORf,
  	      DB_S0_SHAPER_BUCKET_CORRECTED_ERROR_DISINTf},
  	{ 0x0100, DB_S0_SHAPER_BUCKET_UNCORRECTED_ERRORf,
  	      DB_S0_SHAPER_BUCKET_UNCORRECTED_ERROR_DISINTf},
  	{ 0x0080, DB_S0_SHAPER_CONFIG_C_CORRECTED_ERRORf,
  	      DB_S0_SHAPER_CONFIG_C_CORRECTED_ERROR_DISINTf},
  	{ 0x0040, DB_S0_SHAPER_CONFIG_C_UNCORRECTED_ERRORf,
  	      DB_S0_SHAPER_CONFIG_C_UNCORRECTED_ERROR_DISINTf}, 
    { 0x0020, DB_PORT_TDM_CORRECTED_ERRORf,
  	      DB_PORT_TDM_CORRECTED_ERROR_DISINTf},
    { 0x0010, DB_PORT_TDM_UNCORRECTED_ERRORf,
  	      DB_PORT_TDM_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, DB_PORT_SHAPER_CONFIG_C_CORRECTED_ERRORf,
  	      DB_PORT_SHAPER_CONFIG_C_CORRECTED_ERROR_DISINTf},
    { 0x0004, DB_PORT_SHAPER_CONFIG_C_UNCORRECTED_ERRORf,
  	      DB_PORT_SHAPER_CONFIG_C_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, DB_PORT_WERR_MAX_SC_CORRECTED_ERRORf,
  	      DB_PORT_WERR_MAX_SC_CORRECTED_ERROR_DISINTf},
    { 0x0001, DB_PORT_WERR_MAX_SC_UNCORRECTED_ERRORf,
  	      DB_PORT_WERR_MAX_SC_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */

};

STATIC _soc_katana2_mmu_sub_block_leaf_info_t
                _soc_katana2_mmu_sb_lls_l0_ecc_parity_info [] = {
         /* LLS_L0_ECC_ERROR1 */
    { 0x8000000, DB_L0_MIN_NEXT_CORRECTED_ERRORf,
  	      DB_L0_MIN_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x4000000, DB_L0_MIN_NEXT_UNCORRECTED_ERRORf,
  	      DB_L0_MIN_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0x2000000, DB_L0_PARENT_CORRECTED_ERRORf,
  	      DB_L0_PARENT_CORRECTED_ERROR_DISINTf},
    { 0x1000000, DB_L0_PARENT_UNCORRECTED_ERRORf,
  	      DB_L0_PARENT_UNCORRECTED_ERROR_DISINTf},
    { 0x800000, DB_L0_CONFIG_CORRECTED_ERRORf,
  	      DB_L0_CONFIG_CORRECTED_ERROR_DISINTf},
    { 0x400000, DB_L0_CONFIG_UNCORRECTED_ERRORf,
  	      DB_L0_CONFIG_UNCORRECTED_ERROR_DISINTf},
    { 0x200000, DB_L0_MIN_CONFIG_C_CORRECTED_ERRORf,
  	      DB_L0_MIN_CONFIG_C_CORRECTED_ERROR_DISINTf},
    { 0x100000, DB_L0_MIN_CONFIG_C_UNCORRECTED_ERRORf,
  	      DB_L0_MIN_CONFIG_C_UNCORRECTED_ERROR_DISINTf},
    { 0x80000, DB_L0_PARENT_STATE_CORRECTED_ERRORf,
  	      DB_L0_PARENT_STATE_CORRECTED_ERROR_DISINTf},
    { 0x40000, DB_L0_PARENT_STATE_UNCORRECTED_ERRORf,
  	      DB_L0_PARENT_STATE_UNCORRECTED_ERROR_DISINTf},
    { 0x20000, DB_L0_HEADS_TAILS_CORRECTED_ERRORf,
  	      DB_L0_HEADS_TAILS_CORRECTED_ERROR_DISINTf},
    { 0x10000, DB_L0_HEADS_TAILS_UNCORRECTED_ERRORf,
  	      DB_L0_HEADS_TAILS_UNCORRECTED_ERROR_DISINTf},
    { 0x8000, DB_L0_WERR_MAX_SC_CORRECTED_ERRORf,
  	      DB_L0_WERR_MAX_SC_CORRECTED_ERROR_DISINTf},
    { 0x4000, DB_L0_WERR_MAX_SC_UNCORRECTED_ERRORf,
  	      DB_L0_WERR_MAX_SC_UNCORRECTED_ERROR_DISINTf},
    { 0x2000, DB_L0_MIN_BUCKET_C_CORRECTED_ERRORf,
  	      DB_L0_MIN_BUCKET_C_CORRECTED_ERROR_DISINTf},
    { 0x1000, DB_L0_MIN_BUCKET_C_UNCORRECTED_ERRORf,
  	      DB_L0_MIN_BUCKET_C_UNCORRECTED_ERROR_DISINTf},
    { 0x0800, DB_L0_CHILD_STATE1_CORRECTED_ERRORf,
  	      DB_L0_CHILD_STATE1_CORRECTED_ERROR_DISINTf},
    { 0x0400, DB_L0_CHILD_STATE1_UNCORRECTED_ERRORf,
  	      DB_L0_CHILD_STATE1_UNCORRECTED_ERROR_DISINTf},
    { 0x0200, DB_L0_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERRORf,
  	      DB_L0_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERROR_DISINTf},
    { 0x0100, DB_L0_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERRORf,
  	      DB_L0_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, DB_L0_WERR_NEXT_CORRECTED_ERRORf,
  	      DB_L0_WERR_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x0040, DB_L0_WERR_NEXT_UNCORRECTED_ERRORf,
  	      DB_L0_WERR_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, DB_L0_EF_NEXT_CORRECTED_ERRORf,
  	      DB_L0_EF_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x0010, DB_L0_EF_NEXT_UNCORRECTED_ERRORf,
  	      DB_L0_EF_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, DB_L0_SHAPER_CONFIG_C_CORRECTED_ERRORf,
  	      DB_L0_SHAPER_CONFIG_C_CORRECTED_ERROR_DISINTf},
    { 0x0004, DB_L0_SHAPER_CONFIG_C_UNCORRECTED_ERRORf,
  	      DB_L0_SHAPER_CONFIG_C_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, DB_L0_SHAPER_BUCKET_C_CORRECTED_ERRORf,
  	      DB_L0_SHAPER_BUCKET_C_CORRECTED_ERROR_DISINTf},
    { 0x0001, DB_L0_SHAPER_BUCKET_C_UNCORRECTED_ERRORf,
  	      DB_L0_SHAPER_BUCKET_C_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */

};

STATIC _soc_katana2_mmu_sub_block_leaf_info_t 
                     _soc_katana2_mmu_sb_lls_l1_ecc_parity_info [] = {
             /* LLS_L1_ECC_ERROR1 */
    { 0x8000000, DB_L1_MIN_NEXT_CORRECTED_ERRORf,
  	      DB_L1_MIN_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x4000000, DB_L1_MIN_NEXT_UNCORRECTED_ERRORf,
  	      DB_L1_MIN_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0x2000000, DB_L1_PARENT_CORRECTED_ERRORf,
  	      DB_L1_PARENT_CORRECTED_ERROR_DISINTf},
    { 0x1000000, DB_L1_PARENT_UNCORRECTED_ERRORf,
  	      DB_L1_PARENT_UNCORRECTED_ERROR_DISINTf},
    { 0x800000, DB_L1_CONFIG_CORRECTED_ERRORf,
  	      DB_L1_CONFIG_CORRECTED_ERROR_DISINTf},
    { 0x400000, DB_L1_CONFIG_UNCORRECTED_ERRORf,
  	      DB_L1_CONFIG_UNCORRECTED_ERROR_DISINTf},
    { 0x200000, DB_L1_MIN_CONFIG_C_CORRECTED_ERRORf,
  	      DB_L1_MIN_CONFIG_C_CORRECTED_ERROR_DISINTf},
    { 0x100000, DB_L1_MIN_CONFIG_C_UNCORRECTED_ERRORf,
  	      DB_L1_MIN_CONFIG_C_UNCORRECTED_ERROR_DISINTf},
    { 0x80000, DB_L1_PARENT_STATE_CORRECTED_ERRORf,
  	      DB_L1_PARENT_STATE_CORRECTED_ERROR_DISINTf},
    { 0x40000, DB_L1_PARENT_STATE_UNCORRECTED_ERRORf,
  	      DB_L1_PARENT_STATE_UNCORRECTED_ERROR_DISINTf},
    { 0x20000, DB_L1_HEADS_TAILS_CORRECTED_ERRORf,
  	      DB_L1_HEADS_TAILS_CORRECTED_ERROR_DISINTf},
    { 0x10000, DB_L1_HEADS_TAILS_UNCORRECTED_ERRORf,
  	      DB_L1_HEADS_TAILS_UNCORRECTED_ERROR_DISINTf},
    { 0x8000, DB_L1_WERR_MAX_SC_CORRECTED_ERRORf,
  	      DB_L1_WERR_MAX_SC_CORRECTED_ERROR_DISINTf},
    { 0x4000, DB_L1_WERR_MAX_SC_UNCORRECTED_ERRORf,
  	      DB_L1_WERR_MAX_SC_UNCORRECTED_ERROR_DISINTf},
    { 0x2000, DB_L1_MIN_BUCKET_C_CORRECTED_ERRORf,
  	      DB_L1_MIN_BUCKET_C_CORRECTED_ERROR_DISINTf},
    { 0x1000, DB_L1_MIN_BUCKET_C_UNCORRECTED_ERRORf,
  	      DB_L1_MIN_BUCKET_C_UNCORRECTED_ERROR_DISINTf},
    { 0x0800, DB_L1_CHILD_STATE1_CORRECTED_ERRORf,
  	      DB_L1_CHILD_STATE1_CORRECTED_ERROR_DISINTf},
    { 0x0400, DB_L1_CHILD_STATE1_UNCORRECTED_ERRORf,
  	      DB_L1_CHILD_STATE1_UNCORRECTED_ERROR_DISINTf},
    { 0x0200, DB_L1_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERRORf,
  	      DB_L1_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERROR_DISINTf},
    { 0x0100, DB_L1_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERRORf,
  	      DB_L1_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, DB_L1_WERR_NEXT_CORRECTED_ERRORf,
  	      DB_L1_WERR_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x0040, DB_L1_WERR_NEXT_UNCORRECTED_ERRORf,
  	      DB_L1_WERR_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, DB_L1_EF_NEXT_CORRECTED_ERRORf,
  	      DB_L1_EF_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x0010, DB_L1_EF_NEXT_UNCORRECTED_ERRORf,
  	     DB_L1_EF_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, DB_L1_SHAPER_CONFIG_C_CORRECTED_ERRORf,
  	      DB_L1_SHAPER_CONFIG_C_CORRECTED_ERROR_DISINTf},
    { 0x0004, DB_L1_SHAPER_CONFIG_C_UNCORRECTED_ERRORf,
  	      DB_L1_SHAPER_CONFIG_C_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, DB_L1_SHAPER_BUCKET_C_CORRECTED_ERRORf,
  	      DB_L1_SHAPER_BUCKET_C_CORRECTED_ERROR_DISINTf},
    { 0x0001, DB_L1_SHAPER_BUCKET_C_UNCORRECTED_ERRORf,
  	      DB_L1_SHAPER_BUCKET_C_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC _soc_katana2_mmu_sub_block_leaf_info_t 
                     _soc_katana2_mmu_sb_lls_l2_ecc_parity_info [] = {
             /*   LLS_L2_ECC_ERROR1 */
    { 0x2000000, DB_L2_MIN_CONFIG_UPPER_C_CORRECTED_ERRORf,
  	      DB_L2_MIN_CONFIG_UPPER_C_CORRECTED_ERROR_DISINTf},
    { 0x1000000, DB_L2_MIN_CONFIG_UPPER_C_UNCORRECTED_ERRORf,
  	      DB_L2_MIN_CONFIG_UPPER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x800000, DB_L2_MIN_BUCKET_UPPER_C_CORRECTED_ERRORf,
  	      DB_L2_MIN_BUCKET_UPPER_C_CORRECTED_ERROR_DISINTf},
    { 0x400000, DB_L2_MIN_BUCKET_UPPER_C_UNCORRECTED_ERRORf,
  	      DB_L2_MIN_BUCKET_UPPER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x200000, DB_L2_SHAPER_CONFIG_UPPER_C_CORRECTED_ERRORf,
  	      DB_L2_SHAPER_CONFIG_UPPER_C_CORRECTED_ERROR_DISINTf},
    { 0x100000, DB_L2_SHAPER_CONFIG_UPPER_C_UNCORRECTED_ERRORf,
  	      DB_L2_SHAPER_CONFIG_UPPER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x80000, DB_L2_SHAPER_BUCKET_UPPER_C_CORRECTED_ERRORf,
  	      DB_L2_SHAPER_BUCKET_UPPER_C_CORRECTED_ERROR_DISINTf},
    { 0x40000, DB_L2_SHAPER_BUCKET_UPPER_C_UNCORRECTED_ERRORf,
  	      DB_L2_SHAPER_BUCKET_UPPER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x20000, DB_L2_MIN_CONFIG_LOWER_C_CORRECTED_ERRORf,
  	      DB_L2_MIN_CONFIG_LOWER_C_CORRECTED_ERROR_DISINTf},
    { 0x10000, DB_L2_MIN_CONFIG_LOWER_C_UNCORRECTED_ERRORf,
  	      DB_L2_MIN_CONFIG_LOWER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x8000, DB_L2_MIN_BUCKET_LOWER_C_CORRECTED_ERRORf,
  	      DB_L2_MIN_BUCKET_LOWER_C_CORRECTED_ERROR_DISINTf},
    { 0x4000, DB_L2_MIN_BUCKET_LOWER_C_UNCORRECTED_ERRORf,
  	      DB_L2_MIN_BUCKET_LOWER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x2000, DB_L2_SHAPER_CONFIG_LOWER_C_CORRECTED_ERRORf,
  	      DB_L2_SHAPER_CONFIG_LOWER_C_CORRECTED_ERROR_DISINTf},
    { 0x1000, DB_L2_SHAPER_CONFIG_LOWER_C_UNCORRECTED_ERRORf,
  	      DB_L2_SHAPER_CONFIG_LOWER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x0800, DB_L2_SHAPER_BUCKET_LOWER_C_CORRECTED_ERRORf,
  	      DB_L2_SHAPER_BUCKET_LOWER_C_CORRECTED_ERROR_DISINTf},
    { 0x0400, DB_L2_SHAPER_BUCKET_LOWER_C_UNCORRECTED_ERRORf,
  	      DB_L2_SHAPER_BUCKET_LOWER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x0200, DB_L2_CHILD_STATE1_CORRECTED_ERRORf,
  	      DB_L2_CHILD_STATE1_CORRECTED_ERROR_DISINTf},
    { 0x0100, DB_L2_CHILD_STATE1_UNCORRECTED_ERRORf,
  	      DB_L2_CHILD_STATE1_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, DB_L2_PARENT_CORRECTED_ERRORf,
  	      DB_L2_PARENT_CORRECTED_ERROR_DISINTf},
    { 0x0040, DB_L2_PARENT_UNCORRECTED_ERRORf,
  	      DB_L2_PARENT_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, DB_L2_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERRORf,
  	      DB_L2_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERROR_DISINTf},
    { 0x0010, DB_L2_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERRORf,
  	      DB_L2_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, DB_L2_WERR_NEXT_CORRECTED_ERRORf,
  	      DB_L2_WERR_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x0004, DB_L2_WERR_NEXT_UNCORRECTED_ERRORf,
  	      DB_L2_WERR_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, DB_L2_MIN_NEXT_CORRECTED_ERRORf,
  	      DB_L2_MIN_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x0001, DB_L2_MIN_NEXT_UNCORRECTED_ERRORf,
  	      DB_L2_MIN_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC _soc_katana2_mmu_sub_block_leaf_info_t 
                     _soc_katana2_mmu_sb_lls_misc_ecc_parity_info [] = {
              /* LLS_MISC_ECC_ERROR1 */
    { 0x200000, DB_S1_ERROR_CORRECTED_ERRORf,
  	      DB_S1_ERROR_CORRECTED_ERROR_DISINTf},
  	{ 0x100000, DB_S1_ERROR_UNCORRECTED_ERRORf,
  	      DB_S1_ERROR_UNCORRECTED_ERROR_DISINTf},
  	{ 0x80000, DB_S0_ERROR_CORRECTED_ERRORf,
  	      DB_S0_ERROR_CORRECTED_ERRORf},
  	{ 0x40000, DB_S0_ERROR_UNCORRECTED_ERRORf,
  	      DB_S0_ERROR_UNCORRECTED_ERROR_DISINTf},
  	{ 0x20000, DB_L0_ERROR_MIN_CORRECTED_ERRORf,
  	      DB_L0_ERROR_MIN_CORRECTED_ERROR_DISINTf},
  	{ 0x10000, DB_L0_ERROR_MIN_UNCORRECTED_ERRORf,
  	      DB_L0_ERROR_MIN_UNCORRECTED_ERROR_DISINTf},
  	{ 0x8000, DB_L1_ERROR_MIN_CORRECTED_ERRORf,
  	      DB_L1_ERROR_MIN_CORRECTED_ERROR_DISINTf},
  	{ 0x4000, DB_L1_ERROR_MIN_UNCORRECTED_ERRORf,
  	      DB_L1_ERROR_MIN_UNCORRECTED_ERROR_DISINTf},
  	{ 0x2000, DB_L2_ERROR_MIN_CORRECTED_ERRORf,
  	      DB_L2_ERROR_MIN_CORRECTED_ERROR_DISINTf},
  	{ 0x1000, DB_L2_ERROR_MIN_UNCORRECTED_ERRORf,
  	      DB_L2_ERROR_MIN_UNCORRECTED_ERROR_DISINTf},
    { 0x0800, DB_L2_ACT_XON_CORRECTED_ERRORf,
  	      DB_L2_ACT_XON_CORRECTED_ERROR_DISINTf},
    { 0x0400, DB_L2_ACT_XON_UNCORRECTED_ERRORf,
  	      DB_L2_ACT_XON_UNCORRECTED_ERROR_DISINTf},
    { 0x0200, DB_L2_ACT_SHAPER_CORRECTED_ERRORf,
  	      DB_L2_ACT_SHAPER_CORRECTED_ERROR_DISINTf},
    { 0x0100, DB_L2_ACT_SHAPER_UNCORRECTED_ERRORf,
  	      DB_L2_ACT_SHAPER_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, DB_L2_ACT_MIN_CORRECTED_ERRORf,
  	      DB_L2_ACT_MIN_CORRECTED_ERROR_DISINTf},
    { 0x0040, DB_L2_ACT_MIN_UNCORRECTED_ERRORf,
  	      DB_L2_ACT_MIN_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, DB_L0_ERROR_CORRECTED_ERRORf,
  	      DB_L0_ERROR_CORRECTED_ERROR_DISINTf},
    { 0x0010, DB_L0_ERROR_UNCORRECTED_ERRORf,
  	      DB_L0_ERROR_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, DB_L1_ERROR_CORRECTED_ERRORf,
  	      DB_L1_ERROR_CORRECTED_ERROR_DISINTf},
    { 0x0004, DB_L1_ERROR_UNCORRECTED_ERRORf,
  	      DB_L1_ERROR_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, DB_L2_ERROR_CORRECTED_ERRORf,
  	      DB_L2_ERROR_CORRECTED_ERROR_DISINTf},
    { 0x0001, DB_L2_ERROR_UNCORRECTED_ERRORf,
  	      DB_L2_ERROR_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */

};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                        _soc_katana2_mmu_sb_mem1_parity_info [] = {
    /* CLINK_ERROR */
    { 0x0008, CLINKE_CORRECTED_ERRORf,
        CLINKE_CORRECTED_ERROR_DISINTf },
    { 0x0004, CLINKE_UNCORRECTED_ERRORf,
        CLINKE_UNCORRECTED_ERROR_DISINTf },
    { 0x0002, CLINKI_CORRECTED_ERRORf,
        CLINKI_CORRECTED_ERROR_DISINTf },
    { 0x0001, CLINKI_UNCORRECTED_ERRORf,
        CLINKI_UNCORRECTED_ERROR_DISINTf },
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t
                      _soc_katana2_mmu_sb_e2efc_parity_info [] = {
    /* MMU_E2EFC_ERROR_0 */
    { 0x0200, E2EFC_QEN_CNT_UNDERRUNf,
        E2EFC_QEN_CNT_UNDERRUN_DISINTf},
    { 0x0100, E2EFC_QEN_CNT_OVERFLOWf,
        E2EFC_QEN_CNT_OVERFLOW_DISINTf},
    { 0x0080, E2EFC_RQE_CNT_UNDERRUNf,
        E2EFC_RQE_CNT_UNDERRUN_DISINTf},
    { 0x0040, E2EFC_RQE_CNT_OVERFLOWf,
        E2EFC_RQE_CNT_OVERFLOW_DISINTf},
    { 0x0020, E2EFC_EMA_CNT_UNDERRUNf,
        E2EFC_EMA_CNT_UNDERRUN_DISINTf},
    { 0x0010, E2EFC_EMA_CNT_OVERFLOWf,
        E2EFC_EMA_CNT_OVERFLOW_DISINTf},
    { 0x0008, E2EFC_EXT_CNT_UNDERRUNf,
        E2EFC_EXT_CNT_UNDERRUN_DISINTf},
    { 0x0004, E2EFC_EXT_CNT_OVERFLOWf,
        E2EFC_EXT_CNT_OVERFLOW_DISINTf},
    { 0x0002, E2EFC_INT_CNT_UNDERRUNf,
        E2EFC_INT_CNT_UNDERRUN_DISINTf},
    { 0x0001, E2EFC_INT_CNT_OVERFLOWf,
        E2EFC_INT_CNT_OVERFLOW_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                     _soc_katana2_mmu_sb_thdi_parity_info [] = {
    /* MMU_THDI_INTR */
    { 0x0010, THDI_INTR_4f, THDI_INTR_4_DISINTf},
    { 0x0008, THDI_INTR_3f, THDI_INTR_3_DISINTf},
    { 0x0004, THDI_INTR_2f, THDI_INTR_2_DISINTf},
    { 0x0002, THDI_INTR_1f, THDI_INTR_1_DISINTf},
    { 0x0001, THDI_INTR_0f, THDI_INTR_0_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                      _soc_katana2_mmu_sb_ctr_parity_info [] = {
    /* CTR_ERROR */
    { 0x0100, CTR_RQE_FIFO_OVERFLOW_ERRORf,
        CTR_RQE_FIFO_OVERFLOW_ERROR_DISINTf},
    { 0x0080, CTR_ENQ_WRAP_ERRORf,
        CTR_ENQ_WRAP_ERROR_DISINTf},
    { 0x0040, CTR_DEQ_WRAP_ERRORf,
        CTR_DEQ_WRAP_ERROR_DISINTf},
    { 0x0020, CTR_DEQ_STATUS_CORRECTED_ERRORf,
        CTR_DEQ_STATUS_CORRECTED_ERROR_DISINTf},
    { 0x0010, CTR_DEQ_STATUS_UNCORRECTED_ERRORf,
        CTR_DEQ_STATUS_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, CTR_RQE_FIFO_CORRECTED_ERRORf,
        CTR_RQE_FIFO_CORRECTED_ERROR_DISINTf},
    { 0x0004, CTR_RQE_FIFO_UNCORRECTED_ERRORf,
        CTR_RQE_FIFO_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, CTR_FLEX_CNT_CORRECTED_ERRORf,
        CTR_FLEX_CNT_CORRECTED_ERROR_DISINTf},
    { 0x0001, CTR_FLEX_CNT_UNCORRECTED_ERRORf,
        CTR_FLEX_CNT_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                    _soc_katana2_mmu_sb_ccp_parity_info [] = {
    /* CCP_ERROR */
    { 0x0200, CCPE_FIFO_CORRECTED_ERRORf,
         CCPE_FIFO_CORRECTED_ERROR_DISINTf},
    { 0x0100, CCPE_FIFO_UNCORRECTED_ERRORf,
         CCPE_FIFO_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, CCPI_FIFO_CORRECTED_ERRORf,
         CCPI_FIFO_CORRECTED_ERROR_DISINTf},
    { 0x0040, CCPI_FIFO_UNCORRECTED_ERRORf,
         CCPI_FIFO_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, CCPI_RQE_UPD_NEGATIVEf,
         CCPI_RQE_UPD_NEGATIVE_DISINTf},
    { 0x0010, CCPE_RQE_UPD_NEGATIVEf,
         CCPE_RQE_UPD_NEGATIVE_DISINTf},
    { 0x0008, CCPE_CORRECTED_ERRORf,
         CCPE_CORRECTED_ERROR_DISINTf},
    { 0x0004, CCPE_UNCORRECTED_ERRORf,
         CCPE_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, CCPI_CORRECTED_ERRORf,
         CCPI_CORRECTED_ERROR_DISINTf},
    { 0x0001, CCPI_UNCORRECTED_ERRORf,
         CCPI_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                        _soc_katana2_mmu_sb_toq2_parity_info [] = {
    /* TOQ_ERROR2 */
    { 0x2000, REPL_HEAD_WRAPf,
         REPL_HEAD_WRAP_DISINTf},
    { 0x1000, PQE_CREDIT_UNDERRUNf,
         PQE_CREDIT_UNDERRUN_DISINTf},
    { 0x0800, PQE_CREDIT_OVERFLOWf,
         PQE_CREDIT_OVERFLOW_DISINTf},
    { 0x0400, QEN_ALLOC_UNDERRUNf,
         QEN_ALLOC_UNDERRUN_DISINTf},
    { 0x0200, QEN_ALLOC_OVERFLOWf,
         QEN_ALLOC_OVERFLOW_DISINTf},
    { 0x0100, FLUSH_COMPLETEf,
         FLUSH_COMPLETE_DISINTf},
    { 0x0080, QDIS_FIFO_OVERFLOWf,
         QDIS_FIFO_OVERFLOW_DISINTf},
    { 0x0040, TRACE_DEQ_EVENTf,
         TRACE_DEQ_EVENT_DISINTf},
    { 0x0020, TRACE_ENQ_EVENTf,
         TRACE_ENQ_EVENT_DISINTf},
    { 0x0010, DEQ_TO_EMPTY_QUEUE_ERRORf,
         DEQ_TO_EMPTY_QUEUE_ERROR_DISINTf},
    { 0x0008, QSTRUCT_EMPTY_ERRORf,
         QSTRUCT_EMPTY_ERROR_DISINTf},
    { 0x0004, QUEUE_OVELOAD_ERRORf,
         QUEUE_OVELOAD_ERROR_DISINTf},
    { 0x0002, TDM_VIOLATION_ERRORf,
         TDM_VIOLATION_ERROR_DISINTf},
    { 0x0001, RQE_FIFO_OVERFLOWf,
         RQE_FIFO_OVERFLOW_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                        _soc_katana2_mmu_sb_toq1_parity_info [] = {
    /* TOQ_ERROR1 */
    { 0x80000, QPACK_MODE_TBL_CORRECTED_ERRORf,
         QPACK_MODE_TBL_CORRECTED_ERROR_DISINTf},
    { 0x40000, QPACK_MODE_TBL_UNCORRECTED_ERRORf,
         QPACK_MODE_TBL_UNCORRECTED_ERROR_DISINTf},
    { 0x20000, EOPE_TBL_CORRECTED_ERRORf,
         EOPE_TBL_CORRECTED_ERROR_DISINTf},
    { 0x10000, EOPE_TBL_UNCORRECTED_ERRORf,
         EOPE_TBL_UNCORRECTED_ERROR_DISINTf},
    { 0x8000, REPL_MAP_TBL_CORRECTED_ERRORf,
         REPL_MAP_TBL_CORRECTED_ERROR_DISINTf},
    { 0x4000, REPL_MAP_TBL_UNCORRECTED_ERRORf,
         REPL_MAP_TBL_UNCORRECTED_ERROR_DISINTf},
    { 0x2000, REPL_STATE_TBL_CORRECTED_ERRORf,
         REPL_STATE_TBL_CORRECTED_ERROR_DISINTf},
    { 0x1000, REPL_STATE_TBL_UNCORRECTED_ERRORf,
         REPL_STATE_TBL_UNCORRECTED_ERROR_DISINTf},
    { 0x0800, PORT_STATE_CORRECTED_ERRORf,
         PORT_STATE_CORRECTED_ERROR_DISINTf},
    { 0x0400, PORT_STATE_UNCORRECTED_ERRORf,
         PORT_STATE_UNCORRECTED_ERROR_DISINTf},
    { 0x0200, RQE_FIFO_CORRECTED_ERRORf,
         RQE_FIFO_CORRECTED_ERROR_DISINTf},
    { 0x0100, RQE_FIFO_UNCORRECTED_ERRORf,
         RQE_FIFO_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, REPL_GRP_TBL_CORRECTED_ERRORf,
         REPL_GRP_TBL_CORRECTED_ERROR_DISINTf},
    { 0x0040, REPL_GRP_TBL_UNCORRECTED_ERRORf,
         REPL_GRP_TBL_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, REPL_HEAD_TBL_CORRECTED_ERRORf,
         REPL_HEAD_TBL_CORRECTED_ERROR_DISINTf},
    { 0x0010, REPL_HEAD_TBL_UNCORRECTED_ERRORf,
         REPL_HEAD_TBL_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, REPL_LIST_TBL_CORRECTED_ERRORf,
         REPL_LIST_TBL_CORRECTED_ERROR_DISINTf},
    { 0x0004, REPL_LIST_TBL_UNCORRECTED_ERRORf,
         REPL_LIST_TBL_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, TOQ_STATE_CORRECTED_ERRORf,
         TOQ_STATE_CORRECTED_ERROR_DISINTf},
    { 0x0001, TOQ_STATE_UNCORRECTED_ERRORf,
         TOQ_STATE_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};


STATIC  _soc_katana2_mmu_sub_block_leaf_info_t
                         _soc_katana2_mmu_sb_ite_parity_info [] = {
    /* MMU_ITE_ERROR_0  */
    { 0x0008, ITE_WORK_QUEUE_RD_EMPTYf,
        ITE_WORK_QUEUE_RD_EMPTY_DISINTf},
    { 0x0004, ITE_WORK_QUEUE_WR_FULLf,
        ITE_WORK_QUEUE_WR_FULL_DISINTf},
    { 0x0002, ITE_CTRL_RD_EMPTYf,
        ITE_CTRL_RD_EMPTY_DISINTf},
    { 0x0001, ITE_CTRL_WR_FULLf,
        ITE_CTRL_WR_FULL_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t
                         _soc_katana2_mmu_sb_ite_cfg_parity_info [] = {
    /* MMU_ITE_CFG_ECC_ERROR_0 */
    { 0x0800, SOP_CONTROL_ECC_0_CORRECTED_ERRORf,
        SOP_CONTROL_ECC_0_CORRECTED_ERROR_DISINTf},
    { 0x0400, SOP_CONTROL_ECC_0_UNCORRECTED_ERRORf,
        SOP_CONTROL_ECC_0_UNCORRECTED_ERROR_DISINTf},
    { 0x0200, PACKET_PTR_STORE_CORRECTED_ERRORf,
        PACKET_PTR_STORE_FORCE_CORRECTED_ERROR_DISINTf},
    { 0x0100, PACKET_PTR_STORE_UNCORRECTED_ERRORf,
        PACKET_PTR_STORE_FORCE_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, ITE_WORK_QUEUE_CORRECTED_ERRORf,
        ITE_WORK_QUEUE_FORCE_CORRECTED_ERROR_DISINTf},
    { 0x0040, ITE_WORK_QUEUE_UNCORRECTED_ERRORf,
        ITE_WORK_QUEUE_FORCE_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, ITE_CTRL_CORRECTED_ERRORf,
        ITE_CTRL_CORRECTED_ERROR_DISINTf},
    { 0x0010, ITE_CTRL_UNCORRECTED_ERRORf,
        ITE_CTRL_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, ITE_QMGR_FLL_CORRECTED_ERRORf,
        ITE_QMGR_FLL_FORCE_CORRECTED_ERROR_DISINTf},
    { 0x0004, ITE_QMGR_FLL_UNCORRECTED_ERRORf,
        ITE_QMGR_FLL_FORCE_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, ITE_QMGR_QLL_CORRECTED_ERRORf,
        ITE_QMGR_QLL_CORRECTED_ERROR_DISINTf},
    { 0x0001, ITE_QMGR_QLL_UNCORRECTED_ERRORf,
        ITE_QMGR_QLL_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                           _soc_katana2_mmu_sb_enq_cfg_parity_info [] = {
    /* MMU_ENQ_CFG_ECC_ERROR_0 */
    { 0x800000, CBI_CORRECTED_ERRORf,
            CBI_CORRECTED_ERROR_DISINTf},
    { 0x400000, CBI_UNCORRECTED_ERRORf,
            CBI_UNCORRECTED_ERROR_DISINTf},
    { 0x200000, ITE_REORDER_FIFO_CORRECTED_ERRORf,
            ITE_REORDER_FIFO_CORRECTED_ERRORf},
    { 0x100000, ITE_REORDER_FIFO_UNCORRECTED_ERRORf,
            ITE_REORDER_FIFO_UNCORRECTED_ERRORf},
    { 0x80000, PACKING_PKT_LEN_FIFOS_CORRECTED_ERRORf,
            PACKING_PKT_LEN_FIFOS_CORRECTED_ERROR_DISINTf},
    { 0x40000, PACKING_PKT_LEN_FIFOS_UNCORRECTED_ERRORf,
            PACKING_PKT_LEN_FIFOS_UNCORRECTED_ERROR_DISINTf},
    { 0x20000, PACKING_PORT_FIFOS_CORRECTED_ERRORf,
            PACKING_PORT_FIFOS_CORRECTED_ERROR_DISINTf},
    { 0x10000, PACKING_PORT_FIFOS_UNCORRECTED_ERRORf,
            PACKING_PORT_FIFOS_UNCORRECTED_ERROR_DISINTf},
    { 0x8000, PACKING_CTXT_FIFOS_FP_LL_CORRECTED_ERRORf,
            PACKING_CTXT_FIFOS_FP_LL_CORRECTED_ERROR_DISINTf},
    { 0x4000, PACKING_CTXT_FIFOS_FP_LL_UNCORRECTED_ERRORf,
            PACKING_CTXT_FIFOS_FP_LL_UNCORRECTED_ERROR_DISINTf},
    { 0x2000, PACKING_CTXT_FIFOS_CORRECTED_ERRORf,
            PACKING_CTXT_FIFOS_CORRECTED_ERROR_DISINTf},
    { 0x1000, PACKING_CTXT_FIFOS_UNCORRECTED_ERRORf,
            PACKING_CTXT_FIFOS_UNCORRECTED_ERROR_DISINTf},
    { 0x0800, CFAPI_INTERNAL_RECYCLE_CORRECTED_ERRORf,
            CFAPI_INTERNAL_RECYCLE_CORRECTED_ERROR_DISINTf},
    { 0x0400, CFAPI_INTERNAL_RECYCLE_UNCORRECTED_ERRORf,
            CFAPI_INTERNAL_RECYCLE_UNCORRECTED_ERROR_DISINTf},
    { 0x0200, SRC_PPP_TO_S1_LOOKUP_CORRECTED_ERRORf,
            SRC_PPP_TO_S1_LOOKUP_CORRECTED_ERROR_DISINTf},
    { 0x0100, SRC_PPP_TO_S1_LOOKUP_UNCORRECTED_ERRORf,
            SRC_PPP_TO_S1_LOOKUP_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, SRC_PORT_STATE_CORRECTED_ERRORf,
            SRC_PORT_STATE_CORRECTED_ERROR_DISINTf},
    { 0x0040, SRC_PORT_STATE_UNCORRECTED_ERRORf,
            SRC_PORT_STATE_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, SOP_STORE_CORRECTED_ERRORf,
            SOP_STORE_CORRECTED_ERROR_DISINTf},
    { 0x0010, SOP_STORE_UNCORRECTED_ERRORf,
            SOP_STORE_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, RQE_WR_COMPLETE_CORRECTED_ERRORf,
            RQE_WR_COMPLETE_CORRECTED_ERROR_DISINTf},
    { 0x0004, RQE_WR_COMPLETE_UNCORRECTED_ERRORf,
            RQE_WR_COMPLETE_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, CBP_32B_WR_STORE_CORRECTED_ERRORf,
            CBP_32B_WR_STORE_CORRECTED_ERROR_DISINTf},
    { 0x0001, CBP_32B_WR_STORE_UNCORRECTED_ERRORf,
            CBP_32B_WR_STORE_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                            _soc_katana2_mmu_sb_enq_parity_info [] = {
    /* MMU_ENQ_ERROR_0 */
    { 0x0010, FAP_DUPLICATE_PTRf,
            FAP_DUPLICATE_PTR_DISINTf},
    { 0x0008, ENQ_TRACE_STATUSf,
            ENQ_TRACE_STATUS_DISINTf},
    { 0x0004, ILLEGAL_CELL_PBIf,
            ILLEGAL_CELL_PBI_DISINTf},
    { 0x0002, MISSING_START_ERRf,
            MISSING_START_ERR_DISINTf},
    { 0x0001, START_BY_START_ERRf,
            START_BY_START_ERR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                     _soc_katana2_mmu_sb_enq_fap_parity_info [] = {
    /* MMU_ENQ_FAP_ECC_ERROR_0 */
    { 0x0008, FAP_STACK_CORRECTED_ERRORf,
            FAP_STACK_CORRECTED_ERROR_DISINTf},
    { 0x0004, FAP_STACK_UNCORRECTED_ERRORf,
            FAP_STACK_UNCORRECTED_ERROR_ERROR_DISINTf},
    { 0x0002, FAP_BITMAP_CORRECTED_ERRORf,
            FAP_BITMAP_CORRECTED_ERROR_DISINTf},
    { 0x0001, FAP_BITMAP_UNCORRECTED_ERRORf,
            FAP_BITMAP_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                     _soc_katana2_mmu_sb_thdo_stat1_parity_info [] = {
    /* THDO_PARITY_ERROR_STATUS1 */
    { 0xfffff, ECC_1B_ERROR_STATUSf, ECC_1B_MASKf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                     _soc_katana2_mmu_sb_thdo_stat2_parity_info [] = {
    /* THDO_PARITY_ERROR_STATUS2 */
    { 0xfffff, ECC_2B_ERROR_STATUSf, ECC_2B_MASKf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                    _soc_katana2_mmu_sb_cfapi_parity_info [] = {
    /* CFAPI_ECC_ERROR */
    { 0x0010, DUPLICATE_PTRf,
        DUPLICATE_PTR_DISINTf},
    { 0x0008, BITMAP_CORRECTED_ERRORf,
        BITMAP_CORRECTED_ERROR_DISINTf},
    { 0x0004, BITMAP_UNCORRECTED_ERRORf,
        BITMAP_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, STACK_CORRECTED_ERRORf,
        STACK_CORRECTED_ERROR_DISINTf},
    { 0x0001, STACK_UNCORRECTED_ERRORf,
        STACK_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                    _soc_katana2_mmu_sb_cfape_parity_info [] = {
    /* CFAPE_ECC_ERROR */
    { 0x0010, DUPLICATE_PTRf,
        DUPLICATE_PTR_DISINTf},
    { 0x0008, BITMAP_CORRECTED_ERRORf,
        BITMAP_CORRECTED_ERROR_DISINTf},
    { 0x0004, BITMAP_UNCORRECTED_ERRORf,
        BITMAP_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, STACK_CORRECTED_ERRORf,
        STACK_CORRECTED_ERROR_DISINTf},
    { 0x0001, STACK_UNCORRECTED_ERRORf,
        STACK_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                      _soc_katana2_mmu_sb_age_int_parity_info [] = {
    /* AGING_ERROR_INT */
    { 0x0020, LMT_CORRECTED_ERRORf, LMT_CORRECTED_ERROR_DISINTf}, 
    { 0x0010, LMT_UNCORRECTED_ERRORf, LMT_UNCORRECTED_ERROR_DISINTf}, 
    { 0x0008, CTR_CORRECTED_ERRORf, CTR_CORRECTED_ERROR_DISINTf}, 
    { 0x0004, CTR_UNCORRECTED_ERRORf, CTR_UNCORRECTED_ERROR_DISINTf}, 
    { 0x0002, EXP_CORRECTED_ERRORf, EXP_CORRECTED_ERROR_DISINTf}, 
    { 0x0001, EXP_UNCORRECTED_ERRORf, EXP_UNCORRECTED_ERROR_DISINTf}, 
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                                _soc_katana2_mmu_sb_age_ext_parity_info [] = {
    { 0x0020, LMT_CORRECTED_ERRORf, LMT_CORRECTED_ERROR_DISINTf}, 
    { 0x0010, LMT_UNCORRECTED_ERRORf, LMT_UNCORRECTED_ERROR_DISINTf}, 
    { 0x0008, CTR_CORRECTED_ERRORf, CTR_CORRECTED_ERROR_DISINTf}, 
    { 0x0004, CTR_UNCORRECTED_ERRORf, CTR_UNCORRECTED_ERROR_DISINTf}, 
    { 0x0002, EXP_CORRECTED_ERRORf, EXP_CORRECTED_ERROR_DISINTf}, 
    { 0x0001, EXP_UNCORRECTED_ERRORf, EXP_UNCORRECTED_ERROR_DISINTf}, 
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                _soc_katana2_mmu_sb_rqe_extq_parity_info [] = {
    { 0x4000000, REPLICATION_SRCH_FAILf, REPLICATION_SRCH_FAIL_MASKf }, 
    { 0x2000000, REPLICATION_OVER_LIMITf, REPLICATION_OVER_LIMIT_MASKf},
    { 0x1ffe000, REPLICATION_FAIL_MGIDf , 0 }, 
    { 0x0001fff, REPLICATION_COUNTf, 0 }, 
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                _soc_katana2_mmu_sb_ci_parity_info [] = {
    { 0x0100, PHY_READY_EVENTf,
       PHY_READYf},
    { 0x0080, PHY_BL1_RD_FIFO_ERRORf,
       PHY_BL1_RD_FIFO_ERRORf},
    { 0x0040, PHY_BL0_RD_FIFO_ERRORf,
       PHY_BL0_RD_FIFO_ERRORf},
    { 0x0020, WFIFO_CTL_CORRECTED_ERRORf,
       WFIFO_CTL_CORRECTED_ERROR_DISINTf},
    { 0x0010, WFIFO_CTL_UNCORRECTED_ERRORf,
       WFIFO_CTL_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, WFIFO_OVERFLOWf,
       WB_OVERFLOW_DISINTf},
    { 0x0004, RFIFO_CTL_CORRECTED_ERRORf,
       RFIFO_CTL_CORRECTED_ERROR_DISINTf},
    { 0x0002, RFIFO_CTL_UNCORRECTED_ERRORf,
       RFIFO_CTL_UNCORRECTED_ERROR_DISINTf},
    { 0x0001, RFIFO_OVERFLOWf,
       RFIFO_OVERFLOW_DISINTf},
    { 0 } /* table terminator */

};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t 
                         _soc_katana2_mmu_sb_emc0_parity_info [] = {
    /* EMC_ERROR_0 */
    { 0x0020, EMC_WTAC_SPC_EMA_LOCKUP_ERRORf, 
         EMC_WTAC_SPC_EMA_LOCKUP_ERROR_DISINTf },
    { 0x0010, EMC_WLCT2_MF_BUFFER_OVERFLOW_ERRORf, 
         EMC_WLCT2_MF_BUFFER_OVERFLOW_ERROR_DISINTf },
    { 0x0008, EMC_WLCT1_MF_BUFFER_OVERFLOW_ERRORf, 
         EMC_WLCT1_MF_BUFFER_OVERFLOW_ERROR_DISINTf },
    { 0x0004, EMC_WLCT0_MF_BUFFER_OVERFLOW_ERRORf, 
         EMC_WLCT0_MF_BUFFER_OVERFLOW_ERROR_DISINTf },
    { 0x0002, EMC_IRRB_BUFFER_OVERFLOW_ERRORf, 
         EMC_IRRB_BUFFER_OVERFLOW_ERROR_DISINTf },
    { 0x0001, EMC_IWRB_BUFFER_OVERFLOW_ERRORf, 
         EMC_IWRB_BUFFER_OVERFLOW_ERROR_DISINTf },
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t
                                 _soc_katana2_mmu_sb_emc1_parity_info [] = {
    /* EMC_ERROR_1 */
    { 0x20000000, EMC_CSDB_2_UPPER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_2_UPPER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x10000000, EMC_CSDB_2_LOWER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_2_LOWER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x8000000, EMC_CSDB_1_UPPER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_1_UPPER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x4000000, EMC_CSDB_1_LOWER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_1_LOWER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x2000000, EMC_CSDB_0_UPPER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_0_UPPER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x1000000, EMC_CSDB_0_LOWER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_0_LOWER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x800000, EMC_ERRB_1_BUFFER_UNCORRECTED_ERRORf,
        EMC_ERRB_1_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x400000, EMC_ERRB_1_BUFFER_CORRECTED_ERRORf,
        EMC_ERRB_1_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x200000, EMC_ERRB_0_BUFFER_UNCORRECTED_ERRORf,
        EMC_ERRB_0_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x100000, EMC_ERRB_0_BUFFER_CORRECTED_ERRORf,    
        EMC_ERRB_0_BUFFER_CORRECTED_ERROR_DISINTf},    
    { 0x80000, EMC_RFCQ_BUFFER_UNCORRECTED_ERRORf,      
        EMC_RFCQ_BUFFER_UNCORRECTED_ERROR_DISINTf},      
    { 0x40000, EMC_RFCQ_BUFFER_CORRECTED_ERRORf,    
        EMC_RFCQ_BUFFER_CORRECTED_ERROR_DISINTf},    
    { 0x20000, EMC_RSFP_BUFFER_UNCORRECTED_ERRORf,      
        EMC_RSFP_BUFFER_UNCORRECTED_ERROR_DISINTf},      
    { 0x10000, EMC_RSFP_BUFFER_CORRECTED_ERRORf,    
        EMC_RSFP_BUFFER_CORRECTED_ERROR_DISINTf},    
    { 0x8000, EMC_IRRB_BUFFER_UNCORRECTED_ERRORf,      
        EMC_IRRB_BUFFER_UNCORRECTED_ERROR_DISINTf},      
    { 0x4000, EMC_IRRB_BUFFER_CORRECTED_ERRORf,    
        EMC_IRRB_BUFFER_CORRECTED_ERROR_DISINTf},    
    { 0x2000, EMC_EWRB_0_BUFFER_1_UNCORRECTED_ERRORf,      
        EMC_EWRB_0_BUFFER_1_UNCORRECTED_ERROR_DISINTf},      
    { 0x1000, EMC_EWRB_0_BUFFER_1_CORRECTED_ERRORf,    
        EMC_EWRB_0_BUFFER_1_CORRECTED_ERROR_DISINTf},    
    { 0x0800, EMC_EWRB_0_BUFFER_0_UNCORRECTED_ERRORf,      
        EMC_EWRB_0_BUFFER_0_UNCORRECTED_ERROR_DISINTf},      
    { 0x0400, EMC_EWRB_0_BUFFER_0_CORRECTED_ERRORf,    
        EMC_EWRB_0_BUFFER_0_CORRECTED_ERROR_DISINTf},    
    { 0x0200, EMC_WCMT_BUFFER_UNCORRECTED_ERRORf,      
        EMC_WCMT_BUFFER_UNCORRECTED_ERROR_DISINTf},      
    { 0x0100, EMC_WCMT_BUFFER_CORRECTED_ERRORf,     
        EMC_WCMT_BUFFER_CORRECTED_ERROR_DISINTf},     
    { 0x0080, EMC_SWAT_BUFFER_UNCORRECTED_ERRORf,       
        EMC_SWAT_BUFFER_UNCORRECTED_ERROR_DISINTf},       
    { 0x0040, EMC_SWAT_BUFFER_CORRECTED_ERRORf,     
        EMC_SWAT_BUFFER_CORRECTED_ERROR_DISINTf},     
    { 0x0020, EMC_WTOQ_BUFFER_UNCORRECTED_ERRORf,       
        EMC_WTOQ_BUFFER_UNCORRECTED_ERROR_DISINTf},       
    { 0x0010, EMC_WTOQ_BUFFER_CORRECTED_ERRORf,     
        EMC_WTOQ_BUFFER_CORRECTED_ERROR_DISINTf},     
    { 0x0008, EMC_WTFP_BUFFER_UNCORRECTED_ERRORf,       
        EMC_WTFP_BUFFER_UNCORRECTED_ERROR_DISINTf},       
    { 0x0004, EMC_WTFP_BUFFER_CORRECTED_ERRORf,     
        EMC_WTFP_BUFFER_CORRECTED_ERROR_DISINTf},     
    { 0x0002, EMC_IWRB_BUFFER_UNCORRECTED_ERRORf,       
        EMC_IWRB_BUFFER_UNCORRECTED_ERROR_DISINTf},       
    { 0x0001, EMC_IWRB_BUFFER_CORRECTED_ERRORf,     
        EMC_IWRB_BUFFER_CORRECTED_ERROR_DISINTf},  
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t
                          _soc_katana2_mmu_sb_emc2_parity_info [] = {
    /* EMC_ERROR_2 */
    { 0x20000000, EMC_CSDB_5_UPPER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_5_UPPER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x10000000, EMC_CSDB_5_LOWER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_5_LOWER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x08000000, EMC_CSDB_4_UPPER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_4_UPPER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x04000000, EMC_CSDB_4_LOWER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_4_LOWER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x02000000, EMC_CSDB_3_UPPER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_3_UPPER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x01000000, EMC_CSDB_3_LOWER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_3_LOWER_BUFFER_UNCORRECTED_ERROR_DISINTf},    
    { 0x00800000, EMC_WLCT2_UPPER_B_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT2_UPPER_B_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x00400000, EMC_WLCT2_UPPER_B_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT2_UPPER_B_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0200000, EMC_WLCT2_UPPER_A_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT2_UPPER_A_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0100000, EMC_WLCT2_UPPER_A_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT2_UPPER_A_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0080000, EMC_WLCT2_LOWER_B_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT2_LOWER_B_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0040000, EMC_WLCT2_LOWER_B_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT2_LOWER_B_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0020000, EMC_WLCT2_LOWER_A_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT2_LOWER_A_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0010000, EMC_WLCT2_LOWER_A_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT2_LOWER_A_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0008000, EMC_WLCT1_UPPER_B_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT1_UPPER_B_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0004000, EMC_WLCT1_UPPER_B_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT1_UPPER_B_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0002000, EMC_WLCT1_UPPER_A_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT1_UPPER_A_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0001000, EMC_WLCT1_UPPER_A_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT1_UPPER_A_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0000800, EMC_WLCT1_LOWER_B_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT1_LOWER_B_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0000400, EMC_WLCT1_LOWER_B_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT1_LOWER_B_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0000200, EMC_WLCT1_LOWER_A_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT1_LOWER_A_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0000100, EMC_WLCT1_LOWER_A_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT1_LOWER_A_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0000080, EMC_WLCT0_UPPER_B_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT0_UPPER_B_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0000040, EMC_WLCT0_UPPER_B_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT0_UPPER_B_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0000020, EMC_WLCT0_UPPER_A_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT0_UPPER_A_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0000010, EMC_WLCT0_UPPER_A_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT0_UPPER_A_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0000008, EMC_WLCT0_LOWER_B_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT0_LOWER_B_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0000004, EMC_WLCT0_LOWER_B_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT0_LOWER_B_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0000002, EMC_WLCT0_LOWER_A_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT0_LOWER_A_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0000001, EMC_WLCT0_LOWER_A_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT0_LOWER_A_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t
                          _soc_katana2_mmu_sb_emc3_parity_info [] = {
    /* EMC_ERROR_3 */
    { 0x0008000, EMC_CI5_FIXED_PATTERN_ERRORf,
        EMC_CI5_FIXED_PATTERN_ERROR_DISINTf},
    { 0x0004000, EMC_CI4_FIXED_PATTERN_ERRORf,
        EMC_CI4_FIXED_PATTERN_ERROR_DISINTf},
    { 0x0002000, EMC_CI3_FIXED_PATTERN_ERRORf,
        EMC_CI3_FIXED_PATTERN_ERROR_DISINTf},
    { 0x0001000, EMC_CI2_FIXED_PATTERN_ERRORf,
        EMC_CI2_FIXED_PATTERN_ERROR_DISINTf},
    { 0x0000800, EMC_CI1_FIXED_PATTERN_ERRORf,
        EMC_CI1_FIXED_PATTERN_ERROR_DISINTf},
    { 0x0000400, EMC_CI0_FIXED_PATTERN_ERRORf,
        EMC_CI0_FIXED_PATTERN_ERROR_DISINTf},
    { 0x0000200, EMC_WLCT2_MERGED_RETURN_WTAG_FIFO_UNCORRECTED_ERRORf,
        EMC_WLCT2_MERGED_RETURN_WTAG_FIFO_UNCORRECTED_ERROR_DISINTf},
    { 0x0000100, EMC_WLCT2_MERGED_RETURN_WTAG_FIFO_CORRECTED_ERRORf,
        EMC_WLCT2_MERGED_RETURN_WTAG_FIFO_CORRECTED_ERROR_DISINTf},
    { 0x0000080, EMC_WLCT1_MERGED_RETURN_WTAG_FIFO_UNCORRECTED_ERRORf,
        EMC_WLCT1_MERGED_RETURN_WTAG_FIFO_UNCORRECTED_ERROR_DISINTf},
    { 0x0000040, EMC_WLCT1_MERGED_RETURN_WTAG_FIFO_CORRECTED_ERRORf,
        EMC_WLCT1_MERGED_RETURN_WTAG_FIFO_CORRECTED_ERROR_DISINTf},
    { 0x0000020, EMC_WLCT0_MERGED_RETURN_WTAG_FIFO_UNCORRECTED_ERRORf,
        EMC_WLCT0_MERGED_RETURN_WTAG_FIFO_UNCORRECTED_ERROR_DISINTf},
    { 0x0000010, EMC_WLCT0_MERGED_RETURN_WTAG_FIFO_CORRECTED_ERRORf,
        EMC_WLCT0_MERGED_RETURN_WTAG_FIFO_CORRECTED_ERROR_DISINTf},
    { 0x0000008, EMC_EWRB_1_BUFFER_1_UNCORRECTED_ERRORf,
        EMC_EWRB_1_BUFFER_1_UNCORRECTED_ERROR_DISINTf},
    { 0x0000004, EMC_EWRB_1_BUFFER_1_CORRECTED_ERRORf,
        EMC_EWRB_1_BUFFER_1_CORRECTED_ERROR_DISINTf},
    { 0x0000002, EMC_EWRB_1_BUFFER_0_UNCORRECTED_ERRORf,
        EMC_EWRB_1_BUFFER_0_UNCORRECTED_ERROR_DISINTf},
    { 0x0000001, EMC_EWRB_1_BUFFER_0_CORRECTED_ERRORf,
        EMC_EWRB_1_BUFFER_0_CORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_internal_info_t
               _soc_katana2_mmu_sb_emc_parity_info [] = {
    { 0x0008, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_3, 
      0,
      EMC_ERROR_3f,
      EMC_ERROR_MASK_3r,
      EMC_ERROR_3r,
      _soc_katana2_mmu_sb_emc3_parity_info },
      
    { 0x0004, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_2, 
    	0,
      EMC_ERROR_2f,
      EMC_ERROR_MASK_2r,
      EMC_ERROR_2r,
      _soc_katana2_mmu_sb_emc2_parity_info },
      
    { 0x0002, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_1,
    	0,
      EMC_ERROR_1f,
      EMC_ERROR_MASK_1r,
      EMC_ERROR_1r, 
      _soc_katana2_mmu_sb_emc1_parity_info },
      
    { 0x0001, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_0,
    	0,
    	EMC_ERROR_0f,
    	EMC_ERROR_MASK_0r,
      EMC_ERROR_0r, 
      _soc_katana2_mmu_sb_emc0_parity_info },
      
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_internal_info_t
               _soc_katana2_mmu_sb_toq_parity_info [] = {
    { 0x0002, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_TOQ_ERROR_2,
    	TOQ_ERROR2_DISINTf,
      TOQ_ERROR2f,
      TOQ_ERROR2_MASKr,
      TOQ_ERROR2r, 
      _soc_katana2_mmu_sb_toq2_parity_info },
      
    { 0x0001, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_TOQ_ERROR_1,
    	TOQ_ERROR1_DISINTf,
    	TOQ_ERROR1_ERRORf,
    	TOQ_ERROR1_MASKr,
      TOQ_ERROR1r, 
      _soc_katana2_mmu_sb_toq1_parity_info },
      
    { 0 } /* table terminator */

};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t
                                  _soc_katana2_mmu_sb_deq0_parity_info [] = {
    { 0x0800, DEQ_RDE_TRACE_EVENTf, 
    	DEQ_RDE_TRACE_EVENT_DISINTf},
    { 0x0400, CCBE_CONTROL_DATA_REPLICATION_CREDIT_RETURN_2_ERRORf, 
    	CCBE_CONTROL_DATA_REPLICATION_CREDIT_RETURN_2_ERROR_DISINTf},
    { 0x0200, CCBE_CONTROL_DATA_REPLICATION_CREDIT_RETURN_1_ERRORf, 
    	CCBE_CONTROL_DATA_REPLICATION_CREDIT_RETURN_1_ERROR_DISINTf},
    { 0x0100, CCBE_CONTROL_DATA_REPLICATION_ERRORf, 
    	CCBE_CONTROL_DATA_REPLICATION_ERROR_DISINTf},
    { 0x0080, CELL_CLASSIFICATION_EXT_ERRORf, 
    	CELL_CLASSIFICATION_EXT_ERROR_DISINTf},
    { 0x0040, CELL_CLASSIFICATION_INT_ERRORf, 
    	CELL_CLASSIFICATION_INT_ERROR_DISINTf},
    { 0x0020, RD_CTRL_RD_REQ_DISCARD_ERRORf, 
    	RD_CTRL_RD_REQ_DISCARD_ERROR_DISINTf},
    { 0x0010, DEQ_TRACE_EVENTf, 
    	DEQ_TRACE_EVENT_DISINTf},
    { 0x0008, EGRESS_FIFO_OVERFLOW_ERRORf, 
    	EGRESS_FIFO_OVERFLOW_ERROR_DISINTf},
    { 0x0004, EGRESS_FIFO_UNDERRUN_ERRORf,
        EGRESS_FIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0002, TOQ_TO_DEQ_CELL_REP_INFO_BUFFER_RD_REQ_ERRORf,
        DEQ_TO_CFG_TOQ_TO_DEQ_CELL_REP_INFO_BUFFER_RD_REQ_ERROR_DISINTf}, 
    { 0x0001, TOQ_TO_DEQ_CELL_REP_INFO_BUFFER_WR_REQ_ERRORf,
        DEQ_TO_CFG_TOQ_TO_DEQ_CELL_REP_INFO_BUFFER_WR_REQ_ERROR_DISINTf}, 
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t 
                                  _soc_katana2_mmu_sb_deq1_parity_info [] = {
    { 0x0200, PORT_41_EFIFO_UNDERRUN_ERRORf,         
        PORT_41_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0100, PORT_40_EFIFO_UNDERRUN_ERRORf,         
        PORT_40_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0080, PORT_39_EFIFO_UNDERRUN_ERRORf,         
        PORT_39_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0040, PORT_38_EFIFO_UNDERRUN_ERRORf,         
        PORT_38_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0020, PORT_37_EFIFO_UNDERRUN_ERRORf,         
        PORT_37_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0010, PORT_36_EFIFO_UNDERRUN_ERRORf,         
        PORT_36_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0008, PORT_35_EFIFO_UNDERRUN_ERRORf,         
        PORT_35_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0004, PORT_34_EFIFO_UNDERRUN_ERRORf,         
        PORT_34_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0002, PORT_33_EFIFO_UNDERRUN_ERRORf,         
        PORT_33_EFIFO_UNDERRUN_ERROR_DISINTf},     
    { 0x0001, PORT_32_EFIFO_UNDERRUN_ERRORf,
        PORT_32_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t 
                                  _soc_katana2_mmu_sb_deq2_parity_info [] = {
    { 0x80000000, PORT_31_EFIFO_UNDERRUN_ERRORf,
         PORT_31_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x40000000, PORT_30_EFIFO_UNDERRUN_ERRORf,
         PORT_30_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x20000000, PORT_29_EFIFO_UNDERRUN_ERRORf,
         PORT_29_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x10000000, PORT_28_EFIFO_UNDERRUN_ERRORf,
         PORT_28_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x08000000, PORT_27_EFIFO_UNDERRUN_ERRORf,
         PORT_27_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x04000000, PORT_26_EFIFO_UNDERRUN_ERRORf,
         PORT_26_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x02000000, PORT_25_EFIFO_UNDERRUN_ERRORf,
         PORT_25_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x01000000, PORT_24_EFIFO_UNDERRUN_ERRORf,
         PORT_24_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00800000, PORT_23_EFIFO_UNDERRUN_ERRORf,
         PORT_23_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00400000, PORT_22_EFIFO_UNDERRUN_ERRORf,
         PORT_22_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00200000, PORT_21_EFIFO_UNDERRUN_ERRORf,
         PORT_21_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00100000, PORT_20_EFIFO_UNDERRUN_ERRORf,
         PORT_20_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00080000, PORT_19_EFIFO_UNDERRUN_ERRORf,
         PORT_19_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00040000, PORT_18_EFIFO_UNDERRUN_ERRORf,
         PORT_18_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00020000, PORT_17_EFIFO_UNDERRUN_ERRORf,
         PORT_17_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00010000, PORT_16_EFIFO_UNDERRUN_ERRORf,
         PORT_16_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00008000, PORT_15_EFIFO_UNDERRUN_ERRORf,
         PORT_15_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00004000, PORT_14_EFIFO_UNDERRUN_ERRORf,
         PORT_14_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00002000, PORT_13_EFIFO_UNDERRUN_ERRORf,
         PORT_13_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00001000, PORT_12_EFIFO_UNDERRUN_ERRORf,
         PORT_12_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000800, PORT_11_EFIFO_UNDERRUN_ERRORf,
         PORT_11_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000400, PORT_10_EFIFO_UNDERRUN_ERRORf,
         PORT_10_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000200, PORT_09_EFIFO_UNDERRUN_ERRORf,
         PORT_09_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000100, PORT_08_EFIFO_UNDERRUN_ERRORf,
         PORT_08_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000080, PORT_07_EFIFO_UNDERRUN_ERRORf,
         PORT_07_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000040, PORT_06_EFIFO_UNDERRUN_ERRORf,
         PORT_06_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000020, PORT_05_EFIFO_UNDERRUN_ERRORf,
         PORT_05_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000010, PORT_04_EFIFO_UNDERRUN_ERRORf,
         PORT_04_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000008, PORT_03_EFIFO_UNDERRUN_ERRORf,
         PORT_03_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000004, PORT_02_EFIFO_UNDERRUN_ERRORf,
         PORT_02_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000002, PORT_01_EFIFO_UNDERRUN_ERRORf,
         PORT_01_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000001, PORT_00_EFIFO_UNDERRUN_ERRORf,
         PORT_00_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t 
                                  _soc_katana2_mmu_sb_deq3_parity_info [] = {
    { 0x80000000, DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_2_UNCORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_2_UNCORRECTED_ERROR_DISINTf},
    { 0x40000000, DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_2_CORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_2_CORRECTED_ERROR_DISINTf},
    { 0x20000000, DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_1_UNCORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_1_UNCORRECTED_ERROR_DISINTf},
    { 0x10000000, DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_1_CORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_1_CORRECTED_ERROR_DISINTf},
    { 0x08000000, DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_0_UNCORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_0_UNCORRECTED_ERROR_DISINTf},
    { 0x04000000, DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_0_CORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_0_CORRECTED_ERROR_DISINTf},
    { 0x02000000, DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_2_UNCORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_2_UNCORRECTED_ERROR_DISINTf},
    { 0x01000000, DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_2_CORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_2_CORRECTED_ERROR_DISINTf},
    { 0x00800000, DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_1_UNCORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_1_UNCORRECTED_ERROR_DISINTf},
    { 0x00400000, DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_1_CORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_1_CORRECTED_ERROR_DISINTf},
    { 0x00200000, DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_0_UNCORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_0_UNCORRECTED_ERROR_DISINTf},
    { 0x00100000, DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_0_CORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_0_CORRECTED_ERROR_DISINTf},      
    { 0x00080000, DEQ_EP_REDIRECT_BUFFER_2_UNCORRECTED_ERRORf,
          DEQ_EP_REDIRECT_BUFFER_2_UNCORRECTED_ERROR_DISINTf},
    { 0x00040000, DEQ_EP_REDIRECT_BUFFER_2_CORRECTED_ERRORf,
          DEQ_EP_REDIRECT_BUFFER_2_CORRECTED_ERROR_DISINTf},
    { 0x00020000, DEQ_EP_REDIRECT_BUFFER_1_UNCORRECTED_ERRORf,
          DEQ_EP_REDIRECT_BUFFER_1_UNCORRECTED_ERROR_DISINTf},
    { 0x00010000, DEQ_EP_REDIRECT_BUFFER_1_CORRECTED_ERRORf,
          DEQ_EP_REDIRECT_BUFFER_1_CORRECTED_ERROR_DISINTf},
    { 0x00008000, DEQ_EP_REDIRECT_BUFFER_0_UNCORRECTED_ERRORf,
          DEQ_EP_REDIRECT_BUFFER_0_UNCORRECTED_ERROR_DISINTf},
    { 0x00004000, DEQ_EP_REDIRECT_BUFFER_0_CORRECTED_ERRORf,
          DEQ_EP_REDIRECT_BUFFER_0_CORRECTED_ERROR_DISINTf},
    { 0x00002000, DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_1520_UNCORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_1520_UNCORRECTED_ERROR_DISINTf},
    { 0x00001000, DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_1520_CORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_1520_CORRECTED_ERROR_DISINTf},
    { 0x00000800, DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_57_UNCORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_57_UNCORRECTED_ERROR_DISINTf},
    { 0x00000400, DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_57_CORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_57_CORRECTED_ERROR_DISINTf},
    { 0x00000200, DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_1520_UNCORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_1520_UNCORRECTED_ERROR_DISINTf},
    { 0x00000100, DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_1520_CORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_1520_CORRECTED_ERROR_DISINTf},
    { 0x00000080, DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_57_UNCORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_57_UNCORRECTED_ERROR_DISINTf},
    { 0x00000040, DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_57_CORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_57_CORRECTED_ERROR_DISINTf},
    { 0x00000020, DEQ_EGRESS_FIFO_CONTROL_DATA_MEMORY_UNCORRECTED_ERRORf,
          DEQ_EGRESS_FIFO_CONTROL_DATA_MEMORY_UNCORRECTED_ERROR_DISINTf},
    { 0x00000010, DEQ_EGRESS_FIFO_CONTROL_DATA_MEMORY_CORRECTED_ERRORf,
          DEQ_EGRESS_FIFO_CONTROL_DATA_MEMORY_CORRECTED_ERROR_DISINTf},
    { 0x00000008, DEQ_AGING_MASK_MEMORY_UNCORRECTED_ERRORf,
          DEQ_AGING_MASK_MEMORY_UNCORRECTED_ERROR_DISINTf},
    { 0x00000004, DEQ_AGING_MASK_MEMORY_CORRECTED_ERRORf,
          DEQ_AGING_MASK_MEMORY_CORRECTED_ERROR_DISINTf},
    { 0x00000002, DEQ_TOQ_CELL_REP_INFO_BUFFER_UNCORRECTED_ERRORf,
  	  DEQ_TOQ_CELL_REP_INFO_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x00000001, DEQ_TOQ_CELL_REP_INFO_BUFFER_CORRECTED_ERRORf,
          DEQ_TOQ_CELL_REP_INFO_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t 
                                  _soc_katana2_mmu_sb_deq4_parity_info [] = {
    { 0x00000002, DEQ_OPQ_CELL_INFO_BUFFER_UNCORRECTED_ERRORf,
  	  DEQ_OPQ_CELL_INFO_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x00000001, DEQ_OPQ_CELL_INFO_BUFFER_CORRECTED_ERRORf,
          DEQ_OPQ_CELL_INFO_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_internal_info_t
                           _soc_katana2_mmu_sb_deq_parity_info [] = {
    { 0x0010, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_4, 
    	0,
    	DEQ_ERROR_4f,
    	DEQ_ERROR_MASK_4r,
    	DEQ_ERROR_4r, 
      _soc_katana2_mmu_sb_deq4_parity_info },
      
    { 0x0008, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_3,
    	0,
      DEQ_ERROR_3f,
      DEQ_ERROR_MASK_3r,
    	DEQ_ERROR_3r, 
       _soc_katana2_mmu_sb_deq3_parity_info },
    
    { 0x0004, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_2, 
    	0,
      DEQ_ERROR_2f,
      DEQ_ERROR_MASK_2r,
    	DEQ_ERROR_2r, 
      _soc_katana2_mmu_sb_deq2_parity_info },
      
    { 0x0002, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_1,
    	0,
      DEQ_ERROR_1f, 
      DEQ_ERROR_MASK_1r,
    	DEQ_ERROR_1r, 
      _soc_katana2_mmu_sb_deq1_parity_info },
      
    { 0x0001, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_0,
    	0,
      DEQ_ERROR_0f, 
      DEQ_ERROR_MASK_0r,
    	DEQ_ERROR_0r, 
      _soc_katana2_mmu_sb_deq0_parity_info },
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t
                      _soc_katana2_mmu_sb_qstruct_fap_parity_info [] = {
    { 0x100000, FAP3_DUPLICATE_PTR_ERRORf,
  	    FAP3_DUPLICATE_PTR_ERROR_DISINTf},
    { 0x80000, FAP2_DUPLICATE_PTR_ERRORf,
  	    FAP2_DUPLICATE_PTR_ERROR_DISINTf},
    { 0x40000, FAP1_DUPLICATE_PTR_ERRORf,
  	    FAP1_DUPLICATE_PTR_ERROR_DISINTf},
    { 0x20000, FAP0_DUPLICATE_PTR_ERRORf,
  	    FAP0_DUPLICATE_PTR_ERROR_DISINTf},
    { 0x10000, FAP_LOADING_ERRORf,
  	    FAP_LOADING_ERROR_DISINTf},
    { 0x8000, CORRECTED_BITMAP_ERROR_3f,
  	    CORRECTED_BITMAP_ERROR_3_DISINTf},
    { 0x4000, UNCORRECTED_BITMAP_ERROR_3f,
  	    UNCORRECTED_BITMAP_ERROR_3_DISINTf},
    { 0x2000, CORRECTED_STACK_ERROR_3f,
  	    CORRECTED_STACK_ERROR_3_DISINTf},
    { 0x1000, UNCORRECTED_STACK_ERROR_3f,
  	    UNCORRECTED_STACK_ERROR_3_DISINTf},
    { 0x0800, CORRECTED_BITMAP_ERROR_2f,
            CORRECTED_BITMAP_ERROR_2_DISINTf},
    { 0x0400, UNCORRECTED_BITMAP_ERROR_2f,
  	    UNCORRECTED_BITMAP_ERROR_2_DISINTf},
    { 0x0200, CORRECTED_STACK_ERROR_2f,
  	    CORRECTED_STACK_ERROR_2_DISINTf},
    { 0x0100, UNCORRECTED_STACK_ERROR_2f,
  	    UNCORRECTED_STACK_ERROR_2_DISINTf},
    { 0x0080, CORRECTED_BITMAP_ERROR_1f,
            CORRECTED_BITMAP_ERROR_1_DISINTf},
    { 0x0040, UNCORRECTED_BITMAP_ERROR_1f,
  	    UNCORRECTED_BITMAP_ERROR_1_DISINTf},
    { 0x0020, CORRECTED_STACK_ERROR_1f,
  	    CORRECTED_STACK_ERROR_1_DISINTf},
    { 0x0010, UNCORRECTED_STACK_ERROR_1f,
  	    UNCORRECTED_STACK_ERROR_1_DISINTf},
    { 0x0008, CORRECTED_BITMAP_ERROR_0f,
            CORRECTED_BITMAP_ERROR_0_DISINTf},
    { 0x0004, UNCORRECTED_BITMAP_ERROR_0f,
            UNCORRECTED_BITMAP_ERROR_0_DISINTf},
    { 0x0002, CORRECTED_STACK_ERROR_0f,
            CORRECTED_STACK_ERROR_0_DISINTf},
    { 0x0001, UNCORRECTED_STACK_ERROR_0f,
            UNCORRECTED_STACK_ERROR_0_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t
                      _soc_katana2_mmu_sb_qstruct_qentry_upper_parity_info [] = {
    { 0x8000, CORRECTED_ERROR_7f,
        CORRECTED_ERROR_7_DISINTf},
    { 0x4000, UNCORRECTED_ERROR_7f,
        UNCORRECTED_ERROR_7_DISINTf},
    { 0x2000, CORRECTED_ERROR_6f,
        CORRECTED_ERROR_6_DISINTf},
    { 0x1000, UNCORRECTED_ERROR_6f,
        UNCORRECTED_ERROR_6_DISINTf},
    { 0x0800, CORRECTED_ERROR_5f,
        CORRECTED_ERROR_5_DISINTf},
    { 0x0400, UNCORRECTED_ERROR_5f,
        UNCORRECTED_ERROR_5_DISINTf},
    { 0x0200, CORRECTED_ERROR_4f,
        CORRECTED_ERROR_4_DISINTf},
    { 0x0100, UNCORRECTED_ERROR_4f,
        UNCORRECTED_ERROR_4_DISINTf},
    { 0x0080, CORRECTED_ERROR_3f,
        CORRECTED_ERROR_3_DISINTf},
    { 0x0040, UNCORRECTED_ERROR_3f,
        UNCORRECTED_ERROR_3_DISINTf},
    { 0x0020, CORRECTED_ERROR_2f,
        CORRECTED_ERROR_2_DISINTf},
    { 0x0010, UNCORRECTED_ERROR_2f,
        UNCORRECTED_ERROR_2_DISINTf},
    { 0x0008, CORRECTED_ERROR_1f,
        CORRECTED_ERROR_1_DISINTf},
    { 0x0004, UNCORRECTED_ERROR_1f,
        UNCORRECTED_ERROR_1_DISINTf},
    { 0x0002, CORRECTED_ERROR_0f,
        CORRECTED_ERROR_0_DISINTf},
    { 0x0001, UNCORRECTED_ERROR_0f,
        UNCORRECTED_ERROR_0_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t
                      _soc_katana2_mmu_sb_qstruct_qentry_lower_parity_info [] = {
    { 0x8000, CORRECTED_ERROR_7f,
         CORRECTED_ERROR_7_DISINTf},
    { 0x4000, UNCORRECTED_ERROR_7f,
         UNCORRECTED_ERROR_7_DISINTf},
    { 0x2000, CORRECTED_ERROR_6f,
         CORRECTED_ERROR_6_DISINTf},
    { 0x1000, UNCORRECTED_ERROR_6f,
         UNCORRECTED_ERROR_6_DISINTf},
    { 0x0800, CORRECTED_ERROR_5f,
         CORRECTED_ERROR_5_DISINTf},
    { 0x0400, UNCORRECTED_ERROR_5f,
         UNCORRECTED_ERROR_5_DISINTf},
    { 0x0200, CORRECTED_ERROR_4f,
         CORRECTED_ERROR_4_DISINTf},
    { 0x0100, UNCORRECTED_ERROR_4f,
         UNCORRECTED_ERROR_4_DISINTf},
    { 0x0080, CORRECTED_ERROR_3f,
         CORRECTED_ERROR_3_DISINTf},
    { 0x0040, UNCORRECTED_ERROR_3f,
         UNCORRECTED_ERROR_3_DISINTf},
    { 0x0020, CORRECTED_ERROR_2f,
         CORRECTED_ERROR_2_DISINTf},
    { 0x0010, UNCORRECTED_ERROR_2f,
         UNCORRECTED_ERROR_2_DISINTf},
    { 0x0008, CORRECTED_ERROR_1f,
         CORRECTED_ERROR_1_DISINTf},
    { 0x0004, UNCORRECTED_ERROR_1f,
         UNCORRECTED_ERROR_1_DISINTf},
    { 0x0002, CORRECTED_ERROR_0f,
         CORRECTED_ERROR_0_DISINTf},
    { 0x0001, UNCORRECTED_ERROR_0f,
         UNCORRECTED_ERROR_0_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t
                _soc_katana2_mmu_sb_qstruct_qentry_qblock_nxt_parity_info [] = {
    { 0x8000, CORRECTED_ERROR_7f,
         CORRECTED_ERROR_7_DISINTf},
    { 0x4000, UNCORRECTED_ERROR_7f,
         UNCORRECTED_ERROR_7_DISINTf},
    { 0x2000, CORRECTED_ERROR_6f,
         CORRECTED_ERROR_6_DISINTf},
    { 0x1000, UNCORRECTED_ERROR_6f,
         UNCORRECTED_ERROR_6_DISINTf},
    { 0x0800, CORRECTED_ERROR_5f,
         CORRECTED_ERROR_5_DISINTf},
    { 0x0400, UNCORRECTED_ERROR_5f,
         UNCORRECTED_ERROR_5_DISINTf},
    { 0x0200, CORRECTED_ERROR_4f,
         CORRECTED_ERROR_4_DISINTf},
    { 0x0100, UNCORRECTED_ERROR_4f,
         UNCORRECTED_ERROR_4_DISINTf},
    { 0x0080, CORRECTED_ERROR_3f,
         CORRECTED_ERROR_3_DISINTf},
    { 0x0040, UNCORRECTED_ERROR_3f,
         UNCORRECTED_ERROR_3_DISINTf},
    { 0x0020, CORRECTED_ERROR_2f,
         CORRECTED_ERROR_2_DISINTf},
    { 0x0010, UNCORRECTED_ERROR_2f,
         UNCORRECTED_ERROR_2_DISINTf},
    { 0x0008, CORRECTED_ERROR_1f,
         CORRECTED_ERROR_1_DISINTf},
    { 0x0004, UNCORRECTED_ERROR_1f,
         UNCORRECTED_ERROR_1_DISINTf},
    { 0x0002, CORRECTED_ERROR_0f,
         CORRECTED_ERROR_0_DISINTf},
    { 0x0001, UNCORRECTED_ERROR_0f,
         UNCORRECTED_ERROR_0_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_internal_info_t
                           _soc_katana2_mmu_sb_qstruct_parity_info [] = {
    { 0x0008, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_FAP,
      QENTRY_FAP_ERROR_DISINTf,
      QENTRY_FAP_ERRORf,
      QSTRUCT_FAP_MEM_ERROR_MASKr,
      QSTRUCT_FAP_MEM_ERRORr,
      _soc_katana2_mmu_sb_qstruct_fap_parity_info }, 
      
    { 0x0004, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_QENTRY_U,
      QENTRY_UPPER_ERROR_DISINTf,
      QENTRY_UPPER_ERRORf, 
      QSTRUCT_QENTRY_UPPER_ERROR_MASKr,
      QSTRUCT_QENTRY_UPPER_ERRORr,
      _soc_katana2_mmu_sb_qstruct_qentry_upper_parity_info }, 
      
    { 0x0002, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_QENTRY_L,
    	QENTRY_LOWER_ERROR_DISINTf,
      QENTRY_LOWER_ERRORf,
      QSTRUCT_QENTRY_LOWER_ERROR_MASKr,
      QSTRUCT_QENTRY_LOWER_ERRORr,
      _soc_katana2_mmu_sb_qstruct_qentry_lower_parity_info }, 
      
    { 0x0001, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_QBLOCK,
      QBLOCK_NEXT_ERROR_DISINTf,
      QBLOCK_NEXT_ERRORf, 
      QSTRUCT_QBLOCK_NEXT_ERROR_MASKr,
      QSTRUCT_QBLOCK_NEXT_ERRORr,                                         
      _soc_katana2_mmu_sb_qstruct_qentry_qblock_nxt_parity_info }, 
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t 
                             _soc_katana2_mmu_sb_wred_parity_info [] = {
    { 0x4000000, UPDATE_INTRPT_STATUSf,
       UPDATE_INTRPT_MASKf },
    { 0x3ffe000, ECC_ERROR_1Bf,
       ECC_1B_ERROR_MASKf },
    { 0x1fff, ECC_ERROR_2Bf,
       ECC_2B_ERROR_MASKf },
    { 0 } /* table terminator */

};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                _soc_katana2_mmu_sb_rqe_ser_parity_info [] = {
    { 0x1000000, NULL_REPL_PKTf, NULL_REPL_PKT_MASKf }, 
    { 0x0800000, FLL_EMPTYf, FLL_EMPTY_MASKf }, 
    { 0x0400000, EXTQ_LL_ERRORf, EXTQ_LL_ERROR_MASKf }, 
    { 0x03ff100, ECC_1B_BITMAPf, ECC_1B_MASKf }, 
    { 0x00007ff, ECC_2B_BITMAPf, ECC_2B_MASKf }, 
    { 0 } /* table terminator */
};


STATIC 
_soc_katana2_mmu_sub_block_one_level_t  _soc_katana2_mmu_sub_blocks_type_1[] = {
    { 0x08000000, 
    	_SOC_KT2_MMU_SUBBLOCK_IPCTR,
      IPCTR_INTR_DISINTf, 
      IPCTR_INTRf,
      MMU_IPCTR_ECC_ERROR_0_MASKr,
      MMU_IPCTR_ECC_ERROR_0r,
      _soc_katana2_mmu_sb_ipctr_parity_info },
    
    { 0x04000000, 
    	_SOC_KT2_MMU_SUBBLOCK_ADM,
      ADM_INTR_DISINTf, 
      ADM_INTRf,
      MMU_ADM_ECC_ERROR_0_MASKr,
      MMU_ADM_ECC_ERROR_0r,
      _soc_katana2_mmu_sb_adm_parity_info },

    { 0x02000000, 
    	_SOC_KT2_MMU_SUBBLOCK_RDE,
      RDE_INTR_DISINTf, 
      RDE_INTRf,
      RDE_SER_MASKr,
      RDE_SER_STATUSr,
      _soc_katana2_mmu_sb_rde_parity_info },
    
    { 0x00800000, 
    	_SOC_KT2_MMU_SUBBLOCK_CI5,
      CI5_INTR_DISINTf, 
      CI5_INTRf,
      CI_ERROR_MASKr,
      CI_ERRORr,
      _soc_katana2_mmu_sb_ci_parity_info },

    { 0x00400000, 
    	_SOC_KT2_MMU_SUBBLOCK_CI4,
      CI4_INTR_DISINTf, 
      CI4_INTRf,
      CI_ERROR_MASKr,
      CI_ERRORr,
      _soc_katana2_mmu_sb_ci_parity_info },

    { 0x00200000, 
    	_SOC_KT2_MMU_SUBBLOCK_CI3,
      CI3_INTR_DISINTf, 
      CI3_INTRf, 
      CI_ERROR_MASKr,
      CI_ERRORr,
      _soc_katana2_mmu_sb_ci_parity_info },

    { 0x00100000, 
    	_SOC_KT2_MMU_SUBBLOCK_MEM1,
      MEM1_INTR_DISINTf, 
      MEM1_INTRf,
      CLINK_ERROR_MASKr,
      CLINK_ERRORr,
      _soc_katana2_mmu_sb_mem1_parity_info },

    { 0x00040000, 
    	_SOC_KT2_MMU_SUBBLOCK_E2EFC,
      E2EFC_INTR_DISINTf, 
      E2EFC_INTRf,
      MMU_E2EFC_ERROR_0_MASKr,
      MMU_E2EFC_ERROR_0r,
      _soc_katana2_mmu_sb_e2efc_parity_info},

    { 0x00010000, 
    	_SOC_KT2_MMU_SUBBLOCK_THDI,
      THDI_INTR_DISINTf, 
      THDI_INTRf,
      MMU_THDI_INTR_MASKr,
      MMU_THDI_INTRr,
      _soc_katana2_mmu_sb_thdi_parity_info},

    { 0x00000800, 
    	_SOC_KT2_MMU_SUBBLOCK_WRED,
      WRED_INTR_DISINTf, 
      WRED_INTRf,
      WRED_PARITY_ERROR_MASKr,
      WRED_PARITY_ERROR_BITMAPr,
      _soc_katana2_mmu_sb_wred_parity_info},

    { 0x00000040, 
    	_SOC_KT2_MMU_SUBBLOCK_CTR,
      CTR_INTR_DISINTf, 
      CTR_INTRf,
      CTR_ERROR_MASKr,
      CTR_ERRORr,
      _soc_katana2_mmu_sb_ctr_parity_info},

    { 0x00000010, 
    	_SOC_KT2_MMU_SUBBLOCK_CCP,
      CCP_INTR_DISINTf, 
      CCP_INTRf,
      CCP_ERROR_MASKr,
      CCP_ERRORr,
      _soc_katana2_mmu_sb_ccp_parity_info},
    
    { 0x00020000, 
    	_SOC_KT2_MMU_SUBBLOCK_ITE,
      ITE_INTR_DISINTf, 
      ITE_INTRf,
      MMU_ITE_ERROR_0_MASKr,
      MMU_ITE_ERROR_0r,
      _soc_katana2_mmu_sb_ite_parity_info},

    { 0x00020000, 
    	_SOC_KT2_MMU_SUBBLOCK_ITE_CFG,
      ITE_INTR_DISINTf, 
      ITE_INTRf,
      MMU_ITE_CFG_ECC_ERROR_0_MASKr,
      MMU_ITE_CFG_ECC_ERROR_0r,
      _soc_katana2_mmu_sb_ite_cfg_parity_info},

    { 0x00008000, 
    	_SOC_KT2_MMU_SUBBLOCK_ENQ_CFG,
      ENQ_INTR_DISINTf, 
      ENQ_INTRf,
      MMU_ENQ_CFG_ECC_ERROR_0_MASKr,
      MMU_ENQ_CFG_ECC_ERROR_0r,
      _soc_katana2_mmu_sb_enq_cfg_parity_info},

    { 0x00008000, 
    	_SOC_KT2_MMU_SUBBLOCK_ENQ,
      ENQ_INTR_DISINTf, 
      ENQ_INTRf,
      MMU_ENQ_ERROR_0_MASKr,
      MMU_ENQ_ERROR_0r,
      _soc_katana2_mmu_sb_enq_parity_info},

    { 0x00008000, 
    	_SOC_KT2_MMU_SUBBLOCK_ENQ_FAP,
      ENQ_INTR_DISINTf, 
      ENQ_INTRf,
      MMU_ENQ_FAP_ECC_ERROR_0_MASKr,
      MMU_ENQ_FAP_ECC_ERROR_0r,
      _soc_katana2_mmu_sb_enq_fap_parity_info},

    { 0x00000400, 
    	_SOC_KT2_MMU_SUBBLOCK_THDO_STATUS1,
      THDO_INTR_DISINTf, 
      THDO_INTRf,
      THDO_PARITY_ERROR_MASK1r,
      THDO_PARITY_ERROR_STATUS1r,
      _soc_katana2_mmu_sb_thdo_stat1_parity_info},

    { 0x00000400, 
    	_SOC_KT2_MMU_SUBBLOCK_THDO_STATUS2,
      THDO_INTR_DISINTf, 
      THDO_INTRf,
      THDO_PARITY_ERROR_MASK2r,
      THDO_PARITY_ERROR_STATUS2r,
      _soc_katana2_mmu_sb_thdo_stat2_parity_info},

    { 0x00000020, 
    	_SOC_KT2_MMU_SUBBLOCK_CFAPI,
      CFAP_INTR_DISINTf, 
      CFAP_INTRf,
      CFAPI_ERROR_MASKr,
      CFAPI_ECC_ERRORr,
      _soc_katana2_mmu_sb_cfapi_parity_info},

    { 0x00000020, 
    	_SOC_KT2_MMU_SUBBLOCK_CFAPE,
      CFAP_INTR_DISINTf, 
      CFAP_INTRf,
      CFAPE_ERROR_MASKr,
      CFAPE_ECC_ERRORr,
      _soc_katana2_mmu_sb_cfape_parity_info},

    { 0x00000008, 
    	_SOC_KT2_MMU_SUBBLOCK_AGING_INT,
      AGING_INTR_DISINTf, 
      AGING_INTRf,
      AGING_ERROR_MASK_INTr,
      AGING_ERROR_INTr,
      _soc_katana2_mmu_sb_age_int_parity_info},

    { 0x00000008, 
      _SOC_KT2_MMU_SUBBLOCK_AGING_EXT,
      AGING_INTR_DISINTf, 
      AGING_INTRf,
      AGING_ERROR_MASK_EXTr,
      AGING_ERROR_EXTr,
      _soc_katana2_mmu_sb_age_ext_parity_info},

    { 0x00004000, 
      _SOC_KT2_MMU_SUBBLOCK_CI2,
      CI2_INTR_DISINTf, 
      CI2_INTRf,
      CI_ERROR_MASKr,
      CI_ERRORr,
      _soc_katana2_mmu_sb_ci_parity_info},

    { 0x00002000, 
    	_SOC_KT2_MMU_SUBBLOCK_CI1,
      CI1_INTR_DISINTf, 
      CI1_INTRf,
      CI_ERROR_MASKr,
      CI_ERRORr,
      _soc_katana2_mmu_sb_ci_parity_info},

    { 0x00001000, 
    	_SOC_KT2_MMU_SUBBLOCK_CI0,
      CI0_INTR_DISINTf, 
      CI0_INTRf,
      CI_ERROR_MASKr,
      CI_ERRORr,
      _soc_katana2_mmu_sb_ci_parity_info},

    { 0x00000004, 
    	_SOC_KT2_MMU_SUBBLOCK_LLS,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_ERROR_MASKr,
      LLS_ERRORr,
      _soc_katana2_mmu_sb_lls_parity_info},

    { 0x00000004, 
    	_SOC_KT2_MMU_SUBBLOCK_LLS_PORT,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_PORT_ECC_ERROR_MASKr,
      LLS_PORT_ECC_ERRORr,
      _soc_katana2_mmu_sb_lls_port_parity_info},
    
    { 0x00000004,
    	_SOC_KT2_MMU_SUBBLOCK_LLS,
    	LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_ERROR2_MASKr,
      LLS_ERROR2r,
      _soc_katana2_mmu_sb_lls2_parity_info},


    { 0x00000004, 
    	_SOC_KT2_MMU_SUBBLOCK_LLS_UPD2,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_ERROR_UPD2_MASKr,
      LLS_ERROR_UPD2r,
      _soc_katana2_mmu_sb_lls_upd2_parity_info},

    { 0x00000004, 
    	_SOC_KT2_MMU_SUBBLOCK_LLS_L0_ECC,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_L0_ECC_ERROR1_MASKr,
      LLS_L0_ECC_ERROR1r,
      _soc_katana2_mmu_sb_lls_l0_ecc_parity_info},

    { 0x00000004, 
    	_SOC_KT2_MMU_SUBBLOCK_LLS_L1_ECC,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_L1_ECC_ERROR1_MASKr,
      LLS_L1_ECC_ERROR1r,
      _soc_katana2_mmu_sb_lls_l1_ecc_parity_info},

    { 0x00000004, 
    	_SOC_KT2_MMU_SUBBLOCK_LLS_L2_ECC,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_L2_ECC_ERROR1_MASKr,
      LLS_L2_ECC_ERROR1r,
      _soc_katana2_mmu_sb_lls_l2_ecc_parity_info},

    { 0x00000004, 
    	_SOC_KT2_MMU_SUBBLOCK_LLS_MISC_ECC,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_MISC_ECC_ERROR1_MASKr,
      LLS_MISC_ECC_ERROR1r,
      _soc_katana2_mmu_sb_lls_misc_ecc_parity_info},
    
    /*  RQE Ser gives MMU parity error while accessing IPMC group
        tables. Hence, disabling parity for this */
    { 0x00000200, 
    	_SOC_KT2_MMU_SUBBLOCK_RQE_SER,
      RQE_INTR_DISINTf, 
      RQE_INTRf,
      RQE_SER_MASKr,
      RQE_SER_STATUSr,
      _soc_katana2_mmu_sb_rqe_ser_parity_info},
    
    { 0x00000200, 
    	_SOC_KT2_MMU_SUBBLOCK_RQE_EXTQ,
      RQE_INTR_DISINTf, 
      RQE_INTRf,
      RQE_EXTQ_REPLICATION_LIMITr,
      RQE_EXTQ_REPLICATION_COUNTr,
        _soc_katana2_mmu_sb_rqe_extq_parity_info},

    { 0 } /* table terminator */
};

STATIC
_soc_katana2_mmu_sub_block_two_level_t  _soc_katana2_mmu_sub_blocks_type_2[] = {
    { 0x00000100, 
    	_SOC_KT2_MMU_SUBBLOCK_EMC,
      EMC_INTR_DISINTf, 
      EMC_INTRf,
      0,
      EMC_ERRORr,
      _soc_katana2_mmu_sb_emc_parity_info},

    { 0x00000080, 
    	_SOC_KT2_MMU_SUBBLOCK_DEQ,
      DEQ_INTR_DISINTf, 
      DEQ_INTRf,
      0,
      DEQ_ERRORr,
      _soc_katana2_mmu_sb_deq_parity_info},

    { 0x00000002, 
    	_SOC_KT2_MMU_SUBBLOCK_QSTRUCT,
      QSTRUCT_INTR_DISINTf, 
      QSTRUCT_INTRf,
      QSTRUCT_INTERRUPT_MASKr,
      QSTRUCT_INTERRUPTr,
      _soc_katana2_mmu_sb_qstruct_parity_info},
      
    { 0x00000001, 
    	_SOC_KT2_MMU_SUBBLOCK_TOQ,
      TOQ_INTR_DISINTf, 
      TOQ_INTRf,
      TOQ_INTERRUPT_MASKr,
      TOQ_INTERRUPTr,
      _soc_katana2_mmu_sb_toq_parity_info},
    { 0 } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ep0_parity_info[] = {
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_NHOP_PAR_ERRf,
        EGR_NHOP_PAR_ERRf,
        EGR_L3_NEXT_HOPm, NULL,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_L3_NEXT_HOP_PARITY_ENf,
        EGR_L3_NEXT_HOP_PARITY_STATUS_INTRr, NULL,
        EGR_L3_NEXT_HOP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_L3_INTF_PAR_ERRf,
        EGR_L3_INTF_PAR_ERRf,
        EGR_L3_INTFm, NULL,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_L3_INTF_PARITY_ENf,
        EGR_L3_INTF_PARITY_STATUS_INTRr, NULL,
        EGR_L3_INTF_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PAR_ERRf,
        EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PAR_ERRf,
        EGR_MPLS_VC_AND_SWAP_LABEL_TABLEm, NULL,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PARITY_ENf,
        EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PARITY_STATUS_INTRr, NULL,
        EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_VLAN_PAR_ERRf,
        EGR_VLAN_PAR_ERRf,
        EGR_VLANm, NULL,
        EGR_VLAN_PARITY_CONTROLr, EGR_VLAN_PARITY_ENf,
        EGR_VLAN_PARITY_STATUS_INTRr, NULL,
        EGR_VLAN_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_VLAN_STG_PAR_ERRf,
        EGR_VLAN_STG_PAR_ERRf,
        EGR_VLAN_STGm, NULL,
        EGR_VLAN_PARITY_CONTROLr, EGR_VLAN_STG_PARITY_ENf,
        EGR_VLAN_STG_PARITY_STATUS_INTRr, NULL,
        EGR_VLAN_STG_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_IP_TUNNEL_PAR_ERRf,
        EGR_IP_TUNNEL_PAR_ERRf,
        EGR_IP_TUNNELm, NULL,
        EGR_VLAN_PARITY_CONTROLr, EGR_IP_TUNNEL_PARITY_ENf,
        EGR_IP_TUNNEL_PARITY_STATUS_INTRr, NULL,
        EGR_IP_TUNNEL_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        EGR_VLAN_XLATE_PAR_ERRf,
        EGR_VLAN_XLATE_PAR_ERRf,
        EGR_VLAN_XLATEm, NULL,
        EGR_VLAN_PARITY_CONTROLr, EGR_VLAN_XLATE_PARITY_ENf,
        INVALIDr, _soc_katana2_egr_vlan_xlate_intr_reg,
        INVALIDr, _soc_katana2_egr_vlan_xlate_nack_reg },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FRAGMENT_ID_TABLE_PAR_ERRf,
        EGR_FRAGMENT_ID_TABLE_PAR_ERRf,
        EGR_FRAGMENT_ID_TABLEm, NULL,
        EGR_VLAN_PARITY_CONTROLr, EGR_FRAGMENT_ID_TABLE_PARITY_ENf,
        EGR_FRAGMENT_ID_TABLE_PARITY_STATUS_INTRr, NULL,
        EGR_FRAGMENT_ID_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        EGR_INITBUF_ECC_ERRf,
        EGR_INITBUF_ECC_ERRf,
        INVALIDm, "EGR_INITBUF",
        EGR_EHCPM_ECC_PARITY_CONTROLr, INITBUF_ECC_ENf,
        EGR_INITBUF_ECC_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_PORT_PAR_ERRf,
        EGR_PORT_PAR_ERRf,
        EGR_PORTm, NULL,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_PORT_PARITY_ENf,
        EGR_PORT_PARITY_STATUS_INTRr, NULL,
        EGR_PORT_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MOD_MAP_TABLE_PAR_ERRf,
        EGR_MOD_MAP_TABLE_PAR_ERRf,
        EGR_MOD_MAP_TABLEm, NULL,
        EGR_EHCPM_ECC_PARITY_CONTROLr, MOD_MAP_PARITY_ENf,
        EGR_MOD_MAP_PARITY_STATUS_INTRr, NULL,
        EGR_MOD_MAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MAC_DA_PROFILE_PAR_ERRf,
        EGR_MAC_DA_PROFILE_PAR_ERRf,
        EGR_MAC_DA_PROFILEm, NULL,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_MAC_DA_PROFILE_PARITY_ENf,
        EGR_MAC_DA_PROFILE_PARITY_STATUS_INTRr, NULL,
        EGR_MAC_DA_PROFILE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_DVP_ATTRIBUTE_PAR_ERRf,
        EGR_DVP_ATTRIBUTE_PAR_ERRf,
        EGR_DVP_ATTRIBUTEm, NULL,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_DVP_ATTRIBUTE_PARITY_ENf,
        EGR_DVP_ATTRIBUTE_PARITY_STATUS_INTRr, NULL,
        EGR_DVP_ATTRIBUTE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_VFI_PAR_ERRf,
        EGR_VFI_PAR_ERRf,
        EGR_VFIm, NULL,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_VFI_PARITY_ENf,
        EGR_VFI_PARITY_STATUS_INTRr, NULL,
        EGR_VFI_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_IPMC_PAR_ERRf,
        EGR_IPMC_PAR_ERRf,
        EGR_IPMCm, NULL,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_IPMC_PARITY_ENf,
        EGR_IPMC_PARITY_STATUS_INTRr, NULL,
        EGR_IPMC_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MPLS_EXP_MAPPING_2_PAR_ERRf,
        EGR_MPLS_EXP_MAPPING_2_PAR_ERRf,
        EGR_MPLS_EXP_MAPPING_2m, NULL,
        EGR_VLAN_PARITY_CONTROLr, EGR_MPLS_EXP_MAPPING_2_PARITY_ENf,
        EGR_MPLS_EXP_MAPPING_2_PARITY_STATUS_INTRr, NULL,
        EGR_MPLS_EXP_MAPPING_2_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MPLS_PRI_MAPPING_PAR_ERRf,
        EGR_MPLS_PRI_MAPPING_PAR_ERRf,
        EGR_MPLS_PRI_MAPPINGm, NULL,
        EGR_VLAN_PARITY_CONTROLr, EGR_MPLS_PRI_MAPPING_PARITY_ENf,
        EGR_MPLS_PRI_MAPPING_PARITY_STATUS_INTRr, NULL,
        EGR_MPLS_PRI_MAPPING_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_PRI_CNG_MAP_PAR_ERRf,
        EGR_PRI_CNG_MAP_PAR_ERRf,
        EGR_PRI_CNG_MAPm, NULL,
        EGR_VLAN_PARITY_CONTROLr, EGR_PRI_CNG_MAP_PARITY_ENf,
        EGR_PRI_CNG_MAP_PARITY_STATUS_INTRr, NULL,
        EGR_PRI_CNG_MAP_PARITY_STATUS_NACKr, NULL },
     
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_DSCP_TABLE_PAR_ERRf,
        EGR_DSCP_TABLE_PAR_ERRf,
        EGR_DSCP_TABLEm, NULL,
        EGR_VLAN_PARITY_CONTROLr, EGR_DSCP_TABLE_PARITY_ENf,
        EGR_DSCP_TABLE_PARITY_STATUS_INTRr, NULL,
        EGR_DSCP_TABLE_PARITY_STATUS_NACKr, NULL }, 
     
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MPLS_EXP_MAPPING_1_PAR_ERRf,
        EGR_MPLS_EXP_MAPPING_1_PAR_ERRf,
        EGR_MPLS_EXP_MAPPING_1m, NULL,
        EGR_VLAN_PARITY_CONTROLr, EGR_MPLS_EXP_MAPPING_1_PARITY_ENf,
        EGR_MPLS_EXP_MAPPING_1_PARITY_STATUS_INTRr, NULL,
        EGR_MPLS_EXP_MAPPING_1_PARITY_STATUS_NACKr, NULL },
     
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        EGR_MPB_ECC_ERRf,
        EGR_MPB_ECC_ERRf,
        INVALIDm, "EGR_MPB",
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_MPB_ECC_ENf,
        EGR_MPB_ECC_STATUS_INTRr, NULL,
        INVALIDr, NULL }, 
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_GPP_ATTRIBUTES_MODBASE_PAR_ERRf,
        EGR_GPP_ATTRIBUTES_MODBASE_PAR_ERRf,
        EGR_GPP_ATTRIBUTES_MODBASEm, NULL,
        EGR_VLAN_PARITY_CONTROLr, EGR_GPP_ATTRIBUTES_MODBASE_PARITY_ENf,
        EGR_GPP_ATTRIBUTES_MODBASE_PARITY_STATUS_INTRr, NULL,
        EGR_GPP_ATTRIBUTES_MODBASE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_GPP_ATTRIBUTES_PAR_ERRf,
        EGR_GPP_ATTRIBUTES_PAR_ERRf,
        EGR_GPP_ATTRIBUTESm, NULL,
        EGR_VLAN_PARITY_CONTROLr, EGR_GPP_ATTRIBUTES_PARITY_ENf,
        EGR_GPP_ATTRIBUTES_PARITY_STATUS_INTRr, NULL,
        EGR_GPP_ATTRIBUTES_PARITY_STATUS_NACKr, NULL },
        
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_QUEUE_TO_PP_PORT_MAP_PAR_ERRf,
        EGR_QUEUE_TO_PP_PORT_MAP_PAR_ERRf,
        EGR_QUEUE_TO_PP_PORT_MAPm, NULL,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_QUEUE_TO_PP_PORT_MAP_PARITY_ENf,
        EGR_QUEUE_TO_PP_PORT_MAP_PARITY_STATUS_INTRr, NULL,
        EGR_QUEUE_TO_PP_PORT_MAP_PARITY_STATUS_NACKr, NULL },    
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_PCP_DE_MAPPING_PAR_ERRf,
        EGR_PCP_DE_MAPPING_PAR_ERRf,
        EGR_PCP_DE_MAPPINGm, NULL,
        EGR_VLAN_PARITY_CONTROLr, EGR_PCP_DE_MAPPING_PARITY_ENf,
        EGR_PCP_DE_MAPPING_PARITY_STATUS_INTRr, NULL,
        EGR_PCP_DE_MAPPING_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        EGR_MP_GROUP_PAR_ERRf,
        EGR_MP_GROUP_PAR_ERRf,
        EGR_MP_GROUPm, NULL,
        EGR_EOAM_ECC_PARITY_CONTROLr, MP_GROUP_PARITY_ENf,
        INVALIDr, _soc_katana2_egr_mp_group_intr_reg,
        INVALIDr, _soc_katana2_egr_mp_group_nack_reg },    
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MA_INDEX_PAR_ERRf,
        EGR_MA_INDEX_PAR_ERRf,
        EGR_MA_INDEXm, NULL,
        EGR_EOAM_ECC_PARITY_CONTROLr, MA_INDEX_PARITY_ENf,
        EGR_MA_INDEX_PARITY_STATUS_INTRr, NULL,
        EGR_MA_INDEX_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MAP_MH_PAR_ERRf,
        EGR_MAP_MH_PAR_ERRf,
        EGR_MAP_MHm, NULL,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_MAP_MH_PARITY_ENf,
        EGR_MAP_MH_PARITY_STATUS_INTRr, NULL,
        EGR_MAP_MH_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_OAM_LM_COUNTERS_0_PAR_ERRf,
        EGR_OAM_LM_COUNTERS_0_PAR_ERRf,
        EGR_OAM_LM_COUNTERS_0m, NULL,
        EGR_EOAM_ECC_PARITY_CONTROLr, OAM_LM_COUNTERS_0_PARITY_ENf,
        EGR_OAM_LM_COUNTERS_0_PARITY_STATUS_INTRr, NULL,
        EGR_OAM_LM_COUNTERS_0_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_OAM_LM_COUNTERS_1_PAR_ERRf,
        EGR_OAM_LM_COUNTERS_1_PAR_ERRf,
        EGR_OAM_LM_COUNTERS_1m, NULL,
        EGR_EOAM_ECC_PARITY_CONTROLr, OAM_LM_COUNTERS_1_PARITY_ENf,
        EGR_OAM_LM_COUNTERS_1_PARITY_STATUS_INTRr, NULL,
        EGR_OAM_LM_COUNTERS_1_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ep1_parity_info[] = {
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        CM_ECC_ERRf,
        CM_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_CM_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, CM_ECC_ENf,
        EGR_CM_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        LP_ECC_ERRf,
        LP_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_LP_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, LP_ECC_ENf,
        EGR_LP_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        RESI_ECC_ERRf,
        RESI_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_RESI_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, RESI_ECC_ENf,
        EGR_RESI_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_COUNTER, NULL, 0,
        EGR_STATS_COUNTER_TABLE_PAR_ERRf,
        EGR_STATS_COUNTER_TABLE_PAR_ERRf,
        INVALIDm, "TX Debug Counter",
        EGR_EDATABUF_PARITY_CONTROLr, STATS_PAR_ENf,
        EGR_STATS_COUNTER_TABLE_PARITY_STATUS_INTRr, NULL,
        EGR_STATS_COUNTER_TABLE_PARITY_STATUS_NACKr, NULL },
    

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_EFP_COUNTER_TABLE_PAR_ERRf,
        EGR_EFP_COUNTER_TABLE_PAR_ERRf,
        EFP_COUNTER_TABLEm, NULL,
        EGR_EDATABUF_PARITY_CONTROLr, EFPCTR_PAR_ENf,
        EGR_EFP_COUNTER_TABLE_PARITY_STATUS_INTRr, NULL,
        EGR_EFP_COUNTER_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_EFP_METER_TABLE_PAR_ERRf,
        EGR_EFP_METER_TABLE_PAR_ERRf,
        EFP_METER_TABLEm, NULL,
        EFP_METER_PARITY_CONTROLr, PARITY_ENf,
        EFP_METER_PARITY_STATUS_INTRr, NULL,
        EFP_METER_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_EFP_POLICY_TABLE_PAR_ERRf,
        EGR_EFP_POLICY_TABLE_PAR_ERRf,
        EFP_POLICY_TABLEm, NULL,
        EFP_POLICY_PARITY_CONTROLr, PARITY_ENf,
        EFP_POLICY_PARITY_STATUS_INTRr, NULL,
        EFP_POLICY_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_EFP_PW_INIT_COUNTERS_PAR_ERRf,
        EGR_EFP_PW_INIT_COUNTERS_PAR_ERRf,
        EGR_PW_INIT_COUNTERSm, NULL,
        EGR_PW_INIT_COUNTERS_PARITY_CONTROLr, PARITY_ENf,
        EGR_PW_INIT_COUNTERS_PARITY_STATUS_INTRr, NULL,
        EGR_PW_INIT_COUNTERS_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_0_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_0_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_0m, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_0r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_0r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_0r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_1_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_1_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_1m, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_1r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_1r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_1r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_2_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_2_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_2m, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_2r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_2r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_2r, NULL },
        
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_3_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_3_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_3m, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_3r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_3r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_3r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_0_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_0_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_0m, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_0r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_0r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_0r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_1_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_1_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_1m, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_1r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_1r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_1r, NULL },
        
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_2_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_2_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_2m, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_2r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_2r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_2r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_3_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_3_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_3m, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_3r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_3r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_3r, NULL },
        
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_4_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_4_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_4m, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_4r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_4r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_4r, NULL },    
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_5_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_5_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_5m, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_5r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_5r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_5r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_6_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_6_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_6m, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_6r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_6r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_6r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_7_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_7_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_7m, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_7r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_7r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_7r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_4_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_4_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_4m, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_4r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_4r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_4r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_5_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_5_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_5m, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_5r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_5r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_5r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_6_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_6_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_6m, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_6r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_6r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_6r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_7_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_7_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_7m, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_7r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_7r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_7r, NULL },

    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ep2_parity_info[] = {
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_1588_LNK_DELAY_PAR_ERRf,
        EGR_1588_LNK_DELAY_PAR_ERRf,
        INVALIDm, NULL,
        EGR_1588_LINK_DELAY_64_PARITY_CONTROLr, PARITY_ENf,
        EGR_1588_LINK_DELAY_64_PARITY_STATUS_INTRr, NULL,
        EGR_1588_LINK_DELAY_64_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_1588_SA_PAR_ERRf,
        EGR_1588_SA_PAR_ERRf,
        EGR_1588_SAm, NULL,
        EGR_1588_SA_PARITY_CONTROLr, PARITY_ENf,
        EGR_1588_SA_PARITY_STATUS_INTRr, NULL,
        EGR_1588_SA_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ0_ECC_ERRf,
        XQ0_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ0_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, XQ0_ECC_ENf,
        EGR_XQ0_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ1_ECC_ERRf,
        XQ1_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ1_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, XQ1_ECC_ENf,
        EGR_XQ1_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ2_ECC_ERRf,
        XQ2_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ2_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, XQ2_ECC_ENf,
        EGR_XQ2_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ3_ECC_ERRf,
        XQ3_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ3_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, XQ3_ECC_ENf,
        EGR_XQ3_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ4_ECC_ERRf,
        XQ4_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ4_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, XQ4_ECC_ENf,
        EGR_XQ4_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ5_ECC_ERRf,
        XQ5_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ5_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, XQ5_ECC_ENf,
        EGR_XQ5_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ6_ECC_ERRf,
        XQ6_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ6_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, XQ6_ECC_ENf,
        EGR_XQ6_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ7_ECC_ERRf,
        XQ7_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ7_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, XQ7_ECC_ENf,
        EGR_XQ7_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
        
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ip0_parity_info[] = {
    /* Block-IPIPE, Stage-IARB */
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IARB_LMEP1_PAR_ERRf,
        IARB_LMEP1_PAR_ERRf,
        LMEP_1m, NULL,
        LMEP_1_PARITY_CONTROLr, PARITY_ENf,
        LMEP_1_PARITY_STATUS_INTRr, NULL,
        LMEP_1_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        IARB_PIPE_X_LEARN_FIFO_ECC_ERRf,
        IARB_PIPE_X_LEARN_FIFO_ECC_ERRf,
        INVALIDm, "IARB_LEARN_FIFO_PIPE_X",
        IARB_LEARN_FIFO_ECC_CONTROLr, ECC_ENf,
        IARB_PIPE_X_LERAN_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        IARB_HDR_ERRf,
        IARB_HDR_ERRf,
        INVALIDm, "IARB_PKT_HDR",
        IARB_HDR_ECC_CONTROLr, ECC_ENf,
        IARB_HDR_ECC_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        IARB_PKT_ERRf,
        IARB_PKT_ERRf,
        INVALIDm, "IARB_PKT_BUF",
        IARB_PKT_ECC_CONTROLr, ECC_ENf,
        IARB_PKT_ECC_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        LMEP_PAR_ERRf,
        LMEP_PAR_ERRf,
        LMEPm, NULL,
        LMEP_PARITY_CONTROLr, PARITY_ENf,
        LMEP_PARITY_STATUS_INTRr, NULL,
        LMEP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SUBPORT_TAG_TO_PP_PORT_MAP_PARITY_ERRf,
        SUBPORT_TAG_TO_PP_PORT_MAP_PARITY_ERRf,
        SUBPORT_TAG_TO_PP_PORT_MAPm, NULL,
        SUBPORT_TAG_TO_PP_PORT_MAP_DATA_PARITY_CONTROLr, PARITY_ENf,
        SUBPORT_TAG_TO_PP_PORT_MAP_DATA_PARITY_STATUS_INTRr, NULL,
        SUBPORT_TAG_TO_PP_PORT_MAP_DATA_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_PHYSICAL_PORT_TABLE_PARITY_ERRf,
        ING_PHYSICAL_PORT_TABLE_PARITY_ERRf,
        ING_PHYSICAL_PORT_TABLEm, NULL,
        ING_PHYSICAL_PORT_TABLE_PARITY_CONTROLr, PARITY_ENf,
        ING_PHYSICAL_PORT_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_PHYSICAL_PORT_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        DEVICE_STREAM_ID_TO_PP_PORT_MAP_PARITY_ERRf,
        DEVICE_STREAM_ID_TO_PP_PORT_MAP_PARITY_ERRf,
        DEVICE_STREAM_ID_TO_PP_PORT_MAPm, NULL,
        DEVICE_STREAM_ID_TO_PP_PORT_MAP_PARITY_CONTROLr, PARITY_ENf,
        DEVICE_STREAM_ID_TO_PP_PORT_MAP_PARITY_STATUS_INTRr, NULL,
        DEVICE_STREAM_ID_TO_PP_PORT_MAP_PARITY_STATUS_NACKr, NULL },    
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        SOURCE_TRUNK_MAP_PARITY_ERRf,
        SOURCE_TRUNK_MAP_PARITY_ERRf,
        SOURCE_TRUNK_MAP_TABLEm, NULL,
        SRC_TRUNK_ECC_CONTROLr, ECC_ENf,
        SRC_TRUNK_ECC_STATUS_INTRr, NULL,
        SRC_TRUNK_ECC_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SOURCE_TRUNK_MAP_MODVIEW_PAR_ERRf,
        SOURCE_TRUNK_MAP_MODVIEW_PAR_ERRf,
        SOURCE_TRUNK_MAP_MODBASEm, NULL,
        SOURCE_TRUNK_MAP_MODVIEW_PARITY_CONTROLr, PARITY_ENf,
        SOURCE_TRUNK_MAP_MODVIEW_PARITY_STATUS_INTRr, NULL,
        SOURCE_TRUNK_MAP_MODVIEW_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SYSTEM_CONFIG_MODVIEW_PAR_ERRf,
        SYSTEM_CONFIG_MODVIEW_PAR_ERRf,
        SYSTEM_CONFIG_TABLE_MODBASEm, NULL,
        SYSTEM_CONFIG_MODVIEW_PARITY_CONTROLr, PARITY_ENf,
        SYSTEM_CONFIG_MODVIEW_PARITY_STATUS_INTRr, NULL,
        SYSTEM_CONFIG_MODVIEW_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SYS_CONFIG_PAR_ERRf,
        SYS_CONFIG_PAR_ERRf,
        SYSTEM_CONFIG_TABLEm, NULL,
        SYSTEM_CONFIG_PARITY_CONTROLr, PARITY_ENf,
        SYSTEM_CONFIG_PARITY_STATUS_INTRr, NULL,
        SYSTEM_CONFIG_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        PORT_TABLE_PAR_ERRf,
        PORT_TABLE_PAR_ERRf,
        PORT_TABm, NULL,
        PORT_TABLE_ECC_CONTROLr, ECC_ENf,
        PORT_TABLE_ECC_STATUS_INTRr, NULL,
        PORT_TABLE_ECC_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        PTP_LABEL_RANGE_PROFILE_TABLE_PAR_ERRf,
        PTP_LABEL_RANGE_PROFILE_TABLE_PAR_ERRf,
        PTP_LABEL_RANGE_PROFILE_TABLEm, NULL,
        PTP_LABEL_RANGE_PROFILE_TABLE_PARITY_CONTROLr, PARITY_ENf,
        PTP_LABEL_RANGE_PROFILE_TABLE_PARITY_STATUS_INTRr, NULL,
        PTP_LABEL_RANGE_PROFILE_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        LPORT_PAR_ERRf,
        LPORT_PAR_ERRf,
        LPORT_TABm, NULL,
        LPORT_ECC_CONTROLr, ECC_ENf,
        LPORT_ECC_STATUS_INTRr, NULL,
        LPORT_ECC_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        RX_PROT_GROUP_TABLE_1_DMA_PAR_ERRf,
        RX_PROT_GROUP_TABLE_1_DMA_PAR_ERRf,
        RX_PROT_GROUP_TABLE_1_DMAm, NULL,
        RX_PROT_GROUP_TABLE_1_DMA_PARITY_CONTROLr, PARITY_ENf,
        RX_PROT_GROUP_TABLE_1_DMA_PARITY_STATUS_INTRr, NULL,
        RX_PROT_GROUP_TABLE_1_DMA_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        L3_TUNNEL_PAR_ERRf,
        L3_TUNNEL_PAR_ERRf,
        L3_TUNNELm, NULL,
        L3_TUNNEL_PARITY_CONTROLr, PARITY_ENf,
        L3_TUNNEL_PARITY_STATUS_INTRr, NULL,
        L3_TUNNEL_PARITY_STATUS_NACKr, NULL },
     
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        FP_UDF_PAR_ERRf,
        FP_UDF_PAR_ERRf,
        FP_UDF_OFFSETm, NULL,
        FP_UDF_PARITY_CONTROLr, PARITY_ENf,
        FP_UDF_PARITY_STATUS_INTRr, NULL,
        FP_UDF_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MOD_MAP_PAR_ERRf,
        MOD_MAP_PAR_ERRf,
        ING_MOD_MAP_TABLEm, NULL,
        MOD_MAP_PARITY_CONTROLr, PARITY_ENf,
        MOD_MAP_PARITY_STATUS_INTRr, NULL,
        MOD_MAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_RANGE_PAR_ERRf,
        VLAN_RANGE_PAR_ERRf,
        ING_VLAN_RANGEm, NULL,
        VLAN_RANGE_PARITY_CONTROLr, PARITY_ENf,
        VLAN_RANGE_PARITY_STATUS_INTRr, NULL,
        VLAN_RANGE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        CPU_TS_POLICY_PAR_ERRf,
        CPU_TS_POLICY_PAR_ERRf,
        CPU_TS_MAPm, NULL,
        CPU_TS_PARITY_CONTROLr, PARITY_ENf,
        CPU_TS_PARITY_STATUS_INTRr, NULL,
        CPU_TS_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ip1_parity_info[] = {
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SOURCE_VP_PAR_ERRf,
        SOURCE_VP_PAR_ERRf,
        SOURCE_VPm, NULL,
        SOURCE_VP_PARITY_CONTROLr, PARITY_ENf,
        SOURCE_VP_PARITY_STATUS_INTRr, NULL,
        SOURCE_VP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VFI_1_PAR_ERRf,
        VFI_1_PAR_ERRf,
        VFI_1m, NULL,
        VFI_1_PARITY_CONTROLr, PARITY_ENf,
        VFI_1_PARITY_STATUS_INTRr, NULL,
        VFI_1_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        L3_IIF_PAR_ERRf,
        L3_IIF_PAR_ERRf,
        L3_IIFm, NULL,
        L3_IIF_PARITY_CONTROLr, PARITY_ENf,
        L3_IIF_PARITY_STATUS_INTRr, NULL,
        L3_IIF_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VFI_PAR_ERRf,
        VFI_PAR_ERRf,
        VFIm, NULL,
        VFI_PARITY_CONTROLr, PARITY_ENf,
        VFI_PARITY_STATUS_INTRr, NULL,
        VFI_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VRF_PAR_ERRf,
        VRF_PAR_ERRf,
        VRFm, NULL,
        VRF_PARITY_CONTROLr, PARITY_ENf,
        VRF_PARITY_STATUS_INTRr, NULL,
        VRF_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_MPLS_PAR_ERRf,
        VLAN_MPLS_PAR_ERRf,
        VLAN_MPLSm, NULL,
        VLAN_MPLS_PARITY_CONTROLr, PARITY_ENf,
        VLAN_MPLS_PARITY_STATUS_INTRr, NULL,
        VLAN_MPLS_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_PAR_ERRf,
        VLAN_PAR_ERRf,
        VLAN_TABm, NULL,
        VLAN_PARITY_CONTROLr, PARITY_ENf,
        VLAN_PARITY_STATUS_INTRr, NULL,
        VLAN_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_STG_PAR_ERRf,
        VLAN_STG_PAR_ERRf,
        STG_TABm, NULL,
        VLAN_STG_PARITY_CONTROLr, PARITY_ENf,
        VLAN_STG_PARITY_STATUS_INTRr, NULL,
        VLAN_STG_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        L3_ENTRY_PAR_ERRf,
        L3_ENTRY_PAR_ERRf,
        L3_ENTRY_ONLYm, NULL,
        L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
        INVALIDr, _soc_katana2_l3_entry_only_intr_reg,
        INVALIDr, _soc_katana2_l3_entry_only_nack_reg },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        L3_DEFIP_PAR_ERRf,
        L3_DEFIP_PAR_ERRf,
        L3_DEFIP_DATA_ONLYm, NULL,
        L3_DEFIP_DATA_PARITY_CONTROLr, PARITY_ENf,
        L3_DEFIP_DATA_PARITY_STATUS_INTRr, NULL,
        L3_DEFIP_DATA_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        RTAG7_FLOW_BASED_HASH_PAR_ERRf,
        RTAG7_FLOW_BASED_HASH_PAR_ERRf,
        RTAG7_FLOW_BASED_HASHm, NULL,
        RTAG7_FLOW_BASED_HASH_PARITY_CONTROLr, PARITY_ENf,
        RTAG7_FLOW_BASED_HASH_PARITY_STATUS_INTRr, NULL,
        RTAG7_FLOW_BASED_HASH_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        FP_FIELD_SEL_PAR_ERRf,
        FP_FIELD_SEL_PAR_ERRf,
        FP_PORT_FIELD_SELm, NULL,
        FP_FIELD_SEL_PARITY_CONTROLr, PARITY_ENf,
        FP_FIELD_SEL_PARITY_STATUS_INTRr, NULL,
        FP_FIELD_SEL_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TTL_FN_PAR_ERRf,
        TTL_FN_PAR_ERRf,
        TTL_FNm, NULL,
        TTL_FN_PARITY_CONTROLr, PARITY_ENf,
        TTL_FN_PARITY_STATUS_INTRr, NULL,
        TTL_FN_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TOS_FN_PAR_ERRf,
        TOS_FN_PAR_ERRf,
        TOS_FNm, NULL,
        TOS_FN_PARITY_CONTROLr, PARITY_ENf,
        TOS_FN_PARITY_STATUS_INTRr, NULL,
        TOS_FN_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_PRI_CNG_MAP_PAR_ERRf,
        ING_PRI_CNG_MAP_PAR_ERRf,
        ING_PRI_CNG_MAPm, NULL,
        ING_PRI_CNG_MAP_PARITY_CONTROLr, PARITY_ENf,
        ING_PRI_CNG_MAP_PARITY_STATUS_INTRr, NULL,
        ING_PRI_CNG_MAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_UNTAGGED_PHB_PAR_ERRf,
        ING_UNTAGGED_PHB_PAR_ERRf,
        ING_UNTAGGED_PHBm, NULL,
        ING_UNTAGGED_PHB_PARITY_CONTROLr, PARITY_ENf,
        ING_UNTAGGED_PHB_PARITY_STATUS_INTRr, NULL,
        ING_UNTAGGED_PHB_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        DSCP_TABLE_PAR_ERRf,
        DSCP_TABLE_PAR_ERRf,
        DSCP_TABLEm, NULL,
        DSCP_TABLE_PARITY_CONTROLr, PARITY_ENf,
        DSCP_TABLE_PARITY_STATUS_INTRr, NULL,
        DSCP_TABLE_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        L2_ENTRY_PAR_ERRf,
        L2_ENTRY_PAR_ERRf,
        L2Xm, NULL,
        L2_ENTRY_PARITY_CONTROLr, PARITY_ENf,
        INVALIDr, _soc_katana2_l2_entry_only_intr_reg,
        INVALIDr, _soc_katana2_l2_entry_only_nack_reg },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        NHOP_PAR_ERRf,
        NHOP_PAR_ERRf,
        INITIAL_ING_L3_NEXT_HOPm, NULL,
        INITIAL_ING_L3_NEXT_HOP_PARITY_CONTROLr, PARITY_ENf,
        INITIAL_ING_L3_NEXT_HOP_PARITY_STATUS_INTRr, NULL,
        INITIAL_ING_L3_NEXT_HOP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ECMP_GRP_PAR_ERRf,
        ECMP_GRP_PAR_ERRf,
        INITIAL_L3_ECMP_GROUPm, NULL,
        INITIAL_L3_ECMP_GROUP_PARITY_CONTROLr, PARITY_ENf,
        INITIAL_L3_ECMP_GROUP_PARITY_STATUS_INTRr, NULL,
        INITIAL_L3_ECMP_GROUP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        L3_ECMP_PAR_ERRf,
        L3_ECMP_PAR_ERRf,
        INITIAL_L3_ECMPm, NULL,
        INITIAL_L3_ECMP_PARITY_CONTROLr, PARITY_ENf,
        INITIAL_L3_ECMP_PARITY_STATUS_INTRr, NULL,
        INITIAL_L3_ECMP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_DVP_PAR_ERRf,
        ING_DVP_PAR_ERRf,
        ING_DVP_TABLEm, NULL,
        ING_DVP_TABLE_PARITY_CONTROLr, PARITY_ENf,
        ING_DVP_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_DVP_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        PROT_NHI_PAR_ERRf,
        PROT_NHI_PAR_ERRf,
        INITIAL_PROT_NHI_TABLEm, NULL,
        INITIAL_PROT_NHI_TABLE_PARITY_CONTROLr, PARITY_ENf,
        INITIAL_PROT_NHI_TABLE_PARITY_STATUS_INTRr, NULL,
        INITIAL_PROT_NHI_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        PORT_CBL_PAR_ERRf,
        PORT_CBL_PAR_ERRf,
        PORT_CBL_TABLEm, NULL,
        PORT_CBL_TABLE_PARITY_CONTROLr, PARITY_ENf,
        PORT_CBL_TABLE_PARITY_STATUS_INTRr, NULL,
        PORT_CBL_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        PORT_CBL_MODBASE_PAR_ERRf,
        PORT_CBL_MODBASE_PAR_ERRf,
        PORT_CBL_TABLE_MODBASEm, NULL,
        PORT_CBL_TABLE_MODBASE_PARITY_CONTROLr, PARITY_ENf,
        PORT_CBL_TABLE_MODBASE_PARITY_STATUS_INTRr, NULL,
        PORT_CBL_TABLE_MODBASE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        L3_IPMC_1_PAR_ERRf,
        L3_IPMC_1_PAR_ERRf,
        L3_IPMC_1m, NULL,
        L3_IPMC_1_PARITY_CONTROLr, PARITY_ENf,
        L3_IPMC_1_PARITY_STATUS_INTRr, NULL,
        L3_IPMC_1_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MA_INDEX_PAR_ERRf,
        MA_INDEX_PAR_ERRf,
        MA_INDEXm, NULL,
        MA_INDEX_PARITY_CONTROLr, PARITY_ENf,
        MA_INDEX_PARITY_STATUS_INTRr, NULL,
        MA_INDEX_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        RMEP_PAR_ERRf,
        RMEP_PAR_ERRf,
        RMEPm, NULL,
        RMEP_PARITY_CONTROLr, PARITY_ENf,
        RMEP_PARITY_STATUS_INTRr, NULL,
        RMEP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MAID_REDUCTION_PAR_ERRf,
        MAID_REDUCTION_PAR_ERRf,
        MAID_REDUCTIONm, NULL,
        MAID_REDUCTION_PARITY_CONTROLr, PARITY_ENf,
        MAID_REDUCTION_PARITY_STATUS_INTRr, NULL,
        MAID_REDUCTION_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MA_STATE_PAR_ERRf,
        MA_STATE_PAR_ERRf,
        MA_STATEm, NULL,
        MA_STATE_PARITY_CONTROLr, PARITY_ENf,
        MA_STATE_PARITY_STATUS_INTRr, NULL,
        MA_STATE_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_OR_VFI_MAC_COUNT_PAR_ERRf,
        VLAN_OR_VFI_MAC_COUNT_PAR_ERRf,
        VLAN_OR_VFI_MAC_COUNTm, NULL,
        VLAN_OR_VFI_MAC_COUNT_PARITY_CONTROLr, PARITY_ENf,
        VLAN_OR_VFI_MAC_COUNT_PARITY_STATUS_INTRr, NULL,
        VLAN_OR_VFI_MAC_COUNT_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_OR_VFI_MAC_LIMIT_PAR_ERRf,
        VLAN_OR_VFI_MAC_LIMIT_PAR_ERRf,
        VLAN_OR_VFI_MAC_LIMITm, NULL,
        VLAN_OR_VFI_MAC_LIMIT_PARITY_CONTROLr, PARITY_ENf,
        VLAN_OR_VFI_MAC_LIMIT_PARITY_STATUS_INTRr, NULL,
        VLAN_OR_VFI_MAC_LIMIT_PARITY_STATUS_NACKr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ip1_1_parity_info[] = {
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        RTAG7_PORT_BASED_HASH_PAR_ERRf,
        RTAG7_PORT_BASED_HASH_PAR_ERRf,
        RTAG7_PORT_BASED_HASHm, NULL,
        RTAG7_PORT_BASED_HASH_PARITY_CONTROLr, PARITY_ENf,
        RTAG7_PORT_BASED_HASH_PARITY_STATUS_INTRr, NULL,
        RTAG7_PORT_BASED_HASH_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        RX_PROT_GROUP_TABLE_DMA_PAR_ERRf,
        RX_PROT_GROUP_TABLE_DMA_PAR_ERRf,
        RX_PROT_GROUP_TABLE_DMAm, NULL,
        RX_PROT_GROUP_TABLE_DMA_PARITY_CONTROLr, PARITY_ENf,
        RX_PROT_GROUP_TABLE_DMA_PARITY_STATUS_INTRr, NULL,
        RX_PROT_GROUP_TABLE_DMA_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        MPLS_ENTRY_PAR_ERRf,
        MPLS_ENTRY_PAR_ERRf,
        MPLS_ENTRYm, NULL,
        MPLS_ENTRY_PARITY_CONTROLr, PARITY_ENf,
        INVALIDr, _soc_katana2_mpls_entry_intr_reg,
        INVALIDr, _soc_katana2_mpls_entry_nack_reg },    
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_SUBNET_DATA_ONLY_PAR_ERRf,
        VLAN_SUBNET_DATA_ONLY_PAR_ERRf,
        VLAN_SUBNET_DATA_ONLYm, NULL,
        VLAN_SUBNET_PARITY_CONTROLr, PARITY_ENf,
        VLAN_SUBNET_PARITY_STATUS_INTRr, NULL,
        VLAN_SUBNET_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_PROTOCOL_DATA_PAR_ERRf,
        VLAN_PROTOCOL_DATA_PAR_ERRf,
        VLAN_PROTOCOL_DATAm, NULL,
        VLAN_PROT_PARITY_CONTROLr, PARITY_ENf,
        VLAN_PROT_PARITY_STATUS_INTRr, NULL,
        VLAN_PROT_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VFP_POLICY_PAR_ERRf,
        VFP_POLICY_PAR_ERRf,
        VFP_POLICY_TABLEm, NULL,
        VFP_POLICY_PARITY_CONTROLr, PARITY_ENf,
        VFP_POLICY_PARITY_STATUS_INTRr, NULL,
        VFP_POLICY_PARITY_STATUS_NACKr, NULL }, 
    
    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        VLAN_XLATE_PAR_ERRf, 
        VLAN_XLATE_PAR_ERRf,
        VLAN_XLATEm, NULL,
        VLAN_XLATE_PARITY_CONTROLr, PARITY_ENf,
        INVALIDr, _soc_katana2_vlan_xlate_intr_reg,
        INVALIDr, _soc_katana2_vlan_xlate_nack_reg },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        INITIAL_PROT_NHI_TABLE_1_DMA_PAR_ERRf,
        INITIAL_PROT_NHI_TABLE_1_DMA_PAR_ERRf,
        INITIAL_PROT_NHI_TABLE_1_DMAm, NULL,
        INITIAL_PROT_NHI_TABLE_1_DMA_PARITY_CONTROLr, PARITY_ENf,
        INITIAL_PROT_NHI_TABLE_1_DMA_PARITY_STATUS_INTRr, NULL,
        INITIAL_PROT_NHI_TABLE_1_DMA_PARITY_STATUS_NACKr, NULL },
        
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        L2_MOD_FIFO_INTRf,
        L2_MOD_FIFO_INTRf,
        L2_MOD_FIFOm, NULL,
        L2_MOD_FIFO_PARITY_CONTROLr, PARITY_ENf,
        L2_MOD_FIFO_PARITY_STATUS_INTRr, NULL,
        L2_MOD_FIFO_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MY_STATION_TCAM_DATA_ONLY_PAR_ERRf,
        MY_STATION_TCAM_DATA_ONLY_PAR_ERRf,
        MY_STATION_TCAM_DATA_ONLYm, NULL,
        MY_STATION_DATA_PARITY_CONTROLr, PARITY_ENf,
        MY_STATION_TCAM_DATA_ONLY_PARITY_STATUS_INTRr, NULL,
        MY_STATION_TCAM_DATA_ONLY_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ip2_parity_info[] = {
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IFP_METER_PARITY_ERRORf,
        IFP_METER_PARITY_ERRORf,
        FP_METER_TABLEm, NULL,
        IFP_METER_PARITY_CONTROLr, PARITY_ENf,
        IFP_METER_PARITY_STATUS_INTRr, NULL,
        IFP_METER_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IFP_COUNTER_PARITY_ERRORf,
        IFP_COUNTER_PARITY_ERRORf,
        FP_COUNTER_TABLEm, NULL,
        IFP_COUNTER_PARITY_CONTROLr, PARITY_ENf,
        IFP_COUNTER_PARITY_STATUS_INTRr, NULL,
        IFP_COUNTER_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IFP_POLICY_PARITY_ERRORf,
        IFP_POLICY_PARITY_ERRORf,
        FP_POLICY_TABLEm, NULL,
        IFP_POLICY_PARITY_CONTROLr, PARITY_ENf,
        IFP_POLICY_PARITY_STATUS_INTRr, NULL,
        IFP_POLICY_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IFP_STORM_CONTROL_PARITY_ERRORf,
        IFP_STORM_CONTROL_PARITY_ERRORf,
        FP_STORM_CONTROL_METERSm, NULL,
        IFP_STORM_CONTROL_PARITY_CONTROLr, PARITY_ENf,
        IFP_STORM_CONTROL_PARITY_STATUS_INTRr, NULL,
        IFP_STORM_CONTROL_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SVC_MACROFLOW_TABLE_PARITY_ERRORf,
        SVC_MACROFLOW_TABLE_PARITY_ERRORf,
        SVM_MACROFLOW_INDEX_TABLEm, "SVM MACROFLOW",
        ING_SVM_MACROFLOW_INDEX_TABLE_CONTROLr, PARITY_ENf,
        ING_SVM_MACROFLOW_INDEX_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_SVM_MACROFLOW_INDEX_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SVC_OFFSET_TABLE_PARITY_ERRORf,
        SVC_OFFSET_TABLE_PARITY_ERRORf,
        SVM_OFFSET_TABLEm, "SVM OFFSET",
        ING_SVM_OFFSET_TABLE_CONTROLr, PARITY_ENf,
        ING_SVM_OFFSET_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_SVM_OFFSET_TABLE_PARITY_STATUS_NACKr, NULL },
        
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SVC_METER_TABLE_PARITY_ERRORf,
        SVC_METER_TABLE_PARITY_ERRORf,
        SVM_METER_TABLEm, "SVM METER",
        ING_SVM_METER_TABLE_CONTROLr, PARITY_ENf,
        ING_SVM_METER_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_SVM_METER_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SVC_POLICY_TABLE_PARITY_ERRORf,
        SVC_POLICY_TABLE_PARITY_ERRORf,
        SVM_POLICY_TABLEm, "SVM POLICY",
        ING_SVM_POLICY_TABLE_CONTROLr, PARITY_ENf,
        ING_SVM_POLICY_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_SVM_POLICY_TABLE_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ip3_parity_info[] = {
    
	{ _SOC_PARITY_TYPE_PARITY, NULL, 0,
        DLB_HGT_FLOWSET_PORT_PAR_ERRf,
        DLB_HGT_FLOWSET_PORT_PAR_ERRf,
        INVALIDm, NULL,
        DLB_HGT_FLOWSET_PORT_PARITY_CONTROLr, PARITY_ENf,
        DLB_HGT_FLOWSET_PORT_PARITY_STATUS_INTRr, NULL,
        DLB_HGT_FLOWSET_PORT_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        DLB_HGT_FLOWSET_TIMESTAMP_PAR_ERRf,
        DLB_HGT_FLOWSET_TIMESTAMP_PAR_ERRf,
        INVALIDm, NULL,
        DLB_HGT_FLOWSET_TIMESTAMP_PARITY_CONTROLr, PARITY_ENf,
        DLB_HGT_FLOWSET_TIMESTAMP_PARITY_STATUS_INTRr, NULL,
        DLB_HGT_FLOWSET_TIMESTAMP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PAR_ERRf,
        DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PAR_ERRf,
        INVALIDm, NULL,
        DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PARITY_CONTROLr, PARITY_ENf,
        DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PARITY_STATUS_INTRr, NULL,
        DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_ING_L3_NEXT_HOP_PAR_ERRf,
        IRSEL2_ING_L3_NEXT_HOP_PAR_ERRf,
        ING_L3_NEXT_HOPm, NULL,
        ING_L3_NEXT_HOP_PARITY_CONTROLr, PARITY_ENf,
        ING_L3_NEXT_HOP_PARITY_STATUS_INTRr, NULL,
        ING_L3_NEXT_HOP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_L3_IPMC_REMAP_PAR_ERRf,
        IRSEL2_L3_IPMC_REMAP_PAR_ERRf,
        L3_IPMC_REMAPm, NULL,
        L3_IPMC_REMAP_PARITY_CONTROLr, PARITY_ENf,
        L3_IPMC_REMAP_PARITY_STATUS_INTRr, NULL,
        L3_IPMC_REMAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_L3_IPMC_PAR_ERRf,
        IRSEL2_L3_IPMC_PAR_ERRf,
        L3_IPMCm, NULL,
        L3_IPMC_PARITY_CONTROLr, PARITY_ENf,
        L3_IPMC_PARITY_STATUS_INTRr, NULL,
        L3_IPMC_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_L2MC_PAR_ERRf,
        IRSEL2_L2MC_PAR_ERRf,
        L2MCm, NULL,
        L2MC_PARITY_CONTROLr, PARITY_ENf,
        L2MC_PARITY_STATUS_INTRr, NULL,
        L2MC_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_IFP_REDIRECTION_PROFILE_PAR_ERRf,
        IRSEL2_IFP_REDIRECTION_PROFILE_PAR_ERRf,
        IFP_REDIRECTION_PROFILEm, NULL,
        IFP_REDIRECTION_PROFILE_PARITY_CONTROLr, PARITY_ENf,
        IFP_REDIRECTION_PROFILE_PARITY_STATUS_INTRr, NULL,
        IFP_REDIRECTION_PROFILE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_L3_ECMP_GROUP_PAR_ERRf,
        IRSEL2_L3_ECMP_GROUP_PAR_ERRf,
        L3_ECMP_COUNTm, NULL,
        L3_ECMP_GROUP_PARITY_CONTROLr, PARITY_ENf,
        L3_ECMP_GROUP_PARITY_STATUS_INTRr, NULL,
        L3_ECMP_GROUP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_L3_ECMP_PAR_ERRf,
        IRSEL2_L3_ECMP_PAR_ERRf,
        L3_ECMPm, NULL,
        L3_ECMP_PARITY_CONTROLr, PARITY_ENf,
        L3_ECMP_PARITY_STATUS_INTRr, NULL,
        L3_ECMP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_EGR_MASK_MODBASE_PAR_ERRf,
        IRSEL2_EGR_MASK_MODBASE_PAR_ERRf,
        EGR_MASK_MODBASEm, NULL,
        EGR_MASK_MODBASE_PARITY_CONTROLr, PARITY_ENf,
        EGR_MASK_MODBASE_PARITY_STATUS_INTRr, NULL,
        EGR_MASK_MODBASE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ICONTROL_OPCODE_BITMAP_PAR_ERRf,
        ICONTROL_OPCODE_BITMAP_PAR_ERRf,
        ICONTROL_OPCODE_BITMAPm, NULL,
        ICONTROL_OPCODE_BITMAP_PARITY_CONTROLr, PARITY_ENf,
        ICONTROL_OPCODE_BITMAP_PARITY_STATUS_INTRr, NULL,
        ICONTROL_OPCODE_BITMAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_0_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_0_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_0m, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_0r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_0r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_0r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_1_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_1_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_1m, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_1r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_1r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_1r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_2_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_2_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_2m, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_2r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_2r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_2r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_3_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_3_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_3m, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_3r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_3r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_3r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_4_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_4_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_4m, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_4r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_4r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_4r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_5_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_5_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_5m, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_5r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_5r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_5r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_6_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_6_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_6m, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_6r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_6r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_6r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_7_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_7_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_7m, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_7r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_7r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_7r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_0_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_0_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_0m, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_0r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_0r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_0r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_1_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_1_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_1m, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_1r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_1r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_1r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_2_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_2_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_2m, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_2r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_2r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_2r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_3_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_3_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_3m, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_3r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_3r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_3r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_4_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_4_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_4m, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_4r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_4r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_4r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_5_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_5_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_5m, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_5r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_5r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_5r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_6_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_6_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_6m, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_6r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_6r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_6r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_7_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_7_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_7m, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_7r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_7r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_7r, NULL },
     
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SFLOW_ING_THRESHOLD_PAR_ERRf,
        SFLOW_ING_THRESHOLD_PAR_ERRf,
        INVALIDm, NULL,
        SFLOW_ING_THRESHOLD_PARITY_CONTROLr, PARITY_ENf,
        SFLOW_ING_THRESHOLD_PARITY_STATUS_INTRr, NULL,
        SFLOW_ING_THRESHOLD_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ip3_1_parity_info[] = {
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MASK_PAR_ERRf,
        EGR_MASK_PAR_ERRf,
        EGR_MASKm, NULL,
        EGR_MASK_PARITY_CONTROLr, PARITY_ENf,
        EGR_MASK_PARITY_STATUS_INTRr, NULL,
        EGR_MASK_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TRUNK_BITMAP_PAR_ERRf,
        TRUNK_BITMAP_PAR_ERRf,
        TRUNK_BITMAPm, NULL,
        TRUNK_BITMAP_TABLE_PARITY_CONTROLr, PARITY_ENf,
        TRUNK_BITMAP_TABLE_PARITY_STATUS_INTRr, NULL,
        TRUNK_BITMAP_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        NONUCAST_TRUNK_BLOCK_MASK_PAR_ERRf,
        NONUCAST_TRUNK_BLOCK_MASK_PAR_ERRf,
        NONUCAST_TRUNK_BLOCK_MASKm, NULL,
        NONUCAST_TRUNK_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf,
        NONUCAST_TRUNK_BLOCK_MASK_PARITY_STATUS_INTRr, NULL,
        NONUCAST_TRUNK_BLOCK_MASK_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MAC_BLOCK_TABLE_PAR_ERRf,
        MAC_BLOCK_TABLE_PAR_ERRf,
        MAC_BLOCKm, NULL,
        MAC_BLOCK_TABLE_PARITY_CONTROLr, PARITY_ENf,
        MAC_BLOCK_TABLE_PARITY_STATUS_INTRr, NULL,
        MAC_BLOCK_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MODPORT_MAP_SW_PAR_ERRf,
        MODPORT_MAP_SW_PAR_ERRf,
        MODPORT_MAP_SWm, NULL,
        MODPORT_MAP_SW_PARITY_CONTROLr, PARITY_ENf,
        MODPORT_MAP_SW_PARITY_STATUS_INTRr, NULL,
        MODPORT_MAP_SW_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MODPORT_MAP_M0_PAR_ERRf,
        MODPORT_MAP_M0_PAR_ERRf,
        MODPORT_MAP_M0m, NULL,
        MODPORT_MAP_MIRROR_PARITY_CONTROLr, PARITY_ENf,
        MODPORT_MAP_M0_PARITY_STATUS_INTRr, NULL,
        MODPORT_MAP_M0_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MODPORT_MAP_M1_PAR_ERRf,
        MODPORT_MAP_M1_PAR_ERRf,
        MODPORT_MAP_M1m, NULL,
        MODPORT_MAP_MIRROR_PARITY_CONTROLr, PARITY_ENf,
        MODPORT_MAP_M1_PARITY_STATUS_INTRr, NULL,
        MODPORT_MAP_M1_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MODPORT_MAP_M2_PAR_ERRf,
        MODPORT_MAP_M2_PAR_ERRf,
        MODPORT_MAP_M2m, NULL,
        MODPORT_MAP_MIRROR_PARITY_CONTROLr, PARITY_ENf,
        MODPORT_MAP_M2_PARITY_STATUS_INTRr, NULL,
        MODPORT_MAP_M2_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MODPORT_MAP_M3_PAR_ERRf,
        MODPORT_MAP_M3_PAR_ERRf,
        MODPORT_MAP_M3m, NULL,
        MODPORT_MAP_MIRROR_PARITY_CONTROLr, PARITY_ENf,
        MODPORT_MAP_M3_PARITY_STATUS_INTRr, NULL,
        MODPORT_MAP_M3_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SRC_MODID_INGRESS_BLOCK_PAR_ERRf,
        SRC_MODID_INGRESS_BLOCK_PAR_ERRf,
        SRC_MODID_INGRESS_BLOCKm, NULL,
        SRC_MODID_INGRESS_BLOCK_PARITY_CONTROLr, PARITY_ENf,
        SRC_MODID_INGRESS_BLOCK_PARITY_STATUS_INTRr, NULL,
        SRC_MODID_INGRESS_BLOCK_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SRC_MODID_EGRESS_PAR_ERRf,
        SRC_MODID_EGRESS_PAR_ERRf,
        SRC_MODID_EGRESSm, NULL,
        SRC_MODID_EGRESS_PARITY_CONTROLr, PARITY_ENf,
        SRC_MODID_EGRESS_PARITY_STATUS_INTRr, NULL,
        SRC_MODID_EGRESS_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ALTERNATE_EMIRROR_BITMAP_PAR_ERRf,
        ALTERNATE_EMIRROR_BITMAP_PAR_ERRf,
        ALTERNATE_EMIRROR_BITMAPm, NULL,
        ALTERNATE_EMIRROR_BITMAP_PARITY_CONTROLr, PARITY_ENf,
        ALTERNATE_EMIRROR_BITMAP_PARITY_STATUS_INTRr, NULL,
        ALTERNATE_EMIRROR_BITMAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        PORT_LAG_FAILOVER_SET_PAR_ERRf,
        PORT_LAG_FAILOVER_SET_PAR_ERRf,
        PORT_LAG_FAILOVER_SETm, NULL,
        PORT_LAG_FAILOVER_SET_PARITY_CONTROLr, PARITY_ENf,
        PORT_LAG_FAILOVER_SET_PARITY_STATUS_INTRr, NULL,
        PORT_LAG_FAILOVER_SET_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_PROFILE_2_PAR_ERRf,
        VLAN_PROFILE_2_PAR_ERRf,
        VLAN_PROFILE_2m, NULL,
        VLAN_PROFILE_2_PARITY_CONTROLr, PARITY_ENf,
        VLAN_PROFILE_2_PARITY_STATUS_INTRr, NULL,
        VLAN_PROFILE_2_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        L3_MTU_VALUES_PAR_ERRf,
        L3_MTU_VALUES_PAR_ERRf,
        L3_MTU_VALUESm, NULL,
        L3_MTU_VALUES_PARITY_CONTROLr, PARITY_ENf,
        L3_MTU_VALUES_PARITY_STATUS_INTRr, NULL,
        L3_MTU_VALUES_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_PW_TERM_SEQ_NUM_PAR_ERRf,
        ING_PW_TERM_SEQ_NUM_PAR_ERRf,
        ING_PW_TERM_SEQ_NUMm, NULL,
        ING_PW_TERM_SEQ_NUM_PARITY_CONTROLr, PARITY_ENf,
        ING_PW_TERM_SEQ_NUM_PARITY_STATUS_INTRr, NULL,
        ING_PW_TERM_SEQ_NUM_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_PKT_RES_MAP_PAR_ERRf,
        ING_FLEX_CTR_PKT_RES_MAP_PAR_ERRf,
        ING_FLEX_CTR_PKT_RES_MAPm, NULL,
        ING_FLEX_CTR_PKT_RES_MAP_PARITY_CONTROLr, PARITY_ENf,
        ING_FLEX_CTR_PKT_RES_MAP_PARITY_STATUS_INTRr, NULL,
        ING_FLEX_CTR_PKT_RES_MAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_L3_IPMC_2_PAR_ERRf,
        IRSEL2_L3_IPMC_2_PAR_ERRf,
        L3_IPMC_2m, NULL,
        L3_IPMC_2_PARITY_CONTROLr, PARITY_ENf,
        L3_IPMC_2_PARITY_STATUS_INTRr, NULL,
        L3_IPMC_2_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SERVICE_COS_MAP_PAR_ERRf,
        SERVICE_COS_MAP_PAR_ERRf,
        SERVICE_COS_MAPm, NULL,
        SERVICE_COS_MAP_PARITY_CONTROLr, PARITY_ENf,
        SERVICE_COS_MAP_PARITY_STATUS_INTRr, NULL,
        SERVICE_COS_MAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        E2E_HOL_STATUS_PAR_ERRf,
        E2E_HOL_STATUS_PAR_ERRf,
        E2E_HOL_STATUSm, NULL,
        E2E_HOL_STATUS_PARITY_CONTROLr, PARITY_ENf,
        E2E_HOL_STATUS_PARITY_STATUS_INTRr, NULL,
        E2E_HOL_STATUS_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        E2E_HOL_STATUS_1_PAR_ERRf,
        E2E_HOL_STATUS_1_PAR_ERRf,
        E2E_HOL_STATUS_1m, NULL,
        E2E_HOL_STATUS_1_PARITY_CONTROLr, PARITY_ENf,
        E2E_HOL_STATUS_1_PARITY_STATUS_INTRr, NULL,
        E2E_HOL_STATUS_1_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        UNKNOWN_UCAST_BLOCK_MASK_PAR_ERRf,
        UNKNOWN_UCAST_BLOCK_MASK_PAR_ERRf,
        UNKNOWN_UCAST_BLOCK_MASKm, NULL,
        UNKNOWN_UCAST_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf,
        UNKNOWN_UCAST_BLOCK_MASK_PARITY_STATUS_INTRr, NULL,
        UNKNOWN_UCAST_BLOCK_MASK_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        UNKNOWN_MCAST_BLOCK_MASK_PAR_ERRf,
        UNKNOWN_MCAST_BLOCK_MASK_PAR_ERRf,
        UNKNOWN_MCAST_BLOCK_MASKm, NULL,
        UNKNOWN_MCAST_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf,
        UNKNOWN_MCAST_BLOCK_MASK_PARITY_STATUS_INTRr, NULL,
        UNKNOWN_MCAST_BLOCK_MASK_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        BCAST_BLOCK_MASK_PAR_ERRf,
        BCAST_BLOCK_MASK_PAR_ERRf,
        BCAST_BLOCK_MASKm, NULL,
        BCAST_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf,
        BCAST_BLOCK_MASK_PARITY_STATUS_INTRr, NULL,
        BCAST_BLOCK_MASK_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        KNOWN_MCAST_BLOCK_MASK_PAR_ERRf,
        KNOWN_MCAST_BLOCK_MASK_PAR_ERRf,
        KNOWN_MCAST_BLOCK_MASKm, NULL,
        KNOWN_MCAST_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf,
        KNOWN_MCAST_BLOCK_MASK_PARITY_STATUS_INTRr, NULL,
        KNOWN_MCAST_BLOCK_MASK_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_EGRMSKBMAP_PAR_ERRf,
        ING_EGRMSKBMAP_PAR_ERRf,
        ING_EGRMSKBMAPm, NULL,
        ING_EGRMSKBMAP_PARITY_CONTROLr, PARITY_ENf,
        ING_EGRMSKBMAP_PARITY_STATUS_INTRr, NULL,
        ING_EGRMSKBMAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        LOCAL_SW_DISABLE_DEFAULT_PBM_PAR_ERRf,
        LOCAL_SW_DISABLE_DEFAULT_PBM_PAR_ERRf,
        LOCAL_SW_DISABLE_DEFAULT_PBMm, NULL,
        LOCAL_SW_DISABLE_DEFAULT_PBM_PARITY_CONTROLr, PARITY_ENf,
        LOCAL_SW_DISABLE_DEFAULT_PBM_PARITY_STATUS_INTRr, NULL,
        LOCAL_SW_DISABLE_DEFAULT_PBM_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PAR_ERRf,
        LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PAR_ERRf,
        LOCAL_SW_DISABLE_DEFAULT_PBM_MIRRm, NULL,
        LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PARITY_CONTROLr, PARITY_ENf,
        LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PARITY_STATUS_INTRr, NULL,
        LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IMIRROR_BITMAP_PAR_ERRf,
        IMIRROR_BITMAP_PAR_ERRf,
        IMIRROR_BITMAPm, NULL,
        IMIRROR_BITMAP_PARITY_CONTROLr, PARITY_ENf,
        IMIRROR_BITMAP_PARITY_STATUS_INTRr, NULL,
        IMIRROR_BITMAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        UNKNOWN_HGI_BITMAP_PAR_ERRf,
        UNKNOWN_HGI_BITMAP_PAR_ERRf,
        UNKNOWN_HGI_BITMAPm, NULL,
        UNKNOWN_HGI_BITMAP_PARITY_CONTROLr, PARITY_ENf,
        UNKNOWN_HGI_BITMAP_PARITY_STATUS_INTRr, NULL,
        UNKNOWN_HGI_BITMAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TRUNK_MEMBER_PAR_ERRf,
        TRUNK_MEMBER_PAR_ERRf,
        TRUNK_MEMBERm, NULL,
        TRUNK_MEMBER_PARITY_CONTROLr, PARITY_ENf,
        TRUNK_MEMBER_PARITY_STATUS_INTRr, NULL,
        TRUNK_MEMBER_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        PHB2_COS_MAP_PAR_ERRf,
        PHB2_COS_MAP_PAR_ERRf,
        PHB2_COS_MAPm, NULL,
        PHB2_COS_MAP_PARITY_CONTROLr, PARITY_ENf,
        PHB2_COS_MAP_PARITY_STATUS_INTRr, NULL,
        PHB2_COS_MAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ip3_2_parity_info[] = {
  
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EMIRROR_CONTROL_PAR_ERRf,
        EMIRROR_CONTROL_PAR_ERRf,
        EMIRROR_CONTROLm, NULL,
        EMIRROR_CONTROL_PARITY_CONTROLr, PARITY_ENf,
        EMIRROR_CONTROL_PARITY_STATUS_INTRr, NULL,
        EMIRROR_CONTROL_PARITY_STATUS_NACKr, NULL },
  
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EMIRROR_CONTROL1_PAR_ERRf,
        EMIRROR_CONTROL1_PAR_ERRf,
        EMIRROR_CONTROL1m, NULL,
        EMIRROR_CONTROL1_PARITY_CONTROLr, PARITY_ENf,
        EMIRROR_CONTROL1_PARITY_STATUS_INTRr, NULL,
        EMIRROR_CONTROL1_PARITY_STATUS_NACKr, NULL },
  
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EMIRROR_CONTROL2_PAR_ERRf,
        EMIRROR_CONTROL2_PAR_ERRf,
        EMIRROR_CONTROL2m, NULL,
        EMIRROR_CONTROL2_PARITY_CONTROLr, PARITY_ENf,
        EMIRROR_CONTROL2_PARITY_STATUS_INTRr, NULL,
        EMIRROR_CONTROL2_PARITY_STATUS_NACKr, NULL },
  
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EMIRROR_CONTROL3_PAR_ERRf,
        EMIRROR_CONTROL3_PAR_ERRf,
        EMIRROR_CONTROL3m, NULL,
        EMIRROR_CONTROL3_PARITY_CONTROLr, PARITY_ENf,
        EMIRROR_CONTROL3_PARITY_STATUS_INTRr, NULL,
        EMIRROR_CONTROL3_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SW2_EOP_BUFFER_A_PAR_ERRf,
        SW2_EOP_BUFFER_A_PAR_ERRf,
        INVALIDm, "SW2_EOP_BUFFER_A",
        SW2_EOP_BUFFER_A_PARITY_CONTROLr, PARITY_ENf,
        SW2_EOP_BUFFER_A_PARITY_STATUS_INTRr, NULL,
        INVALIDr, NULL },
     
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SW2_EOP_BUFFER_B_PAR_ERRf,
        SW2_EOP_BUFFER_B_PAR_ERRf,
        INVALIDm, "SW2_EOP_BUFFER_B",
        SW2_EOP_BUFFER_B_PARITY_CONTROLr, PARITY_ENf,
        SW2_EOP_BUFFER_B_PARITY_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        OAM_LM_COUNTERS_0_PAR_ERRf,
        OAM_LM_COUNTERS_0_PAR_ERRf,
        OAM_LM_COUNTERS_0m, "OAM_LM_COUNTERS_1",
        OAM_LM_COUNTERS_0_PARITY_CONTROLr, PARITY_ENf,
        OAM_LM_COUNTERS_0_PARITY_STATUS_INTRr, NULL,
        OAM_LM_COUNTERS_0_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_COUNTER, NULL, 0,
        IP_COUNTERS_PAR_ERRf,
        IP_COUNTERS_PAR_ERRf,
        INVALIDm, "Ingress Pipeline Counter",
        IP_COUNTERS_PARITY_CONTROLr, PARITY_ENf,
        IP_COUNTERS_PARITY_STATUS_INTRr, NULL,
        IP_COUNTERS_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_COUNTER, NULL, 0,
        RDBGC_MEM_INST0_PAR_ERRf,
        RDBGC_MEM_INST0_PAR_ERRf,
        INVALIDm, "Ingress Pipeline Counter",
        RDBGC_MEM_INST0_PARITY_CONTROLr, PARITY_ENf,
        RDBGC_MEM_INST0_PARITY_STATUS_INTRr, NULL,
        RDBGC_MEM_INST0_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_COUNTER, NULL, 0,
        RDBGC_MEM_INST1_PAR_ERRf,
        RDBGC_MEM_INST1_PAR_ERRf,
        INVALIDm, "RX Debug Counter",
        RDBGC_MEM_INST1_PARITY_CONTROLr, PARITY_ENf,
        RDBGC_MEM_INST1_PARITY_STATUS_INTRr, NULL,
        RDBGC_MEM_INST1_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_COUNTER, NULL, 0,
        RDBGC_MEM_INST2_PAR_ERRf,
        RDBGC_MEM_INST2_PAR_ERRf,
        INVALIDm, "RX Debug Counter",
        RDBGC_MEM_INST2_PARITY_CONTROLr, PARITY_ENf,
        RDBGC_MEM_INST2_PARITY_STATUS_INTRr, NULL,
        RDBGC_MEM_INST2_PARITY_STATUS_NACKr, NULL }, 

    { _SOC_PARITY_TYPE_COUNTER, NULL, 0,
        HG_COUNTERS_PAR_ERRf,
        HG_COUNTERS_PAR_ERRf,
        INVALIDm, "Ingress Pipeline HG Counter",
        HG_COUNTERS_PARITY_CONTROLr, PARITY_ENf,
        HG_COUNTERS_PARITY_STATUS_INTRr, NULL,
        HG_COUNTERS_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        NIV_ERROR_DROP_PAR_ERRf,
        NIV_ERROR_DROP_PAR_ERRf,
        INVALIDm, "ING_NIV_RX_FRAMES_ERROR_DROP",
        NIV_ERROR_DROP_PARITY_CONTROLr, PARITY_ENf,
        NIV_ERROR_DROP_PARITY_STATUS_INTRr, NULL,
        NIV_ERROR_DROP_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        NIV_FORWARDING_DROP_PAR_ERRf,
        NIV_FORWARDING_DROP_PAR_ERRf,
        INVALIDm, "ING_NIV_RX_FRAMES_FORWARDING_DROP",
        NIV_FORWARDING_DROP_PARITY_CONTROLr, PARITY_ENf,
        NIV_FORWARDING_DROP_PARITY_STATUS_INTRr, NULL,
        NIV_FORWARDING_DROP_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        NIV_VLAN_TAGGED_PAR_ERRf,
        NIV_VLAN_TAGGED_PAR_ERRf,
        INVALIDm, "ING_NIV_RX_FRAMES_VLAN_TAGGED",
        NIV_VLAN_TAGGED_PARITY_CONTROLr, PARITY_ENf,
        NIV_VLAN_TAGGED_PARITY_STATUS_INTRr, NULL,
        NIV_VLAN_TAGGED_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TRILL_RX_PKTS_PAR_ERRf,
        TRILL_RX_PKTS_PAR_ERRf,
        INVALIDm, "ING_TRILL_RX_PKTS",
        TRILL_RX_PKTS_PARITY_CONTROLr, PARITY_ENf,
        TRILL_RX_PKTS_PARITY_STATUS_INTRr, NULL,
        TRILL_RX_PKTS_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PAR_ERRf,
        TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PAR_ERRf,
        INVALIDm, "ING_TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED",
        TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PARITY_CONTROLr, PARITY_ENf,
        TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PARITY_STATUS_INTRr, NULL,
        TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PAR_ERRf,
        TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PAR_ERRf,
        INVALIDm, "ING_TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED",
        TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PARITY_CONTROLr, PARITY_ENf,
        TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PARITY_STATUS_INTRr, NULL,
        TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        CPB_PAR_ERRf,
        CPB_PAR_ERRf,
        INVALIDm, "CPB",
        CPB_PARITY_CONTROLr, PARITY_ENf,
        CPB_PARITY_STATUS_INTRr, NULL,
        INVALIDr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_QUEUE_MAP_PAR_ERRf,
        ING_QUEUE_MAP_PAR_ERRf,
        ING_QUEUE_MAPm, "ING_QUEUE_MAP",
        ING_QUEUE_MAP_PARITY_CONTROLr, PARITY_ENf,
        ING_QUEUE_MAP_PARITY_STATUS_INTRr, NULL,
        ING_QUEUE_MAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        OAM_LM_COUNTERS_1_PAR_ERRf,
        OAM_LM_COUNTERS_1_PAR_ERRf,
        OAM_LM_COUNTERS_1m, "OAM_LM_COUNTERS_1",
        OAM_LM_COUNTERS_1_PARITY_CONTROLr, PARITY_ENf,
        OAM_LM_COUNTERS_1_PARITY_STATUS_INTRr, NULL,
        OAM_LM_COUNTERS_1_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SW2_EOP_BUFFER_C_PAR_ERRf,
        SW2_EOP_BUFFER_C_PAR_ERRf,
        INVALIDm, "SW2_EOP_BUFFER_C",
        SW2_EOP_BUFFER_C_PARITY_CONTROLr, PARITY_ENf,
        SW2_EOP_BUFFER_C_PARITY_STATUS_INTRr, NULL,
        INVALIDr, NULL },
   
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC const
_soc_katana2_parity_route_block_t  _soc_katana2_parity_route_blocks[] = {
    { 0x00000001, /* MMU_TO_CMIC_MEMFAIL_INTR */
        SOC_BLK_MMU, MMU_INTR_MASKr, MMU_INTRr,
        NULL, 0},
        
    { 0x00000002, /* EP1_TO_CMIC_PERR_INTR */
        SOC_BLK_EPIPE, EGR_INTR0_ENABLEr, EGR_INTR0_STATUSr,
        _soc_katana2_ep0_parity_info, 0},
       
    { 0x00000004, /* EP2_TO_CMIC_PERR_INTR */
        SOC_BLK_EPIPE, EGR_INTR1_ENABLEr, EGR_INTR1_STATUSr,
        _soc_katana2_ep1_parity_info, 0},
    
    { 0x00000004, /* EP2_TO_CMIC_PERR_INTR */
        SOC_BLK_EPIPE, EGR_INTR2_ENABLEr, EGR_INTR2_STATUSr,
        _soc_katana2_ep2_parity_info, 0},
         
    { 0x00000008, /* IP0_TO_CMIC_PERR_INTR */
        SOC_BLK_IPIPE, IP0_INTR_ENABLEr, IP0_INTR_STATUSr,
        _soc_katana2_ip0_parity_info, 0},
        
    { 0x00000010, /* IP1_TO_CMIC_PERR_INTR */
        SOC_BLK_IPIPE, IP1_INTR_ENABLEr, IP1_INTR_STATUSr,
        _soc_katana2_ip1_parity_info, 0},
    
    { 0x00000010, /* IP1_TO_CMIC_PERR_INTR */
        SOC_BLK_IPIPE, IP1_INTR_ENABLE_1r, IP1_INTR_STATUS_1r,
        _soc_katana2_ip1_1_parity_info, 0},
        
    { 0x00000020, /* IP2_TO_CMIC_PERR_INTR */
        SOC_BLK_IPIPE, IP2_INTR_ENABLEr, IP2_INTR_STATUSr,
        _soc_katana2_ip2_parity_info, 0},

    /* MXQ0_TO_CMIC_PERR_INTR */
    { 0x00000080,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 0},
   
    /* MXQ1_TO_CMIC_PERR_INTR */
    { 0x00000100,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 1},
    
    /* MXQ2_TO_CMIC_PERR_INTR */
    { 0x00000200,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 2},
    
    /* MXQ3_TO_CMIC_PERR_INTR */
    { 0x00000400,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 3},
    
    { 0x00000800,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 4},
    
    { 0x00001000,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 5},
    
    { 0x00002000,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 6},
    
    { 0x00004000,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 7},
    
    { 0x00008000,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 8},
        
    { 0x00010000,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 9},
    
    { 0x00020000,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 10},

    { 0x00040000,
        SOC_BLK_RXLP, RXLP_ECC_INTERRUPT_ENABLEr, RXLP_ECC_INTERRUPT_STATUSr,
        _soc_katana2_rxlp_parity_info, 0},

    { 0x00080000,
        SOC_BLK_RXLP, RXLP_ECC_INTERRUPT_ENABLEr, RXLP_ECC_INTERRUPT_STATUSr,
        _soc_katana2_rxlp_parity_info, 1},
    
    { 0x00100000,
        SOC_BLK_TXLP, TXLP_INTR_ENABLEr, TXLP_INTR_STATUSr,
        _soc_katana2_txlp_parity_info, 0},
    
    { 0x00200000,
        SOC_BLK_TXLP, TXLP_INTR_ENABLEr, TXLP_INTR_STATUSr,
        _soc_katana2_txlp_parity_info, 1},

    /* IP3_TO_CMIC_PERR_INTR */
    { 0x00400000,
        SOC_BLK_IPIPE, IP3_INTR_ENABLEr, IP3_INTR_STATUSr,
        _soc_katana2_ip3_parity_info, 0},
    
    /* IP3_TO_CMIC_PERR_INTR */
    { 0x00400000,
        SOC_BLK_IPIPE, IP3_INTR_ENABLE_1r, IP3_INTR_STATUS_1r,
        _soc_katana2_ip3_1_parity_info, 0},
    
    /* IP3_TO_CMIC_PERR_INTR */
    { 0x00400000,
        SOC_BLK_IPIPE, IP3_INTR_ENABLE_2r, IP3_INTR_STATUS_2r,
        _soc_katana2_ip3_2_parity_info, 0},
    /* 0x00000800 PULL_DOWN */

    { 0 } /* table terminator */
};


#define _SOC_KT2_SER_REG 1
#define _SOC_KT2_SER_MEM 0

typedef union _kt2_ser_nack_reg_mem_u {
    soc_reg_t reg;
    soc_mem_t mem;
} _kt2_ser_nack_reg_mem_t;

static int _stat_error_fixed[SOC_MAX_NUM_DEVICES];

STATIC int
_soc_katana2_parity_enable_info(int unit, soc_port_t port, 
                                soc_reg_t group_reg,
                                uint32 *group_rval,
                                const _soc_katana2_parity_info_t *info_list,
                                int enable);

STATIC
int _soc_katana2_ci_block_get(int unit, 
                              _soc_katana2_mmu_subblock_type_t sub_block, 
                              soc_block_t* block)
{
    switch(sub_block){
    case _SOC_KT2_MMU_SUBBLOCK_CI5:
    *block = CI5_BLOCK(unit);
        break;
    
    case _SOC_KT2_MMU_SUBBLOCK_CI4:
    *block = CI4_BLOCK(unit);
        break;
    
    case _SOC_KT2_MMU_SUBBLOCK_CI3:
    *block = CI3_BLOCK(unit);
        break;
    
    case _SOC_KT2_MMU_SUBBLOCK_CI2:
    *block = CI2_BLOCK(unit);
        break;
    
    case _SOC_KT2_MMU_SUBBLOCK_CI1:
    *block = CI1_BLOCK(unit);
        break;
        
    case _SOC_KT2_MMU_SUBBLOCK_CI0:
    *block = CI0_BLOCK(unit);
        break;
    
    default:
        break;	
    }
    return SOC_E_NONE;
}

STATIC
int _soc_katana2_process_sb_mmu_leaf_parity_enable(int unit,
                          soc_port_t port,
                          soc_reg_t leaf_enable_reg,
                          _soc_katana2_mmu_sub_block_leaf_info_t * leaf_info,
                          int enable)
{
    uint32 en_rval;
    int index;
    soc_field_t enable_field;
    _soc_katana2_mmu_sub_block_leaf_info_t * info;
    
    /* leaf_info contains a list of leaf block, each leaf has a bit 
       in leaf_enable_reg */
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, leaf_enable_reg, port, 0, 
                                      &en_rval));
    
    for (index = 0; ; index++) {
        info = &leaf_info[index];
        if(info->intr_bit == 0) {
            /* End of leaf table */
            break;
        }
        enable_field = info->enable_field;
        
        if (SOC_REG_FIELD_VALID(unit, leaf_enable_reg, enable_field)) {
            if (enable_field == FLUSH_COMPLETE_DISINTf) {
            continue;
            }
            /* set corresponding field for a leaf block */
            soc_reg_field_set(unit, leaf_enable_reg, &en_rval, enable_field, 
                              enable ? 0 : 1);
        }
    }
    
    /* write back enable register */
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, leaf_enable_reg, port, 0, en_rval));
    return SOC_E_NONE;
}

STATIC
int _soc_katana2_process_sb_one_level_mmu_parity_enable(int unit, 
                        soc_reg_t mmu_en_reg,
                        _soc_katana2_mmu_sub_block_one_level_t * sub_block_info,
                        int enable)
{
    uint32 en_rval;
    soc_block_t block = SOC_BLOCK_ANY;
    soc_port_t port = REG_PORT_ANY;
    soc_reg_t leaf_enable_reg;
    _soc_katana2_mmu_subblock_type_t sub_block_type;
    _soc_katana2_mmu_sub_block_leaf_info_t * leaf_info;
    
    if(sub_block_info->mmu_bit == 0) {
        /* reach the end of one level sub block table */
        return SOC_E_NONE;
    }

    sub_block_type = sub_block_info->mmu_sub_block;
    if ((sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI5)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI4)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI3)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI2)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI1)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI0)){
    	  
    	  if (soc_feature(unit, soc_feature_ddr3)){
    	      _soc_katana2_ci_block_get (unit, sub_block_type, &block);
            port = SOC_BLOCK_PORT(unit, block);
    	  } else {
    	      return SOC_E_NONE;
    	  }
    }
    
    leaf_info = sub_block_info->info;
    
    /* enable for this sub block */
    leaf_enable_reg = sub_block_info->leaf_enable_reg;
    SOC_IF_ERROR_RETURN
        (_soc_katana2_process_sb_mmu_leaf_parity_enable (unit, port, 
                               leaf_enable_reg, leaf_info, enable));
    
    /* set MMU_INTR_MASK */
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, mmu_en_reg, REG_PORT_ANY, 0, &en_rval));
    soc_reg_field_set(unit, mmu_en_reg, &en_rval, 
                      sub_block_info->mmu_enable_field, enable ? 0 : 1);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, mmu_en_reg, REG_PORT_ANY, 0, en_rval));
    
    return SOC_E_NONE;
}

STATIC
int _soc_katana2_process_sb_two_level_mmu_parity_enable(int unit, 
                       soc_reg_t mmu_en_reg,
                       _soc_katana2_mmu_sub_block_two_level_t * sub_block_info,
                       int enable)
{
    uint32 en_rval;
    soc_reg_t internal_enable_reg;
    soc_reg_t leaf_enable_reg;
    soc_field_t internal_enable_field;
    int internal_index;
    soc_port_t port = REG_PORT_ANY;
    _soc_katana2_mmu_sub_block_internal_info_t * internal_info;
    _soc_katana2_mmu_sub_block_leaf_info_t * leaf_info;
    
    if(sub_block_info->mmu_bit == 0) {
        /* reach the end of two level sub block table */
        return SOC_E_NONE;
    }
    
    internal_info = sub_block_info->info;
    internal_enable_reg = sub_block_info->internal_enable_reg;
    
    /* get mask register of level 1 sub block */    
    if (internal_enable_reg != 0) {
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, internal_enable_reg, 
                                      REG_PORT_ANY, 0, &en_rval));
    }

    for (internal_index = 0; ; internal_index++) {
        internal_info = &sub_block_info->info[internal_index];
        if(internal_info->intr_bit == 0) {
            /* End of internal_info table */
            break;
        }

        internal_enable_field = internal_info->internal_enable_field;
        
        if ((internal_enable_reg != 0) && 
        	 (SOC_REG_FIELD_VALID(unit, internal_enable_reg, 
        	                      internal_enable_field))) {
            soc_reg_field_set(unit, internal_enable_reg, &en_rval, 
                              internal_enable_field, enable ? 0 : 1);
        }
        
        /* get mask register of level 2 sub mask */
        leaf_enable_reg = internal_info->leaf_enable_reg;
        leaf_info = internal_info->info;
                                                    
        SOC_IF_ERROR_RETURN
            (_soc_katana2_process_sb_mmu_leaf_parity_enable (unit, port,
                                   leaf_enable_reg, leaf_info, enable));
    }
    
    /* write back mask register of level 1 sub block */
    if (internal_enable_reg != 0) {
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, internal_enable_reg, 
                                          REG_PORT_ANY, 0, en_rval));
    }
    
    /* set MMU_INTR_MASK */
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, mmu_en_reg, REG_PORT_ANY, 0, 
                                      &en_rval));
    soc_reg_field_set(unit, mmu_en_reg, &en_rval, 
                      sub_block_info->mmu_enable_field, enable ? 0 : 1);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, mmu_en_reg, REG_PORT_ANY, 0, 
                                      en_rval));
    
    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_enable_mmu(int unit, soc_reg_t mmu_en_reg, int enable)
{
    int index;
    uint32 sub_block_num;
    _soc_katana2_mmu_sub_block_one_level_t * sub_block;
    _soc_katana2_mmu_sub_block_two_level_t * two_level_sub_block;

    sub_block_num = COUNTOF(_soc_katana2_mmu_sub_blocks_type_1);
                     
    for (index = 0; index < sub_block_num; index++) {
    	  sub_block = &_soc_katana2_mmu_sub_blocks_type_1[index];
        SOC_IF_ERROR_RETURN
            (_soc_katana2_process_sb_one_level_mmu_parity_enable(unit, 
                                       mmu_en_reg, sub_block, enable));
    }

    sub_block_num = COUNTOF(_soc_katana2_mmu_sub_blocks_type_2);

    for (index = 0; index < sub_block_num; index++) {
        two_level_sub_block = &_soc_katana2_mmu_sub_blocks_type_2[index];
        SOC_IF_ERROR_RETURN
            (_soc_katana2_process_sb_two_level_mmu_parity_enable(unit, 
                            mmu_en_reg, two_level_sub_block, enable));	
    }
    return SOC_E_NONE;
}


STATIC
int _soc_katana2_process_sb_mmu_leaf_parity_error (int unit, 
                      _soc_katana2_mmu_subblock_type_t sub_block_type,
                      soc_port_t port,
                      soc_reg_t leaf_enable_reg,
                      soc_reg_t leaf_status_reg,
                      _soc_katana2_mmu_sub_block_leaf_info_t * leaf_info)
{
    uint32 stat_rval, en_rval;
    uint32 intr_bit;
    int index = 0;
    _soc_katana2_mmu_sub_block_leaf_info_t *info;
    char prefix_str[10];
    char *reg_str;
    char *field_str;
    
    sal_sprintf(prefix_str, "unit %d", unit);
    
    /* A _soc_katana2_mmu_sub_block_leaf_info_t object corresponds to
       a list of leaf blocks share the common enable and status register.
       each memory has a bit in enable and status register. usually, the 
       bit position is same, but for in some case, they are not equal.
       in this case, we need to do specical handling. */
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, leaf_status_reg, port, 0, &stat_rval));
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, leaf_enable_reg, port, 0, &en_rval));
    
    if (leaf_status_reg == RQE_EXTQ_REPLICATION_COUNTr) {
        stat_rval &= ((~en_rval) << 11);
    } else {
        stat_rval &= (~en_rval);
    }

    if (stat_rval == 0) {
        /* How did this interrupt get asserted then??? */
        return SOC_E_NONE; 
    }
    
    /* We really need handle the parity, because it trigger status register and we 
       do not mask it. Go over all the memories in the list. 
       a _soc_katana2_mmu_sub_block_leaf_info_t corresponds to a memory instance
       its intr_bit specify its bit position in status register */
    for (index = 0; ; index++) {
        info = &leaf_info[index];
        intr_bit = info->intr_bit;
        if(intr_bit == 0) {
            /* reach the end of leaf table */
            return SOC_E_NONE;
        }
        
        /* get a match */
        if (stat_rval & intr_bit) {
             field_str = SOC_FIELD_NAME(unit, info->status_field);
             reg_str = SOC_REG_NAME(unit, leaf_status_reg);
             
             soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                sub_block_type,
                                leaf_status_reg, info->status_field);
             soc_cm_debug(DK_ERR,
                      "%s MMU subblock %x   reg %s field %s(value = 0x%x) has \
                      MMU parity error\n",
                      prefix_str, sub_block_type, reg_str, 
                      field_str, stat_rval);
             /* clear the parity error bit */
             SOC_IF_ERROR_RETURN
                 (soc_reg32_set(unit, leaf_status_reg, port, 0, intr_bit));
        }
    }
    return SOC_E_NONE;
}

STATIC
int _soc_katana2_process_sb_one_level_mmu_parity_error(int unit,
                      _soc_katana2_mmu_sub_block_one_level_t * sub_block_info)
{
    soc_reg_t leaf_enable_reg;
    soc_reg_t leaf_status_reg; 
    _soc_katana2_mmu_subblock_type_t sub_block_type;
    soc_block_t block = SOC_BLOCK_ANY;
    soc_port_t port = REG_PORT_ANY;
    _soc_katana2_mmu_sub_block_leaf_info_t * leaf_info;
    
    if(sub_block_info->mmu_bit == 0) {
        /* reach the end of one level sub block table */
        return SOC_E_NONE;
    }
    sub_block_type = sub_block_info->mmu_sub_block;
    
    if ((sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI5)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI4)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI3)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI2)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI1)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI0)){
    	  
    	  if (soc_feature(unit, soc_feature_ddr3)){
    	      _soc_katana2_ci_block_get (unit, sub_block_type, &block);
            port = SOC_BLOCK_PORT(unit, block);
    	  } else {
    	      return SOC_E_NONE;
    	  }
    }
    
    leaf_enable_reg = sub_block_info->leaf_enable_reg;
    leaf_status_reg = sub_block_info->leaf_status_reg;
    leaf_info = sub_block_info->info;

    /* process this sub block */
    SOC_IF_ERROR_RETURN
        (_soc_katana2_process_sb_mmu_leaf_parity_error (unit, sub_block_type,
                         port, leaf_enable_reg, leaf_status_reg, leaf_info));

    return SOC_E_NONE;
}

STATIC
int _soc_katana2_process_sb_two_level_mmu_parity_error(int unit,
                          _soc_katana2_mmu_sub_block_two_level_t * sub_block_info)
{
    uint32 en_rval;
    uint32 status_rval;
    soc_reg_t internal_status_reg;
    soc_reg_t internal_enable_reg;
    int internal_index;
    soc_port_t port = REG_PORT_ANY;
    _soc_katana2_mmu_subblock_type_t sub_block_type;
    _soc_katana2_mmu_sub_block_internal_info_t * internal_info;
    
    if(sub_block_info->mmu_bit == 0) {
        /* reach the end of two level sub block table */
        return SOC_E_NONE;
    }
    sub_block_type = sub_block_info->mmu_sub_block;
    
    /* get status register of level 1 sub block */
    internal_status_reg = sub_block_info->internal_status_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, internal_status_reg, REG_PORT_ANY, 0, 
                                                       &status_rval));
    /* get mask register of level 1 sub block */
    internal_enable_reg = sub_block_info->internal_enable_reg;
    if (internal_enable_reg != 0) {
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, internal_enable_reg, REG_PORT_ANY, 0, 
                                                               &en_rval));
        /* remove masked */
        status_rval &= (~en_rval);
    }
    
    if (status_rval == 0) {
        /* How did this interrupt get asserted then??? */
        return SOC_E_NONE; 
    }
    
    for (internal_index = 0; ; internal_index++) {
        internal_info = &sub_block_info->info[internal_index];
        
        if(internal_info->intr_bit == 0) {
            break;
        }
        if (status_rval & internal_info->intr_bit){
        /* process this sub block */
        SOC_IF_ERROR_RETURN
            (_soc_katana2_process_sb_mmu_leaf_parity_error (unit, 
            sub_block_type, port, internal_info->leaf_enable_reg,
            internal_info->leaf_status_reg, internal_info->info));
        
        /* clear the parity error bit */
        SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, internal_status_reg, REG_PORT_ANY, 0, 
                                                  internal_info->intr_bit));
        }
    }
    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_process_mmu(int unit, soc_reg_t mmu_en_reg, 
                               soc_reg_t mmu_stat_reg, char *prefix_str)
{
    uint32 en_rval, stat_rval, mmu_bit;
    int index;
    uint32 sub_block_num;
    _soc_katana2_mmu_sub_block_one_level_t * sub_block;
    _soc_katana2_mmu_sub_block_two_level_t * sub_block_2;

    /* get MMU INTR and MASK */
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, mmu_en_reg, REG_PORT_ANY, 0, &en_rval));
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, mmu_stat_reg, REG_PORT_ANY, 0, &stat_rval));
    
    /* remove masked */
    stat_rval &= (~en_rval);
    if (stat_rval == 0) {
        /* How did this interrupt get asserted then??? */
        return SOC_E_NONE;
    }
    
    sub_block_num = COUNTOF(_soc_katana2_mmu_sub_blocks_type_1);
    for (index = 0; index < sub_block_num; index++){
        sub_block = &_soc_katana2_mmu_sub_blocks_type_1[index];
        if(sub_block->mmu_bit == 0) {
            /* End of table */
            break;
        }
        mmu_bit = sub_block->mmu_bit;
        
        if ((sub_block->mmu_bit & (stat_rval)) == 0) {
            /* No interrupts in this sub-block */
            continue;
        }
        
        _soc_katana2_process_sb_one_level_mmu_parity_error(unit, sub_block);
                                      
        /* clear the MMU parity error bit */
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, mmu_stat_reg, REG_PORT_ANY, 0, mmu_bit));
    }
    
    sub_block_num = COUNTOF(_soc_katana2_mmu_sub_blocks_type_2);
    for (index = 0; index < sub_block_num; index++) {
        sub_block_2 = &_soc_katana2_mmu_sub_blocks_type_2[index];
        if(sub_block_2->mmu_bit == 0) {
            /* End of table */
            break;
        }
        mmu_bit = sub_block_2->mmu_bit;
        
        if ((mmu_bit & (stat_rval)) == 0) {
            /* No interrupts in this sub-block */
            continue;
        }
        
         _soc_katana2_process_sb_two_level_mmu_parity_error(unit, sub_block_2);
        /* clear the MMU parity error bit */
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, mmu_stat_reg, REG_PORT_ANY, 0, mmu_bit));
    }
    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_enable_info(int unit, soc_port_t port,
                                soc_reg_t group_reg,
                                uint32 *group_rval,
                                const _soc_katana2_parity_info_t *info_list,
                                int enable)
{
    const _soc_katana2_parity_info_t *info;
    int info_index;
    soc_reg_t reg;
    uint32 rval;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }

        /* Enable the info entry in the group register */
        soc_reg_field_set(unit, group_reg, group_rval,
                          info->group_reg_enable_field, enable ? 1 : 0);

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_PARITY:
        case _SOC_PARITY_TYPE_ECC:
        case _SOC_PARITY_TYPE_HASH:
        case _SOC_PARITY_TYPE_EDATABUF:
        case _SOC_PARITY_TYPE_COUNTER:
            reg = info->enable_reg;
            if (!SOC_REG_IS_VALID(unit, reg)) {
                continue;
            }

            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));
            soc_reg_field_set(unit, reg, &rval, info->enable_field,
                              enable ? 1 : 0);
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
            break;
        case _SOC_PARITY_TYPE_GENERIC:
        default:
            break;
        } /* Handle different parity error reporting style */
    } /* Loop through each info entry in the route block */

    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_enable_all(int unit, int enable)
{
    const _soc_katana2_parity_route_block_t *route_block;
    int route_block_index, block_idx;
    soc_port_t port;
    soc_reg_t route_block_en_reg;
    uint32 cmic_rval, route_block_rval;
    uint32 cmic_bit;
    uint32 rval;

    port = REG_PORT_ANY;
    cmic_rval = 0;
    /* Loop through each place-and-route block entry */
    for (route_block_index = 0; ; route_block_index++) {
        route_block = &_soc_katana2_parity_route_blocks[route_block_index];
        cmic_bit = route_block->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        /* Enable the route block entry in the CMIC register */
        if (enable) {
            cmic_rval |= cmic_bit;
        }

        route_block_en_reg = route_block->enable_reg;
        
        /* get block and port for MXQ and RXLP and TXLP */
        if ((route_block->blocktype == SOC_BLK_MXQPORT) ||
            (route_block->blocktype == SOC_BLK_TXLP) ||
            (route_block->blocktype == SOC_BLK_RXLP)) {
            SOC_BLOCK_ITER(unit, block_idx, route_block->blocktype) {
                if (SOC_BLOCK_INFO(unit, block_idx).number == route_block->id) {
                    port = SOC_BLOCK_PORT(unit, block_idx);
                    break;
                }
            }
        }
       
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, route_block_en_reg, port, 0, &route_block_rval));

        if (route_block->blocktype == SOC_BLK_MMU) {
            SOC_IF_ERROR_RETURN
              (_soc_katana2_parity_enable_mmu(unit, route_block_en_reg, enable));
        } else {
            
                SOC_IF_ERROR_RETURN(_soc_katana2_parity_enable_info(unit,
                                                 port,
                                                 route_block_en_reg,
                                                 &route_block_rval,
                                                 route_block->info, enable));

            /* Write per route block parity enable register */
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, route_block_en_reg, port, 0, route_block_rval));
        }
    } /* Loop through each place-and-route block entry */

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_STAT_CLEARf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
    if (enable) {
        /* MMU enables */
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_CHK_ENf, 1);
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_GEN_ENf, 1);
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_STAT_CLEARf, 0);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        /* Write CMIC enable register */
        (void)soc_cmicm_intr2_enable(unit, cmic_rval);
    } else {
        /* MMU disables */
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_CHK_ENf, 0);
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_GEN_ENf, 0);
        soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_STAT_CLEARf, 0);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        /* Write CMIC disable register */
        (void)soc_cmicm_intr2_disable(unit, cmic_rval);
    }
    return SOC_E_NONE;
}

void
_soc_katana2_mem_rename(soc_mem_t *memory)
{
    soc_mem_t mem = *memory;
    
    switch(*memory) {
    case VLAN_SUBNETm:
        mem = VLAN_SUBNET_DATA_ONLYm;
        break;
    case L2Xm:
        mem = L2_ENTRY_ONLYm;
        break;
    case L2_USER_ENTRY_ONLYm:
    case L2_USER_ENTRYm:
        mem = L2_USER_ENTRY_DATA_ONLYm;
        break;
    case L3_DEFIPm:
        mem = L3_DEFIP_DATA_ONLYm;
        break;
    case L3_DEFIP_128m:
        mem = L3_DEFIP_128_DATA_ONLYm;
        break;
    case EGR_IP_TUNNEL_IPV6m:
    case EGR_IP_TUNNEL_MPLSm:
        mem = EGR_IP_TUNNELm;
        break;
    case L3_ENTRY_IPV4_UNICASTm:
    case L3_ENTRY_IPV6_UNICASTm:
    case L3_ENTRY_IPV4_MULTICASTm:
    case L3_ENTRY_IPV6_MULTICASTm:
        mem = L3_ENTRY_ONLYm;
        break;
    case VLAN_MACm:
        mem = VLAN_XLATEm;
        break;
    default:
        /* Do nothing, keep memory as provided */
        break;
    }
    *memory = mem;
}

int
_soc_katana2_mem_parity_control(int unit, soc_mem_t mem, int copyno,
                                int enable)
{
    const _soc_katana2_parity_route_block_t *route_block;
    int route_block_index;
    uint32 cmic_bit;
    int info_index;
    soc_reg_t reg;
    uint32 rval;
    const _soc_katana2_parity_info_t *info;

    if (!soc_property_get(unit, spn_PARITY_ENABLE, FALSE)) {
        /* Parity checking is not enabled, nothing to do */
        return SOC_E_NONE;
    }

    /* Convert component/aggregate memories to the table for which
     * the parity registers correspond. */
    _soc_katana2_mem_rename(&mem);

    /* Loop through each place-and-route block entry */
    for (route_block_index = 0; ; route_block_index++) {
        route_block = &_soc_katana2_parity_route_blocks[route_block_index];
        cmic_bit = route_block->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }

        if (route_block->blocktype == SOC_BLK_MMU) {
            SOC_IF_ERROR_RETURN(_soc_katana2_parity_enable_mmu(unit, 
                                         route_block->enable_reg, enable));
            continue;
        }

        /* Loop through each info entry in the list */
        for (info_index = 0; ; info_index++) {
            info = &route_block->info[info_index];
            if (info->type == _SOC_PARITY_TYPE_NONE) {
                /* End of table */
                break;
            }
            if (mem != INVALIDm && info->mem != mem) {
                continue;
            }

            /* Handle different parity error reporting style */
            switch (info->type) {
            case _SOC_PARITY_TYPE_PARITY:
            case _SOC_PARITY_TYPE_ECC:
            case _SOC_PARITY_TYPE_HASH:
            case _SOC_PARITY_TYPE_EDATABUF:
            case _SOC_PARITY_TYPE_COUNTER:
                reg = info->enable_reg;
                if (!SOC_REG_IS_VALID(unit, reg)) {
                    continue;
                }
                
                SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
                soc_reg_field_set(unit, reg, &rval, info->enable_field,
                                  enable ? 1 : 0);
                SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));
                break;
            case _SOC_PARITY_TYPE_GENERIC:
            default:
                break;
            }
        }
    }

    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_process_info(int unit, soc_port_t port, soc_reg_t reg,
                                 uint32 status,
                                 const _soc_katana2_parity_info_t *info_list,
                                 char *prefix_str, soc_block_t block);

STATIC int
_soc_katana2_parity_process_parity(int unit, soc_port_t port,
                                   const _soc_katana2_parity_info_t *info,
                                   int schan, char *prefix_str, char *mem_str, 
                                   soc_block_t block)
{
    _soc_katana2_parity_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    uint32 rval;
    uint32 multiple, entry_idx, idx, has_error;
    char *mem_str_ptr;
    _soc_ser_correct_info_t spci = {0};

    if (schan) {
        /* Some table does not have NACK register */
        if (info->nack_status_reg == INVALIDr &&
            info->nack_status_reg_list == NULL) {
            return SOC_E_NONE;
        }
        reg_entry[0].reg = info->nack_status_reg;
        reg_entry[0].mem_str = NULL;
        reg_entry[1].reg = INVALIDr;
        reg_ptr = reg_entry;
    } else {
        if (info->intr_status_reg != INVALIDr) {
            reg_entry[0].reg = info->intr_status_reg;
            reg_entry[0].mem_str = NULL;
            reg_entry[1].reg = INVALIDr;
            reg_ptr = reg_entry;
        } else if (info->intr_status_reg_list != NULL) {
            reg_ptr = info->intr_status_reg_list;
        } else {
            return SOC_E_NONE;
        }
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = reg_ptr[idx].mem_str != NULL ?
            reg_ptr[idx].mem_str : mem_str;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));

        if (soc_reg_field_get(unit, reg, rval, PARITY_ERRf)) {
            has_error = TRUE;
            multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
            
            if (soc_reg_field_valid(unit, reg, ADDRESSf)) {
                entry_idx = soc_reg_field_get(unit, reg, rval, ADDRESSf);
            } else {
                entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDXf);
            }
            
            soc_cm_debug(DK_ERR,
                         "%s %s entry %d parity error\n",
                         prefix_str, mem_str_ptr, entry_idx);
            if (multiple) {
                soc_cm_debug(DK_ERR,
                             "%s %s has multiple parity errors\n",
                             prefix_str, mem_str_ptr);
            }
            if (info->mem != INVALIDm) {
                spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
                spci.reg = INVALIDr;
                spci.mem = info->mem;
                spci.blk_type = block;
                spci.index = entry_idx;
                (void)soc_ser_correction(unit, &spci);
            }
            /* Clear parity status */
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, 0));
        }
    }

    if (!has_error) {
        soc_cm_debug(DK_ERR,
                     "%s %s parity hardware inconsistency\n",
                     prefix_str, mem_str);
    }

    return SOC_E_NONE;
} /*_soc_katana_parity_process_parity*/

STATIC int
_soc_katana2_parity_process_ecc(int unit, soc_port_t port,
                                const _soc_katana2_parity_info_t *info,
                                int schan, char *prefix_str, char *mem_str, 
                                soc_block_t block)
{
    _soc_katana2_parity_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    uint32 rval;
    uint32 multiple, double_bit, entry_idx, idx, has_error;
    char *mem_str_ptr;
    _soc_ser_correct_info_t spci = {0};

    if (schan) {
        /* Some table does not have NACK register */
        if (info->nack_status_reg == INVALIDr &&
            info->nack_status_reg_list == NULL) {
            return SOC_E_NONE;
        }
        reg_entry[0].reg = info->nack_status_reg;
        reg_entry[0].mem_str = NULL;
        reg_entry[1].reg = INVALIDr;
        reg_ptr = reg_entry;
    } else {
        if (info->intr_status_reg != INVALIDr) {
            reg_entry[0].reg = info->intr_status_reg;
            reg_entry[0].mem_str = NULL;
            reg_entry[1].reg = INVALIDr;
            reg_ptr = reg_entry;
        } else if (info->intr_status_reg_list != NULL) {
            reg_ptr = info->intr_status_reg_list;
        } else {
            return SOC_E_NONE;
        }
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = reg_ptr[idx].mem_str != NULL ?
            reg_ptr[idx].mem_str : mem_str;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));

        if (soc_reg_field_get(unit, reg, rval, ECC_ERRf)) {
            has_error = TRUE;
            multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
            double_bit = soc_reg_field_get(unit, reg, rval, DOUBLE_BIT_ERRf);
            entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDXf);
            if (double_bit) {
                soc_cm_debug(DK_ERR,
                             "%s %s entry %d double-bit ECC error\n",
                             prefix_str, mem_str_ptr, entry_idx);
            } else {
                soc_cm_debug(DK_ERR,
                             "%s %s entry %d ECC error\n",
                             prefix_str, mem_str_ptr, entry_idx);
            }
            if (multiple) {
                soc_cm_debug(DK_ERR,
                             "%s %s has multiple ECC errors\n",
                             prefix_str, mem_str_ptr);
            }
            
            if (info->mem != INVALIDm) {
                spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
                spci.reg = INVALIDr;
                spci.mem = info->mem; 
                spci.blk_type = block;
                spci.index = entry_idx;
                (void)soc_ser_correction(unit, &spci);
            }
            /* Clear parity status */
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, 0));
        }

    }

    if (!has_error) {
        soc_cm_debug(DK_ERR,
                     "%s %s ECC hardware inconsistency\n",
                     prefix_str, mem_str);
    }

    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_process_hash(int unit, soc_port_t port,
                                 const _soc_katana2_parity_info_t *info,
                                 int schan, char *prefix_str, char *mem_str,
                                 soc_block_t block)
{
    _soc_katana2_parity_reg_t *reg_ptr;
    soc_reg_t reg;
    uint32 rval;
    uint32 bitmap, multiple, bucket_idx;
    int bucket_size, entry_idx = -1, idx, bank_bkt_idx, bits, has_error;
    _soc_ser_correct_info_t spci = {0};
    soc_field_t efield = PARITY_ERR_BMf;
    soc_field_t bfield = BUCKET_IDXf;
    soc_field_t mfield = MULTIPLE_ERRf;

    if (schan) {
        reg_ptr = info->nack_status_reg_list;
    } else {
        reg_ptr = info->intr_status_reg_list;
    }

    has_error = FALSE;
    for (idx = 0; idx < 2; idx ++) {
        reg = reg_ptr[idx].reg;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));

        /* Some memories have this field named differently */
        if (soc_reg_field_valid(unit, reg, PARITY_ERR_BMf)) {
            efield = PARITY_ERR_BMf;
            bfield = BUCKET_IDXf;
            mfield = MULTIPLE_ERRf;
        } else if (soc_reg_field_valid(unit, reg, PARITY_ERR_BM_0f)) {
            efield = PARITY_ERR_BM_0f;
            bfield = BUCKET_IDX_0f;
            mfield = MULTIPLE_ERR_0f;
        } else if (soc_reg_field_valid(unit, reg, PARITY_ERR_BM_1f)) {
            efield = PARITY_ERR_BM_1f;
            bfield = BUCKET_IDX_1f;
            mfield = MULTIPLE_ERR_1f;
        }        

        bitmap = soc_reg_field_get(unit, reg, rval, efield);
        if (bitmap != 0) {
            has_error = TRUE;
            multiple = soc_reg_field_get(unit, reg, rval, mfield);
            bucket_size = soc_reg_field_length(unit, reg, efield);
            bucket_idx = soc_reg_field_get(unit, reg, rval, bfield) * 
                bucket_size * 2;
            bank_bkt_idx = idx * bucket_size + bucket_idx;
            for (bits = 0; bits < bucket_size; bits++) {
                if (bitmap & (1 << bits)) {
                    entry_idx = bank_bkt_idx + bits;
                    soc_cm_debug(DK_ERR, "%s %s entry %d parity error\n",
                                 prefix_str, mem_str, entry_idx);
                }
            }
            if (multiple) {
                soc_cm_debug(DK_ERR,
                             "%s %s has multiple parity errors\n",
                             prefix_str, mem_str);
            }

            if ((info->mem != INVALIDm) && (entry_idx != -1)) {
                spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
                spci.reg = INVALIDr;
                spci.mem = info->mem; 
                spci.blk_type = block;
                spci.index = entry_idx;
                (void)soc_ser_correction(unit, &spci);
            }

            /* Clear parity status */
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, 0));
        }
    }

    if (!has_error) {
        soc_cm_debug(DK_ERR,
                     "%s %s parity hardware inconsistency\n",
                     prefix_str, mem_str);
    }

    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_process_edatabuf(int unit, soc_port_t port,
                                     const _soc_katana2_parity_info_t *info,
                                     int schan, char *prefix_str,
                                     char *mem_str)
{
    soc_reg_t reg;
    uint32 rval;
    uint32 double_bit, multiple;

    if (schan) {
        /* Some table may not have NACK status register */
        if (info->nack_status_reg == INVALIDr) {
            return SOC_E_NONE;
        }
        reg = info->nack_status_reg;
    } else {
        reg = info->intr_status_reg;
    }
    reg = schan ? info->nack_status_reg : info->intr_status_reg;
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));

    if (soc_reg_field_get(unit, reg, rval, ECC_ERR_MGRPf)) {
        double_bit = soc_reg_field_get(unit, reg, rval, ECC_ERR_2B_MGRPf);
        multiple = soc_reg_field_get(unit, reg, rval, ECC_MULTI_MGRPf);
        if (double_bit) {
            soc_cm_debug(DK_ERR,
                         "%s %s double-bit ECC error\n",
                         prefix_str, mem_str);
        } else {
            soc_cm_debug(DK_ERR,
                         "%s %s ECC error\n",
                         prefix_str, mem_str);
        }
        if (multiple) {
            soc_cm_debug(DK_ERR,
                         "%s %s has multiple ECC errors\n",
                         prefix_str, mem_str);
        }
    } else {
        soc_cm_debug(DK_ERR,
                     "%s %s ECC hardware inconsistency\n",
                     prefix_str, mem_str);
    }

    /* Clear parity status */
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, 0));

    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_process_counter(int unit, soc_port_t port,
                                    const _soc_katana2_parity_info_t *info,
                                    int schan, char *prefix_str, char *mem_str,
                                    soc_block_t block)
{
    soc_cmap_t *cmap = NULL;
    soc_reg_t reg, counter_reg;
    uint32 rval;
    uint32 multiple, counter_idx, port_idx, entry_idx;
    char *counter_name;
    _soc_ser_correct_info_t spci = {0};

    if (schan) {
        reg = info->nack_status_reg;
    } else {
        reg = info->intr_status_reg;
    }
    
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));

    if (soc_reg_field_get(unit, reg, rval, PARITY_ERRf)) {
        multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
        counter_idx = soc_reg_field_get(unit, reg, rval, COUNTER_IDXf);
        port_idx = soc_reg_field_get(unit, reg, rval, PORT_IDXf);
        entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDXf);

        /* TDBGC starts at index 0x1A of counter DMA table */
        if (info->group_reg_status_field == EGR_STATS_COUNTER_TABLE_PAR_ERRf) {
            counter_idx += 0x1A;
        }
        cmap = soc_port_cmap_get(unit, port_idx);
        
        if (cmap != NULL) {
            counter_reg = cmap->cmap_base[counter_idx].reg;
            if (SOC_REG_IS_VALID(unit, counter_reg)) {
                counter_name = SOC_REG_NAME(unit, counter_reg);
                soc_cm_debug(DK_ERR,
                             "%s %s port %d %s entry %d parity error\n",
                             prefix_str, mem_str, port_idx, counter_name,
                             entry_idx);
                if (multiple) {
                    soc_cm_debug(DK_ERR,
                                 "%s %s has multiple parity errors\n",
                                 prefix_str, mem_str);
                }
                spci.flags = SOC_SER_SRC_REG | SOC_SER_REG_MEM_KNOWN;
                spci.reg = counter_reg;
                spci.mem = INVALIDm;
                spci.blk_type = block;
                spci.port = port_idx;
                (void)soc_ser_correction(unit, &spci);
                _stat_error_fixed[unit]++;
            } else {
                soc_cm_debug(DK_ERR,
                             "%s %s parity hardware inconsistency\n",
                             prefix_str, mem_str);
            }
        } else {
            soc_cm_debug(DK_ERR, "cmap is NULL\n");
        }
    } else if (!schan) {
        soc_cm_debug(DK_ERR,
                     "%s %s parity hardware inconsistency\n",
                     prefix_str, mem_str);
    }

    /* Clear parity status */
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, 0));

    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_process_info(int unit, soc_port_t port,
                                 soc_reg_t group_reg,
                                 uint32 group_rval,
                                 const _soc_katana2_parity_info_t *info_list,
                                 char *prefix_str,
                                 soc_block_t block)
{
    const _soc_katana2_parity_info_t *info;
    int info_index;
    char *mem_str;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }

        /* Check status for the info entry in the group register */
        if (!soc_reg_field_get(unit, group_reg, group_rval,
                               info->group_reg_status_field)) {
            continue;
        }

        if (info->mem_str) {
            mem_str = info->mem_str;
        } else if (info->mem != INVALIDm) {
            mem_str = SOC_MEM_NAME(unit, info->mem);
        } else {
            mem_str = SOC_FIELD_NAME(unit, info->group_reg_status_field);
        }

        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, info->type,
                           info->mem, info->group_reg_status_field);

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_GENERIC:
            soc_cm_debug(DK_ERR, "%s %s asserted\n", prefix_str, mem_str);
            break;
        case _SOC_PARITY_TYPE_PARITY:
            /* PARITY_ERRf, MULTIPLE_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_parity(unit, port, info, FALSE,
                                                   prefix_str, mem_str, block));
            break;
        case _SOC_PARITY_TYPE_ECC:
            /* ECC_ERRf, MULTIPLE_ERRf, DOUBLE_BIT_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_ecc(unit, port, info, FALSE,
                                                 prefix_str, mem_str, block));
            break;
        case _SOC_PARITY_TYPE_HASH:
            /* PARITY_ERR_BMf, MULTIPLE_ERRf, BUCKET_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_hash(unit, port, info, FALSE,
                                                  prefix_str, mem_str, block));
            break;
        case _SOC_PARITY_TYPE_EDATABUF:
            /* ECC_ERR_MGRPf, ECC_ERR_2B_MGRPf, ECC_MULTI_MGRPf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_edatabuf(unit, port, info, FALSE,
                                                      prefix_str, mem_str));
            break;
        case _SOC_PARITY_TYPE_COUNTER:
            /* PARITY_ERRf, MULTIPLE_ERRf, COUNTER_IDXf, PORT_IDX,
               ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_counter(unit, port, info, FALSE,
                                                   prefix_str, mem_str, block));
            break;
        default:
            break;
        } /* Handle different parity error reporting style */
    } /* Loop through each info entry in the list */

    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_process_all(int unit)
{
    const _soc_katana2_parity_route_block_t *route_block;
    int route_block_index, block_idx;
    soc_port_t port;
    soc_reg_t route_block_en_reg, route_block_reg;
    uint32 cmic_rval, route_block_rval;
    uint32 route_block_enable;
    uint32 cmic_bit;
    char prefix_str[10];
    
    port = REG_PORT_ANY;
    sal_sprintf(prefix_str, "unit %d", unit);

    /* Read CMIC parity status register */
    SOC_IF_ERROR_RETURN
        (READ_CMIC_CMC0_IRQ_STAT2r(unit, &cmic_rval));
    if (cmic_rval == 0) {
        return SOC_E_NONE;
    }

    /* Loop through each place-and-route block entry */
    for (route_block_index = 0; ; route_block_index++) {
        route_block = &_soc_katana2_parity_route_blocks[route_block_index];
        cmic_bit = route_block->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }

        /* Check status for the route block in the CMIC register */
        if (!(cmic_rval & cmic_bit)) {
            /* No interrupt bit asserted for the route block */
            continue;
        }

        /* get block and port for MXQ and RXLP and TXLP */
        if ((route_block->blocktype == SOC_BLK_MXQPORT) ||
            (route_block->blocktype == SOC_BLK_TXLP) ||
            (route_block->blocktype == SOC_BLK_RXLP)) {
            SOC_BLOCK_ITER(unit, block_idx, route_block->blocktype) {
                if (SOC_BLOCK_INFO(unit, block_idx).number == route_block->id) {
                    port = SOC_BLOCK_PORT(unit, block_idx);
                    break;
                }
            }
        }

        /* Read per route block parity status register */
        route_block_reg = route_block->status_reg;
        route_block_en_reg = route_block->enable_reg;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, route_block_reg, port, 0, &route_block_rval));
        if (route_block_rval == 0) {
            continue;
        }
        if (route_block->blocktype == SOC_BLK_MMU) {
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_mmu(unit, route_block_en_reg, 
                                                route_block_reg, prefix_str));
        } else {
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_info(unit,
                                                  port,
                                                  route_block_reg,
                                                  route_block_rval,
                                                  route_block->info,
                                                  prefix_str,
                                                  route_block->blocktype));

            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, route_block_en_reg, port, 0, &route_block_enable));
            route_block_enable &= ~route_block_rval;
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, route_block_en_reg, port, 0, route_block_enable));
            route_block_enable |= route_block_rval;
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, route_block_en_reg, port, 0, route_block_enable));
        }
    } /* Loop through each place-and-route block entry */

    return SOC_E_NONE;
}

void
soc_katana2_parity_error(void *unit_vp, void *d1, void *d2, void *d3, void *d4)
{
    int unit = PTR_TO_INT(unit_vp);

    (void)_soc_katana2_parity_process_all(unit);
    sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Don't reenable too soon */
    if (d2 != NULL) {
        (void)soc_cmicm_intr2_enable(unit, PTR_TO_INT(d2));
    }
}

STATIC int
_soc_katana2_mem_nack_process_info(int unit, int reg_mem,
                                   _kt2_ser_nack_reg_mem_t nack_reg_mem,
                                   soc_block_t block,
                                   const _soc_katana2_parity_info_t *info_list,
                                   char *prefix_str)
{
    const _soc_katana2_parity_info_t *info;
    int info_index;
    char *mem_str;
    soc_port_t port = REG_PORT_ANY;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }
        if (reg_mem == _SOC_KT2_SER_MEM && info->mem != nack_reg_mem.mem) {
            continue;
        }
        if (info->mem_str) {
            mem_str = info->mem_str;
        } else {
            mem_str = SOC_MEM_NAME(unit, info->mem);
        }

        if (reg_mem == _SOC_KT2_SER_REG && info->type != _SOC_PARITY_TYPE_COUNTER) {
            continue;
        }

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_PARITY:
            /* PARITY_ERRf, MULTIPLE_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_parity(unit, port, info, TRUE,
                                                    prefix_str, mem_str, block));
            break;
        case _SOC_PARITY_TYPE_ECC:
            /* ECC_ERRf, MULTIPLE_ERRf, DOUBLE_BIT_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_ecc(unit, port, info, TRUE,
                                                 prefix_str, mem_str, block));
            break;
        case _SOC_PARITY_TYPE_HASH:
            /* PARITY_ERR_BMf, MULTIPLE_ERRf, BUCKET_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_hash(unit, port, info, TRUE,
                                                  prefix_str, mem_str, block));
            break;
        case _SOC_PARITY_TYPE_EDATABUF:
            /* ECC_ERR_MGRPf, ECC_ERR_2B_MGRPf, ECC_MULTI_MGRPf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_edatabuf(unit, port, info, TRUE,
                                                      prefix_str, mem_str));
            break;
        case _SOC_PARITY_TYPE_COUNTER:
            /* PARITY_ERRf, MULTIPLE_ERRf, COUNTER_IDXf, PORT_IDX,
               ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_counter(unit, port, info, TRUE,
                                                     prefix_str, mem_str, block));
            break;
        default:
            break;
        } /* Handle different parity error reporting style */
    } /* Loop through each info entry in the list */

    return SOC_E_NONE;
}


STATIC int
_soc_katana2_mem_nack_error_process(int unit, 
                                   _kt2_ser_nack_reg_mem_t nack_reg_mem, 
                                   soc_block_t block, 
                                   int reg_mem)
{
    const _soc_katana2_parity_route_block_t *route_block;
    int route_block_index;
    uint32 cmic_bit;
    char prefix_str[10];

    sal_sprintf(prefix_str, "unit %d", unit);

    /* Loop through each place-and-route block entry */
    for (route_block_index = 0; ; route_block_index++) {
        route_block = &_soc_katana2_parity_route_blocks[route_block_index];
        cmic_bit = route_block->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }

        if (route_block->info == NULL) {
            continue;
        }
        SOC_IF_ERROR_RETURN
            (_soc_katana2_mem_nack_process_info(unit, 
                                                reg_mem, nack_reg_mem, block,
                                                route_block->info,
                                                prefix_str));
    } /* Loop through each place-and-route block entry */

    return SOC_E_NONE;
}

void
soc_katana2_stat_nack(int unit, int *fixed)
{
    int rv;
    _kt2_ser_nack_reg_mem_t nack_reg_mem;

    nack_reg_mem.mem = -1;
    nack_reg_mem.reg = -1;
    _stat_error_fixed[unit] = 0;

    if ((rv = _soc_katana2_mem_nack_error_process(unit, nack_reg_mem, 0, 
        _SOC_KT2_SER_REG)) < 0) {
        soc_cm_debug(DK_ERR,
            "unit %d STAT SCHAN NACK analysis failure.\n", unit);
    }
    *fixed = _stat_error_fixed[unit];
}

void
soc_katana2_mem_nack(void *unit_vp, void *addr_vp, void *blk_vp, 
                     void *d3, void *d4)
{
    soc_mem_t mem = INVALIDm;
    int reg_mem = PTR_TO_INT(d3);
    int rv, unit = PTR_TO_INT(unit_vp);
    uint32 address = PTR_TO_INT(addr_vp);
    uint32 block = PTR_TO_INT(blk_vp);
    uint32 offset = 0, min_addr = 0, max_addr = 0;
    soc_regaddrinfo_t ainfo;
    _kt2_ser_nack_reg_mem_t nack_reg_mem;

    if (reg_mem == _SOC_KT2_SER_REG) {
        if (address) {
            soc_regaddrinfo_get(unit, &ainfo, address);
            nack_reg_mem.reg = ainfo.reg;
        }
    } else {
        offset = address & ~0xC0f00000; /* Strip block ID */
        mem = soc_addr_to_mem_extended(unit, block, 0, address);
        if (mem == INVALIDm) {
            soc_cm_debug(DK_ERR, "unit %d mem decode failed, "
                         "SCHAN NACK analysis failure\n", unit);
            return;
        }
        
        _soc_katana2_mem_rename(&mem);
        nack_reg_mem.mem = mem;

        min_addr = max_addr = SOC_MEM_INFO(unit, mem).base;
        min_addr += SOC_MEM_INFO(unit, mem).index_min;
        max_addr += SOC_MEM_INFO(unit, mem).index_max;
    }

    if ((rv = _soc_katana2_mem_nack_error_process(unit, nack_reg_mem, block,
        reg_mem)) < 0) {
        if (reg_mem == _SOC_KT2_SER_REG) {
            soc_cm_debug(DK_ERR,
                         "unit %d REG SCHAN NACK analysis failure\n",
                         unit);
        } else {
            soc_cm_debug(DK_ERR,
                         "unit %d %s entry %d SCHAN NACK analysis failure\n",
                         unit, SOC_MEM_NAME(unit, mem),
                         min_addr - offset);
        }
    }
    
    if (reg_mem == _SOC_KT2_SER_REG) {
            soc_cm_debug(DK_ERR,
                         "unit %d REG SCHAN NACK analysis\n",
                         unit);
    } else {
        soc_cm_debug(DK_SCHAN,
                     "unit %d %s entry %d SCHAN NACK analysis\n",
                     unit, SOC_MEM_NAME(unit, mem),
                     min_addr - offset);
    }
}

/* SER processing for TCAMs */
STATIC _soc_generic_ser_info_t _soc_kt2_tcam_ser_info[] = {
    
    { MY_STATION_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0 },
    { L2_USER_ENTRYm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 61}, {1, 61}, {62, 122}, {63, 122} }, 0, 0, 0 }, /* may be 62 */
    { VLAN_SUBNETm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 64}, {1, 64}, {65, 128}, {66, 128} }, 0, 0, 0 },
    { L3_DEFIP_PAIR_128m, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_8BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 95}, {96, 189}, {190, 285}, {286, 379} }, 0, 0, 0 },
    { L3_DEFIPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 95}, {1, 95}, {96, 189}, {97, 189} }, 0, 0, 0 },
    { CPU_COS_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 140}, {1, 140}, {141, 280}, {142, 280} }, 0, 0, 0 },
    { EFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0 },
    { FP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_1BIT,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0 },
    { VFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2, 
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0 },
    { FP_UDF_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 69}, {1, 69}, {70, 138}, {71, 160} }, 0, 0, 0 },
    { INVALIDm },
};

void
soc_katana2_ser_fail(int unit)

{
    soc_generic_ser_process_error(unit, _soc_kt2_tcam_ser_info,
                                  _SOC_PARITY_TYPE_SER);
}

#define SOC_KT2_SER_MEM_AVAILABLE (4096 * 32)  /* bits */

STATIC int
_soc_katana2_ser_init(int unit)
{
    return soc_generic_ser_init(unit, &_soc_kt2_tcam_ser_info[0]);
}

void
soc_kt2_ser_fail(int unit)
{
    soc_generic_ser_process_error(unit, _soc_kt2_tcam_ser_info,
                                       _SOC_PARITY_TYPE_SER);
    return;
}

STATIC int
_soc_katana2_parity_block_port(int unit, soc_block_t block, soc_port_t *port)
{
    *port = SOC_BLOCK_PORT(unit, block);
    if ((*port != REG_PORT_ANY) && !SOC_PORT_VALID(unit, *port)) {
        return SOC_E_PORT;
    }

    return SOC_E_NONE;
}

int
_soc_katana2_mem_nack_error_test(int unit, _soc_ser_test_t test_type, int *testErrors)
{
    int group, table;
    _soc_katana2_parity_info_t *info;
    soc_mem_t mem;
    soc_port_t block_port = 0;
    soc_block_t blk;
    uint32 test_count = 0;

    /* loop through each group */
    for (group = 0; _soc_katana2_parity_route_blocks[group].cmic_bit; group++) {
        info = _soc_katana2_parity_route_blocks[group].info;
        
        if (_soc_katana2_parity_route_blocks[group].blocktype == SOC_BLK_MMU) {
            continue;
        } else {
            SOC_BLOCK_ITER(unit, blk,_soc_katana2_parity_route_blocks[group].blocktype) {
                if (_soc_katana2_parity_block_port(unit, blk, &block_port) < 0) {
                    continue;
                }
                
                for (table = 0; info[table].type != _SOC_PARITY_TYPE_NONE; table++) {
                    mem = info[table].mem;
                    if (mem == INVALIDm) {
                        continue;
                    }
                        
                    if ((info[table].enable_reg == INVALIDr) ||
                        !soc_reg_field_valid(unit, info[table].enable_reg,
                                info[table].enable_field)) {
                        soc_cm_debug(DK_ERR,
                            "unit %d %s has no parity toggle\n",
                            unit, SOC_MEM_NAME(unit, mem));
                        continue;
                    }
                    switch (info[table].type) {
                        case _SOC_PARITY_TYPE_PARITY:
                        case _SOC_PARITY_TYPE_COUNTER:
                        break;
                        
                        default:
                        /* No field to check. */
                        continue;
                    }
                    test_count++;
                    soc_cm_print(" nack test mem: %s; %d\n", SOC_MEM_NAME(unit, mem), mem);
                    ser_test_mem_pipe(unit,info[table].enable_reg, -1, info[table].enable_field,
                             mem, INVALIDf, test_type, MEM_BLOCK_ANY, block_port, -1, testErrors);
                }
            }
        }
    }
    soc_cm_print("Hardware SER memories tested: %u\n",test_count);
    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_katana2_ser_mem_test
 * Purpose:
 *      Performs a SER test on a single TR2 memory
 * Parameters:
 *      unit               - (IN) Device Number
 *      mem                - (IN) The memory to test
 *      test_type        - (IN) How many indices in the memory to test
 *
 */
int soc_katana2_ser_mem_test(int unit, soc_mem_t mem, _soc_ser_test_t test_type, int cmd) {
    int group, table, i, rv;
    _soc_katana2_parity_info_t *info;
    soc_mem_t memTable;
    soc_port_t block_port=0;
    soc_block_t blk;
    int testErrors = 0;
    
    /*Prevent compiler error for common function signature.*/
    (void) cmd;
    
    /*TCAM_test*/
    for (i = 0; _soc_kt2_tcam_ser_info[i].mem != INVALIDm; i++) {
        if (_soc_kt2_tcam_ser_info[i].mem == mem) {
            rv = ser_test_mem_pipe(unit, SER_RANGE_ENABLEr, i, -1,
                            _soc_kt2_tcam_ser_info[i].mem, INVALIDf, test_type, MEM_BLOCK_ANY,
                            REG_PORT_ANY, -1, &testErrors);
                            
            if (rv != SOC_E_NONE) {
                soc_cm_print("Error during TCAM test.  Aborting.\n");
                return rv;
            }
        }
    }
    
    /*H/W memory Test*/
    for (group = 0; _soc_katana2_parity_route_blocks[group].cmic_bit; group++) {
        info = _soc_katana2_parity_route_blocks[group].info;
        
        if (_soc_katana2_parity_route_blocks[group].blocktype == SOC_BLK_MMU) {
            continue;
        } else {
            SOC_BLOCK_ITER(unit, blk,_soc_katana2_parity_route_blocks[group].blocktype) {
                if (_soc_katana2_parity_block_port(unit, blk, &block_port) < 0) {
                    continue;
                }

                for (table = 0; info[table].type != _SOC_PARITY_TYPE_NONE; table++) {
                    memTable = info[table].mem;
                    if (memTable == INVALIDm) {
                        continue;
                    }
                    if (memTable == mem) {
                        rv = ser_test_mem_pipe(unit,info[table].enable_reg, -1,
                                               info[table].enable_field, mem, INVALIDf, test_type,
                                               MEM_BLOCK_ANY, block_port, -1, &testErrors);
                        if (rv != SOC_E_NONE) {
                            soc_cm_print("Error during H/W test.  Aborting.\n");
                            return rv;
                        }
                    }
                }
            }
        }
    }
    if (testErrors == 0) {
        soc_cm_print("SER Test passed on unit: %d for memory %s\n ", unit, SOC_MEM_NAME(unit,mem));
    } else {
        soc_cm_print("SER Test failed on unit: %d for memory %s\n", unit, SOC_MEM_NAME(unit,mem));
        return SOC_E_MEMORY;
    }
    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_katana2_ser_test
 * Purpose:
 *      Performs a SER test on all TR2 Memories
 * Parameters:
 *      unit               - (IN) Device Number
 *      test_type        - (IN) Determines how comprehensive of a test to run
 *
 */
int soc_katana2_ser_test(int unit, _soc_ser_test_t test_type) {
    int i, rv;
    int numTCAMErr   = 0;
    int numNACKErr   = 0;
    /*This is a NACK test for hardware-monitored memories*/
    rv = _soc_katana2_mem_nack_error_test(unit, test_type, &numNACKErr);
    if (rv != SOC_E_NONE) {
        soc_cm_print("Error during H/W test.  Aborting.\n");
        return rv;
    }
    /*This is a NACK test for TCAM memories*/
    /*Test each TCAM memory*/
    for(i = 0; i < COUNTOF(_soc_kt2_tcam_ser_info) - 1; i++) {
        rv = ser_test_mem_pipe(unit, SER_RANGE_ENABLEr, i, -1,
                _soc_kt2_tcam_ser_info[i].mem, INVALIDf, test_type, MEM_BLOCK_ANY,
                REG_PORT_ANY, -1, &numTCAMErr);
                if (rv != SOC_E_NONE) {
                    soc_cm_print("Error during TCAM test.  Aborting.\n");
                    return rv;
                }
    }
    soc_cm_print("Total H/W parity errors on unit %d: %d\n",unit, numNACKErr);
    soc_cm_print("Total TCAM errors on unit %d: %d\n", unit, numTCAMErr);
    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_katana2_ser_inject_error
 * Purpose:
 *      Performs a SER test on a single TR2 memory
 * Parameters:
 *      unit               - (IN) Device Number
 *      mem                - (IN) The memory to test
 *      test_type        - (IN) How many indices in the memory to test
 *
 */
int soc_katana2_ser_inject_error(int unit, soc_mem_t mem, int pipeTarget, int block, int index) {
    int group, table, i;
    _soc_katana2_parity_info_t *info;
    soc_mem_t memTable;
    soc_port_t block_port = 0;
    soc_block_t blk;
    ser_test_data_t test_data;
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], fieldData[SOC_MAX_MEM_FIELD_WORDS];
    test_data.index = index;
    test_data.entry_buf = tmp_entry;
    test_data.field_buf = fieldData;
    
    /*TCAM_test*/
    for (i = 0; _soc_kt2_tcam_ser_info[i].mem != INVALIDm; i++) {
        if (_soc_kt2_tcam_ser_info[i].mem == mem) {
            test_data.mem = mem;
            test_data.tcam_parity_bit = i;
            test_data.parity_enable_reg = SER_RANGE_ENABLEr;
            test_data.parity_enable_field = INVALIDf;
            test_data.mem_block = MEM_BLOCK_ANY;
            test_data.port = REG_PORT_ANY;
            test_data.acc_type = _SOC_ACC_TYPE_PIPE_ANY;
            test_data.mem_info = &SOC_MEM_INFO(unit,test_data.mem);
            /*Read the memory for successful injection*/
            SOC_IF_ERROR_RETURN(ser_test_mem_read(unit, &test_data));
            /*Disable parity*/
            SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 0));
            /*Inject error*/            
            SOC_IF_ERROR_RETURN(soc_ser_test_inject_error(unit, &test_data));
            /*Enable parity*/
            SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 1));
            return SOC_E_NONE;
        }
    }
    
    /*H/W memory Test*/
    for (group = 0; _soc_katana2_parity_route_blocks[group].cmic_bit; group++) {
        info = _soc_katana2_parity_route_blocks[group].info;
        
        if (_soc_katana2_parity_route_blocks[group].blocktype == SOC_BLK_MMU) {
            continue;
        } else {
        
            SOC_BLOCK_ITER(unit, blk,_soc_katana2_parity_route_blocks[group].blocktype) {
                if (_soc_katana2_parity_block_port(unit, blk, &block_port) < 0) {
                    continue;
                }
                   
               for (table = 0; info[table].type != _SOC_PARITY_TYPE_NONE; table++) {
                   memTable = info[table].mem;
                   if (memTable == INVALIDm) {
                       continue;
                   }
                   if (memTable == mem) {
                       if((blk == block) || (block == MEM_BLOCK_ANY)) {
                           /*Inject error*/
                           test_data.mem = mem;
                           test_data.tcam_parity_bit = -1;
                           test_data.parity_enable_reg = info[table].enable_reg;
                           test_data.parity_enable_field = info[table].enable_field;
                           test_data.mem_block = blk;
                           test_data.port = block_port;
                           test_data.acc_type = _SOC_ACC_TYPE_PIPE_ANY;
                           test_data.mem_info = &SOC_MEM_INFO(unit,test_data.mem);
                           /*Read the memory for successful injection*/
                           SOC_IF_ERROR_RETURN(ser_test_mem_read(unit, &test_data));
                           /*Disable parity*/
                           SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 0));
                           /*Inject error*/
                           SOC_IF_ERROR_RETURN(soc_ser_test_inject_error(unit, &test_data));
                           /*Enable parity*/
                           SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 1));
                       }
                   }
               } 
           } 
       } 
   }
    return SOC_E_NONE;
}

STATIC soc_kt2_oam_handler_t kt2_oam_handler[SOC_MAX_NUM_DEVICES] = {NULL};
extern int _soc_ddr_shmoo_prepare_for_shmoo(int unit, int ci);
typedef struct _soc_katana2_ci_parama_s {
    uint32          speed;
    uint32          grade;
} _soc_katana2_ci_parama_t;

/* 56450 TDM sequence */

/* 0:CMIC Port  1-40:Physical Ports  41:Loopback Port */
#define KT2_MAX_LOGICAL_PORTS         42
#define KT2_MAX_PHYSICAL_PORTS        40

uint32 mxqspeeds[SOC_MAX_NUM_DEVICES][KT2_MAX_MXQBLOCKS]
              [KT2_MAX_MXQPORTS_PER_BLOCK]={{
              {10000,2500,0,2500},{10000,2500,0,2500},{10000,2500,0,2500},
              {10000,2500,0,2500},{10000,2500,0,2500},{10000,2500,0,2500},
              {13000,2500,0,2500},{13000,2500,0,2500},
              {21000,10000,0,2500},{21000,10000,0,2500},
              {2500,0,0,0}}};
uint32 kt2_current_tdm[256]={0};
uint32 kt2_current_tdm_size=0;

int mxqblock_max_startaddr[KT2_MAX_MXQBLOCKS]={0};
int mxqblock_max_endaddr[KT2_MAX_MXQBLOCKS]={0};

static uint8  old_tdm_no=0;

/* --------*/
/* DEFAULT */
/* --------*/
#ifdef PLISIM
static uint32 kt2_default_port_config=0;
#else
static uint32 kt2_default_port_config=4;
#endif

/* bcm5645x_config=0 */
/* Deprecated=0 24x GE + 16*2.5GE(HG-LIT) */
/* 24xGE(1..24) + 16*2.5GE(HG-LIT)(25..40) */
uint32 kt2_tdm_56450config_deprecated0[88]= {
1,              5,      9,      13,     17,     21,25,26,27,28,KT2_LPBK_PORT,
2,              6,      10,     14,     18,     22,35,38,32,29,KT2_CMIC_PORT,
3,              7,      11,     15,     19,     23,36,39,33,30,KT2_IDLE,
4,              8,      12,     16,     20,     24,37,40,34,31,KT2_IDLE1,
KT2_IDLE1,    KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,25,26,27,28,
KT2_LPBK_PORT,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,35,38,32,29,
KT2_CMIC_PORT,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,36,39,33,30,
KT2_IDLE,     KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,37,40,34,31
};

/* 24xGE(1..24) + 16*2.5GE(HG-LIT)(25..40) */
uint32 kt2_tdm_56450speed_deprecated0[40]= {
       1000,1000,1000,1000,     /* 1 - 4   */
       1000,1000,1000,1000,     /* 5 - 8   */
       1000,1000,1000,1000,     /* 9 - 12  */
       1000,1000,1000,1000,     /* 13 - 16 */
       1000,1000,1000,1000,     /* 17 - 20 */
       1000,1000,1000,1000,     /* 21 - 24 */
       2500,2500,2500,2500,     /* 25 - 28 */
       2500,2500,2500,2500,     /* 29 - 32 */
       2500,2500,2500,2500,     /* 33 - 36 */
       2500,2500,2500,2500};    /* 37 - 40 */
soc_port_details_t kt2_port_details_deprecated0[]={
    {1,24,1,GE_PORT,1000},
#ifdef PLISIM
    {25,40,1,HGL_PORT|STK_PORT,2500}, 
#else
    {25,40,1,GE_PORT,2500}, 
#endif
    {0,0,0,0} /* End */
};

const static uint32 kt2_tdm_56450AA_ref[88]= {
1,              5,      9,      13,     17,     21,25,26,27,28,KT2_LPBK_PORT,
2,              6,      10,     14,     18,     22,35,38,32,29,KT2_CMIC_PORT,
3,              7,      11,     15,     19,     23,36,39,33,30,KT2_IDLE,
4,              8,      12,     16,     20,     24,37,40,34,31,KT2_IDLE1,
KT2_IDLE1,      1,      5,      9,      13,     17,21,25,26,27,28,
KT2_LPBK_PORT,  2,      6,      10,     14,     18,22,35,38,32,29,
KT2_CMIC_PORT,  3,      7,      11,     15,     19,23,36,39,33,30,
KT2_IDLE,       4,      8,      12,     16,     20,24,37,40,34,31
};


const static uint32 kt2_tdm_56450A_ref[88]= {
1,              5,      9,      27,     30,     13,17,21,33,28,KT2_LPBK_PORT,
1,              5,      9,      27,     30,     13,17,21,33,28,KT2_CMIC_PORT,
1,              5,      9,      27,     30,     13,17,21,33,28,KT2_OLP_PORT,
1,              5,      9,      27,     30,     13,17,21,33,28,KT2_IDLE1,
KT2_IDLE1,      1,      5,      9,      27,     30,13,17,21,33,28,
KT2_LPBK_PORT,  1,      5,      9,      27,     30,13,17,21,33,28,
KT2_CMIC_PORT,  1,      5,      9,      27,     30,13,17,21,33,28,
KT2_OLP_PORT,   1,      5,      9,      27,     30,13,17,21,33,28
};
const static uint32 kt2_tdm_56450A1_ref[108]= { 
9,             25, 27,            28,            13, 26, 9,  27,       28,
KT2_LPBK_PORT, 25, KT2_CMIC_PORT, 27,            28, 26, 13, 9,        27,
28,            25, KT2_IDLE1,     KT2_IDLE1,     27, 26, 28, 13,       9,
27,            25, 28,            3,             13, 26, 27, 28,   KT2_OLP_PORT,
9,             25, 27,            28,            5,  26, 13, 27,       28,
KT2_LPBK_PORT, 25, 9,             27,            28, 26, 7,  13,       27,
28,            25, 1,             9,             27, 26, 28, KT2_IDLE, 13,
27,            25, 28,            KT2_CMIC_PORT, 9,  26, 27, 28,   KT2_OLP_PORT,
13,            25, 27,            28,            6,  26, 9,  27,        28,
KT2_LPBK_PORT, 25, 13,            27,            28, 26, 8,  9,         27,
28,            25, 2,             13,            27, 26, 28, KT2_IDLE,  9,
27,            25, 28,            4,             13, 26, 27, 28,   KT2_OLP_PORT
};
const static uint32 kt2_tdm_56450A2_ref[99]= {
KT2_IDLE1,     25, 9,            26, 21,            27, 17,            28,   13,
KT2_CMIC_PORT, 25, KT2_OLP_PORT, 26, 9,             27, 21,            28,   17,
1,             25, 13,           26, KT2_LPBK_PORT, 27, 9,             28,   21,
2,             25, 17,           26, 13,            27, KT2_CMIC_PORT, 28,   9,
3,             25, 21,           26, 17,            27, 13,            28,   8,
9,             25, KT2_OLP_PORT, 26, 21,            27, 17,            28,   13,
4,             25, 9,            26, KT2_LPBK_PORT, 27, 21,            28,   17,
13,            25, 5,            26, 9,             27, KT2_CMIC_PORT, 28,   21,
17,            25, 13,           26, 6,             27, 9,             28,   
                                                                  KT2_LPBK_PORT,
21,            25, 17,           26, 13,            27, KT2_OLP_PORT,  28,   9,
7,             25, 21,           26, 17,            27, 13,            28,   
                                                                   KT2_IDLE1
};
const static uint32 kt2_tdm_56455C_ref[84]= {
KT2_LPBK_PORT,  9,	      17,	        25,	26,	27,	28,
KT2_CMIC_PORT, 10,	      18,	        25,	26,	27,	28,
1,	       KT2_LPBK_PORT, 19,	        25,	26,	27,	28,
2,	       11,            20,	        25,	26,	27,	28,
3,	       12,	      KT2_LPBK_PORT,	25,	26,	27,	28,
4,	       13,	      KT2_CMIC_PORT,	25,	26,	27,	28,
KT2_LPBK_PORT, 14,	      21,	        25,	26,	27,	28,
KT2_IDLE,      15,	      22,	        25,	26,	27,	28,
5,	       KT2_LPBK_PORT, 23,	        25,	26,	27,	28,
6,	       KT2_CMIC_PORT, 24,	        25,	26,	27,	28,
7,	       16,	      KT2_LPBK_PORT,	25,	26,	27,	28,
8,	       KT2_IDLE1,     KT2_IDLE1,	25,	26,	27,	28
};

const static uint32 kt2_tdm_56454D_ref[20] = {
KT2_IDLE1,	1,	5,	27,	28,	
2,		6,	27,	28,	KT2_LPBK_PORT,
3,		7,	27,	28,	KT2_CMIC_PORT,
4,		8,	27,	28,	KT2_IDLE1,
};

/* bcm5645x_config=1 */

/* 8 x F.XAUI(1,,5,9,13,17,21,25,26)    2 x W10G = 2 x XFI (27,28) */
static uint32 kt2_tdm_56450A_1[88]={0}; /* Will be filled-up at run time */
static uint32 kt2_tdm_56450speed_1[40]= {
       10000,0000,0000,0000,     /* 1  - 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       10000,0000,0000,0000,     /* 9  - 12  */
       10000,0000,0000,0000,     /* 13 - 16  */
       10000,0000,0000,0000,     /* 17 - 20  */
       10000,0000,0000,0000,     /* 21 - 24  */
       10000,10000,10000,10000,  /* 25 - 28  */
       0000,0000,0000,0000,      /* 29 - 32  */
       0000,0000,0000,0000,      /* 33 - 36  */
       0000,0000,0000,0000};     /* 37 - 40  */

/* Config=1 8xF.XAUI  2xW10G */
/* 2 XFI */
soc_port_details_t kt2_port_details_config1[]={
    {1,25,4,XE_PORT,10000}, /* 7 F.XAUI */
    {26,28,1,XE_PORT,10000},/* 1 F.XAUI + 2 XFI */
    {0,0,0,0} /* End */
};  

/* bcm5645x_config=2 */

/* 7 x F.XAUI + 1 x XAUI(1,5,9,13,17,21,25,26)  2 x W10G = 2 x XFI (27,28) */
static uint32 kt2_tdm_56450A_2[88]={0}; /* Will be filled-up at run time */
static uint32 kt2_tdm_56450speed_2[40]= {
       10000,0000,0000,0000,     /* 1  - 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       10000,0000,0000,0000,     /* 9  - 12  */
       10000,0000,0000,0000,     /* 13 - 16  */
       10000,0000,0000,0000,     /* 17 - 20  */
       10000,0000,0000,0000,     /* 21 - 24  */
       10000,10000,10000,10000,  /* 25 - 28  */
       0000,0000,0000,0000,      /* 29 - 32  */
       0000,0000,0000,0000,      /* 33 - 36  */
       0000,0000,0000,2500};     /* 37 - 40  */
/* Config=2 7 x F.XAUI + 1 x XAUI + 2 x W10G */
/* 2XFI + OLP */
soc_port_details_t kt2_port_details_config2[]={
    {1,25,4,XE_PORT,10000}, /* 7 F.XAUI */
    {26,28,1,XE_PORT,10000},/* 1 XAUI Fixed + 2 XFI*/
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=3 */

/* 7 x F.XAUI(1,5,9,13,17,21,25)        1xW10G + 1xW20G (3 x XFI)(27,28,30) */
static uint32 kt2_tdm_56450A_3[88]={0}; /* Will be filled-up at run time */
static uint32 kt2_tdm_56450speed_3[40]= {
       10000,0000,0000,0000,     /* 1  - 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       10000,0000,0000,0000,     /* 9  - 12  */
       10000,0000,0000,0000,     /* 13 - 16  */
       10000,0000,0000,0000,     /* 17 - 20  */
       10000,0000,0000,0000,     /* 21 - 24  */
       10000,0000,10000,10000,   /* 25 - 28  */
       0000,10000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,      /* 33 - 36  */
       0000,0000,0000,2500};     /* 37 - 40  */
/* Config=3 7 x F.XAUI	1 x W10G + 1 x W20G */
/* 3XFI + OLP */
soc_port_details_t kt2_port_details_config3[]={
    {1,25,4,XE_PORT,10000}, /* 7 F.XAUI */
    {27,28,1,XE_PORT,10000},/* 2 XFI */
    {30,30,1,XE_PORT,10000},/* 1 XFI */
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=4 */

/* 6 x F.XAUI(1,5,9,13,17,21)   2 x W20G (4 x XFI) 27,33,28,30 */
static uint32 kt2_tdm_56450A_4[88]={0};
static uint32 kt2_tdm_56450speed_4[40]= {
       10000,0000,0000,0000,     /* 1  - 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       10000,0000,0000,0000,     /* 9  - 12  */
       10000,0000,0000,0000,     /* 13 - 16  */
       10000,0000,0000,0000,     /* 17 - 20  */
       10000,0000,0000,0000,     /* 21 - 24  */
       0000,0000,10000,10000,    /* 25 - 28  */
       0000,10000,0000,0000,     /* 29 - 32  */
       10000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};     /* 37 - 40  */
/* Config=4 6 x F.XAUI	2 x W20G */
/* 4XFI + OLP */
soc_port_details_t kt2_port_details_config4[]={
    {1,21,4,XE_PORT,10000}, /* 6 F.XAUI */
    {27,28,1,XE_PORT,10000},/* 2 XFI */
    {30,33,3,XE_PORT,10000}, /* 2 XFI */
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=5 */

/* 4 x F.XAUI(1,5,9,13) 1 x W20G(27,33) + 1 x W40G (28,26,30,39)         */
/* MXQ8:27,33 MXQ9:28,30 */
/* ##MXQ7:26,39 Indirectly used */
/* ##MXQ6(25,36) Not used       */
static uint32 kt2_tdm_56450A_5[88]={0};
static unsigned int kt2_tdm_56450speed_5[40]= {
       10000,0000,0000,0000,     /* 1  - 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       10000,0000,0000,0000,     /* 9  - 12  */
       10000,0000,0000,0000,     /* 13 - 16  */
       0000,0000,0000,0000,      /* 17 - 20  */
       0000,0000,0000,0000,      /* 21 - 24  */
       0000,10000,10000,10000,   /* 25 - 28  */
       0000,10000,0000,0000,     /* 29 - 32  */
       10000,0000,0000,00000,    /* 33 - 36  */
       0000,0000,10000,2500};    /* 37 - 40  */
/* Config=5 4 x F.XAUI	1 x W20G + 1 x W40G */
/* 6XFI + OLP */
soc_port_details_t kt2_port_details_config5[]={
    {1,13,4,XE_PORT,10000}, /* 4 F.XAUI */
    {26,39,13,XE_PORT,10000}, /* 2 XFI */
    {27,33,6,XE_PORT,10000}, /* 2 XFI */
    {28,30,2,XE_PORT,10000}, /* 4 XFI */
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=6 */

/* 2 x F.XAUI (1,5)     2 x W40G=8 XFI (25,36,26,39,27,33,28,30) */
/* MXQ6=25,36      MXQ7=26,39      MXQ8=27,33      MXQ9=28,30 */
static uint32 kt2_tdm_56450A_6[88]={0};
static uint32 kt2_tdm_56450speed_6[40]= {
       10000,0000,0000,0000,     /* 1  - 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       0000,0000,0000,0000,      /* 9  - 12  */
       0000,0000,0000,0000,      /* 13 - 16  */
       0000,0000,0000,0000,      /* 17 - 20  */
       0000,0000,0000,0000,      /* 21 - 24  */
       10000,10000,10000,10000,  /* 25 - 28  */
       0000,10000,0000,0000,     /* 29 - 32  */
       10000,0000,0000,10000,    /* 33 - 36  */
       0000,0000,10000,2500};    /* 37 - 40  */
/* Config=6 2 x F.XAUI	2 x W40G */
/* 8XFI + OLP */
/* ##MXQ7:26,39 Indirectly used */
/* ##MXQ6(25,36) Indirectly used       */
soc_port_details_t kt2_port_details_config6[]={
    {1,5,4,XE_PORT,10000},
    {25,28,1,XE_PORT,10000},
    {30,39,3,XE_PORT,10000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=7 */

/* ATTN:Suspicious Configuration.Need to be double checked! */
/* 24GE + 1 F.XAUI      W40G + W20G (25,36,26,39,27,33,28,30)           */
/* MXQ6:25 MXQ8:27,33 MXQ9:28,30 ##MXQ7(26,39) Indirectly used*/

static uint32 kt2_tdm_56450A_7[88]={0};
static uint32 kt2_tdm_56450speed_7[40]= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       1000,1000,1000,1000,     /* 9  - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       1000,1000,1000,1000,     /* 17 - 20  */
       1000,1000,1000,1000,     /* 21 - 24  */
       10000,10000,10000,10000,  /* 25 - 28  */
       10000,10000,10000,0000,    /* 29 - 32  */
       10000,0000,0000,0000,   /* 33 - 36  */
       0000,0000,10000,2500};    /* 37 - 40  */
/* Config=7 24 x GE   1 x F.XAUI 1 x W40G  1 x W20G */
/* SP3 */
/* Assuming 6 XFI + OLP */
/* MXQ6:25,36 MXQ8:27,33 MXQ9:28,30 ##MXQ7(26,39) Not used*/
soc_port_details_t kt2_port_details_config7[]={
    {1,24,1,GE_PORT,1000},
    {25,25,1,XE_PORT,10000}, /* 1 F.XAUI */
    {27,33,6,XE_PORT,10000}, /* 1 XFI */
    {28,31,1,XE_PORT,10000}, /* 3 XFI */
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=8 */

/* 8x GE + 2x F-XAUI + 2x HG13 + 2x HG21 + OLP */
static uint32 kt2_tdm_56450A1_8[108]={0};
static uint32 kt2_tdm_56450speed_8[40]= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       10000,0000,0000,0000,    /* 9  - 12  */
       10000,0000,0000,0000,    /* 13 - 16  */
       0000,0000,0000,0000,     /* 17 - 20  */
       0000,0000,0000,0000,     /* 21 - 24  */
       13000,13000,21000,21000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
/* Config=8 8 x GE 2 x F.XAUI 1 x F.HG13  1 x X.HG13  2 x W21G */
soc_port_details_t kt2_port_details_config8[]={
    {1,8,1,GE_PORT,1000},
    {9,13,4,XE_PORT,10000}, /* 2 F.XAUI */
    {25,26,1,HG_PORT|STK_PORT,13000}, /* 26 Fixed XAUI */
    {27,28,1,HG_PORT|STK_PORT,21000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=9 */

/* 24x GE + 2x HG13 + 2x HG21 + OLP */
static uint32 kt2_tdm_56450A1_9[108]={0};
static uint32 kt2_tdm_56450speed_9[40]= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       1000,1000,1000,1000,     /* 9  - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       1000,1000,1000,1000,     /* 17 - 20  */
       1000,1000,1000,1000,     /* 21 - 24  */
       13000,13000,21000,21000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
/* Config=9 24 x GE 1 x F.HG13  1 x X.HG13  2 x W21G */
soc_port_details_t kt2_port_details_config9[]={
    {1,24,1,GE_PORT,1000},
    {25,26,1,HG_PORT|STK_PORT,13000},  /* 26 Fixed XAUI */
    {27,28,1,HG_PORT|STK_PORT,21000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};


/* bcm5645x_config=10 */

/* 8 x 1GbE(1..8) + 4 x F.XAUI(9,13,17,21) + 
   1 x HG[13] + 1 x F.HG[13](25,26)   2 x W13G(27,28)(NO OLP) */
static uint32 kt2_tdm_56450A2_10[99]={0};
static uint32 kt2_tdm_56450speed_10[40]= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       10000,0000,0000,0000,    /* 9  - 12  */
       10000,0000,0000,0000,    /* 13 - 16  */
       10000,0000,0000,0000,    /* 17 - 20  */
       10000,0000,0000,0000,    /* 21 - 24  */
       13000,13000,13000,13000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,0000};    /* 37 - 40  */
/* Config=10 8 x GE 4 x F.XAUI  2 x F.HG13  2 x W13G */
soc_port_details_t kt2_port_details_config10[]={
    {1,8,1,GE_PORT,1000},
    {9,21,4,XE_PORT,10000}, /* 4  F.XAUI */
    {25,28,1,HG_PORT|STK_PORT,13000},
    {0,0,0,0} /* End */
};

/* bcm5645x_config=11 */

/* 8 x 1GbE(1..8) + 4 x F.XAUI(9,13,17,21) + 1 x HG[13] + */
/* 1 x F.HG[13](25,26)   2 x W13G(27,28) */
static uint32 kt2_tdm_56450A2_11[99]={0};
static uint32 kt2_tdm_56450speed_11[40]= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       10000,0000,0000,0000,    /* 9  - 12  */
       10000,0000,0000,0000,    /* 13 - 16  */
       10000,0000,0000,0000,    /* 17 - 20  */
       10000,0000,0000,0000,    /* 21 - 24  */
       13000,13000,13000,13000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
/* Config=11 8 x 1GbE + 4 x F.XAUI + 1 x F.HG[13] + 1 x X.HG[13] 2 x W13G */
soc_port_details_t kt2_port_details_config11[]={
    {1,8,1,GE_PORT,1000},
    {9,21,4,XE_PORT,10000}, /* 4  F.XAUI */
    {25,28,1,HG_PORT|STK_PORT,13000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=12 */

/* 8 x 1GbE(1..8) + 4 x F.XAUI(9,13,17,21) + 1 x HG[13](25) */
/* 1x W13G(27) 1xW21G(28) */
static uint32 kt2_tdm_56450A2_12[99]={0};
static uint32 kt2_tdm_56450speed_12[40]= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       10000,0000,0000,0000,    /* 9  - 12  */
       10000,0000,0000,0000,    /* 13 - 16  */
       10000,0000,0000,0000,    /* 17 - 20  */
       10000,0000,0000,0000,    /* 21 - 24  */
       13000,0000,13000,21000,  /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
/* Config=12 8 x 1GbE + 4 x F.XAUI + 1 x F.HG[13] 1 x W13G 1 x W21G*/
/* 2xHG13 + 1xHG21 */
soc_port_details_t kt2_port_details_config12[]={
    {1,8,1,GE_PORT,1000},
    {9,21,4,XE_PORT,10000}, /* 4 F.XAUI */
    {25,27,2,HG_PORT|STK_PORT,13000},
    {28,28,1,HG_PORT|STK_PORT,21000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=13 */

/* 8 x 1GbE(1..8) + 4 x F.XAUI(9,13,17,21) + 2 x W21G(27,28) */
static uint32 kt2_tdm_56450A2_13[99]={0};
static uint32 kt2_tdm_56450speed_13[40]= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       10000,0000,0000,0000,    /* 9  - 12  */
       10000,0000,0000,0000,    /* 13 - 16  */
       10000,0000,0000,0000,    /* 17 - 20  */
       10000,0000,0000,0000,    /* 21 - 24  */
       0000,0000,21000,21000,   /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
/* Config=13 8 x 1GbE + 4 x F.XAUI + 2 x W21G*/
soc_port_details_t kt2_port_details_config13[]={
    {1,8,1,GE_PORT,1000},
    {9,21,4,XE_PORT,10000},
    {27,28,1,HG_PORT|STK_PORT,21000},
    {0,0,0,0} /* End */
};


/* bcm5645x_config=14 */


/* 8 x 1GbE(1..8) + 2 x F.XAUI(9,13) + 2xHG13(25,26) 2 x W20G(27,28) */
static uint32 kt2_tdm_56450A2_14[99]={0};
static uint32 kt2_tdm_56450speed_14[40]= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       10000,0000,0000,0000,    /* 9  - 12  */
       10000,0000,0000,0000,    /* 13 - 16  */
       0000,0000,0000,0000,     /* 17 - 20  */
       0000,0000,0000,0000,     /* 21 - 24  */
       13000,13000,13000,13000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
/* Config=14 8 x 1GbE + 2 x F.XAUI + 1 x F.HG[13] + 1 x X.HG[13]  2 x W20G */
/* TN2 */
/* Actually 4 XFI but treating as 2HG13 only!! */
soc_port_details_t kt2_port_details_config14[]={
    {1,8,1,GE_PORT,1000},
    {9,13,4,XE_PORT,10000}, /* 2 F.XAUI */
    {25,28,1,HG_PORT|STK_PORT,13000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=15 */

/* 16 x 1GbE(1..16) + 1 x F.XAUI(17) + 2xHG13(25,26) 2 x W21G(27,28) */
static uint32 kt2_tdm_56450A2_15[99]={0};
static uint32 kt2_tdm_56450speed_15[40]= {
       1000,1000,1000,1000,     /* 1 .- 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       1000,1000,1000,1000,     /* 9  - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       10000,0000,0000,0000,    /* 17 - 20  */
       0000,0000,0000,0000,     /* 21 - 24  */
       13000,13000,13000,13000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
/* Config=15 16 x 1GbE + 1 x F.XAUI + 1 x F.HG[13] + 1 x X.HG[13]  2 x W20G */
/* TN2 */
/* Assuming 4 XFI */
soc_port_details_t kt2_port_details_config15[]={
    {1,16,1,GE_PORT,1000},
    {17,17,1,XE_PORT,10000},
    {25,28,1,HG_PORT|STK_PORT,13000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* 2xF.XAUI + 2xHG13 */
static uint32 kt2_tdm_56454D_25[20]={0};
static uint32 kt2_tdm_56454speed_25[40]= {
       10000,0000,0000,0000,     /* 1 .- 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       0000,0000,0000,0000,     /* 9  - 12  */
       0000,0000,0000,0000,     /* 13 - 16  */
       0000,0000,0000,0000,     /* 17 - 20  */
       0000,0000,0000,0000,     /* 21 - 24  */
       0000,0000,13000,13000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,0000};    /* 37 - 40  */
soc_port_details_t kt2_port_details_config25[]={
    {1,5,4,XE_PORT,10000},
    {27,28,1,HG_PORT|STK_PORT,13000},
    {0,0,0,0} /* End */
};


/* 24x GE + 4x HG[13] /4x XAUI / 16x 2.5G */
static uint32 kt2_tdm_56455C_27[84]={0};
static uint32 kt2_tdm_56455speed_27[40]= {
       1000,1000,1000,1000,     /* 1 .- 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       1000,1000,1000,1000,     /* 9  - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       1000,1000,1000,1000,     /* 17 - 20  */
       1000,1000,1000,1000,     /* 21 - 24  */
       13000,13000,13000,13000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,0000};    /* 37 - 40  */
soc_port_details_t kt2_port_details_config27[]={
    {1,24,1,GE_PORT,1000},
    {25,28,1,HG_PORT|STK_PORT,13000},
    {0,0,0,0} /* End */
};


static uint32 kt2_tdm_mxqblock_ports_used[KT2_MAX_MXQBLOCKS]={0};
static uint32 kt2_tdm_position_mxq_mask[90]={0};
static uint32 kt2_port_to_mxqblock[40]={0,0,0,0, /* 1-4   mxq0*/
                                        1,1,1,1, /* 5-8   mxq1*/
                                        2,2,2,2, /* 9-12  mxq2*/
                                        3,3,3,3, /* 13-16 mxq3*/
                                        4,4,4,4, /* 17-20 mxq4*/
                                        5,5,5,5, /* 21-24 mxq5*/
                                        6,7,8,9, /* 25-28 mxq6-9 */
                                        9,9,9,8, /* 29-32 mxq9,9,9-8 */
                                        8,8,6,6, /* 33-36 mxq8,8,6-6 */
                                        6,7,7,7  /* 37-40 mxq6,7,7,7 */
                                       };
kt2_tdm_pos_info_t kt2_tdm_pos_info[KT2_MAX_MXQBLOCKS]={{0}};
uint32 kt2_port_to_mxqblock_subports[40]={0,1,2,3, /* 1-4   mxq0*/
                                                 0,1,2,3, /* 5-8   mxq1*/
                                                 0,1,2,3, /* 9-12  mxq2*/
                                                 0,1,2,3, /* 13-16 mxq3*/
                                                 0,1,2,3, /* 17-20 mxq4*/
                                                 0,1,2,3, /* 21-24 mxq5*/
                                                 0,0,0,0, /* 25-28 mxq6-9 */
                                                 1,2,3,1, /* 29-32 mxq9,9,9-8 */
                                                 2,3,1,2, /* 33-36 mxq8,8,6-6 */
                                                 3,1,2,3  /* 37-40 mxq6,7,7,7 */
                                                };

soc_field_t kt2_srcport_field_names[KT2_MAX_LOGICAL_PORTS]={
            SRCPORT_0f,  
            SRCPORT_1f,  SRCPORT_2f,  SRCPORT_3f,  SRCPORT_4f,  
            SRCPORT_5f,  SRCPORT_6f,  SRCPORT_7f,  SRCPORT_8f,  
            SRCPORT_9f,  SRCPORT_10f, SRCPORT_11f, SRCPORT_12f, 
            SRCPORT_13f, SRCPORT_14f, SRCPORT_15f, SRCPORT_16f, 
            SRCPORT_17f, SRCPORT_18f, SRCPORT_19f, SRCPORT_20f, 
            SRCPORT_21f, SRCPORT_22f, SRCPORT_23f, SRCPORT_24f, 
            SRCPORT_25f, SRCPORT_26f, SRCPORT_27f, SRCPORT_28f, 
            SRCPORT_29f, SRCPORT_30f, SRCPORT_31f, SRCPORT_32f, 
            SRCPORT_33f, SRCPORT_34f, SRCPORT_35f, SRCPORT_36f, 
            SRCPORT_37f, SRCPORT_38f, SRCPORT_39f, SRCPORT_40f,
            SRCPORT_41f
            };                 
uint8 kt2_tdm_update_flag=1;



uint32 kt2_tdm_0[78] = { 1,9,25,26,27,28,
                        17,2,25,26,27,28,
                        0,10,18,25,26,27,
                        28,3,11,25,26,27,
                        28,35,19,4,25,26,
                        27,28,12,20,25,26,
                        27,28,63,5,13,25,
                        26,27,28,21,6,25,
                        26,27,28,0,14,22,
                        25,26,27,28,7,15,
                        25,26,27,28,35,23,
                        8,25,26,27,28,16,
                        24,25,26,27,28,35
                      };


uint32 kt2_mxqblock_ports[KT2_MAX_MXQBLOCKS][KT2_MAX_MXQPORTS_PER_BLOCK]=
             {{1,2,3,4},
              {5,6,7,8},
              {9,10,11,12},
              {13,14,15,16},
              {17,18,19,20},
              {21,22,23,24},
              {25,35,36,37},
              {26,38,39,40},
              {27,32,33,34},
              {28,29,30,31},
              {0xFF,0xFF,0xFF,0xFF},
             };
tdm_cycles_info_t kt2_tdm_cycles_info[KT2_MAX_TDM_FREQUENCY][KT2_MAX_SPEEDS]={
                  /*0:80MHz : 16Cycles*/
                  {{16,16,1},{16,16,1},{16,16,1},{4,3,4},
                   {3,2,6},{2,1,8},{2,1,8}},      

                  /*1:120MHz: 20Cycles*/
                  {{20,20,1},{20,20,1},{20,20,1},{6,3,4},
                   {5,3,4},{3,2,7},{3,2,7}},      

                  /*2:155MHz: 84Cycles*/
                  {{84,84,1},{42,41,2},{33,26,3},{9,8,10},
                   {7,6,12},{4,3,21},{4,3,21}},  

                  /*3:185MHz: 80Cycles*/
                  {{80,80,1},{50,39,2},{40,39 ,2 },{10,9,8},
                   {8,7,10},{5,4,16},{5,4,16}},  

                  /*4:185MHz: 90Cycles*/
                  {{90,90,1},{52,44,2},{39,29,3},{10,9,9}, 
                   {8,7,12},{5,4,18},{5,4,18}},  
                  /*5:205MHz: 108*/
                  {{108,108,1},{56,52,2},{44,34,3},{11,10,10},
                   {9,9,12},{5,4,21},{5,4,21}},  
                  /*6:205MHz: 88*/
                  {{88,88,1},{56,42,2},{44,42,2},{11,10,8},
                   {9,8,10},{5,4,18},{5,4,18}}, 
                  /*7:205MHz: 99 */
                  {{99,99,1},{56,48,2},{44,31,3},{11,10,9},
                   {9,8,11},{5,4,20},{5,4,20}},
                  /*8:166MHz: 84 */
                  {{84,84,1},{52,28,3},{42,14,6},{10,9,9},
                   {8,6,12},{5,4,17},{5,4,17}},
                  };

tdm_cycles_info_t kt2_current_tdm_cycles_info[KT2_MAX_SPEEDS]={{0}};

typedef struct tdm_port_slots_info_s  {
        int32                        position;
        struct tdm_port_slots_info_s *prev;
        struct tdm_port_slots_info_s *next;
}tdm_port_slots_info_t;

tdm_port_slots_info_t kt2_tdm_port_slots_info[KT2_MAX_LOGICAL_PORTS];

static uint32 *bcm56450_tdm[]={kt2_tdm_56450config_deprecated0,
                            kt2_tdm_56450A_1,kt2_tdm_56450A_2,
                            kt2_tdm_56450A_3,kt2_tdm_56450A_4,
                            kt2_tdm_56450A_5,kt2_tdm_56450A_6,
                            kt2_tdm_56450A_7,kt2_tdm_56450A1_8,
                            kt2_tdm_56450A1_9,kt2_tdm_56450A2_10,
                            kt2_tdm_56450A2_11,kt2_tdm_56450A2_12,
                            kt2_tdm_56450A2_13,kt2_tdm_56450A2_14,
                            kt2_tdm_56450A2_15, kt2_tdm_56455C_27,
                            NULL,NULL,NULL,NULL,NULL,
                            NULL,NULL,NULL,kt2_tdm_56454D_25,
                            NULL,kt2_tdm_56455C_27
};
static uint32 *bcm56450_speed[]={kt2_tdm_56450speed_deprecated0,
                              kt2_tdm_56450speed_1,kt2_tdm_56450speed_2,
                              kt2_tdm_56450speed_3,kt2_tdm_56450speed_4,
                              kt2_tdm_56450speed_5,kt2_tdm_56450speed_6,
                              kt2_tdm_56450speed_7,kt2_tdm_56450speed_8,
                              kt2_tdm_56450speed_9,kt2_tdm_56450speed_10,
                              kt2_tdm_56450speed_11,kt2_tdm_56450speed_12,
                              kt2_tdm_56450speed_13,kt2_tdm_56450speed_14,
                              kt2_tdm_56450speed_15, kt2_tdm_56455speed_27,
                              NULL,NULL,NULL,NULL,NULL,
                              NULL,NULL,NULL, kt2_tdm_56454speed_25,
                              NULL,kt2_tdm_56455speed_27};
bcm56450_tdm_info_t bcm56450_tdm_info[]={
                              {205,88,8,11},
                              {205,88,8,11}, {205,88,8,11}, {205,88,8,11}, /* TDM_A */
			      {205,88,8,11}, {205,88,8,11}, {205,88,8,11},
                              {205,88,8,11}, 

                              {205,108,12,9}, {205,108,12,9}, /* TDM_A1 */
                              {205,99,11,9}, {205,99,11,9}, {205,99,11,9}, /* TDM_A2 */
                              {205,99,11,9}, {205,99,11,9}, {205,99,11,9},
                              /* TBD Yet */
                              {166,84,12,7},{0,0,0,0},{0,0,0,0},{0,0,0,0},
                              {0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},
                              {0,0,0,0},{120,20,4,5},{0,0,0,0},
                              {166,84,12,7}
                              }; 

#ifdef UNDER_TESTING
char tdm_config_string[80]={0};
/* 4xGE(1..4) 2xF-XAUI(5,9) 2xF-HG[13](25,26) 2x21G[G.INT](27,28) */
uint32 kt2_tdm_56450_test_speed0[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4 */
       10000,0000 ,0000 ,0000,     /* 5 - 8 */
       10000,0000 ,0000 ,0000,     /* 9 - 12 */
       0000 ,0000 ,0000 ,0000,     /* 13 - 16 */
       0000 ,0000 ,0000 ,0000,     /* 17 - 20 */
       0000 ,0000 ,0000 ,0000,     /* 21 - 24 */
       13000,13000,21000,21000,    /* 25 - 28 */
       0,    0,    0,    0,        /* 29 - 32 */
       0,    0,    0,    0,        /* 33 - 36 */
       0,    0,    0,    0};       /* 37 - 40 */

/* 24xGE(1..24) 2xF-HG[13](25,26) 2x21G[G.INT](27,28) */
uint32 kt2_tdm_56450_test_speed1[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4 */
       1000 ,1000 ,1000 ,1000,     /* 5 - 8 */
       1000 ,1000 ,1000 ,1000,     /* 9 - 12 */
       1000 ,1000 ,1000 ,1000,     /* 13 - 16 */
       1000 ,1000 ,1000 ,1000,     /* 17 - 20 */
       1000 ,1000 ,1000 ,1000,     /* 21 - 24 */
       13000,13000,21000,21000,    /* 25 - 28 */
       0,    0,    0,    0,        /* 29 - 32 */
       0,    0,    0,    0,        /* 33 - 36 */
       0,    0,    0,    0};       /* 37 - 40 */

/* 16x 2.5G(1..8 25,26,35..40) + 2x HG21(27..28)  */
uint32 kt2_tdm_56450_test_speed2[40]= {
       2500,2500,2500 ,2500 ,     /* 1 - 4 */
       2500,2500,2500 ,2500 ,     /* 5 - 8 */
       0000,0000,0000 ,0000 ,     /* 9 - 12 */
       0000,0000,0000 ,0000 ,     /* 13 - 16 */
       0000,0000,0000 ,0000 ,     /* 17 - 20 */
       0000,0000,0000 ,0000 ,     /* 21 - 24 */
       2500,2500,21000,21000,     /* 25 - 28 */
       0000,0000,0000 ,0000 ,     /* 29 - 32 */
       0000,0000,2500 ,2500 ,     /* 33 - 36 */
       2500,2500,2500 ,2500 };    /* 37 - 40 */

/* 24x GE(1..24) 8*2.5GE (25..26,35..40) + 2x HG21(27..28)  */
uint32 kt2_tdm_56450_test_speed3[40]= {
       1000,1000,1000 ,1000 ,     /* 1 - 4   */
       1000,1000,1000 ,1000 ,     /* 5 - 8   */
       1000,1000,1000 ,1000 ,     /* 9 - 12  */
       1000,1000,1000 ,1000 ,     /* 13 - 16 */
       1000,1000,1000 ,1000 ,     /* 17 - 20 */
       1000,1000,1000 ,1000 ,     /* 21 - 24 */
       2500,2500,21000,21000,     /* 25 - 28 */
       0000,0000,0000 ,0000 ,     /* 29 - 32 */
       0000,0000,2500 ,2500 ,     /* 33 - 36 */
       2500,2500,2500 ,2500 };    /* 37 - 40 */

/* 24x GE(1..24) 16*2.5GE (25..40) */
uint32 kt2_tdm_56450_test_speed4[40]= {
       1000,1000,1000,1000,     /* 1 - 4   */
       1000,1000,1000,1000,     /* 5 - 8   */
       1000,1000,1000,1000,     /* 9 - 12  */
       1000,1000,1000,1000,     /* 13 - 16 */
       1000,1000,1000,1000,     /* 17 - 20 */
       1000,1000,1000,1000,     /* 21 - 24 */
       2500,2500,2500,2500,     /* 25 - 28 */
       2500,2500,2500,2500,     /* 29 - 32 */
       2500,2500,2500,2500,     /* 33 - 36 */
       2500,2500,2500,2500};    /* 37 - 40 */

/* 12x GE(1..4,5..8,17..20) 12*2.5GE (5..8,13..16,21..24),4*10G(25..28) */
uint32 kt2_tdm_56450_test_speed5[40]= {
       1000,1000,1000,1000,     /* 1 - 4   */
       2500,2500,2500,2500,     /* 5 - 8   */
       1000,1000,1000,1000,     /* 9 - 12  */
       2500,2500,2500,2500,     /* 13 - 16 */
       1000,1000,1000,1000,     /* 17 - 20 */
       2500,2500,2500,2500,     /* 21 - 24 */
       10000,10000,10000,10000,     /* 25 - 28 */
       0000,0000,0000,0000,     /* 29 - 32 */
       0000,0000,0000,0000,     /* 33 - 36 */
       0000,0000,0000,0000};    /* 37 - 40 */

/* 8*10G(1,5,9,13,17,21,25,26) */
uint32 kt2_tdm_56450_test_speed6[40]= {
       10000,0000,0000,0000,     /* 1 - 4   */
       10000,0000,0000,0000,     /* 5 - 8   */
       10000,0000,0000,0000,     /* 9 - 12  */
       10000,0000,0000,0000,     /* 13 - 16 */
       10000,0000,0000,0000,     /* 17 - 20 */
       10000,0000,0000,0000,     /* 21 - 24 */
       10000,10000,0000,0000,     /* 25 - 28 */
       0000,0000,0000,0000,     /* 29 - 32 */
       0000,0000,0000,0000,     /* 33 - 36 */
       0000,0000,0000,0000};    /* 37 - 40 */

/* 24* 2G(1..24) 4*10G(25..28) */
uint32 kt2_tdm_56450_test_speed7[40]= {
       2000,2000,2000,2000,     /* 1 - 4   */
       2000,2000,2000,2000,     /* 5 - 8   */
       2000,2000,2000,2000,     /* 9 - 12  */
       2000,2000,2000,2000,     /* 13 - 16 */
       2000,2000,2000,2000,     /* 17 - 20 */
       2000,2000,2000,2000,     /* 21 - 24 */
       10000,10000,10000,10000,     /* 25 - 28 */
       0000,0000,0000,0000,     /* 29 - 32 */
       0000,0000,0000,0000,     /* 33 - 36 */
       0000,0000,0000,0000};    /* 37 - 40 */

/* 24*GE(1..24) 4*13G(25..28) */
uint32 kt2_tdm_56450_test_speed8[40]= {
       1000,1000,1000,1000,     /* 1 - 4   */
       1000,1000,1000,1000,     /* 5 - 8   */
       1000,1000,1000,1000,     /* 9 - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       1000,1000,1000,1000,     /* 17 - 20  */
       1000,1000,1000,1000,     /* 21 - 24  */
       13000,13000,13000,13000,     /* 25- 28 */
       00,00,00,00,     /* 29 - 32  */
       00,00,00,00,     /* 33 - 36  */
       00,00,00,00};     /* 37 - 40  */

/* 18*GE(1..18) 6*2.5G(19..24) 4*13G(25..28) */
uint32 kt2_tdm_56450_test_speed9[40]= {
       1000,1000,1000,1000,     /* 1 - 4   */
       1000,1000,1000,1000,     /* 5 - 8   */
       1000,1000,1000,1000,     /* 9 - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       1000,1000,2500,2500,     /* 17 - 20  */
       2500,2500,2500,2500,     /* 21 - 24  */
       13000,13000,13000,13000,     /* 25- 28 */
       00,00,00,00,     /* 29 - 32  */
       00,00,00,00,     /* 33 - 36  */
       00,00,00,00};     /* 37 - 40  */


/* 4xGE + 2x F-XAUI + 2x F-HG[13] + 2x F-HG[21] */
uint32 kt2_tdm_56450_test_speed10[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4   */
       10000,0000 ,0000 ,0000,     /* 5 - 8   */
       10000,0000 ,0000 ,0000,     /* 9 - 12  */
       0000 ,0000 ,0000 ,0000,     /* 13 - 16  */
       0000 ,0000 ,0000 ,0000,     /* 17 - 20  */
       0000 ,0000 ,0000 ,0000,     /* 21 - 24  */
       13000,13000,21000,21000,     /* 25- 28 */
       00,00,00,00,     /* 29 - 32  */
       00,00,00,00,     /* 33 - 36  */
       00,00,00,00};     /* 37 - 40  */

/* 8xGE + 16x 2.5GE + 8x2.5G-HGL + 8x2.5G[G.INT] */
uint32 kt2_tdm_56450_test_speed11[40]= {
       1000 ,1000 ,2500 ,2500,     /* 1 - 4   */
       1000 ,1000 ,2500 ,2500,     /* 5 - 8   */
       1000 ,1000 ,2500 ,2500,     /* 9 - 12  */
       1000 ,1000 ,2500 ,2500,     /* 13 - 16  */
       2500 ,2500 ,2500 ,2500,     /* 17 - 20  */
       2500 ,2500 ,2500 ,2500,     /* 21 - 24  */
       2500 ,2500 ,2500 ,2500,     /* 25- 28 */
       2500 ,2500 ,2500 ,2500,     /* 29 - 32  */
       2500 ,2500 ,2500 ,2500,     /* 33 - 36  */
       2500 ,2500 ,2500 ,2500};     /* 37 - 40  */

/* 8xGE + 8x XFI / 8x F-XAUI / 4x F-XAUI + 4x XFI */
uint32 kt2_tdm_56450_test_speed12[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4   */
       1000 ,1000 ,1000 ,1000,     /* 5 - 8   */
       10000 ,0000 ,0000 ,0000,     /* 9 - 12  */
       10000 ,0000 ,0000 ,0000,     /* 13- 16  */
       10000 ,0000 ,0000 ,0000,     /* 17 - 20  */
       10000 ,0000 ,0000 ,0000,     /* 21 - 24  */
       10000 ,10000 ,10000 ,10000,     /* 25 - 28 */
       0000 ,0000 ,0000 ,0000,     /* 29 - 32 */
       0000 ,0000 ,0000 ,0000,     /* 33 - 36  */
       0000 ,0000 ,0000 ,0000};     /* 37 - 40  */

/* 2*13G + 2*21G + 24*G */
uint32 kt2_tdm_56450_test_speed13[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4   */
       1000 ,1000 ,1000 ,1000,     /* 5 - 8   */
       1000 ,1000 ,1000 ,0000,     /* 9 - 12  */
       1000 ,1000 ,1000 ,0000,     /* 13- 16  */
       1000 ,1000 ,1000 ,0000,     /* 17 - 20  */
       1000 ,1000 ,1000 ,0000,     /* 21 - 24  */
       13000 ,13000 ,21000 ,21000,     /* 25 - 28 */
       0000 ,0000 ,0000 ,0000,     /* 29 - 32 */
       0000 ,0000 ,0000 ,0000,     /* 33 - 36  */
       0000 ,0000 ,0000 ,0000};     /* 37 - 40  */

/* 24x GE + 4x HG[13]  */
uint32 kt2_tdm_56450_test_speed14[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4   */
       1000 ,1000 ,1000 ,1000,     /* 5 - 8   */
       1000 ,1000 ,1000 ,1000,     /* 9 - 12  */
       1000 ,1000 ,1000 ,1000,     /* 13- 16  */
       1000 ,1000 ,1000 ,1000,     /* 17 - 20  */
       1000 ,1000 ,1000 ,1000,     /* 21 - 24  */
       13000 ,13000 ,13000 ,13000,     /* 25 - 28 */
       0000 ,0000 ,0000 ,0000,     /* 29 - 32 */
       0000 ,0000 ,0000 ,0000,     /* 33 - 36  */
       0000 ,0000 ,0000 ,0000};     /* 37 - 40  */

/* 24x GE + 4x XAUI / 16x 2.5G */
uint32 kt2_tdm_56450_test_speed15[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4   */
       1000 ,1000 ,1000 ,1000,     /* 5 - 8   */
       1000 ,1000 ,1000 ,1000,     /* 9 - 12  */
       1000 ,1000 ,1000 ,1000,     /* 13- 16  */
       1000 ,1000 ,1000 ,1000,     /* 17 - 20  */
       1000 ,1000 ,1000 ,1000,     /* 21 - 24  */
       10000 ,10000 ,10000 ,10000,     /* 25 - 28 */
       0000 ,0000 ,0000 ,0000,     /* 29 - 32 */
       0000 ,0000 ,0000 ,0000,     /* 33 - 36  */
       0000 ,0000 ,0000 ,0000};     /* 37 - 40  */

/* 24x GE + 16x 2.5G */
uint32 kt2_tdm_56450_test_speed16[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4   */
       1000 ,1000 ,1000 ,1000,     /* 5 - 8   */
       1000 ,1000 ,1000 ,1000,     /* 9 - 12  */
       1000 ,1000 ,1000 ,1000,     /* 13- 16  */
       1000 ,1000 ,1000 ,1000,     /* 17 - 20  */
       1000 ,1000 ,1000 ,1000,     /* 21 - 24  */
       2500 ,2500 ,2500 ,2500,     /* 25 - 28 */
       2500 ,2500 ,2500 ,2500,     /* 29 - 32 */
       2500 ,2500 ,2500 ,2500,     /* 33 - 36  */
       2500 ,2500 ,2500 ,2500};     /* 37 - 40  */

/* 8x GE + 2  * 10G */
uint32 kt2_tdm_56450_test_speed17[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4   */
       1000 ,1000 ,1000 ,1000,     /* 5 - 8   */
       0000 ,0000 ,0000 ,0000,     /* 9 - 12  */
       0000 ,0000 ,0000 ,0000,     /* 13- 16  */
       0000 ,0000 ,0000 ,0000,     /* 17 - 20  */
       0000 ,0000 ,0000 ,0000,     /* 21 - 24  */
       10000 ,10000 ,0000 ,0000,     /* 25 - 28 */
       0000 ,0000 ,0000 ,0000,     /* 29 - 32 */
       0000 ,0000 ,0000 ,0000,     /* 33 - 36  */
       0000 ,0000 ,0000 ,0000};     /* 37 - 40  */

/* 4x 2.5GE + 1  * 13G 1 * 10G */
uint32 kt2_tdm_56450_test_speed18[40]= {
       2500 ,2500 ,2500 ,0000,     /* 1 - 4   */
       0000 ,0000 ,0000 ,0000,     /* 5 - 8   */
       0000 ,0000 ,0000 ,0000,     /* 9 - 12  */
       0000 ,0000 ,0000 ,0000,     /* 13- 16  */
       0000 ,0000 ,0000 ,0000,     /* 17 - 20  */
       0000 ,0000 ,0000 ,0000,     /* 21 - 24  */   
       13000 ,10000 ,0000 ,0000,     /* 25 - 28 */
       0000 ,0000 ,0000 ,0000,     /* 29 - 32 */
       0000 ,0000 ,0000 ,0000,     /* 33 - 36  */
       0000 ,0000 ,0000 ,0000};     /* 37 - 40  */

/* 4x 2.5GE + 4  * 1g */
uint32 kt2_tdm_56450_test_speed19[40]= {
       2500 ,0000 ,0000 ,0000,     /* 1 - 4   */
       2500 ,0000 ,0000 ,0000,     /* 5 - 8   */
       2500 ,0000 ,0000 ,0000,     /* 9 - 12  */
       2500 ,0000 ,0000 ,0000,     /* 13- 16  */
       1000 ,0000 ,0000 ,0000,     /* 17 - 20  */
       1000 ,0000 ,0000 ,0000,     /* 21 - 24  */
       1000 ,0000 ,0000 ,0000,     /* 25 - 28 */
       1000 ,0000 ,0000 ,0000,     /* 29 - 32 */
       0000 ,0000 ,0000 ,0000,     /* 33 - 36  */
       0000 ,0000 ,0000 ,0000};     /* 37 - 40  */










uint32 kt2_tdm_under_testing[90]= {KT2_IDLE};
uint32 kt2_tdm_under_testing_idle[180]= {KT2_IDLE};
#endif

/* *************************************************************** */
/* KATANA2 MMU HELPER  --- START(As per Katana2_MMU_Setting_v8.xls */
/* *************************************************************** */
/* Dynamic/SetLater Parameter */
typedef struct _soc_kt2_mmu_params {
               uint32 mmu_min_pkt_size;                   /*C5*/
               uint32 mmu_ethernet_mtu_bytes;             /*C6*/
               uint32 mmu_max_pkt_size;                   /*C7*/
               uint32 mmu_jumbo_frame_size;               /*C8*/
               uint32 mmu_int_buf_cell_size;              /*C9*/
               /* mmu_ext_buf_cell_size = (mmu_int_buf_cell_size+2)*15;   */
               uint32 mmu_ext_buf_cell_size;              /*C10=2880*/
               uint32 mmu_pkt_header_size;                /*C11*/
               uint32 packing_mode_d_c;                   /* C12:Dynamic */
               uint32 max_pkt_size_support_packing;        /* C13:Dynamic */
               uint32 lossless_mode_d_c;                  /* C14:Dynamic */
               uint32 pfc_pause_mode_d_c;                 /* C15:Dynamic */
               uint32 mmu_lossless_pg_num;                /*C16*/
               uint32 extbuf_used_d_c;                    /* C17:Dynamic */
               uint32 num_ge_ports_d;                     /* C19:Dynamic */
               uint32 mmu_line_rate_ge;                   /*C20*/
               uint32 num_ge_int_ports_d;                 /* C21:Dynamic */
               uint32 num_egr_queue_per_int_ge_port_d;    /* C22:Dynamic */
               uint32 num_ge_ext_ports_d;                 /* C23:Dynamic */
               uint32 num_egr_queue_per_ext_ge_port_d;    /* C24:Dynamic */
               uint32 num_hg_ports_d;                     /* C25:Dynamic */
               uint32 mmu_line_rate_hg;                   /*C26*/
               uint32 num_hg_int_ports_d;                 /* C27:Dynamic */
               uint32 num_egr_queue_per_int_hg_port_d;    /* C28:Dynamic */
               uint32 num_hg_ext_ports_d;                 /* C29:Dynamic */
               uint32 num_egr_queue_per_ext_hg_port_d;    /* C30:Dynamic */
               uint32 mmu_num_cpu_port;                   /*C31*/
               uint32 mmu_num_cpu_queue;                  /*C32*/
               uint32 cpu_port_int_ext_bounding_d_c;      /* C33:Dynamic */
               uint32 mmu_num_loopback_port;              /*C34*/
               uint32 mmu_num_loopback_queue;             /*C35*/
               uint32 mmu_num_ep_redirection_queue;       /*C36*/
               uint32 mmu_num_olp_port_d;                 /*C37*/
               uint32 mmu_num_olp_queue;                  /*C38*/
               uint32 olp_port_int_ext_bounding_d_c;      /* C39:Dynamic */
               uint32 mmu_int_buf_size;                   /*C41:2048KB=2MB*/
               uint32 mmu_available_int_buf_size_d;       /*C42:1434KB */
               uint32 mmu_reserved_int_buf_cells;         /*C43:100 Cells */
               uint32 mmu_reserved_int_buf_ema_pool_size_d; /*C44:614KB */
               uint32 internal_buffer_reduction_d_c;        /* C45:Dynamic */
               uint32 mmu_ext_buf_size;                   /*C46:737280KB=720MB*/
               uint32 mmu_egress_queue_entries;           /*C47*/
               uint32 mmu_ep_redirect_queue_entries;      /*C48*/
               uint32 mmu_exp_num_of_repl_per_pkt;        /*C49*/
               uint32 mmu_repl_engine_work_queue_entries; /*C50*/
               uint32 mmu_repl_engine_work_queue_in_device;/*C51*/
               uint32 mmu_ema_queues;                     /*C52*/
/*
float  kt2_baf_profile_indexes[]={0.015625,0.03125,0.0625,
                                  0.125,0.25,0.5,1.0,2.0,4.0,8.0};
 */
               uint32 num_cells_rsrvd_ing_ext_buf;        /* C54:Dynamic */     
               uint32 per_cos_res_cells_for_int_buff_d;   /* C55:Dynamic */
               uint32 per_cos_res_cells_for_ext_buff_d;   /* C56:Dynamic */
               uint32 mmu_ing_port_dyn_thd_param;         /*C57*/
               uint32 mmu_ing_pg_dyn_thd_param;           /*C58*/
               uint32 mmu_egr_queue_dyn_thd_param;        /*C59*/
               uint32 mmu_egr_pg_dyn_thd_param;           /*C60*/
               uint32 mmu_ing_cell_buf_reduction;         /*C61 */
               uint32 mmu_ing_pkt_buf_reduction;          /*C62 */
} _soc_kt2_mmu_params_t;

typedef struct _general_info {
    uint32 max_packet_size_in_cells;                         /* C68 */
    uint32 jumbo_frame_for_int_buff;                         /* C69 */
    uint32 jumbo_frame_for_ext_buff;                         /* C70 */
    uint32 ether_mtu_cells_for_int_buff;                     /* C72 */
    uint32 ether_mtu_cells_for_ext_buff;                     /* C73 */
    uint32 total_num_of_ports;                               /* C75 */
    uint32 total_num_of_ports_excl_lpbk;                     /* C76 */
    uint32 total_num_of_ports_excl_lpbk_olp;                 /* C77 */
    uint32 total_num_of_ports_excl_lpbk_olp_cpu;             /* C78 */
    uint32 port_bw_bound_to_ext_buff;                        /* C79 */
    uint32 total_egr_queues_for_a_int_ge_ports;              /* C80 */
    uint32 total_egr_queues_for_a_ext_ge_ports;              /* C81 */
    uint32 total_egr_queues_for_a_int_hg_ports;              /* C82 */
    uint32 total_egr_queues_for_a_ext_hg_ports;              /* C83 */
    uint32 total_cpu_queues;                                 /* C84 */
    uint32 total_int_buff_queues;                            /* C85 */
    uint32 total_ext_buff_queues;                            /* C86 */
    uint32 total_ema_queues;                                 /* C87 */
    uint32 total_egr_queues_in_device;                       /* C90 */
    uint32 max_int_cell_buff_size;                           /* C91 */
    uint32 int_cell_buff_size_after_limitation;              /* C92 */
    uint32 src_packing_fifo;                                 /* C93 */
    uint32 int_buff_pool;                                    /* C94 */
    uint32 ema_pool;                                         /* C95 */
    uint32 max_ext_cell_buff_size;                           /* C96 */
    uint32 ratio_of_ext_buff_to_int_buff_size;               /* C99 */
    uint32 int_buff_cells_per_avg_size_pkt;                  /* C100 */
    uint32 ext_buff_cells_per_avg_size_pkt;                  /* C101 */
    uint32 max_prop_of_buff_used_by_one_queue_port;          /* C102*/
}_general_info_t;

typedef struct _input_port_threshold_t {
    uint32 global_hdrm_cells_for_int_buff_pool;              /* C107 */
    uint32 global_hdrm_cells_for_ext_buff_pool;              /* C108 */
    uint32 global_hdrm_cells_for_RE_WQEs;                    /* C109 */
    uint32 global_hdrm_cells_for_EQEs;                       /* C110 */

    uint32 hdrm_int_buff_cells_for_10G_PG;                   /* C112 */
    uint32 hdrm_ext_buff_cells_for_10G_PG;                   /* C113 */
    uint32 hdrm_RE_WQEs_pkts_for_10G_PG;                     /* C114 */
    uint32 hdrm_EQEs_pkts_for_10G_PG;                        /* C115 */

    uint32 hdrm_int_buff_cells_for_10G_total_PG;             /* C117 */
    uint32 hdrm_ext_buff_cells_for_10G_total_PG;             /* C118 */
    uint32 hdrm_RE_WQEs_pkts_for_10G_total_PG;               /* C119 */
    uint32 hdrm_EQEs_pkts_for_10G_total_PG;                  /* C120 */

    uint32 hdrm_int_buff_cells_for_1G_PG;                    /* C122 */
    uint32 hdrm_ext_buff_cells_for_1G_PG;                    /* C123 */
    uint32 hdrm_RE_WQEs_pkts_for_1G_PG;                      /* C124 */
    uint32 hdrm_EQEs_pkts_for_1G_PG;                         /* C125 */

    uint32 hdrm_int_buff_cells_for_1G_total_PG;              /* C127 */
    uint32 hdrm_ext_buff_cells_for_1G_total_PG;              /* C128 */
    uint32 hdrm_RE_WQEs_pkts_for_1G_total_PG;                /* C129 */
    uint32 hdrm_EQEs_pkts_for_1G_total_PG;                   /* C130 */

    uint32 hdrm_int_buff_cells_for_olp_port;                 /* C132 */
    uint32 hdrm_ext_buff_cells_for_olp_port;                 /* C133 */
    uint32 hdrm_RE_WQEs_pkts_for_olp_port;                   /* C134 */
    uint32 hdrm_EQEs_pkts_for_olp_port;                      /* C135 */

    uint32 hdrm_int_buff_cells_for_lpbk_port;                /* C137 */
    uint32 hdrm_ext_buff_cells_for_lpbk_port;                /* C138 */
    uint32 hdrm_RE_WQEs_pkts_for_lpbk_port;                  /* C139 */
    uint32 hdrm_EQEs_pkts_for_lpbk_port;                     /* C140 */

    uint32 hdrm_int_buff_cells_for_cpu_port;                 /* C142 */
    uint32 hdrm_ext_buff_cells_for_cpu_port;                 /* C143 */
    uint32 hdrm_RE_WQEs_pkts_for_cpu_port;                   /* C144 */
    uint32 hdrm_EQEs_pkts_for_cpu_port;                      /* C145 */

    uint32 total_hdrm_int_buff_cells;                        /* C147 */
    uint32 total_hdrm_int_buff_ema_pool_cells;               /* C148 */
    uint32 total_hdrm_ext_buff_cells;                        /* C149 */
    uint32 total_hdrm_RE_WQEs_pkts;                          /* C150 */
    uint32 total_hdrm_EQEs_pkts;                             /* C151 */

    uint32 min_int_buff_cells_per_PG;                        /* C153 */
    uint32 min_int_buff_ema_pool_cells_per_PG;               /* C154 */
    uint32 min_ext_buff_cells_per_PG;                        /* C155 */
    uint32 min_RE_WQEs_pkt_per_PG;                           /* C156 */
    uint32 min_EQEs_pkt_per_PG;                              /* C157 */

    uint32 min_int_buff_cells_for_total_PG;                  /* C159 */
    uint32 min_int_buff_ema_pool_cells_for_total_PG;         /* C160 */
    uint32 min_ext_buff_cells_for_total_PG;                  /* C161 */
    uint32 min_RE_WQEs_pkts_for_total_PG;                    /* C162 */
    uint32 min_EQEs_pkts_for_total_PG;                       /* C163 */

    uint32 min_int_buff_cells_for_a_port;                    /* C165 */
    uint32 min_int_buff_ema_pool_cells_for_a_port;           /* C166 */
    uint32 min_ext_buff_cells_for_a_port;                    /* C167 */
    uint32 min_RE_WQEs_pkts_for_a_port;                      /* C168 */
    uint32 min_EQEs_pkts_for_a_port;                         /* C169 */

    uint32 min_int_buff_cells_for_total_port;                /* C171 */
    uint32 min_int_buff_ema_pool_cells_for_total_port;       /* C172 */
    uint32 min_ext_buff_cells_for_total_port;                /* C173 */
    uint32 min_RE_WQEs_pkts_for_total_port;                  /* C174 */
    uint32 min_EQEs_pkts_for_total_port;                     /* C175 */

    uint32 total_min_int_buff_cells;                         /* C177 */
    uint32 total_min_int_buff_ema_pool_cells;                /* C178 */
    uint32 total_min_ext_buff_cells;                         /* C179 */
    uint32 total_min_RE_WQEs_pkts;                           /* C180 */
    uint32 total_min_EQEs_pkts;                              /* C181 */

    uint32 total_shared_ing_buff_pool;                       /* C183 */
    uint32 total_shared_EMA_buff;                            /* C184 */
    uint32 total_shared_ext_buff;                            /* C185 */
    uint32 total_shared_RE_WQEs_buff;                        /* C186 */
    uint32 total_shared_EQEs_buff;                           /* C187 */

    uint32 ingress_burst_cells_size_for_one_port;            /* C189 */
    uint32 ingress_burst_pkts_size_for_one_port;             /* C190 */
    uint32 ingress_burst_cells_size_for_all_ports;           /* C191 */
    uint32 ingress_total_shared_cells_use_for_all_port;      /* C192 */
    uint32 ingress_burst_pkts_size_for_all_port;             /* C193 */
    uint32 ingress_total_shared_pkts_use_for_all_port;       /* C194 */
    uint32 ingress_total_shared_hdrm_cells_use_for_all_port; /* C195 */
    uint32 ingress_total_shared_hdrm_pkts_use_for_all_port;  /* C196 */

}_input_port_threshold_t;

typedef struct _output_port_threshold_t {
    uint32 min_grntd_res_queue_cells_int_buff;               /* C201 */
    uint32 min_grntd_res_queue_cells_ext_buff;               /* C202 */
    uint32 min_grntd_res_queue_cells_EQEs;                   /* C203 */
    uint32 min_grntd_res_EMA_queue_cells;                    /* C204 */
    uint32 min_grntd_res_RE_WQs_cells;                       /* C205 */
    uint32 min_grntd_res_RE_WQs_queue_cells_for_int_buff;    /* C206 */
    uint32 min_grntd_res_RE_WQs_queue_cells_for_ext_buff;    /* C207 */
    uint32 min_grntd_res_EP_redirect_queue_entry_cells;      /* C208 */

    uint32 min_grntd_tot_res_queue_cells_int_buff;           /* C210 */
    uint32 min_grntd_tot_res_queue_cells_ext_buff;           /* C211 */
    uint32 min_grntd_tot_res_queue_cells_EQEs;               /* C212 */
    uint32 min_grntd_tot_res_EMA_queue_cells;                /* C213 */
    uint32 min_grntd_tot_res_RE_WQs_cells;                   /* C214 */
    uint32 min_grntd_tot_res_RE_WQs_queue_cells_for_int_buff;/* C215 */
    uint32 min_grntd_tot_res_RE_WQs_queue_cells_for_ext_buff;/* C216 */
    uint32 min_grntd_tot_res_EP_redirect_queue_entry_cells;  /* C217 */

    uint32 min_grntd_tot_shr_queue_cells_int_buff;           /* C219 */
    uint32 min_grntd_tot_shr_queue_cells_ext_buff;           /* C220 */
    uint32 min_grntd_tot_shr_queue_cells_EQEs;               /* C221 */
    uint32 min_grntd_tot_shr_EMA_queue_cells;                /* C222 */
    uint32 min_grntd_tot_shr_RE_WQs_cells;                   /* C223 */
    uint32 min_grntd_tot_shr_RE_WQs_queue_cells_for_int_buff;/* C224 */
    uint32 min_grntd_tot_shr_RE_WQs_queue_cells_for_ext_buff;/* C225 */
    uint32 min_grntd_tot_shr_EP_redirect_queue_entry_cells;  /* C226 */

    uint32 egress_queue_dynamic_threshold_parameter;         /* C227 */
    uint32 egress_burst_cells_size_for_one_queue;            /* C228 */
    uint32 egress_burst_pkts_size_for_one_queue;             /* C229 */
    uint32 egress_burst_cells_size_for_all_ports;            /* C230 */
    uint32 egress_burst_pkts_size_for_all_ports;             /* C231 */
    uint32 egress_burst_cells_size_for_all_queues;           /* C232 */
    uint32 egress_burst_pkts_size_for_all_queues;            /* C233 */
    uint32 egress_total_use_in_cells_for_all_queues;         /* C234 */
    uint32 egress_total_use_in_pkts_for_all_queues;          /* C235 */
    uint32 egress_remaining_cells_for_all_queues;            /* C236 */
    uint32 egress_remaining_pkts_for_all_queues;             /* C237 */

}_output_port_threshold_t;

typedef struct _soc_kt2_mmu_intermediate_results {
    _general_info_t           general_info;
    _input_port_threshold_t   input_port_threshold;
    _output_port_threshold_t  output_port_threshold;
}_soc_kt2_mmu_intermediate_results_t;

static soc_ser_functions_t _kt2_ser_functions;
static
void _soc_kt2_mem_config_set(int unit, char *config_str, char *config_value);
void _soc_kt2_mem_config(int unit);

typedef enum {
    _SOC_COUNTER_TYPE_DROP_ENQ,
    _SOC_COUNTER_TYPE_ACCEPT_ENQ,
    _SOC_COUNTER_TYPE_DROP_ENQ_GREEN,
    _SOC_COUNTER_TYPE_DROP_ENQ_YELLOW,
    _SOC_COUNTER_TYPE_DROP_ENQ_RED,
    _SOC_COUNTER_TYPE_ACCEPT_ENQ_GREEN,
    _SOC_COUNTER_TYPE_ACCEPT_ENQ_YELLOW,
    _SOC_COUNTER_TYPE_ACCEPT_ENQ_RED,
    _SOC_COUNTER_TYPE_ACCEPT_DEQ,
    _SOC_COUNTER_TYPE_MAX
} _soc_katana2_counter_type_t;

typedef struct _soc_katana2_counter_info_s {
    _soc_katana2_counter_type_t type;
    int index;
    int segment;
} _soc_katana2_counter_info_t;

STATIC _soc_katana2_counter_info_t _soc_katana2_counter_info[] = {
    { _SOC_COUNTER_TYPE_DROP_ENQ, 0x0, 0 },
    { _SOC_COUNTER_TYPE_ACCEPT_ENQ, 0x0, 1 },
    /* green pkt drops, index = ACCEPT=1'b0, COLOR=2'b00 */
    { _SOC_COUNTER_TYPE_DROP_ENQ_GREEN, 0x0, 2 },
    /* yellow pkt drops, index = ACCEPT=1'b0, COLOR=2'b11 */
    { _SOC_COUNTER_TYPE_DROP_ENQ_YELLOW, 0x3, 3 },
    /* red pkt drops, index = ACCEPT=1'b0, COLOR=2'b01 */
    { _SOC_COUNTER_TYPE_DROP_ENQ_RED, 0x1, 4 },
    /* green accepted pkts, index = ACCEPT=1'b1, COLOR=2'b00 */
    { _SOC_COUNTER_TYPE_ACCEPT_ENQ_GREEN, 0x4, 5 },
    /* yellow accepted pkts, index = ACCEPT=1'b1, COLOR=2'b11 */
    { _SOC_COUNTER_TYPE_ACCEPT_ENQ_YELLOW, 0x7, 6 },
    /* red accepted pkts, index = ACCEPT=1'b1, COLOR=2'b01 */
    { _SOC_COUNTER_TYPE_ACCEPT_ENQ_RED, 0x5, 7 },
    { _SOC_COUNTER_TYPE_ACCEPT_DEQ, 0, 8 } 
};

#define KT2_MAX_SERVICE_POOLS 4
#define KT2_MAX_PRIORITY_GROUPS 8

soc_error_t katana2_get_wc_phy_info(int unit, 
                                    soc_port_t port,
                                    uint8 *lane_num, 
                                    uint8 *phy_mode, 
                                    uint8 *chip_num)
{
  uint32 mxqblock=0;
  uint32 num_lanes=0;
  bcmMxqConnection_t connection=bcmMqxConnectionUniCore;
  /*
     pc->chip_num = 0;
     pc->lane_num = 0;
     pc->phy_mode = PHYCTRL_ONE_LANE_PORT | 
                    PHYCTRL_DUAL_LANE_PORT | 
                    PHYCTRL_QUAD_LANE_PORT;
  */ 
  mxqblock = kt2_port_to_mxqblock[port-1];
  if ((mxqblock == 6) || (mxqblock == 7)) {
      /* Check XFI mode then */
      SOC_IF_ERROR_RETURN(soc_katana2_get_phy_connection_mode(
                          unit,port,mxqblock,&connection));
      if (connection == bcmMqxConnectionUniCore) {
          return SOC_E_PARAM;
      }
      if (mxqblock == 6) {
          *chip_num = 0;
      } else {
          *chip_num = 1;
      }
      *lane_num = (kt2_port_to_mxqblock_subports[port-1]+1);
  } else {
  if (!((mxqblock == 8)  || (mxqblock == 9))) {
      return SOC_E_PARAM;
  }
  if (mxqblock == 8) {
      *chip_num = 0;
  } else {
      *chip_num = 1;
  }
  *lane_num = kt2_port_to_mxqblock_subports[port-1];
  }
  num_lanes = soc_property_port_get(unit, port, spn_PORTGROUP, 0);
  switch(num_lanes) {
  case 1: *phy_mode = PHYCTRL_ONE_LANE_PORT;
          break;
  case 2: *phy_mode = PHYCTRL_DUAL_LANE_PORT;
          break;
  case 4: *phy_mode = PHYCTRL_QUAD_LANE_PORT;
          break;
  default: return SOC_E_PARAM;
  }
  return SOC_E_NONE;
}

/* kt2_mmu_ext_buf_cell_size = (kt2_mmu_int_buf_cell_size+2)*15;*/
STATIC 
uint32 ceil_func(uint32 numerators , uint32 denominator)
{
    uint32  result;
    if (denominator == 0) {
        return 0xFFFFFFFF;
    }
    result = numerators / denominator;
    if (numerators % denominator != 0) {
        result++; 
    }
    return result;
}
STATIC 
uint32 floor_func(uint32 numerators , uint32 denominator)
{
    uint32  result;
    if (denominator == 0) {
        return 0xFFFFFFFF;
    }
    result = numerators / denominator;
/*
    if (numerators % denominator != 0) {
        result--; 
    }
*/
    return result;
}

/* Helper function for MMU settings based on
 * memory selection (internal/external/both) and mode (lossless/lossy)
 * The memory selection is done using config variable  'pbmp_ext_mem'
 * and the mode is selected based on config variable 'lossless_mode'
 */
STATIC 
int _soc_katana2_mmu_init_helper(int unit)
{
    soc_info_t    *si= &SOC_INFO(unit); 
    uint16 dev_id=0;
    uint8  rev_id=0;
    uint32    ext_mem_port_count = 0;
    uint32    valid_port_count = 0;
    soc_pbmp_t    pbmp_int_ge;
    uint32        pbmp_int_ge_count=0;
    soc_pbmp_t    pbmp_int_hg;
    uint32        pbmp_int_hg_count=0;
    soc_pbmp_t    pbmp_ext_ge;
    uint32        pbmp_ext_ge_count=0;
    soc_pbmp_t    pbmp_ext_hg;
    uint32        pbmp_ext_hg_count=0;
    uint32        mmu_num_olp_port=0;
    soc_pbmp_t    valid_port_cpu_pbmp;
    soc_port_t    port=0;
    uint32        available_internal_buffer=100;
    uint32        reserve_internal_buffer=0;
    uint32        temp_val;
    uint32        rval=0;
    uint32        service_pool=0;
    uint32        priority_group=0;
    uint32        op_buffer_shared_limit_celli;
    uint32        op_buffer_shared_limit_resume_celli;
    uint32        op_buffer_shared_limit_celle;
    uint32        op_buffer_shared_limit_resume_celle;
    uint32        op_buffer_shared_limit;
    uint32        op_buffer_shared_limit_resume;
    soc_field_info_t *fieldp;
    uint32        queue;
    uint32        op_node=0;
    uint32        op_node_offset=0;
    uint32        cos;
    uint64        r64val;
    uint64        val64;

    /* soc_reg_info_t   *regp; */

    /* Per Port  Settings */
    uint32                      loop=0;
    uint32                      mem_idx=0;
    thdi_port_sp_config_entry_t thdi_port_sp_config={{0}};
                                /*
                                (KT2_MAX_PHYSICAL_PORTS+2) *
                                 KT2_MAX_SERVICE_POOLS] = {{{0}}};
                                 */
    thdi_port_pg_config_entry_t thdi_port_pg_config_temp={{0}};
    thdi_port_pg_config_entry_t thdi_port_pg_config={{0}};
                                /*
                                (KT2_MAX_PHYSICAL_PORTS+2) *
                                 KT2_MAX_PRIORITY_GROUPS] = {{{0}}};
                                 */

    thdiext_thdi_port_sp_config_entry_t thdiext_thdi_port_sp_config={{0}};
                                        /* 
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_SERVICE_POOLS] = {{{0}}};
                                         */
    thdiext_thdi_port_pg_config_entry_t thdiext_thdi_port_pg_config_temp={{0}};
    thdiext_thdi_port_pg_config_entry_t thdiext_thdi_port_pg_config={{0}};
                                        /*
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_PRIORITY_GROUPS] = {{{0}}};
                                         */
    thdiema_thdi_port_sp_config_entry_t thdiema_thdi_port_sp_config = {{0}};
                                        /* 
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_SERVICE_POOLS] = {{{0}}};
                                         */
    thdiema_thdi_port_pg_config_entry_t thdiema_thdi_port_pg_config_temp={{0}};
    thdiema_thdi_port_pg_config_entry_t thdiema_thdi_port_pg_config={{0}};
                                        /*
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_PRIORITY_GROUPS] = {{{0}}};
                                         */
    thdirqe_thdi_port_sp_config_entry_t thdirqe_thdi_port_sp_config={{0}};
                                        /*
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_SERVICE_POOLS] = {{{0}}};
                                         */
    thdirqe_thdi_port_pg_config_entry_t thdirqe_thdi_port_pg_config_temp={{0}};
    thdirqe_thdi_port_pg_config_entry_t thdirqe_thdi_port_pg_config={{0}};
                                        /*
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_PRIORITY_GROUPS] = {{{0}}};
                                         */
    thdiqen_thdi_port_sp_config_entry_t thdiqen_thdi_port_sp_config = {{0}};
                                        /* 
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_SERVICE_POOLS] = {{{0}}};
                                         */
    thdiqen_thdi_port_pg_config_entry_t thdiqen_thdi_port_pg_config_temp={{0}};
    thdiqen_thdi_port_pg_config_entry_t thdiqen_thdi_port_pg_config = {{0}};
                                        /*
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_PRIORITY_GROUPS] = {{{0}}};
                                         */

    mmu_thdo_opnconfig_cell_entry_t     mmu_thdo_opnconfig_cell_entry={{0}};
    mmu_thdo_qconfig_cell_entry_t       mmu_thdo_qconfig_cell_entry={{0}};
    mmu_thdo_qoffset_cell_entry_t       mmu_thdo_qoffset_cell_entry={{0}};

    mmu_thdo_opnconfig_qentry_entry_t   mmu_thdo_opnconfig_qentry_entry={{0}};
    mmu_thdo_qconfig_qentry_entry_t     mmu_thdo_qconfig_qentry_entry={{0}};
    mmu_thdo_qoffset_qentry_entry_t     mmu_thdo_qoffset_qentry_entry={{0}};

    _soc_kt2_mmu_intermediate_results_t _soc_kt2_mmu_intermediate_results={{0}};
    _general_info_t *general_info = 
                    &_soc_kt2_mmu_intermediate_results.general_info;
    _input_port_threshold_t *input_port_threshold =
                       &_soc_kt2_mmu_intermediate_results.input_port_threshold;
    _output_port_threshold_t *output_port_threshold = 
                       &_soc_kt2_mmu_intermediate_results.output_port_threshold;

    _soc_kt2_mmu_params_t _soc_kt2_mmu_params={0};

    /* Fixed Parameter */
    _soc_kt2_mmu_params.mmu_min_pkt_size = 64;              /*C5*/
    _soc_kt2_mmu_params.mmu_ethernet_mtu_bytes=1536;      /*C6*/
    _soc_kt2_mmu_params.mmu_max_pkt_size = 9216;            /*C7*/
    _soc_kt2_mmu_params.mmu_jumbo_frame_size = 9216;        /*C8*/
    _soc_kt2_mmu_params.mmu_int_buf_cell_size = 190;        /*C9*/
    /* C10  = (C9+2)*15 */
    _soc_kt2_mmu_params.mmu_ext_buf_cell_size = 
        (_soc_kt2_mmu_params.mmu_int_buf_cell_size + 2) * 15;
    _soc_kt2_mmu_params.mmu_pkt_header_size = 62;           /*C11*/
    _soc_kt2_mmu_params.mmu_lossless_pg_num = 1;            /*C16*/
    _soc_kt2_mmu_params.mmu_line_rate_ge = 1;               /*C20*/
    _soc_kt2_mmu_params.mmu_line_rate_hg = 13;              /*C26*/
    _soc_kt2_mmu_params.mmu_num_cpu_port = 1;               /*C31*/
    _soc_kt2_mmu_params.mmu_num_cpu_queue = 48;             /*C32*/
    _soc_kt2_mmu_params.mmu_num_loopback_port = 1;          /*C34*/
    _soc_kt2_mmu_params.mmu_num_loopback_queue = 8;         /*C35*/
    _soc_kt2_mmu_params.mmu_num_ep_redirection_queue = 16;  /*C36*/
    _soc_kt2_mmu_params.mmu_num_olp_queue = 8;              /*C38*/
    _soc_kt2_mmu_params.mmu_int_buf_size = 2;               /*C41:2048KB=2MB*/
    _soc_kt2_mmu_params.mmu_reserved_int_buf_cells = 100;   /*C43:100 Cells */
    _soc_kt2_mmu_params.mmu_ext_buf_size = 720;          /*C46:737280KB=720MB*/
    _soc_kt2_mmu_params.mmu_ep_redirect_queue_entries = 1000;/*C48*/
    _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt = 27;    /*C49*/
    _soc_kt2_mmu_params.mmu_repl_engine_work_queue_entries = 8;    /*C50*/
    _soc_kt2_mmu_params.mmu_repl_engine_work_queue_in_device = 12;    /*C51*/
    _soc_kt2_mmu_params.mmu_ema_queues = 8;    /*C52*/
/*
static const float  kt2_baf_profile_indexes[]={0.015625,0.03125,0.0625,
                                               0.125,0.25,0.5,1.0,2.0,4.0,8.0};
 */
    _soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param = 2; /*C57*/
    _soc_kt2_mmu_params.mmu_ing_pg_dyn_thd_param = 7;  /*C58*/
    _soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param = 2; /*C59*/
    _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param = 7;  /*C60*/
    _soc_kt2_mmu_params.mmu_ing_cell_buf_reduction = 0; /*C61 */
    _soc_kt2_mmu_params.mmu_ing_pkt_buf_reduction = 0; /*C62 */

    SOC_PBMP_CLEAR (pbmp_int_ge);
    SOC_PBMP_CLEAR (pbmp_int_hg);
    SOC_PBMP_CLEAR (pbmp_ext_ge);
    SOC_PBMP_CLEAR (pbmp_ext_hg);

    SOC_PBMP_CLEAR (valid_port_cpu_pbmp);
    SOC_PBMP_ASSIGN(valid_port_cpu_pbmp, PBMP_PORT_ALL(unit));
    SOC_PBMP_PORT_ADD(valid_port_cpu_pbmp, KT2_CMIC_PORT);

    soc_cm_get_id(unit, &dev_id, &rev_id);
    /* C12 */
    _soc_kt2_mmu_params.packing_mode_d_c =  soc_property_get(unit, 
                                             spn_MMU_MULTI_PACKETS_PER_CELL, 0);

    /* C13 */
    if (_soc_kt2_mmu_params.packing_mode_d_c) {
        _soc_kt2_mmu_params.max_pkt_size_support_packing = 10;
    }
    
    /* C14 */
    _soc_kt2_mmu_params.lossless_mode_d_c =  soc_property_get(unit, 
                                                          spn_LOSSLESS_MODE, 1);
    /* C15 */
    _soc_kt2_mmu_params.pfc_pause_mode_d_c =  soc_property_get(unit, 
                                                          "pfc_pause_mode", 0);

    SOC_PBMP_COUNT(PBMP_PORT_ALL (unit), valid_port_count);
    SOC_PBMP_COUNT(PBMP_EXT_MEM (unit), ext_mem_port_count);/*spn_PBMP_EXT_MEM*/

    /* C17 */
    if (ext_mem_port_count == 0) {
        _soc_kt2_mmu_params.extbuf_used_d_c =  0;
    } else {
        _soc_kt2_mmu_params.extbuf_used_d_c =  1;
    } 

    SOC_PBMP_ASSIGN(pbmp_int_ge,PBMP_GE_ALL(unit));
    if (SOC_INFO(unit).olp_port) {
        SOC_PBMP_PORT_REMOVE(pbmp_int_ge,KT2_OLP_PORT);
        mmu_num_olp_port=1;
    }
    SOC_PBMP_ASSIGN(pbmp_int_hg,PBMP_HG_ALL(unit));
    SOC_PBMP_OR(pbmp_int_hg,PBMP_XE_ALL(unit));
    SOC_PBMP_ITER (PBMP_EXT_MEM (unit), port) {
        if (IS_GE_PORT(unit, port)) {
            SOC_PBMP_PORT_ADD(pbmp_ext_ge,port);
            SOC_PBMP_PORT_REMOVE(pbmp_int_ge,port);
        } 
        if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit, port)) {
            SOC_PBMP_PORT_ADD(pbmp_ext_hg,port);
            SOC_PBMP_PORT_REMOVE(pbmp_int_hg,port);
        }
    }
    SOC_PBMP_COUNT(pbmp_ext_ge,pbmp_ext_ge_count);
    SOC_PBMP_COUNT(pbmp_int_ge,pbmp_int_ge_count);
    SOC_PBMP_COUNT(pbmp_ext_hg,pbmp_ext_hg_count);
    SOC_PBMP_COUNT(pbmp_int_hg,pbmp_int_hg_count);

    /* C19 */
    _soc_kt2_mmu_params.num_ge_ports_d = pbmp_int_ge_count + pbmp_ext_ge_count;
    /* C21 */
    _soc_kt2_mmu_params.num_ge_int_ports_d = pbmp_int_ge_count;
    /* C22 */
    _soc_kt2_mmu_params.num_egr_queue_per_int_ge_port_d = pbmp_int_ge_count ? 8:0;
    /* C23 */
    _soc_kt2_mmu_params.num_ge_ext_ports_d = pbmp_ext_ge_count;
    /* C24 */
    _soc_kt2_mmu_params.num_egr_queue_per_ext_ge_port_d = pbmp_ext_ge_count ? 
                        (_soc_kt2_mmu_params.packing_mode_d_c ? 16:8):0;
    /* C25 */
    _soc_kt2_mmu_params.num_hg_ports_d = pbmp_int_hg_count + pbmp_ext_hg_count;
    /* C27 */
    _soc_kt2_mmu_params.num_hg_int_ports_d = pbmp_int_hg_count ;
    /* C28 */
    _soc_kt2_mmu_params.num_egr_queue_per_int_hg_port_d = pbmp_int_hg_count ? 8:0;
    /* C29 */
    _soc_kt2_mmu_params.num_hg_ext_ports_d = pbmp_ext_hg_count ;
    /* C30 */
    _soc_kt2_mmu_params.num_egr_queue_per_ext_hg_port_d = pbmp_ext_hg_count ?
                        (_soc_kt2_mmu_params.packing_mode_d_c ? 16:8):0;
    /* C33 */
    _soc_kt2_mmu_params.cpu_port_int_ext_bounding_d_c = soc_property_get(unit, 
                                                    "cpu_port_bounding",0);
    /* C37 */
    _soc_kt2_mmu_params.mmu_num_olp_port_d = mmu_num_olp_port;
    /* C39 */
    _soc_kt2_mmu_params.olp_port_int_ext_bounding_d_c = soc_property_get(unit, 
                                                    "olp_port_bounding",0);

    if(ext_mem_port_count == 0) { /*spn_PBMP_EXT_MEM*/
       available_internal_buffer=100;
       reserve_internal_buffer=0;
    } else {
       available_internal_buffer=70;
       reserve_internal_buffer=30;
    }
    /* C42 */
    _soc_kt2_mmu_params.mmu_available_int_buf_size_d=available_internal_buffer;
    /* (_soc_kt2_mmu_params.mmu_int_buf_size*available_internal_buffer)/100; */
    /* C44 */
    _soc_kt2_mmu_params.mmu_reserved_int_buf_ema_pool_size_d=
                        reserve_internal_buffer;
    /* (_soc_kt2_mmu_params.mmu_int_buf_size*reserve_internal_buffer)/100; */

    /* C45 */
    _soc_kt2_mmu_params.internal_buffer_reduction_d_c = soc_property_get(unit, 
                                              "internal_buffer_reduction",0);
    /* C47 */
    _soc_kt2_mmu_params.mmu_egress_queue_entries = 
                                _soc_kt2_mmu_params.packing_mode_d_c ? 128:256;

    /* C54 */
    if (_soc_kt2_mmu_params.packing_mode_d_c) {
        _soc_kt2_mmu_params.num_cells_rsrvd_ing_ext_buf = 784;
    }

    /* C55 = CEILING((C6*1024+C11)/C9, 1) */
    _soc_kt2_mmu_params.per_cos_res_cells_for_int_buff_d = 
            ceil_func((_soc_kt2_mmu_params.mmu_ethernet_mtu_bytes + 
                       _soc_kt2_mmu_params.mmu_pkt_header_size),
                      _soc_kt2_mmu_params.mmu_int_buf_cell_size);
    /* C56 = =IF(C12=0,CEILING(C53/15,1),CEILING((C6*1024+C11+2)/C10,1)) */
    if (_soc_kt2_mmu_params.packing_mode_d_c == 0) {
        _soc_kt2_mmu_params.per_cos_res_cells_for_ext_buff_d = 
            ceil_func(_soc_kt2_mmu_params.per_cos_res_cells_for_int_buff_d,15);
    } else {
        _soc_kt2_mmu_params.per_cos_res_cells_for_ext_buff_d = 
            ceil_func((_soc_kt2_mmu_params.mmu_ethernet_mtu_bytes + 
                       _soc_kt2_mmu_params.mmu_pkt_header_size + 2),
                      _soc_kt2_mmu_params.mmu_ext_buf_cell_size);
    }

    /* Intermediate Results Processing Now */
    /* Fill up general info */
    /* C68 = CEILING((C7+C11)/C9,1) */
    general_info->max_packet_size_in_cells = ceil_func(
           (_soc_kt2_mmu_params.mmu_max_pkt_size + 
            _soc_kt2_mmu_params.mmu_pkt_header_size),
            _soc_kt2_mmu_params.mmu_int_buf_cell_size);
    /* C69 = CEILING((C8+C11)/C9,1) */
    general_info->jumbo_frame_for_int_buff = ceil_func(
           (_soc_kt2_mmu_params.mmu_jumbo_frame_size +
            _soc_kt2_mmu_params.mmu_pkt_header_size),
            _soc_kt2_mmu_params.mmu_int_buf_cell_size);
    /* C70 = IF(C12=0,CEILING(C69/15,1),CEILING((C8+C11+2)/C10,1)) */
    if (_soc_kt2_mmu_params.packing_mode_d_c == 0) {
        general_info->jumbo_frame_for_ext_buff = ceil_func(
                      general_info->jumbo_frame_for_int_buff,15);
    } else {
        general_info->jumbo_frame_for_ext_buff = ceil_func(
                      _soc_kt2_mmu_params.mmu_jumbo_frame_size +
                      _soc_kt2_mmu_params.mmu_pkt_header_size + 2,
                      _soc_kt2_mmu_params.mmu_ext_buf_cell_size);
    }
    /* C72 = CEILING((C6*1024+C11)/C9, 1) */
    general_info->ether_mtu_cells_for_int_buff = ceil_func(
                  (_soc_kt2_mmu_params.mmu_ethernet_mtu_bytes) +
                   _soc_kt2_mmu_params.mmu_pkt_header_size,
                  _soc_kt2_mmu_params.mmu_int_buf_cell_size);

    /* C73 = IF(C12=0,CEILING(C72/15,1),CEILING((C6*1024+C11+2)/C10,1)) */
    if (_soc_kt2_mmu_params.packing_mode_d_c == 0) {
        general_info->ether_mtu_cells_for_ext_buff = ceil_func(
                      general_info->ether_mtu_cells_for_int_buff,15);
    } else {
        general_info->ether_mtu_cells_for_ext_buff = ceil_func(
                      (_soc_kt2_mmu_params.mmu_ethernet_mtu_bytes)+
                      _soc_kt2_mmu_params.mmu_pkt_header_size+2,
                      _soc_kt2_mmu_params.mmu_ext_buf_cell_size);
    }
  
    /* C75 = C19+C25+C31+C34+C37 */
    general_info->total_num_of_ports = 
                  _soc_kt2_mmu_params.num_ge_ports_d +
                  _soc_kt2_mmu_params.num_hg_ports_d + 
                  _soc_kt2_mmu_params.mmu_num_cpu_port + 
                  _soc_kt2_mmu_params.mmu_num_loopback_port + 
                  _soc_kt2_mmu_params.mmu_num_olp_port_d;

    /* C76 = C19+C25+C31+C37 ) */
    general_info->total_num_of_ports_excl_lpbk = 
                  _soc_kt2_mmu_params.num_ge_ports_d +
                  _soc_kt2_mmu_params.num_hg_ports_d + 
                  _soc_kt2_mmu_params.mmu_num_cpu_port + 
                  _soc_kt2_mmu_params.mmu_num_olp_port_d;

    /* C77 = C19+C25+C31 */
    general_info->total_num_of_ports_excl_lpbk_olp =
                  _soc_kt2_mmu_params.num_ge_ports_d +
                  _soc_kt2_mmu_params.num_hg_ports_d + 
                  _soc_kt2_mmu_params.mmu_num_cpu_port;

    /* C78 = C19+C25 */
    general_info->total_num_of_ports_excl_lpbk_olp_cpu = 
                  _soc_kt2_mmu_params.num_ge_ports_d +
                  _soc_kt2_mmu_params.num_hg_ports_d;

    /* C79 = C23*C20+C29*C26 */
    general_info->port_bw_bound_to_ext_buff = 
                  (_soc_kt2_mmu_params.num_ge_ext_ports_d *
                   _soc_kt2_mmu_params.mmu_line_rate_ge) +
                  (_soc_kt2_mmu_params.num_hg_ext_ports_d *
                   _soc_kt2_mmu_params.mmu_line_rate_hg) ;

    /* C80 = C22*C21 */
    general_info->total_egr_queues_for_a_int_ge_ports = 
                  (_soc_kt2_mmu_params.num_egr_queue_per_int_ge_port_d *
                   _soc_kt2_mmu_params.num_ge_int_ports_d);

    /* C81 = C24*C23 */
    general_info->total_egr_queues_for_a_ext_ge_ports = 
                  (_soc_kt2_mmu_params.num_egr_queue_per_ext_ge_port_d *
                   _soc_kt2_mmu_params.num_ge_ext_ports_d);

    /* C82 = C28*C27 */
    general_info->total_egr_queues_for_a_int_hg_ports = 
                  (_soc_kt2_mmu_params.num_egr_queue_per_int_hg_port_d *
                   _soc_kt2_mmu_params.num_hg_int_ports_d);

    /* C83 = C30*C29 */
    general_info->total_egr_queues_for_a_ext_hg_ports = 
                  (_soc_kt2_mmu_params.num_egr_queue_per_ext_hg_port_d *
                   _soc_kt2_mmu_params.num_hg_ext_ports_d);

    /* C84 = C31*C32 */
    general_info->total_cpu_queues = 
                  (_soc_kt2_mmu_params.mmu_num_cpu_port *
                   _soc_kt2_mmu_params.mmu_num_cpu_queue);

    /* C85 = $C$80+$C$82+IF(C33=0,C84,0)+IF(C39=0,C38,0)+C35+C36/2 */
    general_info->total_int_buff_queues = 
                  (general_info->total_egr_queues_for_a_int_ge_ports +
                   general_info->total_egr_queues_for_a_int_hg_ports);
    if (_soc_kt2_mmu_params.cpu_port_int_ext_bounding_d_c == 0) {
        general_info->total_int_buff_queues += general_info->total_cpu_queues; 
    }
    if (_soc_kt2_mmu_params.olp_port_int_ext_bounding_d_c == 0) {
        general_info->total_int_buff_queues += 
                      _soc_kt2_mmu_params.mmu_num_olp_queue; 
    }
    general_info->total_int_buff_queues += 
                  _soc_kt2_mmu_params.mmu_num_loopback_queue;
    general_info->total_int_buff_queues += 
                  (_soc_kt2_mmu_params.mmu_num_ep_redirection_queue / 2);

    /* C86 = $C$81+$C$83+IF(C33=1,C84,0)+IF(C39=1,C38,0)+IF(C17=1,C36/2,0) */
    general_info->total_ext_buff_queues =
             (general_info->total_egr_queues_for_a_ext_ge_ports +
              general_info->total_egr_queues_for_a_ext_hg_ports);
    if (_soc_kt2_mmu_params.cpu_port_int_ext_bounding_d_c) {
        general_info->total_ext_buff_queues += general_info->total_cpu_queues; 
    }
    if (_soc_kt2_mmu_params.olp_port_int_ext_bounding_d_c) {
        general_info->total_ext_buff_queues += 
                      _soc_kt2_mmu_params.mmu_num_olp_queue;
    }
    if (_soc_kt2_mmu_params.extbuf_used_d_c) {
        general_info->total_ext_buff_queues += 
                      (_soc_kt2_mmu_params.mmu_num_ep_redirection_queue/2);
    }

    /* C87 = C52 */
    general_info->total_ema_queues = _soc_kt2_mmu_params.mmu_ema_queues;

    /* C90 = C85+C86 */ 
    general_info->total_egr_queues_in_device = 
                  general_info->total_int_buff_queues + 
                  general_info->total_ext_buff_queues;
   
    /* C91 = FLOOR($C$41*1024*1024/($C$9+2),1)-C43 */
    general_info->max_int_cell_buff_size = floor_func(
                  _soc_kt2_mmu_params.mmu_int_buf_size*1024*1024,
                  _soc_kt2_mmu_params.mmu_int_buf_cell_size+2) ;
    general_info->max_int_cell_buff_size -= 
                  _soc_kt2_mmu_params.mmu_reserved_int_buf_cells;

    /* C92 = C91 */
    general_info->int_cell_buff_size_after_limitation = 
                  general_info->max_int_cell_buff_size;

    /* C93 = C75*C13 */
    if (_soc_kt2_mmu_params.packing_mode_d_c) {
        general_info->src_packing_fifo = general_info->total_num_of_ports *
                               _soc_kt2_mmu_params.max_pkt_size_support_packing;
    }
    
    /* C94 = FLOOR($C$42 *( IF($C$45, $C$92, $C$91) , 1) */
    if (_soc_kt2_mmu_params.internal_buffer_reduction_d_c) {
        temp_val = general_info->int_cell_buff_size_after_limitation;
    } else {
        temp_val = general_info->max_int_cell_buff_size;
    }
    /* temp_val -=  input_port_threshold->total_hdrm_int_buff_cells; */
    temp_val = (_soc_kt2_mmu_params.mmu_available_int_buf_size_d * temp_val)/100;
    /* Packed : C94 = FLOOR($C$42 *( IF($C$45, $C$92, $C$91) , 1) - C93 */
    if (_soc_kt2_mmu_params.packing_mode_d_c) {
        temp_val -= general_info->src_packing_fifo;
    }
    general_info->int_buff_pool = temp_val;

    /* C95 = IF($C$45,$C$92,$C$91)-C94 */
    if (_soc_kt2_mmu_params.internal_buffer_reduction_d_c) {
        temp_val = general_info->int_cell_buff_size_after_limitation;
    } else {
        temp_val = general_info->max_int_cell_buff_size;;
    }
    temp_val = temp_val - general_info->int_buff_pool;
    /* Packed : C95 = IF($C$45,$C$92,$C$91)-C94-C93 */
    if (_soc_kt2_mmu_params.packing_mode_d_c) {
        temp_val -= general_info->src_packing_fifo;
    }
    general_info->ema_pool = temp_val;

    /* C96 = IF($C$17,$C$46*1024*1024/$C$10,0) */
    if  (_soc_kt2_mmu_params.extbuf_used_d_c) {
         general_info->max_ext_cell_buff_size = 
                       (_soc_kt2_mmu_params.mmu_ext_buf_size*1024*1024)/
                       (_soc_kt2_mmu_params.mmu_ext_buf_cell_size);
    } 

    /* C99 = $C$10/($C$9+2) */
    general_info->ratio_of_ext_buff_to_int_buff_size = 
                  _soc_kt2_mmu_params.mmu_ext_buf_cell_size /
                  (_soc_kt2_mmu_params.mmu_int_buf_cell_size + 2);
    
    /* C100 = 1 */
    general_info->int_buff_cells_per_avg_size_pkt = 1;

    /* C101 = 1 */
    general_info->ext_buff_cells_per_avg_size_pkt = 1;

    /* C102 = 0.75 but normalized to 1 */
    general_info->max_prop_of_buff_used_by_one_queue_port = 75;


    /* Fill up input threshold info */
    /* C107 = CEILING(20*1024/C9, 1) */
    input_port_threshold->global_hdrm_cells_for_int_buff_pool = ceil_func(
             (20*1024),_soc_kt2_mmu_params.mmu_int_buf_cell_size);

    /* C108 = CEILING( IF($C$17, $C$107/$C$99, 0),1) */
    if ( _soc_kt2_mmu_params.extbuf_used_d_c &&
         (_soc_kt2_mmu_params.packing_mode_d_c == 0)) {
        input_port_threshold->global_hdrm_cells_for_ext_buff_pool = ceil_func(
                      input_port_threshold->global_hdrm_cells_for_int_buff_pool,
                      general_info->ratio_of_ext_buff_to_int_buff_size);
    }
    /* C109,110 = 0 */
    /* C112-C115 values are zero for lossy mode */
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        if (ext_mem_port_count) {
            /* C112*/
            input_port_threshold->hdrm_int_buff_cells_for_10G_PG = 76; 
            /* C113*/
            input_port_threshold->hdrm_ext_buff_cells_for_10G_PG =  67;
            /* C114*/
            input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_PG = 67;
        } else {
            /* C112*/
            input_port_threshold->hdrm_int_buff_cells_for_10G_PG = 180;
            /* C113*/
            input_port_threshold->hdrm_ext_buff_cells_for_10G_PG = 0;
            /* C114*/
            input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_PG = 159;
        }
        /* C115 = C114*C49 */
        input_port_threshold->hdrm_EQEs_pkts_for_10G_PG = 
            input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_PG * 
            _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;
    }
    /* C117 = C25*C16*$C$112 */
    input_port_threshold->hdrm_int_buff_cells_for_10G_total_PG = 
               (_soc_kt2_mmu_params.num_hg_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_int_buff_cells_for_10G_PG);

    /* C118 = C25*C16*C113 */
    input_port_threshold->hdrm_ext_buff_cells_for_10G_total_PG = 
               (_soc_kt2_mmu_params.num_hg_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_ext_buff_cells_for_10G_PG);

    /* C119 = C25*C16*C114 */
    input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_total_PG = 
               (_soc_kt2_mmu_params.num_hg_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_PG);

    /* C120 = C25*C16*C115 */
    input_port_threshold->hdrm_EQEs_pkts_for_10G_total_PG = 
               (_soc_kt2_mmu_params.num_hg_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_EQEs_pkts_for_10G_PG);

    /* C122-C125 values are zero for lossy mode */
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        if (ext_mem_port_count) {
            /* C122 */
            input_port_threshold->hdrm_int_buff_cells_for_1G_PG = 26; 
            /* C123 */
            input_port_threshold->hdrm_ext_buff_cells_for_1G_PG =  23;
            /* C124 */
            input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_PG = 23;
        } else {
            /* C122 */
            input_port_threshold->hdrm_int_buff_cells_for_1G_PG = 130;
            /* C123 */
            input_port_threshold->hdrm_ext_buff_cells_for_1G_PG = 0;
            /* C124 */
            input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_PG = 115;
        }
        /* C125 = C124*C49 */
        input_port_threshold->hdrm_EQEs_pkts_for_1G_PG = 
            input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_PG * 
            _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;
    }
    /* C127 = C19*C16*$C$122 */
    input_port_threshold->hdrm_int_buff_cells_for_1G_total_PG = 
               (_soc_kt2_mmu_params.num_ge_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_int_buff_cells_for_1G_PG);

    /* C128 = C19*C16*$C$123 */
    input_port_threshold->hdrm_ext_buff_cells_for_1G_total_PG = 
               (_soc_kt2_mmu_params.num_ge_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_ext_buff_cells_for_1G_PG);

    /* C129 = C19*C16*$C$124 */
    input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_total_PG = 
               (_soc_kt2_mmu_params.num_ge_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_PG);

    /* C130 = C19*C16*$C$125 */
    input_port_threshold->hdrm_EQEs_pkts_for_1G_total_PG = 
               (_soc_kt2_mmu_params.num_ge_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_EQEs_pkts_for_1G_PG);

    /* C132-C135 values are zero for lossy mode */
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        if (ext_mem_port_count) {
            /* C132 */
            input_port_threshold->hdrm_int_buff_cells_for_olp_port = 76; 
            /* C133 */
            input_port_threshold->hdrm_ext_buff_cells_for_olp_port =  67;
            /* C134 */
            input_port_threshold->hdrm_RE_WQEs_pkts_for_olp_port = 67;
        } else {
            /* C132 */
            input_port_threshold->hdrm_int_buff_cells_for_olp_port = 180;
            /* C133 */
            input_port_threshold->hdrm_ext_buff_cells_for_olp_port = 0;
            /* C134 */
            input_port_threshold->hdrm_RE_WQEs_pkts_for_olp_port = 159;
        }
        /* C135 = C134*C49 */
        input_port_threshold->hdrm_EQEs_pkts_for_olp_port = 
            input_port_threshold->hdrm_RE_WQEs_pkts_for_olp_port * 
            _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;
    }

    /* C137 = 46 */
    input_port_threshold->hdrm_int_buff_cells_for_lpbk_port =  46;
    /* C138 = 40 for external buffer  */
    if (ext_mem_port_count) {
        input_port_threshold->hdrm_ext_buff_cells_for_lpbk_port =  40;
    }
    /* C139 = 40 */
    input_port_threshold->hdrm_RE_WQEs_pkts_for_lpbk_port =  40;
    /* C140 = C139*C49 */
    input_port_threshold->hdrm_EQEs_pkts_for_lpbk_port =  
          input_port_threshold->hdrm_RE_WQEs_pkts_for_lpbk_port *
          _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;

    /* C142 = 46 */
    input_port_threshold->hdrm_int_buff_cells_for_cpu_port =  46;
    /* C143 = 40 for external buffer  */
    if (ext_mem_port_count) {
        input_port_threshold->hdrm_ext_buff_cells_for_cpu_port =  40;
    }
    /* C144 = 40 */
    input_port_threshold->hdrm_RE_WQEs_pkts_for_cpu_port =  40;
    /* C145 = C144*C49 */
    input_port_threshold->hdrm_EQEs_pkts_for_cpu_port =  
          input_port_threshold->hdrm_RE_WQEs_pkts_for_cpu_port *
          _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;
    
    /* C147 = $C$107+$C$117+$C$127+C132+C137+C142 */
    input_port_threshold->total_hdrm_int_buff_cells = 
              input_port_threshold->global_hdrm_cells_for_int_buff_pool +
              input_port_threshold->hdrm_int_buff_cells_for_10G_total_PG +
              input_port_threshold->hdrm_int_buff_cells_for_1G_total_PG +
              input_port_threshold->hdrm_int_buff_cells_for_olp_port +
              input_port_threshold->hdrm_int_buff_cells_for_lpbk_port +
              input_port_threshold->hdrm_int_buff_cells_for_cpu_port;

    /* C148 = $C$107+$C$117+$C$127+C132+C137+C142. For internal memory=0*/
    if (ext_mem_port_count) {
        input_port_threshold->total_hdrm_int_buff_ema_pool_cells = 
              input_port_threshold->global_hdrm_cells_for_int_buff_pool +
              input_port_threshold->hdrm_int_buff_cells_for_10G_total_PG +
              input_port_threshold->hdrm_int_buff_cells_for_1G_total_PG +
              input_port_threshold->hdrm_int_buff_cells_for_olp_port +
              input_port_threshold->hdrm_int_buff_cells_for_lpbk_port +
              input_port_threshold->hdrm_int_buff_cells_for_cpu_port;
    }

    /* C149 = $C$108+$C$118+$C$128++C133+C138+C143 */
    input_port_threshold->total_hdrm_ext_buff_cells = 
               input_port_threshold->global_hdrm_cells_for_ext_buff_pool+
               input_port_threshold->hdrm_ext_buff_cells_for_10G_total_PG+
               input_port_threshold->hdrm_ext_buff_cells_for_1G_total_PG+
               input_port_threshold->hdrm_ext_buff_cells_for_olp_port+
               input_port_threshold->hdrm_ext_buff_cells_for_lpbk_port+
               input_port_threshold->hdrm_ext_buff_cells_for_cpu_port;

    /* C150 = $C$109+$C$119+$C$129+C134+C139+C144 */
    input_port_threshold->total_hdrm_RE_WQEs_pkts =
               input_port_threshold->global_hdrm_cells_for_RE_WQEs+
               input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_total_PG+
               input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_total_PG+
               input_port_threshold->hdrm_RE_WQEs_pkts_for_olp_port+
               input_port_threshold->hdrm_RE_WQEs_pkts_for_lpbk_port+
               input_port_threshold->hdrm_RE_WQEs_pkts_for_cpu_port;

    /* C151 = $C$110+$C$120+$C$130+C135+C140+C145 */
    input_port_threshold->total_hdrm_EQEs_pkts = 
               input_port_threshold->global_hdrm_cells_for_EQEs+
               input_port_threshold->hdrm_EQEs_pkts_for_10G_total_PG+
               input_port_threshold->hdrm_EQEs_pkts_for_1G_total_PG+
               input_port_threshold->hdrm_EQEs_pkts_for_olp_port+
               input_port_threshold->hdrm_EQEs_pkts_for_lpbk_port+
               input_port_threshold->hdrm_EQEs_pkts_for_cpu_port;
    /* C153 = $C$69 */
    input_port_threshold->min_int_buff_cells_per_PG = 
                          general_info->jumbo_frame_for_int_buff;
    /* C154 = IF($C$17, $C$153, 0) */
    if (_soc_kt2_mmu_params.extbuf_used_d_c) {
        input_port_threshold->min_int_buff_ema_pool_cells_per_PG = 
                              input_port_threshold->min_int_buff_cells_per_PG;
    }
   
    /* C155 = CEILING(IF($C$17, $C$153/$C$99, 0), 1) */
    if (_soc_kt2_mmu_params.extbuf_used_d_c) {
        input_port_threshold->min_ext_buff_cells_per_PG = ceil_func(
                              input_port_threshold->min_int_buff_cells_per_PG,
                              general_info->ratio_of_ext_buff_to_int_buff_size);
    }

    /* C156 = $C$153/$C$100 */
    input_port_threshold->min_RE_WQEs_pkt_per_PG = 
                              input_port_threshold->min_int_buff_cells_per_PG/
                              general_info->int_buff_cells_per_avg_size_pkt;

    /* C157 = $C$153/$C$100*C49 */
    input_port_threshold->min_EQEs_pkt_per_PG = 
               (input_port_threshold->min_int_buff_cells_per_PG/
                general_info->int_buff_cells_per_avg_size_pkt) *
                _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;

    /* C159 = C75*C16*$C$153 */
    input_port_threshold->min_int_buff_cells_for_total_PG =
               (general_info->total_num_of_ports *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->min_int_buff_cells_per_PG) ;

    /* C160 = C75*C16*$C$154 */
    input_port_threshold->min_int_buff_ema_pool_cells_for_total_PG =
               (general_info->total_num_of_ports *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->min_int_buff_ema_pool_cells_per_PG);

    /* C161 = C75*C16*$C$155 */
    input_port_threshold->min_ext_buff_cells_for_total_PG =
               (general_info->total_num_of_ports *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->min_ext_buff_cells_per_PG);

    /* C162 = C75*C16*$C$156 */
    input_port_threshold->min_RE_WQEs_pkts_for_total_PG =
               (general_info->total_num_of_ports *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->min_RE_WQEs_pkt_per_PG) ;

    /* C163 = C75*C16*$C$157 */
    input_port_threshold->min_EQEs_pkts_for_total_PG =
               (general_info->total_num_of_ports *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->min_EQEs_pkt_per_PG) ;

   /* C165 = 0 */
   input_port_threshold->min_int_buff_cells_for_a_port = 0;

   /* C166 = IF($C$17, $C$165, 0) */
   if (_soc_kt2_mmu_params.extbuf_used_d_c) {
       input_port_threshold->min_int_buff_ema_pool_cells_for_a_port =
         input_port_threshold->min_int_buff_cells_for_a_port ;
   }
   
   /* C167 = CEILING(IF($C$17, $C$165/$C$99, 0),1) */
   if (_soc_kt2_mmu_params.extbuf_used_d_c) {
       input_port_threshold->min_ext_buff_cells_for_a_port = 
                  input_port_threshold->min_int_buff_cells_for_a_port/    
                  general_info->ratio_of_ext_buff_to_int_buff_size;
   } 

   /* C168 = $C$165/$C$100 */
   input_port_threshold->min_RE_WQEs_pkts_for_a_port = 
                         input_port_threshold->min_int_buff_cells_for_a_port /
                         general_info->int_buff_cells_per_avg_size_pkt;

   /* C169 = $C$165/$C$100*C49 */
   input_port_threshold->min_EQEs_pkts_for_a_port = 
                         (input_port_threshold->min_int_buff_cells_for_a_port /
                          general_info->int_buff_cells_per_avg_size_pkt) *
                         _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;


   /* C171 = $C$75*$C$165 */
   input_port_threshold->min_int_buff_cells_for_total_port = 
                         (general_info->total_num_of_ports *
                          input_port_threshold->min_int_buff_cells_for_a_port);

   /* C172 = $C$75*$C$166 */
   input_port_threshold->min_int_buff_ema_pool_cells_for_total_port = 
                (general_info->total_num_of_ports *
                 input_port_threshold->min_int_buff_ema_pool_cells_for_a_port);

   /* C173 = $C$75*$C$167 */
   input_port_threshold->min_ext_buff_cells_for_total_port = 
                (general_info->total_num_of_ports *
                 input_port_threshold->min_ext_buff_cells_for_a_port);

   /* C174 = $C$75*$C$168 */
   input_port_threshold->min_RE_WQEs_pkts_for_total_port = 
                (general_info->total_num_of_ports *
                 input_port_threshold->min_RE_WQEs_pkts_for_a_port);

   /* C175 = $C$75*$C$169 */
   input_port_threshold->min_EQEs_pkts_for_total_port = 
                (general_info->total_num_of_ports *
                 input_port_threshold->min_EQEs_pkts_for_a_port);

   /* C177 = $C$159+$C$171 */
   input_port_threshold->total_min_int_buff_cells = 
              input_port_threshold->min_int_buff_cells_for_total_PG + 
              input_port_threshold->min_int_buff_cells_for_total_port;

   /* C178 = $C$160+$C$172 */
   input_port_threshold->total_min_int_buff_ema_pool_cells = 
              input_port_threshold->min_int_buff_ema_pool_cells_for_total_PG + 
              input_port_threshold->min_int_buff_ema_pool_cells_for_total_port;

   /* C179 = $C$161+$C$173 */
   input_port_threshold->total_min_ext_buff_cells = 
              input_port_threshold->min_ext_buff_cells_for_total_PG + 
              input_port_threshold->min_ext_buff_cells_for_total_port;

   /* C180 = $C$162+$C$174 */
   input_port_threshold->total_min_RE_WQEs_pkts = 
              input_port_threshold->min_RE_WQEs_pkts_for_total_PG + 
              input_port_threshold->min_RE_WQEs_pkts_for_total_port;

   /* C181 = $C$163+$C$175 */
   input_port_threshold->total_min_EQEs_pkts = 
              input_port_threshold->min_EQEs_pkts_for_total_PG + 
              input_port_threshold->min_EQEs_pkts_for_total_port;

    /* Need to Defer as C183-C196 value depend on C208,C211,C209,C212,C210 values */
                
    /* Fill up output threshold info */
    /* C201 = C55 for lossy mode */
    if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) { 
        output_port_threshold->min_grntd_res_queue_cells_int_buff = 
            _soc_kt2_mmu_params.per_cos_res_cells_for_int_buff_d;
    }
    
    /* C202 = CEILING(IF($C$14, 0, IF($C$17, $C$201/$C$99, 0)),1) */
    if ((_soc_kt2_mmu_params.lossless_mode_d_c == 0) ||
         _soc_kt2_mmu_params.packing_mode_d_c) { 
        if (_soc_kt2_mmu_params.extbuf_used_d_c) {
            output_port_threshold->min_grntd_res_queue_cells_ext_buff = 
                  ceil_func((output_port_threshold->
                             min_grntd_res_queue_cells_int_buff),
                            (general_info->ratio_of_ext_buff_to_int_buff_size));
        }
    }

    /* C203 = $C$55/$C$100(for lossy:external), $C$55/$C$101(for lossy:internal */
    if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) { 
        if (_soc_kt2_mmu_params.extbuf_used_d_c) {
            output_port_threshold->min_grntd_res_queue_cells_EQEs = 
                       _soc_kt2_mmu_params.per_cos_res_cells_for_int_buff_d/
                       general_info->int_buff_cells_per_avg_size_pkt;
        } else {
            output_port_threshold->min_grntd_res_queue_cells_EQEs = 
                       _soc_kt2_mmu_params.per_cos_res_cells_for_int_buff_d/
                       general_info->ext_buff_cells_per_avg_size_pkt;

        }
    }

    /* C204 = IF($C$14, 0, IF($C$17, $C$55, 0)) */
    if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) { 
        if (_soc_kt2_mmu_params.extbuf_used_d_c) {
            output_port_threshold->min_grntd_res_EMA_queue_cells = 
                  _soc_kt2_mmu_params.per_cos_res_cells_for_int_buff_d;
        }
    }

    /* C205 = C201 */
    output_port_threshold->min_grntd_res_RE_WQs_cells =
           output_port_threshold->min_grntd_res_queue_cells_int_buff;

    /* C206 = C201 */
    output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_int_buff =
           output_port_threshold->min_grntd_res_queue_cells_int_buff;

    /* C207 = CEILING(IF($C$14, 0, IF($C$17, C206/$C$99, 0)),1) */
/* Raj:    if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) {  */
        if (_soc_kt2_mmu_params.extbuf_used_d_c) {
            output_port_threshold->
                   min_grntd_res_RE_WQs_queue_cells_for_ext_buff = ceil_func(
                   output_port_threshold->
                          min_grntd_res_RE_WQs_queue_cells_for_int_buff,
                   general_info->ratio_of_ext_buff_to_int_buff_size);
        }
/*    } */

    /* C208 = 4 */
    output_port_threshold->min_grntd_res_EP_redirect_queue_entry_cells = 4;


    if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) { 
        /* C210 = C85*$C$201 */
        output_port_threshold->min_grntd_tot_res_queue_cells_int_buff =
              general_info->total_int_buff_queues *
              output_port_threshold->min_grntd_res_queue_cells_int_buff;
    } else {
        /* C210 = ($C$80+C82)*$C$201+IF(C33=0,C32*C31*C72)+(C35+C36/2)*C72 */
        output_port_threshold->min_grntd_tot_res_queue_cells_int_buff = 
                   (general_info->total_egr_queues_for_a_int_ge_ports + 
                    general_info->total_egr_queues_for_a_int_hg_ports) *
                   output_port_threshold->min_grntd_res_queue_cells_int_buff;
        if (_soc_kt2_mmu_params.cpu_port_int_ext_bounding_d_c == 0) {
            output_port_threshold->min_grntd_tot_res_queue_cells_int_buff += 
                        _soc_kt2_mmu_params.mmu_num_cpu_queue *
                        _soc_kt2_mmu_params.mmu_num_cpu_port *
                        general_info->ether_mtu_cells_for_int_buff;
        } 
        output_port_threshold->min_grntd_tot_res_queue_cells_int_buff +=
               (_soc_kt2_mmu_params.mmu_num_loopback_queue + 
                (_soc_kt2_mmu_params.mmu_num_ep_redirection_queue/2)) *
               general_info->ether_mtu_cells_for_int_buff;
    }

    if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) { 
        /* C211 = $C$86*$C$202 */
        output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff =
              general_info->total_ext_buff_queues *
              output_port_threshold->min_grntd_res_queue_cells_ext_buff;
    } else {
        /* C211 = ($C$81+C83)*$C$202+IF(C33=1,C32*C31, 0)*C72+IF(C17=1, (C36/2)*C72, 0) */
        /* Packed Lossless : C211 = ($C$81+C83-C19*8)*$C$202+IF(C33=1,C32*C31, 0)*C72+IF(C17=1, (C36/2)*C72, 0) */
        output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff =
               (general_info->total_egr_queues_for_a_ext_ge_ports  + 
                general_info->total_egr_queues_for_a_ext_hg_ports);
        if (_soc_kt2_mmu_params.packing_mode_d_c) {
            output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff -= 
                _soc_kt2_mmu_params.num_ge_ports_d * 8;
        }
        output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff *=
                    output_port_threshold->min_grntd_res_queue_cells_ext_buff;
        if (_soc_kt2_mmu_params.cpu_port_int_ext_bounding_d_c) {
            output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff +=
                  (_soc_kt2_mmu_params.mmu_num_cpu_queue * 
                   _soc_kt2_mmu_params.mmu_num_cpu_port * 
                   general_info->ether_mtu_cells_for_int_buff);
        }
        if (_soc_kt2_mmu_params.extbuf_used_d_c) {
            output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff +=
                  (_soc_kt2_mmu_params.mmu_num_ep_redirection_queue/2)*
                   general_info->ether_mtu_cells_for_int_buff;
        }
    }

    if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) { 
        /* C212 = C90*$C$203 */
        /* Packed Lossy : C212 = (C90-C19*8)*$C$203 */
        output_port_threshold->min_grntd_tot_res_queue_cells_EQEs = 
              general_info->total_egr_queues_in_device;
        if (_soc_kt2_mmu_params.packing_mode_d_c) {
            output_port_threshold->min_grntd_tot_res_queue_cells_EQEs -= 
                _soc_kt2_mmu_params.num_ge_ports_d * 8;
        }
        output_port_threshold->min_grntd_tot_res_queue_cells_EQEs *=
              output_port_threshold->min_grntd_res_queue_cells_EQEs;
    } else {
        /* C212 = =SUM(C80:C83)*$C$203+C32*C31*C72+C37*C38*C203+(C35+C36)*C72 */
        output_port_threshold->min_grntd_tot_res_queue_cells_EQEs = 
               (general_info->total_egr_queues_for_a_int_ge_ports +
                general_info->total_egr_queues_for_a_ext_ge_ports +
                general_info->total_egr_queues_for_a_int_hg_ports +
                general_info->total_egr_queues_for_a_int_hg_ports) *
                output_port_threshold->min_grntd_res_queue_cells_EQEs;
        output_port_threshold->min_grntd_tot_res_queue_cells_EQEs +=
                  (_soc_kt2_mmu_params.mmu_num_cpu_queue * 
                   _soc_kt2_mmu_params.mmu_num_cpu_port * 
                   general_info->ether_mtu_cells_for_int_buff);
        output_port_threshold->min_grntd_tot_res_queue_cells_EQEs +=
                   _soc_kt2_mmu_params.mmu_num_olp_port_d * 
                   _soc_kt2_mmu_params.mmu_num_olp_queue * 
                   output_port_threshold->min_grntd_res_queue_cells_EQEs;
        output_port_threshold->min_grntd_tot_res_queue_cells_EQEs +=
                  (_soc_kt2_mmu_params.mmu_num_loopback_queue +
                   _soc_kt2_mmu_params.mmu_num_ep_redirection_queue) *
                   general_info->ether_mtu_cells_for_int_buff;
    }

    /* C213 = $C$52*$C$204 */
    output_port_threshold->min_grntd_tot_res_EMA_queue_cells = 
              _soc_kt2_mmu_params.mmu_ema_queues *
              output_port_threshold->min_grntd_res_EMA_queue_cells;

    /* C214 = $C$51*$C$205 */
    output_port_threshold->min_grntd_tot_res_RE_WQs_cells = 
              _soc_kt2_mmu_params.mmu_repl_engine_work_queue_in_device *
              output_port_threshold->min_grntd_res_RE_WQs_cells;

    /* C215 = $C$51*$C$206 */
    output_port_threshold->min_grntd_tot_res_RE_WQs_queue_cells_for_int_buff = 
           _soc_kt2_mmu_params.mmu_repl_engine_work_queue_in_device *
           output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_int_buff;

    /* C216 = $C$51*$C$207 */
    output_port_threshold->min_grntd_tot_res_RE_WQs_queue_cells_for_ext_buff = 
           _soc_kt2_mmu_params.mmu_repl_engine_work_queue_in_device *
           output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_ext_buff;

    /* C217 = C208*(C36) */
    output_port_threshold->min_grntd_tot_res_EP_redirect_queue_entry_cells = 
           _soc_kt2_mmu_params.mmu_num_ep_redirection_queue *
           output_port_threshold->min_grntd_res_EP_redirect_queue_entry_cells;

    /* Resuming C183-C196 values as C210,C213,C211,C214,C212 values are 
       available  now*/

    /* For Lossless : C183 = $C$94-$C$177 -$C$147 -$C$210 */
    /* For Lossy    : C183 = $C$94-$C$177 -$C$147 */
    input_port_threshold->total_shared_ing_buff_pool =
           general_info->int_buff_pool - 
           input_port_threshold->total_min_int_buff_cells -
           input_port_threshold->total_hdrm_int_buff_cells;
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        input_port_threshold->total_shared_ing_buff_pool -=
              output_port_threshold->min_grntd_tot_res_queue_cells_int_buff;
    }

    /* C184 = $C$95-$C$178-$C$213 */
    /* IntMemLossy       =  =IF(C17,$C$95-$C$178-$C$148,0) */ 
    /* IntMemLossless       =IF(C17,$C$95-$C$178-$C$148 -$C$213,0) */
    /* IntExtMemLossy       ==      $C$95-$C$178-$C$148 */
    /* IntExtMemLossless    ==      $C$95-$C$178-$C$148 -$C$213 */
    if (_soc_kt2_mmu_params.extbuf_used_d_c) {
        input_port_threshold->total_shared_EMA_buff =
           general_info->ema_pool - 
           input_port_threshold->total_min_int_buff_ema_pool_cells -
           input_port_threshold->total_hdrm_int_buff_ema_pool_cells;
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            input_port_threshold->total_shared_EMA_buff -=
               output_port_threshold->min_grntd_tot_res_EMA_queue_cells;
        }
    }

    /* C185 = if (lossless)     $C$96-$C$149-$C$179-$C$211 
              if (lossy)        $C$96-$C$149-$C$179
              Packed Lossless   $C$96-$C$149-$C$179-$C$211-C54  
              Packed Lossy      $C$96-$C$149-$C$179-C54 */
    input_port_threshold->total_shared_ext_buff =
           general_info->max_ext_cell_buff_size - 
           input_port_threshold->total_hdrm_ext_buff_cells -
           input_port_threshold->total_min_ext_buff_cells;
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        input_port_threshold->total_shared_ext_buff -=
           output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff;
    }
    if (_soc_kt2_mmu_params.packing_mode_d_c) {
        input_port_threshold->total_shared_ext_buff -=
           _soc_kt2_mmu_params.num_cells_rsrvd_ing_ext_buf;
    }

    /* C186 = if (lossless)     ($C$50*1024)-$C$150-$C$180-$C$214
              if (lossy)        ($C$50*1024)-$C$150-$C$180       */
    input_port_threshold->total_shared_RE_WQEs_buff =
              (_soc_kt2_mmu_params.mmu_repl_engine_work_queue_entries*1024) -
              input_port_threshold->total_hdrm_RE_WQEs_pkts -
              input_port_threshold->total_min_RE_WQEs_pkts;
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        input_port_threshold->total_shared_RE_WQEs_buff -=
           output_port_threshold->min_grntd_tot_res_RE_WQs_cells;
    }

    /* C187 = if (lossless)     ($C$47*1024)-$C$151-$C$181-$C$212
              if (lossy)        ($C$47*1024)-$C$151-$C$181    */
    input_port_threshold->total_shared_EQEs_buff =
             (_soc_kt2_mmu_params.mmu_egress_queue_entries * 1024) -
             input_port_threshold->total_hdrm_EQEs_pkts - 
             input_port_threshold->total_min_EQEs_pkts; 
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        input_port_threshold->total_shared_EQEs_buff -=
           output_port_threshold->min_grntd_tot_res_queue_cells_EQEs;
    }

    /* C189 = FLOOR(($C$57*$C$183)/(1+($C$57*1)),1) */
    input_port_threshold->ingress_burst_cells_size_for_one_port = floor_func(
              (_soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param * 
               input_port_threshold->total_shared_ing_buff_pool),
              (1+(_soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param*1)));

    /* C190 = FLOOR(($C$57*$C$187)/(1+($C$57*1)),1) */
    input_port_threshold->ingress_burst_pkts_size_for_one_port = floor_func(
              (_soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param *
               input_port_threshold->total_shared_EQEs_buff),
              (1+(_soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param*1)));

    /* C191 = FLOOR(($C$57*$C$183)/(1+($C$57*$C$75)),1) */
    input_port_threshold->ingress_burst_cells_size_for_all_ports = floor_func(
                         (_soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param *
                          input_port_threshold->total_shared_ing_buff_pool),
                         (1+(_soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param*
                             general_info->total_num_of_ports)));

    /* C192 = ($C$191+$C$165)*$C$75 */
    input_port_threshold->ingress_total_shared_cells_use_for_all_port = 
          (input_port_threshold->ingress_burst_cells_size_for_all_ports + 
           input_port_threshold->min_int_buff_cells_for_a_port) * 
           general_info->total_num_of_ports;

    /* C193 = FLOOR(($C$57*$C$187)/(1+($C$57*$C$75)),1) */
    input_port_threshold->ingress_burst_pkts_size_for_all_port = floor_func(
           _soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param *
           input_port_threshold->total_shared_EQEs_buff,
           (1+(_soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param*
               general_info->total_num_of_ports)));

    /* C194 = ($C$193+$C$169)*$C$75 */
    input_port_threshold->ingress_total_shared_pkts_use_for_all_port =
              (input_port_threshold->ingress_burst_pkts_size_for_all_port+
               input_port_threshold->min_EQEs_pkts_for_a_port) * 
              general_info->total_num_of_ports;

    if ((ext_mem_port_count == 0) &&
        (_soc_kt2_mmu_params.lossless_mode_d_c == 0) &&
        (_soc_kt2_mmu_params.packing_mode_d_c == 0)) { 
        /* C195 = $C$192+C147 */
        input_port_threshold->ingress_total_shared_hdrm_cells_use_for_all_port =
          input_port_threshold->ingress_total_shared_cells_use_for_all_port +
          input_port_threshold->total_hdrm_int_buff_cells;
    } else {
        /* C195 = $C$192+C132 */
        input_port_threshold->ingress_total_shared_hdrm_cells_use_for_all_port =
          input_port_threshold->ingress_total_shared_cells_use_for_all_port +
          input_port_threshold->hdrm_int_buff_cells_for_olp_port;
    }

    if ((ext_mem_port_count == 0) &&
        (_soc_kt2_mmu_params.lossless_mode_d_c == 0) &&
        (_soc_kt2_mmu_params.packing_mode_d_c == 0)) { 
        /* C196 = $C$194+C151 */
        input_port_threshold->ingress_total_shared_hdrm_pkts_use_for_all_port = 
          input_port_threshold->ingress_total_shared_pkts_use_for_all_port +
          input_port_threshold->total_hdrm_EQEs_pkts;
    } else {
        /* C196 = $C$194+C135 */
        input_port_threshold->ingress_total_shared_hdrm_pkts_use_for_all_port = 
          input_port_threshold->ingress_total_shared_pkts_use_for_all_port +
          input_port_threshold->hdrm_EQEs_pkts_for_olp_port;
    }

    if ((_soc_kt2_mmu_params.lossless_mode_d_c == 0) && 
        (_soc_kt2_mmu_params.extbuf_used_d_c)) {
        /* C219 = =$C$94-$C$210-C215 */
        output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff = 
                  general_info->int_buff_pool -
                  output_port_threshold->
                         min_grntd_tot_res_queue_cells_int_buff-
                  output_port_threshold->
                         min_grntd_tot_res_RE_WQs_queue_cells_for_int_buff;
    } else { 
        /* C219 = IF($C$45, $C$92, $C$91)-$C$210-C215 */
        if (_soc_kt2_mmu_params.internal_buffer_reduction_d_c ) {
            output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff = 
                  general_info->int_cell_buff_size_after_limitation;
        } else {
            output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff = 
                  general_info->max_int_cell_buff_size ;
        }
        output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff -= 
           output_port_threshold->min_grntd_tot_res_queue_cells_int_buff ;
        output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff -= 
           output_port_threshold->
                  min_grntd_tot_res_RE_WQs_queue_cells_for_int_buff;
    }

    /* C220 = $C$96-$C$211-C216 */
    output_port_threshold->min_grntd_tot_shr_queue_cells_ext_buff = 
       general_info->max_ext_cell_buff_size -
       output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff;
    if (_soc_kt2_mmu_params.extbuf_used_d_c) {
       output_port_threshold->min_grntd_tot_shr_queue_cells_ext_buff -= 
       output_port_threshold->min_grntd_tot_res_RE_WQs_queue_cells_for_ext_buff;
    }
 
    /* C221  = $C$47*1024-$C$212 */
    output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs =
                (_soc_kt2_mmu_params.mmu_egress_queue_entries*1024) -
                output_port_threshold->min_grntd_tot_res_queue_cells_EQEs;

    if ((_soc_kt2_mmu_params.lossless_mode_d_c) && 
        (_soc_kt2_mmu_params.extbuf_used_d_c)) {
        /* C222 = IF($C$45,$C$92,$C$91)-$C$213 */
        if (_soc_kt2_mmu_params.internal_buffer_reduction_d_c ) {
            output_port_threshold->min_grntd_tot_shr_EMA_queue_cells =
                              general_info->int_cell_buff_size_after_limitation;
        } else {
            output_port_threshold->min_grntd_tot_shr_EMA_queue_cells =
                              general_info->max_int_cell_buff_size;
        }
        output_port_threshold->min_grntd_tot_shr_EMA_queue_cells -=
                    output_port_threshold->min_grntd_tot_res_EMA_queue_cells;
    } else {
        /* C222 = =$C$95-$C$213 */
        output_port_threshold->min_grntd_tot_shr_EMA_queue_cells =
                   general_info->ema_pool - 
                   output_port_threshold->min_grntd_tot_res_EMA_queue_cells;
    }

    /* C223 = =$C$50*1024-$C$214 */
    output_port_threshold->min_grntd_tot_shr_RE_WQs_cells = 
                (_soc_kt2_mmu_params.mmu_repl_engine_work_queue_entries * 1024)-
                output_port_threshold->min_grntd_tot_res_RE_WQs_cells;

    /* C224 = =C219 */
    output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_int_buff = 
           output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff ;

    /* C225 =  =C220*/
    if (_soc_kt2_mmu_params.extbuf_used_d_c) {
        output_port_threshold->
        min_grntd_tot_shr_RE_WQs_queue_cells_for_ext_buff = 
           output_port_threshold->min_grntd_tot_shr_queue_cells_ext_buff ;
    } else {
        /* C225 = =$C$95-$C$216 */
        output_port_threshold->
               min_grntd_tot_shr_RE_WQs_queue_cells_for_ext_buff = 
                 general_info->ema_pool -  
                 output_port_threshold->
                        min_grntd_tot_res_RE_WQs_queue_cells_for_ext_buff;

    }

    /* C226 = =C48-C217 */
    output_port_threshold->min_grntd_tot_shr_EP_redirect_queue_entry_cells =
         _soc_kt2_mmu_params.mmu_ep_redirect_queue_entries - 
         output_port_threshold->min_grntd_tot_res_EP_redirect_queue_entry_cells; 
    /* C227 = 2 */
    output_port_threshold->egress_queue_dynamic_threshold_parameter = 2;

    /* C228 = =FLOOR( ($C$59*$C$219)/(1+($C$59*1)), 1) */
    output_port_threshold->egress_burst_cells_size_for_one_queue = floor_func(
                (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param * 
                 output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff),
                (1 + (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param*1)));

    /* C229 = =FLOOR( ($C$59*$C$221)/(1+($C$59*1)), 1) */
    output_port_threshold->egress_burst_pkts_size_for_one_queue = floor_func(
                (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *  
                 output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs),
                (1 + (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param * 1)));

    /* C230 = =FLOOR( ($C$59*$C$219)/(1+($C$59*$C$75)), 1) */
    output_port_threshold->egress_burst_cells_size_for_all_ports = floor_func(
                (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *  
                 output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff),
                (1 + (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *
                      general_info->total_num_of_ports)));

    /* C231 = =FLOOR( ($C$59*$C$221)/(1+($C$59*$C$75)), 1) */
    output_port_threshold->egress_burst_pkts_size_for_all_ports = floor_func(
                (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *  
                 output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs),
                (1 + (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *
                      general_info->total_num_of_ports)));

    /* C232 = =FLOOR( ($C$59*$C$219)/(1+($C$59*C90)), 1) */
    output_port_threshold->egress_burst_cells_size_for_all_queues = floor_func(
                (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *  
                 output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff),
                (1 + (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *
                      general_info->total_egr_queues_in_device)));
    
    /* C233 = =FLOOR( ($C$59*$C$221)/(1+($C$59*C90)), 1) */
    output_port_threshold->egress_burst_pkts_size_for_all_queues = floor_func(
                (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *  
                 output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs),
                (1 + (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *
                      general_info->total_egr_queues_in_device)));

    /* C234 = =C90*$C$232 */
    output_port_threshold->egress_total_use_in_cells_for_all_queues =
           general_info->total_egr_queues_in_device *
           output_port_threshold->egress_burst_cells_size_for_all_queues;

    /* C235 = =C90*$C$233 */
    output_port_threshold->egress_total_use_in_pkts_for_all_queues =
           general_info->total_egr_queues_in_device *
           output_port_threshold->egress_burst_pkts_size_for_all_queues;

    /* C236 =$C$219-C234 */
    output_port_threshold->egress_remaining_cells_for_all_queues =
           output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff -
           output_port_threshold->egress_total_use_in_cells_for_all_queues;

    /* C237 = =$C$221-C235 */
    output_port_threshold->egress_remaining_pkts_for_all_queues =
           output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs -
           output_port_threshold->egress_total_use_in_pkts_for_all_queues;


    /* ===================== */
    /* Device Wide Registers */
    /* ===================== */

    /* C241: CFAPIFULLSETPOINT.CFAPIFULLSETPOINT = =C92 */
    SOC_IF_ERROR_RETURN(READ_CFAPIFULLSETPOINTr(unit, &rval) != SOC_E_NONE);
    soc_reg_field_set(unit, CFAPIFULLSETPOINTr, &rval, CFAPIFULLSETPOINTf,
                             general_info->int_cell_buff_size_after_limitation);
    SOC_IF_ERROR_RETURN(WRITE_CFAPIFULLSETPOINTr(unit, rval));

    /* C242: CFAPIFULLRESETPOINT.CFAPIFULLRESETPOINT = =C241-C69*2 */
    SOC_IF_ERROR_RETURN(READ_CFAPIFULLRESETPOINTr(unit, &rval));
    soc_reg_field_set(unit, CFAPIFULLRESETPOINTr, &rval, CFAPIFULLRESETPOINTf,
        general_info->int_cell_buff_size_after_limitation -
        (2* general_info->jumbo_frame_for_int_buff));
    SOC_IF_ERROR_RETURN(WRITE_CFAPIFULLRESETPOINTr(unit, rval));

    if (_soc_kt2_mmu_params.packing_mode_d_c) {
        /* C243: MISCCONFIG.BUFFER_SIZE  = 0x01 */
        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, BUFFER_SIZEf, 1);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
        
        /* C244: TOP_SW_BOND_OVRD_CTRL1.MMU_PACKING_ENABLE = 0x01 */
        SOC_IF_ERROR_RETURN(READ_TOP_SW_BOND_OVRD_CTRL1r(unit, &rval));
        soc_reg_field_set(unit, TOP_SW_BOND_OVRD_CTRL1r, &rval, MMU_PACKING_ENABLEf, 1);
        SOC_IF_ERROR_RETURN(WRITE_TOP_SW_BOND_OVRD_CTRL1r(unit, rval));

        /* C245: MMU_ENQ_PACKING_REAS_FIFO_PROFILE_THRESH[0..3].THRESH_PROFILE_[0..3] = 0x0A */
        SOC_IF_ERROR_RETURN(READ_MMU_ENQ_PACKING_REAS_FIFO_PROFILE_THRESHr(unit, &rval));
        soc_reg_field_set(unit, MMU_ENQ_PACKING_REAS_FIFO_PROFILE_THRESHr, &rval, THRESH_PROFILE_0f, 0x0a);
        soc_reg_field_set(unit, MMU_ENQ_PACKING_REAS_FIFO_PROFILE_THRESHr, &rval, THRESH_PROFILE_1f, 0x0a);
        soc_reg_field_set(unit, MMU_ENQ_PACKING_REAS_FIFO_PROFILE_THRESHr, &rval, THRESH_PROFILE_2f, 0x0a);
        soc_reg_field_set(unit, MMU_ENQ_PACKING_REAS_FIFO_PROFILE_THRESHr, &rval, THRESH_PROFILE_3f, 0x0a);
        SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PACKING_REAS_FIFO_PROFILE_THRESHr(unit, rval));

        /* C246: MMU_ENQ_PACKING_REAS_FIFO_THRESH_PROFILE_[0/1/2].SRCPORT_[0..41] = 0 */
        rval = 0;
        SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PACKING_REAS_FIFO_THRESH_PROFILE_0r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PACKING_REAS_FIFO_THRESH_PROFILE_1r(unit, rval));
        SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PACKING_REAS_FIFO_THRESH_PROFILE_2r(unit, rval));

        /* C247: THDO_MISCCONFIG.UCMC_SEPARATION = 0 */
        SOC_IF_ERROR_RETURN(READ_THDO_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, THDO_MISCCONFIGr, &rval, UCMC_SEPARATIONf, 0);
        SOC_IF_ERROR_RETURN(WRITE_THDO_MISCCONFIGr(unit, rval));
        
        /* C248: WRED_MISCCONFIG.UCMC_SEPARATION = 0 */
        SOC_IF_ERROR_RETURN(READ_WRED_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, WRED_MISCCONFIGr, &rval, UCMC_SEPARATIONf, 0);
        SOC_IF_ERROR_RETURN(WRITE_WRED_MISCCONFIGr(unit, rval));

        /* C249: MISCCONFIG.THDI_ROLLOVER_COUNT = 0xB4 */
        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, THDI_ROLLOVER_COUNTf, 0xb4);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
    }
    
    /* Input port thresholds */
    /* C251: COLOR_AWARE.ENABLE = 0 */
    SOC_IF_ERROR_RETURN(READ_COLOR_AWAREr (unit, &rval));
    soc_reg_field_set(unit, COLOR_AWAREr, &rval, ENABLEf, 0);
    SOC_IF_ERROR_RETURN(WRITE_COLOR_AWAREr (unit, rval));


    /* Internal Buffer Ingress Pool */
    /* C253: GLOBAL_HDRM_LIMIT.GLOBAL_HDRM_LIMIT = =$C$107 */

    SOC_IF_ERROR_RETURN(READ_GLOBAL_HDRM_LIMITr (unit, &rval));
    soc_reg_field_set(unit, GLOBAL_HDRM_LIMITr, &rval, GLOBAL_HDRM_LIMITf,
            input_port_threshold->global_hdrm_cells_for_int_buff_pool);
    SOC_IF_ERROR_RETURN(WRITE_GLOBAL_HDRM_LIMITr (unit, rval));

    /* C254: BUFFER_CELL_LIMIT_SP.LIMIT =  =$C$183 */
    SOC_IF_ERROR_RETURN(READ_BUFFER_CELL_LIMIT_SPr (unit, service_pool, &rval));
    soc_reg_field_set(unit, BUFFER_CELL_LIMIT_SPr, &rval, LIMITf,
                      input_port_threshold->total_shared_ing_buff_pool);
    SOC_IF_ERROR_RETURN(WRITE_BUFFER_CELL_LIMIT_SPr (unit, service_pool, rval));

    /* C255: CELL_RESET_LIMIT_OFFSET_SP.OFFSET = CEILING(C75/4*C71, 1) */
    SOC_IF_ERROR_RETURN(READ_CELL_RESET_LIMIT_OFFSET_SPr (unit, 
                                                          service_pool, &rval));
    temp_val = ceil_func(general_info->total_num_of_ports,4) *
                general_info->ether_mtu_cells_for_int_buff;
    soc_reg_field_set(unit, CELL_RESET_LIMIT_OFFSET_SPr, &rval, 
                      OFFSETf, temp_val);
    SOC_IF_ERROR_RETURN(WRITE_CELL_RESET_LIMIT_OFFSET_SPr (unit, 
                                                           service_pool, rval));

    /* External Buffer */
    if (ext_mem_port_count) { /* not applicable for all internal mem port */
        /* C257: THDIEXT_GLOBAL_HDRM_LIMIT.GLOBAL_HDRM_LIMIT = =C108 */
        SOC_IF_ERROR_RETURN(READ_THDIEXT_GLOBAL_HDRM_LIMITr (unit, &rval));
        soc_reg_field_set(unit, THDIEXT_GLOBAL_HDRM_LIMITr, &rval,
            GLOBAL_HDRM_LIMITf, 
            input_port_threshold->global_hdrm_cells_for_ext_buff_pool);
        SOC_IF_ERROR_RETURN(WRITE_THDIEXT_GLOBAL_HDRM_LIMITr (unit, rval));

        /* C258:  THDIEXT_BUFFER_CELL_LIMIT_SP.LIMIT =C185*/
        SOC_IF_ERROR_RETURN(READ_THDIEXT_BUFFER_CELL_LIMIT_SPr (
                            unit, service_pool, &rval));
        soc_reg_field_set(unit, THDIEXT_BUFFER_CELL_LIMIT_SPr, &rval, LIMITf,
                          input_port_threshold->total_shared_ext_buff);
        SOC_IF_ERROR_RETURN(WRITE_THDIEXT_BUFFER_CELL_LIMIT_SPr (unit, 0,rval));

        /* C259:THDIEXT_CELL_RESET_LIMIT_OFFSET_SP.OFFSET=CEILING(C75/4*C73,1)*/
        SOC_IF_ERROR_RETURN(READ_THDIEXT_CELL_RESET_LIMIT_OFFSET_SPr (
                            unit, service_pool, &rval));
        temp_val = (general_info->total_num_of_ports * 
                    general_info->ether_mtu_cells_for_ext_buff) / 4;
        if (general_info->total_num_of_ports % 4) {
            temp_val++;
        }
        soc_reg_field_set(unit, 
                THDIEXT_CELL_RESET_LIMIT_OFFSET_SPr, &rval, OFFSETf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_THDIEXT_CELL_RESET_LIMIT_OFFSET_SPr (
                            unit, service_pool, rval));


        /* EMA pool */
        /* C261: THDIEMA_GLOBAL_HDRM_LIMIT.GLOBAL_HDRM_LIMIT==C107 */
        SOC_IF_ERROR_RETURN(READ_THDIEMA_GLOBAL_HDRM_LIMITr (unit, &rval));
        soc_reg_field_set(unit, THDIEMA_GLOBAL_HDRM_LIMITr, &rval,
            GLOBAL_HDRM_LIMITf,
            input_port_threshold->global_hdrm_cells_for_int_buff_pool);
        SOC_IF_ERROR_RETURN(WRITE_THDIEMA_GLOBAL_HDRM_LIMITr (unit, rval));

        /* C262:  THDIEMA_BUFFER_CELL_LIMIT_SP.LIMIT = =C184 */
        SOC_IF_ERROR_RETURN(READ_THDIEMA_BUFFER_CELL_LIMIT_SPr (
                            unit, service_pool, &rval));
        soc_reg_field_set(unit, THDIEMA_BUFFER_CELL_LIMIT_SPr, &rval, LIMITf,
                          input_port_threshold->total_shared_EMA_buff);
        SOC_IF_ERROR_RETURN(WRITE_THDIEMA_BUFFER_CELL_LIMIT_SPr (unit, 0,rval));

        /* C263:THDIEMA_CELL_RESET_LIMIT_OFFSET_SP.OFFSET=CEILING(C75/4*C72,1)*/
        SOC_IF_ERROR_RETURN(READ_THDIEMA_CELL_RESET_LIMIT_OFFSET_SPr (
                            unit, service_pool, &rval));
        temp_val = ceil_func(general_info->total_num_of_ports,4) *
                             general_info->ether_mtu_cells_for_int_buff ;
        soc_reg_field_set(
                unit, THDIEMA_CELL_RESET_LIMIT_OFFSET_SPr, &rval, OFFSETf,
                temp_val);
        SOC_IF_ERROR_RETURN(WRITE_THDIEMA_CELL_RESET_LIMIT_OFFSET_SPr (
                            unit, service_pool, rval));
    }

    /* RE WQEs */
    /* C265: THDIRQE_GLOBAL_HDRM_LIMIT.GLOBAL_HDRM_LIMIT = C109 */
    SOC_IF_ERROR_RETURN(READ_THDIRQE_GLOBAL_HDRM_LIMITr (unit, &rval));
    soc_reg_field_set(unit, THDIRQE_GLOBAL_HDRM_LIMITr, &rval,
                      GLOBAL_HDRM_LIMITf, 
                      input_port_threshold->global_hdrm_cells_for_RE_WQEs);
    SOC_IF_ERROR_RETURN(WRITE_THDIRQE_GLOBAL_HDRM_LIMITr (unit, rval));

    /* C266:  THDIRQE_BUFFER_CELL_LIMIT_SP.LIMIT =$C$186  */
    SOC_IF_ERROR_RETURN(READ_THDIRQE_BUFFER_CELL_LIMIT_SPr (
                        unit, service_pool, &rval));
    soc_reg_field_set(unit, THDIRQE_BUFFER_CELL_LIMIT_SPr, &rval, LIMITf,
                      input_port_threshold->total_shared_RE_WQEs_buff);
    SOC_IF_ERROR_RETURN(WRITE_THDIRQE_BUFFER_CELL_LIMIT_SPr (
                        unit, service_pool, rval));

    /* C267: = THDIRQE_CELL_RESET_LIMIT_OFFSET_SP.OFFSET = CEILING(C75/4, 1) */
    SOC_IF_ERROR_RETURN(READ_THDIRQE_CELL_RESET_LIMIT_OFFSET_SPr(
                        unit,service_pool,&rval));
    soc_reg_field_set(unit, THDIRQE_CELL_RESET_LIMIT_OFFSET_SPr, &rval,
                      OFFSETf, ceil_func(general_info->total_num_of_ports , 4));
    SOC_IF_ERROR_RETURN(WRITE_THDIRQE_CELL_RESET_LIMIT_OFFSET_SPr(
                        unit,service_pool,rval));

    /* EQEs */
    /* C269: THDIQEN_GLOBAL_HDRM_LIMIT.GLOBAL_HDRM_LIMIT = C110 */
    SOC_IF_ERROR_RETURN(READ_THDIQEN_GLOBAL_HDRM_LIMITr (unit, &rval));
    soc_reg_field_set(unit, THDIQEN_GLOBAL_HDRM_LIMITr, &rval,
                      GLOBAL_HDRM_LIMITf,
                      input_port_threshold->global_hdrm_cells_for_EQEs);
    SOC_IF_ERROR_RETURN(WRITE_THDIQEN_GLOBAL_HDRM_LIMITr (unit, rval));

    /* C270:  THDIQEN_BUFFER_CELL_LIMIT_SP.LIMIT =$C$187  */
    SOC_IF_ERROR_RETURN(READ_THDIQEN_BUFFER_CELL_LIMIT_SPr (
                        unit, service_pool, &rval));
    soc_reg_field_set(unit, THDIQEN_BUFFER_CELL_LIMIT_SPr, &rval, LIMITf,
                      input_port_threshold->total_shared_EQEs_buff);
    SOC_IF_ERROR_RETURN(WRITE_THDIQEN_BUFFER_CELL_LIMIT_SPr (
                        unit, service_pool, rval));

    /* C271: THDIQEN_CELL_RESET_LIMIT_OFFSET_SP.OFFSET= CEILING(C75/4*C49, 1)*/
    SOC_IF_ERROR_RETURN(READ_THDIQEN_CELL_RESET_LIMIT_OFFSET_SPr(
                        unit,service_pool,&rval));
    temp_val = ceil_func(general_info->total_num_of_ports, 4)  * 
                          _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;
    soc_reg_field_set(unit, THDIQEN_CELL_RESET_LIMIT_OFFSET_SPr, &rval, OFFSETf,
                      temp_val);
    SOC_IF_ERROR_RETURN(WRITE_THDIQEN_CELL_RESET_LIMIT_OFFSET_SPr(
                        unit,service_pool,rval));

    /* Ouput port thresholds */
    /* Internal buffer Egress pool */
    /* C274: OP_BUFFER_SHARED_LIMIT_CELLI.OP_BUFFER_SHARED_LIMIT_CELLI = C219 */
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_CELLIr (unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_CELLIr, &rval,
              OP_BUFFER_SHARED_LIMIT_CELLIf, 
              output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_CELLIr (unit, rval));
    op_buffer_shared_limit_celli = output_port_threshold->
                                   min_grntd_tot_shr_queue_cells_int_buff;

    /* C275: OP_BUFFER_SHARED_LIMIT_RESUME_CELLI.
             OP_BUFFER_SHARED_LIMIT_RESUME_CELLI */
    temp_val = op_buffer_shared_limit_celli;
    if (ext_mem_port_count == 0) {
        if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) {
            /* C275 = =C274-CEILING(C78/4, 1)*C72 */
            temp_val = temp_val - 
                       (ceil_func(general_info->
                                  total_num_of_ports_excl_lpbk_olp_cpu,4) 
                        * general_info->ether_mtu_cells_for_int_buff);
        } else {
            /* C275 = =C274-CEILING(C76/4, 1)*C72 */
            temp_val = temp_val - 
                       (ceil_func(general_info->total_num_of_ports_excl_lpbk,4)
                        * general_info->ether_mtu_cells_for_int_buff);
        }
    } else {
        /* C275 = =C274-CEILING(C75/4,1)*C72 */
        temp_val = temp_val - (ceil_func(general_info->total_num_of_ports,4) 
                               * general_info->ether_mtu_cells_for_int_buff);
    }
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_RESUME_CELLIr(unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_RESUME_CELLIr, &rval,
              OP_BUFFER_SHARED_LIMIT_RESUME_CELLIf, temp_val);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_RESUME_CELLIr(unit, rval));
    op_buffer_shared_limit_resume_celli = temp_val;

    /* C276: OP_BUFFER_LIMIT_YELLOW_CELLI.OP_BUFFER_LIMIT_YELLOW_CELLI =
             =CEILING(C274/8, 1) */
    /* C278: OP_BUFFER_LIMIT_RED_CELLI.OP_BUFFER_LIMIT_RED_CELLI =
             =CEILING(C274/8, 1) */
    temp_val = op_buffer_shared_limit_celli;
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_YELLOW_CELLIr (unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_YELLOW_CELLIr, &rval,
          OP_BUFFER_LIMIT_YELLOW_CELLIf, ceil_func(temp_val,8));
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_YELLOW_CELLIr (unit, rval));

    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RED_CELLIr (unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_RED_CELLIr, &rval,
          OP_BUFFER_LIMIT_RED_CELLIf, ceil_func( temp_val,8));
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RED_CELLIr (unit, rval));


    /* C277: OP_BUFFER_LIMIT_RESUME_YELLOW_CELLI.
             OP_BUFFER_LIMIT_RESUME_YELLOW_CELLI =CEILING(C275/8, 1) */
    /* C279: OP_BUFFER_LIMIT_RESUME_RED_CELLI.
             OP_BUFFER_LIMIT_RESUME_RED_CELLI =CEILING(C275/8, 1) */
    temp_val = op_buffer_shared_limit_resume_celli;
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_YELLOW_CELLIr (
                        unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_YELLOW_CELLIr, &rval,
              OP_BUFFER_LIMIT_RESUME_YELLOW_CELLIf, ceil_func(temp_val,8));
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_YELLOW_CELLIr (
                        unit, rval));

    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_RED_CELLIr (unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_RED_CELLIr, &rval,
              OP_BUFFER_LIMIT_RESUME_RED_CELLIf, ceil_func(temp_val,8));
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_RED_CELLIr (unit, rval));

    /* External Buffer */
    if (ext_mem_port_count) { /* not applicable for all internal mem port */
        /* C281: 
           OP_BUFFER_SHARED_LIMIT_CELLE.OP_BUFFER_SHARED_LIMIT_CELLE = C220 */
        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_CELLE_POOL0r (
                            unit, &rval));
        soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_CELLE_POOL0r, &rval,
              OP_BUFFER_SHARED_LIMIT_CELLEf, 
              output_port_threshold->min_grntd_tot_shr_queue_cells_ext_buff);
        SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_CELLE_POOL0r (
                            unit, rval));
        op_buffer_shared_limit_celle = output_port_threshold->
                                       min_grntd_tot_shr_queue_cells_ext_buff;

        /* C282: OP_BUFFER_SHARED_LIMIT_RESUME_CELLE.
             OP_BUFFER_SHARED_LIMIT_RESUME_CELLE =C281-CEILING(C75/4, 1)*C73 */
        temp_val = op_buffer_shared_limit_celle - 
                   (ceil_func(general_info->total_num_of_ports ,4) *
                    general_info->ether_mtu_cells_for_ext_buff);
        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_RESUME_CELLE_POOL0r(
                            unit, &rval));
        soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_RESUME_CELLE_POOL0r, 
                          &rval,OP_BUFFER_SHARED_LIMIT_RESUME_CELLEf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_RESUME_CELLE_POOL0r(
                            unit, rval));
        op_buffer_shared_limit_resume_celle = temp_val;
    
        /* C283: OP_BUFFER_LIMIT_YELLOW_CELLE.OP_BUFFER_LIMIT_YELLOW_CELLE =
                 =CEILING(C281/8, 1) */
        /* C285: OP_BUFFER_LIMIT_RED_CELLE.OP_BUFFER_LIMIT_RED_CELLE =
                 =CEILING(C281/8, 1) */
        temp_val = op_buffer_shared_limit_celle;
        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_YELLOW_CELLE_POOL0r (
                            unit, &rval));
        soc_reg_field_set(unit, OP_BUFFER_LIMIT_YELLOW_CELLE_POOL0r, &rval,
              OP_BUFFER_LIMIT_YELLOW_CELLEf, ceil_func(temp_val,8));
        SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_YELLOW_CELLE_POOL0r (
                          unit, rval));
    
        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RED_CELLE_POOL0r(unit, &rval));
        soc_reg_field_set(unit, OP_BUFFER_LIMIT_RED_CELLE_POOL0r, &rval,
              OP_BUFFER_LIMIT_RED_CELLEf, ceil_func( temp_val,8));
        SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RED_CELLE_POOL0r(unit, rval));


        /* C284: OP_BUFFER_LIMIT_RESUME_YELLOW_CELLE.
                 OP_BUFFER_LIMIT_RESUME_YELLOW_CELLE ==CEILING(C282/8, 1) */
        /* C286: OP_BUFFER_LIMIT_RESUME_RED_CELLE.
                 OP_BUFFER_LIMIT_RESUME_RED_CELLE ==CEILING(C282/8, 1) */
        temp_val = op_buffer_shared_limit_resume_celle;
        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_YELLOW_CELLE_POOL0r (
                            unit, &rval));
        soc_reg_field_set(unit, 
                  OP_BUFFER_LIMIT_RESUME_YELLOW_CELLE_POOL0r, &rval,
                  OP_BUFFER_LIMIT_RESUME_YELLOW_CELLEf, ceil_func(temp_val,8));
        SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_YELLOW_CELLE_POOL0r (
                            unit, rval));

        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_RED_CELLE_POOL0r (
                            unit, &rval));
        soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_RED_CELLE_POOL0r, &rval,
                  OP_BUFFER_LIMIT_RESUME_RED_CELLEf, ceil_func(temp_val,8));
        SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_RED_CELLE_POOL0r (
                            unit, rval));

        /* EMA pool */
        /* C288: 
           OP_BUFFER_SHARED_LIMIT_THDOEMA.OP_BUFFER_SHARED_LIMIT_CELLE = C222 */
        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_THDOEMAr (unit, &rval));
        soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_THDOEMAr, &rval,
              OP_BUFFER_SHARED_LIMITf, 
              output_port_threshold->min_grntd_tot_shr_EMA_queue_cells);
        SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_THDOEMAr (unit, rval));
        op_buffer_shared_limit = output_port_threshold->
                                       min_grntd_tot_shr_EMA_queue_cells;

        /* C289: OP_BUFFER_SHARED_LIMIT_RESUME_THDOEMA.
             OP_BUFFER_SHARED_LIMIT_RESUME_CELLE = C288-CEILING(C75/4,1)*C72 */
        temp_val = op_buffer_shared_limit;
        temp_val = temp_val - (ceil_func(general_info->total_num_of_ports,4) *
                               general_info->ether_mtu_cells_for_int_buff);
        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_RESUME_THDOEMAr(
                            unit, &rval));
        soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_RESUME_THDOEMAr, &rval,
                  OP_BUFFER_SHARED_LIMIT_RESUMEf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_RESUME_THDOEMAr(
                            unit, rval));
        op_buffer_shared_limit_resume = temp_val;
    
        /* C290: OP_BUFFER_LIMIT_YELLOW_THDOEMA.OP_BUFFER_LIMIT_YELLOW =
                 =CEILING(C288/8, 1) */
        /* C292: OP_BUFFER_LIMIT_RED_THDOEMA.OP_BUFFER_LIMIT_RED =
                 =CEILING(C288/8, 1) */
        temp_val = op_buffer_shared_limit;
        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_YELLOW_THDOEMAr (unit, &rval));
        soc_reg_field_set(unit, OP_BUFFER_LIMIT_YELLOW_THDOEMAr, &rval,
              OP_BUFFER_LIMIT_YELLOWf, ceil_func(temp_val,8));
        SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_YELLOW_THDOEMAr (unit, rval));
    
        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RED_THDOEMAr (unit, &rval));
        soc_reg_field_set(unit, OP_BUFFER_LIMIT_RED_THDOEMAr, &rval,
              OP_BUFFER_LIMIT_REDf, ceil_func( temp_val,8));
        SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RED_THDOEMAr (unit, rval));


        /* C291: OP_BUFFER_LIMIT_RESUME_YELLOW_THDOEMA.
                 OP_BUFFER_LIMIT_RESUME_YELLOW==CEILING(C289/8, 1) */
        /* C293: OP_BUFFER_LIMIT_RESUME_RED_THDOEMA.
                 OP_BUFFER_LIMIT_RESUME_RED==CEILING(C289/8, 1) */
        temp_val = op_buffer_shared_limit_resume;
        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_YELLOW_THDOEMAr (
                            unit, &rval));
        soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_YELLOW_THDOEMAr, &rval,
                  OP_BUFFER_LIMIT_RESUME_YELLOWf, ceil_func(temp_val,8));
        SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_YELLOW_THDOEMAr (
                            unit, rval));

        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_RED_THDOEMAr (
                            unit, &rval));
        soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_RED_THDOEMAr, &rval,
                  OP_BUFFER_LIMIT_RESUME_REDf, ceil_func(temp_val,8));
        SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_RED_THDOEMAr (
                            unit, rval));
    }
    /* RE WQEs*/
    /* C295: 
       OP_BUFFER_SHARED_LIMIT_THDORQEQ.OP_BUFFER_SHARED_LIMIT_CELLE = C223 */

    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_THDORQEQr (unit, &rval));
    SOC_FIND_FIELD(OP_BUFFER_SHARED_LIMITf,
                   SOC_REG_INFO(unit, OP_BUFFER_SHARED_LIMIT_THDORQEQr).fields,
                   SOC_REG_INFO(unit, OP_BUFFER_SHARED_LIMIT_THDORQEQr).nFields,
                   fieldp);
    temp_val = output_port_threshold->min_grntd_tot_shr_RE_WQs_cells; 
    if (temp_val >= (1 << fieldp->len)) {
        temp_val = (1 << fieldp->len) - 1;
    }
    soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_THDORQEQr, &rval,
          OP_BUFFER_SHARED_LIMITf, temp_val);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_THDORQEQr (unit, rval));
    op_buffer_shared_limit = temp_val;

    /* C296: OP_BUFFER_SHARED_LIMIT_RESUME_THDORQEQ.
             OP_BUFFER_SHARED_LIMIT_RESUME = CEILING(C223-C75/4, 1) */
    temp_val = output_port_threshold->min_grntd_tot_shr_RE_WQs_cells;
    if (ext_mem_port_count ) {
        /* =C223-CEILING(C75/4, 1) */
        temp_val -= ceil_func(general_info->total_num_of_ports,4);
    } else {
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
           /* =C223-CEILING(C76/4, 1) */
           temp_val -= ceil_func(general_info->total_num_of_ports_excl_lpbk,4);
        } else {
           /* =C223-CEILING(C78/4, 1) */
           temp_val -= ceil_func(
                       general_info->total_num_of_ports_excl_lpbk_olp_cpu,4);
        }
    }
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_RESUME_THDORQEQr(
                        unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_RESUME_THDORQEQr, &rval,
              OP_BUFFER_SHARED_LIMIT_RESUMEf, temp_val);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_RESUME_THDORQEQr(
                        unit, rval));
    op_buffer_shared_limit_resume = temp_val;

    /* C297: OP_BUFFER_LIMIT_YELLOW_THDORQEQ.OP_BUFFER_LIMIT_YELLOW =
             =CEILING(C295/8, 1)-1 */
    temp_val = ceil_func(op_buffer_shared_limit,8) ;
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        temp_val -= 1;
    }
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_YELLOW_THDORQEQr (unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_YELLOW_THDORQEQr, &rval,
          OP_BUFFER_LIMIT_YELLOWf, temp_val);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_YELLOW_THDORQEQr (unit, rval));

    /* C298: OP_BUFFER_LIMIT_RESUME_YELLOW_THDORQEQ.
             OP_BUFFER_LIMIT_RESUME_YELLOW = C297-1 */
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_YELLOW_THDORQEQr (
                        unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_YELLOW_THDORQEQr, &rval,
          OP_BUFFER_LIMIT_RESUME_YELLOWf, temp_val-1);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_YELLOW_THDORQEQr (
                        unit, rval));

    /* C299: OP_BUFFER_LIMIT_RED_THDORQEQ.OP_BUFFER_LIMIT_RED =
             =CEILING(C295/8, 1) */
    temp_val = ceil_func(op_buffer_shared_limit,8);
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        temp_val -= 1;
    }
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RED_THDORQEQr (unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_RED_THDORQEQr, &rval,
          OP_BUFFER_LIMIT_REDf, temp_val);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RED_THDORQEQr (unit, rval));


    /* C300: OP_BUFFER_LIMIT_RESUME_RED_THDORQEQ.
             OP_BUFFER_LIMIT_RESUME_RED==C299 -1 */
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_RED_THDORQEQr (
                        unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_RED_THDORQEQr, &rval,
              OP_BUFFER_LIMIT_RESUME_REDf, temp_val-1);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_RED_THDORQEQr (
                        unit, rval));

    /* EQEs */
    /* C302: OP_BUFFER_SHARED_LIMIT_QENTRY.OP_BUFFER_SHARED_LIMIT_QENTRY =C221*/
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_QENTRYr (unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_QENTRYr, &rval,
                  OP_BUFFER_SHARED_LIMIT_QENTRYf, 
                  output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_QENTRYr (unit, rval));

    temp_val = output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs;

    /* C304: OP_BUFFER_LIMIT_YELLOW_QENTRY.OP_BUFFER_LIMIT_YELLOW_QENTRY
             = CEILING(C302/8, 1)  */
    /* C306: OP_BUFFER_LIMIT_RED_QENTRY.OP_BUFFER_LIMIT_RED_QENTRY
             = CEILING(C302/8, 1)  */
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RED_QENTRYr(unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_RED_QENTRYr, &rval,
              OP_BUFFER_LIMIT_RED_QENTRYf, ceil_func(temp_val,8));
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RED_QENTRYr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_YELLOW_QENTRYr(unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_YELLOW_QENTRYr, &rval,
              OP_BUFFER_LIMIT_YELLOW_QENTRYf, ceil_func(temp_val,8));
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_YELLOW_QENTRYr(unit, rval));
    /* C303: OP_BUFFER_SHARED_LIMIT_RESUME_QENTRY = 
             =C221-CEILING(C78/4, 1)*C49
             =C221-CEILING(C76/4, 1)*C49
             =C221-CEILING(C75/4, 1)*C49 */
    temp_val= output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs;
    if (ext_mem_port_count) {
        /* C303     =C221-CEILING(C75/4, 1)*C49 */
        temp_val = temp_val - (ceil_func(general_info->total_num_of_ports,4) *
                               _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt);
    } else {
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
             /* =C221-CEILING(C76/4, 1)*C49 */
            temp_val = temp_val - 
                       (ceil_func(
                        general_info->total_num_of_ports_excl_lpbk,4) *
                        _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt);
        } else {
             /* =C221-CEILING(C78/4, 1)*C49 */
            temp_val = temp_val - 
                       (ceil_func(
                        general_info->total_num_of_ports_excl_lpbk_olp_cpu,4) *
                        _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt);
        }
    }
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_RESUME_QENTRYr(
                        unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_RESUME_QENTRYr, 
              &rval,
              OP_BUFFER_SHARED_LIMIT_RESUME_QENTRYf, temp_val);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_RESUME_QENTRYr(
              unit, rval));

    /* C305: OP_BUFFER_LIMIT_RESUME_YELLOW_QENTRY.
             OP_BUFFER_LIMIT_RESUME_YELLOW_QENTRY = =CEILING(C303/8, 1) */
    /* C307: OP_BUFFER_LIMIT_RESUME_RED_QENTRY.
             OP_BUFFER_LIMIT_RESUME_RED_QENTRY = =CEILING(C303/8, 1) */
    SOC_IF_ERROR_RETURN(
                 READ_OP_BUFFER_LIMIT_RESUME_YELLOW_QENTRYr(unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_YELLOW_QENTRYr, &rval,
                      OP_BUFFER_LIMIT_RESUME_YELLOW_QENTRYf, 
                      ceil_func(temp_val,8));
    SOC_IF_ERROR_RETURN(
                 WRITE_OP_BUFFER_LIMIT_RESUME_YELLOW_QENTRYr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_RED_QENTRYr(unit, &rval));
    soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_RED_QENTRYr, &rval,
                      OP_BUFFER_LIMIT_RESUME_RED_QENTRYf, 
                      ceil_func(temp_val,8));
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_RED_QENTRYr(unit, rval));

    /* EP Redirection Packets */
    /* C309 : OP_BUFFER_SHARED_LIMIT_THDORDEQ.OP_BUFFER_SHARED_LIMIT = C226 */
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_THDORDEQr(unit, &rval));
    soc_reg_field_set(unit,OP_BUFFER_SHARED_LIMIT_THDORDEQr,&rval,
       OP_BUFFER_SHARED_LIMITf,
       output_port_threshold->min_grntd_tot_shr_EP_redirect_queue_entry_cells);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_THDORDEQr(unit, rval));
    op_buffer_shared_limit= output_port_threshold->
                            min_grntd_tot_shr_EP_redirect_queue_entry_cells;

    /* C311: OP_BUFFER_LIMIT_YELLOW_THDORDEQ.OP_BUFFER_LIMIT_YELLOW
             = CEILING(C309/8, 1) */
    /* C313: OP_BUFFER_LIMIT_RED_THDORDEQ.OP_BUFFER_LIMIT_RED
             = CEILING(C309/8, 1) */
    temp_val = ceil_func(op_buffer_shared_limit,8);
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_YELLOW_THDORDEQr(unit, &rval));
    soc_reg_field_set(unit,OP_BUFFER_LIMIT_YELLOW_THDORDEQr,&rval,
        OP_BUFFER_LIMIT_YELLOWf, temp_val);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_YELLOW_THDORDEQr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RED_THDORDEQr(unit, &rval));
    soc_reg_field_set(unit,OP_BUFFER_LIMIT_RED_THDORDEQr,&rval,
        OP_BUFFER_LIMIT_REDf, temp_val);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RED_THDORDEQr(unit, rval));

    /* C312: OP_BUFFER_LIMIT_RESUME_YELLOW_THDORDEQ.
             OP_BUFFER_LIMIT_RESUME_YELLOW = =C311-1 */
    /* C314: OP_BUFFER_LIMIT_RESUME_RED_THDORDEQ.
             OP_BUFFER_LIMIT_RESUME_RED = =C313-1 */
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_YELLOW_THDORDEQr(
                        unit, &rval));
    soc_reg_field_set(unit,OP_BUFFER_LIMIT_RESUME_YELLOW_THDORDEQr,&rval,
        OP_BUFFER_LIMIT_RESUME_YELLOWf, temp_val-1);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_YELLOW_THDORDEQr(
                        unit, rval));
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_RED_THDORDEQr(unit, &rval));
    soc_reg_field_set(unit,OP_BUFFER_LIMIT_RESUME_RED_THDORDEQr,&rval,
        OP_BUFFER_LIMIT_RESUME_REDf, temp_val-1);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_RED_THDORDEQr(unit, rval));

    /*C310: OP_BUFFER_SHARED_LIMIT_TRESUME_THDORDEQr.
            OP_BUFFER_SHARED_LIMIT_RESUMEf = =C226-4 */
    SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_RESUME_THDORDEQr(
                        unit, &rval));
    soc_reg_field_set(unit,OP_BUFFER_SHARED_LIMIT_RESUME_THDORDEQr,&rval,
                      OP_BUFFER_SHARED_LIMIT_RESUMEf,
                      output_port_threshold->
                      min_grntd_tot_shr_EP_redirect_queue_entry_cells - 4);
    SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_RESUME_THDORDEQr(
                        unit, rval));
    /* C312: OP_BUFFER_LIMIT_RESUME_YELLOW_THDORDEQ.
             OP_BUFFER_LIMIT_RESUME_YELLOW = =C302-1 */
    /* C314: OP_BUFFER_LIMIT_RESUME_RED_THDORDEQ.
             OP_BUFFER_LIMIT_RESUME_RED = =C302-1 */


    /* Per Port Registers */
    /* ######################## */
    /* 1. Input Port Thresholds */
    /* ######################## */

    /* 1.1 Internal Buffer Ingress Pool */
    /* Assuming only service_pool = 0 is used */
    /* Assuming only prioty_Group = 0 is used */
    SOC_PBMP_ITER (valid_port_cpu_pbmp, port) {
         sal_memset(&thdi_port_sp_config,0,sizeof(thdi_port_sp_config));
         mem_idx= (port * KT2_MAX_SERVICE_POOLS) + service_pool;
         /* C320 : THDI_PORT_SP_CONFIG.PORT_SP_MIN_LIMIT = =$C$165 */
         soc_mem_field32_set(unit, THDI_PORT_SP_CONFIGm, 
             &thdi_port_sp_config, PORT_SP_MIN_LIMITf, 
             input_port_threshold->min_int_buff_cells_for_a_port);
         /* C321 : THDI_PORT_SP_CONFIG.PORT_SP_MAX_LIMIT = =$C$254 <==C183 */
         soc_mem_field32_set(unit, THDI_PORT_SP_CONFIGm, 
             &thdi_port_sp_config, PORT_SP_MAX_LIMITf, 
             input_port_threshold->total_shared_ing_buff_pool);
         /* C322 : PORT_MAX_PKT_SIZE.PORT_MAX_PKT_SIZE = =$C$68 */
         SOC_IF_ERROR_RETURN(READ_PORT_MAX_PKT_SIZEr (unit, port, &rval));
         soc_reg_field_set(unit, PORT_MAX_PKT_SIZEr, &rval,
                           PORT_MAX_PKT_SIZEf,
                           general_info->max_packet_size_in_cells);
         SOC_IF_ERROR_RETURN(WRITE_PORT_MAX_PKT_SIZEr (unit, port, rval));

         /* C323: THDI_PORT_SP_CONFIG.PORT_SP_RESUME_LIMIT = =$C$321-2*C72 */
         soc_mem_field32_set(unit, THDI_PORT_SP_CONFIGm, 
             &thdi_port_sp_config, PORT_SP_RESUME_LIMITf, 
             input_port_threshold->total_shared_ing_buff_pool - 
             (2 *  general_info->ether_mtu_cells_for_int_buff));

         SOC_IF_ERROR_RETURN (soc_mem_write(
                         unit, THDI_PORT_SP_CONFIGm, MEM_BLOCK_ALL, 
                         mem_idx, &thdi_port_sp_config));

         sal_memset(&thdi_port_pg_config,0,sizeof(thdi_port_pg_config));
         mem_idx= (port * KT2_MAX_PRIORITY_GROUPS) + priority_group;
         /* C324: THDI_PORT_PG_CONFIG.PG_MIN_LIMIT (PG0) = =$C$153 */
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, PG_MIN_LIMITf, 
             input_port_threshold->min_int_buff_cells_per_PG);

         /* C325: THDI_PORT_PG_CONFIG.PG_SHARED_LIMIT=IF($C$14, $C$58, $C$254)*/
         if (_soc_kt2_mmu_params.lossless_mode_d_c) {
             temp_val = _soc_kt2_mmu_params.mmu_ing_pg_dyn_thd_param;
         } else {
             /* $C$254 = =$C$183 */
             temp_val = input_port_threshold->total_shared_ing_buff_pool;
         } 
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, PG_SHARED_LIMITf, temp_val);

         /* C326: THDI_PORT_PG_CONFIG.PG_RESET_OFFSET = 2*$C$72 */
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, PG_RESET_OFFSETf, 
             (2 * general_info->ether_mtu_cells_for_int_buff));

         /* C327: THDI_PORT_PG_CONFIG.PG_RESET_FLOOR = 0 */
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, PG_RESET_FLOORf, 0);

         /* C328: THDI_PORT_PG_CONFIG.PG_SHARED_DYNAMIC= =IF($C$14, 1, 0) */
         if (_soc_kt2_mmu_params.lossless_mode_d_c) {
             temp_val = 1;
         } else {
             temp_val = 0;
         }
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, PG_SHARED_DYNAMICf,temp_val);

         /* C329: THDI_PORT_PG_CONFIG.PG_HDRM_LIMIT=
                  For Ge:$C122 For Hg:$C112 For Cpu:$C142 */
         if (IS_CPU_PORT(unit, port)) {
             temp_val = input_port_threshold->hdrm_int_buff_cells_for_cpu_port;
         } else if (IS_GE_PORT(unit, port)) {
             temp_val = input_port_threshold->hdrm_int_buff_cells_for_1G_PG;
         } else if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit,port) ) {
             temp_val = input_port_threshold->hdrm_int_buff_cells_for_10G_PG;
         }
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, PG_HDRM_LIMITf,temp_val);

         /* C330 : THDI_PORT_PG_CONFIG.PG_GBL_HDRM_EN = for lossy=1 else 0 */
         if (_soc_kt2_mmu_params.lossless_mode_d_c) {
             temp_val = 0;
         } else {
             temp_val = 1;
         }
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, PG_GBL_HDRM_ENf ,temp_val);

         /* C331: THDI_PORT_PG_CONFIG.SP_SHARED_MAX_ENABLE = 
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */

         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, SP_SHARED_MAX_ENABLEf ,1);

         /* C332: THDI_PORT_PG_CONFIG.SP_MIN_PG_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, SP_MIN_PG_ENABLEf ,1);

         SOC_IF_ERROR_RETURN (soc_mem_write(
                         unit, THDI_PORT_PG_CONFIGm, MEM_BLOCK_ALL, 
                         mem_idx, &thdi_port_pg_config));

         /* C324: THDI_PORT_PG_CONFIG.PG_MIN_LIMIT (PG1-7) = 1 (for HG Ports)*/
         if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit,port) /* ||
             ((port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT) &&
              (kt2_port_to_mxqblock_subports[port-1] == 0)) */) {
             for (loop =1 ; loop < KT2_MAX_PRIORITY_GROUPS;loop++) {
                  sal_memcpy(&thdi_port_pg_config_temp,
                             &thdi_port_pg_config, sizeof(thdi_port_pg_config));
                  soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
                  &thdi_port_pg_config_temp, PG_MIN_LIMITf, 1);
                  SOC_IF_ERROR_RETURN (soc_mem_write(
                         unit, THDI_PORT_PG_CONFIGm, MEM_BLOCK_ALL, 
                         mem_idx+loop, &thdi_port_pg_config_temp));
             }
         }
    }
     
    /* 1.2 External Buffer              */
    /* Assuming only service_pool = 0 is used */
    /* Assuming only prioty_Group = 0 is used */
    SOC_PBMP_ITER (valid_port_cpu_pbmp, port) {
         if (ext_mem_port_count) {
             sal_memset(&thdiext_thdi_port_sp_config,0,
                        sizeof(thdiext_thdi_port_sp_config));
             mem_idx= (port * KT2_MAX_SERVICE_POOLS) + service_pool;
             /* C335: THDIEXT_THDI_PORT_SP_CONFIG.PORT_SP_MIN_LIMIT  = $C$167 */
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_SP_CONFIGm,
                 &thdiext_thdi_port_sp_config, PORT_SP_MIN_LIMITf,
                 input_port_threshold->min_ext_buff_cells_for_a_port);

             /* C336: THDIEXT_THDI_PORT_SP_CONFIG.PORT_SP_MAX_LIMIT = 
                      $C$258 <== =C185  */
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_SP_CONFIGm,
                 &thdiext_thdi_port_sp_config, PORT_SP_MAX_LIMITf,
                 input_port_threshold->total_shared_ext_buff);

             /* C337: THDIEXT_PORT_MAX_PKT_SIZE.PORT_MAX_PKT_SIZE = =$C$70 */
             SOC_IF_ERROR_RETURN(READ_THDIEXT_PORT_MAX_PKT_SIZEr (
                                 unit, port, &rval));
             soc_reg_field_set(unit, THDIEXT_PORT_MAX_PKT_SIZEr, &rval,
                               PORT_MAX_PKT_SIZEf,
                               general_info->jumbo_frame_for_ext_buff);
             SOC_IF_ERROR_RETURN(WRITE_THDIEXT_PORT_MAX_PKT_SIZEr (
                                 unit, port, rval));
             /* C338: THDIEXT_THDI_PORT_SP_CONFIG.PORT_SP_RESUME_LIMIT =
                      =$C$336-2*$C$73 */
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_SP_CONFIGm,
                 &thdiext_thdi_port_sp_config, PORT_SP_RESUME_LIMITf,
                 input_port_threshold->total_shared_ext_buff -
                 (2 *  general_info->ether_mtu_cells_for_ext_buff));
             SOC_IF_ERROR_RETURN (soc_mem_write(unit, 
                THDIEXT_THDI_PORT_SP_CONFIGm, MEM_BLOCK_ALL, 
                mem_idx, &thdiext_thdi_port_sp_config));
         }
         sal_memset(&thdiext_thdi_port_pg_config,0,
                    sizeof(thdiext_thdi_port_pg_config));
         mem_idx= (port * KT2_MAX_PRIORITY_GROUPS) + priority_group;
         if (ext_mem_port_count) {
             /* C339: THDIEXT_THDI_PORT_PG_CONFIG.PG_MIN_LIMIT(PG0) = =$C$155 */
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                 &thdiext_thdi_port_pg_config, PG_MIN_LIMITf,
                 input_port_threshold->min_ext_buff_cells_per_PG);


             /* C340: THDIEXT_THDI_PORT_PG_CONFIG.PG_SHARED_LIMIT =
                      IF($C$14, $C$58, $C$258) */
             if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                 temp_val = _soc_kt2_mmu_params.mmu_ing_pg_dyn_thd_param;
             } else {
                 /* $C$258 = =$C$185 */
                 temp_val = input_port_threshold->total_shared_ext_buff;;
             }
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                 &thdiext_thdi_port_pg_config, 
                 PG_SHARED_LIMITf, temp_val);

             /* C341: THDIEXT_THDI_PORT_PG_CONFIG.PG_RESET_OFFSET = =2*$C$72 */
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                 &thdiext_thdi_port_pg_config, PG_RESET_OFFSETf,
                 (2 * general_info->ether_mtu_cells_for_ext_buff));

             /* C342: THDI_PORT_PG_CONFIG.PG_RESET_FLOOR = 0 */
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                 &thdiext_thdi_port_pg_config, PG_RESET_FLOORf, 0);

             /* C343: THDIEXT_THDI_PORT_PG_CONFIG.PG_SHARED_DYNAMIC= 
                      IF($C$14, 1, 0) */
             if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                 temp_val = 1;
             } else {
                 temp_val = 0;
             }
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                 &thdiext_thdi_port_pg_config, PG_SHARED_DYNAMICf,
                 temp_val);

             /* C344: THDIEXT_THDI_PORT_PG_CONFIG.PG_HDRM_LIMIT
                      For Ge:$C123 For Hg:$C113 For Cpu:$C143 */
             if (IS_CPU_PORT(unit, port)) {
                 temp_val = input_port_threshold->
                            hdrm_ext_buff_cells_for_cpu_port;
             } else if (IS_GE_PORT(unit, port)) {
                 temp_val = input_port_threshold->hdrm_ext_buff_cells_for_1G_PG;
             } else if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit, port)) {
                 temp_val= input_port_threshold->hdrm_ext_buff_cells_for_10G_PG;
             }
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
               &thdiext_thdi_port_pg_config, PG_HDRM_LIMITf,temp_val);

             /* C345: THDIEXT_THDI_PORT_PG_CONFIG.PG_GBL_HDRM_EN = 
                      for lossy=1 else 0
                      For Packed : 0 */
             if (_soc_kt2_mmu_params.lossless_mode_d_c || 
                 _soc_kt2_mmu_params.packing_mode_d_c) {
                 temp_val = 0;
             } else {
                 temp_val = 1;
             }
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm, 
                 &thdiext_thdi_port_pg_config, PG_GBL_HDRM_ENf ,
                 temp_val);
         }
         /* C346: THDIEXT_THDI_PORT_PG_CONFIG.SP_SHARED_MAX_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
             &thdiext_thdi_port_pg_config, SP_SHARED_MAX_ENABLEf ,1);

         /* C347: THDIEXT_THDI_PORT_PG_CONFIG.SP_MIN_PG_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
             &thdiext_thdi_port_pg_config, SP_MIN_PG_ENABLEf ,1);

         SOC_IF_ERROR_RETURN (soc_mem_write(unit, 
                THDIEXT_THDI_PORT_PG_CONFIGm, MEM_BLOCK_ALL, 
                mem_idx, &thdiext_thdi_port_pg_config));

         /* C339: THDIEXT_THDI_PORT_PG_CONFIG.PG_MIN_LIMIT (PG1-7) = 1 
                  (for HG Ports)*/
         if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit,port) /* ||
             ((port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT) &&
              (kt2_port_to_mxqblock_subports[port-1] == 0)) */) {
             for (loop =1 ; loop < KT2_MAX_PRIORITY_GROUPS;loop++) {
                  sal_memcpy(&thdiext_thdi_port_pg_config_temp,
                             &thdiext_thdi_port_pg_config,
                             sizeof(thdiext_thdi_port_pg_config));
                  soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                  &thdiext_thdi_port_pg_config_temp, PG_MIN_LIMITf, 1);
                  SOC_IF_ERROR_RETURN (soc_mem_write(unit, 
                         THDIEXT_THDI_PORT_PG_CONFIGm, MEM_BLOCK_ALL, 
                         mem_idx+loop, &thdiext_thdi_port_pg_config_temp));
             }
         }
    }
    /* 1.3 EMA Pool                     */
    /* Assuming only service_pool = 0 is used */
    /* Assuming only prioty_Group = 0 is used */
    SOC_PBMP_ITER (valid_port_cpu_pbmp, port) {
         if (ext_mem_port_count) {
             sal_memset(&thdiema_thdi_port_sp_config,0,
                        sizeof(thdiema_thdi_port_sp_config));
             mem_idx= (port * KT2_MAX_SERVICE_POOLS) + service_pool;
             /* C350: THDIEMA_THDI_PORT_SP_CONFIG.PORT_SP_MIN_LIMIT  = $C$166 */
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_SP_CONFIGm,
                 &thdiema_thdi_port_sp_config, PORT_SP_MIN_LIMITf,
                 input_port_threshold->min_int_buff_ema_pool_cells_for_a_port);

             /* C351: THDIEMA_THDI_PORT_SP_CONFIG.PORT_SP_MAX_LIMIT = 
                      $C$262 <== =C184  */
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_SP_CONFIGm,
                 &thdiema_thdi_port_sp_config, PORT_SP_MAX_LIMITf,
                 input_port_threshold->total_shared_EMA_buff);

             /* C352: THDIEMA_PORT_MAX_PKT_SIZE.PORT_MAX_PKT_SIZE = =$C$68 */
             SOC_IF_ERROR_RETURN(READ_THDIEMA_PORT_MAX_PKT_SIZEr (
                                 unit, port, &rval));
             soc_reg_field_set(unit, THDIEMA_PORT_MAX_PKT_SIZEr, &rval,
                               PORT_MAX_PKT_SIZEf,
                               general_info->max_packet_size_in_cells);
             SOC_IF_ERROR_RETURN(WRITE_THDIEMA_PORT_MAX_PKT_SIZEr (
                                 unit, port, rval));
             /* C353: THDIEMA_THDI_PORT_SP_CONFIG.PORT_SP_RESUME_LIMIT =
                      =$C$351-2*$C$72 */
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_SP_CONFIGm,
                 &thdiema_thdi_port_sp_config, PORT_SP_RESUME_LIMITf,
                 input_port_threshold->total_shared_EMA_buff -
                 (2 *  general_info->ether_mtu_cells_for_int_buff));
             SOC_IF_ERROR_RETURN(soc_mem_write(unit, 
                        THDIEMA_THDI_PORT_SP_CONFIGm, MEM_BLOCK_ALL, 
                        mem_idx, &thdiema_thdi_port_sp_config));
         }
         sal_memset(&thdiema_thdi_port_pg_config,0,
                    sizeof(thdiema_thdi_port_pg_config));
         mem_idx= (port * KT2_MAX_PRIORITY_GROUPS) + priority_group;
         if (ext_mem_port_count) {
             /* C354: THDIEMA_THDI_PORT_PG_CONFIG.PG_MIN_LIMIT(PG0) = =$C$154 */
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
                 &thdiema_thdi_port_pg_config, PG_MIN_LIMITf,
                 input_port_threshold->min_int_buff_ema_pool_cells_per_PG);


             /* C355: THDIEMA_THDI_PORT_PG_CONFIG.PG_SHARED_LIMIT =
                      IF($C$14, $C$58, $C$262) */
             if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                 temp_val = _soc_kt2_mmu_params.mmu_ing_pg_dyn_thd_param;
             } else {
                 /* $C$262 = =$C$184 */
                 temp_val = input_port_threshold->total_shared_EMA_buff;
             }
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
                 &thdiema_thdi_port_pg_config, 
                 PG_SHARED_LIMITf, temp_val);

             /* C356: THDIEMA_THDI_PORT_PG_CONFIG.PG_RESET_OFFSET = =2*$C$72 */
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
                 &thdiema_thdi_port_pg_config, PG_RESET_OFFSETf,
                 (2 * general_info->ether_mtu_cells_for_int_buff));

             /* C357: THDIEMA_PORT_PG_CONFIG.PG_RESET_FLOOR = 0 */
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
                 &thdiema_thdi_port_pg_config, PG_RESET_FLOORf, 0);

             /* C358: THDIEMA_THDI_PORT_PG_CONFIG.PG_SHARED_DYNAMIC= 
                      IF($C$14, 1, 0) */
             if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                 temp_val = 1;
             } else {
                 temp_val = 0;
             }
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
                 &thdiema_thdi_port_pg_config, PG_SHARED_DYNAMICf,
                 temp_val);

             /* C359: THDIEMA_THDI_PORT_PG_CONFIG.PG_HDRM_LIMIT
                      For Ge:$C122 For Hg:$C112 For Cpu:$C142 */
             if (IS_CPU_PORT(unit, port)) {
                 temp_val = input_port_threshold->
                            hdrm_int_buff_cells_for_cpu_port;
             } else if (IS_GE_PORT(unit, port)) {
                 temp_val = input_port_threshold->hdrm_int_buff_cells_for_1G_PG;
             } else if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit,port)) {
                 temp_val= input_port_threshold->hdrm_int_buff_cells_for_10G_PG;
             }
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
               &thdiema_thdi_port_pg_config, PG_HDRM_LIMITf,temp_val);

             /* C360: THDIEMA_THDI_PORT_PG_CONFIG.PG_GBL_HDRM_EN = 
                      for lossy=1 else 0 */
             if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                 temp_val = 0;
             } else {
                 temp_val = 1;
             }
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm, 
                 &thdiema_thdi_port_pg_config, PG_GBL_HDRM_ENf ,
                 temp_val);
         }
         /* C361: THDIEMA_THDI_PORT_PG_CONFIG.SP_SHARED_MAX_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
             &thdiema_thdi_port_pg_config, SP_SHARED_MAX_ENABLEf ,1);

         /* C362: THDIEMA_THDI_PORT_PG_CONFIG.SP_MIN_PG_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
             &thdiema_thdi_port_pg_config, SP_MIN_PG_ENABLEf ,1);
         SOC_IF_ERROR_RETURN(soc_mem_write(
                        unit, THDIEMA_THDI_PORT_PG_CONFIGm, 
                        MEM_BLOCK_ALL, mem_idx,
                        &thdiema_thdi_port_pg_config));
         /* C354: THDIEMA_THDI_PORT_PG_CONFIG.PG_MIN_LIMIT (PG1-7) = 1 
                  (for HG Ports)*/
         if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit,port) /* ||
             ((port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT) &&
              (kt2_port_to_mxqblock_subports[port-1] == 0)) */) {
             for (loop =1 ; loop < KT2_MAX_PRIORITY_GROUPS;loop++) {
                  sal_memcpy(&thdiema_thdi_port_pg_config_temp,
                             &thdiema_thdi_port_pg_config,
                             sizeof(thdiema_thdi_port_pg_config));
                  soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
                  &thdiema_thdi_port_pg_config_temp, PG_MIN_LIMITf, 1);
                  SOC_IF_ERROR_RETURN(soc_mem_write(
                        unit, THDIEMA_THDI_PORT_PG_CONFIGm, MEM_BLOCK_ALL, 
                        mem_idx+loop, &thdiema_thdi_port_pg_config_temp));
             }
         }
    }
    /* 1.4 RE WQEs                      */
    /* Assuming only service_pool = 0 is used */
    /* Assuming only prioty_Group = 0 is used */
    SOC_PBMP_ITER (valid_port_cpu_pbmp, port) {
         sal_memset(&thdirqe_thdi_port_sp_config , 0,
                    sizeof(thdirqe_thdi_port_sp_config));
  
         mem_idx= (port * KT2_MAX_SERVICE_POOLS) + service_pool;
         /* C365: THDIRQE_THDI_PORT_SP_CONFIG.PORT_SP_MIN_LIMIT  = $C$168 */
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_SP_CONFIGm,
             &thdirqe_thdi_port_sp_config, PORT_SP_MIN_LIMITf,
             input_port_threshold->min_RE_WQEs_pkts_for_a_port);

         /* C366: THDIRQE_THDI_PORT_SP_CONFIG.PORT_SP_MAX_LIMIT = $C$186 */
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_SP_CONFIGm,
             &thdirqe_thdi_port_sp_config, PORT_SP_MAX_LIMITf,
             input_port_threshold->total_shared_RE_WQEs_buff);

         /* C367: THDIRQE_THDI_PORT_SP_CONFIG.PORT_SP_RESUME_LIMIT =
                  =$C$366 -2 */
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_SP_CONFIGm,
             &thdirqe_thdi_port_sp_config, PORT_SP_RESUME_LIMITf,
             input_port_threshold->total_shared_RE_WQEs_buff - 2);
         SOC_IF_ERROR_RETURN(soc_mem_write(
                        unit, THDIRQE_THDI_PORT_SP_CONFIGm, MEM_BLOCK_ALL, 
                        mem_idx, &thdirqe_thdi_port_sp_config));

         sal_memset(&thdirqe_thdi_port_pg_config , 0,
                    sizeof(thdirqe_thdi_port_pg_config));
         mem_idx= (port * KT2_MAX_PRIORITY_GROUPS) + priority_group;
         /* C368: THDIRQE_THDI_PORT_PG_CONFIG.PG_MIN_LIMIT(PG0) = =$C$156 */
         temp_val = input_port_threshold->min_RE_WQEs_pkt_per_PG;
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
             &thdirqe_thdi_port_pg_config, PG_MIN_LIMITf,temp_val);

         /* C369: THDIRQE_THDI_PORT_PG_CONFIG.PG_SHARED_LIMIT =
                  IF($C$14, $C$58, $C$186) */
         if (_soc_kt2_mmu_params.lossless_mode_d_c) {
             temp_val = _soc_kt2_mmu_params.mmu_ing_pg_dyn_thd_param;
         } else {
             temp_val = input_port_threshold->total_shared_RE_WQEs_buff;
         }
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
             &thdirqe_thdi_port_pg_config, 
             PG_SHARED_LIMITf, temp_val);

         /* C370: THDIRQE_THDI_PORT_PG_CONFIG.PG_RESET_OFFSET = 2 */
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
             &thdirqe_thdi_port_pg_config, PG_RESET_OFFSETf,2);

         /* C371: THDIRQE_THDI_PORT_PG_CONFIG.PG_RESET_FLOOR = 0 */
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
             &thdirqe_thdi_port_pg_config, PG_RESET_FLOORf, 0);

         /* C372: THDIRQE_THDI_PORT_PG_CONFIG.PG_SHARED_DYNAMIC= 
                  IF($C$14, 1, 0) */
         if (_soc_kt2_mmu_params.lossless_mode_d_c) {
             temp_val = 1;
         } else {
             temp_val = 0;
         }
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
             &thdirqe_thdi_port_pg_config, PG_SHARED_DYNAMICf,
             temp_val);

         /* C373: THDIRQE_THDI_PORT_PG_CONFIG.PG_HDRM_LIMIT
                  For Ge:$C124 For Hg:$C114 For Cpu:$C144 */
         if (IS_CPU_PORT(unit, port)) {
             temp_val = input_port_threshold->hdrm_RE_WQEs_pkts_for_cpu_port;
         } else if (IS_GE_PORT(unit, port)) {
             temp_val = input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_PG;
         } else if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit, port)) {
             temp_val= input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_PG;
         }
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
           &thdirqe_thdi_port_pg_config, PG_HDRM_LIMITf,temp_val);

         /* C374: THDIRQE_THDI_PORT_PG_CONFIG.PG_GBL_HDRM_EN = 
                  for lossy=1 else 0
                  Packed : 0 */
         if (_soc_kt2_mmu_params.lossless_mode_d_c ||
             _soc_kt2_mmu_params.packing_mode_d_c) {
             temp_val = 0;
         } else {
             temp_val = 1;
         }
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm, 
             &thdirqe_thdi_port_pg_config, PG_GBL_HDRM_ENf ,
             temp_val);

         /* C375: THDIRQE_THDI_PORT_PG_CONFIG.SP_SHARED_MAX_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
             &thdirqe_thdi_port_pg_config, SP_SHARED_MAX_ENABLEf ,1);

         /* C376: THDIRQE_THDI_PORT_PG_CONFIG.SP_MIN_PG_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
                 &thdirqe_thdi_port_pg_config, SP_MIN_PG_ENABLEf ,1);
   
         SOC_IF_ERROR_RETURN(soc_mem_write(unit, THDIRQE_THDI_PORT_PG_CONFIGm, 
                        MEM_BLOCK_ALL, mem_idx, &thdirqe_thdi_port_pg_config));

         /* C368: THDIRQE_THDI_PORT_PG_CONFIG.PG_MIN_LIMIT (PG1-7) = 1 
                  (for HG Ports)*/
         if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit,port) /* ||
             ((port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT) &&
	      (kt2_port_to_mxqblock_subports[port-1] == 0)) */) {
             for (loop =1 ; loop < KT2_MAX_PRIORITY_GROUPS;loop++) {
                  sal_memcpy(&thdirqe_thdi_port_pg_config_temp,
                             &thdirqe_thdi_port_pg_config,
                             sizeof(thdirqe_thdi_port_pg_config));
                  soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
                  &thdirqe_thdi_port_pg_config_temp, PG_MIN_LIMITf, 1);
                  SOC_IF_ERROR_RETURN(soc_mem_write(
                      unit, THDIRQE_THDI_PORT_PG_CONFIGm, MEM_BLOCK_ALL, 
                      mem_idx+loop, &thdirqe_thdi_port_pg_config_temp));
             }
         }
    }
    /* 1.5 EQEs                         */
    /* Assuming only service_pool = 0 is used */
    /* Assuming only prioty_Group = 0 is used */
    SOC_PBMP_ITER (valid_port_cpu_pbmp, port) {
         sal_memset(&thdiqen_thdi_port_sp_config,0,
                    sizeof(thdiqen_thdi_port_sp_config));
         mem_idx= (port * KT2_MAX_SERVICE_POOLS) + service_pool;
         /* C379: THDIQEN_THDI_PORT_SP_CONFIG.PORT_SP_MIN_LIMIT  = $C$169 */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_SP_CONFIGm,
             &thdiqen_thdi_port_sp_config, PORT_SP_MIN_LIMITf,
             input_port_threshold->min_EQEs_pkts_for_a_port);

         /* C380: THDIQEN_THDI_PORT_SP_CONFIG.PORT_SP_MAX_LIMIT = $C$187 */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_SP_CONFIGm,
             &thdiqen_thdi_port_sp_config, PORT_SP_MAX_LIMITf,
             input_port_threshold->total_shared_EQEs_buff);

         /* C381: THDIQEN_THDI_PORT_SP_CONFIG.PORT_SP_RESUME_LIMIT =
                  =C380-2*C49 */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_SP_CONFIGm,
             &thdiqen_thdi_port_sp_config, PORT_SP_RESUME_LIMITf,
             input_port_threshold->total_shared_EQEs_buff - 
             (2 * _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt));
         SOC_IF_ERROR_RETURN(soc_mem_write(unit, 
                        THDIQEN_THDI_PORT_SP_CONFIGm, MEM_BLOCK_ALL, 
                        mem_idx, &thdiqen_thdi_port_sp_config));
         sal_memset(&thdiqen_thdi_port_pg_config,0,
                    sizeof(&thdiqen_thdi_port_pg_config));
         mem_idx= (port * KT2_MAX_PRIORITY_GROUPS) + priority_group;
         /* C382: THDIQEN_THDI_PORT_PG_CONFIG.PG_MIN_LIMIT(PG0) = 
                   =$C$157 */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
             &thdiqen_thdi_port_pg_config, PG_MIN_LIMITf,
             input_port_threshold->min_EQEs_pkt_per_PG);


         /* C383: THDIQEN_THDI_PORT_PG_CONFIG.PG_SHARED_LIMIT =
                  =IF($C$14, $C$58, $C$187) */
         if (_soc_kt2_mmu_params.lossless_mode_d_c) {
             temp_val = _soc_kt2_mmu_params.mmu_ing_pg_dyn_thd_param;
         } else {
             temp_val = input_port_threshold->total_shared_EQEs_buff;
         }
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
             &thdiqen_thdi_port_pg_config, 
             PG_SHARED_LIMITf, temp_val);

         /* C384: THDIQEN_THDI_PORT_PG_CONFIG.PG_RESET_OFFSET = =2*C49 */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
             &thdiqen_thdi_port_pg_config, PG_RESET_OFFSETf,
             2 * _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt);

         /* C385: THDIQEN_THDI_PORT_PG_CONFIG.PG_RESET_FLOOR = 0 */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
             &thdiqen_thdi_port_pg_config, PG_RESET_FLOORf, 0);

         /* C386: THDIQEN_THDI_PORT_PG_CONFIG.PG_SHARED_DYNAMIC= 
                  IF($C$14, 1, 0) */
         if (_soc_kt2_mmu_params.lossless_mode_d_c) {
             temp_val = 1;
         } else {
             temp_val = 0;
         }
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
             &thdiqen_thdi_port_pg_config, PG_SHARED_DYNAMICf,
             temp_val);

         /* C387: THDIQEN_THDI_PORT_PG_CONFIG.PG_HDRM_LIMIT
                  For Ge:$C125 For Hg:$C115 For Cpu:$C145 */
         if (IS_CPU_PORT(unit, port)) {
             temp_val = input_port_threshold->hdrm_EQEs_pkts_for_cpu_port;
         } else if (IS_GE_PORT(unit, port)) {
             temp_val = input_port_threshold->hdrm_EQEs_pkts_for_1G_PG;
         } else if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit, port)) {
             temp_val= input_port_threshold->hdrm_EQEs_pkts_for_10G_PG;
         }
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
           &thdiqen_thdi_port_pg_config, PG_HDRM_LIMITf,temp_val);

         /* C388: THDIQEN_THDI_PORT_PG_CONFIG.PG_GBL_HDRM_EN = 
                  for lossy=1 else 0 
                  Packed : 0 */
         if (_soc_kt2_mmu_params.lossless_mode_d_c  ||
             _soc_kt2_mmu_params.packing_mode_d_c) {
             temp_val = 0;
         } else {
             temp_val = 1;
         }
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm, 
             &thdiqen_thdi_port_pg_config, PG_GBL_HDRM_ENf ,
             temp_val);

         /* C389: THDIQEN_THDI_PORT_PG_CONFIG.SP_SHARED_MAX_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
             &thdiqen_thdi_port_pg_config, SP_SHARED_MAX_ENABLEf ,1);

         /* C390: THDIQEN_THDI_PORT_PG_CONFIG.SP_MIN_PG_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
                 &thdiqen_thdi_port_pg_config, SP_MIN_PG_ENABLEf ,1);
         SOC_IF_ERROR_RETURN(soc_mem_write( unit, THDIQEN_THDI_PORT_PG_CONFIGm, 
                        MEM_BLOCK_ALL, mem_idx, &thdiqen_thdi_port_pg_config));

         /* C382: THDIQEN_THDI_PORT_PG_CONFIG.PG_MIN_LIMIT (PG1-7) = 1 
                  (for HG Ports)*/
         if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit,port) /* ||
             ((port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT) &&
	      (kt2_port_to_mxqblock_subports[port-1] == 0)) */) {
             for (loop =1 ; loop < KT2_MAX_PRIORITY_GROUPS;loop++) {
                  sal_memcpy(&thdiqen_thdi_port_pg_config_temp,
                             &thdiqen_thdi_port_pg_config,
                             sizeof(thdiqen_thdi_port_pg_config));
                  soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
                  &thdiqen_thdi_port_pg_config_temp,
                  PG_MIN_LIMITf, 1);
                  SOC_IF_ERROR_RETURN(soc_mem_write(unit, 
                        THDIQEN_THDI_PORT_PG_CONFIGm, MEM_BLOCK_ALL, 
                        mem_idx+loop, &thdiqen_thdi_port_pg_config_temp));
             }
         }
    }
     
    /* ######################## */
    /* 2. Output Port Thresholds */
    /* ######################## */
    /* 2.1 Internal Buffer              */
    op_node = 0;
    SOC_PBMP_ITER (valid_port_cpu_pbmp, port) {
        if (IS_CPU_PORT(unit, port) ||
            !SOC_PBMP_MEMBER(PBMP_EXT_MEM (unit), port)) {
            if (!IS_CPU_PORT(unit, port) &&
                (port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT)) {
                op_node = ( si->port_cosq_base[port] / 8) - 1 ;
            }

            for (op_node_offset = 0; 
                 op_node_offset < (IS_CPU_PORT(unit, port) ?
                                   (si->port_num_uc_cosq[port] / 8) : 1); 
                 op_node_offset++) {
                 SOC_IF_ERROR_RETURN(READ_MMU_THDO_OPNCONFIG_CELLm(unit,
                                     MEM_BLOCK_ANY,op_node + op_node_offset,
                                     &mmu_thdo_opnconfig_cell_entry));
                 /* C394:THDO_OPNCONFIG_CELL.OPN_SHARED_LIMIT_CELL = =$C$219 */
                 soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                     &mmu_thdo_opnconfig_cell_entry, 
                                     OPN_SHARED_LIMIT_CELLf,
                                     output_port_threshold->
                                     min_grntd_tot_shr_queue_cells_int_buff);

                 /* C395:THDO_OPNCONFIG_CELL.OP_SHARED_RESET_VALUE_CELL
                         = C394-2*$C$72 */
                 temp_val = output_port_threshold->
                            min_grntd_tot_shr_queue_cells_int_buff -
                            (2 * general_info->ether_mtu_cells_for_int_buff);
                 soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                     &mmu_thdo_opnconfig_cell_entry, 
                                     OPN_SHARED_RESET_VALUE_CELLf, temp_val);

                 /* C396:THDO_OPNCONFIG_CELL.PORT_LIMIT_ENABLE_CELL
                    = 0 */
                 soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                     &mmu_thdo_opnconfig_cell_entry, 
                                     PORT_LIMIT_ENABLE_CELLf, 0);
                 soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                     &mmu_thdo_opnconfig_cell_entry, 
                                     PIDf, port);
                 SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_OPNCONFIG_CELLm(unit,
                                     MEM_BLOCK_ANY,op_node + op_node_offset,
                                     &mmu_thdo_opnconfig_cell_entry));
            }

            for (queue = si->port_uc_cosq_base[port];
                 queue < si->port_uc_cosq_base[port] + 
                         si->port_num_uc_cosq[port];
                 queue++) {
                 SOC_IF_ERROR_RETURN(READ_MMU_THDO_QCONFIG_CELLm(unit,
                                     MEM_BLOCK_ANY,queue,
                                     &mmu_thdo_qconfig_cell_entry));
                 /* C397:THDO_QCONFIG_CELL.Q_MIN_CELL
                    = =$C$201 */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_MIN_CELLf,
                     output_port_threshold->min_grntd_res_queue_cells_int_buff);

                 /* C398:THDO_QCONFIG_CELL.Q_SHARED_LIMIT_CELL
                         =IF($C$14,$C$219,$C$60) */
                 if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                     temp_val = output_port_threshold->
                                       min_grntd_tot_shr_queue_cells_int_buff;
                 } else {
                     temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
                 }
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf, 
                     temp_val);

                 /* C400:THDO_QCONFIG_CELL.Q_LIMIT_DYNAMIC_CELL
                         =IF($C$14, 0, 1) */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_LIMIT_DYNAMIC_CELLf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                 /* C401:THDO_QCONFIG_CELL.Q_LIMIT_ENABLE_CELL
                         =IF($C$14, 0, 1) */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_LIMIT_ENABLE_CELLf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                 /* C402:THDO_QCONFIG_CELL.Q_COLOR_ENABLE_CELL = 0 */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_COLOR_ENABLE_CELLf,0); 

                 /* C403: THDO_QCONFIG_CELL.Q_COLOR_LIMIT_DYNAMIC_CELL
                         =IF($C$14, 0, 1) */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_COLOR_LIMIT_DYNAMIC_CELLf,
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                 /* C404: THDO_QCONFIG_CELL.LIMIT_YELLOW_CELL= 
                          if lossless= C398/8 else C398 */
                 temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_CELLm, 
                            &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf);
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, LIMIT_YELLOW_CELLf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 
                     ceil_func(temp_val, 8) : temp_val);
                 SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QCONFIG_CELLm(unit,
                                     MEM_BLOCK_ANY,queue,
                                     &mmu_thdo_qconfig_cell_entry));

                 SOC_IF_ERROR_RETURN(READ_MMU_THDO_QOFFSET_CELLm(unit,
                                     MEM_BLOCK_ANY,queue,
                                     &mmu_thdo_qoffset_cell_entry));
                 /* C399:THDO_QOFFSET_CELL.RESET_OFFSET_CELL =2 */
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_CELLf, 2);

                 /* C405: THDO_QOFFSET_CELL.LIMIT_RED_CELL  = 
                          if lossless= C398/8 else C398 */
                 temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_CELLm, 
                            &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf);
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, LIMIT_RED_CELLf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 
                     ceil_func(temp_val, 8) : temp_val);

                 /* C406: THDO_QOFFSET_CELL.RESET_OFFSET_YELLOW_CELL =2 */
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_YELLOW_CELLf,2); 
                 /* C407: THDO_QOFFSET_CELL.RESET_OFFSET_RED_CELL =2 */
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_RED_CELLf,2); 

                 SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QOFFSET_CELLm(unit,
                                     MEM_BLOCK_ANY,queue,
                                     &mmu_thdo_qoffset_cell_entry));
            }
        }
    }
    /* 2.2 External Buffer              */
    SOC_PBMP_ITER (valid_port_cpu_pbmp, port) {
        if (!IS_CPU_PORT(unit, port) &&
            (port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT) &&
            SOC_PBMP_MEMBER(PBMP_EXT_MEM (unit), port)) {

            op_node = ( si->port_cosq_base[port] / 8) - 1 ;

            SOC_IF_ERROR_RETURN(READ_MMU_THDO_OPNCONFIG_CELLm(unit,
                MEM_BLOCK_ANY,op_node , &mmu_thdo_opnconfig_cell_entry));
            /* C409:THDO_OPNCONFIG_CELL.OPN_SHARED_LIMIT_CELL = =$C$220 */
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                &mmu_thdo_opnconfig_cell_entry, 
                                OPN_SHARED_LIMIT_CELLf,
                                output_port_threshold->
                                min_grntd_tot_shr_queue_cells_ext_buff);

            /* C410:THDO_OPNCONFIG_CELL.OP_SHARED_RESET_VALUE_CELL
                    = =$C$409-2*$C$73 */
            temp_val = output_port_threshold->
                       min_grntd_tot_shr_queue_cells_ext_buff -
                       (2 * general_info->ether_mtu_cells_for_ext_buff);
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                &mmu_thdo_opnconfig_cell_entry, 
                                OPN_SHARED_RESET_VALUE_CELLf, temp_val);

            /* C411:THDO_OPNCONFIG_CELL.PORT_LIMIT_ENABLE_CELL = 0 */
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                &mmu_thdo_opnconfig_cell_entry, 
                                PORT_LIMIT_ENABLE_CELLf, 0);
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                &mmu_thdo_opnconfig_cell_entry, 
                                PIDf, port);
            SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_OPNCONFIG_CELLm(unit,
                                MEM_BLOCK_ANY,op_node,
                                &mmu_thdo_opnconfig_cell_entry));

            for (queue = si->port_uc_cosq_base[port];
                 queue < si->port_uc_cosq_base[port] + 
                         si->port_num_uc_cosq[port];
                 queue++) {
                 SOC_IF_ERROR_RETURN(READ_MMU_THDO_QCONFIG_CELLm(unit,
                                     MEM_BLOCK_ANY,queue,
                                     &mmu_thdo_qconfig_cell_entry));
                 /* C412:THDO_QCONFIG_CELL.Q_MIN_CELL
                    = =$C$202 */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_MIN_CELLf,
                     output_port_threshold->min_grntd_res_queue_cells_ext_buff);

                 /* C413:THDO_QCONFIG_CELL.Q_SHARED_LIMIT_CELL
                         =IF($C$14,$C$220,$C$60) */
                 if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                     temp_val = output_port_threshold->
                                       min_grntd_tot_shr_queue_cells_ext_buff;
                 } else {
                     temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
                 }
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf, 
                     temp_val);

                 /* C415:THDO_QCONFIG_CELL.Q_LIMIT_DYNAMIC_CELL
                         =IF($C$14, 0, 1) */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_LIMIT_DYNAMIC_CELLf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                 /* C416:THDO_QCONFIG_CELL.Q_LIMIT_ENABLE_CELL
                         =IF($C$14, 0, 1) */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_LIMIT_ENABLE_CELLf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                 /* C417:THDO_QCONFIG_CELL.Q_COLOR_ENABLE_CELL = 0 */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_COLOR_ENABLE_CELLf,0); 

                 /* C418: THDO_QCONFIG_CELL.Q_COLOR_LIMIT_DYNAMIC_CELL
                         =IF($C$14, 0, 1) */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_COLOR_LIMIT_DYNAMIC_CELLf,
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                 /* C419: THDO_QCONFIG_CELL.LIMIT_YELLOW_CELL= 
                          if lossless= CEILING(C413/8) else C413 */
                 temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_CELLm, 
                            &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf);
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, LIMIT_YELLOW_CELLf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 
                     ceil_func(temp_val, 8) : temp_val);
                 SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QCONFIG_CELLm(unit,
                                     MEM_BLOCK_ANY,queue,
                                     &mmu_thdo_qconfig_cell_entry));

                 SOC_IF_ERROR_RETURN(READ_MMU_THDO_QOFFSET_CELLm(unit,
                                     MEM_BLOCK_ANY,queue,
                                     &mmu_thdo_qoffset_cell_entry));
                 /* C414:THDO_QOFFSET_CELL.RESET_OFFSET_CELL =2 */
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_CELLf, 2);

                 /* C420: THDO_QOFFSET_CELL.LIMIT_RED_CELL  = 
                          if lossless= CEILING(C413/8) else C413 */
                 temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_CELLm, 
                            &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf);
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, LIMIT_RED_CELLf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 
                     ceil_func(temp_val, 8) : temp_val);

                 /* C421: THDO_QOFFSET_CELL.RESET_OFFSET_YELLOW_CELL =2 */
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_YELLOW_CELLf,2); 
                 /* C422: THDO_QOFFSET_CELL.RESET_OFFSET_RED_CELL =2 */
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_RED_CELLf,2); 

                 SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QOFFSET_CELLm(unit,
                                     MEM_BLOCK_ANY,queue,
                                     &mmu_thdo_qoffset_cell_entry));
            }
        }
    }
    /* 2.3 EMA Pool                     */
    if (ext_mem_port_count) {
        for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDOEMAr); cos++) {
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG1_THDOEMAr(
                                unit, cos, &rval));
            /* C424:OP_QUEUE_CONFIG1_THDOEMA.Q_MIN = C204 */
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDOEMAr, &rval,
                    Q_MINf, 
                    output_port_threshold->min_grntd_res_EMA_queue_cells);
         
            /* C429:OP_QUEUE_CONFIG1_THDOEMA.Q_COLOR_ENABLE  = 0 */
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDOEMAr, &rval,
                              Q_COLOR_ENABLEf, 0);

            /* C430:OP_QUEUE_CONFIG1_THDOEMA.Q_COLOR_DYNAMIC lossless=0 else 1*/
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDOEMAr, &rval,
                              Q_COLOR_DYNAMICf, 
                              _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG1_THDOEMAr(
                                unit, cos, rval));
        }

        for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG_THDOEMAr); cos++) {
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDOEMAr(
                                unit, cos, &rval));
            /* C425:OP_QUEUE_CONFIG_THDOEMA.Q_SHARED_LIMIT
                    =IF($C$14,$C$222,$C$60)..Can be put outside loop */
            if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                temp_val = output_port_threshold->
                           min_grntd_tot_shr_EMA_queue_cells;
            } else {
                temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
            }
            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDOEMAr, &rval,
                              Q_SHARED_LIMITf, temp_val);

            /*C427: OP_QUEUE_CONFIG_THDOEMA.Q_LIMIT_DYNAMIC:=lossless=0 else 1*/

            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDOEMAr, &rval,
                              Q_LIMIT_DYNAMICf, 
                              _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
            
            /*C428:OP_QUEUE_CONFIG_THDOEMA.Q_LIMIT_ENABLE:=lossless=0 else 1*/
            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDOEMAr, &rval,
                              Q_LIMIT_ENABLEf, 
                              _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_THDOEMAr(
                                unit, cos, rval));

        }
        for(cos=0; 
            cos<SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_THDOEMAr); cos++) {
            SOC_IF_ERROR_RETURN(
                         READ_OP_QUEUE_RESET_OFFSET_THDOEMAr(unit, cos,&rval));
            /*C422: OP_QUEUE_RESET_OFFSET_THDOEMA.Q_RESET_OFFSET == 2 */
            soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_THDOEMAr, &rval,
                              Q_RESET_OFFSETf, 2);
            SOC_IF_ERROR_RETURN(
                         WRITE_OP_QUEUE_RESET_OFFSET_THDOEMAr(unit, cos,rval));
        }
        for(cos=0; 
            cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_YELLOW_THDOEMAr); 
            cos++) {
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_YELLOW_THDOEMAr(
                                unit, cos,&rval));
            /* C431: OP_QUEUE_LIMIT_YELLOW_THDOEMA.Q_LIMIT_YELLOW
                     for lossless =CEILING(C425/8, 1)    else C425 */
            /* HG Port has temp_val/8++ !! */
            if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                temp_val = output_port_threshold->
                           min_grntd_tot_shr_EMA_queue_cells;
            } else {
                temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
            }	
            soc_reg_field_set(unit, OP_QUEUE_LIMIT_YELLOW_THDOEMAr, &rval,
                Q_LIMIT_YELLOWf, _soc_kt2_mmu_params.lossless_mode_d_c?
                                 ceil_func(temp_val,8): temp_val);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_YELLOW_THDOEMAr(
                                unit, cos,rval));
        }
        for(cos=0; 
            cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_RED_THDOEMAr); 
            cos++) {
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_RED_THDOEMAr(
                                unit, cos,&rval));
            /* C432: OP_QUEUE_LIMIT_RED_THDOEMA.Q_LIMIT_RED
                     for lossless =CEILING(C425/8, 1)    else C425 */
            /* HG Port has temp_val/8++ !! */
            if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                temp_val = output_port_threshold->
                           min_grntd_tot_shr_EMA_queue_cells;
            } else {
                temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
            }	
            soc_reg_field_set(unit, OP_QUEUE_LIMIT_RED_THDOEMAr, &rval,
                Q_LIMIT_REDf, _soc_kt2_mmu_params.lossless_mode_d_c?
                                 ceil_func(temp_val,8): temp_val);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_RED_THDOEMAr(
                                unit, cos,rval));
        }
        for(cos=0; 
            cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_YELLOW_THDOEMAr); 
            cos++) {
            SOC_IF_ERROR_RETURN(
                READ_OP_QUEUE_RESET_OFFSET_YELLOW_THDOEMAr(unit, cos,&rval));
            /*C433:OP_QUEUE_RESET_OFFSET_YELLOW_THDOEMA.RESUME_OFFSET_YELLOW=2*/
            soc_reg_field_set(unit,
                OP_QUEUE_RESET_OFFSET_YELLOW_THDOEMAr, &rval,
                RESUME_OFFSET_YELLOWf, 2);
            SOC_IF_ERROR_RETURN(
                WRITE_OP_QUEUE_RESET_OFFSET_YELLOW_THDOEMAr(unit, cos,rval));
        }
        for(cos=0; 
            cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_RED_THDOEMAr); 
            cos++) {
            SOC_IF_ERROR_RETURN(
                READ_OP_QUEUE_RESET_OFFSET_RED_THDOEMAr(unit, cos,&rval));
            /*C434:OP_QUEUE_RESET_OFFSET_RED_THDOEMA.RESUME_OFFSET_RED=2*/
            soc_reg_field_set(unit,
                OP_QUEUE_RESET_OFFSET_RED_THDOEMAr, &rval,
                RESUME_OFFSET_REDf, 2);
            SOC_IF_ERROR_RETURN(
                WRITE_OP_QUEUE_RESET_OFFSET_RED_THDOEMAr(unit, cos,rval));
        }
    }
    /* 2.4 RE WQEs                      */
    /* 2.4.1 RQEQ */
    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDORQEQr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG1_THDORQEQr(
                            unit, cos, &rval));
        /* C436:OP_QUEUE_CONFIG1_THDORQEQ.Q_MIN = C205 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEQr, &rval,
                Q_MINf, 
                output_port_threshold->min_grntd_res_RE_WQs_cells);
         
        /* C441:OP_QUEUE_CONFIG1_THDORQEQ.Q_COLOR_ENABLE  = 0 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEQr, &rval,
                          Q_COLOR_ENABLEf, 0);

        /* C442:OP_QUEUE_CONFIG1_THDORQEQ.Q_COLOR_DYNAMIC lossless=0 else 1*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEQr, &rval,
                          Q_COLOR_DYNAMICf, 
                          _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG1_THDORQEQr(
                            unit, cos, rval));
    }

    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG_THDORQEQr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORQEQr(
                            unit, cos, &rval));
        /* C437:OP_QUEUE_CONFIG_THDORQEQ.Q_SHARED_LIMIT
                =IF($C$14,$C$223-1,$C$60)..Can be put outside loop */
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            temp_val = output_port_threshold->
                       min_grntd_tot_shr_RE_WQs_cells - 1;
        } else {
            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
        }	

        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEQr, &rval,
                          Q_SHARED_LIMITf, temp_val);

        /*C439: OP_QUEUE_CONFIG_THDORQEQ.Q_LIMIT_DYNAMIC:=lossless=0 else 1*/

        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEQr, &rval,
                          Q_LIMIT_DYNAMICf, 
                          _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
            
        /*C440:OP_QUEUE_CONFIG_THDORQEQ.Q_LIMIT_ENABLE:=lossless=0 else 1*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEQr, &rval,
                          Q_LIMIT_ENABLEf, 
                          _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_THDORQEQr(
                            unit, cos, rval));

    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_THDORQEQr); cos++) {
        SOC_IF_ERROR_RETURN(
                     READ_OP_QUEUE_RESET_OFFSET_THDORQEQr(unit, cos,&rval));
        /*C438: OP_QUEUE_RESET_OFFSET_THDORQEQ.Q_RESET_OFFSET == 1 */
        soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_THDORQEQr, &rval,
                          Q_RESET_OFFSETf, 1);
        SOC_IF_ERROR_RETURN(
                     WRITE_OP_QUEUE_RESET_OFFSET_THDORQEQr(unit, cos,rval));
    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEQr); 
        cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_YELLOW_THDORQEQr(
                            unit, cos,&rval));
        /* C443: OP_QUEUE_LIMIT_YELLOW_THDORQEQ.Q_LIMIT_YELLOW
                 for lossless =CEILING(C437/8, 1)-1    else C437 */
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            temp_val = ceil_func(output_port_threshold->
                                 min_grntd_tot_shr_RE_WQs_cells,8) - 1;
        } else {
            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
        }
        soc_reg_field_set(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEQr, &rval,
            Q_LIMIT_YELLOWf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_YELLOW_THDORQEQr(
                                unit, cos,rval));
    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_RED_THDORQEQr); 
        cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_RED_THDORQEQr(
                            unit, cos,&rval));
        /* C444: OP_QUEUE_LIMIT_RED_THDORQEQ.Q_LIMIT_RED
                 for lossless =CEILING(C437/8, 1)-1    else C437 */
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            temp_val = ceil_func(output_port_threshold->
                                 min_grntd_tot_shr_RE_WQs_cells,8) - 1;
        } else {
            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
        }	
        soc_reg_field_set(unit, OP_QUEUE_LIMIT_RED_THDORQEQr, &rval,
            Q_LIMIT_REDf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_RED_THDORQEQr(
                            unit, cos,rval));
    }
    for(cos=0; 
        cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEQr); 
        cos++) {
        SOC_IF_ERROR_RETURN(
            READ_OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEQr(unit, cos,&rval));
        /*C445:OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEQ.RESUME_OFFSET_YELLOW=1*/
        soc_reg_field_set(unit,
            OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEQr, &rval,
            RESUME_OFFSET_YELLOWf, 1);
        SOC_IF_ERROR_RETURN(
            WRITE_OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEQr(unit, cos,rval));
    }
    for(cos=0; 
        cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_RED_THDORQEQr); 
        cos++) {
        SOC_IF_ERROR_RETURN(
            READ_OP_QUEUE_RESET_OFFSET_RED_THDORQEQr(unit, cos,&rval));
        /*C446:OP_QUEUE_RESET_OFFSET_RED_THDORQEQ.RESUME_OFFSET_RED=1*/
        soc_reg_field_set(unit,
            OP_QUEUE_RESET_OFFSET_RED_THDORQEQr, &rval,
            RESUME_OFFSET_REDf, 1);
        SOC_IF_ERROR_RETURN(
            WRITE_OP_QUEUE_RESET_OFFSET_RED_THDORQEQr(unit, cos,rval));
    }
    /* 2.4.2 RQEI */
    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDORQEIr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG1_THDORQEIr(
                            unit, cos, &rval));
        /* C447:OP_QUEUE_CONFIG1_THDORQEI.Q_MIN = C206 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEIr, &rval, Q_MINf, 
          output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_int_buff);
         
        /* C452:OP_QUEUE_CONFIG1_THDORQEI.Q_COLOR_ENABLE  = 0 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEIr, &rval,
                          Q_COLOR_ENABLEf, 0);

        /* C453:OP_QUEUE_CONFIG1_THDORQEI.Q_COLOR_DYNAMIC lossless=0 else 1*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEIr, &rval,
                          Q_COLOR_DYNAMICf, 
                          _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG1_THDORQEIr(
                            unit, cos, rval));
    }

    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG_THDORQEIr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORQEIr(
                            unit, cos, &rval));
        /* C448:OP_QUEUE_CONFIG_THDORQEI.Q_SHARED_LIMIT
                =IF($C$14,$C$224,$C$60)..Can be put outside loop */
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            temp_val = output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_int_buff;
        } else {
            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
        }	
        /*
        SOC_FIND_FIELD(Q_SHARED_LIMITf,
                   SOC_REG_INFO(unit, OP_QUEUE_CONFIG_THDORQEIr).fields,
                   SOC_REG_INFO(unit, OP_QUEUE_CONFIG_THDORQEIr).nFields,
                   fieldp);
        if (temp_val >= (1 << fieldp->len)) {
            temp_val = (1 << fieldp->len) - 1;
        }
         */

        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEIr, &rval,
                          Q_SHARED_LIMITf, temp_val);

        /*C450: OP_QUEUE_CONFIG_THDORQEI.Q_LIMIT_DYNAMIC:=lossless=0 else 1*/

        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEIr, &rval,
                          Q_LIMIT_DYNAMICf, 
                          _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
            
        /*C451:OP_QUEUE_CONFIG_THDORQEI.Q_LIMIT_ENABLE:=lossless=0 else 1*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEIr, &rval,
                          Q_LIMIT_ENABLEf, 
                          _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_THDORQEIr(
                            unit, cos, rval));

    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_THDORQEIr); cos++) {
        SOC_IF_ERROR_RETURN(
                     READ_OP_QUEUE_RESET_OFFSET_THDORQEIr(unit, cos,&rval));
        /*C449: OP_QUEUE_RESET_OFFSET_THDORQEI.Q_RESET_OFFSET == 2 */
        soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_THDORQEIr, &rval,
                          Q_RESET_OFFSETf, 2);
        SOC_IF_ERROR_RETURN(
                     WRITE_OP_QUEUE_RESET_OFFSET_THDORQEIr(unit, cos,rval));
    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEIr); 
        cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_YELLOW_THDORQEIr(
                            unit, cos,&rval));
        /* C454: OP_QUEUE_LIMIT_YELLOW_THDORQEI.Q_LIMIT_YELLOW
                 for lossless =CEILING(C448/8, 1)    else C448 */
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            temp_val = ceil_func(output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_int_buff,8);
        } else {
            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
        }	
        /* 
        SOC_FIND_FIELD(Q_LIMIT_YELLOWf,
                   SOC_REG_INFO(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEIr).fields,
                   SOC_REG_INFO(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEIr).nFields,
                   fieldp);
        if (temp_val >= (1 << fieldp->len)) {
            temp_val = (1 << fieldp->len) - 1;
        }
        */
        soc_reg_field_set(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEIr, &rval,
            Q_LIMIT_YELLOWf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_YELLOW_THDORQEIr(
                                unit, cos,rval));
    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_RED_THDORQEIr); 
        cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_RED_THDORQEIr(
                            unit, cos,&rval));
        /* C455: OP_QUEUE_LIMIT_RED_THDORQEI.Q_LIMIT_RED
                 for lossless =CEILING(C448/8, 1)    else C448 */
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            temp_val = ceil_func(output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_int_buff,8);
        } else {
            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
        }	
        /* 
        SOC_FIND_FIELD(Q_LIMIT_REDf,
                   SOC_REG_INFO(unit, OP_QUEUE_LIMIT_RED_THDORQEIr).fields,
                   SOC_REG_INFO(unit, OP_QUEUE_LIMIT_RED_THDORQEIr).nFields,
                   fieldp);
        if (temp_val >= (1 << fieldp->len)) {
            temp_val = (1 << fieldp->len) - 1;
        }
         */
        soc_reg_field_set(unit, OP_QUEUE_LIMIT_RED_THDORQEIr, &rval,
            Q_LIMIT_REDf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_RED_THDORQEIr(
                            unit, cos,rval));
    }
    for(cos=0; 
        cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEIr); 
        cos++) {
        SOC_IF_ERROR_RETURN(
            READ_OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEIr(unit, cos,&rval));
        /*C456:OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEI.RESUME_OFFSET_YELLOW=2*/
        soc_reg_field_set(unit,
            OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEIr, &rval,
            RESUME_OFFSET_YELLOWf, 2);
        SOC_IF_ERROR_RETURN(
            WRITE_OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEIr(unit, cos,rval));
    }
    for(cos=0; 
        cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_RED_THDORQEIr); 
        cos++) {
        SOC_IF_ERROR_RETURN(
            READ_OP_QUEUE_RESET_OFFSET_RED_THDORQEIr(unit, cos,&rval));
        /*C457:OP_QUEUE_RESET_OFFSET_RED_THDORQEI.RESUME_OFFSET_RED=2*/
        soc_reg_field_set(unit,
            OP_QUEUE_RESET_OFFSET_RED_THDORQEIr, &rval,
            RESUME_OFFSET_REDf, 2);
        SOC_IF_ERROR_RETURN(
            WRITE_OP_QUEUE_RESET_OFFSET_RED_THDORQEIr(unit, cos,rval));
    }
    /* 2.4.3 RQEE */
 if (ext_mem_port_count) {
    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDORQEEr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG1_THDORQEEr(
                            unit, cos, &rval));
        /* C458:OP_QUEUE_CONFIG1_THDORQEE.Q_MIN = C207 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEEr, &rval, Q_MINf, 
          output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_ext_buff);
         
        /* C463:OP_QUEUE_CONFIG1_THDORQEE.Q_COLOR_ENABLE  = 0 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEEr, &rval,
                          Q_COLOR_ENABLEf, 0);

        /* C464:OP_QUEUE_CONFIG1_THDORQEE.Q_COLOR_DYNAMIC lossless=0 else 1*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEEr, &rval,
                          Q_COLOR_DYNAMICf, 
                          _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG1_THDORQEEr(
                            unit, cos, rval));
    }

    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG_THDORQEEr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORQEEr(
                            unit, cos, &rval));
        /* C459:OP_QUEUE_CONFIG_THDORQEE.Q_SHARED_LIMIT
                =IF($C$14,$C$225,$C$60)..Can be put outside loop */
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            temp_val = output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_ext_buff;
        } else {
            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
        }	
        /* 
        SOC_FIND_FIELD(Q_SHARED_LIMITf,
                   SOC_REG_INFO(unit, OP_QUEUE_CONFIG_THDORQEEr).fields,
                   SOC_REG_INFO(unit, OP_QUEUE_CONFIG_THDORQEEr).nFields,
                   fieldp);
        if (temp_val >= (1 << fieldp->len)) {
            temp_val = (1 << fieldp->len) - 1;
        }
         */

        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEEr, &rval,
                          Q_SHARED_LIMITf, temp_val);

        /*C461: OP_QUEUE_CONFIG_THDORQEE.Q_LIMIT_DYNAMIC:=lossless=0 else 1*/

        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEEr, &rval,
                          Q_LIMIT_DYNAMICf, 
                          _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
            
        /*C462:OP_QUEUE_CONFIG_THDORQEE.Q_LIMIT_ENABLE:=lossless=0 else 1*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEEr, &rval,
                          Q_LIMIT_ENABLEf, 
                          _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_THDORQEEr(
                            unit, cos, rval));

    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_THDORQEEr); cos++) {
        SOC_IF_ERROR_RETURN(
                     READ_OP_QUEUE_RESET_OFFSET_THDORQEEr(unit, cos,&rval));
        /*C460: OP_QUEUE_RESET_OFFSET_THDORQEE.Q_RESET_OFFSET == 2 */
        soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_THDORQEEr, &rval,
                          Q_RESET_OFFSETf, 2);
        SOC_IF_ERROR_RETURN(
                     WRITE_OP_QUEUE_RESET_OFFSET_THDORQEEr(unit, cos,rval));
    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEEr); 
        cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_YELLOW_THDORQEEr(
                            unit, cos,&rval));
        /* C465: OP_QUEUE_LIMIT_YELLOW_THDORQEE.Q_LIMIT_YELLOW
                 for lossless =CEILING(C459/8, 1)    else C459*/
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            temp_val = ceil_func(output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_ext_buff,8);
        } else {
            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
        }	
        /* 
        SOC_FIND_FIELD(Q_LIMIT_YELLOWf,
                   SOC_REG_INFO(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEEr).fields,
                   SOC_REG_INFO(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEEr).nFields,
                   fieldp);
        if (temp_val >= (1 << fieldp->len)) {
            temp_val = (1 << fieldp->len) - 1;
        }
         */
        soc_reg_field_set(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEEr, &rval,
            Q_LIMIT_YELLOWf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_YELLOW_THDORQEEr(
                                unit, cos,rval));
    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_RED_THDORQEEr); 
        cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_RED_THDORQEEr(
                            unit, cos,&rval));
        /* C466: OP_QUEUE_LIMIT_RED_THDORQEE.Q_LIMIT_RED
                 for lossless =CEILING(C459/8, 1)    else C459 */
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            temp_val = ceil_func(output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_ext_buff,8);
        } else {
            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
        }	
        /* 
        SOC_FIND_FIELD(Q_LIMIT_REDf,
                   SOC_REG_INFO(unit, OP_QUEUE_LIMIT_RED_THDORQEEr).fields,
                   SOC_REG_INFO(unit, OP_QUEUE_LIMIT_RED_THDORQEEr).nFields,
                   fieldp);
        if (temp_val >= (1 << fieldp->len)) {
            temp_val = (1 << fieldp->len) - 1;
        }
         */
        soc_reg_field_set(unit, OP_QUEUE_LIMIT_RED_THDORQEEr, &rval,
            Q_LIMIT_REDf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_RED_THDORQEEr(
                            unit, cos,rval));
    }
    for(cos=0; 
        cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEEr); 
        cos++) {
        SOC_IF_ERROR_RETURN(
            READ_OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEEr(unit, cos,&rval));
        /*C467:OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEE.RESUME_OFFSET_YELLOW=2*/
        soc_reg_field_set(unit,
            OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEEr, &rval,
            RESUME_OFFSET_YELLOWf, 2);
        SOC_IF_ERROR_RETURN(
            WRITE_OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEEr(unit, cos,rval));
    }
    for(cos=0; 
        cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_RED_THDORQEEr); 
        cos++) {
        SOC_IF_ERROR_RETURN(
            READ_OP_QUEUE_RESET_OFFSET_RED_THDORQEEr(unit, cos,&rval));
        /*C468:OP_QUEUE_RESET_OFFSET_RED_THDORQEE.RESUME_OFFSET_RED=2*/
        soc_reg_field_set(unit,
            OP_QUEUE_RESET_OFFSET_RED_THDORQEEr, &rval,
            RESUME_OFFSET_REDf, 2);
        SOC_IF_ERROR_RETURN(
            WRITE_OP_QUEUE_RESET_OFFSET_RED_THDORQEEr(unit, cos,rval));
    }
 }
    /* 2.5 EQEs                         */
    op_node = 0;
    SOC_PBMP_ITER (valid_port_cpu_pbmp, port) {
        if (!IS_CPU_PORT(unit, port) &&
            (port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT)) {
                op_node = ( si->port_cosq_base[port] / 8) - 1 ;
        }

        for (op_node_offset = 0; 
             op_node_offset < (IS_CPU_PORT(unit, port) ?
                               (si->port_num_uc_cosq[port] / 8) : 1); 
             op_node_offset++) {
             SOC_IF_ERROR_RETURN(READ_MMU_THDO_OPNCONFIG_QENTRYm(unit,
                        MEM_BLOCK_ANY,op_node + op_node_offset,
                        &mmu_thdo_opnconfig_qentry_entry));
             /* C470:THDO_OPNCONFIG_QENTRY.OPN_SHARED_LIMIT_QENTRY = =$C$221 */
             soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_QENTRYm, 
                 &mmu_thdo_opnconfig_qentry_entry, OPN_SHARED_LIMIT_QENTRYf,
                 output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs);

             /* C471:THDO_OPNCONFIG_QENTRY.OP_SHARED_RESET_VALUE_QENTRY
                     = =$C$470 -2 */
             temp_val = output_port_threshold->
                        min_grntd_tot_shr_queue_cells_EQEs - 2;
             soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_QENTRYm, 
                                 &mmu_thdo_opnconfig_qentry_entry, 
                                 OPN_SHARED_RESET_VALUE_QENTRYf, temp_val);

             /* C472:THDO_OPNCONFIG_QENTRY.PORT_LIMIT_ENABLE_QENTRY
                = 0 */
             soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_QENTRYm, 
                                 &mmu_thdo_opnconfig_qentry_entry, 
                                 PORT_LIMIT_ENABLE_QENTRYf, 0);
             soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_QENTRYm, 
                                 &mmu_thdo_opnconfig_qentry_entry, 
                                 PIDf, port);
             SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_OPNCONFIG_QENTRYm(unit,
                                 MEM_BLOCK_ANY,op_node + op_node_offset,
                                 &mmu_thdo_opnconfig_qentry_entry));
        }
        for (queue = si->port_uc_cosq_base[port];
             queue < si->port_uc_cosq_base[port] + si->port_num_uc_cosq[port];
             queue++) {


             SOC_IF_ERROR_RETURN(READ_MMU_THDO_QCONFIG_QENTRYm(unit,
                                 MEM_BLOCK_ANY,queue,
                                 &mmu_thdo_qconfig_qentry_entry));
             /* C473:THDO_QCONFIG_QENTRY.Q_MIN_QENTRY = =$C$203 */
             soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                 &mmu_thdo_qconfig_qentry_entry, Q_MIN_QENTRYf,
                 output_port_threshold->min_grntd_res_queue_cells_EQEs);

             /* C474:THDO_QCONFIG_QENTRY.Q_SHARED_LIMIT_QENTRY
                         =IF($C$14,$C$221,$C$60) */
             if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                 temp_val = output_port_threshold->
                                   min_grntd_tot_shr_queue_cells_EQEs;
             } else {
                 temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
             }
             soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                 &mmu_thdo_qconfig_qentry_entry, Q_SHARED_LIMIT_QENTRYf, temp_val);

             /* C476:THDO_QCONFIG_QENTRY.Q_LIMIT_DYNAMIC_QENTRY
                     =IF($C$14, 0, 1) */
             soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                     &mmu_thdo_qconfig_qentry_entry, Q_LIMIT_DYNAMIC_QENTRYf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

             /* C477:THDO_QCONFIG_QENTRY.Q_LIMIT_ENABLE_QENTRY
                         =IF($C$14, 0, 1) */
             soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                     &mmu_thdo_qconfig_qentry_entry, Q_LIMIT_ENABLE_QENTRYf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

             /* C478:THDO_QCONFIG_QENTRY.Q_COLOR_ENABLE_QENTRY = 0 */
             soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                     &mmu_thdo_qconfig_qentry_entry, Q_COLOR_ENABLE_QENTRYf,0); 

             /* C479: THDO_QCONFIG_QENTRY.Q_COLOR_LIMIT_DYNAMIC_QENTRY
                     =IF($C$14, 0, 1) */
             soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                     &mmu_thdo_qconfig_qentry_entry, 
                     Q_COLOR_LIMIT_DYNAMIC_QENTRYf,
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

             /* C480: THDO_QCONFIG_QENTRY.LIMIT_YELLOW_QENTRY= 
                      if lossless= C474/8 else C474 */
             temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_QENTRYm, 
                        &mmu_thdo_qconfig_qentry_entry, Q_SHARED_LIMIT_QENTRYf);
             soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                     &mmu_thdo_qconfig_qentry_entry, LIMIT_YELLOW_QENTRYf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 
                     ceil_func(temp_val, 8) : temp_val);
             SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QCONFIG_QENTRYm(unit,
                                 MEM_BLOCK_ANY,queue,
                                 &mmu_thdo_qconfig_qentry_entry));

             SOC_IF_ERROR_RETURN(READ_MMU_THDO_QOFFSET_QENTRYm(unit,
                                 MEM_BLOCK_ANY,queue,
                                 &mmu_thdo_qoffset_qentry_entry));
             /* C475:THDO_QOFFSET_QENTRY.RESET_OFFSET_QENTRY =1 */
             soc_mem_field32_set(unit, MMU_THDO_QOFFSET_QENTRYm, 
                 &mmu_thdo_qoffset_qentry_entry, RESET_OFFSET_QENTRYf, 1);

             /* C481: THDO_QOFFSET_QENTRY.LIMIT_RED_QENTRY  = 
                      if lossless= C474/8 else C474 */
             temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_QENTRYm, 
                        &mmu_thdo_qconfig_qentry_entry, Q_SHARED_LIMIT_QENTRYf);
             soc_mem_field32_set(unit, MMU_THDO_QOFFSET_QENTRYm, 
                 &mmu_thdo_qoffset_qentry_entry, LIMIT_RED_QENTRYf, 
                 _soc_kt2_mmu_params.lossless_mode_d_c ? 
                 ceil_func(temp_val, 8) : temp_val);

             /* C482: THDO_QOFFSET_QENTRY.RESET_OFFSET_YELLOW_QENTRY =1 */
             soc_mem_field32_set(unit, MMU_THDO_QOFFSET_QENTRYm, 
                 &mmu_thdo_qoffset_qentry_entry,RESET_OFFSET_YELLOW_QENTRYf,1); 
             /* C483: THDO_QOFFSET_QENTRY.RESET_OFFSET_RED_QENTRY =1 */
             soc_mem_field32_set(unit, MMU_THDO_QOFFSET_QENTRYm, 
                 &mmu_thdo_qoffset_qentry_entry, RESET_OFFSET_RED_QENTRYf,1); 

             SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QOFFSET_QENTRYm(unit,
                                 MEM_BLOCK_ANY,queue,
                                 &mmu_thdo_qoffset_qentry_entry));
        }
    }
    /* 2.5 Redirect Port                */
    /* 2.5.1 RDEQ */
    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDORDEQr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG1_THDORDEQr(
                            unit, cos, &rval));
        /* C485:OP_QUEUE_CONFIG1_THDORDEQ.Q_MIN = 9 (C205) */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEQr, &rval,
                Q_MINf, 9);
                /* output_port_threshold->min_grntd_res_RE_WQs_cells); */
         
        /* C490:OP_QUEUE_CONFIG1_THDORDEQ.Q_COLOR_ENABLE  = 0 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEQr, &rval,
                          Q_COLOR_ENABLEf, 0);

        /* C491:OP_QUEUE_CONFIG1_THDORDEQ.Q_COLOR_DYNAMIC = 1*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEQr, &rval,
                          Q_COLOR_DYNAMICf, 1);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG1_THDORDEQr(
                            unit, cos, rval));
    }

    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG_THDORDEQr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORDEQr(
                            unit, cos, &rval));
        /* C486:OP_QUEUE_CONFIG_THDORDEQ.Q_SHARED_LIMIT = 7 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEQr, &rval,
                          Q_SHARED_LIMITf, 7);

        /*C488: OP_QUEUE_CONFIG_THDORDEQ.Q_LIMIT_DYNAMIC:=1 */

        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEQr, &rval,
                          Q_LIMIT_DYNAMICf,1); 
            
        /*C489:OP_QUEUE_CONFIG_THDORDEQ.Q_LIMIT_ENABLE:=0 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEQr, &rval,
                          Q_LIMIT_ENABLEf, 0);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_THDORDEQr(
                            unit, cos, rval));
    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_THDORDEQr); cos++) {
        SOC_IF_ERROR_RETURN(
                     READ_OP_QUEUE_RESET_OFFSET_THDORDEQr(unit, cos,&rval));
        /*C487: OP_QUEUE_RESET_OFFSET_THDORDEQ.Q_RESET_OFFSET == 1 */
        soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_THDORDEQr, &rval,
                          Q_RESET_OFFSETf, 1);
        SOC_IF_ERROR_RETURN(
                     WRITE_OP_QUEUE_RESET_OFFSET_THDORDEQr(unit, cos,rval));
    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_YELLOW_THDORDEQr); 
        cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_YELLOW_THDORDEQr(
                            unit, cos,&rval));
        /* C492: OP_QUEUE_LIMIT_YELLOW_THDORDEQ.Q_LIMIT_YELLOW = C486 ==>7 */
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORDEQr(
                            unit, cos, &rval));
        temp_val = soc_reg_field_get(unit, OP_QUEUE_CONFIG_THDORDEQr, rval,
                          Q_SHARED_LIMITf);

        soc_reg_field_set(unit, OP_QUEUE_LIMIT_YELLOW_THDORDEQr, &rval,
            Q_LIMIT_YELLOWf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_YELLOW_THDORDEQr(
                                unit, cos,rval));
    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_RED_THDORDEQr); 
        cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_RED_THDORDEQr(
                            unit, cos,&rval));
        /* C493: OP_QUEUE_LIMIT_RED_THDORDEQ.Q_LIMIT_RED = C486 */
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORDEQr(
                            unit, cos, &rval));
        temp_val = soc_reg_field_get(unit, OP_QUEUE_CONFIG_THDORDEQr, rval,
                          Q_SHARED_LIMITf);

        soc_reg_field_set(unit, OP_QUEUE_LIMIT_RED_THDORDEQr, &rval,
            Q_LIMIT_REDf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_RED_THDORDEQr(
                            unit, cos,rval));
    }
    for(cos=0; 
        cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEQr); 
        cos++) {
        SOC_IF_ERROR_RETURN(
            READ_OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEQr(unit, cos,&rval));
        /*C494:OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEQ.RESUME_OFFSET_YELLOW=1*/
        soc_reg_field_set(unit,
            OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEQr, &rval,
            RESUME_OFFSET_YELLOWf, 1);
        SOC_IF_ERROR_RETURN(
            WRITE_OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEQr(unit, cos,rval));
    }
    for(cos=0; 
        cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_RED_THDORDEQr); 
        cos++) {
        SOC_IF_ERROR_RETURN(
            READ_OP_QUEUE_RESET_OFFSET_RED_THDORDEQr(unit, cos,&rval));
        /*C495:OP_QUEUE_RESET_OFFSET_RED_THDORDEQ.RESUME_OFFSET_RED=1*/
        soc_reg_field_set(unit,
            OP_QUEUE_RESET_OFFSET_RED_THDORDEQr, &rval,
            RESUME_OFFSET_REDf, 1);
        SOC_IF_ERROR_RETURN(
            WRITE_OP_QUEUE_RESET_OFFSET_RED_THDORDEQr(unit, cos,rval));
    }
    /* 2.5.2 RDEI */
    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDORDEIr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG1_THDORDEIr(
                            unit, cos, &rval));
        /* C496:OP_QUEUE_CONFIG1_THDORDEI.Q_MIN = 9 (C206) */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEIr, &rval, Q_MINf, 
          _soc_kt2_mmu_params.lossless_mode_d_c? 9 :
          output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_int_buff);
         
        /* C501:OP_QUEUE_CONFIG1_THDORDEI.Q_COLOR_ENABLE  = 0 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEIr, &rval,
                          Q_COLOR_ENABLEf, 0);

        /* C491:OP_QUEUE_CONFIG1_THDORDEI.Q_COLOR_DYNAMIC = 1*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEIr, &rval,
                          Q_COLOR_DYNAMICf, 1);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG1_THDORDEIr(
                            unit, cos, rval));
    }

    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG_THDORDEIr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORDEIr(
                            unit, cos, &rval));
        /* C497:OP_QUEUE_CONFIG_THDORDEI.Q_SHARED_LIMIT = 7 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEIr, &rval,
                          Q_SHARED_LIMITf, 7);

        /*C499: OP_QUEUE_CONFIG_THDORDEI.Q_LIMIT_DYNAMIC:=1 */

        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEIr, &rval,
                          Q_LIMIT_DYNAMICf,1); 
            
        /*C500:OP_QUEUE_CONFIG_THDORDEI.Q_LIMIT_ENABLE:=0 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEIr, &rval,
                          Q_LIMIT_ENABLEf, 0);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_THDORDEIr(
                            unit, cos, rval));
    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_THDORDEIr); cos++) {
        SOC_IF_ERROR_RETURN(
                     READ_OP_QUEUE_RESET_OFFSET_THDORDEIr(unit, cos,&rval));
        /*C498: OP_QUEUE_RESET_OFFSET_THDORDEI.Q_RESET_OFFSET == 2 */
        soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_THDORDEIr, &rval,
                          Q_RESET_OFFSETf, 2);
        SOC_IF_ERROR_RETURN(
                     WRITE_OP_QUEUE_RESET_OFFSET_THDORDEIr(unit, cos,rval));
    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_YELLOW_THDORDEIr); 
        cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_YELLOW_THDORDEIr(
                            unit, cos,&rval));
        /* C503: OP_QUEUE_LIMIT_YELLOW_THDORDEI.Q_LIMIT_YELLOW = C497 ==>7 */
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORDEIr(
                            unit, cos, &rval));
        temp_val = soc_reg_field_get(unit, OP_QUEUE_CONFIG_THDORDEIr, rval,
                          Q_SHARED_LIMITf);

        soc_reg_field_set(unit, OP_QUEUE_LIMIT_YELLOW_THDORDEIr, &rval,
            Q_LIMIT_YELLOWf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_YELLOW_THDORDEIr(
                                unit, cos,rval));
    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_RED_THDORDEIr); 
        cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_RED_THDORDEIr(
                            unit, cos,&rval));
        /* C504: OP_QUEUE_LIMIT_RED_THDORDEI.Q_LIMIT_RED = C497 */
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORDEIr(
                            unit, cos, &rval));
        temp_val = soc_reg_field_get(unit, OP_QUEUE_CONFIG_THDORDEIr, rval,
                          Q_SHARED_LIMITf);

        soc_reg_field_set(unit, OP_QUEUE_LIMIT_RED_THDORDEIr, &rval,
            Q_LIMIT_REDf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_RED_THDORDEIr(
                            unit, cos,rval));
    }
    for(cos=0; 
        cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEIr); 
        cos++) {
        SOC_IF_ERROR_RETURN(
            READ_OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEIr(unit, cos,&rval));
        /*C505:OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEI.RESUME_OFFSET_YELLOW=2*/
        soc_reg_field_set(unit,
            OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEIr, &rval,
            RESUME_OFFSET_YELLOWf, 2);
        SOC_IF_ERROR_RETURN(
            WRITE_OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEIr(unit, cos,rval));
    }
    for(cos=0; 
        cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_RED_THDORDEIr); 
        cos++) {
        SOC_IF_ERROR_RETURN(
            READ_OP_QUEUE_RESET_OFFSET_RED_THDORDEIr(unit, cos,&rval));
        /*C506:OP_QUEUE_RESET_OFFSET_RED_THDORDEI.RESUME_OFFSET_RED=2*/
        soc_reg_field_set(unit,
            OP_QUEUE_RESET_OFFSET_RED_THDORDEIr, &rval,
            RESUME_OFFSET_REDf, 2);
        SOC_IF_ERROR_RETURN(
            WRITE_OP_QUEUE_RESET_OFFSET_RED_THDORDEIr(unit, cos,rval));
    }

    /* 2.5.2 RDEE */
 if(ext_mem_port_count) {
    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDORDEEr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG1_THDORDEEr(
                            unit, cos, &rval));
        /* C507:OP_QUEUE_CONFIG1_THDORDEE.Q_MIN =  lossless=9 lossy:C485*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEEr, &rval, Q_MINf, 
          _soc_kt2_mmu_params.lossless_mode_d_c? 9 :
          output_port_threshold->min_grntd_res_RE_WQs_cells);
         
        /* C512:OP_QUEUE_CONFIG1_THDORDEE.Q_COLOR_ENABLE  = 0 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEEr, &rval,
                          Q_COLOR_ENABLEf, 0);

        /* C513:OP_QUEUE_CONFIG1_THDORDEE.Q_COLOR_DYNAMIC = 1*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEEr, &rval,
                          Q_COLOR_DYNAMICf, 1);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG1_THDORDEEr(
                            unit, cos, rval));
    }

    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG_THDORDEEr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORDEEr(
                            unit, cos, &rval));
        /* C508:OP_QUEUE_CONFIG_THDORDEE.Q_SHARED_LIMIT = 7 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEEr, &rval,
                          Q_SHARED_LIMITf, 7);

        /*C510: OP_QUEUE_CONFIG_THDORDEE.Q_LIMIT_DYNAMIC:=1 */

        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEEr, &rval,
                          Q_LIMIT_DYNAMICf,1); 
            
        /*C511:OP_QUEUE_CONFIG_THDORDEE.Q_LIMIT_ENABLE:=0 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEEr, &rval,
                          Q_LIMIT_ENABLEf, 0);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_THDORDEEr(
                            unit, cos, rval));
    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_THDORDEEr); cos++) {
        SOC_IF_ERROR_RETURN(
                     READ_OP_QUEUE_RESET_OFFSET_THDORDEEr(unit, cos,&rval));
        /*C509:OP_QUEUE_RESET_OFFSET_THDORDEE.Q_RESET_OFFSETlossless=2 else 1 */
        soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_THDORDEEr, &rval,
                          Q_RESET_OFFSETf, 
                          _soc_kt2_mmu_params.lossless_mode_d_c? 2 : 1);
        SOC_IF_ERROR_RETURN(
                     WRITE_OP_QUEUE_RESET_OFFSET_THDORDEEr(unit, cos,rval));
    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_YELLOW_THDORDEEr); 
        cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_YELLOW_THDORDEEr(
                            unit, cos,&rval));
        /* C514: OP_QUEUE_LIMIT_YELLOW_THDORDEE.Q_LIMIT_YELLOW = 7 */

        soc_reg_field_set(unit, OP_QUEUE_LIMIT_YELLOW_THDORDEEr, &rval,
            Q_LIMIT_YELLOWf, 7);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_YELLOW_THDORDEEr(
                                unit, cos,rval));
    }
    for(cos=0; 
        cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_RED_THDORDEEr); 
        cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_RED_THDORDEEr(
                            unit, cos,&rval));
        /* C515: OP_QUEUE_LIMIT_RED_THDORDEE.Q_LIMIT_RED = 7 */
        soc_reg_field_set(unit, OP_QUEUE_LIMIT_RED_THDORDEEr, &rval,
            Q_LIMIT_REDf, 7);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_RED_THDORDEEr(
                            unit, cos,rval));
    }
    for(cos=0; 
        cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEEr); 
        cos++) {
        SOC_IF_ERROR_RETURN(
            READ_OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEEr(unit, cos,&rval));
        /*C516:OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEE.RESUME_OFFSET_YELLOW=2*/
        soc_reg_field_set(unit,
            OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEEr, &rval,
            RESUME_OFFSET_YELLOWf, 2);
        SOC_IF_ERROR_RETURN(
            WRITE_OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEEr(unit, cos,rval));
    }
    for(cos=0; 
        cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_RED_THDORDEEr); 
        cos++) {
        SOC_IF_ERROR_RETURN(
            READ_OP_QUEUE_RESET_OFFSET_RED_THDORDEEr(unit, cos,&rval));
        /*C517:OP_QUEUE_RESET_OFFSET_RED_THDORDEE.RESUME_OFFSET_RED=2*/
        soc_reg_field_set(unit,
            OP_QUEUE_RESET_OFFSET_RED_THDORDEEr, &rval,
            RESUME_OFFSET_REDf, 2);
        SOC_IF_ERROR_RETURN(
            WRITE_OP_QUEUE_RESET_OFFSET_RED_THDORDEEr(unit, cos,rval));
    }
 }
        /* Enable back pressure status from MMU for lossless mode */
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            COMPILER_64_SET(val64, 0x3ff, 0xffffffff); /* 0 to 41 ports */
            COMPILER_64_ZERO(r64val);
            soc_reg64_field_set(unit, THDIEXT_PORT_PAUSE_ENABLE_64r, &r64val,
                                PORT_PAUSE_ENABLEf, val64);
            SOC_IF_ERROR_RETURN(WRITE_THDIEXT_PORT_PAUSE_ENABLE_64r(
                                unit, r64val));

            COMPILER_64_ZERO(r64val);
            soc_reg64_field_set(unit, THDIQEN_PORT_PAUSE_ENABLE_64r, &r64val,
                                PORT_PAUSE_ENABLEf, val64);
            SOC_IF_ERROR_RETURN(WRITE_THDIQEN_PORT_PAUSE_ENABLE_64r(unit, r64val));

            COMPILER_64_ZERO(r64val);
            soc_reg64_field_set(unit, THDIRQE_PORT_PAUSE_ENABLE_64r, &r64val,
                                PORT_PAUSE_ENABLEf, val64);
            SOC_IF_ERROR_RETURN(WRITE_THDIRQE_PORT_PAUSE_ENABLE_64r(unit, r64val));

            COMPILER_64_ZERO(r64val);
            soc_reg64_field_set(unit, THDIEMA_PORT_PAUSE_ENABLE_64r, &r64val,
                                PORT_PAUSE_ENABLEf, val64);
            SOC_IF_ERROR_RETURN(WRITE_THDIEMA_PORT_PAUSE_ENABLE_64r(unit, r64val));

            COMPILER_64_ZERO(r64val);
            soc_reg64_field_set(unit, PORT_PAUSE_ENABLE_64r, &r64val,
                                PORT_PAUSE_ENABLEf, val64);
            SOC_IF_ERROR_RETURN(WRITE_PORT_PAUSE_ENABLE_64r(unit, r64val));
    }

    return SOC_E_NONE;
}


static 
void soc_katana2_save_tdm_pos(int unit, uint8 new_tdm_size,uint32 *new_tdm);
void soc_kt2_oam_interrupt_process(int unit);
void kt2_tdm_replace(uint32 *tdm, uint32 total_tdm_slots,
                     uint32  src, uint32 dst,uint32 one_time)
{
     uint32 index=0;
     for (index=0; index < total_tdm_slots ; index++ ) {
          if (tdm[index] == src) {
              tdm[index] = dst;
              if (one_time) {
                  break;
              }
          }
     }
}

void kt2_tdm_swap(uint32 *tdm, uint32 total_tdm_slots,
                  uint32  src, uint32 dst)
{
     uint32 index=0;
     uint32 temp_index=0;
     uint32 temp=0;
     for (index=0; index < total_tdm_slots ; index++ ) {
          if (tdm[index] == src) {
              temp_index=index;
          }
          if (tdm[index] == dst) {
              temp = tdm[temp_index];
              tdm[temp_index]=dst;
              tdm[index]=temp;
          }
     }
}

int
soc_katana2_pipe_mem_clear(int unit)
{
    uint32              rval;
    int                 pipe_init_usec;
    soc_timeout_t       to;

    /*
     * Reset the IPIPE and EPIPE block
     */
    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_1r(unit, rval));
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, VALIDf, 1);
    /* Set count to # entries in largest IPIPE table (L2X) */
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, COUNTf, 32768);
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_0r(unit, rval));

    rval = 0;
    SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1r (unit, &rval));
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, VALIDf, 1);
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    /* For simulation, set timeout to 10 sec.  Otherwise, timeout = 50 ms */
    if (SAL_BOOT_SIMULATION) {
        pipe_init_usec = 10000000;
    } else {
        pipe_init_usec = 50000;
    }
    soc_timeout_init(&to, pipe_init_usec, 0);

    /* Wait for IPIPE memory initialization done. */
    do {
        SOC_IF_ERROR_RETURN(READ_ING_HW_RESET_CONTROL_2r(unit, &rval));
        if (soc_reg_field_get(unit, ING_HW_RESET_CONTROL_2r, rval, DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            soc_cm_debug(DK_WARN, "unit %d : ING_HW_RESET timeout\n", unit);
            break;
        }
    } while (TRUE);

    /* Wait for EPIPE memory initialization done. */
    do {
        SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1r(unit, &rval));
        if (soc_reg_field_get(unit, EGR_HW_RESET_CONTROL_1r, rval, DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            soc_cm_debug(DK_WARN, "unit %d : EGR_HW_RESET timeout\n", unit);
            break;
        }
    } while (TRUE);

    SOC_IF_ERROR_RETURN(READ_ING_HW_RESET_CONTROL_2r(unit, &rval));
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, RESET_ALLf, 0);
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, CMIC_REQ_ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));

    SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1r(unit, &rval));
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, RESET_ALLf, 0);
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    return SOC_E_NONE;
}

int soc_katana2_linkphy_mem_clear(unit)
{
    soc_mem_t mem;

    mem = RXLP_INTERNAL_STREAM_MAP_PORT_0m;
    SOC_IF_ERROR_RETURN(soc_mem_clear(unit, mem, COPYNO_ALL, TRUE));

    mem = RXLP_INTERNAL_STREAM_MAP_PORT_1m;
    SOC_IF_ERROR_RETURN(soc_mem_clear(unit, mem, COPYNO_ALL, TRUE));

    mem = RXLP_INTERNAL_STREAM_MAP_PORT_2m;
    SOC_IF_ERROR_RETURN(soc_mem_clear(unit, mem, COPYNO_ALL, TRUE));

    mem = RXLP_INTERNAL_STREAM_MAP_PORT_3m;
    SOC_IF_ERROR_RETURN(soc_mem_clear(unit, mem, COPYNO_ALL, TRUE));

    mem = TXLP_PORT_STREAM_BITMAP_TABLEm;
    SOC_IF_ERROR_RETURN(soc_mem_clear(unit, mem, COPYNO_ALL, TRUE));

    mem = TXLP_INT2EXT_STREAM_MAP_TABLEm;
    SOC_IF_ERROR_RETURN(soc_mem_clear(unit, mem, COPYNO_ALL, TRUE));

    mem = DEVICE_STREAM_ID_TO_PP_PORT_MAPm;
    SOC_IF_ERROR_RETURN(soc_mem_clear(unit, mem, COPYNO_ALL, TRUE));

    mem = PP_PORT_TO_PHYSICAL_PORT_MAPm;
    SOC_IF_ERROR_RETURN(soc_mem_clear(unit, mem, COPYNO_ALL, TRUE));

    return SOC_E_NONE;
}
soc_error_t kt2_tdm_verify(uint32 *tdm,
                           uint32 total_tdm_slots,
                           uint32 tdm_freq,    /* In MHHz */
                           uint32 *port_speed,
                           uint32 olp_port_flag,  
                           uint32 *offender_port)
{
    /* Following rules need to be met */
    /* Rule1 : Each Loopback port need 2.5G bandwidth */
    /* Rule2 : Each CMIC port need 2G bandwidth       */
    /* Rule3 : Loopback (LPBK) ports require min 3 cycle spacing among LPBK or 
               CMIC ports */ 
    /* Rule4 : Each subport in MXQPORT operates with 4 cycle TDM */
    /* Rule5 : Each 10G-XAUI ports should be able to operate in 4x2.5G with 4 
               slots allocated to each subport from the same MXQPORT */
    soc_error_t           rv=SOC_E_NONE;
    uint32                index=0;
    uint32                expected_tdm_cycles_min=0;
    uint32                expected_tdm_cycles_max=0;
    uint32                tdm_freq_index=0;
    uint32                speed_index=0;
    uint32                port=0;
    uint32                speed=0;
    uint32                worse_tdm_slot_spacing=0;
    uint32                prev_tdm_slot_spacing=0;
    uint32                next_tdm_slot_spacing=0;
    uint32                tdm_slot_spacing=0;
    uint32                min_tdm_cycles=0; /* To Meet BW */
    uint32                count=0; 
    uint32                skip_count=0; 
    uint32                mxqblock=0;
    uint32                outer_port=0;
    uint32                inner_port=0;
    uint32                spacing=0;
    uint32                loop=0;
    tdm_port_slots_info_t *head=NULL;
    tdm_port_slots_info_t *head1=NULL;
    tdm_port_slots_info_t *current=NULL;
    tdm_port_slots_info_t *current1=NULL;
    tdm_port_slots_info_t *prev = NULL;
    tdm_port_slots_info_t *temp=NULL;
    uint32                idle_flag=0;
    uint32                idle_rule=0;


   /* Possible TDM frequencies 
      80MHz(16Cycles) ,120MHz(20Cycles),155MHz(84Cycles),
      185MHz(80Cycles),185MHz(90Cycles) 
    */


   switch(tdm_freq) {
   case 80: tdm_freq_index=0;
            expected_tdm_cycles_min=16;
            expected_tdm_cycles_max=32;
            break;
   case 120: tdm_freq_index=1;
             expected_tdm_cycles_min=20;
             expected_tdm_cycles_max=40;
             break;
   case 155: tdm_freq_index=2;
             expected_tdm_cycles_min=84;
             expected_tdm_cycles_max=168;
             break;
   case 185: 
             expected_tdm_cycles_min=80;
             expected_tdm_cycles_max=180;
             if ((total_tdm_slots >= 80 ) && (total_tdm_slots <= 90)) {
                 tdm_freq_index=3; 
             } else {
                 tdm_freq_index=4; 
             }
             break;
   case 205:
             expected_tdm_cycles_min=88;
             expected_tdm_cycles_max=180;
             if (total_tdm_slots == 108 ) {
                 tdm_freq_index=5;
             }
             if (total_tdm_slots == 88 ) {
                 tdm_freq_index=6;
             }
             if (total_tdm_slots == 99 ) {
                 tdm_freq_index=7;
             }
             break;
   case 166: tdm_freq_index=8;
             expected_tdm_cycles_min=84;
             expected_tdm_cycles_max=84;
             break;
   default:  soc_cm_debug(DK_ERR,"Unsupported tdm frequency:%d\n",tdm_freq);
             return SOC_E_FAIL;
   }
   if (!((total_tdm_slots >= expected_tdm_cycles_min) && 
         (total_tdm_slots <= expected_tdm_cycles_max))) {
          soc_cm_debug(DK_ERR,"Unsupported tdm cycles:%d (min:%d max:%d\n",
                  total_tdm_slots,
                  expected_tdm_cycles_min,expected_tdm_cycles_max);
          return SOC_E_FAIL; 
   }

    idle_flag=0;
    idle_rule = 0;
    /* Initialize list */
    for (port=0;port < KT2_MAX_LOGICAL_PORTS ; port++) {
         kt2_tdm_port_slots_info[port].prev=&kt2_tdm_port_slots_info[port];
         kt2_tdm_port_slots_info[port].next=&kt2_tdm_port_slots_info[port];
         kt2_tdm_port_slots_info[port].position = -1;
    }
    for (index=0; index < total_tdm_slots; index++) {
         if ((tdm[index] == KT2_IDLE1) ||
             (tdm[index] == KT2_IDLE)) {
             if (idle_flag == 1) {
                 idle_rule = 1;
             }
             idle_flag=1;
             skip_count++;
             continue;
         }
         idle_flag=0;
         port = tdm[index];
         if (kt2_tdm_port_slots_info[port].position == -1) {
             /* First Entry */
             kt2_tdm_port_slots_info[port].position = index;
             skip_count++;
             continue;
         }
         head = current = &kt2_tdm_port_slots_info[port];
         while(current->next !=head) {
               current = current->next;
         } 
         current->next=sal_alloc(sizeof(tdm_port_slots_info_t),"TDM Pointer");
         count++;
         soc_cm_debug(DK_VERBOSE,"Count=%d SkipCount:%d  Port:%d  Addr:%p\n",count,skip_count,port,(void *)current->next);

         current->next->position=index;
         current->next->prev=current;
         current->next->next=head;
         head->prev=current->next;
   }
   if (idle_rule == 0) {
       /* Special case */
       /* soc_cm_debug(DK_VERBOSE,"Idle slot on edges \n"); */
       if (!(((tdm[0] == KT2_IDLE1) ||
             (tdm[0] == KT2_IDLE)) &&
            ((tdm[total_tdm_slots-1] == KT2_IDLE1) ||
             (tdm[total_tdm_slots-1] == KT2_IDLE)))) {
           soc_cm_debug(DK_VERBOSE,"Two consecutive idle not found \n");
           *offender_port = KT2_IDLE;
           return SOC_E_CONFIG;
       }
   }
   soc_cm_debug(DK_VERBOSE,"Final Count=%d SkipCount:%d\n",count,skip_count);
   soc_cm_debug(DK_VERBOSE,"Verifying rule  \n");
   soc_cm_debug(DK_VERBOSE,
                "Rule3: Loopback (LPBK) ports require min 3 cycle spacing "
                "among LPBK or CMIC ports \n");
   head = current = &kt2_tdm_port_slots_info[KT2_LPBK_PORT];
   do {
      prev = current->prev;
      if ( current->position != prev->position ) {
           prev_tdm_slot_spacing = 
                          (current->position - prev->position) > 0 ?
                          (current->position - prev->position)-1:
                          (total_tdm_slots - prev->position + 
                           current->position) - 1;
           next_tdm_slot_spacing = 
                          (current->next->position - current->position) >0 ?
                          (current->next->position - current->position)-1:
                          (total_tdm_slots - current->position +
                           current->next->position) - 1;
      if (prev_tdm_slot_spacing <= 3) {
          soc_cm_debug(DK_ERR,
                       "Loopback Ports need min 3 spacing but(prev)found"
                       "(current:%d , prev:%d)=%d\n",
                       current->position,prev->position,prev_tdm_slot_spacing);
          rv = SOC_E_FAIL;
          continue;
      } 
      if (next_tdm_slot_spacing <= 3) {
          soc_cm_debug(DK_ERR,
                       "Loopback Ports need min 3 spacing but(next)found"
                       "(current:%d , prev:%d)=%d\n",
                        current->position,prev->position,next_tdm_slot_spacing);
          rv = SOC_E_CONFIG;
          *offender_port = KT2_LPBK_PORT;
          continue;
      } 
      } else {
          prev_tdm_slot_spacing = next_tdm_slot_spacing = 0;
      }
      head1 = current1 = &kt2_tdm_port_slots_info[KT2_CMIC_PORT];
      do {
         tdm_slot_spacing = (current->position - current1->position) > 0 ?
                          (current->position - current1->position)-1:
                          (total_tdm_slots - current1->position + 
                           current->position) - 1  ;
         if (tdm_slot_spacing <= 3) {
             soc_cm_debug(DK_ERR,
                          "Loopback and CMIC ports need min 3 spacing but "
                          "found:%u" "(Loopack current:%d , CMIC Current:%d)\n",
                          tdm_slot_spacing,
                          current->position,current1->position);
             rv = SOC_E_CONFIG;
             *offender_port=KT2_LPBK_PORT;
             continue;
         }
         current1 = current1->next;
      }while ((current1 !=head1) && (rv == SOC_E_NONE));
      current = current->next;
   } while ((current !=head) && (rv == SOC_E_NONE));
   soc_cm_debug(DK_VERBOSE,"Verifying rules \n");
   soc_cm_debug(DK_VERBOSE,"Rule1 : Each Loopback port need 2.5G bandwidth \n");
   soc_cm_debug(DK_VERBOSE,"Rule2 : Each CMIC port need 2G bandwidth       \n");
   for (index=0;index < KT2_MAX_LOGICAL_PORTS && rv == SOC_E_NONE ;index++ ) {
        port = index ;
        if (kt2_tdm_port_slots_info[port].position == -1) {
            continue;
        }
        soc_cm_debug(DK_VERBOSE," %d ==>\n\n",port);
        switch(port) {
        case KT2_CMIC_PORT: soc_cm_debug(DK_VERBOSE,"CMIM \n");
                            speed =2000; 
                            break;
        case KT2_LPBK_PORT: soc_cm_debug(DK_VERBOSE,"LOOPBAKC \n");
                            speed =2500; 
                            break;
        default:            soc_cm_debug(DK_VERBOSE," Port:%d Speed %d ==>\n\n",
                                   port,port_speed[port-1]);
                            speed = port_speed[port-1];
                            break;
        }
        switch(speed) {
        case 1000 : speed_index=0;break;/* 1G   */ 
        case 2000 : speed_index=1;break;/* 2G   */ 
        case 2500 : speed_index=2;break;/* 2.5G */ 
        case 10000: speed_index=3;break;/* 10G  */ 
        case 13000: speed_index=4;break;/* 13G  */ 
        case 20000: speed_index=5;break;/* 20G  */ 
        case 21000: speed_index=6;break;/* 21G  */ 
        default   : soc_cm_debug(DK_ERR,"Unsupported speed:%d \n",speed);
                    return SOC_E_FAIL;
        }
        worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                               worse_tdm_slot_spacing;
        min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                       min_tdm_cycles;

        count=0;
        head = current = &kt2_tdm_port_slots_info[port];
        do {
           prev = current->prev;
           if (current->position != prev->position ) {
               prev_tdm_slot_spacing = 
                          (current->position - prev->position)> 0 ?
                          (current->position - prev->position)-1:
                          (total_tdm_slots - prev->position + 
                           current->position) - 1  ;
               next_tdm_slot_spacing = 
                          (current->next->position - current->position) > 0 ?
                          (current->next->position - current->position)-1:
                          (total_tdm_slots - current->position + 
                           current->next->position) - 1;
           } else {
               prev_tdm_slot_spacing = next_tdm_slot_spacing = 0;
           }
           soc_cm_debug(DK_VERBOSE,"Pos:%d Spacing (Prev %d - %d =  )%d"
                        "(Next %d - %d =  )%d\n", current->position,
                        current->position , prev->position ,
                        prev_tdm_slot_spacing, current->next->position , 
                        current->position , next_tdm_slot_spacing);
           if ((prev_tdm_slot_spacing > worse_tdm_slot_spacing) ||
               (next_tdm_slot_spacing > worse_tdm_slot_spacing)) {
                soc_cm_debug(DK_ERR,"WorseSpacing:%d NOK !!!! port:%d\n",
                       worse_tdm_slot_spacing,port);
                rv = SOC_E_CONFIG;
                *offender_port=port;
                continue;
           }
           count++;
           current = current->next;
        } while ((current !=head) && (rv == SOC_E_NONE)) ;
        soc_cm_debug(DK_VERBOSE,"TDM Cycles: %d \n",count);
        if (count < min_tdm_cycles) {
            soc_cm_debug(DK_ERR,"min_tdm_cycles:%dNOK  !!!! port:%d\n",
                         min_tdm_cycles,port);
            rv =  SOC_E_CONFIG;
            *offender_port=port;
            continue;
        }
        soc_cm_debug(DK_VERBOSE,"n== %d <==\n\n",port);
   }

   soc_cm_debug(DK_VERBOSE,"Verifying rule  \n");
   soc_cm_debug(DK_VERBOSE,
                "Rule4 : Each subport in MXQPORT operates with 4 cycle TDM \n");
   soc_cm_debug(DK_VERBOSE,"Verifying MXQports spacing concern\n");
   for(mxqblock=0;mxqblock<KT2_MAX_MXQBLOCKS && rv == SOC_E_NONE ;mxqblock++) {
       for(index=0;
           index<KT2_MAX_MXQPORTS_PER_BLOCK && rv == SOC_E_NONE;
           index++) {
           outer_port = kt2_mxqblock_ports[mxqblock][index];
           if (outer_port == 0xFF) {
                continue;
           }
#if 0
           /* Ignore MXQSpacing issue for OLP Port */
           if ((outer_port == KT2_OLP_PORT) && (olp_port_flag)) {
                continue;
           }
#endif
           if (kt2_tdm_port_slots_info[outer_port].position == -1) {
               continue;
           }
           head = current = &kt2_tdm_port_slots_info[outer_port];
           do {
              for(loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK; loop++) {
                  inner_port=kt2_mxqblock_ports[mxqblock][loop];
                  if (inner_port == 0xFF) {
                      continue;
                  }
#if 0
                  /* Ignore MXQSpacing issue for OLP Port */
                  if ((inner_port == KT2_OLP_PORT) && (olp_port_flag)) {
                       continue;
                  }
#endif
                  if ( inner_port == outer_port) {
                       continue;
                  }
                  if (kt2_tdm_port_slots_info[inner_port].position == -1) {
                      continue;
                  }
                  head1 = current1 = &kt2_tdm_port_slots_info[inner_port];
                  do {
                       spacing = (current->position - current1->position) > 0 ?
                                 (current->position - current1->position)-1:
                                 (total_tdm_slots - current1->position +
                                  current->position) - 1;
                       if (spacing < 3) {
                           soc_cm_debug(DK_ERR,
                                        "Port:%d MXQSpacing Issue Expected > 4 "
                                        "but observed %d\n",inner_port,spacing);
                           rv = SOC_E_CONFIG;
                           *offender_port=outer_port;
                           continue;
                       }
                       current1 = current1->next;
                  } while ((current1 !=head1) && (rv == SOC_E_NONE));
              }
              current = current->next;
         } while ((current !=head) && (rv == SOC_E_NONE));
      }
  }

  /* Free allocated resources */
  count=0;
  for (port=0;port < KT2_MAX_LOGICAL_PORTS ; port++) {
       head = current = &kt2_tdm_port_slots_info[port];
       do {
          temp = current->next;
          if (current != head) {
              count++;
              soc_cm_debug(DK_VERBOSE,"Freed count :%d\n",count);
              sal_free(current);
          }          
          current = temp;
       } while (current != head);
       kt2_tdm_port_slots_info[port].prev=NULL;
       kt2_tdm_port_slots_info[port].next=NULL;
       kt2_tdm_port_slots_info[port].position = -1;
  }
  sal_memcpy(&kt2_current_tdm_cycles_info,
             &kt2_tdm_cycles_info[tdm_freq_index][0],
             sizeof(tdm_cycles_info_t)*KT2_MAX_SPEEDS);
  return rv;
}
static soc_error_t 
kt2_tdm_position_mask(uint32 port, 
                      int32  pos, 
                      uint32 total_tdm_slots,
                      uint32 *tdm_position_mask)
{
    uint32 count=0;
    uint32 mxqblock=0;
    int32  pos1=0;
    int32  pos2=0;

    if (!((port >=  1) && (port <= KT2_MAX_PHYSICAL_PORTS))) {
         return SOC_E_PORT;
    }
    mxqblock=kt2_port_to_mxqblock[port-1];
    for (count=0;count < 4; count++) {
         pos1 = (pos + count+1)%total_tdm_slots;
         tdm_position_mask[pos1] |= (1 << mxqblock);
         pos2 = (int32)(pos - (count+1));
         if (pos2 < 0) {
             pos2 = pos2 + total_tdm_slots;
         }
         tdm_position_mask[pos2] |= (1 << mxqblock);
    }
    return SOC_E_NONE;
}
void kt2_fill_pos(uint32 *tdm, 
                  uint32 total_tdm_slots,
                  int32  pos, 
                  uint32 port,
                  uint32 port_type,
                  uint32 min_tdm_cycles,
                  uint32 worse_tdm_slot_spacing,
                  uint32 optimal_tdm_slot_spacing)
{
    uint32 negative_flag=0;
    uint32 fill_count=0;
    uint32 optimal_pos=pos;
    uint32 no_optimal_flag=0;
    int32 mxqblock=0;
    static uint32 last_port_type;
    static uint32 previous_position[18]={0};

    if ((port != KT2_LPBK_PORT) && (port != KT2_CMIC_PORT)) {
         mxqblock=kt2_port_to_mxqblock[port-1];
    }
    if (pos == -1) {
        no_optimal_flag=1;
        pos = 0;
        if (last_port_type != port_type) { 
            for(fill_count=0;fill_count<18;fill_count++) {
                previous_position[fill_count]=0;
            }
        }
    }
    last_port_type=port_type;

    for(fill_count=0;fill_count<min_tdm_cycles;fill_count++) {
        if (no_optimal_flag == 1) {
            if ( previous_position[fill_count] != 0) {
                 pos = previous_position[fill_count]+1;
            }
        }
        while (1) {
               if (tdm[pos] == KT2_IDLE) {
                   if ((port == KT2_LPBK_PORT) || (port == KT2_CMIC_PORT)) {
                       break;
                   }
                   if ((kt2_tdm_position_mxq_mask[pos] & (1<<mxqblock))==0) {
                        break;
                   }
                   if (kt2_tdm_mxqblock_ports_used[kt2_port_to_mxqblock[port]] 
                       == 1) {
                        break;
                   }
               }
               if (no_optimal_flag == 0) {
                   if ((negative_flag == 0) && (fill_count != 0)) {
                        pos--;
                   } else {
                        pos++;
                        negative_flag=0;
                   }
               } else {
                   pos++;
               }
        }
        if (pos < optimal_pos) {
               negative_flag=1;
        }
        tdm[pos]=port;
        previous_position[fill_count]=pos;
        if (!((port == KT2_LPBK_PORT) || (port == KT2_CMIC_PORT))) {
               kt2_tdm_position_mask(port,
                                     pos,
                                     total_tdm_slots,
                                     kt2_tdm_position_mxq_mask);
        }
        pos = optimal_pos = pos + optimal_tdm_slot_spacing + 1;
        if (pos >= total_tdm_slots) {
            pos = total_tdm_slots -1;
            negative_flag = 0; /* forced too */
        }
    }
    if (no_optimal_flag == 0) {
            for(fill_count=0;fill_count<18;fill_count++) {
                previous_position[fill_count]=0;
            }
    }
}

static
void kt2_tdm_display(int unit,
                     uint32 *tdm,
                     uint32 total_tdm_slots,
                     uint32 row, uint32 col)
{
     uint32 inner_index=0;
     uint32 outer_index=0;

     soc_cm_debug(DK_VERBOSE,"\n");
     soc_cm_debug(DK_VERBOSE,"\t\t\t\t======TDM======\n");
     for (outer_index=0;outer_index < col ; outer_index ++ ) {
          soc_cm_debug(DK_VERBOSE,"\t%d",outer_index);
     }
     soc_cm_debug(DK_VERBOSE,"\n");
     for (outer_index=0;outer_index < col ; outer_index ++ ) {
          soc_cm_debug(DK_VERBOSE,"\t%d#",outer_index);
     }
     soc_cm_debug(DK_VERBOSE,"\n");

     for (outer_index=0; outer_index < total_tdm_slots ; outer_index +=col ) {
          soc_cm_debug(DK_VERBOSE,"%d==>\t",outer_index/col);
          for (inner_index=0;
               (inner_index < col) && 
               ((outer_index+inner_index) < total_tdm_slots) ; 
               inner_index++ ) {
               switch(tdm[outer_index+inner_index]) {
               case KT2_IDLE : soc_cm_debug(DK_VERBOSE,"IDLE\t"); break;
               case KT2_IDLE1 : soc_cm_debug(DK_VERBOSE,"IDLE1\t"); break;
               case KT2_LPBK_PORT : soc_cm_debug(DK_VERBOSE,"LPBK\t"); break;
               case KT2_CMIC_PORT : soc_cm_debug(DK_VERBOSE,"CMIC\t"); break;
               case KT2_OLP_PORT :  if (SOC_INFO(unit).olp_port) {
                                        soc_cm_debug(DK_VERBOSE,"OLP\t"); break;
                                    }
               default :            soc_cm_debug(DK_VERBOSE,"%d\t",
                                           tdm[outer_index+inner_index]);break;
               }
          }
          soc_cm_debug(DK_VERBOSE,"\n");
     }
}
soc_error_t kt2_tdm_generate(
            uint32 *port_speed,
            uint32 total_ports, 
            uint32 tdm_freq       , /* In MHHz */
            uint32 total_tdm_slots,
            uint32 *tdm, 
            char  *tdm_config_string)
{
    char temp_string[80];
    uint32 reserved_flag=0;
    uint32 optimal_pos=0;
    uint32 mxqblock;
    uint32 next_mxqblock;
    uint32 temp;
    uint32 total_bw=0;
    uint32 port=0;
    uint32 count=0;
    uint32 index=0;
    uint32 index1=0;

    int32  pos=0;

    uint32 kt2_1g_ports=0;
    uint32 kt2_1g_ports_array[40]={0};
    uint32 kt2_1g_ports_mxqflags[10]={0};
    /* int    kt2_1g_ports_pos[2]={0}; */
    uint32 kt2_2g_ports=0;
    uint32 kt2_2g_ports_array[40]={0};
    uint32 kt2_2g_ports_mxqflags[10]={0};

    uint32 kt2_2_5g_ports=0;
    uint32 kt2_2_5g_ports_array[40]={0};
    uint32 kt2_2_5g_ports_mxqflags[10]={0};

    uint32 kt2_10g_ports=0;
    uint32 kt2_10g_ports_array[40]={0};
    uint32 kt2_13g_ports=0;
    uint32 kt2_13g_ports_array[40]={0};
    /*
    uint32 kt2_20g_ports=0;
    uint32 kt2_20g_ports_array[40]={0};
    */
    uint32 kt2_21g_ports=0;
    uint32 kt2_21g_ports_array[40]={0};

    uint32 kt2_21g_reserved_position[2]={0,2};
    /* uint32 kt2_20g_reserved_position[2]={0,2}; */
    uint32 kt2_13g_reserved_position[2]={1,4};
    uint32 kt2_10g_reserved_position[2]={3,8};
    uint32 tdm_freq_index=0; 
    uint32 min_tdm_cycles=0; 
    uint32 lpbk_min_tdm_cycles=0; 
    uint32 cmic_min_tdm_cycles=0; 
    uint32 worse_tdm_slot_spacing=0; 
    uint32 optimal_tdm_slot_spacing=0; 
    /* uint32 min_tdm_slot_spacing=0; */
    uint32 speed_index=0; 
    uint32 speed_index_1g=0; 
    uint32 speed_index_2g=1; 
    uint32 speed_index_2_5g=2; 
    uint32 speed_index_10g=3; 
    uint32 speed_index_13g=4; 
    /* uint32 speed_index_20g=5;  */
    uint32 speed_index_21g=6; 
    uint32 total_slots=0;
    unsigned int row=0;
    unsigned int col=0;

    /* To avoid unused warning message with GCC 4.6.x */ 
    row = row;
    col = col; 

    for(index=0;index<10;index++) {
        kt2_tdm_mxqblock_ports_used[index]=0;
    }
    switch(tdm_freq) {
    case 80:  tdm_freq_index=0;
              row=4;
              col=4;
              break;
    case 120: tdm_freq_index=1;
              row=4;
              col=5;
              break;
    case 155: tdm_freq_index=2;
              row=12;
              col=7;
              break;
    case 185: if (total_tdm_slots == 80 ) {
                  row=16;
                  col=5;
                  tdm_freq_index=3; 
              } else {
                  tdm_freq_index=4; 
                  row=18;
                  col=5;
              }
              reserved_flag=1;
              break;
    default:  soc_cm_debug(DK_ERR,"Unsupported tdm frequency:%d \n",
                           tdm_freq);
              return SOC_E_FAIL;
    }

    for (port=0;port<total_ports;port++) {
         switch(port_speed[port]) {
         case 1000:  kt2_1g_ports_array[kt2_1g_ports]=port+1;
                     kt2_1g_ports++;
                     kt2_1g_ports_mxqflags[kt2_port_to_mxqblock[port]]=1;
                     total_slots += kt2_tdm_cycles_info[tdm_freq_index]
                                    [speed_index_1g].min_tdm_cycles;
                     break;
         case 2000:  kt2_2g_ports_array[kt2_2g_ports]=port+1;
                     kt2_2g_ports++;
                     kt2_2g_ports_mxqflags[kt2_port_to_mxqblock[port]]=1;
                     total_slots += kt2_tdm_cycles_info[tdm_freq_index]
                                    [speed_index_2g].min_tdm_cycles;
                     break;
         case 2500:  kt2_2_5g_ports_array[kt2_2_5g_ports]=port+1;
                     kt2_2_5g_ports++;
                     kt2_2_5g_ports_mxqflags[kt2_port_to_mxqblock[port]]=1;
                     total_slots += kt2_tdm_cycles_info[tdm_freq_index]
                                    [speed_index_2_5g].min_tdm_cycles;
                     break;
         case 10000: kt2_10g_ports_array[kt2_10g_ports]=port+1;kt2_10g_ports++;
                     total_slots += kt2_tdm_cycles_info[tdm_freq_index]
                                    [speed_index_10g].min_tdm_cycles;
                     break;
         case 13000: kt2_13g_ports_array[kt2_13g_ports]=port+1;kt2_13g_ports++;
                     total_slots += kt2_tdm_cycles_info[tdm_freq_index]
                                    [speed_index_13g].min_tdm_cycles;
                     break;
         case 20000:
         case 21000: kt2_21g_ports_array[kt2_21g_ports]=port+1;kt2_21g_ports++;
                     total_slots += kt2_tdm_cycles_info[tdm_freq_index]
                                    [speed_index_21g].min_tdm_cycles;
                     break;
         case 0    : continue;
         default   : soc_cm_debug(DK_ERR,
                                "Unsupported speed%d\n",port_speed[port]);
                     return SOC_E_FAIL;
         }     
         kt2_tdm_mxqblock_ports_used[kt2_port_to_mxqblock[port]]++;
    }
    /*
     * Multiply each base speed by 10 and then divide the total
     * bandwidth by 10 in order to avoid floating point (2.5G).
     */
    total_bw = (10 * kt2_1g_ports + 
                20 * kt2_2g_ports +
                25 * kt2_2_5g_ports +
                100 * kt2_10g_ports +
                130 * kt2_13g_ports +
                210 * kt2_21g_ports) / 10;
    if (total_bw > 92) {
        soc_cm_debug(DK_ERR,"Exceeded max bw:92 %d \n",total_bw);
        return SOC_E_FAIL;
    }
    speed_index=speed_index_2_5g;
    lpbk_min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                        min_tdm_cycles;
    speed_index=speed_index_2g;
    cmic_min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                        min_tdm_cycles;
    if (total_slots > (total_tdm_slots -
                       lpbk_min_tdm_cycles - cmic_min_tdm_cycles)) {
        soc_cm_debug(DK_ERR,"Exceeded max slots:%d %d \n",
                     (total_tdm_slots-
                      lpbk_min_tdm_cycles-cmic_min_tdm_cycles),total_slots);
        return SOC_E_FAIL;
    }

    sal_strcpy(tdm_config_string,"");
    if(kt2_21g_ports) {
       sal_sprintf(temp_string," %d*21HG ",kt2_21g_ports);
       sal_sprintf(tdm_config_string,"%s%s",tdm_config_string,temp_string);
    }
    if(kt2_13g_ports) {
       sal_sprintf(temp_string,"  %d*13HG ",kt2_13g_ports);
       sal_sprintf(tdm_config_string,"%s%s",tdm_config_string,temp_string);
    }
    if(kt2_10g_ports) {
       sal_sprintf(temp_string,"  %d*10HG ",kt2_10g_ports);
       sal_sprintf(tdm_config_string,"%s%s",tdm_config_string,temp_string);
    }
    if(kt2_2_5g_ports) {
       sal_sprintf(temp_string,"  %d*2.5G ",kt2_2_5g_ports);
       sal_sprintf(tdm_config_string,"%s%s",tdm_config_string,temp_string);
    }
    if(kt2_2g_ports) {
       sal_sprintf(temp_string,"  %d*2G ",kt2_2g_ports);
       sal_sprintf(tdm_config_string,"%s%s",tdm_config_string,temp_string);
    }
    if(kt2_1g_ports) {
       sal_sprintf(temp_string,"  %d*1G ",kt2_1g_ports);
       sal_sprintf(tdm_config_string,"%s%s",tdm_config_string,temp_string);
    }
    sal_sprintf(temp_string,"TotalBw=%d",total_bw);
    sal_sprintf(tdm_config_string,"%s%s",tdm_config_string,temp_string);
                              
    /* soc_cm_debug(DK_ERR,"Total BW:%d \n",total_bw); */
    for(pos=0;pos<total_tdm_slots;pos++) {
        tdm[pos]=KT2_IDLE;
        kt2_tdm_position_mxq_mask[pos]=0;
    }
    /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    /* 1. First fill-up 10G ports */ 
    speed_index=speed_index_10g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;

    count=0;
    /* MAX 4 (2HG*2) 10G ports can be filled-up over here */
    for(index=kt2_21g_ports;index<2;index++) {
        for(index1=0;index1<2 && count<kt2_10g_ports;index1++,count++) {
            if (reserved_flag == 1) {
                /* 5=(9+1)/2 */
                pos = kt2_21g_reserved_position[index] + col*index1;
            } else {
                pos = optimal_pos= 0;
            }
            kt2_fill_pos(tdm, total_tdm_slots, 
                         pos,  kt2_10g_ports_array[index],10000,min_tdm_cycles,
                         worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
            /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
        }
    }
    /* MAX 2 10G ports can be filled-up over here */
    for(index1=0;count<kt2_10g_ports;index1++,count++) {
        if (reserved_flag == 1) {
            if (index1 == 2) {
                break;
            }
            pos = kt2_10g_reserved_position[index1] ;
        } else {
            pos = optimal_pos = 0;
        }
        kt2_fill_pos(tdm, total_tdm_slots, pos,  
                     kt2_10g_ports_array[count],10000,min_tdm_cycles,
                     worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
        /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    }
    /* 10G ports can still be used(2 more) if 13G ports are not used !! */
    if (count < kt2_10g_ports) {
        if (kt2_13g_ports != 0) {
            soc_cm_debug(DK_ERR,"13G ports being used.."
                                "max 10G port can be 6 only\n");
            return SOC_E_FAIL;
        }
        for(index1=0; index1<2 && count<kt2_10g_ports; index1++,count++) {
             if (reserved_flag == 1) {
                 pos = kt2_13g_reserved_position[0] + col*index1;/*5=(9+1)/2*/
             } else {
                 pos = 0;
             }
             kt2_fill_pos(tdm, total_tdm_slots, pos,  
                          kt2_10g_ports_array[count],10000,min_tdm_cycles,
                          worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
             /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
        }
    }
    speed_index=speed_index_21g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;

    /* 2. Fill-up 21,20G ports now */ 
    for(index=0;index<kt2_21g_ports;index++) {
        if (reserved_flag == 1) {
            pos = kt2_21g_reserved_position[index] ;
        } else {
            pos = 0;
        }
        kt2_fill_pos(tdm, total_tdm_slots, pos,  
                     kt2_21g_ports_array[index],21000,min_tdm_cycles,
                     worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
        /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    }
    speed_index=speed_index_13g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;

    /* 3. Fill-up 13G ports now */ 
    for(index=0;index<kt2_13g_ports;index++) {
        if (reserved_flag == 1) {
        switch(index) {
        case 0:
        case 1: pos = kt2_13g_reserved_position[index] ; break;
        case 2:
        case 3: if (tdm[kt2_21g_reserved_position[0]] == KT2_IDLE) {
                    pos = kt2_21g_reserved_position[0] ; break;
                }
                if (tdm[kt2_10g_reserved_position[0]] == KT2_IDLE) {
                    pos = kt2_10g_reserved_position[0] ; break;
                }
                soc_cm_debug(DK_ERR,
                             "21G  and 10G ports Slots are not free :%d \n",
                             index);
                return SOC_E_FAIL;
        }
        } else {
            pos = 0;
        }
        kt2_fill_pos(tdm, total_tdm_slots, pos,  
                     kt2_13g_ports_array[index],13000,min_tdm_cycles,
                     worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
        /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    }
    /* 3. Fill-up Loopback ports now */ 
    speed_index=speed_index_2_5g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;

    kt2_fill_pos(tdm, total_tdm_slots, -1,  KT2_LPBK_PORT,2500, min_tdm_cycles,
                 worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
    /* 4. Fill-up CMIC ports now */ 
    speed_index=speed_index_2g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;
    /* min_tdm_slot_spacing=optimal_tdm_slot_spacing-(worse_tdm_slot_spacing);*/
    pos = 0;
    while (tdm[pos] != KT2_LPBK_PORT) {
           pos++;
    }
    pos = pos + 3 + 1; /* Minimum 3 spacing */
    while (tdm[pos] != KT2_IDLE) {
           pos++;
    }
    tdm[pos] = KT2_CMIC_PORT;
    /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    kt2_fill_pos(tdm, total_tdm_slots, pos+optimal_tdm_slot_spacing+1,  
                 KT2_CMIC_PORT,2000, min_tdm_cycles-1,
                 worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
    /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */

    /* 5. Fill-up remaining 2.5G ports now */ 

    /* 5.1 First Re-arrange 2.5g ports */
    port = kt2_2_5g_ports_array[0];
    for (index=1;index < kt2_2_5g_ports;index++) {
         mxqblock = kt2_port_to_mxqblock[port-1];
         next_mxqblock=mxqblock;
         do {
             next_mxqblock=(next_mxqblock+1)%10;
             if (kt2_2_5g_ports_mxqflags[next_mxqblock] == 1) {
                 break;
             }
         }while (next_mxqblock != mxqblock);
         /* Swap entry with next mxqblock */
         index1=index;
         do {
             port = kt2_2_5g_ports_array[index1];
             if ( kt2_port_to_mxqblock[port-1] == next_mxqblock) {
                  break;
             }
             index1=(index1+1)%kt2_2_5g_ports;
         } while ( index1 != index);
         temp = kt2_2_5g_ports_array[index1];
         kt2_2_5g_ports_array[index1]= kt2_2_5g_ports_array[index];
         kt2_2_5g_ports_array[index]= temp;
    }

    /* 5.2 Now update tdm for 2.5g ports */
    speed_index=speed_index_2_5g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;

    for(index=0;index<kt2_2_5g_ports;index++) {
        port = kt2_2_5g_ports_array[index];
        kt2_fill_pos(tdm, total_tdm_slots, -1,  
                     port,2500, min_tdm_cycles,
                     worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
        /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    }

    /* 6. Fill-up 2G ports now */ 

    /* 6.1 Re-arrange 2g ports first */
    port = kt2_2g_ports_array[0];
    for (index=1;index < kt2_2g_ports;index++) {
         mxqblock = kt2_port_to_mxqblock[port-1];
         next_mxqblock=mxqblock;
         do {
             next_mxqblock=(next_mxqblock+1)%10;
             if (kt2_2g_ports_mxqflags[next_mxqblock] == 1) {
                 break;
             }
         }while (next_mxqblock != mxqblock);
         /* Swap entry with next mxqblock */
         index1=index;
         do {
             port = kt2_2g_ports_array[index1];
             if ( kt2_port_to_mxqblock[port-1] == next_mxqblock) {
                  break;
             }
             index1=(index1+1)%kt2_2g_ports;
         } while ( index1 != index);
         temp = kt2_2g_ports_array[index1];
         kt2_2g_ports_array[index1]= kt2_2g_ports_array[index];
         kt2_2g_ports_array[index]= temp;
    }

    /* 6.2 Now update tdm for 2g ports  */
    speed_index=speed_index_2g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;

    for(index=0;index<kt2_2g_ports;index++) {
        port = kt2_2g_ports_array[index];
        kt2_fill_pos(tdm, total_tdm_slots, -1,  
                     port,2000, min_tdm_cycles,
                     worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
        /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    }

    /* Re-arrange 1g ports */
    port = kt2_1g_ports_array[0];
    for (index=1;index < kt2_1g_ports;index++) {
         mxqblock = kt2_port_to_mxqblock[port-1];
         next_mxqblock=mxqblock;
         do {
             next_mxqblock=(next_mxqblock+1)%10;
             if (kt2_1g_ports_mxqflags[next_mxqblock] == 1) {
                 break;
             }
         }while (next_mxqblock != mxqblock);
         /* Swap entry with next mxqblock */
         index1=index;
         do {
             port = kt2_1g_ports_array[index1];
             if ( kt2_port_to_mxqblock[port-1] == next_mxqblock) {
                  break;
             }
             index1=(index1+1)%kt2_1g_ports;
         } while ( index1 != index);
         temp = kt2_1g_ports_array[index1];
         kt2_1g_ports_array[index1]= kt2_1g_ports_array[index];
         kt2_1g_ports_array[index]= temp;
    } 
    speed_index=speed_index_1g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;
    /* 6. Fill-up 1G ports now */ 
    for(index=0;index<kt2_1g_ports;index++) {
        port = kt2_1g_ports_array[index];
        kt2_fill_pos(tdm, total_tdm_slots, 0,  port,1000, min_tdm_cycles,
                     worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
        /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    }
    return SOC_E_NONE;
}



 STATIC soc_error_t
_soc_katana2_mmu_tdm_init(int unit)
{
    uint32 *arr;
    uint32 olp_port_flag=0;
    uint32 offender_port=0;
    soc_error_t retVal=SOC_E_NONE;
    uint32 port=0;
    uint32 outer_index=0;
    uint32 inner_index=0;
    uint32 tdm_index=0;
    uint32  row=18;
    uint32  col=5;


#ifdef UNDER_TESTING
    uint32 bcm56450_test_selection=0;
    uint32 *bcm56450_test_speed[]={kt2_tdm_56450_test_speed0,
                                   kt2_tdm_56450_test_speed1,
                                   kt2_tdm_56450_test_speed2,
                                   kt2_tdm_56450_test_speed3,
                                   kt2_tdm_56450_test_speed4,
                                   kt2_tdm_56450_test_speed5,
                                   kt2_tdm_56450_test_speed6,
                                   kt2_tdm_56450_test_speed7,
                                   kt2_tdm_56450_test_speed8,
                                   kt2_tdm_56450_test_speed9,
                                   kt2_tdm_56450_test_speed10,
                                   kt2_tdm_56450_test_speed11,
                                   kt2_tdm_56450_test_speed12,
                                   kt2_tdm_56450_test_speed13,
                                   kt2_tdm_56450_test_speed14,
                                   kt2_tdm_56450_test_speed15,
                                   kt2_tdm_56450_test_speed16,
                                   kt2_tdm_56450_test_speed17,
                                   kt2_tdm_56450_test_speed18,
                                   kt2_tdm_56450_test_speed19,
                                   };
    uint32  pos=0;
    uint32  index=0;
    uint32  freq=0;


#endif
    int i, tdm_size,tdm_freq, cfg_num;
    iarb_tdm_table_entry_t iarb_tdm;
    lls_port_tdm_entry_t lls_tdm;
    uint32 rval, arr_ele;
    uint16 dev_id;
    uint8 rev_id;
    uint32 port_enable_value=0;

    soc_cm_get_id(unit, &dev_id, &rev_id);
    cfg_num = soc_property_get(unit, spn_BCM5645X_CONFIG,
                               kt2_default_port_config);
    if (cfg_num >= (sizeof(bcm56450_tdm)/sizeof(bcm56450_tdm[0]))) {
        soc_cm_print("Wrong cfg_num:%d exceeding max cfg_num: %d\n",
                     cfg_num, 
                     (int)(sizeof(bcm56450_tdm)/sizeof(bcm56450_tdm[0])));
        return SOC_E_FAIL;
    } 
    
    switch(dev_id) {
    case BCM56450_DEVICE_ID:
    case BCM56452_DEVICE_ID:
    case BCM56454_DEVICE_ID:
    case BCM56455_DEVICE_ID:
    case BCM56456_DEVICE_ID:
    case BCM56457_DEVICE_ID:
    case BCM56458_DEVICE_ID:
         if (((dev_id == BCM56452_DEVICE_ID) || (dev_id == BCM56457_DEVICE_ID)) 
               && (cfg_num != 16)) {
             soc_cm_print("For bcm56452,56457 wrong cfg_num:%d \n",cfg_num);
             return SOC_E_FAIL;
         }
         if (((dev_id == BCM56454_DEVICE_ID) || (dev_id == BCM56458_DEVICE_ID)) 
               && (cfg_num != 25)) {
             soc_cm_print("For bcm56454,56458 wrong cfg_num:%d \n",cfg_num);
             return SOC_E_FAIL;
         }
         if ((dev_id == BCM56455_DEVICE_ID) &&
             (cfg_num != 27)) {
             soc_cm_print("For bcm56455 wrong cfg_num:%d \n",cfg_num);
             return SOC_E_FAIL;
         }
         if (((dev_id == BCM56450_DEVICE_ID) || (dev_id == BCM56456_DEVICE_ID)) 
               && (cfg_num > 15)) {
             soc_cm_print("For bcm56450 wrong cfg_num:%d exceeded 15 \n",
                          cfg_num);
             return SOC_E_FAIL;
         }
         tdm_size= bcm56450_tdm_info[cfg_num].tdm_size;
         tdm_freq= bcm56450_tdm_info[cfg_num].tdm_freq;
         row= bcm56450_tdm_info[cfg_num].row;
         col= bcm56450_tdm_info[cfg_num].col;
         soc_cm_print("Cfg=%d freq=%d size=%d raw=%d col=%d\n",
                       cfg_num,tdm_freq,tdm_size,row,col);
         arr = bcm56450_tdm[cfg_num];
         switch(cfg_num) { /* Will be later changed to switch(cfg_num) */
         case 1:/* kt2_tdm_56450A_1 */
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0],sizeof(kt2_tdm_56450A_ref));
                kt2_tdm_replace(arr,88,KT2_OLP_PORT,KT2_IDLE,0);
                kt2_tdm_replace(arr,tdm_size,33,25,0);
                kt2_tdm_replace(arr,tdm_size,30,26,0);
                olp_port_flag=0;
                break;
         case 2:/* kt2_tdm_56450A_2 */
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0], sizeof(kt2_tdm_56450A_ref));
                kt2_tdm_replace(arr,88,33,25,0);
                kt2_tdm_replace(arr,88,30,26,0);
                olp_port_flag=1;
                break;
         case 3:/* kt2_tdm_56450A_3 */
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0],sizeof(kt2_tdm_56450A_ref));
                kt2_tdm_replace(arr,88,33,25,0);
                olp_port_flag=1;
                break;
         case 4:/* kt2_tdm_56450A_4 */
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0], sizeof(kt2_tdm_56450A_ref));
                olp_port_flag=1;
                break;
#if 0
         case 16:/* kt2_tdm_56450A_16 */
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0], sizeof(kt2_tdm_56450A_ref));
                kt2_tdm_replace(arr,88,30,KT2_IDLE,0);
                kt2_tdm_replace(arr,88,33,KT2_IDLE,0);
                olp_port_flag=1;
                break;
         case 17:/* kt2_tdm_56450A_17 */
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0], sizeof(kt2_tdm_56450A_ref));
                olp_port_flag=1;
                break;
         case 20:/* kt2_tdm_56450DA_20 */
                sal_memcpy(arr,
                           &kt2_tdm_56450D_ref[0], sizeof(kt2_tdm_56450D_ref));
                break;
#endif
         case 5:/* kt2_tdm_56450A_5 */
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0], sizeof(kt2_tdm_56450A_ref));
                kt2_tdm_swap(arr,88,9,17);
                kt2_tdm_replace(arr,88,17,26,0);
                kt2_tdm_replace(arr,88,21,39,0);
                olp_port_flag=1;
                break;
         case 6:/*  kt2_tdm_56450A_6 */
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0], sizeof(kt2_tdm_56450A_ref));
#if 0
                kt2_tdm_replace(arr,88,28,36,0);
                kt2_tdm_replace(arr,88,27,28,0);
                kt2_tdm_replace(arr,88,9,27,0);
                kt2_tdm_replace(arr,88,33,25,0);
                kt2_tdm_replace(arr,88,30,26,0);
                kt2_tdm_replace(arr,88,13,39,0);
                kt2_tdm_replace(arr,88,17,33,0);
                kt2_tdm_replace(arr,88,21,30,0);
#else
                kt2_tdm_swap(arr,88,21,33);
                kt2_tdm_swap(arr,88,21,28);
                kt2_tdm_replace(arr,88,9,25,0);
                kt2_tdm_replace(arr,88,17,36,0);
                kt2_tdm_replace(arr,88,13,26,0);
                kt2_tdm_replace(arr,88,21,39,0);
#endif
                olp_port_flag=1;
                break;
         case 7:/* kt2_tdm_56450A_7 */
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0], sizeof(kt2_tdm_56450A_ref));
                kt2_tdm_swap(arr,88,9,17);
                kt2_tdm_replace(arr,88,13,25,0);
                kt2_tdm_replace(arr,88,17,26,0);
                kt2_tdm_replace(arr,88,21,39,0);


                kt2_tdm_replace(arr,88,1,KT2_IDLE,0);
                kt2_tdm_replace(arr,88,5,KT2_IDLE,0);
                kt2_tdm_replace(arr,88,9,KT2_IDLE,0);
                tdm_index=0;
                for (outer_index=1;outer_index<=4;outer_index++) {
                     for (inner_index=0;inner_index < 6;inner_index++) {
                          port = outer_index + inner_index*4;
                          while(arr[tdm_index] != KT2_IDLE) {
                                tdm_index++;
                          }
                          arr[tdm_index]=port;
                     }
                }
                olp_port_flag=1;
                break;
         case 8:/* kt2_tdm_56450A1_8 */
                sal_memcpy(arr,
                           &kt2_tdm_56450A1_ref[0], 
                           sizeof(kt2_tdm_56450A1_ref));
                olp_port_flag=1;
                break;
         case 9:/* kt2_tdm_56450A1_9 */
                sal_memcpy(arr,
                           &kt2_tdm_56450A1_ref[0],
                           sizeof(kt2_tdm_56450A1_ref));
                kt2_tdm_replace(arr,108,9,KT2_IDLE,0);
                kt2_tdm_replace(arr,108,13,KT2_IDLE,0);
                for(port=1;port<=8;port++) {
                    kt2_tdm_replace(arr,108,port,KT2_IDLE,0);
                }
                tdm_index=0;
                for (outer_index=1;outer_index<=4;outer_index++) {
                     for (inner_index=0;inner_index < 6;inner_index++) {
                          port = outer_index + inner_index*4;/* 1,5,9,13,17,21
                                                                2,6,10,14,18,22,
                                                                3,7,11,15,19,23,
                                                                4,8,12,16,20,24
                                                              */
                          while(arr[tdm_index] != KT2_IDLE) {
                                 tdm_index++;
                          }
                          arr[tdm_index]=port;
                     }
                }
                olp_port_flag=1;
                break;
#if 0
         case 18:/* kt2_tdm_56450A1_18 */
                sal_memcpy(arr,
                           &kt2_tdm_56450A1_ref[0], sizeof(kt2_tdm_56450A1_ref));
                kt2_tdm_replace(arr,108,9,KT2_IDLE,0);
                kt2_tdm_replace(arr,108,13,KT2_IDLE,0);
                for(port=1;port<=8;port++) {
                    kt2_tdm_replace(arr,108,port,KT2_IDLE,0);
                }
                tdm_index=0;
                for (outer_index=1;outer_index<=4;outer_index++) {
                     for (inner_index=0;inner_index < 6;inner_index++) {
                          port = outer_index + inner_index*4;/* 1,5,9,13,17,21
                                                                2,6,10,14,18,22,
                                                                3,7,11,15,19,23,
                                                                4,8,12,16,20,24
                                                              */
                          while(arr[tdm_index] != KT2_IDLE) {
                                 tdm_index++;
                          }
                          arr[tdm_index]=port;
                     }
                }
                olp_port_flag=1;
                break;
#endif
         case 10: /* kt2_tdm_56450A2_10 */
                  sal_memcpy(arr,
                             &kt2_tdm_56450A2_ref[0],
                             sizeof(kt2_tdm_56450A2_ref));
                  kt2_tdm_replace(arr,99,KT2_OLP_PORT,KT2_IDLE,0);
                  olp_port_flag=0;
                  break;
         case 11: /* kt2_tdm_56450A2_11 */
                  sal_memcpy(arr,
                            &kt2_tdm_56450A2_ref[0],
                            sizeof(kt2_tdm_56450A2_ref));
                  olp_port_flag=1;
                  break;
         case 12: /* kt2_tdm_56450A2_12 */
                  sal_memcpy(arr,
                             &kt2_tdm_56450A2_ref[0],
                             sizeof(kt2_tdm_56450A2_ref));
                  kt2_tdm_replace(arr,99,26,28,0);
                  olp_port_flag=1;
                  break;
         case 13: /* kt2_tdm_56450A2_13 */
                  sal_memcpy(arr,
                             &kt2_tdm_56450A2_ref[0],
                             sizeof(kt2_tdm_56450A2_ref));
                  kt2_tdm_replace(arr,99,26,28,0);
                  kt2_tdm_replace(arr,99,25,27,0);
                  olp_port_flag=1;
                  break;
         case 14: /* kt2_tdm_56450A2_14 */
                  sal_memcpy(arr,
                             &kt2_tdm_56450A2_ref[0],
                             sizeof(kt2_tdm_56450A2_ref));
                  kt2_tdm_replace(arr,99,21,KT2_IDLE,0);
                  kt2_tdm_replace(arr,99,17,KT2_IDLE,0);
                  olp_port_flag=1;
                  break;
         case 15: /* kt2_tdm_56450A2_15 */
                  memcpy(arr,
                         &kt2_tdm_56450A2_ref[0],
                         sizeof(kt2_tdm_56450A2_ref));
                  kt2_tdm_replace(arr,99,21,KT2_IDLE,0);
                  kt2_tdm_replace(arr,99,17,KT2_IDLE,0);
                  kt2_tdm_replace(arr,99,9,KT2_IDLE,0);
                  kt2_tdm_replace(arr,99,13,17,0);
                  for(port=1;port<=8;port++) {
                      kt2_tdm_replace(arr,99,port,KT2_IDLE,0);
                  }
                  tdm_index=0;
                  for (outer_index=1;outer_index<=4;outer_index++) {
                       for (inner_index=0;inner_index < 4;inner_index++) {
                            port = outer_index + inner_index*4;
                            while(arr[tdm_index] != KT2_IDLE) {
                                  tdm_index++;
                            }
                            arr[tdm_index]=port;
                       }
                  }
                  olp_port_flag=1;
                  break;
#if 0
         case 19:/* kt2_tdm_56450AA_19 */
                sal_memcpy(arr,
                          &kt2_tdm_56450AA_ref[0], sizeof(kt2_tdm_56450AA_ref));
                olp_port_flag=0;
                break;
#endif
         case 0:/* kt2_tdm_56450AA_19 */
                sal_memcpy(arr,
                          &kt2_tdm_56450AA_ref[0], sizeof(kt2_tdm_56450AA_ref));
                olp_port_flag=0;
                break;
         case 25:
                sal_memcpy(arr,
                          &kt2_tdm_56454D_ref[0], sizeof(kt2_tdm_56454D_ref));
                kt2_tdm_replace(arr,20,2,1,1);
                kt2_tdm_replace(arr,20,3,1,1);
                kt2_tdm_replace(arr,20,4,1,1);
                kt2_tdm_replace(arr,20,6,5,1);
                kt2_tdm_replace(arr,20,7,5,1);
                kt2_tdm_replace(arr,20,8,5,1);
                olp_port_flag=0;
                break;
         case 16:
         case 27:
                sal_memcpy(arr,
                          &kt2_tdm_56455C_ref[0], sizeof(kt2_tdm_56455C_ref));
                olp_port_flag=0;
                break;
         default: olp_port_flag=0;
                  break;
         }
         kt2_tdm_display(unit,arr, tdm_size,  row,  col);
         /* speed = bcm56450_speed[cfg_num]; */
         retVal=kt2_tdm_verify(bcm56450_tdm[cfg_num],tdm_size,tdm_freq,
                               bcm56450_speed[cfg_num],
                               olp_port_flag,&offender_port);  
         if ((retVal == SOC_E_CONFIG) && (offender_port == KT2_IDLE)) {
              soc_cm_debug(DK_WARN,
                 "#Ignoring KT2:TDM IDLE Slot verification failure time-being\n"
                 "Issue has already been addressed but under testing\n");
              retVal=SOC_E_NONE;
         } 
         SOC_IF_ERROR_RETURN(retVal);
         /* ######################## */
         /* Just for testing purpose */
         /* ######################## */
#ifdef UNDER_TESTING
         for(bcm56450_test_selection=0;
             bcm56450_test_selection < sizeof(bcm56450_test_speed)/
                                       sizeof(bcm56450_test_speed[0]);
             bcm56450_test_selection++) {
             if ((bcm56450_test_selection >=0) &&
                 (bcm56450_test_selection <=10)) {
                 pos = 90; row = 18; col = 5;freq=185;
             }
             if ((bcm56450_test_selection >=11) &&
                 (bcm56450_test_selection <=13)) {
                 pos = 80; row = 16; col = 5;freq=185;
             }
             if ((bcm56450_test_selection >=14) &&
                 (bcm56450_test_selection <=16)) {
                 pos = 84; row = 12; col = 7;freq=155;
             }
             if ((bcm56450_test_selection >=17) &&
                 (bcm56450_test_selection <=18)) {
                 pos = 20; row = 4; col = 5;freq=120;
             }
             if ((bcm56450_test_selection >=19) &&
                 (bcm56450_test_selection <=19)) {
                 pos = 16; row = 4; col = 4;freq=80;
             }
             soc_cm_debug(DK_WARN,"\n###############\n");
             SOC_IF_ERROR_RETURN(kt2_tdm_generate(
                                 bcm56450_test_speed[bcm56450_test_selection],
                                 40,freq,pos,
                                 kt2_tdm_under_testing,tdm_config_string));
             retVal = kt2_tdm_verify(
                                 kt2_tdm_under_testing,pos,freq, 
                                 bcm56450_test_speed[bcm56450_test_selection],
                                 olp_port_flag,&offender_port);
             for(index=0;index<180;index++) {
                  kt2_tdm_under_testing_idle[index]=KT2_IDLE;
             }
             sal_memcpy(kt2_tdm_under_testing_idle,kt2_tdm_under_testing,
                        sizeof(uint32)*pos);
             if ((retVal == SOC_E_CONFIG) && (offender_port == KT2_IDLE)) {
                 do {
                    switch(offender_port) {
                    case KT2_IDLE:
                         if (kt2_tdm_under_testing_idle[pos-1] == KT2_IDLE) {
                             pos++;
                         } else {
                             pos+=2;
                         }
                         break;
                    default:kt2_tdm_under_testing_idle[pos-2]=offender_port;
                            pos++;
                            break; 
                    }
                    if (pos == 180) {
                        break;
                    }
                    retVal = kt2_tdm_verify(
                                 kt2_tdm_under_testing_idle,pos, freq, 
                                 bcm56450_test_speed[bcm56450_test_selection],
                                 olp_port_flag,&offender_port);
                  }while(retVal == SOC_E_CONFIG);
             } 
             SOC_IF_ERROR_RETURN(retVal);
             soc_cm_debug(DK_WARN,"Configuration:%d:(freq:%d Cycles:%d) %s",
                                  bcm56450_test_selection,freq,pos,
                                  tdm_config_string);
             kt2_tdm_display(unit,kt2_tdm_under_testing_idle,pos,row,col);
             soc_cm_debug(DK_WARN,"###############\n");
         } 
#endif
         break; 
    default:
        return SOC_E_FAIL;
    }

    /* Disable IARB TDM before programming... */
    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 1);
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, TDM_WRAP_PTRf,
                      tdm_size -1);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));

    for (i = 0; i < tdm_size; i++) {
        arr_ele = arr[i];
        if (arr_ele <= 41) { /* Non Idle Slots */
            port_enable_value = 1;
        } else {
            port_enable_value = 0;
        }

        sal_memset(&iarb_tdm, 0, sizeof(iarb_tdm_table_entry_t));
        soc_IARB_TDM_TABLEm_field32_set(unit, &iarb_tdm, PORT_NUMf,
                                        arr_ele);
        SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_TABLEm(unit, SOC_BLOCK_ALL, i, 
                                                  &iarb_tdm));

        if (0 == (i%2)) {
            /* Two entries per mem entry */
            sal_memset(&lls_tdm, 0, sizeof(lls_port_tdm_entry_t));
            soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm, PORT_ID_0f, arr_ele);
            soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm, 
                                          PORT_ID_0_ENABLEf, port_enable_value);
        } else {
            soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm, PORT_ID_1f, arr_ele);
            soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm, 
                                          PORT_ID_1_ENABLEf, port_enable_value);
            SOC_IF_ERROR_RETURN(WRITE_LLS_PORT_TDMm(unit, SOC_BLOCK_ALL, (i/2),
                                                      &lls_tdm));
            SOC_IF_ERROR_RETURN(WRITE_LLS_PORT_TDMm(unit, SOC_BLOCK_ALL, 128+(i/2),
                                                      &lls_tdm));
        }
    }
    if (tdm_size % 2) {
        soc_cm_print("Info:Odd TDM Size%d \n",tdm_size);
        SOC_IF_ERROR_RETURN(WRITE_LLS_PORT_TDMm(unit, SOC_BLOCK_ALL, (i/2),
                                                &lls_tdm));
        SOC_IF_ERROR_RETURN(WRITE_LLS_PORT_TDMm(unit, SOC_BLOCK_ALL, 128+(i/2),
                                                &lls_tdm));
    }
    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 0);
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, TDM_WRAP_PTRf,
                      tdm_size -1);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));

    
    rval = 0;
    soc_reg_field_set(unit, LLS_TDM_CAL_CFGr, &rval, END_Af, tdm_size - 1);
    soc_reg_field_set(unit, LLS_TDM_CAL_CFGr, &rval, END_Bf, tdm_size - 1);
    soc_reg_field_set(unit, LLS_TDM_CAL_CFGr, &rval, ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_LLS_TDM_CAL_CFGr(unit, rval));
    soc_katana2_save_tdm_pos(unit, tdm_size,arr);
    mxqspeeds[unit][6][0]= bcm56450_speed[cfg_num][25-1];
    mxqspeeds[unit][7][0]= bcm56450_speed[cfg_num][26-1];
    mxqspeeds[unit][8][0]= bcm56450_speed[cfg_num][27-1];
    mxqspeeds[unit][9][0]= bcm56450_speed[cfg_num][28-1];
    switch(mxqspeeds[unit][8][0]) {
    case 21000: 
        mxqspeeds[unit][8][1]= 10000;
        mxqspeeds[unit][8][3]= 2500;
        break;
    case 13000: 
        mxqspeeds[unit][8][1]= 2500;
        mxqspeeds[unit][8][3]= 2500;
        break;
    case 10000:
        if (bcm56450_speed[cfg_num][33-1] == 10000) {
            /* We can handle but doubt about TDM mxqspeeds[8][0]= 21000; */
            mxqspeeds[unit][8][1]= 10000;
            mxqspeeds[unit][8][3]= 2500;
        } else {
            mxqspeeds[unit][8][1]= 2500;
            mxqspeeds[unit][8][3]= 2500;
        } 
        break;
    }
    switch(mxqspeeds[unit][9][0]) {
    case 21000: 
        mxqspeeds[unit][9][1]= 10000;
        mxqspeeds[unit][9][3]= 2500;
        break;
    case 13000: 
        mxqspeeds[unit][9][1]= 2500;
        mxqspeeds[unit][9][3]= 2500;
        break;
    case 10000:
        if (bcm56450_speed[cfg_num][30-1] == 10000) {
            /* We can handle but doubt about TDM mxqspeeds[9][0]= 21000; */
            mxqspeeds[unit][9][1]= 10000;
            mxqspeeds[unit][9][3]= 2500;
        } else {
            mxqspeeds[unit][9][1]= 2500;
            mxqspeeds[unit][9][3]= 2500;
        } 
        break;
    }
    return SOC_E_NONE;
}
soc_error_t 
soc_katana2_port_enable_set(int unit, soc_port_t port, int enable)
{
   soc_field_t port_enable_field[KT2_MAX_MXQPORTS_PER_BLOCK]=
                {PORT0f, PORT1f, PORT2f , PORT3f};
   uint32 rval ;
   uint8 mxqblock ;
   uint8 loop ;
   uint32 entry[SOC_MAX_MEM_WORDS];
   soc_info_t *si= &SOC_INFO(unit);
   uint32 lp_enable = 0, port_enable = 0;
   uint32 regval=0;

   SOC_IF_ERROR_RETURN(soc_katana2_get_port_mxqblock(unit,port,&mxqblock));
   if (!SOC_PBMP_MEMBER((PBMP_ALL(unit)), port)) {
       return SOC_E_PORT; 
   }
   for(loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK; loop++) {
       if (kt2_mxqblock_ports[mxqblock][loop] == port) {
           break;
       } 
   }
   if (loop == KT2_MAX_MXQPORTS_PER_BLOCK) {
       return SOC_E_PORT; 
   }
   if (SOC_REG_PORT_VALID(unit, TXLP_PORT_ENABLEr, port)) {
       SOC_IF_ERROR_RETURN(READ_TXLP_PORT_ENABLEr(unit, port, &regval));
       port_enable = soc_reg_field_get(unit, TXLP_PORT_ENABLEr, 
                                       regval, PORT_ENABLEf);
       port_enable |= (1 << loop);
       soc_reg_field_set(unit, TXLP_PORT_ENABLEr, &regval, 
                         PORT_ENABLEf,port_enable);
       if (SOC_PBMP_MEMBER(si->linkphy_pbm, port)) {
           lp_enable = soc_reg_field_get(unit, TXLP_PORT_ENABLEr, 
                             regval, LP_ENABLEf);
           lp_enable |= (1 << loop);
           soc_reg_field_set(unit, TXLP_PORT_ENABLEr, &regval, 
                             LP_ENABLEf,lp_enable);
       }
       soc_cm_debug(DK_VERBOSE,"TXLP port_enable=%d lp_enable=%d\n",
                    port_enable,lp_enable);
       SOC_IF_ERROR_RETURN(WRITE_TXLP_PORT_ENABLEr(unit, port, regval));
   }
   if (SOC_REG_PORT_VALID(unit, RXLP_PORT_ENABLEr, port)) {
       SOC_IF_ERROR_RETURN(READ_RXLP_PORT_ENABLEr(unit, port, &regval));
       if (SOC_PBMP_MEMBER(si->linkphy_pbm, port)) {
           lp_enable = soc_reg_field_get(unit, RXLP_PORT_ENABLEr, 
                             regval, LP_ENABLEf);
           lp_enable |= (1 << loop);
           soc_reg_field_set(unit, RXLP_PORT_ENABLEr, &regval, 
                             LP_ENABLEf,lp_enable);
       }
       soc_cm_debug(DK_VERBOSE,"RXLP lp_enable=%d\n",lp_enable);
       SOC_IF_ERROR_RETURN(WRITE_RXLP_PORT_ENABLEr(unit, port, regval));
   }
   sal_memset(entry, 0, sizeof(egr_enable_entry_t));
   SOC_IF_ERROR_RETURN(READ_XPORT_PORT_ENABLEr(unit, port, &rval));
   if ((port == KT2_OLP_PORT) && (si->olp_port == 1) ) {
        
        loop = 0; /* Port 0 Field */
   }
   if (enable) {
       soc_reg_field_set(unit, XPORT_PORT_ENABLEr, &rval,
                         port_enable_field[loop], 1); /* Enable port */
       soc_mem_field32_set(unit, EGR_ENABLEm, entry, PRT_ENABLEf, 1);
       SOC_IF_ERROR_RETURN(WRITE_XPORT_PORT_ENABLEr(unit, port, rval));
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, port, entry));

   } else {
       soc_reg_field_set(unit, XPORT_PORT_ENABLEr, &rval,
                         port_enable_field[loop], 0); /* Disable port */
       soc_mem_field32_set(unit, EGR_ENABLEm, entry, PRT_ENABLEf, 0);
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, port, entry));
       SOC_IF_ERROR_RETURN(WRITE_XPORT_PORT_ENABLEr(unit, port, rval));
   }

   return SOC_E_NONE;
}
void soc_katana2_mxqblock_reset(int unit, uint8 mxqblock,int active_low)
{
    uint32 rval;
    soc_field_t hot_swap_reset_fld[]={
                TOP_MXQ0_HOTSWAP_RST_Lf,TOP_MXQ1_HOTSWAP_RST_Lf,
                TOP_MXQ2_HOTSWAP_RST_Lf,TOP_MXQ3_HOTSWAP_RST_Lf,
                TOP_MXQ4_HOTSWAP_RST_Lf,TOP_MXQ5_HOTSWAP_RST_Lf,
                TOP_MXQ6_HOTSWAP_RST_Lf,TOP_MXQ7_HOTSWAP_RST_Lf,
                TOP_MXQ8_HOTSWAP_RST_Lf,TOP_MXQ9_HOTSWAP_RST_Lf};

    if (READ_TOP_SOFT_RESET_REGr(unit, &rval) != SOC_E_NONE) {
        soc_cm_print("ATTN: Reading TOP_SOFT_RESET_REG failed \n");
        return;
    }
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, 
                      hot_swap_reset_fld[mxqblock],active_low);
    WRITE_TOP_SOFT_RESET_REGr(unit, rval);

}
soc_error_t 
soc_katana2_reconfigure_tdm(int unit,uint32 new_tdm_size,uint32 *new_tdm)
{
    uint8                new_tdm_no=0;
    soc_mem_t            tdm_table[]={IARB_TDM_TABLEm , IARB_TDM_TABLE_1m};
    soc_field_t          wrap_ptr[]={TDM_WRAP_PTRf , TDM_1_WRAP_PTRf};
    /* 
    lls_port_tdm_entry_t   lls_tdm[128]={{{0}}};
    iarb_tdm_table_entry_t iarb_tdm[256]={{{0}}};
    */
    uint32                 lls_tdm_size=0;
    lls_port_tdm_entry_t   *lls_tdm=NULL;
    uint32                 iarb_size=0;
    iarb_tdm_table_entry_t *iarb_tdm=NULL;
    int                  cfg_num=0; 
    int                  iter=0; 

    uint8                index;
    uint32               rval;

    if (new_tdm_size > 108) {
        return SOC_E_PARAM;
    }
    /*
    if (sal_memcmp(&kt2_current_tdm[0],&new_tdm[0],
                   sizeof(kt2_current_tdm[0])) == 0) {
        return SOC_E_NONE;
    }
    */
    cfg_num = soc_property_get(unit, spn_BCM5645X_CONFIG,
                               kt2_default_port_config);
    if (cfg_num >= (sizeof(bcm56450_tdm)/sizeof(bcm56450_tdm[0]))) {
        return SOC_E_FAIL;
    } 

    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    old_tdm_no = soc_reg_field_get(unit, IARB_TDM_CONTROLr, rval, SELECT_TDMf);
    new_tdm_no = (old_tdm_no + 1)%2;

#if 0
    /* Disable IARB TDM before programming... */
    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));
#endif
    iarb_size =  soc_mem_index_count(unit,IARB_TDM_TABLEm) *
                 sizeof(iarb_tdm_table_entry_t);
    iarb_tdm = soc_cm_salloc(unit,iarb_size, "iarb_tdm_table_entry_t");
    if (iarb_tdm == NULL) {
        return SOC_E_MEMORY;
    }
    sal_memset(iarb_tdm,0,iarb_size);
    lls_tdm_size =  soc_mem_index_count(unit,LLS_PORT_TDMm) *
                    sizeof(lls_port_tdm_entry_t);
    lls_tdm = soc_cm_salloc(unit,lls_tdm_size, "lls_port_tdm_entry_t");
    if (lls_tdm == NULL) {
        soc_cm_sfree(unit,iarb_tdm);
        return SOC_E_MEMORY;
    }
    sal_memset(lls_tdm,0,lls_tdm_size);

    for (index = 0; index < new_tdm_size; index++) {
        soc_IARB_TDM_TABLEm_field32_set(unit, &iarb_tdm[index], PORT_NUMf,
                                        new_tdm[index]);
    }
    soc_mem_write_range(unit, tdm_table[new_tdm_no], MEM_BLOCK_ANY, 0,
                        new_tdm_size, iarb_tdm);
    soc_cm_sfree(unit,iarb_tdm);

    for (index = 0; index < new_tdm_size/2; index++) {
         soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index], 
                                       PORT_ID_0f, new_tdm[index*2]);
         if ( new_tdm[index*2] <= 41) {
              soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index], 
                                            PORT_ID_0_ENABLEf, 1);
         } else {
              soc_cm_debug(DK_VERBOSE,"IDLE SLOTs so PORT_ID_0_ENABLEf=0 for index=%d\n",
                           index);
              soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index], 
                                            PORT_ID_0_ENABLEf, 0);
         }
         soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index],     
                                       PORT_ID_1f, new_tdm[(index*2) + 1]);
         if ( new_tdm[(index*2)+1] <= 41) {
              soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index],   
                                            PORT_ID_1_ENABLEf, 1);
         } else {
              soc_cm_debug(DK_VERBOSE,
                           "IDLE SLOTs so PORT_ID_1_ENABLEf=0 for index=%d\n",
                           index);
              soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index],   
                                            PORT_ID_1_ENABLEf, 0);
         }
    }
    if (new_tdm_size % 2) {
        soc_cm_print("ODD TDM SIZE \n");
        soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index*2], 
                                      PORT_ID_0_ENABLEf, 1);
        soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index*2],     
                                      PORT_ID_0f, new_tdm[(index*2)]);
        soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[(index*2)+1], 
                                      PORT_ID_1_ENABLEf, 0);
        soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[(index*2)+1],     
                                      PORT_ID_1f, 0);
        index++;
    }
    soc_mem_write_range(unit, LLS_PORT_TDMm, MEM_BLOCK_ANY,
                        new_tdm_no*128, (new_tdm_no*128) + index, 
                        lls_tdm);
    soc_cm_sfree(unit,lls_tdm);


    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 0);
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, 
                      wrap_ptr[new_tdm_no],new_tdm_size -1);
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, SELECT_TDMf, new_tdm_no);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));
    if (soc_cm_debug_check(DK_VERBOSE)) {
        kt2_tdm_display(unit,new_tdm,new_tdm_size,
                        bcm56450_tdm_info[cfg_num].row,
                        bcm56450_tdm_info[cfg_num].col);
    }
    SOC_IF_ERROR_RETURN(WRITE_LLS_TDM_CAL_CFG_SWITCHr(unit, 1));
    if ((SAL_BOOT_BCMSIM || SAL_BOOT_PLISIM)) {
        SOC_IF_ERROR_RETURN(READ_LLS_TDM_CAL_CFGr(unit, &rval));
        soc_reg_field_set(unit, LLS_TDM_CAL_CFGr, &rval,
                          CURRENT_CALENDARf,new_tdm_no);
        SOC_IF_ERROR_RETURN(WRITE_LLS_TDM_CAL_CFGr(unit, rval));
    }
    do {
        SOC_IF_ERROR_RETURN(READ_LLS_TDM_CAL_CFGr(unit, &rval));
        sal_udelay(100);
        if (soc_reg_field_get(unit, LLS_TDM_CAL_CFGr, rval, 
                              CURRENT_CALENDARf) == new_tdm_no) {
            break;
        }
    } while (iter++ < 100000);
    if (iter >= 100000) {
        soc_cm_debug(DK_ERR, "LLS Calendar switch failed !!\n");
        return SOC_E_INTERNAL;
    }
    old_tdm_no = new_tdm_no;
#if 1
    soc_katana2_save_tdm_pos(unit, new_tdm_size,new_tdm);
#endif

    return SOC_E_NONE;
}
static 
void soc_katana2_save_tdm_pos(int unit, uint8 new_tdm_size,uint32 *new_tdm)
{
    uint8 pos=0;
    uint8 port=0;
    uint8 mxqblock=0;
    uint8 total_slots=0;
    sal_memset(kt2_tdm_pos_info,0,sizeof(kt2_tdm_pos_info));
    for (pos=0;pos < new_tdm_size ; pos++) {
         port= new_tdm[pos];
         if ((port == KT2_IDLE) || (port == KT2_IDLE1) || 
             (port == KT2_LPBK_PORT) || (port == KT2_CMIC_PORT) /* ||
             (port == KT2_OLP_PORT) */) { /* QUICKTURN:ATTN */
              continue;
         }
         mxqblock = kt2_port_to_mxqblock[port-1];
         total_slots = kt2_tdm_pos_info[mxqblock].total_slots;
         kt2_tdm_pos_info[mxqblock].pos[total_slots]=pos;
         kt2_tdm_pos_info[mxqblock].total_slots++;
    }
    sal_memcpy(kt2_current_tdm,new_tdm,new_tdm_size*sizeof(new_tdm[0]));
    old_tdm_no=0;
    kt2_current_tdm_size=new_tdm_size;
}

static soc_error_t 
_soc_katana2_tdm_feasibility_check(int unit, soc_port_t port, int speed,
                                   uint8 *mxqblock, uint8 *sub_port,
                                   uint8 *min_tdm_cycles)
{
    uint8  mxqblock_local=0;
    uint8  sub_port_local=0;
    uint32 speed_index=0;
    soc_field_t wc_xfi_mode_sel_fld[]={WC0_8_XFI_MODE_SELf,WC1_8_XFI_MODE_SELf};
    uint32      wc_8_xfi_mode_sel_val = 0;
    uint32      top_misc_control_1_val = 0;
    if (kt2_tdm_update_flag == 0) {
        return SOC_E_NONE;
    }
    SOC_IF_ERROR_RETURN(soc_katana2_get_port_mxqblock(unit,port,
                                                      &mxqblock_local));
    sub_port_local = kt2_port_to_mxqblock_subports[port-1]; 
    switch(speed) {
    case 1000:  speed_index=0;
                break;
    case 2500:  speed_index=2;
                break;
    case 10000: speed_index=3;
                break;
    case 13000: speed_index=4;
                break;
    case 21000: speed_index=6;
                break;
    default:    soc_cm_print("Check:Invalid Speed:%d \n",speed);
                return SOC_E_CONFIG;
    }
    if (kt2_current_tdm_cycles_info[speed_index].min_tdm_cycles == 0) {
        soc_cm_print("Check:Invalid Minimum TDM Cycles=0 \n");
        return SOC_E_CONFIG;
    }
    if (kt2_tdm_pos_info[mxqblock_local].total_slots == 0) {
        if (((mxqblock_local == 8) || (mxqblock_local == 9)) &&
            ((sub_port_local == 1) || (sub_port_local == 3))) {
             /*Need To Check XFI Mode then */
             SOC_IF_ERROR_RETURN(READ_TOP_MISC_CONTROL_1r(
                                     unit,&top_misc_control_1_val));
             wc_8_xfi_mode_sel_val = soc_reg_field_get(
                                     unit, TOP_MISC_CONTROL_1r,
                                     top_misc_control_1_val,
                                     wc_xfi_mode_sel_fld[mxqblock_local-8]);
             if (wc_8_xfi_mode_sel_val == 0) {
                 soc_cm_print("Check:Total Slots in corresponding"
                              " MXQBlock=%d is zero \n", mxqblock_local);
                 return SOC_E_CONFIG;
             }
             mxqblock_local -= 2;
             sub_port_local  -= 1;
             if (kt2_tdm_pos_info[mxqblock_local].total_slots ==0) {
                 soc_cm_print("Check:Total Slots in corresponding"
                              " MXQBlock=%d is zero \n", mxqblock_local);
                 return SOC_E_CONFIG;
             }
        } else {
            soc_cm_print("Check: Total Slots in corresponding MXQBlock=%d"
                         " is zero \n", mxqblock_local);
            return SOC_E_CONFIG;
        }
    }
    if(mxqblock != NULL) {
       *mxqblock = mxqblock_local;
    }
    if(sub_port != NULL) {
       *sub_port = sub_port_local;
    }
    if(min_tdm_cycles != NULL) {
       *min_tdm_cycles = kt2_current_tdm_cycles_info[speed_index].
                         min_tdm_cycles; 
    }
    return SOC_E_NONE;
}

STATIC int
_soc_katana2_perq_flex_counters_init(int unit)
{
    _soc_katana2_counter_info_t *counter_info;
    uint32 rval;
    int index, seg, i, j;
    soc_reg_t   dtype_reg[] = {
                                CTR_DEQ_DTYPE_TBL0r,
                                CTR_DEQ_DTYPE_TBL1r,
                                CTR_DEQ_DTYPE_TBL2r
                              };
    soc_field_t dtype_field[] = {
                                  DTYPE0f, DTYPE1f, DTYPE2f, 
                                  DTYPE3f, DTYPE4f, DTYPE5f, 
                                  DTYPE6f, DTYPE7f, DTYPE8f, 
                                  DTYPE9f, DTYPE10f, DTYPE11f,
                                  DTYPE12f, DTYPE13f,DTYPE14f,
                                  DTYPE15f
                                };

    /* Setup MMU counter pool segment start address, consider each 1K block
       as separate segment */
    for (i = 0; i < 12; i++) {
        if ((!soc_feature(unit, soc_feature_cosq_gport_stat_ability) &&
            ((i % 4) != 0)) ||
            ((soc_feature(unit, soc_feature_counter_toggled_read) &&
            (i == 8)))) {
            /*
             * Create 3 segments each with 4K counters
             * Seg0(total enq drop pkts) seg_start address 0
             * Seg4(red enq drop pkts)  seg_start address 4 * 1024
             * Seg8(deq stats)) seg_start_address 8 * 1024
             */
            continue;
        }
        rval = 0;
        soc_reg_field_set(unit, CTR_SEGMENT_STARTr, &rval, SEG_STARTf, (i * 1024));
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, CTR_SEGMENT_STARTr,REG_PORT_ANY, i, rval));
    }

    /* Cosq_stats -
     * CTR_FLEX_COUNT_0 = Total ENQ discarded
     * CTR_FLEX_COUNT_4  = Red ENQ discarded
     * CTR_FLEX_COUNT_8  = Total DEQ
     */

    /* Cosq_gport_stats -
     * CTR_FLEX_COUNT_1 = Total ENQ Accepted
     * CTR_FLEX_COUNT_2 = Green ENQ discarded
     * CTR_FLEX_COUNT_3 = Yellow ENQ discarded
     * CTR_FLEX_COUNT_5 = Green ENQ Accepted
     * CTR_FLEX_COUNT_6 = Yellow ENQ Accepted
     * CTR_FLEX_COUNT_7 = Red ENQ Accepted
     */

    counter_info = _soc_katana2_counter_info;

    /* enable deq stats */
    for (i = 0; i < 3; i++) {
        rval = 0; 
        for (j = 0; j < 16; j++) {
            if ((dtype_reg[i] == CTR_DEQ_DTYPE_TBL2r) && (j > 9)) {
                continue;
            }
            soc_reg_field_set(unit, dtype_reg[i], &rval, dtype_field[j], 2);
        }   
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, dtype_reg[i], REG_PORT_ANY, 0, rval));
    }

    /* set deq stats config */
    rval = 0;
    seg = counter_info[_SOC_COUNTER_TYPE_ACCEPT_DEQ].segment;
    if (!soc_feature(unit, soc_feature_cosq_gport_stat_ability) &&
        soc_feature(unit, soc_feature_counter_toggled_read)) {
        seg = counter_info[_SOC_COUNTER_TYPE_ACCEPT_DEQ].segment - 4;
    }
    index = counter_info[_SOC_COUNTER_TYPE_ACCEPT_DEQ].index;
    soc_reg_field_set(unit, CTR_DEQ_STATS_CFGr, &rval, ACTIVE0f, 1);
    soc_reg_field_set(unit, CTR_DEQ_STATS_CFGr, &rval, SEG0f, seg);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, CTR_DEQ_STATS_CFGr, REG_PORT_ANY, index, rval));

    /* set enq stats config */
    for (i = _SOC_COUNTER_TYPE_DROP_ENQ_GREEN;
         i < _SOC_COUNTER_TYPE_ACCEPT_DEQ; i++) {

        if (!soc_feature(unit, soc_feature_cosq_gport_stat_ability) &&
            (i >= _SOC_COUNTER_TYPE_ACCEPT_ENQ_GREEN)) {
            continue;
        }
        rval = 0;
        index = counter_info[i].index;
        if (i < _SOC_COUNTER_TYPE_ACCEPT_ENQ_GREEN) {
            seg = counter_info[_SOC_COUNTER_TYPE_DROP_ENQ].segment;
        } else {
            seg = counter_info[_SOC_COUNTER_TYPE_ACCEPT_ENQ].segment;
        }

        if (!soc_feature(unit, soc_feature_counter_toggled_read) ||
            !soc_feature(unit, soc_feature_cosq_gport_stat_ability)) {
            soc_reg_field_set(unit, CTR_ENQ_STATS_CFGr, &rval, ACTIVE0f, 1);
            soc_reg_field_set(unit, CTR_ENQ_STATS_CFGr, &rval, SEG0f, seg);
        } else {
            soc_reg_field_set(unit, CTR_ENQ_STATS_CFGr, &rval, ACTIVE0f, 1);
            seg = counter_info[i].segment;
            soc_reg_field_set(unit, CTR_ENQ_STATS_CFGr, &rval, SEG0f, seg);
        }

        if (!soc_feature(unit, soc_feature_counter_toggled_read) &&
            (soc_feature(unit, soc_feature_cosq_gport_stat_ability) ||
            (i == _SOC_COUNTER_TYPE_DROP_ENQ_RED))) {
            soc_reg_field_set(unit, CTR_ENQ_STATS_CFGr, &rval, ACTIVE1f, 1);
            seg = counter_info[i].segment;
            soc_reg_field_set(unit, CTR_ENQ_STATS_CFGr, &rval, SEG1f, seg);
        }
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, CTR_ENQ_STATS_CFGr, REG_PORT_ANY, index, rval));

    }

    return SOC_E_NONE;
}

soc_error_t 
soc_katana2_tdm_feasibility_check(int unit, soc_port_t port, int speed)
{
    return _soc_katana2_tdm_feasibility_check(unit, port, speed,NULL,NULL,NULL);
}
soc_error_t 
soc_katana2_update_tdm(int unit, soc_port_t port, int speed)
{
    uint8  mxqblock=0;
    uint8  sub_port=0;
    uint8  min_tdm_cycles=0;
    uint8  available_tdm_slots=0;
    uint32 new_tdm[256];
    uint8  spacing=0;
    uint8  loop=0;
    uint8  pos=0;
    if (kt2_tdm_update_flag == 0) {
        return SOC_E_NONE;
    }
    SOC_IF_ERROR_RETURN(_soc_katana2_tdm_feasibility_check(
                        unit, port, speed, 
                        &mxqblock , &sub_port,&min_tdm_cycles));
    available_tdm_slots=kt2_tdm_pos_info[mxqblock].total_slots;
    sal_memcpy(&new_tdm[0],&kt2_current_tdm[0],
               kt2_current_tdm_size *sizeof(kt2_current_tdm[0]));
    spacing = available_tdm_slots / min_tdm_cycles;
    for (loop=0; loop < available_tdm_slots; loop++) {
         pos = kt2_tdm_pos_info[mxqblock].pos[loop];
         if (loop % spacing == 0) {
             new_tdm[pos]= port;
         } else {
             new_tdm[pos]= KT2_IDLE;
         }
    }
    soc_katana2_reconfigure_tdm(unit,kt2_current_tdm_size,new_tdm); 
    sal_memcpy(kt2_current_tdm,new_tdm,
               kt2_current_tdm_size*sizeof(new_tdm[0]));
    return SOC_E_NONE;
}
soc_error_t soc_katana2_get_port_mxqblock(
            int unit, soc_port_t port,uint8 *mxqblock)
{
   if (!((port >=1) && (port <= 40))) {
       return SOC_E_PORT;
   }
   *mxqblock = kt2_port_to_mxqblock[port-1];
   return SOC_E_NONE; 
}
soc_error_t soc_katana2_get_core_port_mode(
            int unit,soc_port_t port,bcmMxqCorePortMode_t *mode)
{
   uint8      mxqblock = 0;
   uint8      loop =0;
   uint8      mxqport_used = 0;

   SOC_IF_ERROR_RETURN(soc_katana2_get_port_mxqblock(unit,port,&mxqblock));
   for(loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK; loop++) {
       if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), 
                            kt2_mxqblock_ports[mxqblock][loop])) {
           mxqport_used++;
       } 
   }
   switch(mxqport_used){
   case 0: return SOC_E_PARAM;
   case 1: *mode=bcmMxqCorePortModeSingle; /* 0=SINGLE */
           break; 
   case 2: *mode=bcmMxqCorePortModeDual;   /* 1=DUAL   */
           break; 
   case 3: 
   case 4: *mode=bcmMxqCorePortModeQuad;   /* 2=QUAD   */
           break;
   }
   return SOC_E_NONE; 
}
soc_error_t 
soc_katana2_get_phy_connection_mode(int unit,soc_port_t port,int mxqblock,
                                    bcmMxqConnection_t *connection)
{
   /* port is not being used..Might remove it later */

   soc_field_t wc_xfi_mode_sel_fld[]={WC0_8_XFI_MODE_SELf,WC1_8_XFI_MODE_SELf};
   uint32      wc_8_xfi_mode_sel_val = 0;
   uint32      top_misc_control_1_val = 0;


   if (mxqblock <= 5) {   /* MXQPORT is connected to Unicore */
       *connection=bcmMqxConnectionUniCore;
       return SOC_E_NONE; 
   } 
   if ((mxqblock >= 6) && (mxqblock <= 7)) {
       /*Need To Check XFI Mode then */
       if (!(SOC_CONTROL(unit)->soc_flags & SOC_F_INITED)) {
           /* Not Initialized yet so OK to return UNICORE */
           *connection=bcmMqxConnectionUniCore;
           return SOC_E_NONE; 
       }
       SOC_IF_ERROR_RETURN(READ_TOP_MISC_CONTROL_1r(
                                             unit,&top_misc_control_1_val));
       wc_8_xfi_mode_sel_val = soc_reg_field_get(
                                       unit, TOP_MISC_CONTROL_1r,
                                       top_misc_control_1_val,
                                       wc_xfi_mode_sel_fld[mxqblock-6]);
       if (wc_8_xfi_mode_sel_val) {
           *connection=bcmMqxConnectionWarpCore;
       } else {     
           *connection=bcmMqxConnectionUniCore;
       }
       return SOC_E_NONE; 
   }
   if ((mxqblock >= 8) && (mxqblock <= 9)) {/*MXQPORT is connected to Warpcore*/
       *connection=bcmMqxConnectionWarpCore;
       return SOC_E_NONE; 
   } 
   return SOC_E_PARAM; 
}
soc_error_t soc_katana2_get_phy_port_mode(
            int unit, soc_port_t port,int speed, bcmMxqPhyPortMode_t *mode)
{
   int mxqblock=0;
   bcmMxqConnection_t connection;
   soc_info_t *si=&SOC_INFO(unit);

   if (!((port >=1) && (port <= 40))) {
       return SOC_E_PORT;
   }
   if (!SOC_PBMP_MEMBER((PBMP_ALL(unit)), port)) {
       return SOC_E_PORT;
   }
   si = &SOC_INFO(unit);
   /* If speed is less than 2.5G, irrespective of unicore,warpcore,phy_mode 
      will be zero */
   if (speed <= 2500) {
       *mode=bcmMxqPhyPortModeQuad;
       return SOC_E_NONE; 
   }
   mxqblock = kt2_port_to_mxqblock[port-1];
   SOC_IF_ERROR_RETURN(soc_katana2_get_phy_connection_mode(
                       unit,port,mxqblock,&connection));
   switch(connection) {
   case bcmMqxConnectionUniCore:
        if ((speed == 10000) || (speed==12000) || (speed==13000)) {
             *mode=bcmMxqPhyPortModeSingle;
             return SOC_E_NONE; 
        }
        break;
   case bcmMqxConnectionWarpCore:
        if (SOC_IS_KATANA2(unit) && SAL_BOOT_QUICKTURN) {
                if ((speed == 10000)) {
                     if (SOC_PBMP_MEMBER(si->linkphy_pbm, port)) { 
                         soc_cm_print("QUICKTURN:ATTN:LinkPhyPortDualMode");
                     } else {
                         soc_cm_print("QUICKTURN:ATTN:NonLinkPhyPortDualMode");
                     }
                     *mode=bcmMxqPhyPortModeDual;
                     return SOC_E_NONE; 
                }
            /* } */
        }
        if ((speed == 12000) || (speed==13000) || (speed==16000) ||
            (speed == 20000) || (speed==21000)) {
             *mode=bcmMxqPhyPortModeSingle;
             return SOC_E_NONE; 
        }
        if ((speed == 10000)) {
             *mode=bcmMxqPhyPortModeQuad;
             return SOC_E_NONE; 
        }
        break;
   }
   return SOC_E_CONFIG; 
}
void 
soc_katana2_pbmp_init(int unit, kt2_pbmp_t kt2_pbmp)
{
    int port;
    soc_pbmp_t          my_pbmp_xport_xe;
    soc_pbmp_t          my_pbmp_xport_ge;
    soc_port_details_t  *kt2_port_details[]={
                        kt2_port_details_deprecated0,
                        /* New Configuration */
                        kt2_port_details_config1,  kt2_port_details_config2,
                        kt2_port_details_config3,  kt2_port_details_config4,
                        kt2_port_details_config5,  kt2_port_details_config6,
                        kt2_port_details_config7,  kt2_port_details_config8,
                        kt2_port_details_config9,  kt2_port_details_config10,
                        kt2_port_details_config11, kt2_port_details_config12,
                        kt2_port_details_config13, kt2_port_details_config14,
                        kt2_port_details_config15, kt2_port_details_config27,
                        NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                        kt2_port_details_config25,NULL,
                        kt2_port_details_config27, 
                        };
    soc_port_details_t  *kt2_selected_port_details=NULL;
    uint32              kt2_port_details_index=0;
    uint32              loop_index=0;
    uint8               kt2_port_used_flags[40]={0};

    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_gport_stack);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_mxq);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_mxq1g);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_mxq2p5g);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_mxq10g);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_mxq13g);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_mxq21g);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_xport_xe);
    /* SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_valid); */
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_pp);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_linkphy);
    kt2_port_details_index=soc_property_get(unit, spn_BCM5645X_CONFIG,
                               kt2_default_port_config);
    if (kt2_port_details_index >= (sizeof(bcm56450_tdm)/
                                   sizeof(bcm56450_tdm[0]))) {
        soc_cm_print("WRONG CFG VALUE %s=%d \n",
                     spn_BCM5645X_CONFIG, kt2_port_details_index);
        return ;
    } 
    SOC_INFO(unit).olp_port = 0;
    kt2_port_to_mxqblock[40-1]=7;
    kt2_port_to_mxqblock_subports[40-1]=3;
    kt2_mxqblock_ports[7][3]=40;
    kt2_mxqblock_ports[10][0]=0xFF;

    SOC_PBMP_CLEAR(my_pbmp_xport_xe);
    SOC_PBMP_CLEAR(my_pbmp_xport_ge);
    my_pbmp_xport_xe = soc_property_get_pbmp_default(unit, spn_PBMP_XPORT_XE,
                                                     my_pbmp_xport_xe);
    my_pbmp_xport_ge = soc_property_get_pbmp_default(unit, spn_PBMP_XPORT_GE,
                                                     my_pbmp_xport_ge);

    kt2_selected_port_details= kt2_port_details[kt2_port_details_index];
    loop_index=0;
    while(kt2_selected_port_details[loop_index].port_speed != 0) {
          soc_cm_debug(DK_VERBOSE,"start:%d end:%d incr:%d type:%d speed:%d\n",
                       kt2_selected_port_details[loop_index].start_port_no,
                       kt2_selected_port_details[loop_index].end_port_no,
                       kt2_selected_port_details[loop_index].port_incr,
                       kt2_selected_port_details[loop_index].port_type,
                       kt2_selected_port_details[loop_index].port_speed);
          for (port =  kt2_selected_port_details[loop_index].start_port_no;
               port <= kt2_selected_port_details[loop_index].end_port_no;
               port += kt2_selected_port_details[loop_index].port_incr) {
               if (kt2_selected_port_details[loop_index].port_type &
                     GE_PORT) {
                     switch(kt2_selected_port_details[loop_index].port_speed) {
                     case 1000: SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq1g, port); break;
                     case 2500: SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq2p5g, port); break;
                     default:break;/*error */
                     }
               }
               if (kt2_selected_port_details[loop_index].port_type & XE_PORT) {
                   SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq10g, port);
                   SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_xport_xe, port);
               }
               if (kt2_selected_port_details[loop_index].port_type & HG_PORT) {
                   if (SOC_PBMP_MEMBER(my_pbmp_xport_xe, port)) {
                       SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq10g, port);
                       SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_xport_xe, port);
                   } else {
                   switch(kt2_selected_port_details[loop_index].port_speed) {
                   case 10000: SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq10g, port);break;
                   case 13000: SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq13g, port);break;
                   case 20000:
                   case 21000: SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq21g, port);break;
                   default:break;/*error */
                   }
               }
               }
               if (kt2_selected_port_details[loop_index].port_type & HGL_PORT) {
                   if (SOC_PBMP_MEMBER(my_pbmp_xport_ge, port)) {
                       SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq2p5g, port);
                   } else {
                   SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq2p5g, port);
                   SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_gport_stack, port);
               }
               }
               if (kt2_selected_port_details[loop_index].port_type & STK_PORT) {
                   if (!(SOC_PBMP_MEMBER(my_pbmp_xport_xe, port) ||
                         SOC_PBMP_MEMBER(my_pbmp_xport_ge, port))) {
                   SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_gport_stack, port);
               }
               }
               /* Currently not taking action on CES,OLP */
               if (kt2_selected_port_details[loop_index].port_type &
                   LPHY_PORT) {
                   SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_linkphy, port);
               }
               if (kt2_selected_port_details[loop_index].port_type & OLP_PORT) {
                   SOC_INFO(unit).olp_port = 1;
                    kt2_port_to_mxqblock[40-1]=10;
                    kt2_port_to_mxqblock_subports[40-1]=0;
                    kt2_mxqblock_ports[7][3]=0xFF;
                    kt2_mxqblock_ports[10][0]=40;
                   SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq2p5g, port); 
               }
               SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq, port);
               kt2_port_used_flags[port-1]=1;
          }
          loop_index++;
      }
      for (port = 1; port <= 40; port++) {
           if (kt2_port_used_flags[port-1] == 0) {
               SOC_PBMP_PORT_REMOVE(*kt2_pbmp.pbmp_valid, port);
           }
      }
      for (port = 0; port < 170; port++) {
           SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_pp, port);
      }
}

void
soc_katana2_subport_init(int unit)
{
    soc_port_t port, lp_port, prev_port, pp_port;
    soc_pbmp_t pbmp_subport, pbmp_linkphy;
    soc_info_t *si=&SOC_INFO(unit);
    int num_subport = 0, available_subport = 0;
    int port_subport_index_start = 0;
    int port_subport_index_end = 0;
    int first_half_subport_index_max = 0;
    int second_half_subport_index_max = 0;
    int num_subports_valid = 0;

    SOC_PBMP_CLEAR(pbmp_subport);
    SOC_PBMP_CLEAR(pbmp_linkphy);
    SOC_PBMP_CLEAR(si->linkphy_pbm);
    SOC_PBMP_CLEAR(si->lp.bitmap);
    SOC_PBMP_CLEAR(si->subtag_pbm);
    SOC_PBMP_CLEAR(si->subtag.bitmap);
    SOC_PBMP_CLEAR(si->linkphy_pp_port_pbm);
    SOC_PBMP_CLEAR(si->subtag_pp_port_pbm);
    si->subtag_enabled = 0;
    si->linkphy_enabled = 0;

    pbmp_subport = soc_property_get_pbmp(unit, spn_PBMP_SUBPORT, 0);
    pbmp_linkphy = soc_property_get_pbmp(unit, spn_PBMP_LINKPHY, 0);

    SOC_PBMP_ASSIGN(si->subtag_pbm, pbmp_subport);
    SOC_PBMP_ASSIGN(si->subtag.bitmap, pbmp_subport);

    if (SOC_PBMP_NOT_NULL(pbmp_subport)) {
        /* All members of pbmp_linkphy should also be
         *  member of pbmp_subport */
        if (SOC_PBMP_NOT_NULL(pbmp_linkphy)) {
            /* Check if pbmp_linkphy members are valid for
             * supporting LinkPHY.
             * For Katana2(BCM56450) port 27 to 34 only support LinkPHY */
            SOC_PBMP_ITER(pbmp_linkphy, port) {
                if (!SOC_REG_PORT_VALID(unit, RXLP_PORT_ENABLEr, port)) {
                    SOC_ERROR_PRINT((DK_ERR, "\nCONFIG ERROR\n"
                                "pbmp_linkphy member port %d is invalid for "
                                "LinkPHY support\n\n", port));
                    SOC_PBMP_CLEAR(si->linkphy_pbm);
                    SOC_PBMP_CLEAR(si->lp.bitmap);
                    SOC_PBMP_CLEAR(si->subtag_pbm);
                    SOC_PBMP_CLEAR(si->subtag.bitmap);
                    break;
                }
                SOC_PBMP_PORT_ADD(si->linkphy_pbm, port);
                SOC_PBMP_PORT_ADD(si->lp.bitmap, port);
            }

            SOC_PBMP_ITER(pbmp_linkphy, port) {
                if (!SOC_PBMP_MEMBER(pbmp_subport, port)) {
                    SOC_ERROR_PRINT((DK_ERR, "\nCONFIG ERROR\n"
                        "pbmp_linkphy member port %d is not member of "
                        "pbmp_subport\n\n", port));
                    SOC_PBMP_CLEAR(si->linkphy_pbm);
                    SOC_PBMP_CLEAR(si->lp.bitmap);
                    SOC_PBMP_CLEAR(si->subtag_pbm);
                    SOC_PBMP_CLEAR(si->subtag.bitmap);
                    break;
                }
                SOC_PBMP_PORT_REMOVE(si->subtag_pbm, port);
                SOC_PBMP_PORT_REMOVE(si->subtag.bitmap, port);
            }
        }
    } else {
        if (SOC_PBMP_NOT_NULL(pbmp_linkphy)) {
            SOC_ERROR_PRINT((DK_ERR, "\nCONFIG ERROR\n"
                "config variable pbmp_linkphy should be sub-set of "
                "config variable pbmp_subport\n\n"));
        }
    }

    available_subport = KT2_MAX_SUBPORTS;
    prev_port = 0;
    si->port_num_subport[prev_port] = 0;
    si->port_subport_base[prev_port] = KT2_MIN_SUBPORT_INDEX;

    if (SOC_PBMP_NOT_NULL(si->linkphy_pbm)) {

        /* Contraint:
        * If physical port type is LinkPHY then both the
        * subport base and subport end indices should entirely be
        * either in first half or second half.
        * KT2 can support max 128 subports.
        * So a single LinkPHY port can support maximum 64 subports.
        */
        first_half_subport_index_max =
            KT2_MIN_SUBPORT_INDEX + KT2_MAX_LINKPHY_SUBPORTS_PER_PORT - 1;

        second_half_subport_index_max =
            KT2_MIN_SUBPORT_INDEX + KT2_MAX_SUBPORTS - 1;

        /* Iterate through LinkPHY members first and reserve subport indices */
        SOC_PBMP_ITER(si->linkphy_pbm, port) {
            if (port < SOC_MAX_NUM_PORTS) {
                num_subport =
                    soc_property_port_get(unit, port, spn_NUM_SUBPORTS, 0);

                if (num_subport > KT2_MAX_LINKPHY_SUBPORTS_PER_PORT) {
                    num_subport = KT2_MAX_LINKPHY_SUBPORTS_PER_PORT;
                }

                if (num_subport == 0) {
                    SOC_ERROR_PRINT((DK_ERR, "\nCONFIG ERROR\n"
                        "num_subports_%d should be non-zero for "
                        "LinkPHY port %d\n\n", port, port));
                    SOC_PBMP_PORT_REMOVE(si->linkphy_pbm, port);
                    SOC_PBMP_PORT_REMOVE(si->lp.bitmap, port);
                    continue;
                }

                if (num_subport > available_subport) {
                    SOC_ERROR_PRINT((DK_ERR, "\nCONFIG ERROR\n"
                        "num_subports_%d=%d unavailable for LinkPHY port\n\n",
                            port, num_subport));
                    SOC_PBMP_PORT_REMOVE(si->linkphy_pbm, port);
                    SOC_PBMP_PORT_REMOVE(si->lp.bitmap, port);
                    continue;
                }

                port_subport_index_start =
                    si->port_subport_base[prev_port] +
                    si->port_num_subport[prev_port];

                port_subport_index_end =
                    port_subport_index_start + num_subport - 1;

                if (port_subport_index_start < first_half_subport_index_max) {
                    /* check if subports can be accomodated in first half */
                    if (port_subport_index_end <=
                            first_half_subport_index_max) {
                        num_subports_valid = 1;
                    }
                } else {
                    /* check if subports can be accomodated in second half */
                    if (port_subport_index_end <=
                            second_half_subport_index_max) {
                        num_subports_valid = 1;
                    }
                }
                if (num_subports_valid) {
                    si->port_subport_base[port] = port_subport_index_start;
                    si->port_num_subport[port] = num_subport;

                    available_subport -= num_subport;
                    num_subports_valid = 0;
                } else {
                    SOC_ERROR_PRINT((DK_ERR, "\nCONFIG ERROR\n"
                        "contiguous num_subport=%d unavailable "
                        "for LinkPHY port %d\n\n", num_subport, port));
                    SOC_PBMP_PORT_REMOVE(si->linkphy_pbm, port);
                    SOC_PBMP_PORT_REMOVE(si->lp.bitmap, port);
                    continue;
                }
                prev_port = port;
            }
        } /* end SOC_PBMP_ITER(si->linkphy_pbm, port) */
    }

    prev_port = 0;
    if (SOC_PBMP_NOT_NULL(si->subtag_pbm)) {
        /* Iterate through SubTag ports and reserve subport indices */
        SOC_PBMP_ITER(si->subtag_pbm, port) {
            num_subport =
                soc_property_port_get(unit, port, spn_NUM_SUBPORTS, 0);

            if (num_subport == 0) {
                SOC_ERROR_PRINT((DK_ERR, "\nCONFIG ERROR\n"
                    "num_subports_%d should be non-zero for SubTag port %d\n\n",
                    port, port));
                SOC_PBMP_PORT_REMOVE(si->subtag_pbm, port);
                SOC_PBMP_PORT_REMOVE(si->subtag.bitmap, port);
                continue;
            }

            if (num_subport > available_subport) {
                SOC_ERROR_PRINT((DK_ERR, "\nCONFIG ERROR\n"
                    "num_subports_%d=%d unavailable for SubTag port\n\n",
                    port, num_subport));
                SOC_PBMP_PORT_REMOVE(si->subtag_pbm, port);
                SOC_PBMP_PORT_REMOVE(si->subtag.bitmap, port);
                continue;
            }

            port_subport_index_start = si->port_subport_base[prev_port] +
                                       si->port_num_subport[prev_port];

            /* Iterate the LinkPHY ports.
             * Skip the LinkPHY ports for which subports are allocated
             * until we get start index of required free subports
             * or reach end of LinkPHY ports. */

            SOC_PBMP_ITER(si->linkphy_pbm, lp_port) {
                if (lp_port < SOC_MAX_NUM_PORTS) {
                    if (si->port_num_subport[lp_port]) {
                        if (si->port_subport_base[lp_port] ==
                                                    port_subport_index_start) {
                            /* skip the allocated LinkPHY ports */
                            port_subport_index_start =
                                si->port_subport_base[lp_port] +
                                si->port_num_subport[lp_port];
                            continue;
                        } else if (si->port_subport_base[lp_port] >
                                                    port_subport_index_start) {
                            /* check if there is a big enough subport index
                             * chunk unused, between 2 consecutive LinkPHY
                             * enabled ports, to accomodate required subports */
                            if ((si->port_subport_base[lp_port] -
                                 port_subport_index_start) < num_subport) {
                                /* skip the allocated LinkPHY ports */
                                port_subport_index_start =
                                    si->port_subport_base[lp_port]
                                    + si->port_num_subport[lp_port];
                                continue;
                            }
                        }
                    }
                }
            }

            if (port < SOC_MAX_NUM_PORTS) {
                si->port_subport_base[port] = port_subport_index_start;
                si->port_num_subport[port] = num_subport;

                available_subport -= num_subport;
                prev_port = port;
            }
        } /* end SOC_PBMP_ITER(si->subtag_pbm, port) */
    }

    /* populate LinkPHY pp_port bitmap */
    SOC_PBMP_ITER(si->linkphy_pbm, port) {
        if (port < SOC_MAX_NUM_PORTS) {
            for (pp_port = 0; pp_port < si->port_num_subport[port]; pp_port++) {
                SOC_PBMP_PORT_ADD(si->linkphy_pp_port_pbm,
                        pp_port + si->port_subport_base[port]);
            }
        }
    }
    /* populate SubTag pp_port bitmap */
    SOC_PBMP_ITER(si->subtag_pbm, port) {
        if (port < SOC_MAX_NUM_PORTS) {
            for (pp_port = 0; pp_port < si->port_num_subport[port]; pp_port++) {
                SOC_PBMP_PORT_ADD(si->subtag_pp_port_pbm,
                        pp_port + si->port_subport_base[port]);
            }
        }
    }
    if (SOC_PBMP_NOT_NULL (si->subtag_pp_port_pbm)) {
        si->subtag_enabled = 1;
    }
    if (SOC_PBMP_NOT_NULL (si->linkphy_pp_port_pbm)) {
        si->linkphy_enabled = 1;
    }
}

void
_soc_katana2_ci_init(int unit)
{
    uint32 rval;
    soc_cm_print("QUICKTURN:ATTN %s:%d \n",__FUNCTION__,  __LINE__);

WRITE_CI_CONFIG1r(unit, 0, 0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.0,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.1,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.1,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.2,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.2,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.3,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.3,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.4,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.4,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.5,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.5,  0xf0dcf0dc);
WRITE_CI_RESETr(unit,.0,  0x00000004);
WRITE_CI_RESETr(unit,.0,  0x00000002);
WRITE_CI_RESETr(unit,.1,  0x00000004);
WRITE_CI_RESETr(unit,.1,  0x00000002);
WRITE_CI_RESETr(unit,.2,  0x00000004);
WRITE_CI_RESETr(unit,.2,  0x00000002);
WRITE_CI_RESETr(unit,.3,  0x00000004);
WRITE_CI_RESETr(unit,.3,  0x00000002);
WRITE_CI_RESETr(unit,.4,  0x00000004);
WRITE_CI_RESETr(unit,.4,  0x00000002);
WRITE_CI_RESETr(unit,.5,  0x00000004);
WRITE_CI_RESETr(unit,.5,  0x00000002);
WRITE_CI_CONFIG0r(unit,.0,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.0,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.1,  0x0324aa03);
WRITE_CI_CONFIG0r(unit,.1,  0x0324aa03);
WRITE_CI_CONFIG0r(unit,.2,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.2,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.3,  0x0324aa03);
WRITE_CI_CONFIG0r(unit,.3,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.4,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.4,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.5,  0x0324aa03);
WRITE_CI_CONFIG0r(unit,.5,  0x0324ab03);
WRITE_CI_CONFIG2r(unit,.0,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.0,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.1,  0x0c4860f0);
WRITE_CI_CONFIG2r(unit,.1,  0x0c4860f0);
WRITE_CI_CONFIG2r(unit,.2,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.2,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.3,  0x0c4860f0);
WRITE_CI_CONFIG2r(unit,.3,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.4,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.4,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.5,  0x0c4860f0);
WRITE_CI_CONFIG2r(unit,.5,  0x0d4860f0);
WRITE_CI_CONFIG3r(unit,.0,  0x00003451);
WRITE_CI_CONFIG3r(unit,.0,  0x00003451);
WRITE_CI_CONFIG3r(unit,.1,  0x00003451);
WRITE_CI_CONFIG3r(unit,.1,  0x00003451);
WRITE_CI_CONFIG3r(unit,.2,  0x00003451);
WRITE_CI_CONFIG3r(unit,.2,  0x00003451);
WRITE_CI_CONFIG3r(unit,.3,  0x00003451);
WRITE_CI_CONFIG3r(unit,.3,  0x00003451);
WRITE_CI_CONFIG3r(unit,.4,  0x00003451);
WRITE_CI_CONFIG3r(unit,.4,  0x00003451);
WRITE_CI_CONFIG3r(unit,.5,  0x00003451);
WRITE_CI_CONFIG3r(unit,.5,  0x00003451);
WRITE_CI_CONFIG6r(unit,.0,  0x36000214);
WRITE_CI_CONFIG6r(unit,.0,  0x36000214);
WRITE_CI_CONFIG6r(unit,.1,  0x36000214);
WRITE_CI_CONFIG6r(unit,.1,  0x36000214);
WRITE_CI_CONFIG6r(unit,.2,  0x36000214);
WRITE_CI_CONFIG6r(unit,.2,  0x36000214);
WRITE_CI_CONFIG6r(unit,.3,  0x36000214);
WRITE_CI_CONFIG6r(unit,.3,  0x36000214);
WRITE_CI_CONFIG6r(unit,.4,  0x36000214);
WRITE_CI_CONFIG6r(unit,.4,  0x36000214);
WRITE_CI_CONFIG6r(unit,.5,  0x36000214);
WRITE_CI_CONFIG6r(unit,.5,  0x36000214);
WRITE_CI_PHY_STRAPS1r(unit,.0,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.0,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.1,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.1,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.2,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.2,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.3,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.3,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.4,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.4,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.5,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.5,  0x0004129b);
WRITE_CI_RESETr(unit,.0,  0x00000002);
WRITE_CI_RESETr(unit,.0,  0x00000000);
WRITE_CI_RESETr(unit,.1,  0x00000002);
WRITE_CI_RESETr(unit,.1,  0x00000000);
WRITE_CI_RESETr(unit,.2,  0x00000002);
WRITE_CI_RESETr(unit,.2,  0x00000000);
WRITE_CI_RESETr(unit,.3,  0x00000002);
WRITE_CI_RESETr(unit,.3,  0x00000000);
WRITE_CI_RESETr(unit,.4,  0x00000002);
WRITE_CI_RESETr(unit,.4,  0x00000000);
WRITE_CI_RESETr(unit,.5,  0x00000002);
WRITE_CI_RESETr(unit,.5,  0x00000000);
WRITE_CI_DDR_MR0r(unit,.0,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.0,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.0,  0x00001b60);
WRITE_CI_DDR_MR1r(unit,.0,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.0,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.0,  0x00008010);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR0r(unit,.1,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.1,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.1,  0x00001b60);
WRITE_CI_DDR_MR1r(unit,.1,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.1,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.1,  0x00008010);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.1,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.1,  0x00010210);
WRITE_CI_DDR_MR0r(unit,.2,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.2,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.2,  0x00001b60);
WRITE_CI_DDR_MR1r(unit,.2,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.2,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.2,  0x00008010);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.2,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.2,  0x00010210);
WRITE_CI_DDR_MR0r(unit,.3,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.3,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.3,  0x00001b60);
WRITE_CI_DDR_MR1r(unit,.3,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.3,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.3,  0x00008010);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.3,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.3,  0x00010210);
WRITE_CI_DDR_MR0r(unit,.4,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.4,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.4,  0x00001b60);
WRITE_CI_DDR_MR1r(unit,.4,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.4,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.4,  0x00008010);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.4,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.4,  0x00010210);
WRITE_CI_DDR_MR0r(unit,.5,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.5,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.5,  0x00001b60);
WRITE_CI_DDR_MR1r(unit,.5,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.5,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.5,  0x00008010);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.5,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.5,  0x00010210);
WRITE_CI_RESETr(unit,.0,  0x00000000);
WRITE_CI_RESETr(unit,.0,  0x00000004);
WRITE_CI_RESETr(unit,.1,  0x00000000);
WRITE_CI_RESETr(unit,.1,  0x00000004);
WRITE_CI_RESETr(unit,.2,  0x00000000);
WRITE_CI_RESETr(unit,.2,  0x00000004);
WRITE_CI_RESETr(unit,.3,  0x00000000);
WRITE_CI_RESETr(unit,.3,  0x00000004);
WRITE_CI_RESETr(unit,.4,  0x00000000);
WRITE_CI_RESETr(unit,.4,  0x00000004);
WRITE_CI_RESETr(unit,.5,  0x00000000);
WRITE_CI_RESETr(unit,.5,  0x00000004);
sal_sleep( 2);
WRITE_CI_PHY_CONTROLr(unit,.0,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.0,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.1,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.1,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.2,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.2,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.3,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.3,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.4,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.4,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.5,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.5,  0x0425360f);
sal_sleep( 2);
WRITE_CI_PHY_CONTROLr(unit,.0,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.0,  0x04a53603);
WRITE_CI_PHY_CONTROLr(unit,.1,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.1,  0x04253603);
WRITE_CI_PHY_CONTROLr(unit,.2,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.2,  0x04a53603);
WRITE_CI_PHY_CONTROLr(unit,.3,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.3,  0x04253603);
WRITE_CI_PHY_CONTROLr(unit,.4,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.4,  0x04a53603);
WRITE_CI_PHY_CONTROLr(unit,.5,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.5,  0x04253603);
sal_sleep( 2);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000438);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xe000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa000001c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00001420);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00001420);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00001810);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000001c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00001810);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000012);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000012);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000438);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xe000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa000001c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00001420);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00001420);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00001810);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000001c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00001810);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000012);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000012);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000438);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xe000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa000001c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00001420);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00001420);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00001810);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000001c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00001810);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000012);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000012);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xe0000010);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000010);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xe0000010);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000010);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xe0000010);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000010);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000010);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000064);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000064);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000064);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000068);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000068);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000068);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc000005c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000005c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000010);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000064);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000064);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000064);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000068);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000068);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000068);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc000005c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000005c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000010);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000064);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000064);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000064);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000068);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000068);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000004);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000068);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc000005c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000005c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000005c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00100000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000005c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00100000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000005c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00100000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xe000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0043f000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xe000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0043f000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xe000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000040);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000040);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000040);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc00003a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800003a4);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800003a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc00005a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800005a4);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000040);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000040);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000040);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc00003a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800003a4);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800003a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc00005a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800005a4);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000040);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000040);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000040);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc00003a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800003a4);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800003a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc00005a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800005a4);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000003);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800005a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000360);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000360);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000003);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000360);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000560);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000560);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000007);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000560);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000364);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000364);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000007);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000364);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000564);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000564);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000564);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc00003ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800003ac);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800003ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc00005ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800005ac);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000003);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800005a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000360);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000360);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000003);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000360);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000560);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000560);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000007);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000560);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000364);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000364);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000007);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000364);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000564);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000564);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000564);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc00003ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800003ac);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800003ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc00005ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800005ac);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000003);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800005a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000360);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000360);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000003);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000360);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000560);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000560);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000007);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000560);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000364);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000364);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000007);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000364);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000564);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000564);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000564);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc00003ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800003ac);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800003ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc00005ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800005ac);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800005ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000238);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000238);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000238);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000438);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000438);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800005ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000238);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000238);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000238);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000438);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000438);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800005ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000238);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000238);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000238);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000438);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000438);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
sal_sleep( 2);
WRITE_CI_PHY_CONTROLr(unit,.0,  0x05a53603);
WRITE_CI_PHY_CONTROLr(unit,.0,  0x05a5360f);
WRITE_CI_PHY_CONTROLr(unit,.1,  0x04253603);
WRITE_CI_PHY_CONTROLr(unit,.1,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.2,  0x05a53603);
WRITE_CI_PHY_CONTROLr(unit,.2,  0x05a5360f);
WRITE_CI_PHY_CONTROLr(unit,.3,  0x04253603);
WRITE_CI_PHY_CONTROLr(unit,.3,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.4,  0x05a53603);
WRITE_CI_PHY_CONTROLr(unit,.4,  0x05a5360f);
WRITE_CI_PHY_CONTROLr(unit,.5,  0x04253603);
WRITE_CI_PHY_CONTROLr(unit,.5,  0x0425360f);
sal_sleep( 2);
WRITE_CI_MRS_CMDr(unit,.0,  0x000000bc);
WRITE_CI_MRS_CMDr(unit,.0,  0x000000ce);
WRITE_CI_MRS_CMDr(unit,.1,  0x000000bc);
WRITE_CI_MRS_CMDr(unit,.1,  0x000000ce);
WRITE_CI_MRS_CMDr(unit,.2,  0x000000bc);
WRITE_CI_MRS_CMDr(unit,.2,  0x000000ce);
WRITE_CI_MRS_CMDr(unit,.3,  0x000000bc);
WRITE_CI_MRS_CMDr(unit,.3,  0x000000ce);
WRITE_CI_MRS_CMDr(unit,.4,  0x000000bc);
WRITE_CI_MRS_CMDr(unit,.4,  0x000000ce);
WRITE_CI_MRS_CMDr(unit,.5,  0x000000bc);
WRITE_CI_MRS_CMDr(unit,.5,  0x000000ce);
sal_sleep( 2);
WRITE_CI_MRS_CMDr(unit,.0,  0x0000008e);
WRITE_CI_MRS_CMDr(unit,.0,  0x000000cf);
WRITE_CI_MRS_CMDr(unit,.1,  0x0000008e);
WRITE_CI_MRS_CMDr(unit,.1,  0x000000cf);
WRITE_CI_MRS_CMDr(unit,.2,  0x0000008e);
WRITE_CI_MRS_CMDr(unit,.2,  0x000000cf);
WRITE_CI_MRS_CMDr(unit,.3,  0x0000008e);
WRITE_CI_MRS_CMDr(unit,.3,  0x000000cf);
WRITE_CI_MRS_CMDr(unit,.4,  0x0000008e);
WRITE_CI_MRS_CMDr(unit,.4,  0x000000cf);
WRITE_CI_MRS_CMDr(unit,.5,  0x0000008e);
WRITE_CI_MRS_CMDr(unit,.5,  0x000000cf);
sal_sleep( 2);
WRITE_CI_MRS_CMDr(unit,.0,  0x0000008f);
WRITE_CI_MRS_CMDr(unit,.0,  0x000000cd);
WRITE_CI_MRS_CMDr(unit,.1,  0x0000008f);
WRITE_CI_MRS_CMDr(unit,.1,  0x000000cd);
WRITE_CI_MRS_CMDr(unit,.2,  0x0000008f);
WRITE_CI_MRS_CMDr(unit,.2,  0x000000cd);
WRITE_CI_MRS_CMDr(unit,.3,  0x0000008f);
WRITE_CI_MRS_CMDr(unit,.3,  0x000000cd);
WRITE_CI_MRS_CMDr(unit,.4,  0x0000008f);
WRITE_CI_MRS_CMDr(unit,.4,  0x000000cd);
WRITE_CI_MRS_CMDr(unit,.5,  0x0000008f);
WRITE_CI_MRS_CMDr(unit,.5,  0x000000cd);
sal_sleep( 2);
WRITE_CI_MRS_CMDr(unit,.0,  0x0000008d);
WRITE_CI_MRS_CMDr(unit,.0,  0x000000cc);
WRITE_CI_MRS_CMDr(unit,.1,  0x0000008d);
WRITE_CI_MRS_CMDr(unit,.1,  0x000000cc);
WRITE_CI_MRS_CMDr(unit,.2,  0x0000008d);
WRITE_CI_MRS_CMDr(unit,.2,  0x000000cc);
WRITE_CI_MRS_CMDr(unit,.3,  0x0000008d);
WRITE_CI_MRS_CMDr(unit,.3,  0x000000cc);
WRITE_CI_MRS_CMDr(unit,.4,  0x0000008d);
WRITE_CI_MRS_CMDr(unit,.4,  0x000000cc);
WRITE_CI_MRS_CMDr(unit,.5,  0x0000008d);
WRITE_CI_MRS_CMDr(unit,.5,  0x000000cc);
sal_sleep( 2);
WRITE_CI_MRS_CMDr(unit,.0,  0x0000008c);
WRITE_CI_MRS_CMDr(unit,.0,  0x000000fc);
WRITE_CI_MRS_CMDr(unit,.1,  0x0000008c);
WRITE_CI_MRS_CMDr(unit,.1,  0x000000fc);
WRITE_CI_MRS_CMDr(unit,.2,  0x0000008c);
WRITE_CI_MRS_CMDr(unit,.2,  0x000000fc);
WRITE_CI_MRS_CMDr(unit,.3,  0x0000008c);
WRITE_CI_MRS_CMDr(unit,.3,  0x000000fc);
WRITE_CI_MRS_CMDr(unit,.4,  0x0000008c);
WRITE_CI_MRS_CMDr(unit,.4,  0x000000fc);
WRITE_CI_MRS_CMDr(unit,.5,  0x0000008c);
WRITE_CI_MRS_CMDr(unit,.5,  0x000000fc);
sal_sleep( 2);
WRITE_CI_CONFIG0r(unit,.3,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.3,  0x0324aa03);
WRITE_CI_CONFIG0r(unit,.5,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.5,  0x0324aa03);
WRITE_CI_CONFIG2r(unit,.3,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.3,  0x0c4860f0);
WRITE_CI_CONFIG2r(unit,.5,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.5,  0x0c4860f0);
sal_sleep( 2);
if (READ_CI_CONFIG0r(unit, 3, &rval) != SOC_E_NONE) {
    return;
}
soc_reg_field_set(unit, CI_CONFIG0r, &rval, TWLf, 0xa);
WRITE_CI_CONFIG0r(unit, 3, rval);
if (READ_CI_CONFIG0r(unit, 5, &rval) != SOC_E_NONE) {
    return;
}
soc_reg_field_set(unit, CI_CONFIG0r, &rval, TWLf, 0xa);
WRITE_CI_CONFIG0r(unit, 5, rval);
if (READ_CI_CONFIG2r(unit, 3, &rval) != SOC_E_NONE) {
    return;
}
soc_reg_field_set(unit, CI_CONFIG2r, &rval, TREAD_ENBf, 0xc);
WRITE_CI_CONFIG2r(unit, 3, rval);
if (READ_CI_CONFIG2r(unit, 3, &rval) != SOC_E_NONE) {
    return;
}
soc_reg_field_set(unit, CI_CONFIG2r, &rval, TREAD_ENBf, 0xc);
WRITE_CI_CONFIG2r(unit, 3, rval);
sal_sleep( 2);

}

#if defined (SER_TR_TEST_SUPPORT)
soc_ser_test_functions_t ser_katana2_test_fun;    
#endif

int _soc_katana2_misc_init(int unit)
{
    soc_info_t *si;
    uint32 rval;
    uint32 xport_port_enable_reg=0;
#if 0
    uint32 mxq6_7_rval=0;
#endif
    uint32 entry[SOC_MAX_MEM_WORDS], ing_entry[SOC_MAX_MEM_WORDS];
    txlp_port_addr_map_table_entry_t txlp_port_addr_map_table_entry={{0}};
    uint32                start_addr=0;
    uint32                end_addr=0;
    uint8                 mxqblock_port = 0;
    soc_pbmp_t pbmp;
    int port, blk_port, blk;
    int count;
    uint64 reg64;
    uint16 dev_id;
    uint8 rev_id;
    int i;
    soc_field_t fields[3];
    uint32 values[3];
    int rv;
    bcmMxqCorePortMode_t core_mode = 0;
    bcmMxqPhyPortMode_t  phy_mode;
    int                  any_phy_port=0; 
    uint8                loop=0;             
    int                  cfg_num=0; 
    uint8                mxqblock=0;
    uint8                port_count=0;
    uint32               xfi_mode[2]={0};
    uint8                wc_10g_21g_sel=0;
    uint32               port_speed=0;
    uint32               any_port_speed=0;
    uint32               num_cis = 0;
    uint32               ddr3_clock_mhz = 0;
    uint32               num_rows = 32768;
    uint32               ddr3_mem_grade = 0;
    int my_modid_list[KT2_MAX_MODIDS_PER_TRANSLATION_TABLE] = 
        { 0, 0, 0, 0 };
    int my_modid_valid[KT2_MAX_MODIDS_PER_TRANSLATION_TABLE] = 
        { 1, 0, 0, 0 };
    int my_modid_port_base_ptr[KT2_MAX_MODIDS_PER_TRANSLATION_TABLE] = 
        { 0, 0, 0, 0 };

    soc_field_t port_enable_field[KT2_MAX_MXQPORTS_PER_BLOCK]=
                {PORT0f, PORT1f, PORT2f , PORT3f};
   soc_field_t wc_xfi_mode_sel_fld[]={WC0_8_XFI_MODE_SELf,WC1_8_XFI_MODE_SELf};
   uint32      top_misc_control_1_val = 0;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    si = &SOC_INFO(unit);

    if (!SOC_IS_RELOADING(unit) && !SOC_WARM_BOOT(unit)) {
        /* Clear IPIPE/EIPIE Memories */
        SOC_IF_ERROR_RETURN(soc_katana2_pipe_mem_clear(unit));
        SOC_IF_ERROR_RETURN(soc_katana2_linkphy_mem_clear(unit));
    }

    /* Some registers are implemented in memory, need to clear them in order
     * to have correct parity value */
    PBMP_PP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1r(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_EGR_IPMC_CFG2r(unit, port, 0));
    }

    /* PP_PORT_GPP_TRANSLATION_x
    *  4 instances one each for icfg, il2lu, isw2 and ipars stages of ipipe
    * EGR_PP_PORT_GPP_TRANSLATION_x
    *  2 instances one each for evlan and ehcpm stages of epipe */
    /* If LinkPHY/SubTag CoE is enabled then all 170 pp_ports cannot be accomodated
     * insingle modid. We will use 2 mod_ids.
     * All pp_port mapped to front_panel port in one module and
     * remaining pp_ports in another module */
    if ((soc_feature(unit, soc_feature_linkphy_coe) &&
         SOC_INFO(unit).linkphy_enabled) ||
         (soc_feature(unit, soc_feature_subtag_coe) &&
          SOC_INFO(unit).subtag_enabled)) {
        my_modid_list[0] = 0;
        my_modid_valid[0] = 1;
        my_modid_port_base_ptr[0] = 0;
        my_modid_list[1] = 1;
        my_modid_valid[1] = 1;
        my_modid_port_base_ptr[1] = _BCM_KT2_SUBPORT_PP_PORT_INDEX_MIN;
    }

    BCM_IF_ERROR_RETURN(
        bcm_kt2_modid_set(unit, my_modid_list, my_modid_valid,
                                my_modid_port_base_ptr));

#if 0
    if (SOC_IS_KATANA2(unit) && SAL_BOOT_QUICKTURN) {
        if (soc_property_get(unit, spn_DDR3_AUTO_TUNE, FALSE)) {
            soc_cm_print("QUICKTURN:ATTN %s:%d \n",__FUNCTION__,  __LINE__);
            _soc_katana2_ci_init(unit);
        }
    }
#endif

    /* default DDR3 Configuration */
    /* 16k Col * 1k Row * 8 Banks * 16 bits = 2Gb */
#if 0 /* Katana Only supports 1k Cols and 8 banks */
    SOC_DDR3_NUM_COLUMNS(unit) = soc_property_get(unit,spn_EXT_RAM_COLUMNS, 2048);
    SOC_DDR3_NUM_BANKS(unit) = soc_property_get(unit,spn_EXT_RAM_BANKS, 8);
#else
    SOC_DDR3_NUM_COLUMNS(unit) = 2048;
    SOC_DDR3_NUM_BANKS(unit) = 8;
#endif

    switch(dev_id) {
    case BCM56454_DEVICE_ID:
         num_cis = 3;
         ddr3_clock_mhz = 800;
         si->frequency = 123;
         break;
    case BCM56455_DEVICE_ID:
         num_cis = 3;
         ddr3_clock_mhz = 800;
         si->frequency = 166;
         break;
    case BCM56456_DEVICE_ID: /*  Need to check si->frequency */
    case BCM56457_DEVICE_ID:
    case BCM56458_DEVICE_ID:
         num_cis = 0;
         ddr3_clock_mhz = 0;
         if (dev_id == BCM56458_DEVICE_ID) {
             si->frequency = 120;
         } else {
             si->frequency = 205;
         }
         break;
    case BCM56450_DEVICE_ID:
    case BCM56452_DEVICE_ID:
    default: /* 56450 */
         num_cis = 6;       
         ddr3_clock_mhz = 933; /* 933 MHz */
         si->frequency = 205;
         break;
    }
    SOC_DDR3_NUM_MEMORIES(unit) = soc_property_get(unit,spn_EXT_RAM_PRESENT, 
                                                   num_cis);
    SOC_DDR3_NUM_ROWS(unit) = soc_property_get(unit,spn_EXT_RAM_ROWS, 
                                                   num_rows);
    SOC_DDR3_CLOCK_MHZ(unit) = soc_property_get(unit, spn_DDR3_CLOCK_MHZ, 
                                                   ddr3_clock_mhz);
    SOC_DDR3_MEM_GRADE(unit) = soc_property_get(unit, spn_DDR3_MEM_GRADE, 
                                                   ddr3_mem_grade);
    soc_cm_print("num_cis=%d num_rows=%d ddr3_clock_mhz=%d ddr3_mem_grade=%d\n",
                  num_cis,num_rows,ddr3_clock_mhz,ddr3_mem_grade);

    if (soc_feature(unit, soc_feature_ddr3)) {
        /* CI Init */
        soc_ddr40_set_shmoo_dram_config(unit, ((uint32) 0xFFFFFFFF) >> (32 - SOC_DDR3_NUM_MEMORIES(unit)));
        if ((soc_ddr40_phy_pll_ctl(unit, 0, SOC_DDR3_CLOCK_MHZ(unit), 1, 0) == SOC_E_NONE) &&
            (soc_ddr40_ctlr_ctl(unit, 0, 1, 0) == SOC_E_NONE) &&
            (soc_ddr40_phy_calibrate(unit, 0, 1, 0) == SOC_E_NONE)) {

            if (soc_property_get(unit, spn_DDR3_AUTO_TUNE, FALSE)) {
                for(i = 0; i < SOC_DDR3_NUM_MEMORIES(unit); i += 2) {
                    soc_ddr40_shmoo_ctl(unit, i, 1, 1, 0, 0);
                }
                soc_cm_print("DDR Tune Completed\n");
            } else {
                rval = SOC_E_NONE;
                for(i = 0; i < SOC_DDR3_NUM_MEMORIES(unit); i += 2) {
                    rval |= soc_ddr40_shmoo_restorecfg(unit, i);
                }
                if (rval == SOC_E_NONE) {
                    soc_cm_print("DDR Tune Values Restored\n");
                } else {
                    soc_cm_print("DDR Tune Values Restore FAILED\n");
                }
            }
        }
    }

    /* Reset MXQPORT MIB counter (registers implemented in memory) */
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_MXQPORT) {
        blk_port = SOC_BLOCK_PORT(unit, blk);
        if (blk_port < 0) {
            continue;
        }
        rval = 0;
        soc_reg_field_set(unit, XPORT_MIB_RESETr, &rval, CLR_CNTf, 0xf); /* All Ports */
        SOC_IF_ERROR_RETURN(WRITE_XPORT_MIB_RESETr(unit, blk_port, rval));
        SOC_IF_ERROR_RETURN(WRITE_XPORT_MIB_RESETr(unit, blk_port, 0));
    }

    if (soc_property_get(unit, spn_PARITY_ENABLE, FALSE)) {
        (void)_soc_katana2_ser_init(unit);
        memset(&_kt2_ser_functions, 0, sizeof(soc_ser_functions_t));
        _kt2_ser_functions._soc_ser_stat_nack_f = &soc_katana2_stat_nack;
        _kt2_ser_functions._soc_ser_fail_f = &soc_kt2_ser_fail;
        _kt2_ser_functions._soc_ser_mem_nack_f = &soc_katana2_mem_nack;
        _kt2_ser_functions._soc_ser_parity_error_cmicm_intr_f = 
            &soc_katana2_parity_error;
        soc_ser_function_register(unit, &_kt2_ser_functions);
        _soc_katana2_parity_enable_all(unit, TRUE);
    }

#if defined(SER_TR_TEST_SUPPORT)
    /*Initialize chip-specific functions for SER testing*/
    memset(&ser_katana2_test_fun, 0, sizeof(soc_ser_test_functions_t));
    ser_katana2_test_fun.inject_error_f = &soc_katana2_ser_inject_error;
    ser_katana2_test_fun.test_mem = &soc_katana2_ser_mem_test;
    ser_katana2_test_fun.test     = &soc_katana2_ser_test;
    ser_katana2_test_fun.parity_control = &_ser_test_parity_control_pci_write;
    soc_ser_test_functions_register(unit, &ser_katana2_test_fun);
#endif /*defined(SER_TR_TEST_SUPPORT*/

    sal_memset(entry, 0, sizeof(cpu_pbm_entry_t));
    soc_mem_pbmp_field_set(unit, CPU_PBMm, entry, BITMAPf, &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, CPU_PBMm, MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(cpu_pbm_2_entry_t));
    soc_mem_pbmp_field_set(unit, CPU_PBM_2m, entry, BITMAPf, &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, CPU_PBM_2m, MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(multipass_loopback_bitmap_entry_t));
    soc_mem_pbmp_field_set(unit, MULTIPASS_LOOPBACK_BITMAPm, entry, BITMAPf,
                           &PBMP_LB(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, MULTIPASS_LOOPBACK_BITMAPm, MEM_BLOCK_ALL, 0,
                       entry));

    SOC_PBMP_CLEAR(pbmp);
    for (port = 0; port < 42; port++) {
        if (IS_LB_PORT(unit, port) ||
            (si->port_group[port] >= 2 && si->port_group[port] <= 3)) {
            SOC_PBMP_PORT_ADD(pbmp, port);
        }
    }

    sal_memset(entry, 0, sizeof(egr_physical_port_entry_t));
    sal_memset(ing_entry, 0, sizeof(ing_physical_port_table_entry_t));

    soc_mem_field32_set(unit, EGR_PHYSICAL_PORTm, entry, PORT_TYPEf, 1);
    soc_mem_field32_set(unit, ING_PHYSICAL_PORT_TABLEm,
            ing_entry, PORT_TYPEf, 1);
    /* Higig ports */
    PBMP_HG_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(soc_reg_field32_modify(
            unit, XPORT_CONFIGr, port, HIGIG_MODEf, 1));        
        SOC_IF_ERROR_RETURN(soc_mem_write(unit, EGR_PHYSICAL_PORTm,
            MEM_BLOCK_ALL, port, entry));
        SOC_IF_ERROR_RETURN(soc_mem_write(unit, ING_PHYSICAL_PORT_TABLEm, 
            MEM_BLOCK_ALL, port, ing_entry));
    }
  
    /* CMIC higig index */
    SOC_IF_ERROR_RETURN(soc_mem_write(
        unit, EGR_PHYSICAL_PORTm, MEM_BLOCK_ALL, si->cpu_hg_index, entry));
    SOC_IF_ERROR_RETURN(soc_mem_write(
        unit, ING_PHYSICAL_PORT_TABLEm, MEM_BLOCK_ALL,
        si->cpu_hg_index, ing_entry));

    /* Loopback port */
    soc_mem_field32_set(unit, EGR_PHYSICAL_PORTm, entry, PORT_TYPEf, 2);
    soc_mem_field32_set(unit, ING_PHYSICAL_PORT_TABLEm, ing_entry,
        PORT_TYPEf, 2);
    SOC_IF_ERROR_RETURN(soc_mem_write(
        unit, EGR_PHYSICAL_PORTm, MEM_BLOCK_ALL, LB_PORT(unit), entry));
    SOC_IF_ERROR_RETURN(soc_mem_write(
        unit, ING_PHYSICAL_PORT_TABLEm,
        MEM_BLOCK_ALL, LB_PORT(unit), ing_entry));
    /* ingress physical port to pp_port mapping */
    SOC_IF_ERROR_RETURN(soc_mem_field32_modify(
        unit, ING_PHYSICAL_PORT_TABLEm,
        LB_PORT(unit), PP_PORTf, LB_PORT(unit)));

    /* pp_port to egress physical port mapping */
    SOC_IF_ERROR_RETURN(soc_mem_field32_modify(
        unit, PP_PORT_TO_PHYSICAL_PORT_MAPm,
        LB_PORT(unit), DESTINATIONf,LB_PORT(unit)));

    /* All quad ports in default config */
    
    cfg_num = soc_property_get(unit, spn_BCM5645X_CONFIG, 
                               kt2_default_port_config);
    if (cfg_num >= (sizeof(bcm56450_tdm)/sizeof(bcm56450_tdm[0]))) {
        return SOC_E_FAIL;
    } 
    /* Check whether MXQ8,9 are in XFI mode or not */
    for (mxqblock=8; mxqblock <=9 ; mxqblock++) {
        port_count=0; 
        xfi_mode[mxqblock-8] = 0;
        if ((mxqblock == 8) || (mxqblock == 9)) {
             for (loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK; loop+=2) {
                  if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), 
                      kt2_mxqblock_ports[mxqblock][loop])) {
                      if (bcm56450_speed[cfg_num]
                             [kt2_mxqblock_ports[mxqblock][loop]-1] == 10000) {
                          port_count++;
                      }
                  }  
             }
             for (loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK; loop+=2) {
                  if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), 
                      kt2_mxqblock_ports[mxqblock-2][loop])) {
                      if (bcm56450_speed[cfg_num]
                          [kt2_mxqblock_ports[mxqblock-2][loop]-1] == 10000) {
                          port_count++;
                      }
                  }  
             }
             if (port_count == KT2_MAX_MXQPORTS_PER_BLOCK) {
                /*Need To Set XFI Mode then */
                xfi_mode[mxqblock-8] = 1;
             }
             SOC_IF_ERROR_RETURN(READ_TOP_MISC_CONTROL_1r(
                                 unit,&top_misc_control_1_val));
             soc_reg_field_set(unit, TOP_MISC_CONTROL_1r, 
                               &top_misc_control_1_val,
                               wc_xfi_mode_sel_fld[mxqblock-8],
                               xfi_mode[mxqblock-8]);
             SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_1r(
                                 unit,top_misc_control_1_val));
        }
    }
    if ((xfi_mode[0] == 1) || (xfi_mode[1] == 1)) {
        /* Reinitialize katana2 phy addresses */
        SOC_IF_ERROR_RETURN(soc_phyctrl_software_init(unit));
    }
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_MXQPORT) {
        blk_port = SOC_BLOCK_PORT(unit, blk);
        if (blk_port < 0) {
            continue;
        }
        SOC_IF_ERROR_RETURN(soc_katana2_get_port_mxqblock(
                            unit,blk_port,&mxqblock));
        xport_port_enable_reg = 0;
        any_phy_port=0; 
        any_port_speed=0; 
        for (loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK; loop++) {
             if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), 
                            kt2_mxqblock_ports[mxqblock][loop])) {
                 if ((kt2_mxqblock_ports[mxqblock][loop] == KT2_OLP_PORT) &&
                     (si->olp_port == 1) ) {
                     
                     soc_reg_field_set(unit, XPORT_PORT_ENABLEr, 
                                   &xport_port_enable_reg,
                                   port_enable_field[0], 1); /*Enable port */
                 } else { 
                     soc_reg_field_set(unit, XPORT_PORT_ENABLEr, 
                                   &xport_port_enable_reg,
                                   port_enable_field[loop], 1); /*Enable port */
                 }
                 if (any_phy_port == 0) {
                     any_phy_port= kt2_mxqblock_ports[mxqblock][loop];
                     any_port_speed= bcm56450_speed[cfg_num]
                                         [kt2_mxqblock_ports[mxqblock][loop]-1];
                 }
             } else {
                 soc_reg_field_set(unit, XPORT_PORT_ENABLEr, 
                                   &xport_port_enable_reg,
                                   port_enable_field[loop], 0);/*Disable port */
             }
        }

        rval = 0;
        SOC_IF_ERROR_RETURN(soc_katana2_get_phy_port_mode(
                            unit, any_phy_port,
                            bcm56450_speed[cfg_num][any_phy_port-1], 
                            &phy_mode));
        soc_reg_field_set(unit, XPORT_MODE_REGr, &rval,
                            PHY_PORT_MODEf, phy_mode);

        SOC_IF_ERROR_RETURN(soc_katana2_get_core_port_mode(
                            unit,blk_port,&core_mode));
        soc_reg_field_set(unit, XPORT_MODE_REGr, &rval,
                            CORE_PORT_MODEf, core_mode);
        wc_10g_21g_sel = 0;
        if ((mxqblock>=6) && (mxqblock<=9)) {
            for (loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK; loop++) {
                 port_speed= bcm56450_speed[cfg_num]
                                      [kt2_mxqblock_ports[mxqblock][loop]-1];
                 if ((mxqblock==8) || (mxqblock==9)) {
                      if ((SAL_BOOT_QUICKTURN) && 
                          (core_mode == bcmMxqCorePortModeSingle) &&
                          (SOC_PBMP_MEMBER(si->linkphy_pbm, 
                               kt2_mxqblock_ports[mxqblock][loop]))) {
                          soc_cm_print("QUICKTURN: ATTN : 10G_21G_SEL=0 \n");
                          wc_10g_21g_sel = 0;
                          break;
                      }
                      if ((port_speed == 10000) || (port_speed == 21000)) {
                           wc_10g_21g_sel = 1;
                           break;
                      }
                 }
                 if ((mxqblock==6) || (mxqblock==7)) {
                      if ((port_speed == 10000) && (xfi_mode[mxqblock-6] ==1)) {
                           wc_10g_21g_sel = 1;
                           break;
                      }
                 }
            }
#if 0
            if (xfi_mode) { /* so obvious 10g speed */
                mxq6_7_rval=0;
                soc_reg_field_set(unit, XPORT_MODE_REGr, &mxq6_7_rval,
                                  WC_10G_21G_SELf, wc_10g_21g_sel);
                SOC_IF_ERROR_RETURN(WRITE_XPORT_MODE_REGr(unit, 
                             kt2_mxqblock_ports[mxqblock-2][0], mxq6_7_rval));
            }
#endif
            soc_reg_field_set(unit, XPORT_MODE_REGr, &rval,
                               WC_10G_21G_SELf, wc_10g_21g_sel);

        }
        if ((any_port_speed != 0 ) && 
            (any_port_speed < 10000)) {
             soc_reg_field_set(unit, XPORT_MODE_REGr, &rval,
                               PORT_GMII_MII_ENABLEf, 1);
        } else {
             soc_reg_field_set(unit, XPORT_MODE_REGr, &rval,
                               PORT_GMII_MII_ENABLEf, 0);
        } 
        SOC_IF_ERROR_RETURN(WRITE_XPORT_MODE_REGr(unit, blk_port, rval));
        SOC_IF_ERROR_RETURN(WRITE_XPORT_PORT_ENABLEr(unit, blk_port, 
                                                     xport_port_enable_reg));
    }

    count = 32;

    /* Setup main TDM control */
    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    /* BCMSIM handles Single Cell packets */
    if (SAL_BOOT_BCMSIM) {
        soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 1);
    } else {
        soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 0);
    }
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, TDM_WRAP_PTRf, count);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, MISCCONFIGr, &rval, METERING_CLK_ENf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));

    if (0) { 
        rval = 0;
        soc_reg_field_set(unit, ING_BYPASS_CTRLr, &rval, IFP_BYPASS_ENABLEf,
                          1);
        SOC_IF_ERROR_RETURN(WRITE_ING_BYPASS_CTRLr(unit, rval));

        rval = 0;
        soc_reg_field_set(unit, EGR_BYPASS_CTRLr, &rval, EFP_BYPASSf, 1);
        SOC_IF_ERROR_RETURN(WRITE_EGR_BYPASS_CTRLr(unit, rval));
    }

    /* Enable dual hash on L2, L3 and MPLS_ENTRY tables */
    fields[0] = ENABLEf;
    values[0] = 1;
    fields[1] = HASH_SELECTf;
    values[1] = FB_HASH_CRC32_LOWER;
    fields[2] = INSERT_LEAST_FULL_HALFf;
    values[2] = 1;
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, L2_AUX_HASH_CONTROLr, REG_PORT_ANY, 3,
                                 fields, values));
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, L3_AUX_HASH_CONTROLr, REG_PORT_ANY, 3,
                                 fields, values));
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, MPLS_ENTRY_HASH_CONTROLr, REG_PORT_ANY,
                                INSERT_LEAST_FULL_HALFf, 1));

    /*
     * IPMC init 
     */
    SOC_IF_ERROR_RETURN(READ_RQE_GLOBAL_CONFIGr(unit, &rval));
    soc_reg_field_set(unit,RQE_GLOBAL_CONFIGr, &rval, PARITY_GEN_ENf,
                      1);
    soc_reg_field_set(unit,RQE_GLOBAL_CONFIGr, &rval, PARITY_CHK_ENf,
                      1);
    SOC_IF_ERROR_RETURN(WRITE_RQE_GLOBAL_CONFIGr(unit, rval));

    /*
     * Egress Enable
     */
    sal_memset(entry, 0, sizeof(egr_enable_entry_t));
    soc_mem_field32_set(unit, EGR_ENABLEm, entry, PRT_ENABLEf, 0);
    for (port = 0; port < 42; port++) {
        rv = WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, port, entry);
        /* ****************************************************************** */
        
        /* ****************************************************************** */
        if (SOC_FAILURE(rv)) {
            if (SOC_IS_KATANA2(unit) && (rv == _SHR_E_PARAM)) {
                continue;
            }
            return rv;
        }
    }

    sal_memset(entry, 0, sizeof(epc_link_bmap_entry_t));
    soc_mem_pbmp_field_set(unit, EPC_LINK_BMAPm, entry, PORT_BITMAPf,
                           &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN(WRITE_EPC_LINK_BMAPm(unit, MEM_BLOCK_ALL, 0, entry));

    SOC_IF_ERROR_RETURN(READ_ING_CONFIG_64r(unit, &reg64));
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          L3SRC_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          L2DST_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          APPLY_EGR_MASK_ON_L2f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          APPLY_EGR_MASK_ON_L3f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          ARP_RARP_TO_FPf, 0x3); /* enable both ARP & RARP */
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          ARP_VALIDATION_ENf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          IGNORE_HG_HDR_LAG_FAILOVERf, 1);
    SOC_IF_ERROR_RETURN(WRITE_ING_CONFIG_64r(unit, reg64));


    /* The HW defaults for EGR_VLAN_CONTROL_1.VT_MISS_UNTAG == 1, which
     * causes the outer tag to be removed from packets that don't have
     * a hit in the egress vlan tranlation table. Set to 0 to disable this.
     */
    rval = 0;
    soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, VT_MISS_UNTAGf, 0);

    /* Enable pri/cfi remarking on egress ports. */
    soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, REMARK_OUTER_DOT1Pf,
                      1);
    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1r(unit, port, rval));
    }

    SOC_PBMP_ASSIGN(pbmp, PBMP_ALL(unit));
    SOC_PBMP_REMOVE(pbmp, PBMP_LB(unit));
    SOC_IF_ERROR_RETURN(soc_mem_read(unit, ING_EN_EFILTER_BITMAPm,
                                     MEM_BLOCK_ANY, 0, &entry));
    soc_mem_pbmp_field_set(unit, ING_EN_EFILTER_BITMAPm, &entry, BITMAPf,
                           &pbmp);
    SOC_IF_ERROR_RETURN(soc_mem_write(unit, ING_EN_EFILTER_BITMAPm,
                                      MEM_BLOCK_ANY, 0, &entry));

    SOC_IF_ERROR_RETURN(READ_CMIC_TXBUF_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, CMIC_TXBUF_CONFIGr, &rval,
                            FIRST_SERVE_BUFFERS_WITH_EOP_CELLSf, 0);
    SOC_IF_ERROR_RETURN(WRITE_CMIC_TXBUF_CONFIGr(unit, rval));

    if (soc_mspi_init(unit) != SOC_E_NONE) {
        soc_cm_debug(DK_WARN, "unit %d : MSPI Init Failed\n", unit);
    }

    if (soc_feature(unit, soc_feature_ces)) {
	/*
	 * Add CES TDM ports
	 */
	for (i = 0;i < 16;i++) {
	    int port = 39 + i;
	    SOC_PBMP_PORT_ADD(si->tdm_pbm, port);
	    si->tdm.port[si->tdm.num++] = port;
	    if (si->tdm.min > port || si->tdm.min < 0) {
		si->tdm.min = port;
	    }
	    if (si->tdm.max < port) {
		si->tdm.max = port;
	    }
	    SOC_PBMP_PORT_ADD(si->tdm.bitmap, port);
	}
    }
    /* TXLP_PORT_ADDR_MAP_TABLE */
    for (mxqblock=8;mxqblock<=9;mxqblock++) {
         for (loop=0,start_addr=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK;loop++) {
             sal_memset(&txlp_port_addr_map_table_entry,0,
                        sizeof(txlp_port_addr_map_table_entry_t));
             mxqblock_port=kt2_mxqblock_ports[mxqblock][loop];
             if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), mxqblock_port)) {
                 if (!SOC_PBMP_MEMBER(si->linkphy_pbm, mxqblock_port)) {
                     /*  5.  As each cell-occupies "4" lines in buffer, [end-start+1] must be a integral 
                             multiple of "4". */
                     if (si->port_speed_max[mxqblock_port] <= 2500) {
                         end_addr = start_addr + (( 6 * 4) - 1); /* 6 Cells */
                     } else if (si->port_speed_max[mxqblock_port] <= 10000) {
                         end_addr = start_addr + ((12 * 4) - 1); /* 12 Cells */
                     } else if (si->port_speed_max[mxqblock_port] <= 13000) {
                         end_addr = start_addr + ((16 * 4) - 1); /* 16 Cells */
                     } else if (si->port_speed_max[mxqblock_port] <= 21000) {
                         end_addr = start_addr + ((20 * 4) - 1); /* 20 Cells */
                     }
                     soc_TXLP_PORT_ADDR_MAP_TABLEm_field_set(unit,
                         &txlp_port_addr_map_table_entry,START_ADDRf,&start_addr);
                     soc_TXLP_PORT_ADDR_MAP_TABLEm_field_set(unit,
                         &txlp_port_addr_map_table_entry,END_ADDRf,&end_addr);
                     start_addr = end_addr+1;
                 }
             } 
             SOC_IF_ERROR_RETURN(WRITE_TXLP_PORT_ADDR_MAP_TABLEm(
                                 unit,SOC_INFO(unit).txlp_block[mxqblock-8],
                                 loop, &txlp_port_addr_map_table_entry));
        }
    }
    SOC_IF_ERROR_RETURN(soc_mem_clear(
                        unit, MMU_RQE_QUEUE_OP_NODE_MAPm, COPYNO_ALL, TRUE));
    SOC_IF_ERROR_RETURN(soc_mem_clear(
                        unit, MMU_WRED_QUEUE_OP_NODE_MAPm, COPYNO_ALL, TRUE));

    return SOC_E_NONE;
}

#define KA2_MMU_EFIFO_DEPTH             10
#define KA2_MMU_EFIFO_XMIT_THERESHOLD   4

/* Just splitted _soc_katana2_mmu_init() for flex IO feature */
/* Configure Egress Fifo */
/* Port BW Ctrl */
STATIC int
_soc_katana2_mmu_init1_port(int unit,int port,uint32 *nxtaddr)
{
    uint32     rval=0;
    soc_info_t *si= &SOC_INFO(unit);
    int depth = 0;
    int thereshold = 0;
    int mxqblock=0;
    uint32 port_cfg0=0;
    uint32 port_cfg1=0;

    if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), port)) {
        if (!(IS_CPU_PORT(unit,port) || IS_LB_PORT(unit,port))) {
            mxqblock = kt2_port_to_mxqblock[port-1];
            /* Configure Egress Fifo */
            if(mxqblock_max_startaddr[mxqblock] == 0) {
               mxqblock_max_startaddr[mxqblock]= *nxtaddr;
            }
        }
        rval = 0;
        soc_reg_field_set(unit, DEQ_EFIFO_CFGr, &rval, 
                          EGRESS_FIFO_START_ADDRESSf, *nxtaddr);
        soc_cm_debug(DK_VERBOSE,"port=%d nxtaddr=%d \n",port,*nxtaddr);
        if (si->port_speed_max[port] <= 1000) {
            depth = 10;
            thereshold = (IS_EXT_MEM_PORT(unit, port)) ? 8 : 0;
        } else if (si->port_speed_max[port] <= 2500) {
            depth = 15;
            thereshold = (IS_EXT_MEM_PORT(unit, port)) ? 15 : 0;
        } else if (si->port_speed_max[port] <= 13000) {
            depth = 60;
            thereshold = (IS_EXT_MEM_PORT(unit, port)) ? 49 : 0;
        } else { /* > 13G */
            depth = 120;
            thereshold = (IS_EXT_MEM_PORT(unit, port)) ? 85 : 0;
        }
        soc_reg_field_set(unit, DEQ_EFIFO_CFGr, &rval, 
                          EGRESS_FIFO_XMIT_THRESHOLDf, thereshold);
        soc_reg_field_set(unit, DEQ_EFIFO_CFGr, &rval, 
                          EGRESS_FIFO_DEPTHf, depth);
        if (SOC_PBMP_MEMBER(si->linkphy_pbm, port)) {
            soc_reg_field_set(unit, DEQ_EFIFO_CFGr, &rval, 
                              EGRESS_FIFO_LINK_PHYf, 1);
        }
        *nxtaddr += depth;
        SOC_IF_ERROR_RETURN(WRITE_DEQ_EFIFO_CFGr(unit, port, rval));

        if (IS_EXT_MEM_PORT(unit, port)) {
            SOC_IF_ERROR_RETURN(READ_DEST_PORT_CFG_0r(unit, &port_cfg0));
            SOC_IF_ERROR_RETURN(READ_DEST_PORT_CFG_1r(unit, &port_cfg1));
            if (port <= 31) {
                port_cfg0 |= (1 << port);
            } else {
                port_cfg1 |= (1 << (port - 32));
            }
            SOC_IF_ERROR_RETURN(WRITE_DEST_PORT_CFG_0r(unit, port_cfg0));
            SOC_IF_ERROR_RETURN(WRITE_DEST_PORT_CFG_1r(unit, port_cfg1));

            SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_0r(unit, port_cfg0));
            SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_1r(unit, port_cfg1));
        }

        /* Port BW Ctrl */
        SOC_IF_ERROR_RETURN(READ_TOQ_PORT_BW_CTRLr(unit, port, &rval));
        if (IS_CPU_PORT(unit,port) || IS_LB_PORT(unit,port)) {
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              PORT_BWf, 50);
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              START_THRESHOLDf, 127);
        } else if (si->port_speed_max[port] >= 10000) {
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              PORT_BWf, 500);
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              START_THRESHOLDf, 34);
        } else if (si->port_speed_max[port] == 2500) {
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              PORT_BWf, 125);
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              START_THRESHOLDf, 19);
        } else {
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              PORT_BWf, 50);
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              START_THRESHOLDf, 7);
        }
        SOC_IF_ERROR_RETURN(WRITE_TOQ_PORT_BW_CTRLr(unit, port, rval));
        if (!(IS_CPU_PORT(unit,port) || IS_LB_PORT(unit,port))) {
            mxqblock_max_endaddr[mxqblock]=(*nxtaddr)-1;
        }
    } else {
        SOC_IF_ERROR_RETURN(WRITE_DEQ_EFIFO_CFGr(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_TOQ_PORT_BW_CTRLr(unit, port, 0));
    }
    return SOC_E_NONE;
}
STATIC int
_soc_katana2_mmu_init1(int unit) 
{
    uint32 nxtaddr=0;
    int    port=0;
    int    mxqblock=0;
    int    subport=0;

    for (mxqblock=0;mxqblock<KT2_MAX_MXQBLOCKS ; mxqblock++) {
         mxqblock_max_startaddr[mxqblock]=0;
         mxqblock_max_endaddr[mxqblock]=0;
    }

     /* cpu port */
     _soc_katana2_mmu_init1_port(unit,0,&nxtaddr);
     /* lb port */
    _soc_katana2_mmu_init1_port(unit,41,&nxtaddr);
    for (mxqblock=0;mxqblock<KT2_MAX_MXQBLOCKS ; mxqblock++) {
         for (subport=0;subport<KT2_MAX_MXQPORTS_PER_BLOCK; subport++) {
              port = kt2_mxqblock_ports[mxqblock][subport];
              _soc_katana2_mmu_init1_port(unit,port,&nxtaddr);
         }
    }
    for (mxqblock=0;mxqblock<KT2_MAX_MXQBLOCKS ; mxqblock++) {
         soc_cm_debug(DK_VERBOSE,"start=%d end=%d \n",
                      mxqblock_max_startaddr[mxqblock],
                      mxqblock_max_endaddr[mxqblock]);
    }
    return SOC_E_NONE;
}

/* Just splitted _soc_katana2_mmu_init() for flex IO feature */
STATIC int
_soc_katana2_mmu_init3(int unit)
{
    int    port=0;
    uint32 rval=0;
    for (port=0;port<42;port++) {
         rval = 0;
         if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), port)) {
             soc_reg_field_set(unit, PORT_MAX_PKT_SIZEr, &rval, 
                               PORT_MAX_PKT_SIZEf,49);
         }
         SOC_IF_ERROR_RETURN(WRITE_PORT_MAX_PKT_SIZEr(unit, port, rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIEXT_PORT_MAX_PKT_SIZEr(unit, port,
                                                              rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIEMA_PORT_MAX_PKT_SIZEr(unit, port, 
                                                              rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIRQE_PORT_MAX_PKT_SIZEr(unit, port, 
                                                              rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIQEN_PORT_MAX_PKT_SIZEr(unit, port, 
                                                              rval));

         rval = 0xffff;
         SOC_IF_ERROR_RETURN(WRITE_THDIEXT_PORT_PRI_XON_ENABLEr(unit, port, 
                                                                rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIEXT_PORT_PRI_XON_ENABLEr(unit, port, 
                                                                rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIEMA_PORT_PRI_XON_ENABLEr(unit, port, 
                                                                rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIRQE_PORT_PRI_XON_ENABLEr(unit, port, 
                                                                rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIQEN_PORT_PRI_XON_ENABLEr(unit, port, 
                                                                rval));
    }

    /* MXQ Ports */
    for (port=KT2_CMIC_PORT;port<(KT2_LPBK_PORT+1);port++) {
         rval = 0;
         if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit,port) /* || 
             ((port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT) &&
              (kt2_port_to_mxqblock_subports[port-1] == 0)) */) {
                  rval = 0xffffff; /* PRIx_GRP = 0x7 */
         }
         SOC_IF_ERROR_RETURN(WRITE_PORT_PRI_GRP0r(unit, port, rval));
         SOC_IF_ERROR_RETURN(WRITE_PORT_PRI_GRP1r(unit, port, rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIEXT_PORT_PRI_GRP0r(unit, port, rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIEXT_PORT_PRI_GRP1r(unit, port, rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIEMA_PORT_PRI_GRP0r(unit, port, rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIEMA_PORT_PRI_GRP1r(unit, port, rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIRQE_PORT_PRI_GRP0r(unit, port, rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIRQE_PORT_PRI_GRP1r(unit, port, rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIQEN_PORT_PRI_GRP0r(unit, port, rval));
         SOC_IF_ERROR_RETURN(WRITE_THDIQEN_PORT_PRI_GRP1r(unit, port, rval));
    }

    /* READ_MMU_ENQ_IP_PRI_TO_PG_PROFILE_0r(unit, rval); */
    rval = 0;
    for (port=0;port<42;port++) {
         if (IS_XE_PORT(unit,port) || IS_HG_PORT(unit,port)) {
             if (soc_reg_field_valid(unit, MMU_ENQ_IP_PRI_TO_PG_PROFILE_0r, 
                                     kt2_srcport_field_names[port])) {
                 /* PRIx_GRP = 0x7 */
                 soc_reg_field_set(unit, MMU_ENQ_IP_PRI_TO_PG_PROFILE_0r, 
                                   &rval,kt2_srcport_field_names[port], 3);
             } else {
                soc_cm_print("Suspicious Config:%s:%d\n",__FUNCTION__,__LINE__);
             }
         }
    }
    WRITE_MMU_ENQ_IP_PRI_TO_PG_PROFILE_0r(unit, rval);
    return SOC_E_NONE;
}

STATIC int
_soc_katana2_mmu_init(int unit)
{
    uint32 rval;
    uint64 r64val, rval64;
    int                 mmu_init_usec, i;
    soc_timeout_t       to;
    /* uint32 entry[SOC_MAX_MEM_WORDS]; */
    mmu_aging_lmt_int_entry_t age_entry;
    int count;
    uint16 dev_id;
    uint8 rev_id;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    /* Init Link List Scheduler */
    rval = 0;
    soc_reg_field_set(unit, LLS_SOFT_RESETr, &rval, SOFT_RESETf, 0);
    SOC_IF_ERROR_RETURN(WRITE_LLS_SOFT_RESETr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, LLS_INITr, &rval, INITf, 1);
    SOC_IF_ERROR_RETURN(WRITE_LLS_INITr(unit, rval));

    /* Wait for LLS init done. */
    if (SAL_BOOT_SIMULATION) {
        mmu_init_usec = 10000000; /* Simulation  .. 10sec */
    } else {
        mmu_init_usec = 50000;
    }
    soc_timeout_init(&to, mmu_init_usec, 0);
    do {
        SOC_IF_ERROR_RETURN(READ_LLS_INITr(unit, &rval));
        if (soc_reg_field_get(unit, LLS_INITr, rval, INIT_DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            soc_cm_debug(DK_WARN, "unit %d : LLS INIT timeout\n", unit);
            break;
        }
    } while (TRUE);

    /* Setup TDM for MMU Arb & LLS */
    SOC_IF_ERROR_RETURN(_soc_katana2_mmu_tdm_init(unit));

    for(i=0; i<16; i++) {
        SOC_IF_ERROR_RETURN(READ_TOQ_EXT_MEM_BW_MAP_TABLEr(unit, i, &rval));
        
        soc_reg_field_set(unit, TOQ_EXT_MEM_BW_MAP_TABLEr, &rval,
                                            GBL_GUARENTEE_BW_LIMITf, 1450);
        soc_reg_field_set(unit, TOQ_EXT_MEM_BW_MAP_TABLEr, &rval,
                                            WR_PHASEf, 142);/* KT2 */
        soc_reg_field_set(unit, TOQ_EXT_MEM_BW_MAP_TABLEr, &rval,
                                            RD_PHASEf, 138);/* KT2 */
        SOC_IF_ERROR_RETURN(
            WRITE_TOQ_EXT_MEM_BW_MAP_TABLEr(unit,i,rval));
    }

    SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init1(unit));

    rval = 0;
    soc_reg_field_set(unit, DEQ_EFIFO_CFG_COMPLETEr, &rval, EGRESS_FIFO_CONFIGURATION_COMPLETEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_DEQ_EFIFO_CFG_COMPLETEr(unit, rval));

    /* Enable LLS */
    rval = 0;
    soc_reg_field_set(unit, LLS_CONFIG0r, &rval, DEQUEUE_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_CONFIG0r, &rval, ENQUEUE_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_CONFIG0r, &rval, FC_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_CONFIG0r, &rval, MIN_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_CONFIG0r, &rval, PORT_SCHEDULER_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_CONFIG0r, &rval, SHAPER_ENABLEf, 1);
    if (SOC_REG_FIELD_VALID(unit, LLS_CONFIG0r, SPRI_VECT_MODE_ENABLEf)) {
        if (soc_feature(unit, soc_feature_vector_based_spri)) {
            soc_reg_field_set(unit, LLS_CONFIG0r, &rval,
                              SPRI_VECT_MODE_ENABLEf, 1);
        }
    }
    SOC_IF_ERROR_RETURN(WRITE_LLS_CONFIG0r(unit, rval));

    /* Enable shaper background refresh */
    rval = 0;
    soc_reg_field_set(unit, LLS_MAX_REFRESH_ENABLEr, &rval, L0_MAX_REFRESH_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_MAX_REFRESH_ENABLEr, &rval, L1_MAX_REFRESH_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_MAX_REFRESH_ENABLEr, &rval, L2_MAX_REFRESH_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_MAX_REFRESH_ENABLEr, &rval, PORT_MAX_REFRESH_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_MAX_REFRESH_ENABLEr, &rval, S0_MAX_REFRESH_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_MAX_REFRESH_ENABLEr, &rval, S1_MAX_REFRESH_ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_LLS_MAX_REFRESH_ENABLEr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, LLS_MIN_REFRESH_ENABLEr, &rval, L0_MIN_REFRESH_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_MIN_REFRESH_ENABLEr, &rval, L1_MIN_REFRESH_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_MIN_REFRESH_ENABLEr, &rval, L2_MIN_REFRESH_ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_LLS_MIN_REFRESH_ENABLEr(unit, rval));

    /* RQE configuration */
    rval = 0;
    soc_reg_field_set(unit, RQE_SCHEDULER_CONFIGr, &rval,
                      L0_MCM_MODEf, 1);
    soc_reg_field_set(unit, RQE_SCHEDULER_CONFIGr, &rval,
                      L0_CC_MODEf, 1);
    soc_reg_field_set(unit, RQE_SCHEDULER_CONFIGr, &rval,
                      L0_UCM_MODEf, 1);
    soc_reg_field_set(unit, RQE_SCHEDULER_CONFIGr, &rval,
                      L1_MODEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_RQE_SCHEDULER_CONFIGr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, RQE_SCHEDULER_WEIGHT_L0_QUEUEr, &rval,
                      WRR_WEIGHTf, 1);
    for(i=0; i<SOC_REG_NUMELS(unit, RQE_SCHEDULER_WEIGHT_L0_QUEUEr); i++) {
        SOC_IF_ERROR_RETURN(WRITE_RQE_SCHEDULER_WEIGHT_L0_QUEUEr(unit, i, 
                                                                 rval));
    }

    rval = 0;
    soc_reg_field_set(unit, RQE_SCHEDULER_WEIGHT_L1_QUEUEr, &rval,
                      WRR_WEIGHTf, 1);
    for(i=0; i<SOC_REG_NUMELS(unit, RQE_SCHEDULER_WEIGHT_L1_QUEUEr); i++) {
        SOC_IF_ERROR_RETURN(WRITE_RQE_SCHEDULER_WEIGHT_L1_QUEUEr(unit, i, 
                                                                 rval));
    }

    /* Enable all ports */
    COMPILER_64_ZERO(r64val);
    COMPILER_64_SET(rval64, 0x3ff, 0xffffffff); /*Bits 0..41 */
    soc_reg64_field_set(unit, INPUT_PORT_RX_ENABLE_64r, &r64val,
                          INPUT_PORT_RX_ENABLEf, rval64);
    SOC_IF_ERROR_RETURN(WRITE_INPUT_PORT_RX_ENABLE_64r(unit, r64val));
    SOC_IF_ERROR_RETURN(WRITE_THDIEMA_INPUT_PORT_RX_ENABLE_64r(unit, r64val));
    SOC_IF_ERROR_RETURN(WRITE_THDIEXT_INPUT_PORT_RX_ENABLE_64r(unit, r64val));
    SOC_IF_ERROR_RETURN(WRITE_THDIQEN_INPUT_PORT_RX_ENABLE_64r(unit, r64val));
    SOC_IF_ERROR_RETURN(WRITE_THDIRQE_INPUT_PORT_RX_ENABLE_64r(unit, r64val));

    SOC_IF_ERROR_RETURN(WRITE_THDI_BYPASSr(unit, 0));
    SOC_IF_ERROR_RETURN(WRITE_THDIQEN_THDI_BYPASSr(unit, 0));
    SOC_IF_ERROR_RETURN(WRITE_THDIRQE_THDI_BYPASSr(unit, 0));
    SOC_IF_ERROR_RETURN(WRITE_THDIEXT_THDI_BYPASSr(unit, 0));
    SOC_IF_ERROR_RETURN(WRITE_THDIEMA_THDI_BYPASSr(unit, 0));
    SOC_IF_ERROR_RETURN(WRITE_THDO_BYPASSr(unit, 0));

    if (soc_feature(unit, soc_feature_ddr3)) {
        /* Configure EMC */
        SOC_IF_ERROR_RETURN(READ_EMC_CFGr(unit, &rval));
        soc_reg_field_set(unit, EMC_CFGr, &rval, NUM_CISf, 
            SOC_DDR3_NUM_MEMORIES(unit)); /* Number of CIs attached to EMC */
        soc_reg_field_set(unit, EMC_CFGr, &rval, DRAM_SIZEf, 2); 
        SOC_IF_ERROR_RETURN(WRITE_EMC_CFGr(unit, rval));

        SOC_IF_ERROR_RETURN(READ_EMC_FREE_POOL_SIZESr(unit, &rval));
        soc_reg_field_set(unit, EMC_FREE_POOL_SIZESr, &rval, WTFP_SIZEf, 240);
        soc_reg_field_set(unit, EMC_FREE_POOL_SIZESr, &rval, RSFP_SIZEf, 128);
        SOC_IF_ERROR_RETURN(WRITE_EMC_FREE_POOL_SIZESr(unit, rval));

        SOC_IF_ERROR_RETURN(READ_EMC_IWRB_SIZEr(unit, &rval));
        soc_reg_field_set(unit, EMC_IWRB_SIZEr, &rval, IWRB_SIZEf, 2);
        SOC_IF_ERROR_RETURN(WRITE_EMC_IWRB_SIZEr(unit, rval));

        SOC_IF_ERROR_RETURN(READ_EMC_IRRB_THRESHOLDSr(unit, &rval));
        soc_reg_field_set(unit, EMC_IRRB_THRESHOLDSr, &rval, ALL_Q_XOFF_THRESHOLDf, 0x10);
        soc_reg_field_set(unit, EMC_IRRB_THRESHOLDSr, &rval, ALL_UNDERRUN_Q_XOFF_THRESHOLDf, 0x28);
        soc_reg_field_set(unit, EMC_IRRB_THRESHOLDSr, &rval, ALL_UNDERRUN_Q_XON_THRESHOLDf, 0x18);
        soc_reg_field_set(unit, EMC_IRRB_THRESHOLDSr, &rval, ALL_Q_XON_THRESHOLDf, 8);
        SOC_IF_ERROR_RETURN(WRITE_EMC_IRRB_THRESHOLDSr(unit, rval));
    }

    /* WRED Configuration */
    if ((dev_id != BCM56450_DEVICE_ID)) { /* And all other 90MHz variants */
        SOC_IF_ERROR_RETURN(READ_WRED_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, WRED_MISCCONFIGr, &rval, BASE_UPDATE_INTERVALf, 7);
        SOC_IF_ERROR_RETURN(WRITE_WRED_MISCCONFIGr(unit, rval));

        SOC_IF_ERROR_RETURN(READ_WRED_PARITY_ERROR_MASKr(unit, &rval));
        soc_reg_field_set(unit, WRED_PARITY_ERROR_MASKr, &rval, UPDATE_INTRPT_MASKf, 0);
        SOC_IF_ERROR_RETURN(WRITE_WRED_PARITY_ERROR_MASKr(unit, rval));

        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, REFRESH_ENf, 1);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
    }
    SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init3(unit));

    SOC_IF_ERROR_RETURN(_soc_katana2_perq_flex_counters_init(unit));

    rval = 0; /* PRIx_GRP = 0x0 */
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_0_PRI_GRP0r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_0_PRI_GRP1r(unit, rval));
    rval = 0xffffff; /* PRIx_GRP = 0x7 */
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_1_PRI_GRP0r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_1_PRI_GRP1r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_2_PRI_GRP0r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_2_PRI_GRP1r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_3_PRI_GRP0r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_3_PRI_GRP1r(unit, rval));

    /* Input port shared space */
/*    rval = 0;
    soc_reg_field_set(unit, USE_SP_SHAREDr, &rval, ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_USE_SP_SHAREDr(unit, rval));
*/
    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_BUFFER_CELL_LIMIT_SP_SHAREDr(unit,0));
    SOC_IF_ERROR_RETURN(WRITE_THDIEXT_BUFFER_CELL_LIMIT_SP_SHAREDr(unit,0));
    SOC_IF_ERROR_RETURN(WRITE_THDIEMA_BUFFER_CELL_LIMIT_SP_SHAREDr(unit,0));
    SOC_IF_ERROR_RETURN(WRITE_THDIRQE_BUFFER_CELL_LIMIT_SP_SHAREDr(unit,0));
    SOC_IF_ERROR_RETURN(WRITE_THDIQEN_BUFFER_CELL_LIMIT_SP_SHAREDr(unit,0));

    /* Input port per-device global headroom */
    rval = 0;
    SOC_IF_ERROR_RETURN(READ_THDO_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, THDO_MISCCONFIGr, &rval, STAT_CLEARf, 0);
    soc_reg_field_set(unit, THDO_MISCCONFIGr, &rval, PARITY_CHK_ENf, 1);
    soc_reg_field_set(unit, THDO_MISCCONFIGr, &rval, PARITY_GEN_ENf, 1);
    SOC_IF_ERROR_RETURN(WRITE_THDO_MISCCONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_OP_THR_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, OP_THR_CONFIGr, &rval, EARLY_E2E_SELECTf, 0);
    SOC_IF_ERROR_RETURN(WRITE_OP_THR_CONFIGr(unit, rval));

    /* Helper function for MMU settings based on
       memory selection (internal/external/both) and mode (lossless/lossy) */
    SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init_helper(unit));

    /* Initialize MMU internal/external aging limit memory */
    count = soc_mem_index_count(unit, MMU_AGING_LMT_INTm); 
    sal_memset(&age_entry, 0, sizeof(mmu_aging_lmt_int_entry_t));
    for (i=0; i < count; i++) {
        SOC_IF_ERROR_RETURN(WRITE_MMU_AGING_LMT_INTm(unit,
                            MEM_BLOCK_ANY, i, &age_entry));
    }

    count = soc_mem_index_count(unit, MMU_AGING_LMT_EXTm); 
    for (i=0; i < count; i++) {
        SOC_IF_ERROR_RETURN(WRITE_MMU_AGING_LMT_EXTm(unit,
                            MEM_BLOCK_ANY, i, &age_entry));
    }
    _soc_kt2_mem_config(unit);

    return SOC_E_NONE;
}
int _soc_katana2_mmu_reconfigure(int unit)
{
  /* SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init1(unit)); */
  SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init3(unit)); 
  SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init_helper(unit));
  soc_cm_print("MMU is reconfigured \n");
  return SOC_E_NONE;
}

STATIC int
_soc_katana2_age_timer_get(int unit, int *age_seconds, int *enabled)
{
    uint32 rval;

    SOC_IF_ERROR_RETURN(READ_L2_AGE_TIMERr(unit, &rval));
    *enabled = soc_reg_field_get(unit, L2_AGE_TIMERr, rval, AGE_ENAf);
    *age_seconds = soc_reg_field_get(unit, L2_AGE_TIMERr, rval, AGE_VALf);

    return SOC_E_NONE;
}

STATIC int
_soc_katana2_age_timer_max_get(int unit, int *max_seconds)
{
    *max_seconds =
        soc_reg_field_get(unit, L2_AGE_TIMERr, 0xffffffff, AGE_VALf);

    return SOC_E_NONE;
}

STATIC int
_soc_katana2_age_timer_set(int unit, int age_seconds, int enable)
{
    uint32 rval;

    rval = 0;
    soc_reg_field_set(unit, L2_AGE_TIMERr, &rval, AGE_ENAf, enable);
    soc_reg_field_set(unit, L2_AGE_TIMERr, &rval, AGE_VALf, age_seconds);
    SOC_IF_ERROR_RETURN(WRITE_L2_AGE_TIMERr(unit, rval));

    return SOC_E_NONE;
}

int kt2_linkphy_port[2][4] = {
    {27, 32, 33, 34}, /* {T,R}XLP0 */
    {28, 29, 30, 31}  /* {T,R}XLP1 */
};

int 
soc_kt2_linkphy_port_reg_blk_idx_get(
    int unit, int port, int blktype, int *block, int *index)
{
    int i,j;
    int blk = -1;
    int idx = -1;

    for (i=0; i<2; i++) {
        for(j=0; j<4; j++) {
            if(port == kt2_linkphy_port[i][j]) {
                    blk = i;
                    idx = j;
                    break;
            }
        }
    }

    if (blktype == SOC_BLK_TXLP) {
        if (blk == 0) {
            blk = TXLP0_BLOCK(unit);
        } else if (blk == 1) {
            blk = TXLP1_BLOCK(unit);
        }
    } else if (blktype == SOC_BLK_RXLP) {
        if (blk == 0) {
            blk = RXLP0_BLOCK(unit);
        } else if (blk == 1) {
            blk = RXLP1_BLOCK(unit);
        }
    } else {
        return SOC_E_PARAM;
    }

    if (block != NULL) {
        *block = blk;
    }
    if (index != NULL) {
        *index = idx;
    }
    if ((blk == -1) || (idx == -1)) {
        return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

int
soc_kt2_linkphy_port_blk_idx_get(
    int unit, int port, int *block, int *index)
{
    int i,j;
    int blk = -1;
    int idx = -1;

    for (i=0; i<2; i++) {
        for(j=0; j<4; j++) {
            if(port == kt2_linkphy_port[i][j]) {
                    blk = i;
                    idx = j;
                    break;
            }
        }
    }

    if (block != NULL) {
        *block = blk;
    }
    if (index != NULL) {
        *index = idx;
    }
    if ((blk == -1) || (idx == -1)) {
        return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

int soc_kt2_linkphy_get_portid(int unit, int block, int index) {
    if (index > 3) {
        return -1;
    }
    if ((block == TXLP0_BLOCK(unit)) || (block == RXLP0_BLOCK(unit))) {
        return kt2_linkphy_port[0][index];
    } else if ((block == TXLP1_BLOCK(unit)) || (block == RXLP1_BLOCK(unit))) {
            return kt2_linkphy_port[1][index];
    }
    return -1;
}


/*
 * cpu port (mmu port 0): 48 queues (0-47)
 * loopback port (48-71)
 * hg ports : 24 queues
 * other ports : 8 queues                              
 */

int
soc_katana2_num_cosq_init(int unit)
{
    soc_info_t *si;
    int port, prev_port;
    int numq = 0, i;
    int pp_port_cos;
    int start_pp_port, end_pp_port;
    int packing_mode;
    
    si = &SOC_INFO(unit);
    prev_port = 0;
    packing_mode = soc_property_get(unit, spn_MMU_MULTI_PACKETS_PER_CELL, 0); 

    for (port = 0; port < 42; port++) {
        si->port_num_ext_cosq[port] = 0;
        si->port_num_cosq[port] = 0;

        if (IS_CPU_PORT(unit, port)) {
            si->port_cosq_base[port] = 0;
            si->port_uc_cosq_base[port] = 0;
            si->port_num_uc_cosq[port] = 72;
            si->port_num_ext_cosq[port] = 0;
            numq = si->port_num_uc_cosq[port];
        } else {
            si->port_uc_cosq_base[port] = si->port_uc_cosq_base[prev_port] +
                                          numq;
            si->port_cosq_base[port] = si->port_uc_cosq_base[port];
            if (IS_HG_PORT(unit, port)) {
                si->port_num_uc_cosq[port] = 32;
            } else {
                si->port_num_uc_cosq[port] = 8;
            }
        }
        prev_port = port;
        numq = si->port_num_uc_cosq[port];

        pp_port_cos = soc_property_port_get(unit, port, 
                                spn_NUM_SUBPORT_COS, 4); 
        
        if (si->port_num_subport[port] > 0) {
            start_pp_port = si->port_subport_base[port];
            end_pp_port = si->port_subport_base[port] + 
                          si->port_num_subport[port];
            for (i = start_pp_port; i < end_pp_port; i++) {
                si->port_uc_cosq_base[i] = si->port_uc_cosq_base[port] + numq;
                si->port_cosq_base[i] = si->port_uc_cosq_base[i];
                si->port_num_uc_cosq[i] = pp_port_cos;
                numq += pp_port_cos;
                /*if (soc_feature(unit, soc_feature_mmu_packing)) { */
                if (packing_mode) {
                    si->port_cosq_base[i] += 2048;
                    si->port_num_cosq[i] = si->port_num_uc_cosq[i];    
                }
            }
        }

        /*if (soc_feature(unit, soc_feature_mmu_packing)) { */
        if (packing_mode) {
            si->port_cosq_base[port] += 2048;
            si->port_num_cosq[port] = si->port_num_uc_cosq[port];    
        }
        
        if (soc_cm_debug_check(DK_VERBOSE)) {
            soc_cm_print("\nport num %d cosq_base %d num_cosq %d",
                   port, si->port_cosq_base[port], si->port_num_uc_cosq[port]);
        }
    }
    
    return SOC_E_NONE;
}

soc_blk_ctr_reg_desc_t _soc_kt2_blk_ctr_reg_desc[] =
{
    {
        SOC_BLK_RXLP,
        {
            {RXLP_UNEXPECTED_ETHERTYPEr, 1, 1, 0},
            {RXLP_UNKNOWN_STREAM_IDr, 1, 1, 0},
            {RXLP_DFC_FRAMESr, 1, 1, 0},
            {RXLP_DFC_FRAME_UNEXPECTED_MACDAr, 1, 1, 0},
            {RXLP_DFC_FRAME_UNEXPECTED_MACSAr, 1, 1, 0},
            {RXLP_DFC_HEADER_OPCODE_ERRORr, 1, 1, 0},
            {RXLP_DFC_HEADER_TIME_ERRORr, 1, 1, 0},
            {RXLP_DFC_LENGTH_ERRORr, 1, 1, 0},
            {INVALIDr, 0, 0}
        }
    }
};

void
soc_kt2_blk_counter_config(int unit)
{
    soc_control_t *soc = SOC_CONTROL(unit);
    /* TimeBeing Skipping it due to some NACK issue */
    if (!(SAL_BOOT_BCMSIM || SAL_BOOT_PLISIM)) {
      soc_cm_print("QUICKTURN|BOARD:ATTN:Skipping RXLP Counter(NACK-issue)\n");
        soc->blk_ctr_desc_count = 0;
    } else {
        soc->blk_ctr_desc_count = COUNTOF(_soc_kt2_blk_ctr_reg_desc);
    }
    soc->blk_ctr_desc = _soc_kt2_blk_ctr_reg_desc;
}

/*
 * Katana chip driver functions.
 */
soc_functions_t soc_katana2_drv_funs = {
    _soc_katana2_misc_init,
    _soc_katana2_mmu_init,
    _soc_katana2_age_timer_get,
    _soc_katana2_age_timer_max_get,
    _soc_katana2_age_timer_set,
};

/* KT2 OAM */
STATIC
soc_field_t _soc_kt2_oam_interrupt_fields[] = {
    SOME_RMEP_CCM_DEFECTf,
    SOME_RDI_DEFECTf,
    ERROR_CCM_DEFECTf,
    XCON_CCM_DEFECTf,
    ANY_RMEP_TLV_INTERFACE_UPf,
    ANY_RMEP_TLV_INTERFACE_DOWNf,
    ANY_RMEP_TLV_PORT_UPf,
    ANY_RMEP_TLV_PORT_DOWNf,
    INVALIDf
};

void
soc_kt2_oam_interrupt_process(int unit)
{
    uint32 rval;
    int rv, found = 0, fidx = 0;
    soc_kt2_oam_handler_t oam_handler_snapshot = kt2_oam_handler[unit];

    rv = READ_IP1_INTR_ENABLE_1r(unit, &rval);
    while (_soc_kt2_oam_interrupt_fields[fidx] != INVALIDf) {
        if (soc_reg_field_get(unit, IP1_INTR_ENABLE_1r, rval,
                          _soc_kt2_oam_interrupt_fields[fidx])) {
        
            soc_event_generate(unit, SOC_SWITCH_EVENT_DEVICE_INTERRUPT, 
                               _SOC_PARITY_INFO_TYPE_OAM, 
                               INVALIDm, _soc_kt2_oam_interrupt_fields[fidx]);
            
            found++;
        }
        fidx++;
    }
    if (!found) {
        soc_cm_debug(DK_ERR, "Unexpected interrupt \
                          received for OAM rv=0x%x!!\n", rv);
    } else {
        if (oam_handler_snapshot != NULL) {
            (void)(oam_handler_snapshot(unit, 
                                       _soc_kt2_oam_interrupt_fields[fidx]));
        }
    }
}

void
soc_kt2_oam_handler_register(int unit, soc_kt2_oam_handler_t handler)
{
    int rv, fidx = 0;
    uint32 rval;

    kt2_oam_handler[unit] = handler;
    
    rv = READ_IP1_INTR_ENABLE_1r(unit, &rval);
    if (rv) {
        soc_cm_debug(DK_ERR, "unit %d: Error reading %s reg !!\n",
                     unit, SOC_REG_NAME(unit, IP1_INTR_ENABLE_1r));
    }
    while (_soc_kt2_oam_interrupt_fields[fidx] != INVALIDf) {
        soc_reg_field_set(unit, IP1_INTR_ENABLE_1r, &rval,
                          _soc_kt2_oam_interrupt_fields[fidx], 1);
        fidx++;
    }
    rv = WRITE_IP1_INTR_ENABLE_1r(unit, rval);
    if (rv) {
        soc_cm_debug(DK_ERR, "unit %d: Error writing %s reg !!\n",
                     unit, SOC_REG_NAME(unit, IP1_INTR_ENABLE_1r));
    }                   
}


/* soc_kt2_mem_config:
 * Over-ride the default table sizes (from regsfile) for any SKUs here
 */
int
soc_kt2_mem_config(int unit, int dev_id)
{
    int rv = SOC_E_NONE;
    soc_persist_t *sop = SOC_PERSIST(unit);

    switch (dev_id) {
        case BCM56456_DEVICE_ID:
            sop->memState[MMU_THDO_QCONFIG_CELLm].index_max = 1023;
            sop->memState[MMU_THDO_QCONFIG_QENTRYm].index_max = 1023;
            sop->memState[MMU_THDO_QCOUNT_CELL_0m].index_max = 1023;
            sop->memState[MMU_THDO_QOFFSET_CELLm].index_max = 1023;
            sop->memState[MMU_THDO_QOFFSET_QENTRYm].index_max = 1023;
            sop->memState[MMU_THDO_QRESET_VALUE_CELL_0m].index_max = 1023;
            sop->memState[MMU_THDO_QRESET_VALUE_QENTRY_0m].index_max = 1023;
            sop->memState[MMU_THDO_QSTATUS_CELL_0m].index_max = 1023;
            sop->memState[MMU_THDO_QSTATUS_QENTRY_0m].index_max = 1023;
            sop->memState[MMU_TOQ_STATE_MEM0m].index_max = 1023;
            sop->memState[MMU_TOQ_STATE_MEM1m].index_max = 1023;
            sop->memState[MMU_WRED_QUEUE_AVG_QSIZE_BUFFERm].index_max = 1023;
            sop->memState[MMU_WRED_QUEUE_AVG_QSIZE_QENTRYm].index_max = 1023;
            sop->memState[MMU_WRED_QUEUE_CONFIG_BUFFERm].index_max = 1023;
            sop->memState[MMU_WRED_QUEUE_CONFIG_QENTRYm].index_max = 1023;
            sop->memState[MMU_WRED_QUEUE_DROP_THD_DEQm].index_max = 1023;
            sop->memState[MMU_WRED_QUEUE_DROP_THD_ENQ_0m].index_max = 1023;
            sop->memState[MMU_WRED_QUEUE_OP_NODE_MAPm].index_max = 1023;
            sop->memState[THDO_QCOUNT_QENTRY_0m].index_max = 1023;
            break;
        default:
            break;
    }
    return rv;
}

static const soc_reg_t pvtmon_result_reg[] = {
    TOP_PVTMON_RESULT_0r, TOP_PVTMON_RESULT_1r,
    TOP_PVTMON_RESULT_2r, TOP_PVTMON_RESULT_3r
};

int 
_soc_katana2_temperature_monitor_init(int unit) {
    uint32 rval;
    
    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_1r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RSTBf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));

    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_0r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, PROG_RESISTERf, 3);
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, BG_ADJf, 3);
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, MEASUREMENT_CALLIBRATIONf, 5);    
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_0r(unit, rval));

    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_1r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_SELECTf, 0);
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RSTBf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));

    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_1r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RSTBf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));

    sal_usleep(1000);

    return SOC_E_NONE;
}    

int
soc_kt2_temperature_monitor_get(int unit,
          int temperature_max,
          soc_switch_temperature_monitor_t *temperature_array,
          int *temperature_count)
{
    uint32 rval;
    soc_reg_t reg;
    int index;
    int fval, cur, peak;
    int num_entries_out;

    *temperature_count = 0;
    if (COUNTOF(pvtmon_result_reg) > temperature_max) {
        num_entries_out = temperature_max;
    } else {
        num_entries_out = COUNTOF(pvtmon_result_reg);
    }
    /* Check to see if the thermal monitor is initialized */
    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_1r(unit, &rval));
    if ((soc_reg_field_get(unit, TOP_PVTMON_CTRL_1r, rval, PVTMON_RSTBf) == 0) ||
        (soc_reg_field_get(unit, TOP_PVTMON_CTRL_1r, rval, PVTMON_SELECTf) != 0)) {
        SOC_IF_ERROR_RETURN(_soc_katana2_temperature_monitor_init(unit));
   }

    for (index = 0; index < num_entries_out; index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        fval = soc_reg_field_get(unit, reg, rval, TEMP_DATAf);
        cur = (4180000 - (5556 * fval)) / 1000;
        fval = soc_reg_field_get(unit, reg, rval, PEAK_TEMP_DATAf);
        peak = (4180000 - (5556 * fval)) / 1000;
        (temperature_array + index)->curr = cur;
        (temperature_array + index)->peak = peak;
    }
    SOC_IF_ERROR_RETURN(READ_TOP_MISC_CONTROL_0r(unit, &rval));
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON0_PEAK_DATA_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON1_PEAK_DATA_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON2_PEAK_DATA_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON3_PEAK_DATA_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_0r(unit, rval));
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON0_PEAK_DATA_RST_Lf, 0);
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON1_PEAK_DATA_RST_Lf, 0);
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON2_PEAK_DATA_RST_Lf, 0);
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON3_PEAK_DATA_RST_Lf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_0r(unit, rval));
    *temperature_count=num_entries_out;
    
    return SOC_E_NONE;
}

int
soc_kt2_show_ring_osc(int unit)
{
    soc_reg_t ctrl_reg;
    uint32 rval, fval;
    int core_clk, quo, rem, frac;
    int ring_osc, ring_sel;
    int cmc = SOC_PCI_CMC(unit);

    core_clk = SOC_INFO(unit).frequency * 1024;
    ctrl_reg = TOP_MISC_CONTROL_2r;

    for (ring_osc = 2; ring_osc < 4; ring_osc++) {
        for (ring_sel = 0; ring_sel < 2; ring_sel++) {
            rval = 0;
            SOC_IF_ERROR_RETURN(READ_TOP_MISC_CONTROL_2r(unit, &rval));
            soc_reg_field_set(unit, ctrl_reg, &rval, OSC_ENABLEf, 1);
            SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_2r(unit, rval));
            soc_reg_field_set(unit, ctrl_reg, &rval, IROSC_ENf, 1);
            SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_2r(unit, rval));

            soc_reg_field_set(unit, ctrl_reg, &rval, IROSC_0_SELf, ring_sel);
            SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_2r(unit, rval));
            soc_reg_field_set(unit, ctrl_reg, &rval, IROSC_1_SELf, ring_sel);
            SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_2r(unit, rval));

            soc_reg_field_set(unit, ctrl_reg, &rval, OSC_1_SELf, ring_osc);
            SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_2r(unit, rval));
            soc_reg_field_set(unit, ctrl_reg, &rval, OSC_0_SELf, 1);
            SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_2r(unit, rval));
            soc_reg_field_set(unit, ctrl_reg, &rval, OSC_0_SELf, 3);
            SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_2r(unit, rval));
        
            sal_usleep(1000);
    
            rval = soc_pci_read(unit, CMIC_CMCx_IRQ_STAT3_OFFSET(cmc));
            /* SOC_IF_ERROR_RETURN(READ_CMIC_CMC0_IRQ_STAT3r(unit, &rval)); */
            fval = rval & 0xffff;
            if (0 == fval) {
                quo = 0;
                frac = 0;
            } else {
                quo = core_clk / fval;
                rem = core_clk - quo * fval;
                frac = (rem * 10000) / fval;
            }
            soc_cm_print("%d: %d.%04d Mhz\n",
                         ring_osc, quo, frac);
        }
    }
    return SOC_E_NONE;
}

int
soc_kt2_show_material_process(int unit)
{
    soc_reg_t reg;
    int index;
    uint32 rval, fval, nmos[COUNTOF(pvtmon_result_reg)], n_avg, p_avg;

    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_0r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, FUNC_MODE_SELf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_0r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, MEASUREMENT_CALLIBRATIONf, 0x5);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_0r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, PROG_RESISTERf, 0x3);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_0r(unit, rval));

    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_1r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RSTBf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_SELECTf, 0x1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RSTBf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));

    sal_usleep(1000);

    /* Read NMOS information */
    n_avg = 0;
    for (index = 0; index < COUNTOF(pvtmon_result_reg); index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        nmos[index] = soc_reg_field_get(unit, reg, rval, TEMP_DATAf);
        n_avg += nmos[index];
    }

    /* Read PMOS information and print both NMOS and PMOS value */
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_0r, REG_PORT_ANY,
                                MEASUREMENT_CALLIBRATIONf, 7));

    sal_usleep(1000);

    p_avg = 0;
    for (index = 0; index < COUNTOF(pvtmon_result_reg); index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        fval = soc_reg_field_get(unit, reg, rval, TEMP_DATAf);
        p_avg += fval;

        soc_cm_print("Material process location %d: NMOS = %3d PMOS = %3d\n",
                     index, nmos[index], fval);
    }

    soc_cm_print("Average:                     NMOS = %3d PMOS = %3d\n",
                 n_avg / COUNTOF(pvtmon_result_reg),
                 p_avg / COUNTOF(pvtmon_result_reg));

    return SOC_E_NONE;
}

int
soc_kt2_show_voltage(int unit)
{
    soc_reg_t reg;
    int index;
    uint32 rval, fval, avg;

    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_0r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, FUNC_MODE_SELf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_0r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, MEASUREMENT_CALLIBRATIONf, 0x5);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_0r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, PROG_RESISTERf, 0x3);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_0r(unit, rval));

    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_1r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RSTBf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_SELECTf, 0x3);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RSTBf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));

    sal_usleep(1000);
    avg = 0;
    /* Read Voltages */
    for (index = 0; index < COUNTOF(pvtmon_result_reg); index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        fval = soc_reg_field_get(unit, reg, rval, TEMP_DATAf);
        /* (0.99/1024) * 8/7 * TEMP_DATA */
        fval = (fval * 8 * 990) / (1024 * 7);
        avg += fval;
        soc_cm_print("Voltage @ location %d: = %d.%03dV\n",
                     index, (fval/1000), (fval %1000));
    }
    avg /= COUNTOF(pvtmon_result_reg);
    soc_cm_print("Average:            = %d.%03dV\n",
                 (avg/1000), (avg %1000));

    return SOC_E_NONE;
}
static
void _soc_kt2_mem_config_set(int unit, char *config_str, char *config_value)
{
   /* Need to revisit for WARMBOOT case */
   /* if (soc_property_get(unit,config_str,0xABCD) == 0xABCD) { */
       soc_mem_config_set(config_str,config_value);
   /* }     */
}

void
_soc_kt2_mem_config(int unit)
{
/* #ifdef BROADCOM_SVK  */
   /* For first 4(UC0-UC3) mxqblock , tx polarity is changed */
   /* For next  4(UC4-UC7) mxqblock , rx polarity is changed */
   char tx_rx[][8]={"tx","tx","tx","tx","rx","rx","rx","rx"};

   char config_str[80];
   char config_value[10];
   uint8 mxqblock=0;
   uint8 loop=0;
   uint16 dev_id=0;
   uint8 rev_id=0;
   int   cfg_num=0;
   int   auto_portgroup=0;
   int   auto_polarity_flip=0;


   if (soc_mem_config_set == NULL) {
       return;
   }

   soc_cm_get_id(unit, &dev_id, &rev_id);
   cfg_num = soc_property_get(unit, spn_BCM5645X_CONFIG,
                              kt2_default_port_config);
   auto_portgroup  = soc_property_get(unit, "auto_portgroup",
                              0);
   auto_polarity_flip = soc_property_get(unit, "auto_polarity_flip",
                              0);

   if (auto_polarity_flip) {
       soc_cm_print("Broadcom SVK..Adding required polarity flips \n");
       for (mxqblock = 0; mxqblock < 8; mxqblock++) {
            for (loop=0; loop < KT2_MAX_MXQPORTS_PER_BLOCK; loop++) {       
                 if (kt2_mxqblock_ports[mxqblock][loop] == 0xFF) {
                     continue;
                 }
                 if (kt2_mxqblock_ports[mxqblock][loop] == 40) {
                     if (SOC_INFO(unit).olp_port) {
                         continue;
                     }
                 }
                 sal_sprintf(config_str,"phy_xaui_%s_polarity_flip_%d",
                             tx_rx[mxqblock], 
                             kt2_mxqblock_ports[mxqblock][loop]);
                 _soc_kt2_mem_config_set(unit,config_str,"1");
            }
       }
       /* There is no change in WC0 */
       /* For WC1: MXQBLOCK9:Lane0, RX polarity flip is changed */
       if (dev_id == BCM56456_DEVICE_ID) {
           sal_sprintf(config_value,"0xF00F");
       } else {
           sal_sprintf(config_value,"0x000F");
       }
       /* for (loop=0; loop < KT2_MAX_MXQPORTS_PER_BLOCK; loop++)  */
       sal_sprintf(config_str,"phy_xaui_rx_polarity_flip_%d",
                               kt2_mxqblock_ports[9][0]);
       _soc_kt2_mem_config_set(unit,config_str,config_value);
   }

   if (auto_portgroup) {
       soc_cm_print("Broadcom SVK..Adding required port groups \n");
       switch(cfg_num) {
       case 0:
              _soc_kt2_mem_config_set(unit,"portgroup_27","1");
              _soc_kt2_mem_config_set(unit,"portgroup_28","1");
              _soc_kt2_mem_config_set(unit,"portgroup_29","1");
              _soc_kt2_mem_config_set(unit,"portgroup_30","1");
              _soc_kt2_mem_config_set(unit,"portgroup_31","1");
              _soc_kt2_mem_config_set(unit,"portgroup_32","1");
              _soc_kt2_mem_config_set(unit,"portgroup_33","1");
              _soc_kt2_mem_config_set(unit,"portgroup_34","1");
       case 1: case 2: 
              _soc_kt2_mem_config_set(unit,"portgroup_27","1");
              _soc_kt2_mem_config_set(unit,"portgroup_28","1");
              break;
       case 3:
              _soc_kt2_mem_config_set(unit,"portgroup_27","1");
              _soc_kt2_mem_config_set(unit,"portgroup_28","1");
              _soc_kt2_mem_config_set(unit,"portgroup_30","1");
              break;
       case 4:
              _soc_kt2_mem_config_set(unit,"portgroup_27","1");
              _soc_kt2_mem_config_set(unit,"portgroup_33","1");
              _soc_kt2_mem_config_set(unit,"portgroup_28","1");
              _soc_kt2_mem_config_set(unit,"portgroup_30","1");
              break;
       case 5:
              _soc_kt2_mem_config_set(unit,"portgroup_27","1");
              _soc_kt2_mem_config_set(unit,"portgroup_33","1");

              _soc_kt2_mem_config_set(unit,"portgroup_28","1");
              _soc_kt2_mem_config_set(unit,"portgroup_30","1");
              _soc_kt2_mem_config_set(unit,"portgroup_26","1");
              _soc_kt2_mem_config_set(unit,"portgroup_39","1");
              break;
       case 6:
              _soc_kt2_mem_config_set(unit,"portgroup_27","1");
              _soc_kt2_mem_config_set(unit,"portgroup_33","1");
              _soc_kt2_mem_config_set(unit,"portgroup_25","1");
              _soc_kt2_mem_config_set(unit,"portgroup_36","1");

              _soc_kt2_mem_config_set(unit,"portgroup_28","1");
              _soc_kt2_mem_config_set(unit,"portgroup_30","1");
              _soc_kt2_mem_config_set(unit,"portgroup_26","1");
              _soc_kt2_mem_config_set(unit,"portgroup_39","1");
              break;
       case 8: case 9: case 10: case 11: case 12: case 13: case 14: case 15: case 16:
              _soc_kt2_mem_config_set(unit,"portgroup_27","4");
              _soc_kt2_mem_config_set(unit,"portgroup_28","4");
              break;
       default : break;
       }
  }
/* #endif  */
  return;
}

#endif /* BCM_KATANA2_SUPPORT */
