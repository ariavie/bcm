/*
 * $Id: fabric.h 1.67 Broadcom SDK $
 * 
 * $Copyright: Copyright 2012 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_FABRIC_H__
#define __BCM_FABRIC_H__

#include <bcm/types.h>
#include <bcm/port.h>
#include <shared/fabric.h>

#define BCM_FABRIC_PORT_EGRESS_MULTICAST    (1<<0)     
#define BCM_FABRIC_PORT_INGRESS_MULTICAST   (1<<1)     

#ifndef BCM_HIDE_DISPATCHABLE

/* Create subports corresponding to front panel ports. */
extern int bcm_fabric_port_create(
    int unit, 
    bcm_gport_t parent_port, 
    int offset, 
    uint32 flags, 
    bcm_gport_t *port);

/* Destroy subports corresponding to front panel ports. */
extern int bcm_fabric_port_destroy(
    int unit, 
    bcm_gport_t parent_port);

/* Retreive parent port. */
extern int bcm_fabric_port_get(
    int unit, 
    bcm_gport_t child_port, 
    uint32 flags, 
    bcm_gport_t *parent_port);

#endif /* BCM_HIDE_DISPATCHABLE */

/* bcm_fabric_control_t */
typedef enum bcm_fabric_control_e {
    bcmFabricArbiterId,                 /* Arbiter Identifier */
    bcmFabricActiveArbiterId,           /* Active Arbiter Identifier */
    bcmFabricArbiterConfig,             /* Arbiter NULL Grant Mechanism */
    bcmFabricMaximumFailedLinks,        /* Maximum Failed Links for load shared
                                           data plane redundancy mode */
    bcmFabricActiveId,                  /* retreives actual(versus provisioned)
                                           Active Arbiter Identifier */
    bcmFabricRedundancyMode,            /* Fabric Redundancy Mode */
    bcmFabricMode,                      /* Fabric Mode (QE fabric, QE TME) */
    bcmFabricManager,                   /* Fabric Manager Mode (XBAR only,
                                           ARB/XBAR, ARB capable/XBAR) */
    bcmFabricMcGroupSourceKnockout,     /* Multicast Group Source Knockout
                                           Configuration. For get operation the
                                           arg parameter direction In/Out */
    bcmFabricEgressQueueMin,            /* Local QID start index */
    bcmFabricEgressQueueMax,            /* Local QID end index */
    bcmFabricQueueMin,                  /* FIC QID start index */
    bcmFabricQueueMax,                  /* FIC QID end index */
    bcmFabricArbitrationMapFabric,      /* Arbitration Map for Fabric Queues */
    bcmFabricArbitrationMapSubscriber,  /* Arbitration Map for Subscriber Queues */
    bcmFabricArbitrationMapHierarchicalSubscriber, /* Arbitration Map for higher level
                                           schedulers/scheduling nodes */
    bcmFabricSubscriberCosLevels,       /* Maximum COS levels for subscriber
                                           queues */
    bcmFabricSubscriberCosLevelAllocation, /* Internal COS allocation for
                                           subscriber queues */
    bcmFabricShaperQueueMin,            /* FIC QID start shaping index */
    bcmFabricShaperQueueMax,            /* FIC QID end shaping index */
    bcmFabricShaperQueueIncrement,      /* FIC QID shaping increment. 1
                                           indicates shaping can be configured
                                           on every queue, 4 indicates shaping
                                           can be configured on every 4th queue,
                                           0 indicates shaping on entire queue
                                           group */
    bcmFabricShaperEgressQueueMin,      /* Local QID start shaping index */
    bcmFabricShaperEgressQueueMax,      /* Local QID end shaping index */
    bcmFabricShaperEgressQueueIncrement, /* Local QID shaping increment. 1
                                           indicates shaping can be configured
                                           on every queue, 4 indicates shaping
                                           can be configured on every 4th queue,
                                           0 indicates shaping on entire queue
                                           group */
    bcmFabricMulticastQueueMin,         /* Multicast QID start index */
    bcmFabricMulticastQueueMax,         /* Multicast QID end index */
    bcmFabricRecycleQueueMin,           /* Recycle QID start index */
    bcmFabricRecycleQueueMax,           /* Recycle QID end index */
    bcmFabricWatchdogQueueMin,          /* Watchdog QID start index */
    bcmFabricWatchdogQueueMax,          /* Watchdog QID end index */
    bcmFabricWatchdogQueueEnable,       /* Queue Watchdog Functionality
                                           Enable/Disable setting (True/False) */
    bcmFabricTrafficManagementCosMode,  /* traffic management cos mode. Only
                                           retreiving this configuration is
                                           supported */
    bcmFabricCellSizeFixed,             /* fixed cell size configuration. TRUE
                                           => fixed cell size, FALSE => variable
                                           cell size */
    bcmFabricCellSizeMin,               /* minimum cell size configuration.
                                           Configuration units are in bytes */
    bcmFabricCellSizeMax,               /* maximum cell size configuration.
                                           Configuration units are in bytes */
    bcmFabricCreditSize,                /* credit worth size. Configuration
                                           units are in bytes */
    bcmFabricCreditSizeRemoteDefault,   /* Default remote credit size */
    bcmFabricVsqCategory,               /* VSQ Catagory Mode */
    bcmFabricMulticastSchedulerMode,    /* 0 => Trafic Class only mode, 1 =>
                                           {Traffic class, group} mode */
    bcmFabricMcLowPrioMin,              /* Start index of low priority multicast
                                           groups */
    bcmFabricMcLowPrioMax,              /* End index of low priority multicast
                                           groups */
    bcmFabricMcMidPrioMin,              /* Start index of medium priority
                                           multicast groups */
    bcmFabricMcMidPrioMax,              /* End index of medium priority
                                           multicast groups */
    bcmFabricEnableMcLowPrioDrop,       /*  Enable dropping low priority
                                           mulicast */
    bcmFabricMcLowPrioDropThUp,         /* Dropping low priority multicast high
                                           threshold */
    bcmFabricMcLowPrioDropThDown,       /* Dropping low priority multicast low
                                           threshold */
    bcmFabricMcLowPrioDropSelect,       /* Select the highet priority to be
                                           treated as low */
    bcmFabricTsApplicationHierachySetup, /* Application manage ingress node
                                           resources. 1 indicates application
                                           manage, 0 indicate SDK auto manage */
    bcmFabricMaxPorts,                  /* Maximum fabric ports to be supported
                                           by SDK */
    bcmFabricEgressDropLimitBytes,      /* Total system-wide buffer drop limit */
    bcmFabricEgressRedDropLimitBytes,   /* Total system-wide Red drop limit */
    bcmFabricEgressYellowDropLimitBytes, /* Total system-wide Yellow drop limit */
    bcmFabricDemandCalculationEnable,   /* Enable the demand calculation (on QE) */
    bcmFabricOperatingIntervalEnable,   /* Enable the start of epoch/operating
                                           interval (on standby arbiter) */
    bcmFabricIngressLevel1NumSchedulers, /* Number of ingress schedulers on level
                                           1 */
    bcmFabricIngressLevel2NumSchedulers, /* Number of ingress schedulers on level
                                           2 */
    bcmFabricIngressLevel3NumSchedulers, /* Number of ingress schedulers on level
                                           3 */
    bcmFabricIngressLevel4NumSchedulers, /* Number of ingress schedulers on level
                                           4 */
    bcmFabricIngressLevel5NumSchedulers, /* Number of ingress schedulers on level
                                           5 */
    bcmFabricIngressLevel6NumSchedulers, /* Number of ingress schedulers on level
                                           6 */
    bcmFabricIngressLevel7NumSchedulers, /* Number of ingress schedulers on level
                                           7 */
    bcmFabricIngressLevel1SchedulerUpdateCycles, /* Ingress scheduler update cycles on
                                           level 1 */
    bcmFabricIngressLevel2SchedulerUpdateCycles, /* Ingress scheduler update cycles on
                                           level 2 */
    bcmFabricIngressLevel3SchedulerUpdateCycles, /* Ingress scheduler update cycles on
                                           level 3 */
    bcmFabricIngressLevel4SchedulerUpdateCycles, /* Ingress scheduler update cycles on
                                           level 4 */
    bcmFabricIngressLevel5SchedulerUpdateCycles, /* Ingress scheduler update cycles on
                                           level 5 */
    bcmFabricIngressLevel6SchedulerUpdateCycles, /* Ingress scheduler update cycles on
                                           level 6 */
    bcmFabricIngressLevel7SchedulerUpdateCycles, /* Ingress scheduler update cycles on
                                           level 7 */
    bcmFabricIsolate,                   /* ArgValue: 1: Isolate the fabric
                                           element from the system 0: Undo the
                                           Isolation action */
    bcmFabricRCIControlSource,          /* In Dual switch mode on links that
                                           emit 128B cells, it determines the
                                           sources for RCI bits. Whether from
                                           the Primary queue, from the Secondary
                                           queue, the OR of both, or none */
    bcmFabricGCIControlSource,          /* In Dual switch mode on links that
                                           emit 128B cells, it determines the
                                           source for GCI bits. Whether from the
                                           Primary queue, from the Secondary
                                           queue, the MAX of both, or none */
    bcmFabricControlECNEnable,          /* Enable the support of ECN */
    bcmFabricOcbMulticastId1Min,        /* define the 1st Multicast range
                                           minimum. If the Multicast Packet is
                                           in this range, the start-of-packet is
                                           offloaded to the OCB (On-Chip Buffer) */
    bcmFabricOcbMulticastId1Max,        /* define the 1st Multicast range
                                           maximum */
    bcmFabricOcbMulticastId2Min,        /* define the 2nd Multicast range
                                           minimum. */
    bcmFabricOcbMulticastId2Max,        /* define the 2nd Multicast range
                                           maximum */
    bcmFabricShutdown,                  /* performs graceful shutdown of the
                                           device */
    bcmFabricRCIIncrementValue,         /* The value that will be added to RCI
                                           bucket whenever a cell carrying RCI
                                           indication arrives */
    bcmFabricGciLeakyBucketEnable,      /* Enable/Disable GCI leaky bucket
                                           mechanism */
    bcmFabricGciBackoffEnable,          /* Enable/Disable GCI random backoff
                                           mechanism */
    bcmFabricMinimalLinksToDestination, /* Define minimum number of links to
                                           destination */
    bcmFabricControlCellsEnable         /* Enable/Disable fabric control cells */
} bcm_fabric_control_t;

/* bcm_fabric_mode_t */
typedef enum bcm_fabric_mode_e {
    bcmFabricModeTME,                   /* QE Standalone/TME */
    bcmFabricModeFabric,                /* QE Uses external fabric device */
    bcmFabricModeArbiterCrossbar,       /* BM configured as both and arbiter and
                                           a crossbar */
    bcmFabricModeCrossbar,              /* BM configured as a crossbar without
                                           arbiter functionality */
    bcmFabricModeArbiterCapableCrossbar /* BM configured as xbar without arbiter
                                           functionality, but capable of to
                                           switching arbiter */
} bcm_fabric_mode_t;

/* bcm_fabric_connection_mode_t */
typedef enum bcm_fabric_connection_mode_e {
    bcmFabricXbarConnectionModeA = 1,   /* Plane A */
    bcmFabricXbarConnectionModeB = 2,   /* Plane B */
    bcmFabricXbarConnectionModeC = 3    /* Worst Case Plane A/Plane B */
} bcm_fabric_connection_mode_t;

/* BCM_FABRIC_XBAR_ABILITY_ flags */
#define BCM_FABRIC_XBAR_ABILITY_PROTOCOL_A  1          /* Plane A */
#define BCM_FABRIC_XBAR_ABILITY_PROTOCOL_B  2          /* Plane B */
#define BCM_FABRIC_XBAR_ABILITY_PROTOCOL_C  3          /* Worst Case Plane
                                                          A/Plane B */

/* bcm_fabric_redundancy_mode_t */
typedef enum bcm_fabric_redundancy_mode_e {
    bcmFabricRedManual,     /* Manual Mode */
    bcmFabricRed1Plus1Both, /* 1+1 Control Plane and 1+1 Data Plane */
    bcmFabricRed1Plus1LS,   /* 1+1 Control Plane and Load Sharing Data Plane */
    bcmFabricRed1Plus1ELS,  /* 1+1 Control Planeand Enhanced Load Sharing Data
                               Plane */
    bcmFabricRedLS,         /* Load Sharing Data Plane */
    bcmFabricRedELS         /* Enhanced Load Sharing Data Plane */
} bcm_fabric_redundancy_mode_t;

/* fabric_traffic_management_cos_mode_t */
typedef enum bcm_fabric_traffic_management_cos_mode_e {
    bcmFabricTrafficManagementCosModeSimple, /* Simple Mode. Hierarchy setup by SDK */
    bcmFabricTrafficManagementCosModeFlexible, /* Flexible Mode. Hierarchy setup by
                                           application */
    bcmFabricTrafficManagementCosModeHybrid /* Hybrid Mode. Hierarchy setup by SDK
                                           and application can add to it */
} bcm_fabric_traffic_management_cos_mode_t;

/* vsq catagory modes */
typedef enum bcm_fabric_vsq_category_mode_e {
    bcmFabricVsqCatagoryModeNone,   /* None. By default, all queues are assigned
                                       to category 2 */
    bcmFabricVsqCatagoryMode1,      /* Category 0:  Spatial Multicast Queues,
                                       Category 1:  Ingress Shaping Queues,
                                       Category 2:  VoQ destination based
                                       queues, Category 3:  Egress TM queues */
    bcmFabricVsqCatagoryMode2       /* Category 2: Unicast Queues, Category 0:
                                       all other queues */
} bcm_fabric_vsq_category_mode_t;

/* Information passed back during callback of redundancy state change */
typedef struct bcm_fabric_control_redundancy_info_s {
    int active_arbiter_id;  /* Active Arbiter Identifier. */
    uint64 xbars;           /* xbar links that are being used. */
} bcm_fabric_control_redundancy_info_t;

/* BCM_FABRIC_DISTRIBUTION_* flags. */
#define BCM_FABRIC_DISTRIBUTION_WITH_ID 0x00000001 /* flag to create
                                                      distributionId that is
                                                      passed */

/* Reference bcm_fabric_control_t, bcmFabricMcGroupSourceKnockout type. */
#define BCM_FABRIC_MC_GROUP_SOURCE_KNOCKOUT_ENABLE 0x40000000 /* Indicates if source
                                                          knockout is enabled on
                                                          a multicast group */
#define BCM_FABRIC_MC_GROUP_MASK            0x3FFFFFFF /* multicast group mask */

/* 
 * Allows more specific control in bcm_fabric_packet_adjust_get/set. 
 * With neither flag, get will fetch the ingress (or egress if the chip
 * does not support ingress) value, and set will set both values (of
 * whichever the chip supports if it supports only one).  ORing the
 * INGRESS flag with the selector ID will cause ingress to be set or
 * read.  ORing the EGRESS flag with the selector will cause egress to be
 * set or read.  ORing both INGRESS and EGRESS flags with the selector ID
 * will specifically set both, but is not valid for get.  The GLOBAL flag
 * indicates that the global adjust value (can be combined with ingress
 * and egress as appropriate to the device) is to be accessed, rather
 * than one of the indexed adjust values.
 */
#define BCM_FABRIC_PACKET_ADJUST_INGRESS    0x40000000 
#define BCM_FABRIC_PACKET_ADJUST_EGRESS     0x20000000 
#define BCM_FABRIC_PACKET_ADJUST_GLOBAL     0x10000000 
#define BCM_FABRIC_PACKET_ADJUST_SELECTOR_MASK 0x0FFFFFFF 

/* bcm_fabric_control_redundancy_handler_t */
typedef void (*bcm_fabric_control_redundancy_handler_t)(
    int unit, 
    bcm_fabric_control_redundancy_info_t *redundancy_info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Initialize the BCM Fabric subsystem. */
extern int bcm_fabric_init(
    int unit);

/* defines connection setup between two nodes. */
extern int bcm_fabric_crossbar_connection_set(
    int unit, 
    int xbar, 
    int src_modid, 
    bcm_port_t src_xbport, 
    int dst_modid, 
    bcm_port_t dst_xbport);

/* retreives connection setup between two nodes. */
extern int bcm_fabric_crossbar_connection_get(
    int unit, 
    int xbar, 
    int src_modid, 
    bcm_port_t src_xbport, 
    int dst_modid, 
    bcm_port_t *dst_xbport);

/* Retrieves the number of active crossbars between two modules */
extern int bcm_fabric_crossbar_connection_status_get(
    int unit, 
    int src_modid, 
    int dst_modid, 
    bcm_fabric_connection_mode_t mode, 
    uint64 *xbars);

/* Retrieve fabric operating interval - epoch time */
extern int bcm_fabric_operating_interval_get(
    int unit, 
    int link_fail_count, 
    int *operating_interval);

/* Retrieves the number of timeslots in an epoch */
extern int bcm_fabric_connection_max_get(
    int unit, 
    int link_fail_count, 
    int *connection);

/* Gets fabric connection interval - timeslot size */
extern int bcm_fabric_connection_interval_get(
    int unit, 
    int link_fail_count, 
    int *connection_interval);

/* retrieve bytes per connection - bytes sent in a timeslot */
extern int bcm_fabric_connection_bytes_get(
    int unit, 
    int src_modid, 
    int dst_modid, 
    bcm_fabric_connection_mode_t mode, 
    int link_fail_count, 
    int *max_bytes);

/* Enable/disable TDM calendar */
extern int bcm_fabric_tdm_enable_set(
    int unit, 
    int enable);

/* Get enable/disable status of TDM calendar. */
extern int bcm_fabric_tdm_enable_get(
    int unit, 
    int *enable);

/* Get maximum TDM calendar size that is supported by the device. */
extern int bcm_fabric_calendar_max_get(
    int unit, 
    int *max_size);

/* Configure TDM calendar size */
extern int bcm_fabric_calendar_size_set(
    int unit, 
    int config_size);

/* Retrieve TDM calendar size */
extern int bcm_fabric_calendar_size_get(
    int unit, 
    int *config_size);

/* Set single calendar entry */
extern int bcm_fabric_calendar_set(
    int unit, 
    int cindex, 
    int connection, 
    bcm_gport_t dest_port, 
    bcm_cos_queue_t dest_cosq);

/* Get single calendar entry */
extern int bcm_fabric_calendar_get(
    int unit, 
    int cindex, 
    int *connection, 
    bcm_gport_t *dest_port, 
    bcm_cos_queue_t *dest_cosq);

/* Set multiple calendar entries */
extern int bcm_fabric_calendar_multi_set(
    int unit, 
    int array_size, 
    int *connection_array, 
    bcm_gport_t *dest_port_array, 
    bcm_cos_queue_t *dest_cosq_array);

/* Get multiple calendar entries */
extern int bcm_fabric_calendar_multi_get(
    int unit, 
    int array_size, 
    int *connection_array, 
    bcm_gport_t *dest_port_array, 
    bcm_cos_queue_t *dest_cosq_array);

/* Arm TDM calendar */
extern int bcm_fabric_calendar_active(
    int unit);

/* defines SFI link remap. */
extern int bcm_fabric_crossbar_mapping_set(
    int unit, 
    int modid, 
    int switch_fabric_arbiter_id, 
    int xbar, 
    bcm_port_t port);

/* retreive SFI link remap. */
extern int bcm_fabric_crossbar_mapping_get(
    int unit, 
    int modid, 
    int switch_fabric_arbiter_id, 
    int xbar, 
    bcm_port_t *port);

/* configure Link enable. */
extern int bcm_fabric_crossbar_enable_set(
    int unit, 
    uint64 xbars);

/* retreive Link enable. */
extern int bcm_fabric_crossbar_enable_get(
    int unit, 
    uint64 *xbars);

/* retreive runtime Link enable configuration. */
extern int bcm_fabric_crossbar_status_get(
    int unit, 
    uint64 *xbars);

/* set packet length adjustment. */
extern int bcm_fabric_packet_adjust_set(
    int unit, 
    int pkt_adjust_selector, 
    int pkt_adjust_len);

/* retreive packet length adjustment. */
extern int bcm_fabric_packet_adjust_get(
    int unit, 
    int pkt_adjust_selector, 
    int *pkt_adjust_len);

/* set failover/APS configuration. */
extern int bcm_fabric_port_failover_set(
    int unit, 
    bcm_gport_t port, 
    bcm_failover_t failover_id, 
    bcm_gport_t failover_port);

/* retreive failover/APS configuration. */
extern int bcm_fabric_port_failover_get(
    int unit, 
    bcm_gport_t port, 
    bcm_failover_t *failover_id, 
    bcm_gport_t *failover_port);

/* set fabric control attributes. */
extern int bcm_fabric_control_set(
    int unit, 
    bcm_fabric_control_t type, 
    int arg);

/* get fabric control attributes. */
extern int bcm_fabric_control_get(
    int unit, 
    bcm_fabric_control_t type, 
    int *arg);

/* Register user callback for redundancy state changes. */
extern int bcm_fabric_control_redundancy_register(
    int unit, 
    bcm_fabric_control_redundancy_handler_t f);

/* Unregister user callback for redundancy state changes. */
extern int bcm_fabric_control_redundancy_unregister(
    int unit, 
    bcm_fabric_control_redundancy_handler_t f);

/* Create Distribution Group. Reference BCM_FABRIC_DISTRIBUTION_* flags. */
extern int bcm_fabric_distribution_create(
    int unit, 
    uint32 flags, 
    bcm_fabric_distribution_t *ds_id);

/* Destroy Distribution Group. */
extern int bcm_fabric_distribution_destroy(
    int unit, 
    bcm_fabric_distribution_t ds_id);

/* Configure Distribution Group. */
extern int bcm_fabric_distribution_set(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    int modid_count, 
    int *dist_modids);

/* Retreive Distribution Group. */
extern int bcm_fabric_distribution_get(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    int max_count, 
    int *dist_modids, 
    int *count);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_FABRIC_DISTRIBUTION_SCHED_ALL   0x00000000 
#define BCM_FABRIC_DISTRIBUTION_SCHED_ANY   0x00000001 

/* Multicast Fabric distribution feature control. */
typedef enum bcm_fabric_distribution_control_e {
    bcmFabricDistributionSched  /* Multicast fabric forwarding - all nodes must
                                   be available or any. */
} bcm_fabric_distribution_control_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Configure Distribution Group fabric forwarding settings. */
extern int bcm_fabric_distribution_control_set(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    bcm_fabric_distribution_control_t type, 
    int value);

/* Get Distribution Group fabric forwarding settings. */
extern int bcm_fabric_distribution_control_get(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    bcm_fabric_distribution_control_t type, 
    int *value);

/* 
 * Sets the number of port status messages that will be present in
 * congestion message (e.g. E2ECC).
 */
extern int bcm_fabric_congestion_size_set(
    int unit, 
    bcm_module_t module_id, 
    int max_ports);

/* 
 * Gets the number of port status messages that will be present in
 * congestion message (e.g. E2ECC).
 */
extern int bcm_fabric_congestion_size_get(
    int unit, 
    bcm_module_t module_id, 
    int *max_ports);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Specifies the bit position and length of a field in packets */
typedef struct bcm_fabric_action_field_s {
    uint16 offset;  /* Bit offset of field in a packet */
    uint16 length;  /* Bit length of field in a packet */
} bcm_fabric_action_field_t;

/* Specifies where the predicate obtains its information for comparison */
typedef enum bcm_fabric_predicate_type_e {
    bcmFabricPredicateTypePacket,       /* Predicate is based upon packet
                                           contents (field indicates which bits) */
    bcmFabricPredicateTypeInterface,    /* Predicate is based upon 'interface'
                                           metadatum (field is ignored) */
    bcmFabricPredicateTypeSysport,      /* Predicate is based upon 'sysport'
                                           metadatum (field is ignored) */
    bcmFabricPredicateTypeChannel,      /* Predicate is based upon 'channel'
                                           metadatum (field is ignored) */
    bcmFabricPredicateTypeFifo,         /* Predicate is based upon 'fifo'
                                           metadatum (field is ignored) */
    bcmFabricPredicateTypeSubport,      /* Predicate is based upon 'subport'
                                           metadatum (field is ignored) */
    bcmFabricPredicateTypePacketClass,  /* Predicate is based upon 'packet
                                           class' metadatum (field is ignored) */
    bcmFabricPredicateTypeFlags         /* Predicate is based upon 'packet
                                           flags' metadata (field is ignored) */
} bcm_fabric_predicate_type_t;

#define BCM_FABRIC_PREDICATE_INFO_INGRESS   0x00000001 /* Predicate will be used
                                                          for ingress path
                                                          packets */
#define BCM_FABRIC_PREDICATE_INFO_EGRESS    0x00000002 /* Predicate will be used
                                                          for egress path
                                                          packets */
#define BCM_FABRIC_PREDICATE_INFO_WITH_ID   0x00000004 /* Predicate needs to be
                                                          created/replaced with
                                                          a specific ID */
#define BCM_FABRIC_PREDICATE_INFO_REPLACE   0x00000008 /* Predicate needs to be
                                                          replaced instead of
                                                          created */
#define BCM_FABRIC_PREDICATE_INFO_RANGE     0x00000010 /* Predicate comparison
                                                          is range instead of
                                                          equality-under-mask */

typedef struct bcm_fabric_predicate_info_s {
    uint32 flags;                       /* Flags controlling the creation and
                                           the operation of the parser */
    bcm_fabric_predicate_type_t source; /* Indicates from where the predicate
                                           will draw its comparison data */
    bcm_fabric_action_field_t field;    /* Indicates the bit field location in
                                           packets for packet type predicates;
                                           is ignored for metadata type
                                           predicates */
    uint32 data;                        /* Compare data for equality-under-mask
                                           comparisons (ignored for range) */
    uint32 mask;                        /* Masking value used for
                                           equality-under-mask comparisons
                                           (ignored for range) */
    uint32 range_low;                   /* Lowest included value for range
                                           comparisons (ignored for non-range) */
    uint32 range_high;                  /* Highest included value for range
                                           comparisons (ignored for non-range) */
} bcm_fabric_predicate_info_t;

/* Fabric predicate ID */
typedef int bcm_fabric_predicate_t;

/* Callback used by bcm_fabric_predicate_traverse */
typedef int (*bcm_fabric_predicate_traverse_cb)(
    int unit, 
    bcm_fabric_predicate_t pred_id, 
    bcm_fabric_predicate_info_t *pred_info, 
    void *user_data);

/* Initialize a fabric predicate info structure. */
extern void bcm_fabric_predicate_info_t_init(
    int unit, 
    bcm_fabric_predicate_info_t *pred_info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create or update a fabric predicate */
extern int bcm_fabric_predicate_create(
    int unit, 
    bcm_fabric_predicate_info_t *pred_info, 
    bcm_fabric_predicate_t *pred_id);

/* Destroys an existing predicate */
extern int bcm_fabric_predicate_destroy(
    int unit, 
    bcm_fabric_predicate_t pred_id);

/* Destroys all fabric predicates on the unit */
extern int bcm_fabric_predicate_destroy_all(
    int unit);

/* Retrieve the information about a specific predicate */
extern int bcm_fabric_predicate_get(
    int unit, 
    bcm_fabric_predicate_t pred_id, 
    bcm_fabric_predicate_info_t *pred_info);

/* 
 * Traverse the existing predicates, and invoke an application provided
 * callback for each one
 */
extern int bcm_fabric_predicate_traverse(
    int unit, 
    bcm_fabric_predicate_traverse_cb cb, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Indicates source for queue index. */
typedef enum bcm_fabric_action_queue_idx_from_e {
    bcmFabricActionQueueIdxFromPacket,  /* Take queue index from queue field of
                                           packet */
    bcmFabricActionQueueIdxFromReplicantId, /* Take queue index from multicast
                                           replicant ID */
    bcmFabricActionQueueIdxFromReplicantLookup /* Take queue index from result of
                                           multicast replicant lookup */
} bcm_fabric_action_queue_idx_from_t;

/* Indicates source data (and size) selection for insert action */
typedef enum bcm_fabric_action_insert_e {
    bcmFabricActionInsertRepId16,       /* Insert 16-bit replicant ID from
                                           multicast path */
    bcmFabricActionInsertRepId18,       /* Insert 18-bit replicant ID from
                                           multicast path, overwriting low two
                                           bits of prior byte */
    bcmFabricActionInsertEncapId16,     /* Insert 16-bit encapId from primary
                                           lookup (based upon replicant ID) */
    bcmFabricActionInsertEncapId18,     /* Insert 18-bit encapId from primary
                                           lookup (based upon replicant ID),
                                           overwriting low two bits of prior
                                           byte */
    bcmFabricActionInsertQueueIndex16,  /* Insert 16-bit queue index pulled from
                                           packet by action */
    bcmFabricActionInsertQueueIndex18,  /* Insert 18-bit queue index pulled from
                                           packet by action, overwriting low two
                                           bits of prior byte */
    bcmFabricActionInsertQueueId16,     /* Insert 16-bit queue ID from secondary
                                           lookup (based upon queue index pulled
                                           from packet by action) */
    bcmFabricActionInsertQueueId18      /* Insert 18-bit queue ID from secondary
                                           lookup (based upon queue index pulled
                                           from packet by action), overwriting
                                           low two bits of prior byte */
} bcm_fabric_action_insert_t;

#define BCM_FABRIC_ACTION_INFO_INGRESS      0x00000001 /* Action will be used
                                                          for ingress path
                                                          packets */
#define BCM_FABRIC_ACTION_INFO_EGRESS       0x00000002 /* Action will be used
                                                          for egress path
                                                          packets */
#define BCM_FABRIC_ACTION_INFO_WITH_ID      0x00000004 /* Action needs to be
                                                          created/replaced with
                                                          a specific ID */
#define BCM_FABRIC_ACTION_INFO_REPLACE      0x00000008 /* Action needs to be
                                                          replaced instead of
                                                          created */
#define BCM_FABRIC_ACTION_INFO_QUEUE_DEFAULT 0x00000010 /* Use global default
                                                          queue instead of
                                                          deriving one from the
                                                          packet */
#define BCM_FABRIC_ACTION_INFO_USE_TAG_OFFSET 0x00000020 /* Include HGX extension
                                                          queue tag in queue
                                                          selection process */
#define BCM_FABRIC_ACTION_INFO_OVERWRITE_DEST 0x00000040 /* Overwrite packet
                                                          destination with
                                                          selected queue */
#define BCM_FABRIC_ACTION_INFO_LENGTH_ADJUST 0x00000080 /* Use packet len_adj_idx
                                                          to select length
                                                          adjustment */
#define BCM_FABRIC_ACTION_INFO_CLEAR_TEST_BIT 0x00000100 /* Clear the 'test' bit
                                                          in the packet header */
#define BCM_FABRIC_ACTION_INFO_LOOKUP_ENCAPID 0x00000200 /* Lookup encapId from
                                                          multicast replicantId */
#define BCM_FABRIC_ACTION_INFO_CLEAR_MC_BIT 0x00000400 /* Clear the 'multicast'
                                                          bit in the packet
                                                          header */
#define BCM_FABRIC_ACTION_INFO_LEN_ADJ_ON_SHAPING 0x00000800 /* Apply length
                                                          adjustment to the data
                                                          sent to shaping */
#define BCM_FABRIC_ACTION_INFO_LOOKUP_QUEUEID 0x00001000 /* Lookup queueId from
                                                          the queue index */
#define BCM_FABRIC_ACTION_INFO_XGS_MODE     0x00002000 /* Overwrite packet
                                                          header destination
                                                          field according to the
                                                          fifo into which the
                                                          packet is placed */
#define BCM_FABRIC_ACTION_INFO_STAT0_ADJ_PER_PACKET 0x00004000 /* Adjust stat 0 per
                                                          frame */
#define BCM_FABRIC_ACTION_INFO_STAT1_ADJ_PER_PACKET 0x00008000 /* Adjust stat 1 per
                                                          frame */
#define BCM_FABRIC_ACTION_INFO_STAT_COMBINE 0x00010000 /* Combine stat 0 and 1
                                                          so stat 0 is low bits
                                                          and stat 1 is high
                                                          bits */

/* Fabric action ID */
typedef int bcm_fabric_action_t;

/* Fabric qsel ID */
typedef int bcm_fabric_qsel_t;

/* Fabric qsel_offset ID */
typedef int bcm_fabric_qsel_offset_t;

/* Fabric statistics segment ID */
typedef int bcm_fabric_stats_segment_t;

/* Specifies the bit position and length of a field in packets */
typedef struct bcm_fabric_action_info_s {
    uint32 flags;                       /* Flags controlling the creation and
                                           operation of the action */
    bcm_fabric_action_field_t queue_field_low; /* Selects bits from packet to be used
                                           for low bits of queue index */
    bcm_fabric_action_field_t queue_field_high; /* Selects bits from packet to be used
                                           for high bits of queue index */
    bcm_fabric_action_field_t qsel_offset_index_field; /* Selects bits from packet to be used
                                           for qsel_offset index */
    int override_dp;                    /* Override value for packet drop
                                           precedence; set -1 to use value from
                                           packet */
    int override_ecn;                   /* Override value for packet ECN bits;
                                           set -1 to use value from packet */
    bcm_fabric_action_field_t len_adj_index_field; /* Selects bits from packet to be used
                                           for len_adj index */
    bcm_fabric_action_queue_idx_from_t queue_id_source; /* Selects whether to draw initial queue
                                           index from packet or multicast path */
    uint32 queue_index_offset;          /* Offset to apply to queue index during
                                           lookup of queue_id */
    bcm_fabric_qsel_t qsel;             /* Specifies the qsel that is to be used
                                           for queue lookup; if this is zero,
                                           the queue lookup is not performed and
                                           qsel_offset will be chosen according
                                           to the qsel_offset field rather than
                                           read during the lookup */
    bcm_fabric_qsel_offset_t qsel_offset; /* Specifies the qsel_offset to use if
                                           qsel is zero */
    bcm_fabric_action_field_t encap_id_field; /* Which bits in the packet to overwrite
                                           with the encap_id */
    bcm_fabric_action_field_t queue_id_field; /* Which bits in the packet to overwrite
                                           with the queue_id */
    int clear_ehv_bit;                  /* Which bit to clear for extended
                                           header valid bit clear; use -1 to
                                           inhibit */
    int clear_mp_bit;                   /* Which bit to clear for header MP bit
                                           clear; use -1 to inhibit */
    int four_byte_remove_offset;        /* Specifies the bit offset of a four
                                           byte block to remove from the packet;
                                           -1 indicates no removal */
    int header_bytes_remove;            /* Specifies a number of bytes to remove
                                           from the front of the packet; 0
                                           indicates no removal */
    bcm_fabric_action_insert_t insert_dest_select; /* Specifies the source (and size) of
                                           the insertion that will be done by an
                                           interface that is configured to
                                           perform a header insertion; the
                                           configuration of each interface
                                           determines whether the insertion is
                                           actually performed for packets on
                                           that interface */
    bcm_fabric_stats_segment_t stat0_segment; /* The statistics segment used for stat0 */
    bcm_fabric_predicate_type_t stat0_field_low_type; /* Indicate source of stat0 low bits */
    bcm_fabric_action_field_t stat0_field_low; /* Which bits from the packet select the
                                           low bits of stat0 */
    bcm_fabric_predicate_type_t stat0_field_high_type; /* Indicates source of stat0 high bits */
    bcm_fabric_action_field_t stat0_field_high; /* Which bits from the packet select the
                                           high bits of stat0 */
    int stat0_adjust;                   /* Adjustment applied to value for stat0
                                           during statistics update */
    bcm_fabric_stats_segment_t stat1_segment; /* The statistics segment used for stat0 */
    bcm_fabric_predicate_type_t stat1_field_low_type; /* Indicates source of stat1 low bits */
    bcm_fabric_action_field_t stat1_field_low; /* Which bits from the packet select the
                                           low bits of stat1 */
    bcm_fabric_predicate_type_t stat1_field_high_type; /* Indicates source of stat1 high bits */
    bcm_fabric_action_field_t stat1_field_high; /* Which bits from the packet select the
                                           high bits of stat1 */
    int stat1_adjust;                   /* Adjustment applied to value for stat1
                                           during statistics update */
} bcm_fabric_action_info_t;

/* Callback used by bcm_fabric_action_traverse */
typedef int (*bcm_fabric_action_traverse_cb)(
    int unit, 
    bcm_fabric_action_t action_id, 
    bcm_fabric_action_info_t *action_info, 
    void *user_data);

extern void bcm_fabric_action_info_t_init(
    int unit, 
    bcm_fabric_action_info_t *action_info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create or update a fabric action */
extern int bcm_fabric_action_create(
    int unit, 
    bcm_fabric_action_info_t *action_info, 
    bcm_fabric_action_t *action_id);

/* Destroy a fabric action */
extern int bcm_fabric_action_destroy(
    int unit, 
    bcm_fabric_action_t action_id);

/* Destroy all fabric actions on the unit */
extern int bcm_fabric_action_destroy_all(
    int unit);

/* Get information about a fabric action */
extern int bcm_fabric_action_get(
    int unit, 
    bcm_fabric_action_t action_id, 
    bcm_fabric_action_info_t *action_info);

/* 
 * Traverse the existing actions, and invoke an application provided
 * callback for each one
 */
extern int bcm_fabric_action_traverse(
    int unit, 
    bcm_fabric_action_traverse_cb cb, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_FABRIC_PREDICATE_ACTION_INFO_INGRESS 0x00000001 /* Predicate will be used
                                                          for ingress path
                                                          packets */
#define BCM_FABRIC_PREDICATE_ACTION_INFO_EGRESS 0x00000002 /* Predicate will be used
                                                          for egress path
                                                          packets */
#define BCM_FABRIC_PREDICATE_ACTION_INFO_WITH_ID 0x00000004 /* Predicate needs to be
                                                          created/replaced with
                                                          a specific ID */
#define BCM_FABRIC_PREDICATE_ACTION_INFO_REPLACE 0x00000008 /* Predicate needs to be
                                                          replaced instead of
                                                          created */

#define BCM_FABRIC_PREDICATE_COUNT  32         /* Maximum number of supported
                                                  fabric predicates */

/* 
 * Used to specify mask and data for predicates when connecting them to
 * actions
 */
typedef SHR_BITDCL bcm_fabric_predicate_vector_t[_SHR_BITDCLSIZE(BCM_FABRIC_PREDICATE_COUNT)];

#define BCM_FABRIC_PREDICATE_VECTOR_GET(_vec, _n)  SHR_BITGET((_vec), (_n)) 
#define BCM_FABRIC_PREDICATE_VECTOR_SET(_vec, _n)  SHR_BITSET((_vec), (_n)) 
#define BCM_FABRIC_PREDICATE_VECTOR_CLR(_vec, _n)  SHR_BITCLR((_vec), (_n)) 

/* Fabric predicate action ID */
typedef int bcm_fabric_predicate_action_t;

typedef struct bcm_fabric_predicate_action_info_s {
    uint32 flags;                       /* Flags indicating how this
                                           predicate_action is to be
                                           created/replaced */
    int priority;                       /* The priority for this
                                           predicate_action */
    bcm_fabric_predicate_vector_t data; /* The value of the predicate vector for
                                           this predicate_action */
    bcm_fabric_predicate_vector_t mask; /* Indicates which predicates are
                                           significant in the data field */
    bcm_fabric_action_t action_id;      /* Specifies the action to be taken when
                                           the specified predicate condition is
                                           met */
} bcm_fabric_predicate_action_info_t;

/* Callback used by bcm_fabric_predicate_action_traverse */
typedef int (*bcm_fabric_predicate_action_traverse_cb)(
    int unit, 
    bcm_fabric_predicate_action_t predicate_action_id, 
    bcm_fabric_predicate_action_info_t *predicate_action_info, 
    void *user_data);

extern void bcm_fabric_predicate_action_info_t_init(
    int unit, 
    bcm_fabric_predicate_action_info_t *predicate_action_info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create or update a fabric action */
extern int bcm_fabric_predicate_action_create(
    int unit, 
    bcm_fabric_predicate_action_info_t *predicate_action, 
    bcm_fabric_predicate_action_t *predicate_action_id);

/* Read a fabric predicate action */
extern int bcm_fabric_predicate_action_get(
    int unit, 
    bcm_fabric_predicate_action_t predicate_action_id, 
    bcm_fabric_predicate_action_info_t *predicate_action_info);

/* Destroy a fabric predicate action */
extern int bcm_fabric_predicate_action_destroy(
    int unit, 
    bcm_fabric_predicate_action_t predicate_action_id);

/* Destroy all fabric predicate actions on the unit */
extern int bcm_fabric_predicate_action_destroy_all(
    int unit);

/* 
 * Traverse existing fabric predicate actions, calling the provided
 * callback one time per existing fabric predicate action
 */
extern int bcm_fabric_predicate_action_traverse(
    int unit, 
    bcm_fabric_predicate_action_traverse_cb cb, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_FABRIC_QSEL_INGRESS 0x00000001 /* qsel will be used for ingress path
                                              packets */
#define BCM_FABRIC_QSEL_EGRESS  0x00000002 /* qsel will be used for egress path
                                              packets */
#define BCM_FABRIC_QSEL_WITH_ID 0x00000004 /* qsel needs to be created/replaced
                                              with a specific ID */
#define BCM_FABRIC_QSEL_REPLACE 0x00000008 /* qsel needs to be replaced instead
                                              of created */

/* Callback used by bcm_fabric_qsel_traverse */
typedef int (*bcm_fabric_qsel_traverse_cb)(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    uint32 flags, 
    int base, 
    int count, 
    void *user_data);

/* Callback used by bcm_fabric_qsel_entry_traverse */
typedef int (*bcm_fabric_qsel_entry_traverse_cb)(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    bcm_gport_t queue, 
    bcm_fabric_qsel_offset_t qsel_offset, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* This creates or updates a qsel */
extern int bcm_fabric_qsel_create(
    int unit, 
    uint32 flags, 
    int base, 
    int count, 
    bcm_fabric_qsel_t *qsel_id);

/* This destroys a qsel */
extern int bcm_fabric_qsel_destroy(
    int unit, 
    bcm_fabric_qsel_t qsel_id);

/* Destroys all qsel on the unit */
extern int bcm_fabric_qsel_destroy_all(
    int unit);

/* This gets information about a qsel */
extern int bcm_fabric_qsel_get(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    uint32 *flags, 
    int *base, 
    int *count);

/* 
 * Traverse existing fabric qsels, calling the provided callback one time
 * per existing qsel
 */
extern int bcm_fabric_qsel_traverse(
    int unit, 
    bcm_fabric_qsel_traverse_cb cb, 
    void *user_data);

/* 
 * Sets an entry within a qsel.  To effectively clear an entry, provide
 * BCM_GPORT_INVALID as the queue.
 */
extern int bcm_fabric_qsel_entry_set(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    bcm_gport_t queue, 
    bcm_fabric_qsel_offset_t qsel_offset_id);

/* 
 * Gets an entry within a qsel.  Entries which are not in use will return
 * BCM_GPORT_INVALID as their queue.
 */
extern int bcm_fabric_qsel_entry_get(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    bcm_gport_t *queue, 
    bcm_fabric_qsel_offset_t *qsel_offset_id);

/* 
 * Sets a group of entries within a qsel.  To effectively clear entries,
 * set their respective queues to BCM_GPORT_INVALID.
 */
extern int bcm_fabric_qsel_entry_multi_set(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    int count, 
    bcm_gport_t *queue, 
    bcm_fabric_qsel_offset_t *qsel_offset_id);

/* 
 * Gets a group of entries within a qsel.  Entries that are not in use
 * will have BCM_GPORT_INVALID as their queue.
 */
extern int bcm_fabric_qsel_entry_multi_get(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    int count, 
    bcm_gport_t *queue, 
    bcm_fabric_qsel_offset_t *qsel_offset_id);

/* 
 * Traverse existing entries within a specified qsel, calling the
 * provided callback one time per existing entry
 */
extern int bcm_fabric_qsel_entry_traverse(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    bcm_fabric_qsel_entry_traverse_cb cb, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_FABRIC_QSEL_OFFSET_INGRESS  0x00000001 /* qsel will be used for
                                                      ingress path packets */
#define BCM_FABRIC_QSEL_OFFSET_EGRESS   0x00000002 /* qsel will be used for
                                                      egress path packets */
#define BCM_FABRIC_QSEL_OFFSET_WITH_ID  0x00000004 /* qsel needs to be
                                                      created/replaced with a
                                                      specific ID */
#define BCM_FABRIC_QSEL_OFFSET_REPLACE  0x00000008 /* qsel needs to be replaced
                                                      instead of created */

/* Callback used by bcm_fabric_qsel_offset_traverse */
typedef int (*bcm_fabric_qsel_offset_traverse_cb)(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    uint32 flags, 
    void *user_data);

/* Callback used by bcm_fabric_qsel_offset_entry_traverse */
typedef int (*bcm_fabric_qsel_offset_entry_traverse_cb)(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    bcm_cos_t int_pri, 
    int offset, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* This creates or updates a qsel_offset */
extern int bcm_fabric_qsel_offset_create(
    int unit, 
    uint32 flags, 
    bcm_fabric_qsel_offset_t *qsel_offset_id);

/* This destroys a qsel_offset */
extern int bcm_fabric_qsel_offset_destroy(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id);

/* Destroys all qsel_offset on the unit */
extern int bcm_fabric_qsel_offset_destroy_all(
    int unit);

/* 
 * Traverse existing qsel_offsets, calling the provided callback one time
 * per existing qsel_offset
 */
extern int bcm_fabric_qsel_offset_traverse(
    int unit, 
    bcm_fabric_qsel_offset_traverse_cb cb, 
    void *user_data);

/* Set an entry of a qsel_offset */
extern int bcm_fabric_qsel_offset_entry_set(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    bcm_cos_t int_pri, 
    int offset);

/* Get an entry of a qsel_offset */
extern int bcm_fabric_qsel_offset_entry_get(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    bcm_cos_t int_pri, 
    int *offset);

/* 
 * Traverse entries in a qsel_offset, calling the provided callback one
 * time per existing entry
 */
extern int bcm_fabric_qsel_offset_entry_traverse(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    bcm_fabric_qsel_offset_entry_traverse_cb cb, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_GROUP_MODID_BIT             \
(1<<31)  /* Group indicator bit */
#define BCM_LOCAL_MODID_BIT             \
(1<<30)  /* Local modid indicator bit */
#define BCM_FABRIC_GROUP_MODID_SET(id)  \
id = id | BCM_GROUP_MODID_BIT; /* The macro will internally
                                                      add group_base to define a
                                                      separate number space
                                                      representing a FAPs group */
#define BCM_FABRIC_LOCAL_MODID_SET(id)  \
        id = id | BCM_LOCAL_MODID_BIT;   /* The macro will internally
                                                      add local_base to define a
                                                      separate number space
                                                      representing a local index
                                                      of a single Module */
#define BCM_FABRIC_MODID_IS_GROUP(modid)  \
        (modid & BCM_GROUP_MODID_BIT ? 1 : 0)  /* True if the modid
                                                      represents a FAPs group */
#define BCM_FABRIC_MODID_IS_LOCAL(modid)  \
        (modid & BCM_LOCAL_MODID_BIT ? 1 : 0)  /* True if the modid
                                                      represents a Module local
                                                      index */
#define BCM_FABRIC_MODID_IS_MODULE(modid)  \
        !BCM_FABRIC_MODID_IS_GROUP(modid) && !BCM_FABRIC_MODID_IS_LOCAL(modid) /* True if the modid
                                                      represents a Module index */
#define BCM_FABRIC_GROUP_MODID_UNSET(id)  \
id & ~BCM_GROUP_MODID_BIT /* Clear group indicator */
#define BCM_FABRIC_LOCAL_MODID_UNSET(id)  \
id & ~BCM_LOCAL_MODID_BIT   /* Clear local modid
                                                      indicator */

#ifndef BCM_HIDE_DISPATCHABLE

/* Set of Modules belong to a group */
extern int bcm_fabric_modid_group_set(
    int unit, 
    bcm_module_t group, 
    int modid_count, 
    bcm_module_t *modid_array);

/* Get of Modules belong to a group */
extern int bcm_fabric_modid_group_get(
    int unit, 
    bcm_module_t group, 
    int modid_max_count, 
    bcm_module_t *modid_array, 
    int *modid_count);

/* Find the relevant group for a given module id */
extern int bcm_fabric_modid_group_find(
    int unit, 
    bcm_module_t modid, 
    bcm_module_t *group);

/* Mapping a Module ID to local space */
extern int bcm_fabric_modid_local_mapping_set(
    int unit, 
    bcm_module_t local_modid, 
    bcm_module_t modid);

/* Get the mapping a Module ID to local space */
extern int bcm_fabric_modid_local_mapping_get(
    int unit, 
    bcm_module_t local_modid, 
    bcm_module_t *modid);

/* Update links topology, set all the links connected to a destination */
extern int bcm_fabric_link_topology_set(
    int unit, 
    bcm_module_t destination, 
    int links_count, 
    bcm_port_t *links_array);

/* Get links topology. */
extern int bcm_fabric_link_topology_get(
    int unit, 
    bcm_module_t destination, 
    int max_links_count, 
    int *links_count, 
    bcm_port_t *links_array);

/* Set the replications of the multicast group in the fabric element */
extern int bcm_fabric_multicast_set(
    int unit, 
    bcm_multicast_t group, 
    uint32 flags, 
    uint32 destid_count, 
    bcm_module_t *destid_array);

/* Get the replications of the multicast group in the fabric element */
extern int bcm_fabric_multicast_get(
    int unit, 
    bcm_multicast_t group, 
    uint32 flags, 
    int destid_count_max, 
    int *destid_count, 
    bcm_module_t *destid_array);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_FABRIC_MAX_MULTICAST_MODULES    (128)      /* Max number of mosules
                                                          in
                                                          BCM_FABRIC_MODULE_VEC_GET */

typedef SHR_BITDCL bcm_fabric_module_vector_t[_SHR_BITDCLSIZE(BCM_FABRIC_MAX_MULTICAST_MODULES)];

#define BCM_FABRIC_MODULE_VEC_GET(vec, modid)  SHR_BITGET(vec, modid) 
#define BCM_FABRIC_MODULE_VEC_SET(vec, modid)  SHR_BITSET(vec, modid) 
#define BCM_FABRIC_MODULE_VEC_CLR(vec, modid)  SHR_BITCLR(vec, modid) 
#define BCM_FABRIC_MODULE_VEC_ZERO(vec)  \
    sal_memset(vec, 0, SHR_BITALLOCSIZE(BCM_FABRIC_MAX_MULTICAST_MODULES))  

/* bcm_fabric_multicast_* flags */
#define BCM_FABRIC_MULTICAST_SET_ONLY       _SHR_FABRIC_MULTICAST_SET_ONLY 
#define BCM_FABRIC_MULTICAST_COMMIT_ONLY    _SHR_FABRIC_MULTICAST_COMMIT_ONLY 
#define BCM_FABRIC_MULTICAST_STATUS_ONLY    _SHR_FABRIC_MULTICAST_STATUS_ONLY 

#ifndef BCM_HIDE_DISPATCHABLE

/* Set replications of the multicast groups in the fabric element */
extern int bcm_fabric_multicast_multi_set(
    int unit, 
    uint32 flags, 
    uint32 ngroups, 
    bcm_multicast_t *groups, 
    bcm_fabric_module_vector_t *dest_array);

/* 
 * Get a set of replications of the multicast groups in the fabric
 * element
 */
extern int bcm_fabric_multicast_multi_get(
    int unit, 
    uint32 flags, 
    uint32 ngroups, 
    bcm_multicast_t *groups, 
    bcm_fabric_module_vector_t *dest_array);

#endif /* BCM_HIDE_DISPATCHABLE */

typedef enum bcm_fabric_link_control_e {
    bcmFabricLinkCellFormat,            /* VSC256 or VSC128 */
    bcmFabricLinkCellInterleavingEnable, /* Enable controls and data cells
                                           interleaving (only if link partner is
                                           Arad/Petra-B/FE1600) */
    bcmFabricLinkPrimaryWeight,         /* Sets primary arbitrations weight for
                                           MAC-TX access, in Dual-switch mode.
                                           This mode supports two queues per
                                           link: Primary queue for Data traffic
                                           and Secondary queue for TDM traffic.
                                           The bandwidth allocation between the
                                           two types of traffic can be
                                           controlled by assigning Weights for
                                           each queue type, in the
                                           0:[NUMBER_OF_LINKS-1] range. Lower
                                           weight implies higher priority weight
                                           0 is taken as strict priority. */
    bcmFabricLinkSecondaryWeight,       /* Sets secondary arbitrations weight
                                           for MAC-TX access, in Dual-switch
                                           mode. This mode supports two queues
                                           per link: Primary queue for Data
                                           traffic and Secondary queue for TDM
                                           traffic. The bandwidth allocation
                                           between the two types of traffic can
                                           be controlled by assigning Weights
                                           for each queue type, in the
                                           0:[NUMBER_OF_LINKS-1] range. Lower
                                           weight implies higher priority weight
                                           0 is taken as strict priority. */
    bcmFabricLinkIsSecondaryOnly,       /* Sets the link to support Secondary
                                           (TDM) queue only (relevant only to
                                           VCS128 links) */
    bcmFabricLLFControlSource,          /* In Dual switch mode, on links that
                                           emit 128B cells, it determined the
                                           source for LLFC bits. Whether from
                                           the Primary queue, from the Secondary
                                           queue, the OR of both, or none */
    bcmFabricLinkRepeaterDestinationLink, /* For each input link, defines the
                                           output link that the traffic is
                                           forwarded to. Only relevant when
                                           setting the operation mode to
                                           'repeater mode'. The driver validates
                                           that the mapping is symmetric */
    bcmFabricLinkIsolate                /* 1: The link may be enabled in the
                                           SerDes level and in the MAC level,
                                           however, it's link partner will see
                                           the link as disabled, and will not
                                           use it for traffic distribution 0:
                                           Undo the isolation operation */
} bcm_fabric_link_control_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Set fabric-link attribute (fifo ype) per link. Each link might have
 * two fifo types; one per RX and one per TX
 */
extern int bcm_fabric_link_control_set(
    int unit, 
    bcm_port_t link, 
    bcm_fabric_link_control_t type, 
    int arg);

/*  Get fabric-link attribute (fifo type) per link and direction */
extern int bcm_fabric_link_control_get(
    int unit, 
    bcm_port_t link, 
    bcm_fabric_link_control_t type, 
    int *arg);

#endif /* BCM_HIDE_DISPATCHABLE */

/* fabric link threshold types */
typedef enum bcm_fabric_link_threshold_type_e {
    bcmFabricLinkRxFifoLLFC,            /* the threshold that initiates link
                                           level flow control when the receiving
                                           FIFO is overloaded */
    bcmFabricLinkFE1TxBypassLLFC,       /* Only relevant for FE1 links. When the
                                           transmitting threshold is overloaded;
                                           the receiving FIFOs of all the FE1
                                           links start generating link level
                                           flow control */
    bcmFabricLinkRciFC,                 /* The TX FIFO threshold; that initiates
                                           the Route Congestion Indication flow
                                           control */
    bcmFabricLinkTxGciLvl1FC,           /* The TX FIFO threshold that initiates
                                           the Global Congestion Indication
                                           level 1 Flow Vontrol. */
    bcmFabricLinkTxGciLvl2FC,           /* The TX FIFO threshold that initiates
                                           the Global Congestion Indication
                                           level 2 Flow Vontrol. */
    bcmFabricLinkTxGciLvl3FC,           /* The TX FIFO threshold that initiates
                                           the Global Congestion Indication
                                           level 3 Flow Vontrol. */
    bcmFabricLinkRxGciLvl1FC,           /* The RX FIFO threshold that initiates
                                           the Global Congestion Indication
                                           level 1 Flow Control. */
    bcmFabricLinkRxGciLvl2FC,           /* The RX FIFO threshold that initiates
                                           the Global Congestion Indication
                                           level 2 Flow Control. */
    bcmFabricLinkRxGciLvl3FC,           /* The RX FIFO threshold that initiates
                                           the Global Congestion Indication
                                           level 3 Flow Control. */
    bcmFabricLinkTxPrio0Drop,           /* The TX FIFO threshold; that initiate
                                           the priority 0 packet dropping. */
    bcmFabricLinkTxPrio1Drop,           /* The TX FIFO threshold; that initiate
                                           the priority 1 packet dropping. */
    bcmFabricLinkTxPrio2Drop,           /* The TX FIFO threshold; that initiate
                                           the priority 2 packet dropping. */
    bcmFabricLinkTxPrio3Drop,           /* The TX FIFO threshold; that initiate
                                           the priority 3 packet dropping. */
    bcmFabricLinkRxPrio0Drop,           /*  The RX FIFO threshold that initiate
                                           the priority 0 packet dropping. */
    bcmFabricLinkRxPrio1Drop,           /*  The RX FIFO threshold that initiate
                                           the priority 1 packet dropping. */
    bcmFabricLinkRxPrio2Drop,           /*  The RX FIFO threshold that initiate
                                           the priority 2 packet dropping. */
    bcmFabricLinkRxPrio3Drop,           /*  The RX FIFO threshold that initiate
                                           the priority 3 packet dropping. */
    bcmFabricLinkGciLeakyBucket1Congestion, /* Configure GCI leaky bucket 1
                                           congestion threshold */
    bcmFabricLinkGciLeakyBucket2Congestion, /* Configure GCI leaky bucket 2
                                           congestion threshold */
    bcmFabricLinkGciLeakyBucket3Congestion, /* Configure GCI leaky bucket 3
                                           congestion threshold */
    bcmFabricLinkGciLeakyBucket4Congestion, /* Configure GCI leaky bucket 4
                                           congestion threshold */
    bcmFabricLinkGciLeakyBucket1Full,   /* Configure GCI leaky bucket 1 full
                                           value */
    bcmFabricLinkGciLeakyBucket2Full,   /* Configure GCI leaky bucket 2 full
                                           value */
    bcmFabricLinkGciLeakyBucket3Full,   /* Configure GCI leaky bucket 3 full
                                           value */
    bcmFabricLinkGciLeakyBucket4Full    /* Configure GCI leaky bucket 4 full
                                           value */
} bcm_fabric_link_threshold_type_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Add thresholds set */
extern int bcm_fabric_link_threshold_add(
    int unit, 
    uint32 flags, 
    int *fifo_type);

/* Delete thresholds set */
extern int bcm_fabric_link_threshold_delete(
    int unit, 
    int fifo_type);

/* Set fifo_type thresholds */
extern int bcm_fabric_link_thresholds_set(
    int unit, 
    int fifo_type, 
    uint32 count, 
    bcm_fabric_link_threshold_type_t *type, 
    int *value);

/* Get fifo_type thresholds */
extern int bcm_fabric_link_thresholds_get(
    int unit, 
    int fifo_type, 
    uint32 count, 
    bcm_fabric_link_threshold_type_t *type, 
    int *value);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_FABRIC_LINK_TH_FE1_LINKS_ONLY   0x00000001 /* Only apply the
                                                          settings for the FE1
                                                          links. FE1 and FE3
                                                          links with the same
                                                          type, will have
                                                          different values */
#define BCM_FABRIC_LINK_TH_FE3_LINKS_ONLY   0x00000002 /* Only apply the
                                                          settings for the FE3
                                                          links. FE1 and FE3
                                                          links with the same
                                                          type, will have
                                                          different values */
#define BCM_FABRIC_LINK_TH_PRIM_ONLY        0x00000004 /* Only apply the
                                                          settings to the
                                                          Primary switching
                                                          context */
#define BCM_FABRIC_LINK_TH_SCND_ONLY        0x00000008 /* Only apply the
                                                          settings to the
                                                          Secondary switching
                                                          context */
#define BCM_FABRIC_LINK_THRESHOLD_WITH_ID   0x00000010 
#define BCM_FABRIC_LINK_THRESHOLD_RX_FIFO_ONLY 0x00000020 /* Only apply the
                                                          settings to the RX
                                                          links */
#define BCM_FABRIC_LINK_THRESHOLD_TX_FIFO_ONLY 0x00000040 /* Only apply the
                                                          settings to the TX
                                                          links */

#define BCM_FABRIC_LINK_STATUS_CRC_ERROR    _SHR_FABRIC_LINK_STATUS_CRC_ERROR /* Non-zero CRC rate */
#define BCM_FABRIC_LINK_STATUS_SIZE_ERROR   _SHR_FABRIC_LINK_STATUS_SIZE_ERROR /* Non-zero size
                                                          error-count */
#define BCM_FABRIC_LINK_STATUS_CODE_GROUP_ERROR _SHR_FABRIC_LINK_STATUS_CODE_GROUP_ERROR /* Non-zero code group
                                                          error-count */
#define BCM_FABRIC_LINK_STATUS_MISALIGN     _SHR_FABRIC_LINK_STATUS_MISALIGN /* Link down,
                                                          misalignment error */
#define BCM_FABRIC_LINK_STATUS_NO_SIG_LOCK  _SHR_FABRIC_LINK_STATUS_NO_SIG_LOCK /* Link down, SerDes
                                                          signal lock error */
#define BCM_FABRIC_LINK_STATUS_NO_SIG_ACCEP _SHR_FABRIC_LINK_STATUS_NO_SIG_ACCEP /* Link up, but not
                                                          accepting reachability
                                                          cells */
#define BCM_FABRIC_LINK_STATUS_ERRORED_TOKENS _SHR_FABRIC_LINK_STATUS_ERRORED_TOKENS /* Low value, indicates
                                                          bad link connectivity
                                                          or link down, based on
                                                          reachability cells */

#ifndef BCM_HIDE_DISPATCHABLE

/* Attach links to fifo_type */
extern int bcm_fabric_link_thresholds_attach(
    int unit, 
    int fifo_type, 
    uint32 links_count, 
    bcm_port_t *links);

/* Retrieve links which are attached to a fifo_type */
extern int bcm_fabric_link_thresholds_retrieve(
    int unit, 
    int fifo_type, 
    uint32 links_count_max, 
    bcm_port_t *links, 
    uint32 *links_count);

/* Get status of the link */
extern int bcm_fabric_link_status_get(
    int unit, 
    bcm_port_t link_id, 
    uint32 *link_status, 
    uint32 *errored_token_count);

#endif /* BCM_HIDE_DISPATCHABLE */

typedef enum bcm_fabric_device_type_e {
    bcmFabricDeviceTypeUnknown, /* Unknown device type */
    bcmFabricDeviceTypeFE13,    /* FE13 device type */
    bcmFabricDeviceTypeFE2,     /* FE2 device type */
    bcmFabricDeviceTypeFAP,     /* FAP device type */
    bcmFabricDeviceTypeFE1,     /* FE1 device type */
    bcmFabricDeviceTypeFE3,     /* FE3 device type */
    bcmFabricDeviceTypeFIP,     /* FIP device type */
    bcmFabricDeviceTypeFOP      /* FOP device type */
} bcm_fabric_device_type_t;

typedef struct bcm_fabric_link_connectivity_s {
    uint32 module_id;                   /* remote module ID. */
    uint32 link_id;                     /* remote link id. The ID of the link
                                           partner in the remote module.
                                           BCM_FABRIC_LINK_NO_CONNECTIVITY: The
                                           connection is invalid */
    bcm_fabric_device_type_t device_type; /* remote device type */
} bcm_fabric_link_connectivity_t;

#define BCM_FABRIC_LINK_NO_CONNECTIVITY _SHR_FABRIC_LINK_NO_CONNECTIVITY /* FABRIC_LINK_NO_CONNECTIVITY */

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Retrieves the current link-partner information of a link, for all
 * existing links up to link_partner_max
 */
extern int bcm_fabric_link_connectivity_status_get(
    int unit, 
    int link_partner_max, 
    bcm_fabric_link_connectivity_t *link_partner_array, 
    int *link_partner_count);

/* Retrieves the current link-partner information of a link */
extern int bcm_fabric_link_connectivity_status_single_get(
    int unit, 
    bcm_port_t link_id, 
    bcm_fabric_link_connectivity_t *link_partner_info);

/* Retrieves the links through which a remote module ID is reachable */
extern int bcm_fabric_reachability_status_get(
    int unit, 
    int moduleid, 
    int links_max, 
    uint32 *links_array, 
    int *links_count);

#endif /* BCM_HIDE_DISPATCHABLE */

/* bandwidth profile configuration */
typedef struct bcm_fabric_bandwidth_profile_s {
    int num_links;      /* number of links/serdes */
    int rci;            /* route congestion indication */
    uint32 max_kbps;    /* maximum bandwidth (in kbps) */
} bcm_fabric_bandwidth_profile_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Set fabric bandwidth profile. Each link has entries corresponding to
 * all the rci levels. Thus table size is the (number of links) * (rci
 * levels)
 */
extern int bcm_fabric_bandwidth_profile_set(
    int unit, 
    int profile_count, 
    bcm_fabric_bandwidth_profile_t *profile_array);

/* 
 * Retreive fabric bandwidth profile. Each link has entries corresponding
 * to all the rci levels. Thus table size is the (number of links) * (rci
 * levels)
 */
extern int bcm_fabric_bandwidth_profile_get(
    int unit, 
    int profile_count, 
    bcm_fabric_bandwidth_profile_t *profile_array);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_FABRIC_TDM_USER_FIELD_MAX_SIZE  6          /* Maximum size of user
                                                          field */

/* TDM editing flags */
#define BCM_FABRIC_TDM_EDITING_INGRESS      0x0001     /* Ingress direction */
#define BCM_FABRIC_TDM_EDITING_EGRESS       0x0002     /* Egress Direction */
#define BCM_FABRIC_TDM_EDITING_UNICAST      0x0004     /* Unicast */
#define BCM_FABRIC_TDM_EDITING_MULTICAST    0x0008     /* Multicast */
#define BCM_FABRIC_TDM_EDITING_NON_SYMMETRIC_CRC 0x0010     /* asymmetric CRC,
                                                          add/remove CRC based
                                                          on ingress/egress
                                                          flags */

/* bcm_fabric_tdm_editing_type_t */
typedef enum bcm_fabric_tdm_editing_type_e {
    bcmFabricTdmEditingAppend = 0,      /* append internal forwarding header
                                           (FTMH) to all received TDM packets.
                                           Configuration applied to ingress
                                           port. If set destination forwarding
                                           must be configured (egress port). */
    bcmFabricTdmEditingRemove = 1,      /* remove forwarding header to all the
                                           transmitted packets at this egress
                                           port. */
    bcmFabricTdmEditingNoChange = 2,    /* do not change the forwarding header.
                                           For ingress the forwarding header is
                                           not changed (forwarding header added
                                           by upstream device). For egress
                                           forwarding header not changed (i.e
                                           not changed/removed) and is passed to
                                           downstream device. */
    bcmFabricTdmEditingCustomExternal = 3 /* External custom header. In ingress
                                           direction embed external custom
                                           header in the added forwading header.
                                           Embedded fields will replace user
                                           specified fields. In the egress
                                           direction, extract  external custom
                                           overhead from user specified fields
                                           of the removed forwarding header. */
} bcm_fabric_tdm_editing_type_t;

/* tdm editing configuration */
typedef struct bcm_fabric_tdm_editing_s {
    uint32 flags;                       /* flag values. Valid for Ingress and
                                           Egress configuration */
    bcm_fabric_tdm_editing_type_t type; /* editing type. Valid for Ingress and
                                           Egress configuration */
    bcm_gport_t destination_port;       /* destination port. Valid for Ingress
                                           unicast configuration.
                                           (BCM_FABRIC_TDM_EDITING_UNICAST and
                                           TDM_EDITING_INGRESS flag has to be
                                           specified. Also reference type
                                           field). */
    bcm_multicast_t multicast_id;       /* Multicast Id. Valid for Ingress
                                           multicast configuration.
                                           (BCM_FABRIC_TDM_EDITING_MULTICAST and
                                           BCM_FABRIC_TDM_EDITING_INGRESS flag
                                           has to be specified. Also reference
                                           type field. */
    uint8 user_field[BCM_FABRIC_TDM_USER_FIELD_MAX_SIZE]; /* user field values. Valid for Ingress
                                           configuration.
                                           (BCM_FABRIC_TDM_EDITING_INGRESS flag
                                           has to be specified) */
    int user_field_count;               /* count of total number of bits. Valid
                                           for Ingress configuration
                                           (BCM_FABRIC_TDM_EDITING_INGRESS flag
                                           has to be specified) */
    int add_packet_crc;                 /* TRUE =>add CRC, FALSE => do not add
                                           CRC */
} bcm_fabric_tdm_editing_t;

/* Initialize a fabric tdm editing structure. */
extern void bcm_fabric_tdm_editing_t_init(
    bcm_fabric_tdm_editing_t *editing);

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * set port editing configuration. Configuration for ingress/Egress
 * direction. Reference flags in bcm_fabric_tdm_editing_t structure.
 */
extern int bcm_fabric_tdm_editing_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_fabric_tdm_editing_t *editing);

/* 
 * retreive port editing configuration. flags field has to be specifed.
 * Reference flags in bcm_fabric_tdm_editing_t structure.
 */
extern int bcm_fabric_tdm_editing_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_fabric_tdm_editing_t *editing);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_FABRIC_TDM_MAX_LINKS    64         /* maximum fabric links */

/* tdm editing configuration */
typedef struct bcm_fabric_tdm_direct_routing_s {
    int links_count;                    /* number of links. setting a link count
                                           of zero implies no direct routing */
    bcm_gport_t links[BCM_FABRIC_TDM_MAX_LINKS]; /* link specification */
} bcm_fabric_tdm_direct_routing_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* set port routing configuration. */
extern int bcm_fabric_tdm_direct_routing_set(
    int unit, 
    bcm_gport_t gport, 
    bcm_fabric_tdm_direct_routing_t *routing_info);

/* retreive port routing configuration. */
extern int bcm_fabric_tdm_direct_routing_get(
    int unit, 
    bcm_gport_t gport, 
    bcm_fabric_tdm_direct_routing_t *routing_info);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Discard aging flags */
#define BCM_FABRIC_CONFIG_DISCARD_AGING_ACTION_ONLY 0x0001     /* If set, only aging can
                                                          set discard aging.
                                                          Otherwise, also other
                                                          mechanizems. */

/* bcm_fabric_age_mode_t */
typedef enum bcm_fabric_age_mode_e {
    bcmFabricAgeModeReset,      /* size is reset to 0 */
    bcmFabricAgeModeDecrement   /* size is decremented by 1 */
} bcm_fabric_age_mode_t;

/* Aging configuration */
typedef struct bcm_fabric_config_discard_s {
    uint32 flags;                   /* BCM_FABRIC_CONFIG_DISCARD_XXX flags */
    int enable;                     /* Enable Aging period functionality */
    int age;                        /* Unit in millisecond. Every 'age' outgoing
                                       local port size is monitored. If it was
                                       not updated during parameter age, it is
                                       updated according to age_mode */
    bcm_fabric_age_mode_t age_mode; /* Defines the action if outgoing local port
                                       size was not updated by VoQs after
                                       aging_period */
} bcm_fabric_config_discard_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * set discard configuration. Configuration to enable, disable aging and
 * its settings
 */
extern int bcm_fabric_config_discard_set(
    int unit, 
    bcm_fabric_config_discard_t *discard);

/* get discard configuration. */
extern int bcm_fabric_config_discard_get(
    int unit, 
    bcm_fabric_config_discard_t *discard);

#endif /* BCM_HIDE_DISPATCHABLE */

/* 
 * Credit watchdog control, allowed values to:
 * bcm_fabric_control_set(unit, bcmFabricWatchdogQueueEnable, value)
 */
#define BCM_FABRIC_WATCHDOG_QUEUE_DISABLE   0          /* credit watchdog will
                                                          be disabled */
#define BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_NORMAL 1          /* credit watchdog will
                                                          be enabled in normal
                                                          mode */
#define BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_FAST_STATUS_MESSAGE 2          /* credit watchdog will
                                                          be enabled in
                                                          aggressive status
                                                          message mode */
#define BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_COMMON_STATUS_MESSAGE 3          /* credit watchdog will
                                                          be enabled in common
                                                          status message mode */
#define BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_MIN BCM_FABRIC_WATCHDOG_QUEUE_DISABLE 
#define BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_MAX BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_COMMON_STATUS_MESSAGE 

/* bcm_fabric_priority_* flags */
#define BCM_FABRIC_QUEUE_PRIORITY_HIGH_ONLY _SHR_FABRIC_QUEUE_PRIORITY_HIGH_ONLY 
#define BCM_FABRIC_QUEUE_PRIORITY_LOW_ONLY  _SHR_FABRIC_QUEUE_PRIORITY_LOW_ONLY 
#define BCM_FABRIC_PRIORITY_MULTICAST       _SHR_FABRIC_PRIORITY_MULTICAST 

#ifndef BCM_HIDE_DISPATCHABLE

/* configure fabric cell priority. */
extern int bcm_fabric_priority_set(
    int unit, 
    uint32 flags, 
    bcm_cos_t ingress_pri, 
    bcm_color_t color, 
    int fabric_priority);

/* retrieve fabric cell priority. */
extern int bcm_fabric_priority_get(
    int unit, 
    uint32 flags, 
    bcm_cos_t ingress_pri, 
    bcm_color_t color, 
    int *fabric_priority);

#endif /* BCM_HIDE_DISPATCHABLE */

#endif /* __BCM_FABRIC_H__ */
